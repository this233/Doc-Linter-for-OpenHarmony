{
  "规则ID": 7,
  "规则名称": "语言表达一致性",
  "规则描述": "待提取 - 语言表达一致性的规则描述",
  "正面示例": [
    {
      "defect_id": 2899,
      "sentence": "将数据项名称及数据项的值保存到数据库中，使用callback异步回调。",
      "reference_sentence": "将数据项名称及数据项的值保存到数据库中。使用Promise异步回调。",
      "line_num": 205,
      "context": "",
      "用户拒绝的修改": "将数据项名称及数据项的值保存到数据库中，使用Promise异步回调。",
      "注意事项": "确保异步机制术语与上下文完全一致，替换时需同时检查前后句的逻辑衔接，若存在混合用法风险应采用分句结构明确区分操作描述和实现方式。"
    },
    {
      "defect_id": 2932,
      "sentence": "使用 Promise异步回调。",
      "reference_sentence": "使用Promise异步回调。",
      "line_num": 276,
      "context": "",
      "用户拒绝的修改": "使用Promise异步回调。",
      "注意事项": "严格检查术语大小写一致性，修复时需同步验证技术名词的标准格式；保持格式统一性时，需同时检查相邻字符的空格规范，避免产生新错误。"
    },
    {
      "defect_id": 22451,
      "sentence": "API version9-11系统能力为SystemCapability.Security.CryptoFramework；从API version12开始为SystemCapability.Security.CryptoFramework.Cipher",
      "reference_sentence": "API version 12开始，该接口支持在原子化服务中使用。",
      "line_num": 55,
      "context": "",
      "用户拒绝的修改": "API version 9-11系统能力为SystemCapability.Security.CryptoFramework；从API version 12开始为SystemCapability.Security.CryptoFramework.Cipher",
      "注意事项": "修复时应确保数值范围表达格式统一（如\"9-11\"对应\"12+\"或\"9到11\"对应\"12开始\"），避免仅修改标点而忽略数值逻辑关系的一致性。"
    },
    {
      "defect_id": 103487,
      "sentence": "setEventConfig(name: string, config: Record&lt;string, ParamType&gt;): Promise&lt;void&gt;",
      "reference_sentence": "setEventConfig(name: string, config: Record&lt;string, ParamType&gt;): Promise&lt;void&gt;",
      "line_num": 322,
      "context": "",
      "用户拒绝的修改": "setEventConfig(name: string, config: Record&lt;string, ParamType12&gt;): Promise&lt;void&gt;)",
      "注意事项": "修复时必须严格校验术语一致性，避免擅自修改用户自定义类型名称（如`ParamType`）；优先核对上下文原始定义，禁止添加未经验证的后缀或变体。"
    },
    {
      "defect_id": 103485,
      "sentence": "setEventParam(params: Record&lt;string, ParamType&gt;, domain: string, name?: string): Promise&lt;void&gt;",
      "reference_sentence": "setEventParam(params: Record&lt;string, ParamType&gt;, domain: string, name?: string): Promise&lt;void&gt;",
      "line_num": 271,
      "context": "",
      "用户拒绝的修改": "setEventParam(params: Record&lt;string, ParamType12&gt;, domain: string, name?: string): Promise&lt;void&gt;)",
      "注意事项": "确保类型名称与上下文定义完全一致，修改前必须验证参数类型在代码库中的实际存在性和命名准确性，避免臆造或混淆相似术语。"
    },
    {
      "defect_id": 103501,
      "sentence": "setUserId(name: string, value: string): void",
      "reference_sentence": "## hiAppEvent.setUserId<sup>11+</sup>",
      "line_num": 478,
      "context": "",
      "用户拒绝的修改": "hiAppEvent.setUserId(name: string, value: string): void",
      "注意事项": "严格区分方法名与调用路径，避免将类/对象名前缀错误合并至方法名中；修复时需精确匹配标题中的完整方法标识符（如`hiAppEvent.setUserId`），而非仅提取后半段（`setUserId`）。\n\n（1）当文档标题包含带命名空间的方法名时，应保持方法定义与标题的完全一致性，不可省略命名空间前缀；（2）需识别代码片段中的方法调用语法（如`obj.method()`）与方法定义语法的差异，避免将调用格式错误移植到定义中。"
    },
    {
      "defect_id": 103502,
      "sentence": "获取之前通过setUserId接口设置的value值。",
      "reference_sentence": "## hiAppEvent.getUserId<sup>11+</sup>",
      "line_num": 515,
      "context": "",
      "用户拒绝的修改": "获取之前通过hiAppEvent.setUserId接口设置的value值。",
      "注意事项": "修复时必须严格检查上下文中的方法命名规范，确保方法名（如`setUserId`）与文档标题或已有参考格式（如`hiAppEvent.setUserId`）完全一致，避免擅自添加或删除命名空间前缀。"
    },
    {
      "defect_id": 103489,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3.Parameter verification failed.",
      "reference_sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types.",
      "line_num": 349,
      "context": "",
      "用户拒绝的修改": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types.",
      "注意事项": "修复时必须严格对照上下文所有相关条目，确保错误码描述与对应原因列表完全匹配，同时验证参考句子的适用范围是否覆盖当前错误场景。"
    },
    {
      "defect_id": 103488,
      "sentence": "参数值为ParamType类型，参数值长度需在1024个字符以内。",
      "reference_sentence": "参数值为ParamType12类型，参数值长度需在1024个字符以内。",
      "line_num": 335,
      "context": "",
      "用户拒绝的修改": "参数值为ParamType12类型，参数值长度需在1024个字符以内。",
      "注意事项": "严格保持术语一致性，修改时需验证上下文中的专有名词正确性；避免基于相似命名模式擅自添加/删除数字或字符，确保修改仅针对明确指出的不一致问题。"
    },
    {
      "defect_id": 103468,
      "sentence": "write(info: AppEventInfo): Promise&lt;void&gt;",
      "reference_sentence": "write(info: AppEventInfo): Promise&lt;void&gt;",
      "line_num": 196,
      "context": "",
      "用户拒绝的修改": "writewrite(info: AppEventInfo): Promise&lt;void&gt;",
      "注意事项": "修复时应严格核对原始文本中的命名和拼写，避免引入重复或冗余字符；优先参考用户提供的正确示例，确保修改后的内容与上下文保持完全一致，不添加无关变更。"
    },
    {
      "defect_id": 103523,
      "sentence": "行807: | timeOut | number | 否   | 满足触发回调的超时时长，正整数，单位为30s。默认值0，不触发回调。传入负值时，会被置为默认值。    |",
      "reference_sentence": "行807: | timeOut | number | 否   | 满足触发回调的超时时长，正整数，单位为秒。默认值0，不触发回调。传入负值时，会被置为默认值。    |",
      "line_num": 807,
      "context": "",
      "用户拒绝的修改": "| timeOut | number | 否   | 满足触发回调的超时时长，正整数，单位为秒。默认值0，不触发回调。传入负值时，会被置为默认值。    |",
      "注意事项": "调整单位描述时必须同步修正相关数值说明，确保单位与数值逻辑一致；修改前需完整核对原始数据中所有关联要素（如\"30s\"中的数值30和单位s），避免片面修改导致矛盾。"
    },
    {
      "defect_id": 103486,
      "sentence": "参数值为[ParamType](#paramtype12)类型，参数值长度需在1024个字符以内。",
      "reference_sentence": "参数值为[ParamType12](#paramtype12)类型，参数值长度需在1024个字符以内。",
      "line_num": 283,
      "context": "",
      "用户拒绝的修改": "参数值为[ParamType12](#paramtype12)类型，参数值长度需在1024个字符以内。",
      "注意事项": "修复时需严格校验术语与锚点链接的精确匹配，确保文档内相同概念始终使用统一命名，避免因锚点ID相似度造成的术语混淆。"
    },
    {
      "defect_id": 103524,
      "sentence": "行884: setRow(size: number): void",
      "reference_sentence": "行884: setRow(row: number): void",
      "line_num": 884,
      "context": "",
      "用户拒绝的修改": "setRow(row: number): void",
      "注意事项": "修复参数名不一致时必须严格核对上下文中的原始命名（如参考句子的\"row\"），避免误判正确参数名；优先确保修改后的参数名与已有调用上下文和文档中的实际使用场景完全匹配。"
    },
    {
      "defect_id": 103503,
      "sentence": "setUserProperty(name: string, value: string): void",
      "reference_sentence": "## hiAppEvent.setUserProperty<sup>11+</sup>",
      "line_num": 555,
      "context": "",
      "用户拒绝的修改": "hiAppEvent.setUserProperty(name: string, value: string): void",
      "注意事项": "修复时需严格区分方法标题与定义格式，标题中的`hiAppEvent.`为类/命名空间前缀，方法定义应仅保留方法名`setUserProperty`，避免冗余添加命名空间导致语法错误。"
    },
    {
      "defect_id": 103526,
      "sentence": "设置每次取出的应用事件包的数据条数，优先级高于setSize，和setSize同时调用时仅setRow生效。",
      "reference_sentence": "设置每次取出的应用事件包的数据大小阈值。",
      "line_num": 886,
      "context": "",
      "用户拒绝的修改": "设置每次取出的应用事件包的数据条数，优先级高于 setSize，和 setSize 同时调用时仅 setRow 生效。",
      "注意事项": "修复时必须严格检查术语一致性，优先匹配上下文或参考句中的核心概念（如“数据大小阈值”），避免因格式调整破坏语义连贯性；修改前需明确参数名（setRow/setSize）与业务概念的对应关系。"
    },
    {
      "defect_id": 103467,
      "sentence": "## hiAppEvent.write",
      "reference_sentence": "## hiAppEvent.writewrite",
      "line_num": 194,
      "context": "",
      "用户拒绝的修改": "## hiAppEvent.writewrite",
      "注意事项": "修复时必须严格验证参考句子的正确格式，避免机械重复（如错误添加\"write\"后缀），同时检查上下文确保修改后与文档整体命名规范一致。"
    },
    {
      "defect_id": 103549,
      "sentence": "提供了订阅返回的事件组的参数定义。",
      "reference_sentence": "## AppEventPackage提供了订阅返回的应用事件包的参数定义。",
      "line_num": 956,
      "context": "",
      "用户拒绝的修改": "提供了订阅返回的应用事件包的参数定义。",
      "注意事项": "在替换术语前，必须严格核查文档中所有关联内容（包括用户提供的参考句子）的用词一致性，优先采用已有高频术语或用户明确提供的标准表述，避免自行创造同义词或近义词替换。"
    },
    {
      "defect_id": 103550,
      "sentence": "应用事件打点数据清理方法，将应用存储在本地的打点数据进行清除。",
      "reference_sentence": "根据设置的数据大小阈值或条数来取出订阅事件数据，当订阅事件数据全部被取出时返回null作为标识。",
      "line_num": 971,
      "context": "",
      "用户拒绝的修改": "应用事件数据清理方法，将应用存储在本地的事件数据进行清除。",
      "注意事项": "在修复术语不一致问题时，需优先识别并保留原文核心术语（如\"打点数据\"），仅在确保上下文存在明确同义关系时进行替换；若参考句与问题句存在术语差异，应通过上下文验证术语使用场景是否一致，避免跨语境强行统一。"
    },
    {
      "defect_id": 188812,
      "sentence": "doWritev(chunks: string[] | Uint8Array[], callback: Function): void",
      "reference_sentence": "doWrite(chunk: string | Uint8Array, encoding: string, callback: Function): void",
      "line_num": 1466,
      "context": "{\"1461\":\"\",\"1462\":\"let duplexStream = new TestDuplex();\",\"1463\":\"duplexStream.write('data', 'utf8');\",\"1464\":\"```\",\"1465\":\"\",\"1466\":\"### doWritev\",\"1467\":\"\",\"1468\":\"doWritev(chunks: string[] | Uint8Array[], callback: Function): void\",\"1469\":\"\",\"1470\":\"数据分批写出接口是一个由使用者实现的函数，在数据被写出时自动调用，而不需要用户手动调用。使用callback异步回调。\",\"1471\":\"\"}",
      "用户拒绝的修改": "doWrite(chunks: string[] | Uint8Array[], callback: Function): void",
      "注意事项": "在修复方法名一致性时，必须优先确认上下文是否存在功能不同的重载方法，区分\"doWritev\"(批量写入)和\"doWrite\"(单次写入)等设计意图，避免仅通过命名相似性误判为命名错误。"
    },
    {
      "defect_id": 188531,
      "sentence": "end(chunk?: string | Uint8Array, encoding?: string, callback?: Function): Writable",
      "reference_sentence": "write(chunk?: string | Uint8Array, encoding?: string, callback?: Function): boolean",
      "line_num": 108,
      "context": "{\"103\":\"writableStream.write('test', 'utf8');\",\"104\":\"```\",\"105\":\"\",\"106\":\"### end\",\"107\":\"\",\"108\":\"end(chunk?: string | Uint8Array, encoding?: string, callback?: Function): Writable\",\"109\":\"\",\"110\":\"结束可写流的写入操作。如果属性writableCorked的值大于0，会置零该值并输出缓冲区剩余数据。如果传入chunk参数，则根据实际运行情况，通过write或者doWrite将其作为最后一块数据写入。其中通过doWrite写入时，encoding参数的合法性检查依赖doWrite。end单独使用（不使用write）并传入chunk参数的情况下，必然通过doWrite写入。使用callback异步回调。\",\"111\":\"\",\"112\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"113\":\"\"}",
      "用户拒绝的修改": "end(chunk?: string | Uint8Array, encoding?: string, callback?: Function): void",
      "注意事项": "修复时应优先严格遵循当前接口自身的返回值定义和上下文描述，避免跨接口类比；需结合方法行为（如是否支持链式调用）和文档中的异步回调机制综合判断返回类型。"
    },
    {
      "defect_id": 284512,
      "sentence": "应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户首次认证前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。",
      "reference_sentence": "对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“[应用文件目录](#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。",
      "line_num": 74,
      "context": "{\"69\":\"     - 在EL2的基础上，增加设备锁屏时的文件保护能力。在用户锁屏后，满足一定条件时，通过EL5能力保护的数据将无法被访问，但可以继续创建和读写新的文件。如无特殊必要，无需使用该方式。\",\"70\":\"     - 默认情况下不会生成EL5的相关目录，需要配置访问E类加密数据库的相关权限，详见[E类加密数据库的使用](../database/encrypted_estore_guidelines.md)。\",\"71\":\"\",\"72\":\"   > **说明：**\",\"73\":\"   >\",\"74\":\"   > 应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件需要在用户首次认证前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件存放到设备级加密区（el1）。\",\"75\":\"   >\",\"76\":\"   > 开发者可通过监听[COMMON_EVENT_USER_UNLOCKED](../reference/apis-basic-services-kit/common_event/commonEventManager-definitions.md#common_event_user_unlocked)事件感知当前用户首次认证完成。\",\"77\":\"   >\",\"78\":\"   > 切换应用文件加密类型目录的方法请参见[获取和修改加密分区](../application-models/application-context-stage.md#获取和修改加密分区)。\",\"79\":\"\"}",
      "用户拒绝的修改": "应用如无特殊需要，应将数据存放在el2加密目录下，以尽可能保证数据安全。但是对于某些场景，一些应用文件目录需要在用户首次认证前就可被访问，例如时钟、闹铃、壁纸等，此时应用需要将这些文件目录存放到设备级加密区（el1）。",
      "注意事项": "在保持术语一致性时需严格区分近义词的语义差异，替换前必须确认上下文是否存在明确定义（如参考句子中的\"应用文件目录\"为专有概念），避免将实体文件(file)与存储路径(directory)混为一谈。"
    },
    {
      "defect_id": 284511,
      "sentence": "应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问[用户文件](user-file-overview.md)，则需要通过特定API同时经过用户的相应授权才能进行。",
      "reference_sentence": "对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“[应用文件目录](#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"- 对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“[应用文件目录](#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。\",\"6\":\"\",\"7\":\"- 应用沙箱限制了应用可见的数据范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。\",\"8\":\"\",\"9\":\"- 应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问[用户文件](user-file-overview.md)，则需要通过特定API同时经过用户的相应授权才能进行。\",\"10\":\"\",\"11\":\"下图展示了应用沙箱下，应用可访问的文件范围和方式。\",\"12\":\"\",\"13\":\"**图1** 应用沙箱文件访问关系图  \",\"14\":\"![Application sandbox file access relationship](figures/application-sandbox-file-access-relationship.png)\"}",
      "用户拒绝的修改": "应用可以在“应用文件目录”下保存和处理自己的应用文件目录；系统文件及其目录对于应用是只读的；而应用若需访问[用户文件](user-file-overview.md)，则需要通过特定API同时经过用户的相应授权才能进行。",
      "注意事项": "修复术语一致性时需优先确认上下文中的术语定义及使用场景，避免因机械替换导致语义偏差；修改后应交叉验证技术概念准确性（如区分\"应用文件\"与\"应用文件目录\"的物理存储层级关系）。"
    },
    {
      "defect_id": 284514,
      "sentence": "其中&lt;USERID&gt;为当前用户ID，从100开始递增，&lt;EXTENSIONPATH&gt;为moduleName-extensionName。应用是否以Extension独立沙箱运行可参考[ExtensionAbility组件](../application-models/extensionability-overview.md)。",
      "reference_sentence": "应用沙箱路径与真实物理路径对应关系如下表所示。",
      "line_num": 104,
      "context": "{\"99\":\"\",\"100\":\"## 应用沙箱路径和真实物理路径的对应关系\",\"101\":\"\",\"102\":\"在应用沙箱路径下读写文件，经过映射转换，实际读写的是真实物理路径中的应用文件，应用沙箱路径与真实物理路径对应关系如下表所示。\",\"103\":\"\",\"104\":\"其中&lt;USERID&gt;为当前用户ID，从100开始递增，&lt;EXTENSIONPATH&gt;为moduleName-extensionName。应用是否以Extension独立沙箱运行可参考[ExtensionAbility组件](../application-models/extensionability-overview.md)。\",\"105\":\"\",\"106\":\"| 应用沙箱路径 | 物理路径 |\",\"107\":\"| -------- | -------- |\",\"108\":\"| /data/storage/el1/bundle | 应用安装包目录：<br> /data/app/el1/bundle/public/&lt;PACKAGENAME&gt; |\",\"109\":\"| /data/storage/el1/base | 应用el1级别加密数据目录：<br> - 非独立沙箱运行的应用：/data/app/el1/&lt;USERID&gt;/base/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用： /data/app/el1/&lt;USERID&gt;/base/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt; |\"}",
      "用户拒绝的修改": "请参考[ExtensionAbility组件](../application-models/extensionability-overview.md)，了解应用是否以Extension独立沙箱运行。",
      "注意事项": "修复时应优先保留原文核心信息与逻辑关系，避免因句式调整导致语义偏移；需结合上下文判断祈使句或陈述句的适用性（如说明性段落多用陈述句，操作指引才用祈使句）。"
    },
    {
      "defect_id": 284510,
      "sentence": "应用沙箱限制了应用可见的数据范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。",
      "reference_sentence": "对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“[应用文件目录](#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"应用沙箱是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。在这种沙箱的保护机制下，应用可见的目录范围即为“应用沙箱目录”。\",\"4\":\"\",\"5\":\"- 对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“[应用文件目录](#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。\",\"6\":\"\",\"7\":\"- 应用沙箱限制了应用可见的数据范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。\",\"8\":\"\",\"9\":\"- 应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问[用户文件](user-file-overview.md)，则需要通过特定API同时经过用户的相应授权才能进行。\",\"10\":\"\",\"11\":\"下图展示了应用沙箱下，应用可访问的文件范围和方式。\",\"12\":\"\"}",
      "用户拒绝的修改": "应用沙箱限制了应用可见的数据范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件目录以及少量的系统文件（应用运行必需的少量系统文件）。",
      "注意事项": "修复术语一致性时必须严格验证上下文定义，确保替换后的术语在原文中指向相同实体且不改变技术含义，避免混淆\"文件\"与\"目录\"等层级概念差异。"
    },
    {
      "defect_id": 383023,
      "sentence": "The target bundle is not in u1.",
      "reference_sentence": "仅当应用安装在userId为1的用户下",
      "line_num": 1918,
      "context": "{\"1913\":\"| 801 | Capability not supported. |\",\"1914\":\"| 16000050 | Internal error. |\",\"1915\":\"| 16000081 | Failed to obtain the target application information. |\",\"1916\":\"| 16000202 | Invalid main element type. |\",\"1917\":\"| 16000203 | Cannot change the keep-alive status. |\",\"1918\":\"| 16000204 | The target bundle is not in u1. |\",\"1919\":\"\",\"1920\":\"**示例：**\",\"1921\":\"\",\"1922\":\"```ts\",\"1923\":\"import { appManager } from '@kit.AbilityKit';\"}",
      "用户拒绝的修改": "The target bundle is not in userId 1.",
      "注意事项": "在修复术语不一致问题时，必须优先识别并严格遵循上下文已有的统一表述形式（如\"userId为1\"），禁止自行替换为缩写或变体（如\"u1\"）；修改前需全局检索文档中所有相关术语的使用场景，确保全文档表述一致性。"
    },
    {
      "defect_id": 382979,
      "sentence": "该AppServiceExtensionAbility的保活策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保活。",
      "reference_sentence": "该AppServiceExtensionAbility的保活策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保活。",
      "line_num": 1534,
      "context": "{\"1529\":\"\",\"1530\":\"无法更改AppServiceExtensionAbility保活状态时，方法返回该错误码。\",\"1531\":\"\",\"1532\":\"**可能原因**\",\"1533\":\"\",\"1534\":\"该AppServiceExtensionAbility的保活策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保活。\",\"1535\":\"\",\"1536\":\"**处理步骤**\",\"1537\":\"\",\"1538\":\"MDM取消设置保活，或者设置保活策略为用户可取消；切换到设置保活的用户下取消AppServiceExtensionAbility的保活。\",\"1539\":\"\"}",
      "用户拒绝的修改": "该AppServiceExtensionAbility的保持在线策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保持在线。",
      "注意事项": "在替换术语前必须检查上下文中的现有术语使用情况，若原术语已在问题描述或参考句子中高频出现，即使未被术语表收录也应优先保持上下文一致性，避免因机械替换导致语义偏差。"
    },
    {
      "defect_id": 382981,
      "sentence": "## 16000204 指定的应用未安装在userId为1的用户下",
      "reference_sentence": "## 16000204 指定的应用未安装在userId为1的用户下",
      "line_num": 1540,
      "context": "{\"1535\":\"\",\"1536\":\"**处理步骤**\",\"1537\":\"\",\"1538\":\"MDM取消设置保活，或者设置保活策略为用户可取消；切换到设置保活的用户下取消AppServiceExtensionAbility的保活。\",\"1539\":\"\",\"1540\":\"## 16000204 指定的应用未安装在userId为1的用户下\",\"1541\":\"\",\"1542\":\"**错误信息**\",\"1543\":\"\",\"1544\":\"The target bundle is not in u1.\",\"1545\":\"\"}",
      "用户拒绝的修改": "## 16000204 指定的应用未安装在用户ID为1的用户下",
      "注意事项": "修复术语一致性时必须优先检查上下文现有用法，若原文已固定使用英文术语（如userId）则保持统一，禁止擅自转换为中文全称；同时需确认文档全局术语标准，避免局部修改导致上下文冲突。"
    },
    {
      "defect_id": 382995,
      "sentence": "| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |",
      "reference_sentence": "## KeepAliveSetter<sup>14+</sup>",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"67\":\"| ------------------------- | ------ | ---- | ---- | --------- |\",\"68\":\"| bundleName   | string | 是 | 否  | Bundle名称。 |\",\"69\":\"| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |\",\"70\":\"| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |\",\"71\":\"| setterUserId<sup>20+</sup>   | number | 是 | 是  | 应用保活设置者的用户ID。 |\",\"72\":\"| allowUserToCancel<sup>20+</sup>   | boolean | 是 | 是  | 表示是否允许用户取消应用保活，true表示允许，false表示不允许。 |\",\"73\":\"\",\"74\":\"## appManager.isSharedBundleRunning<sup>10+</sup>\",\"75\":\"\"}",
      "用户拒绝的修改": "| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 设置方类型。   |",
      "注意事项": "修复时必须保留原文中的核心业务关键词（如“应用保活”），避免过度简化导致信息缺失；需严格检查上下文术语一致性（如\"setterUserId\"等关联字段），确保全局概念统一。"
    },
    {
      "defect_id": 382983,
      "sentence": "指定的应用未安装在userId为1的用户下。",
      "reference_sentence": "指定的应用未安装在userId为1的用户下。",
      "line_num": 1552,
      "context": "{\"1547\":\"\",\"1548\":\"指定的应用未安装在userId为1的用户下，方法返回该错误码。\",\"1549\":\"\",\"1550\":\"**可能原因**\",\"1551\":\"\",\"1552\":\"指定的应用未安装在userId为1的用户下。\",\"1553\":\"\",\"1554\":\"**处理步骤**\",\"1555\":\"\",\"1556\":\"将指定的应用安装在userId为1的用户下。\",\"1557\":\"<!--DelEnd-->\"}",
      "用户拒绝的修改": "指定的应用未安装在用户ID为1的用户下。",
      "注意事项": "修复术语一致性时必须严格检查上下文已有用法，若原文已统一使用英文术语（如userId），应优先保留原格式而非强制翻译为中文（如用户ID）。"
    },
    {
      "defect_id": 382975,
      "sentence": "如果设置保活的对象不是appService类型的ExtensionAbility，方法将返回该错误码。",
      "reference_sentence": "如果设置保活的对象不是appService类型的ExtensionAbility，方法将返回该错误码。",
      "line_num": 1512,
      "context": "{\"1507\":\"\",\"1508\":\"Invalid main element type.\",\"1509\":\"\",\"1510\":\"**错误描述**\",\"1511\":\"\",\"1512\":\"如果设置保活的对象不是appService类型的ExtensionAbility，方法将返回该错误码。\",\"1513\":\"\",\"1514\":\"**可能原因**\",\"1515\":\"\",\"1516\":\"应用中entry类型的HAP的module.json5配置文件中的mainElement字段不是appService类型的ExtensionAbility。\",\"1517\":\"\"}",
      "用户拒绝的修改": "如果设置保持在线的对象不是appService类型的ExtensionAbility，方法将返回该错误码。",
      "注意事项": "在修复术语一致性时，需优先确认上下文是否存在隐性术语约定（如错误码描述中已高频出现\"保活\"），若术语虽未在术语表定义但上下文已形成固定用法，应保留原词避免歧义；修改前需交叉验证文档全局术语使用情况，避免局部替换破坏技术概念一致性。"
    },
    {
      "defect_id": 382980,
      "sentence": "MDM取消设置保活，或者设置保活策略为用户可取消；切换到设置保活的用户下取消AppServiceExtensionAbility的保活。",
      "reference_sentence": "MDM取消设置保活，或者设置保活策略为用户可取消；切换到设置保活的用户下取消AppServiceExtensionAbility的保活。",
      "line_num": 1538,
      "context": "{\"1533\":\"\",\"1534\":\"该AppServiceExtensionAbility的保活策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保活。\",\"1535\":\"\",\"1536\":\"**处理步骤**\",\"1537\":\"\",\"1538\":\"MDM取消设置保活，或者设置保活策略为用户可取消；切换到设置保活的用户下取消AppServiceExtensionAbility的保活。\",\"1539\":\"\",\"1540\":\"## 16000204 指定的应用未安装在userId为1的用户下\",\"1541\":\"\",\"1542\":\"**错误信息**\",\"1543\":\"\"}",
      "用户拒绝的修改": "MDM取消设置保持在线，或者设置保持在线策略为用户可取消；切换到设置保持在线的用户下取消AppServiceExtensionAbility的保持在线。",
      "注意事项": "维护术语一致性时需优先遵循上下文既有用法，即使术语表未定义也要保留原文高频出现的专业词汇（如\"保活\"），避免机械替换导致语义偏离。"
    },
    {
      "defect_id": 382976,
      "sentence": "修改应用中entry类型的HAP的module.json5配置文件的mainElement字段为appService类型的ExtensionAbility。",
      "reference_sentence": "修改应用中entry类型的HAP的module.json5配置文件的mainElement字段为appService类型的ExtensionAbility。",
      "line_num": 1520,
      "context": "{\"1515\":\"\",\"1516\":\"应用中entry类型的HAP的module.json5配置文件中的mainElement字段不是appService类型的ExtensionAbility。\",\"1517\":\"\",\"1518\":\"**处理步骤**\",\"1519\":\"\",\"1520\":\"修改应用中entry类型的HAP的module.json5配置文件的mainElement字段为appService类型的ExtensionAbility。\",\"1521\":\"\",\"1522\":\"## 16000203 无法更改AppServiceExtensionAbility保活状态\",\"1523\":\"\",\"1524\":\"**错误信息**\",\"1525\":\"\"}",
      "用户拒绝的修改": "修改应用中entry类型的Harmony Ability Package的module.json5配置文件的mainElement字段为appService类型的ExtensionAbility。",
      "注意事项": "修复时应严格遵循上下文已有的术语形式（如缩写HAP），避免将已明确使用的缩写替换为全称；优先保持用户原始表述习惯，仅在术语首次出现或上下文不一致时考虑补充说明。"
    },
    {
      "defect_id": 382994,
      "sentence": "| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |",
      "reference_sentence": "## KeepAliveAppType<sup>14+</sup>",
      "line_num": 69,
      "context": "{\"64\":\"**系统接口**：此接口为系统接口。\",\"65\":\"\",\"66\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"67\":\"| ------------------------- | ------ | ---- | ---- | --------- |\",\"68\":\"| bundleName   | string | 是 | 否  | Bundle名称。 |\",\"69\":\"| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |\",\"70\":\"| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |\",\"71\":\"| setterUserId<sup>20+</sup>   | number | 是 | 是  | 应用保活设置者的用户ID。 |\",\"72\":\"| allowUserToCancel<sup>20+</sup>   | boolean | 是 | 是  | 表示是否允许用户取消应用保活，true表示允许，false表示不允许。 |\",\"73\":\"\",\"74\":\"## appManager.isSharedBundleRunning<sup>10+</sup>\"}",
      "用户拒绝的修改": "| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 应用类型。   |",
      "注意事项": "保持核心限定词不丢失，修复时应完整保留原句中的关键上下文信息（如\"被保活应用\"），确保术语与文档其他部分严格一致，避免因过度简化导致指代对象模糊。"
    },
    {
      "defect_id": 382984,
      "sentence": "将指定的应用安装在userId为1的用户下。",
      "reference_sentence": "将指定的应用安装在userId为1的用户下。",
      "line_num": 1556,
      "context": "{\"1551\":\"\",\"1552\":\"指定的应用未安装在userId为1的用户下。\",\"1553\":\"\",\"1554\":\"**处理步骤**\",\"1555\":\"\",\"1556\":\"将指定的应用安装在userId为1的用户下。\",\"1557\":\"<!--DelEnd-->\"}",
      "用户拒绝的修改": "将指定的应用安装在用户ID为1的用户下。",
      "注意事项": "修复术语不一致时必须优先检查上下文中的原始用法，保持与已出现术语形式(userId)严格一致，避免擅自替换为全称或规范形式(用户ID)。"
    },
    {
      "defect_id": 382982,
      "sentence": "指定的应用未安装在userId为1的用户下，方法返回该错误码。",
      "reference_sentence": "指定的应用未安装在userId为1的用户下，方法返回该错误码。",
      "line_num": 1548,
      "context": "{\"1543\":\"\",\"1544\":\"The target bundle is not in u1.\",\"1545\":\"\",\"1546\":\"**错误描述**\",\"1547\":\"\",\"1548\":\"指定的应用未安装在userId为1的用户下，方法返回该错误码。\",\"1549\":\"\",\"1550\":\"**可能原因**\",\"1551\":\"\",\"1552\":\"指定的应用未安装在userId为1的用户下。\",\"1553\":\"\"}",
      "用户拒绝的修改": "指定的应用未安装在用户ID为1的用户下，方法返回该错误码。",
      "注意事项": "修复术语时应优先检查上下文中的原始用法，保持全篇术语一致性高于格式规范；若原文已确立特定缩写/全称形式，需严格沿用而非强制统一格式。"
    },
    {
      "defect_id": 382978,
      "sentence": "无法更改AppServiceExtensionAbility保活状态时，方法返回该错误码。",
      "reference_sentence": "无法更改AppServiceExtensionAbility保活状态时，方法返回该错误码。",
      "line_num": 1530,
      "context": "{\"1525\":\"\",\"1526\":\"Cannot change the keep-alive status.\",\"1527\":\"\",\"1528\":\"**错误描述**\",\"1529\":\"\",\"1530\":\"无法更改AppServiceExtensionAbility保活状态时，方法返回该错误码。\",\"1531\":\"\",\"1532\":\"**可能原因**\",\"1533\":\"\",\"1534\":\"该AppServiceExtensionAbility的保活策略被MDM设置为用户不可取消，或者该AppServiceExtensionAbility是由其他用户设置的保活。\",\"1535\":\"\"}",
      "用户拒绝的修改": "无法更改AppServiceExtensionAbility保持在线状态时，方法返回该错误码。",
      "注意事项": "在替换未定义术语前必须检查上下文是否存在已建立的惯用表述，若原词在文档中多次出现且具有领域共识性，应优先保留原术语并建议更新术语表而非直接替换。"
    },
    {
      "defect_id": 382977,
      "sentence": "## 16000203 无法更改AppServiceExtensionAbility保活状态",
      "reference_sentence": "## 16000203 无法更改AppServiceExtensionAbility保活状态",
      "line_num": 1522,
      "context": "{\"1517\":\"\",\"1518\":\"**处理步骤**\",\"1519\":\"\",\"1520\":\"修改应用中entry类型的HAP的module.json5配置文件的mainElement字段为appService类型的ExtensionAbility。\",\"1521\":\"\",\"1522\":\"## 16000203 无法更改AppServiceExtensionAbility保活状态\",\"1523\":\"\",\"1524\":\"**错误信息**\",\"1525\":\"\",\"1526\":\"Cannot change the keep-alive status.\",\"1527\":\"\"}",
      "用户拒绝的修改": "## 16000203 无法更改AppServiceExtensionAbility保持在线状态",
      "注意事项": "修复术语时应优先确认上下文是否存在已定义的技术术语或行业惯用表达，若用户原文使用领域内约定俗成表述（如\"保活\"），即使未在通用术语表收录也应保留原词，必要时建议用户补充术语表而非强制替换。"
    },
    {
      "defect_id": 383022,
      "sentence": "Cannot change the keep-alive status.",
      "reference_sentence": "为AppServiceExtensionAbility设置保活或取消保活。",
      "line_num": 1917,
      "context": "{\"1912\":\"| 202 | Not system application. |\",\"1913\":\"| 801 | Capability not supported. |\",\"1914\":\"| 16000050 | Internal error. |\",\"1915\":\"| 16000081 | Failed to obtain the target application information. |\",\"1916\":\"| 16000202 | Invalid main element type. |\",\"1917\":\"| 16000203 | Cannot change the keep-alive status. |\",\"1918\":\"| 16000204 | The target bundle is not in u1. |\",\"1919\":\"\",\"1920\":\"**示例：**\",\"1921\":\"\",\"1922\":\"```ts\"}",
      "用户拒绝的修改": "Cannot cancel the keep-alive status.",
      "注意事项": "修复时必须严格匹配上下文已有术语（如\"取消保活\"），避免在相同语义场景混用不同动词（如change/cancel）；修改前需交叉验证参考句中的固定表达模式，确保操作描述与系统定义的动作名称完全一致。"
    },
    {
      "defect_id": 382997,
      "sentence": "Not system application.",
      "reference_sentence": "Not System App. Interface caller is not a system app.",
      "line_num": 1912,
      "context": "{\"1907\":\"以下错误码详细介绍请参考[通用错误码](../errorcode-universal.md)和[元能力子系统错误码](errorcode-ability.md)。\",\"1908\":\"\",\"1909\":\"| 错误码ID | 错误信息 |\",\"1910\":\"| ------- | -------- |\",\"1911\":\"| 201 | Permission denied. |\",\"1912\":\"| 202 | Not system application. |\",\"1913\":\"| 801 | Capability not supported. |\",\"1914\":\"| 16000050 | Internal error. |\",\"1915\":\"| 16000081 | Failed to obtain the target application information. |\",\"1916\":\"| 16000202 | Invalid main element type. |\",\"1917\":\"| 16000203 | Can not change keep alive status. |\"}",
      "用户拒绝的修改": "Not System App.",
      "注意事项": "修复时必须严格检查上下文及参考句例中的术语格式（如大小写、缩写形式），确保全局统一性，避免仅修改局部而忽略文档整体一致性要求。"
    },
    {
      "defect_id": 383021,
      "sentence": "Not system application.",
      "reference_sentence": "Not System App. Interface caller is not a system app.",
      "line_num": 1912,
      "context": "{\"1907\":\"以下错误码详细介绍请参考[通用错误码](../errorcode-universal.md)和[元能力子系统错误码](errorcode-ability.md)。\",\"1908\":\"\",\"1909\":\"| 错误码ID | 错误信息 |\",\"1910\":\"| ------- | -------- |\",\"1911\":\"| 201 | Permission denied. |\",\"1912\":\"| 202 | Not system application. |\",\"1913\":\"| 801 | Capability not supported. |\",\"1914\":\"| 16000050 | Internal error. |\",\"1915\":\"| 16000081 | Failed to obtain the target application information. |\",\"1916\":\"| 16000202 | Invalid main element type. |\",\"1917\":\"| 16000203 | Cannot change the keep-alive status. |\"}",
      "用户拒绝的修改": "Not system app.",
      "注意事项": "修改前必须全面检查上下文术语使用习惯，优先沿用文档中已确立的缩写形式（如\"app\"）或全称形式（如\"application\"），确保同一概念在整份文档中保持完全一致的表达方式。"
    },
    {
      "defect_id": 382974,
      "sentence": "## 16000202 仅支持为appService类型的ExtensionAbility设置保活",
      "reference_sentence": "## 16000202 仅支持为appService类型的ExtensionAbility设置保活",
      "line_num": 1504,
      "context": "{\"1499\":\"\",\"1500\":\"**处理步骤**\",\"1501\":\"\",\"1502\":\"检查bundleName是否正确。\",\"1503\":\"\",\"1504\":\"## 16000202 仅支持为appService类型的ExtensionAbility设置保活\",\"1505\":\"\",\"1506\":\"**错误信息**\",\"1507\":\"\",\"1508\":\"Invalid main element type.\",\"1509\":\"\"}",
      "用户拒绝的修改": "## 16000202 仅支持为appService类型的ExtensionAbility设置保持在线",
      "注意事项": "在修改未定义术语前必须核查上下文是否存在领域专用术语，若用户明确拒绝术语替换应优先保留原文并建议更新术语表而非强行替换。"
    },
    {
      "defect_id": 403850,
      "sentence": "用于从ArkTS对象中获取命名属性的值。",
      "reference_sentence": "用于从ArkTS对象中获取命名属性的值。",
      "line_num": 441,
      "context": "{\"436\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_set_named_property: %{public}s', objAsString);\",\"437\":\"```\",\"438\":\"\",\"439\":\"### napi_get_named_property\",\"440\":\"\",\"441\":\"用于从ArkTS对象中获取命名属性的值。\",\"442\":\"\",\"443\":\"cpp部分代码\",\"444\":\"\",\"445\":\"```cpp\",\"446\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "用于从ArkTS对象中取得命名属性的值。",
      "注意事项": "修复时应优先检查上下文术语一致性，避免在无明确重复问题下替换原文合理用词；技术文档中需严格保持核心术语（如“获取”）统一，除非存在歧义否则不主动替换近义词。"
    },
    {
      "defect_id": 403797,
      "sentence": "用于对Promise关联的deferred对象进行解析，napi_resolve_deferred将其从挂起状态转换为已兑现状态，napi_reject_deferred将其从挂起状态转换为已拒绝状态。",
      "reference_sentence": "用于对Promise关联的deferred对象进行解析，napi_resolve_deferred将其从挂起状态转换为已兑现状态，napi_reject_deferred将其从挂起状态转换为已拒绝状态。",
      "line_num": 113,
      "context": "{\"108\":\"}\",\"109\":\"```\",\"110\":\"\",\"111\":\"### napi_resolve_deferred & napi_reject_deferred\",\"112\":\"\",\"113\":\"用于对Promise关联的deferred对象进行解析，napi_resolve_deferred将其从挂起状态转换为已兑现状态，napi_reject_deferred将其从挂起状态转换为已拒绝状态。\",\"114\":\"\",\"115\":\"为确保微任务能正确的被执行，ArkTS运行时在使用Node-API方法兑现Promise时，将会触发一次微任务的执行。\",\"116\":\"\",\"117\":\"cpp部分代码\",\"118\":\"\"}",
      "用户拒绝的修改": "对Promise关联的deferred对象进行解析，使用napi_resolve_deferred将其从挂起状态转换为已兑现状态，使用napi_reject_deferred将其从挂起状态转换为已拒绝状态。",
      "注意事项": "修复时需确保整个段落保持统一的祈使句结构，避免混合使用陈述句和祈使句；特别注意动作描述的主语一致性，若上下文采用无主语句式，修复时不得擅自添加\"使用\"等动作主体。"
    },
    {
      "defect_id": 401697,
      "sentence": "ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。",
      "reference_sentence": "ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS基础类库概述\",\"2\":\"\",\"3\":\"ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。\",\"4\":\"\",\"5\":\"ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。\"}",
      "用户拒绝的修改": "ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块，提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等功能，协助开发者简化开发工作，提升开发效率。",
      "注意事项": "保持核心术语一致性，避免同一段落中混用\"功能\"和\"能力\"等近义词；修改前需完整核对上下文，防止与已有内容重复列举功能模块。"
    },
    {
      "defect_id": 402775,
      "sentence": "if (value == 'Play' || value == 'Work') {",
      "reference_sentence": "if (value == 'Play' || value == 'Work') {",
      "line_num": 64,
      "context": "{\"59\":\"    ```ts\",\"60\":\"    function func(name: string, value: string): boolean {\",\"61\":\"      if (name == 'note') {\",\"62\":\"        console.info(name);\",\"63\":\"      }\",\"64\":\"      if (value == 'Play' || value == 'Work') {\",\"65\":\"        console.info('    ' + value);\",\"66\":\"      }\",\"67\":\"      if (name == 'title' || name == 'lens') {\",\"68\":\"        console.info('  ' + name);\",\"69\":\"      }\"}",
      "用户拒绝的修改": "if (value == 'Play' || value == 'Work') { // 标签值",
      "注意事项": "确保注释术语与变量名严格对应，避免引入不一致的表述；优先复用上下文已有的注释风格，若需新增内容需明确补充逻辑背景而非重复字面信息。"
    },
    {
      "defect_id": 402776,
      "sentence": "if (name == 'title' || name == 'lens') {",
      "reference_sentence": "if (name == 'title' || name == 'lens') {",
      "line_num": 67,
      "context": "{\"62\":\"        console.info(name);\",\"63\":\"      }\",\"64\":\"      if (value == 'Play' || value == 'Work') {\",\"65\":\"        console.info('    ' + value);\",\"66\":\"      }\",\"67\":\"      if (name == 'title' || name == 'lens') {\",\"68\":\"        console.info('  ' + name);\",\"69\":\"      }\",\"70\":\"      return true; //true:继续解析 false:停止解析\",\"71\":\"    }\",\"72\":\"    ```\"}",
      "用户拒绝的修改": "if (name == 'title' || name == 'lens') { // 标签名",
      "注意事项": "确保注释术语与代码变量名严格一致，避免引入冗余或冲突的语义标签；修复时需结合上下文确认命名逻辑的统一性，优先使用代码已有命名体系进行解释。"
    },
    {
      "defect_id": 403853,
      "sentence": "用于获取传入的ArkTS对象的所有属性名。",
      "reference_sentence": "用于获取传入的ArkTS对象的所有属性名。",
      "line_num": 695,
      "context": "{\"690\":\"  .setterCallback('set data'));\",\"691\":\"```\",\"692\":\"\",\"693\":\"### napi_get_all_property_names\",\"694\":\"\",\"695\":\"用于获取传入的ArkTS对象的所有属性名。\",\"696\":\"\",\"697\":\"cpp部分代码\",\"698\":\"\",\"699\":\"```cpp\",\"700\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "用于取得传入的ArkTS对象的所有属性名。",
      "注意事项": "修复时应严格检查上下文术语一致性，优先沿用原文用词，避免在技术文档中替换近义词（如\"获取\"→\"取得\"），除非存在明确表述错误。"
    },
    {
      "defect_id": 402769,
      "sentence": "对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型和元素信息](#解析xml事件类型和元素信息)三类操作。",
      "reference_sentence": "对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型和元素信息](#解析xml事件类型和元素信息)三类操作。",
      "line_num": 4,
      "context": "{\"1\":\"# XML解析\",\"2\":\"\",\"3\":\"\",\"4\":\"对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型和元素信息](#解析xml事件类型和元素信息)三类操作。如在Web服务中，XML是SOAP（Simple Object Access Protocol）协议的基础，SOAP消息通常以XML格式封装，包含请求和响应参数，通过解析这些XML消息，Web服务可以处理来自客户端的请求并生成相应的响应。\",\"5\":\"\",\"6\":\"\",\"7\":\"XML模块提供XmlPullParser类解析XML文本，输入为含有XML文本的ArrayBuffer或DataView，输出为解析结果。\",\"8\":\"\",\"9\":\"\"}",
      "用户拒绝的修改": "对于以XML作为载体传递的数据，实际使用中需要对相关的元素进行解析，一般包括[解析XML标签和标签值](#解析xml标签和标签值)、[解析XML属性和属性值](#解析xml属性和属性值)、[解析XML事件类型](#解析xml事件类型)三类操作。",
      "注意事项": "保持超链接锚文本与目标标题的完全匹配，修改内容时必须同步更新链接锚点；当标题存在固定标记(tag)时，优先保持标记完整性而非强行统一句式结构。"
    },
    {
      "defect_id": 402774,
      "sentence": "let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码",
      "reference_sentence": "let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码",
      "line_num": 48,
      "context": "{\"43\":\"      '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\",\"44\":\"      '<title>Play</title>' +\",\"45\":\"      '<lens>Work</lens>' +\",\"46\":\"      '</note>';\",\"47\":\"    let textEncoder: util.TextEncoder = new util.TextEncoder();\",\"48\":\"    let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\",\"49\":\"    // 方式1：基于ArrayBuffer构造XmlPullParser对象\",\"50\":\"    let that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');\",\"51\":\"   \",\"52\":\"    // 方式2：基于DataView构造XmlPullParser对象\",\"53\":\"    // let dataView: DataView = new DataView(arrBuffer.buffer as object as ArrayBuffer);\"}",
      "用户拒绝的修改": "let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 编码数据，防止包含中文字符乱码",
      "注意事项": "修复时应优先确保注释术语与上下文变量/操作对象一致，避免重复提及已明确的主体（如\"数据\"）；调整语序时需维持\"动词+目的\"结构清晰性，防止因主谓倒置产生歧义或信息冗余。"
    },
    {
      "defect_id": 402788,
      "sentence": "3. 自定义回调函数，本例直接打印元素事件类型及元素深度。",
      "reference_sentence": "3. 自定义回调函数，本例直接打印出标签及标签值。",
      "line_num": 165,
      "context": "{\"160\":\"    let textEncoder: util.TextEncoder = new util.TextEncoder();\",\"161\":\"    let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\",\"162\":\"    let that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');\",\"163\":\"    ```\",\"164\":\"\",\"165\":\"3. 自定义回调函数，本例直接打印元素事件类型及元素深度。\",\"166\":\"\",\"167\":\"    ```ts\",\"168\":\"    let str: string = '';\",\"169\":\"    function func(name: xml.EventType, value: xml.ParseInfo): boolean {\",\"170\":\"      str = name + ' ' + value.getDepth(); // getDepth 获取元素的当前深度\"}",
      "用户拒绝的修改": "3. 自定义回调函数，本例直接打印出事件类型及元素深度。",
      "注意事项": "修复时应严格核查上下文变量命名和技术术语的全局一致性，确保同一示例中的参数名称（如\"元素事件类型\"）与代码变量（如EventType/getDepth）保持完全对应，避免跨示例的术语混用。"
    },
    {
      "defect_id": 404271,
      "sentence": "import testNapi from 'libentry.so';",
      "reference_sentence": "import testNapi from 'libentry.so';",
      "line_num": 158,
      "context": "{\"153\":\"\",\"154\":\"- ArkTS代码示例\",\"155\":\"\",\"156\":\"    ```ts\",\"157\":\"    // index.ets\",\"158\":\"    import testNapi from 'libentry.so';\",\"159\":\"    \",\"160\":\"    let callback = (a: number, b: number) : number => {\",\"161\":\"        console.info('result is ' + (a + b));\",\"162\":\"        return a + b;\",\"163\":\"    }\"}",
      "用户拒绝的修改": "import testNapi from 'entry';",
      "注意事项": "严格保持上下文引用名称的完整性，禁止擅自删除文件扩展名或库前缀（如\"lib\"），必须通过交叉验证确认所有相关代码段中模块引用格式的一致性。"
    },
    {
      "defect_id": 404525,
      "sentence": "异步线程向ArkTS主线程投递的任务需要根据任务指定的优先级和入队方式进行处理。",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 19,
      "context": "{\"14\":\"| data           | 异步线程期望传递给主线程的数据  |\",\"15\":\"| priority       | 指定任务的优先级[napi_task_priority](napi-data-types-interfaces.md#线程安全任务优先级) |\",\"16\":\"| isTail         | 指定任务的入队方式，true代表任务从队列的尾部入队，false代表任务从队列的头部入队。 |\",\"17\":\"\",\"18\":\"## 场景介绍\",\"19\":\"异步线程向ArkTS主线程投递的任务需要根据任务指定的优先级和入队方式进行处理。\",\"20\":\"\",\"21\":\"## 调用异步的ArkTS接口示例\",\"22\":\"\",\"23\":\"### 示例代码\",\"24\":\"\"}",
      "用户拒绝的修改": "异步线程向ArkTS主线程投递的指定优先级和入队方式的任务需要根据任务的优先级和入队方式进行处理。",
      "注意事项": "修复时应严格保持原文核心要素，避免添加上下文未明确提及的限定词（如\"指定优先级和入队方式的任务\"）；需通过上下文验证任务属性是否已在其他位置定义，若已定义则直接使用\"任务\"作为主语即可避免冗余。"
    },
    {
      "defect_id": 403919,
      "sentence": "以下Node-API接口主要用于string的创建和获取，使用场景如下：",
      "reference_sentence": "使用Node-API接口创建和获取string值",
      "line_num": 18,
      "context": "{\"13\":\"- **UTF-16**：UTF-16是一种定长或变长编码方案，使用16位编码。它可以表示全球范围的字符集，并且适用于较大的字符集。\",\"14\":\"- **ISO-8859-1（Latin-1）**：ISO-8859-1是一种单字节编码方案，使用8位编码。它主要用于表示拉丁字母字符集，包括欧洲大部分语言。\",\"15\":\"\",\"16\":\"## 场景和功能介绍\",\"17\":\"\",\"18\":\"以下Node-API接口主要用于string的创建和获取，使用场景如下：\",\"19\":\"\",\"20\":\"| 接口 | 描述 |\",\"21\":\"| -------- | -------- |\",\"22\":\"| napi_get_value_string_utf8 | 需要将ArkTS的字符类型的数据转换为utf8编码的字符时使用这个函数。 |\",\"23\":\"| napi_create_string_utf8 | 需要通过UTF8编码的C字符串创建ArkTS string值时使用这个函数。 |\"}",
      "用户拒绝的修改": "以下Node-API接口主要用于string值的创建和获取，使用场景如下：",
      "注意事项": "修复时应严格统一语法结构（如保持\"创建和获取string值\"的动宾结构，避免与\"string的创建和获取\"名词化表述混用），并同步检查上下文其他同类表述是否匹配参考句式。"
    },
    {
      "defect_id": 404549,
      "sentence": "#### async_cleanup_hook相关接口",
      "reference_sentence": "#### env_cleanup_hook相关接口",
      "line_num": 433,
      "context": "{\"428\":\"    delete data;\",\"429\":\"    return nullptr;\",\"430\":\"}\",\"431\":\"```\",\"432\":\"\",\"433\":\"#### async_cleanup_hook相关接口\",\"434\":\"\",\"435\":\"napi_add_async_cleanup_hook示例代码\",\"436\":\"\",\"437\":\"```cpp\",\"438\":\"static void AsyncCleanupCallback(napi_async_cleanup_hook_handle handle, void *)\"}",
      "用户拒绝的修改": "#### env_cleanup_hook相关接口",
      "注意事项": "修复时必须严格核对上下文术语使用场景，确保替换概念时同时验证原始文档中相关接口名称的实际引用情况，避免将不同功能的同名后缀接口混为一谈。"
    },
    {
      "defect_id": 404550,
      "sentence": "napi_add_async_cleanup_hook示例代码",
      "reference_sentence": "napi_add_env_cleanup_hook、napi_remove_env_cleanup_hook示例代码",
      "line_num": 435,
      "context": "{\"430\":\"}\",\"431\":\"```\",\"432\":\"\",\"433\":\"#### async_cleanup_hook相关接口\",\"434\":\"\",\"435\":\"napi_add_async_cleanup_hook示例代码\",\"436\":\"\",\"437\":\"```cpp\",\"438\":\"static void AsyncCleanupCallback(napi_async_cleanup_hook_handle handle, void *)\",\"439\":\"{\",\"440\":\"    napi_remove_async_cleanup_hook(handle);    \"}",
      "用户拒绝的修改": "napi_add_env_cleanup_hook示例代码",
      "注意事项": "严格核对上下文中的关键术语使用场景，区分相似接口的命名差异（如`async_cleanup_hook`与`env_cleanup_hook`属于独立概念），避免跨功能模块的术语混用。"
    },
    {
      "defect_id": 404543,
      "sentence": "以下维测手段多依赖于ArkTS运行时的多线程检测能力，因此建议在调试前启用此功能。启用方法参考文档[分析CppCrash（进程崩溃）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)。",
      "reference_sentence": "若无特殊说明，本章节所描述的维测手段，在启用ArkTS运行时多线程检测开关的前提下，会在第一现场中断进程。",
      "line_num": 3,
      "context": "{\"1\":\"# 使用Node-API接口产生的异常日志/崩溃分析\",\"2\":\"\",\"3\":\"以下维测手段多依赖于ArkTS运行时的多线程检测能力，因此建议在调试前启用此功能。启用方法参考文档[分析CppCrash（进程崩溃）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)。\",\"4\":\"\",\"5\":\"若无特殊说明，本章节所描述的维测手段，在启用ArkTS运行时多线程检测开关的前提下，会在第一现场中断进程。\",\"6\":\"\",\"7\":\"## 数据在使用时，与创建该数据时所使用的env不一致\",\"8\":\"\"}",
      "用户拒绝的修改": "以下维测手段多依赖于ArkTS运行时的多线程检测开关，因此建议在调试前启用此开关。启用方法参考文档[分析CppCrash（进程崩溃）](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)。",
      "注意事项": "在统一术语表述时需优先确认上下文是否存在隐性区分（如\"功能\"指整体能力、\"开关\"指具体操作项），避免将相关但不同层级的术语强制统一；若参考句与问题句存在逻辑从属关系（如\"开关启用功能\"），应保留原文术语并采用补充说明方式保持一致性。"
    },
    {
      "defect_id": 404752,
      "sentence": "1. 使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。",
      "reference_sentence": "1. 使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"## 使用Promise方式示例\",\"22\":\"\",\"23\":\"![NAPI Promise异步流程](figures/napi_async_work_with_promise.png)\",\"24\":\"\",\"25\":\"1. 使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。\",\"26\":\"\",\"27\":\"   ```cpp\",\"28\":\"   // 调用方提供的data context，该数据会传递给execute和complete函数\",\"29\":\"   struct CallbackData {\",\"30\":\"       napi_async_work asyncWork = nullptr;\"}",
      "用户拒绝的修改": "使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。",
      "注意事项": "修复时应优先保留原有格式标记（如序号、代码块标识），仅调整句式结构；需结合上下文判断是否需要保持列表项格式，避免因过度统一句式破坏文档结构完整性。"
    },
    {
      "defect_id": 404755,
      "sentence": "4. 模块初始化以及ArkTS侧调用接口。",
      "reference_sentence": "4. 模块初始化以及ArkTS侧调用接口。",
      "line_num": 92,
      "context": "{\"87\":\"       delete callbackData;\",\"88\":\"       callbackData = nullptr;\",\"89\":\"   }\",\"90\":\"   ```\",\"91\":\"\",\"92\":\"4. 模块初始化以及ArkTS侧调用接口。\",\"93\":\"\",\"94\":\"   ```cpp\",\"95\":\"   // 模块初始化\",\"96\":\"   static napi_value Init(napi_env env, napi_value exports)\",\"97\":\"   {\"}",
      "用户拒绝的修改": "进行模块初始化以及ArkTS侧调用接口。",
      "注意事项": "修复时应优先保留原有格式标记（如序号、标点），并严格检查上下文句式结构模式（如列表项统一使用祈使句），避免破坏文档层级一致性。"
    },
    {
      "defect_id": 404754,
      "sentence": "3. 定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。",
      "reference_sentence": "3. 定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。",
      "line_num": 72,
      "context": "{\"67\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"68\":\"       callbackData->result = callbackData->args;\",\"69\":\"   }\",\"70\":\"   ```\",\"71\":\"\",\"72\":\"3. 定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。\",\"73\":\"\",\"74\":\"   ```cpp\",\"75\":\"   static void CompleteCB(napi_env env, napi_status status, void *data)\",\"76\":\"   {\",\"77\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\"}",
      "用户拒绝的修改": "定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。",
      "注意事项": "修复时应优先保留用户原有的序号格式，在调整句式一致性时需对比上下文条目结构，确保祈使句使用不破坏原有编号体系的完整性。"
    },
    {
      "defect_id": 404753,
      "sentence": "2. 定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。",
      "reference_sentence": "2. 定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"      return promise;\",\"59\":\"   }\",\"60\":\"   ```\",\"61\":\"\",\"62\":\"2. 定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。\",\"63\":\"\",\"64\":\"   ```cpp\",\"65\":\"   static void ExecuteCB(napi_env env, void *data)\",\"66\":\"   {\",\"67\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\"}",
      "用户拒绝的修改": "定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。",
      "注意事项": "修复时应优先保留用户指定的格式要素（如序号/标点），在确保格式一致性的前提下调整句式；修改前需仔细核对上下文格式特征，避免破坏文档结构完整性。"
    },
    {
      "defect_id": 404792,
      "sentence": "如果需要进行多线程编程，可以创建一个线程安全的函数，确保多个线程之间的通信和同步操作正确无误。",
      "reference_sentence": "如果多个线程需要访问同一份数据，可以创建一个线程安全的函数，确保数据的读写操作不会发生竞争条件或死锁等问题。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"- 异步计算：如果需要进行耗时的计算或IO操作，可以创建一个线程安全的函数，将计算或IO操作放在另一个线程中执行，避免阻塞主线程，提高程序的响应速度。\",\"10\":\"\",\"11\":\"- 数据共享：如果多个线程需要访问同一份数据，可以创建一个线程安全的函数，确保数据的读写操作不会发生竞争条件或死锁等问题。\",\"12\":\"\",\"13\":\"- 多线程编程：如果需要进行多线程编程，可以创建一个线程安全的函数，确保多个线程之间的通信和同步操作正确无误。\",\"14\":\"\",\"15\":\"\",\"16\":\"## 使用示例\",\"17\":\"\",\"18\":\"1. 在Native入口定义线程安全函数。\"}",
      "用户拒绝的修改": "如果需要进行多线程编程，可以创建一个线程安全的函数，确保多个线程之间的数据读写操作正确无误。",
      "注意事项": "修复时应严格核对上下文术语使用场景（如\"数据读写操作\"对应数据共享场景，\"通信和同步操作\"对应多线程协调场景），避免跨场景混用关键术语；保持同一规则项下表达方式与上下文中已建立的描述范式完全一致。"
    },
    {
      "defect_id": 404750,
      "sentence": "napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。",
      "reference_sentence": "napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"- 数据库操作：当需要执行复杂的数据库查询或写入操作时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的并发性能。\",\"12\":\"\",\"13\":\"- 图像处理：当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。\",\"14\":\"\",\"15\":\"napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。\",\"16\":\"\",\"17\":\"异步调用支持callback方式和Promise方式，使用哪种方式由应用开发者决定。下面为两种方式的示例代码：\",\"18\":\"\",\"19\":\"![NAPI 异步任务线程](figures/napi_async_work.png)\",\"20\":\"\"}",
      "用户拒绝的修改": "对napi_queue_async_work接口底层使用uv_queue_work能力，并对回调中的napi_value的生命周期管理进行兜底。",
      "注意事项": "修复时应优先保持上下文句式统一，避免改变原句核心结构；调整语态时需参照相邻条目使用\"使用/确保\"等动词开头的祈使结构，而非添加冗余介词破坏整体一致性。"
    },
    {
      "defect_id": 404848,
      "sentence": "| First attempt: $ERRMSG. | 首先加载后缀不拼接'_napi'的模块名为'xxx'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "reference_sentence": "| First attempt: $ERRMSG. | 首先加载后缀不拼接'_napi'的模块名为'xxx'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "line_num": 30,
      "context": "{\"25\":\"\",\"26\":\"5. 如果有明确的Error message，可以通过Error message判断当前问题。\",\"27\":\"\",\"28\":\"| **Error message** | **修改建议** |\",\"29\":\"| -------- | -------- |\",\"30\":\"| First attempt: $ERRMSG. | 首先加载后缀不拼接'_napi'的模块名为'xxx'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |\",\"31\":\"| Second attempt: $ERRMSG. | 第二次加载后缀拼接'_napi'的模块名为'xxx_napi'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |\",\"32\":\"| try to load abc file from xxx failed. | 第三次加载名字为'xxx'的abc文件，如果加载失败会有该错误信息。 |\",\"33\":\"| module xxx is not allowed to load in restricted runtime. | 该模块不允许在受限运行时中使用，xxx表示模块名，建议用户删除该模块。 |\",\"34\":\"| module xxx is in blocklist, loading prohibited. | 该模块不允许在当前extension下使用，xxx表示模块名，建议用户删除该模块。 |\",\"35\":\"\"}",
      "用户拒绝的修改": "| First attempt: $ERRMSG. | 首先加载后缀不拼接'_napi'的模块名'xxx'，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "注意事项": "修复时必须严格保持术语结构完整性（如\"模块名为xxx的so\"不可简化为\"模块名xxx\"），并检查上下文是否存在已建立的统一表达模式（如\"名为xxx\"的固定搭配）。"
    },
    {
      "defect_id": 405227,
      "sentence": "包含执行方舟字节码的解释器、快速路径内联缓存以及[文件模块化管理运行](module-principle.md)。",
      "reference_sentence": "ArkTS运行时是OpenHarmony上应用默认语言运行时，运行着ArkTS、TS、JS语言的字节码和相关标准库，支持解释器、AOT和JIT高效执行方式，并提供完善的跨语言调用接口实现[Node-API](../napi/napi-introduction.md)，支持多语言混合开发。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"ArkTS Runtime主要由四个子系统组成：\",\"6\":\"\",\"7\":\"- **Core Subsystem**：主要由与语言无关的基础运行库组成，包括承载字节码的File组件、支持Debugger的Tooling组件、负责适配系统调用的Base库组件等。\",\"8\":\"\",\"9\":\"- **Execution Subsystem**：包含执行方舟字节码的解释器、快速路径内联缓存以及[文件模块化管理运行](module-principle.md)。\",\"10\":\"\",\"11\":\"- **Compiler Subsystem**：包含Stub编译器、基于IR的编译优化框架、AOT静态编译器和JIT动态编译器（实验中）。\",\"12\":\"\",\"13\":\"- **Runtime subsystem**：包含以下ArkTS/TS/JS运行相关的模块。\",\"14\":\"\"}",
      "用户拒绝的修改": "包含执行方舟字节码的解释器、快速路径内联缓存以及[文件模块化管理](module-principle.md)。",
      "注意事项": "修复时应严格区分并保留文档中已定义的特定术语（如\"运行\"与\"执行\"在上下文中的模块化分工），避免混淆不同子系统的功能表述，优先核对参考句子的术语使用逻辑。"
    },
    {
      "defect_id": 405223,
      "sentence": "在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。",
      "reference_sentence": "在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "用户拒绝的修改": "参考[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)，根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，实现跨语言交互。",
      "注意事项": "确保句式结构统一，优先使用祈使句并保持状语位置一致性；在调整语序时需兼顾前后分句逻辑衔接，避免破坏原有操作流程的连贯性。"
    },
    {
      "defect_id": 404849,
      "sentence": "| Second attempt: $ERRMSG. | 第二次加载后缀拼接'_napi'的模块名为'xxx_napi'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "reference_sentence": "| Second attempt: $ERRMSG. | 第二次加载后缀拼接'_napi'的模块名为'xxx_napi'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "line_num": 31,
      "context": "{\"26\":\"5. 如果有明确的Error message，可以通过Error message判断当前问题。\",\"27\":\"\",\"28\":\"| **Error message** | **修改建议** |\",\"29\":\"| -------- | -------- |\",\"30\":\"| First attempt: $ERRMSG. | 首先加载后缀不拼接'_napi'的模块名为'xxx'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |\",\"31\":\"| Second attempt: $ERRMSG. | 第二次加载后缀拼接'_napi'的模块名为'xxx_napi'的so，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |\",\"32\":\"| try to load abc file from xxx failed. | 第三次加载名字为'xxx'的abc文件，如果加载失败会有该错误信息。 |\",\"33\":\"| module xxx is not allowed to load in restricted runtime. | 该模块不允许在受限运行时中使用，xxx表示模块名，建议用户删除该模块。 |\",\"34\":\"| module xxx is in blocklist, loading prohibited. | 该模块不允许在当前extension下使用，xxx表示模块名，建议用户删除该模块。 |\",\"35\":\"\",\"36\":\"## 接口执行结果非预期，日志显示occur exception need return\"}",
      "用户拒绝的修改": "| Second attempt: $ERRMSG. | 第二次加载后缀拼接'_napi'的模块名'xxx_napi'，如果加载失败会有该错误信息，$ERRMSG表示具体加载时的错误信息。 |",
      "注意事项": "修复时必须严格保持\"模块名为'xxx'的so\"的完整结构表述，禁止省略关键介词\"为\"和类型说明\"的so\"，需与上下文其他条目（如第30行）保持完全一致的术语表达框架。"
    },
    {
      "defect_id": 405441,
      "sentence": "1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。",
      "reference_sentence": "1. **创建和分配内存**：允许开发者指定大小初始化Buffer，创建后拥有固定的内存容量。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\\\<number\\\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。\",\"34\":\"\",\"35\":\"FastBuffer模块的核心功能包括：\",\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\",\"39\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。\",\"40\":\"\",\"41\":\"3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"42\":\"\"}",
      "用户拒绝的修改": "1. **创建和分配内存**：允许开发者指定大小初始化FastBuffer，创建后拥有固定的内存容量。",
      "注意事项": "修复时必须严格保留原始术语（如\"uint32限制\"）和关键限定条件，避免因过度简化丢失技术细节；需结合上下文确认参数类型（如Buffer/FastBuffer）是否与当前模块描述一致。"
    },
    {
      "defect_id": 405481,
      "sentence": "线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。",
      "reference_sentence": "线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、ArrayList、LinkedList、Deque、Queue和Stack。",
      "line_num": 4,
      "context": "{\"1\":\"# 线性容器\",\"2\":\"\",\"3\":\"\",\"4\":\"线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、List、LinkedList、Deque、Queue和Stack。\",\"5\":\"\",\"6\":\"\",\"7\":\"线性容器充分考虑了数据访问的速度，运行时（Runtime）通过一条字节码指令就可以完成增、删、改、查等操作。\",\"8\":\"\",\"9\":\"## 各线性容器类型特征对比\"}",
      "用户拒绝的修改": "线性容器实现能按顺序访问的数据结构，其底层主要通过数组实现，包括ArrayList、Vector、ArrayList、LinkedList、Deque、Queue和Stack。",
      "注意事项": "修复时必须严格区分技术术语层级（如接口List与实现类ArrayList），在用户确认原文正确时优先保留原内容，避免因概念混淆导致重复或错误修改。"
    },
    {
      "defect_id": 405419,
      "sentence": "输出结果如下所示：",
      "reference_sentence": "调用转换函数并打印结果。",
      "line_num": 76,
      "context": "{\"71\":\"   let result: object = conv.fastConvertToJSObject(xml, options);\",\"72\":\"   let strRes: string = JSON.stringify(result); // 将js对象转换为json字符串，用于显式输出\",\"73\":\"   console.info(strRes);\",\"74\":\"   ```\",\"75\":\"\",\"76\":\"   输出结果如下所示：\",\"77\":\"\",\"78\":\"   ```json\",\"79\":\"   strRes:\",\"80\":\"   {\\\"_declaration\\\":{\\\"_attributes\\\":{\\\"version\\\":\\\"1.0\\\",\\\"encoding\\\":\\\"utf-8\\\"}},\\\"_elements\\\":[{\\\"_type\\\":\\\"element\\\",\\\"_name\\\":\\\"note\\\",\",\"81\":\"    \\\"_attributes\\\":{\\\"importance\\\":\\\"high\\\",\\\"logged\\\":\\\"true\\\"},\\\"_elements\\\":[{\\\"_type\\\":\\\"element\\\",\\\"_name\\\":\\\"title\\\",\\\"_parent\\\":\\\"note\\\",\"}",
      "用户拒绝的修改": "查看输出结果。",
      "注意事项": "修复时应优先识别上下文语境中的功能差异（如结果展示 vs. 操作指令），避免机械统一句式；需保留技术文档中\"如下所示\"类引导词与后续代码/结果的逻辑衔接，而非强行转换为祈使句。"
    },
    {
      "defect_id": 405482,
      "sentence": "可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：：",
      "reference_sentence": "可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：",
      "line_num": 48,
      "context": "{\"43\":\"\",\"44\":\"List和[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)相比，LinkedList是双向链表，支持快速在头部和尾部进行增删操作，而List是单向链表，不支持双向操作。\",\"45\":\"\",\"46\":\"当需要频繁的插入删除元素，并且需要使用单向链表时，推荐使用List高效操作。\",\"47\":\"\",\"48\":\"可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：：\",\"49\":\"\",\"50\":\"| 操作 | 方法 | 描述 |\",\"51\":\"| --------- | ------- | ------- |\",\"52\":\"| 增加元素 | add(element: T) | 在数组尾部增加一个元素。 |\",\"53\":\"| 增加元素 | insert(element: T, index: number) | 在指定位置增加一个元素。 |\"}",
      "用户拒绝的修改": "可以通过get/set等接口修改存储的元素，List支持增、删、改、查操作，常用API如下：",
      "注意事项": "修复时应严格检查标点符号的一致性（如多余冒号），并同步核对上下文格式规范，避免因局部修复导致与相邻段落产生重复或冲突。"
    },
    {
      "defect_id": 405526,
      "sentence": "| 访问元素 | list[index: number] | 获取指定index位置对应的元素，但会导致未定义结果。 |",
      "reference_sentence": "| 访问元素 | list[index: number] | 获取指定index位置对应的元素，但会导致未定义结果。 |",
      "line_num": 85,
      "context": "{\"80\":\"| 操作 | 方法 | 描述 |\",\"81\":\"| --------- | ------- | ------- |\",\"82\":\"| 增加元素 | add(element: T) | 在数组尾部增加一个元素。 |\",\"83\":\"| 增加元素 | insert(element: T, index: number) | 在指定位置插入一个元素。 |\",\"84\":\"| 访问元素 | get(index: number) | 获取指定index位置对应的元素。 |\",\"85\":\"| 访问元素 | list[index: number] | 获取指定index位置对应的元素，但会导致未定义结果。 |\",\"86\":\"| 访问元素 | getFirst() | 获取第一个元素。 |\",\"87\":\"| 访问元素 | getLast() | 获取最后一个元素。 |\",\"88\":\"| 访问元素 | getIndexOf(element: T) | 获取第一个匹配指定元素的位置。 |\",\"89\":\"| 访问元素 | getLastIndexOf(element: T) | 获取最后一个匹配指定元素的位置。 |\",\"90\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, list?: LinkedList&lt;T&gt;) =&gt; void, thisArg?: Object) | 遍历访问整个LinkedList容器的的每个元素，并执行指定的回调函数。 |\"}",
      "用户拒绝的修改": "| 访问元素 | LinkedList[index: number] | 获取指定index位置对应的元素，但会导致未定义结果。 |",
      "注意事项": "修复时需全局检查术语一致性，避免局部修正导致概念混用；优先使用文档中已高频出现的统一命名（如\"LinkedList\"），若存在多术语指代同一概念需明确注释或统一替换。"
    },
    {
      "defect_id": 405483,
      "sentence": "修改指定index位置的元素值为element素时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。",
      "reference_sentence": "修改指定index位置的元素值为element时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。",
      "line_num": 63,
      "context": "{\"58\":\"| 访问元素 | getIndexOf(element: T) | 获取第一个匹配指定元素的位置。 |\",\"59\":\"| 访问元素 | getLastIndexOf(element: T) | 获取最后一个匹配指定元素的位置。 |\",\"60\":\"| 访问元素 | forEach(callbackfn: (value:T, index?: number, list?: List&lt;T&gt;)=&gt; void,thisArg?: Object) | 遍历访问整个List容器中的每个元素，并执行指定的回调函数。 |\",\"61\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"62\":\"| 修改元素 | set(index:number, element: T) | 修改指定index位置的元素值为element。 |\",\"63\":\"| 修改元素 | list[index] = element | 修改指定index位置的元素值为element素时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。 |\",\"64\":\"| 修改元素 | replaceAllElements(callbackFn:(value: T,index?: number,list?: List&lt;T&gt;)=&gt;T,thisArg?: Object) | 对List内元素进行逐个替换。 |\",\"65\":\"| 删除元素 | remove(element: T) | 通过 === 运算符逐个比对链表中的元素，删除第一个匹配成功的节点。对于对象类型，只有当传入的对象与链表中某节点的引用完全一致时才会被删除。 |\",\"66\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素，如果index超出范围，则会报out of range错误。 |\",\"67\":\"\",\"68\":\"## LinkedList\"}",
      "用户拒绝的修改": "修改指定index位置的元素值为element时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。",
      "注意事项": "修复时应严格检查术语一致性，确保上下文相同概念使用完全一致的表述（如\"element\"而非\"element素\"），同时需核对相邻条目避免因局部修改导致重复性描述（如第62/63行重复出现\"修改指定index位置的元素值为element\"）。"
    },
    {
      "defect_id": 405527,
      "sentence": "| 访问元素 | list[index] = element | 修改指定index位置的元素值为element，但会导致未定义结果。 |",
      "reference_sentence": "| 修改元素 | list[index] = element | 修改指定index位置的元素值为element素时，不会对链表中的实际节点进行任何更改，仅会在对象上添加一个属性，这将导致程序状态与链表实际内容不一致，从而产生未定义行为。 |",
      "line_num": 93,
      "context": "{\"88\":\"| 访问元素 | getIndexOf(element: T) | 获取第一个匹配指定元素的位置。 |\",\"89\":\"| 访问元素 | getLastIndexOf(element: T) | 获取最后一个匹配指定元素的位置。 |\",\"90\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, list?: LinkedList&lt;T&gt;) =&gt; void, thisArg?: Object) | 遍历访问整个LinkedList容器的的每个元素，并执行指定的回调函数。 |\",\"91\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"92\":\"| 修改元素 | set(index:number, element: T) | 修改指定index位置的元素值为element。 |\",\"93\":\"| 修改元素 | list[index] = element | 修改指定index位置的元素值为element，但会导致未定义结果。 |\",\"94\":\"| 删除元素 | remove(element: T) | 删除第一个匹配到的元素。 |\",\"95\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"96\":\"\",\"97\":\"## Deque\",\"98\":\"\"}",
      "用户拒绝的修改": "| 修改元素 | LinkedList[index] = element | 修改指定index位置的元素值为element，但会导致未定义结果。 |",
      "注意事项": "确保术语使用与上下文完全一致，避免混合数据结构名称（如list/LinkedList）导致概念混淆；修改时应全面检查相邻条目和参考句子的表述规范，保持变量命名和操作描述的统一性。"
    },
    {
      "defect_id": 405532,
      "sentence": "| 访问元素 | getLastElement() | 获取最后一个元素。 |",
      "reference_sentence": "| 访问元素 | getLast() | 获取最后一个元素。 |",
      "line_num": 184,
      "context": "{\"179\":\"| 增加元素 | add(element: T) | 在数组尾部增加一个元素。 |\",\"180\":\"| 增加元素 | insert(element: T, index: number) | 在指定位置插入一个元素。 |\",\"181\":\"| 访问元素 | get(index: number) | 获取指定index位置对应的元素。 |\",\"182\":\"| 访问元素 | vec[index: number] | 获取指定index位置对应的元素，通过指令获取保证访问速度。 |\",\"183\":\"| 访问元素 | getFirst() | 获取第一个元素。 |\",\"184\":\"| 访问元素 | getLastElement() | 获取最后一个元素。 |\",\"185\":\"| 访问元素 | getIndexOf(element: T) | 获取第一个匹配指定元素的位置。 |\",\"186\":\"| 访问元素 | getLastIndexOf(element: T) | 获取最后一个匹配指定元素的位置。 |\",\"187\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, Vector?: Vector&lt;T&gt;) =&gt; void, thisArg?: Object) | 遍历访问整个Vector容器的每个元素，并执行指定的回调函数。 |\",\"188\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"189\":\"| 修改元素 | set(index:number, element: T) | 修改指定index位置的元素值为element。 |\"}",
      "用户拒绝的修改": "| 访问元素 | getLast() | 获取最后一个元素。 |",
      "注意事项": "修复时必须严格校验上下文命名规范，若原文方法名在同类操作中保持唯一命名结构（如getFirst/getLast），则不应擅自添加冗余词汇；同时需确保修改理由准确反映真实的不一致类型（如方法名与描述重复vs术语不统一）。"
    },
    {
      "defect_id": 405626,
      "sentence": "非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。",
      "reference_sentence": "非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的键及值的类型均满足ECMA标准。",
      "line_num": 4,
      "context": "{\"1\":\"# 非线性容器\",\"2\":\"\",\"3\":\"\",\"4\":\"非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的key及value的类型均满足ECMA标准。\",\"5\":\"\",\"6\":\"## 各非线性容器类型特征对比\",\"7\":\"\",\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\"}",
      "用户拒绝的修改": "非线性容器实现能快速查找的数据结构，其底层通过hash或者红黑树实现，包括HashMap、HashSet、TreeMap、TreeSet、LightWeightMap、LightWeightSet、PlainArray七种。非线性容器中的键及值的类型均满足ECMA标准。",
      "注意事项": "修复术语一致性时需优先保留技术领域常用英文术语（如key/value），避免机械翻译为中文；同时检查上下文是否存在已统一的术语用法，确保修改符合领域惯例及用户偏好。"
    },
    {
      "defect_id": 405629,
      "sentence": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。",
      "reference_sentence": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由键、值两个值组成。在HashSet中，只处理值对象。",
      "line_num": 26,
      "context": "{\"21\":\"\",\"22\":\"HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。\",\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\",\"26\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。\",\"27\":\"\",\"28\":\"需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。\",\"29\":\"\",\"30\":\"HashMap支持增、删、改、查操作，常用API如下：\",\"31\":\"\"}",
      "用户拒绝的修改": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由键、值两个值组成。在HashSet中，只处理值对象。",
      "注意事项": "保持术语一致性时应优先保留原文英文专业词汇（如\"key/value\"），仅在上下文明确使用中文译名（如\"键/值\"）时进行统一替换，避免过度翻译技术领域通用术语。"
    },
    {
      "defect_id": 405634,
      "sentence": "## TreeMap",
      "reference_sentence": "## HashMap",
      "line_num": 69,
      "context": "{\"64\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"65\":\"| 修改元素 | forEach(callbackFn: (value?: T, key?: T, set?: HashSet\\\\<T>) => void, thisArg?: Object) | 通过遍历修改整个set的元素。 |\",\"66\":\"| 删除元素 | remove(value: T) | 删除指定的元素。 |\",\"67\":\"| 删除元素 | clear() | 清空整个set。 |\",\"68\":\"\",\"69\":\"## TreeMap\",\"70\":\"\",\"71\":\"[TreeMap](../reference/apis-arkts/js-apis-treemap.md)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。\",\"72\":\"\",\"73\":\"TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。\",\"74\":\"\"}",
      "用户拒绝的修改": "### TreeMap",
      "注意事项": "修复标题格式时应优先检查上下文中的现有标题层级结构，确保不改变原有标记级别（如保持##不变），仅调整格式符号或空格等非层级要素来维持一致性。"
    },
    {
      "defect_id": 405635,
      "sentence": "TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。",
      "reference_sentence": "HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "line_num": 73,
      "context": "{\"68\":\"\",\"69\":\"## TreeMap\",\"70\":\"\",\"71\":\"[TreeMap](../reference/apis-arkts/js-apis-treemap.md)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。\",\"72\":\"\",\"73\":\"TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。\",\"74\":\"\",\"75\":\"TreeMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"76\":\"\",\"77\":\"一般需要存储有序键值对的场景，可以使用TreeMap。\",\"78\":\"\"}",
      "用户拒绝的修改": "TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。TreeMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。",
      "注意事项": "修复时应严格校验新增内容与上下文技术细节的一致性，避免跨数据结构错误移植特性（如TreeMap不涉及容量扩容机制），同时保持段落间描述风格统一，确保补充信息与原主题紧密相关且不存在冲突。"
    },
    {
      "defect_id": 405631,
      "sentence": "## HashSet",
      "reference_sentence": "## HashMap",
      "line_num": 46,
      "context": "{\"41\":\"| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |\",\"42\":\"| 修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 通过遍历修改整个map的元素。 |\",\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\",\"47\":\"\",\"48\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\"}",
      "用户拒绝的修改": "### HashSet",
      "注意事项": "修复标题格式时必须先确认文档整体层级结构，当用户明确维护tag层级时应优先保持原标记级别，仅调整格式符号（如添加/删除#号）而不改变标题等级，同时检查参考案例的完整上下文确保修改依据的准确性。"
    },
    {
      "defect_id": 405630,
      "sentence": "| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |",
      "reference_sentence": "| 修改元素 | replace(key: K, newValue: V) | 修改指定键对应的值。 |",
      "line_num": 41,
      "context": "{\"36\":\"| 访问元素 | keys() | 返回一个迭代器对象，包含map中的所有key值。 |\",\"37\":\"| 访问元素 | values() | 返回一个迭代器对象，包含map中的所有value值。 |\",\"38\":\"| 访问元素 | entries() | 返回一个迭代器对象，包含map中的所有键值对。 |\",\"39\":\"| 访问元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 遍历访问整个map的元素。 |\",\"40\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;[K,V]&gt; | 创建迭代器以访问数据。 |\",\"41\":\"| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |\",\"42\":\"| 修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 通过遍历修改整个map的元素。 |\",\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\"}",
      "用户拒绝的修改": "| 修改元素 | replace(key: K, newValue: V) | 修改指定键对应的值。 |",
      "注意事项": "保持术语中英文使用严格统一，若参数名使用英文（如key/value），对应描述应优先保留英文形式或与相邻条目表述一致，避免在\"键/值\"和\"key/value\"间混用。需特别检查上下文中相同语义字段的表述模式（如观察问题上下文第36-44行存在\"key值/value值\"与\"键值对\"共存的案例）。"
    },
    {
      "defect_id": 405637,
      "sentence": "TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。",
      "reference_sentence": "HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，而TreeSet中的数据有序存放。",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"TreeSet依据泛型定义，值是有序存储的，底层基于红黑树实现，支持快速的插入和删除。value的类型满足ECMA标准。\",\"102\":\"\",\"103\":\"TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。\",\"104\":\"\",\"105\":\"TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。两者集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"106\":\"\",\"107\":\"一般需要存储有序集合的场景，可以使用TreeSet。\",\"108\":\"\",\"109\":\"TreeSet支持增、删、改、查操作，常用API如下：\",\"110\":\"\"}",
      "用户拒绝的修改": "TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet中的数据有序存放。",
      "注意事项": "在保持句式结构对称时，需避免重复主语（如\"数据\"）导致冗余，优先通过省略或代词替代实现简洁性，同时确保核心术语（如\"存放\"）在全文中保持严格一致。"
    },
    {
      "defect_id": 405627,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。",
      "reference_sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、删除以及插入键值对数据时推荐使用。",
      "line_num": 10,
      "context": "{\"5\":\"\",\"6\":\"## 各非线性容器类型特征对比\",\"7\":\"\",\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\"}",
      "用户拒绝的修改": "存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、删除以及插入键值对数据时推荐使用。",
      "注意事项": "修复时应严格保持并列结构的语法一致性，避免混用不同连接词（如\"、\"/\"以及\"）；同时需核对上下文同类表述，确保术语顺序（如\"存取、插入删除\"）与文档整体风格统一。"
    },
    {
      "defect_id": 408190,
      "sentence": "开发者可以在导出的日志文件中搜索关键词`[gc]`查看GC相关日志，或搜索关键词`ArkCompiler`查看更全面的虚拟机相关日志。",
      "reference_sentence": "### 典型日志",
      "line_num": 336,
      "context": "{\"331\":\"hdc shell reboot\",\"332\":\"```\",\"333\":\"\",\"334\":\"### 典型日志\",\"335\":\"\",\"336\":\"以下日志统计了GC完整执行后的信息，不同GC类型可能有所差异。开发者可以在导出的日志文件中搜索关键词`[gc]`查看GC相关日志，或搜索关键词`ArkCompiler`查看更全面的虚拟机相关日志。\",\"337\":\"\",\"338\":\"```\",\"339\":\"// GC前对象实际占用大小（Region实际占用大小）->GC后对象实际占用大小（Region实际占用大小），总耗时（+concurrentMark耗时），GC触发原因。\",\"340\":\"C03F00/ArkCompiler: [gc]  [ CompressGC ] 26.1164 (35) -> 7.10049 (10.5) MB, 160.626(+0)ms, Switch to background\",\"341\":\"// GC运行时的各种状态以及应用名称\"}",
      "用户拒绝的修改": "开发者可以在导出的日志文件中搜索关键词`[gc]`查看GC日志，或搜索关键词`ArkCompiler`查看更全面的虚拟机日志。",
      "注意事项": "保持术语一致性时需优先沿用原文中的限定词（如\"相关日志\"），避免在并列结构中混合使用不同修饰方式；修改前需核对上下文是否存在相同表述模式，确保同类型操作的描述结构完全对称。"
    },
    {
      "defect_id": 408186,
      "sentence": "#### 第二次及以后的OldGC对old Space/global space阈值调整，以及增长因子的调整",
      "reference_sentence": "#### Old GC- **触发机制**：老年代GC触发阈值在20MB-300多MB变化，大部分情况，第一次Old GC的阈值在20M左右，之后会根据对象存活率，内存占用大小进行阈值调整。",
      "line_num": 266,
      "context": "{\"261\":\"\",\"262\":\"- 函数方法：`AdjustOldSpaceLimit`\",\"263\":\"- 说明：根据最小增长步长以及平均存活率调整OldSpace阈值限制。\",\"264\":\"- 日志关键词：`AdjustOldSpaceLimit`。\",\"265\":\"\",\"266\":\"#### 第二次及以后的OldGC对old Space/global space阈值调整，以及增长因子的调整\",\"267\":\"\",\"268\":\"- 函数方法：`RecomputeLimits`\",\"269\":\"- 说明：根据当前GC统计的数据变化，重新计算并调整`newOldSpaceLimit`、`newGlobalSpaceLimit`、`globalSpaceNativeLimit`和增长因子。\",\"270\":\"- 日志关键词：`RecomputeLimits`。\",\"271\":\"\"}",
      "用户拒绝的修改": "#### 第二次及以后的Old GC对老年代/全局空间阈值调整，以及增长因子的调整",
      "注意事项": "在技术文档中涉及代码变量/函数名（如`oldSpaceLimit`）时，必须保留英文原词并保持大小写一致，避免强行中文化；需严格检查上下文术语使用场景（如参考句中的\"老年代\"对应通用概念，而问题句的\"old Space\"特指代码变量）。"
    },
    {
      "defect_id": 407637,
      "sentence": "组件走焦换行规则。",
      "reference_sentence": "组件的UI状态枚举，用于处理状态样式。",
      "line_num": 197,
      "context": "{\"192\":\"| [ArkUI_RouterPageState](_ark_u_i___native_module.md#arkui_routerpagestate) {<br/>[ARKUI_ROUTER_PAGE_STATE_ON_WILL_APPEAR](_ark_u_i___native_module.md) = 0, [ARKUI_ROUTER_PAGE_STATE_ON_WILL_DISAPPEAR](_ark_u_i___native_module.md) = 1, [ARKUI_ROUTER_PAGE_STATE_ON_SHOW](_ark_u_i___native_module.md) = 2, [ARKUI_ROUTER_PAGE_STATE_ON_HIDE](_ark_u_i___native_module.md) = 3,<br/>[ARKUI_ROUTER_PAGE_STATE_ON_BACK_PRESS](_ark_u_i___native_module.md) = 4<br/>} | 定义Router Page的状态。  | \",\"193\":\"| [ArkUI_DatePickerMode](_ark_u_i___native_module.md#arkui_datepickermode) { <br/>[ARKUI_DATEPICKER_MODE_DATE](_ark_u_i___native_module.md) = 0, [ARKUI_DATEPICKER_YEAR_AND_MONTH](_ark_u_i___native_module.md) = 1, [ARKUI_DATEPICKER_MONTH_AND_DAY](_ark_u_i___native_module.md) = 2 <br/>} | 定义要显示的日期选项列样式。 | \",\"194\":\"| [ArkUI_ExpandMode](_ark_u_i___native_module.md#arkui_expandmode) { <br/>[ARKUI_NOT_EXPAND](_ark_u_i___native_module.md) = 0, [ARKUI_EXPAND](_ark_u_i___native_module.md) = 1, [ARKUI_LAZY_EXPAND](_ark_u_i___native_module.md) = 2 <br/>} | 定义子节点展开模式枚举值。 | \",\"195\":\"| [ArkUI_ListItemGroupArea](_ark_u_i___native_module.md#arkui_listitemgrouparea) { <br/>[ARKUI_LIST_ITEM_GROUP_AREA_OUTSIDE](_ark_u_i___native_module.md) = 0, [ARKUI_LIST_ITEM_SWIPE_AREA_NONE](_ark_u_i___native_module.md), [ARKUI_LIST_ITEM_SWIPE_AREA_ITEM](_ark_u_i___native_module.md), [ARKUI_LIST_ITEM_SWIPE_AREA_HEADER](_ark_u_i___native_module.md), [ARKUI_LIST_ITEM_SWIPE_AREA_FOOTER](_ark_u_i___native_module.md) <br/>} | 定义组件区域的枚举值。 | \",\"196\":\"| [ArkUI_UIState](_ark_u_i___native_module.md#arkui_uistate) { <br/>[UI_STATE_NORMAL](_ark_u_i___native_module.md) = 0, [UI_STATE_PRESSED](_ark_u_i___native_module.md) = 1 &lt;&lt; 0, [UI_STATE_FOCUSED](_ark_u_i___native_module.md) = 1 &lt;&lt; 1, [UI_STATE_DISABLED](_ark_u_i___native_module.md) = 1 &lt;&lt; 2, [UI_STATE_SELECTED](_ark_u_i___native_module.md) = 1 &lt;&lt; 3 <br/>} | 组件的UI状态枚举，用于处理状态样式。 | \",\"197\":\"| [ArkUI_FocusWrapMode](_ark_u_i___native_module.md#arkui_focuswrapmode) { <br/>[FOCUS_WRAP_MODE_DEFAULT](_ark_u_i___native_module.md) = 0,  [FOCUS_WRAP_WITH_ARROW](_ark_u_i___native_module.md) = 1 <br/>} | 组件走焦换行规则。<br/>**起始版本：** 20  |\",\"198\":\"\",\"199\":\"\",\"200\":\"### 函数\",\"201\":\"\",\"202\":\"| 名称 | 描述 | \"}",
      "用户拒绝的修改": "组件的走焦换行规则枚举。",
      "注意事项": "修复时应严格遵循跨仓库术语和结构一致性，优先匹配参考句式的\"名词+枚举\"前置描述模式，并校验上下文同类条目是否采用\"定义...\"的统一句式，避免局部添加修饰词破坏整体规范。"
    },
    {
      "defect_id": 409172,
      "sentence": "fdsan针对的操作对象是文件描述符，主要用于检测不同使用者对相同文件描述符的错误操作，包括多次关闭（double-close）和关闭后使用（use-after-close)。",
      "reference_sentence": "fdsan针对的操作对象是文件描述符，主要用于检测不同使用者对相同文件描述符的错误操作，包括多次关闭（double-close）和关闭后使用（use-after-close)。",
      "line_num": 5,
      "context": "{\"1\":\"# fdsan使用指导\",\"2\":\"\",\"3\":\"## 1. 功能介绍\",\"4\":\"\",\"5\":\"fdsan针对的操作对象是文件描述符，主要用于检测不同使用者对相同文件描述符的错误操作，包括多次关闭（double-close）和关闭后使用（use-after-close)。这些文件描述符可以是操作系统中的文件、目录、网络套接字和其他I/O设备等，在程序中，打开文件或套接字会生成一个文件描述符，如果此文件描述符在使用后出现反复关闭、或者关闭后使用等场景，就会造成内存泄露、文件句柄泄露等安全隐患问题。该类问题非常隐蔽，且难以排查，为了更好地检测此类问题，因此引入了此种针对文件描述符错误操作的检测工具fdsan。\",\"6\":\"\",\"7\":\"## 2. 实现原理\",\"8\":\"\",\"9\":\"设计思路：当打开已有文件或创建一个新文件的时候，在得到返回fd后，设置一个关联的tag，来标记fd的属主信息；关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常文件关闭流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。\",\"10\":\"\"}",
      "用户拒绝的修改": "fdsan针对的操作对象是文件描述符，主要用于检测不同使用者对相同文件描述符的错误操作，包括多次关闭（double-close）和关闭后使用（关闭后使用）。",
      "注意事项": "修复术语混用时应优先保持上下文原有术语形式，若原文已形成中英文使用惯例（如技术名词保留英文），需严格遵循现有模式而非强制统一语种。"
    },
    {
      "defect_id": 409175,
      "sentence": "disabled，此level代表什么都不处理。",
      "reference_sentence": "disabled，此level代表什么都不处理。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"**参数：** fdsan_error_level\",\"34\":\"\",\"35\":\"| 名称                       | 说明                                                         |\",\"36\":\"| -------------------------- | ------------------------------------------------------------ |\",\"37\":\"| `FDSAN_ERROR_LEVEL_DISABLED` | disabled，此level代表什么都不处理。                         |\",\"38\":\"| `FDSAN_ERROR_LEVEL_WARN_ONCE` | warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。 |\",\"39\":\"| `FDSAN_ERROR_LEVEL_WARN_ALWAYS` | warn-always，每次出现错误时都在hilog中发出警告。 |\",\"40\":\"| `FDSAN_ERROR_LEVEL_FATAL` | fatal，出现错误时调用abort异常退出。 |\",\"41\":\"\",\"42\":\"**返回值：** 返回旧的error_level。\"}",
      "用户拒绝的修改": "此level，代表什么都不处理。",
      "注意事项": "修复时必须严格匹配上下文中的参数名称（如`FDSAN_ERROR_LEVEL_DISABLED`），优先保留参数对应的英文术语直译（如\"禁用模式\"），禁止将参数名关键术语（disabled）与代称（此level）混用。"
    },
    {
      "defect_id": 408832,
      "sentence": "用于将给定的ArkTS value强转成ArkTS Boolean对象。",
      "reference_sentence": "用于将给定的ArkTS value强转成ArkTS boolean值。",
      "line_num": 219,
      "context": "{\"214\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_coerce_to_string:%{public}s', bool);\",\"215\":\"```\",\"216\":\"\",\"217\":\"### napi_get_boolean\",\"218\":\"\",\"219\":\"用于根据给定的C boolean值，获取等价的ArkTS Boolean对象。\",\"220\":\"\",\"221\":\"cpp部分代码\",\"222\":\"\",\"223\":\"```cpp\",\"224\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "用于将给定的ArkTS value强转成ArkTS boolean值。",
      "注意事项": "严格保持技术术语一致性，区分\"对象\"与\"值\"的技术差异；修复前需结合上下文确认返回值类型（如参考219行明确使用\"Boolean对象\"），避免脱离技术语境进行字面替换。"
    },
    {
      "defect_id": 409176,
      "sentence": "warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。",
      "reference_sentence": "warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。",
      "line_num": 38,
      "context": "{\"33\":\"**参数：** fdsan_error_level\",\"34\":\"\",\"35\":\"| 名称                       | 说明                                                         |\",\"36\":\"| -------------------------- | ------------------------------------------------------------ |\",\"37\":\"| `FDSAN_ERROR_LEVEL_DISABLED` | disabled，此level代表什么都不处理。                         |\",\"38\":\"| `FDSAN_ERROR_LEVEL_WARN_ONCE` | warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。 |\",\"39\":\"| `FDSAN_ERROR_LEVEL_WARN_ALWAYS` | warn-always，每次出现错误时都在hilog中发出警告。 |\",\"40\":\"| `FDSAN_ERROR_LEVEL_FATAL` | fatal，出现错误时调用abort异常退出。 |\",\"41\":\"\",\"42\":\"**返回值：** 返回旧的error_level。\",\"43\":\"\"}",
      "用户拒绝的修改": "此level，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。",
      "注意事项": "修复时应确保术语使用与上下文完全一致，优先采用文档已有表述（如\"记录警告信息\"而非\"发出警告\"），并严格匹配技术场景的动词选择（如日志场景用\"记录\"而非\"发出\"）。"
    },
    {
      "defect_id": 409180,
      "sentence": "默认非法fd对应的type值。",
      "reference_sentence": "默认非法fd对应的type值。",
      "line_num": 65,
      "context": "{\"60\":\"**参数：** fdsan_owner_type\",\"61\":\"\",\"62\":\"| 名称                       | 说明                                                         |\",\"63\":\"| -------------------------- | ------------------------------------------------------------ |\",\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\",\"70\":\"\"}",
      "用户拒绝的修改": "默认非法文件描述符对应的type值。",
      "注意事项": "修复术语时应优先检查上下文既有使用习惯（如参数名\"fdsan_owner_type\"和字段\"unique_fd\"均使用缩写），保持与代码元素命名的一致性，避免将合理缩写强行展开为全称。"
    },
    {
      "defect_id": 409182,
      "sentence": "默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。",
      "reference_sentence": "默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。",
      "line_num": 67,
      "context": "{\"62\":\"| 名称                       | 说明                                                         |\",\"63\":\"| -------------------------- | ------------------------------------------------------------ |\",\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\",\"70\":\"\",\"71\":\"**返回值：** 返回创建的tag，可以用于fdsan_exchange_owner_tag函数的输入。\",\"72\":\"\"}",
      "用户拒绝的修改": "默认文件对应的type值，使用opendir或fdopendir打开的文件具有该类型。",
      "注意事项": "修复时应严格核对上下文术语定义（如`FDSAN_OWNER_TYPE_DIRECTORY`明确关联\"文件夹\"），并确认API功能语义（opendir/fdopendir操作对象为目录），避免脱离技术语境强行统一用词。"
    },
    {
      "defect_id": 409179,
      "sentence": "默认未使用fd对应的type值。",
      "reference_sentence": "默认未使用fd对应的type值。",
      "line_num": 64,
      "context": "{\"59\":\"\",\"60\":\"**参数：** fdsan_owner_type\",\"61\":\"\",\"62\":\"| 名称                       | 说明                                                         |\",\"63\":\"| -------------------------- | ------------------------------------------------------------ |\",\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\"}",
      "用户拒绝的修改": "默认未使用文件描述符对应的type值。",
      "注意事项": "在替换术语前必须严格检查上下文中的现有用词规范，若原文已统一使用缩写（如\"fd\"）且无歧义，应优先保持缩写形式而非强制展开全称（如\"文件描述符\"）。"
    },
    {
      "defect_id": 409178,
      "sentence": "fatal，出现错误时调用abort异常退出。",
      "reference_sentence": "fatal，出现错误时调用abort异常退出。",
      "line_num": 40,
      "context": "{\"35\":\"| 名称                       | 说明                                                         |\",\"36\":\"| -------------------------- | ------------------------------------------------------------ |\",\"37\":\"| `FDSAN_ERROR_LEVEL_DISABLED` | disabled，此level代表什么都不处理。                         |\",\"38\":\"| `FDSAN_ERROR_LEVEL_WARN_ONCE` | warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。 |\",\"39\":\"| `FDSAN_ERROR_LEVEL_WARN_ALWAYS` | warn-always，每次出现错误时都在hilog中发出警告。 |\",\"40\":\"| `FDSAN_ERROR_LEVEL_FATAL` | fatal，出现错误时调用abort异常退出。 |\",\"41\":\"\",\"42\":\"**返回值：** 返回旧的error_level。\",\"43\":\"\",\"44\":\"### fdsan_get_error_level\",\"45\":\"\"}",
      "用户拒绝的修改": "此level，出现错误时调用abort异常退出。",
      "注意事项": "修复时必须严格核对上下文术语的完整形态（如\"异常退出\"与\"异常退出信号\"），确保全文档统一使用完整术语表述；处理枚举型内容时需交叉验证相邻条目（如error_level参数表）的句式结构和用词模式，保持表格内部表述范式的高度一致性。"
    },
    {
      "defect_id": 410452,
      "sentence": "> 由于\\@Concurrent标记的函数不能访问闭包，因此函数内部不能调用当前文件的其他函数，例如：",
      "reference_sentence": "> 由于@Concurrent标记的函数不能访问闭包，因此函数内部不能调用当前文件的其他函数，例如：",
      "line_num": 84,
      "context": "{\"79\":\"| 装饰的函数内的变量类型 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量。 |\",\"80\":\"| 装饰的函数内的返回值类型 | 支持的类型请查[线程间通信对象](interthread-communication-overview.md)。 |\",\"81\":\"\",\"82\":\"> **说明：**\",\"83\":\">\",\"84\":\"> 由于\\\\@Concurrent标记的函数不能访问闭包，因此函数内部不能调用当前文件的其他函数，例如：\",\"85\":\">\",\"86\":\"> ```ts\",\"87\":\"> function bar() {\",\"88\":\"> }\",\"89\":\"> \"}",
      "用户拒绝的修改": "> 由于@Concurrent标记的函数不能访问闭包，因此函数内部不能调用当前文件的其他函数，例如：",
      "注意事项": "保留原始文本中必要的转义符号（如\\@），避免破坏代码/文档特殊符号的渲染逻辑；修复时应严格对照用户提供的参考示例格式，而非机械执行通用转义规则。"
    },
    {
      "defect_id": 409177,
      "sentence": "warn-always，每次出现错误时都在hilog中发出警告。",
      "reference_sentence": "warn-always，每次出现错误时都在hilog中发出警告。",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"| 名称                       | 说明                                                         |\",\"36\":\"| -------------------------- | ------------------------------------------------------------ |\",\"37\":\"| `FDSAN_ERROR_LEVEL_DISABLED` | disabled，此level代表什么都不处理。                         |\",\"38\":\"| `FDSAN_ERROR_LEVEL_WARN_ONCE` | warn-once，第一次出现错误时在hilog中发出警告，然后将级别降低为disabled(FDSAN_ERROR_LEVEL_DISABLED)。 |\",\"39\":\"| `FDSAN_ERROR_LEVEL_WARN_ALWAYS` | warn-always，每次出现错误时都在hilog中发出警告。 |\",\"40\":\"| `FDSAN_ERROR_LEVEL_FATAL` | fatal，出现错误时调用abort异常退出。 |\",\"41\":\"\",\"42\":\"**返回值：** 返回旧的error_level。\",\"43\":\"\",\"44\":\"### fdsan_get_error_level\"}",
      "用户拒绝的修改": "此level，每次出现错误时都在hilog中发出警告。",
      "注意事项": "修复时必须严格核查上下文术语体系，确保同一概念在全文使用完全一致的表述方式（如\"发出警告\"与\"记录警告信息\"的选择需与相邻条目保持统一），并优先采用参考句式的核心动词结构。"
    },
    {
      "defect_id": 410945,
      "sentence": "需要使用Worker。场景示例可参考[常驻任务开发指导](resident-task-guide.md)。",
      "reference_sentence": "需要使用Worker。场景示例可参考[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"TaskPool偏向独立任务维度，该任务在线程中执行，无需关注线程的生命周期，超长任务（大于3分钟且非长时任务）会被系统自动回收。而Worker偏向线程的维度，支持长时间占据线程执行，需要开发者主动管理线程生命周期。\",\"40\":\"\",\"41\":\"常见开发场景及适用说明如下：\",\"42\":\"\",\"43\":\"- 运行时间超过3分钟的任务（不包括Promise和async/await异步调用的耗时，如网络下载、文件读写等I/O任务的耗时）：例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。场景示例可参考[常驻任务开发指导](resident-task-guide.md)。\",\"44\":\"\",\"45\":\"- 有关联的一系列同步任务：例如在一些需要创建、使用句柄的场景中，句柄每次创建都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。场景示例可参考[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。\",\"46\":\"\",\"47\":\"- 需要设置优先级的任务：在API version 18 之前，Worker不支持设置调度优先级，需要使用TaskPool。从API version 18 开始，Worker支持设置调度优先级，开发者可以根据使用场景和任务特性选择使用TaskPool或Worker。例如[图库直方图绘制场景](cpu-intensive-task-development.md#使用taskpool进行图像直方图处理)，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。\",\"48\":\"\"}",
      "用户拒绝的修改": "需要使用Worker。场景示例可参考[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。",
      "注意事项": "在修复链接一致性时，需优先确认上下文是否明确区分不同场景的示例引用，避免强制统一不同功能的文档链接；若原文链接与上下文场景严格对应，应保留原文引用而非机械替换。"
    },
    {
      "defect_id": 409184,
      "sentence": "默认zip压缩文件对应的type值，保留暂未使用。",
      "reference_sentence": "默认zip压缩文件对应的type值，保留暂未使用。",
      "line_num": 69,
      "context": "{\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\",\"70\":\"\",\"71\":\"**返回值：** 返回创建的tag，可以用于fdsan_exchange_owner_tag函数的输入。\",\"72\":\"\",\"73\":\"### fdsan_exchange_owner_tag\",\"74\":\"\"}",
      "用户拒绝的修改": "默认文件对应的type值，保留暂未使用。",
      "注意事项": "修改术语时应严格检查上下文中的同类项命名规范，保持领域专用词汇的精确性（如\"zip压缩文件\"在上下文中是特定类型名称），避免过度泛化为上位词破坏技术文档的准确性。"
    },
    {
      "defect_id": 410449,
      "sentence": "## \\@Concurrent装饰器",
      "reference_sentence": "## @Concurrent装饰器",
      "line_num": 64,
      "context": "{\"59\":\"\",\"60\":\"- TaskPool支持开发者在宿主线程封装任务并提交给任务队列，理论上支持的任务数量没有上限。然而，任务的执行效率受限于任务的优先级和系统资源。当工作线程达到最大数量时，任务的执行效率可能会下降。\",\"61\":\"\",\"62\":\"- TaskPool不支持指定任务所运行的线程，任务会被分配到空闲的线程中执行。如果需要指定任务所运行的线程，建议使用[Worker](worker-introduction.md)。\",\"63\":\"\",\"64\":\"## \\\\@Concurrent装饰器\",\"65\":\"\",\"66\":\"在使用[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)时，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。\",\"67\":\"\",\"68\":\"> **说明：**\",\"69\":\">\"}",
      "用户拒绝的修改": "## @Concurrent装饰器",
      "注意事项": "在修复Markdown转义问题时，必须优先确认目标平台的渲染规则和项目规范，保留用户明确声明无需修改的转义字符（如用户反馈中的反斜杠），避免过度纠正已符合上下文格式要求的符号。"
    },
    {
      "defect_id": 410436,
      "sentence": "TaskPool支持开发者在宿主线程封装任务并提交给任务队列，理论上支持的任务数量没有上限。然而，任务的执行效率受限于任务的优先级和系统资源。当工作线程达到最大数量时，任务的执行效率可能会下降。",
      "reference_sentence": "TaskPool支持开发者在宿主线程提交任务到任务队列，系统选择合适的工作线程执行任务，再将结果返回给宿主线程。",
      "line_num": 60,
      "context": "{\"55\":\"\",\"56\":\"- Promise不支持跨线程传递。TaskPool返回pending或rejected状态的Promise时会失败，返回fulfilled状态的Promise时TaskPool会解析返回的结果，如果结果可以跨线程传递，则返回成功。\",\"57\":\"\",\"58\":\"- 不支持在TaskPool工作线程中使用[AppStorage](../ui/state-management/arkts-appstorage.md)。\",\"59\":\"\",\"60\":\"- TaskPool支持开发者在宿主线程封装任务并提交给任务队列，理论上支持的任务数量没有上限。然而，任务的执行效率受限于任务的优先级和系统资源。当工作线程达到最大数量时，任务的执行效率可能会下降。\",\"61\":\"\",\"62\":\"- TaskPool不支持指定任务所运行的线程，任务会被分配到空闲的线程中执行。如果需要指定任务所运行的线程，建议使用[Worker](worker-introduction.md)。\",\"63\":\"\",\"64\":\"## \\\\@Concurrent装饰器\",\"65\":\"\"}",
      "用户拒绝的修改": "TaskPool支持开发者在宿主线程提交任务并提交给任务队列，理论上支持的任务数量没有上限。然而，任务的执行效率受限于任务的优先级和系统资源。当工作线程达到最大数量时，任务的执行效率可能会下降。",
      "注意事项": "在修复术语一致性时需严格校验上下文是否存在多步骤描述，避免将不同操作阶段的动词（如\"封装\"和\"提交\"）强制统一为单一动词，导致动作逻辑断裂。应优先参考文档中已明确的标准表达（如\"提交任务到任务队列\"）保持全篇术语体系一致。"
    },
    {
      "defect_id": 410450,
      "sentence": "> 从API version 9开始，支持使用\\@Concurrent装饰器声明并校验并发函数。",
      "reference_sentence": "> 从API version 9开始，支持使用@Concurrent装饰器声明并校验并发函数。",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"在使用[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)时，执行的并发函数需要使用该装饰器修饰，否则无法通过相关校验。\",\"67\":\"\",\"68\":\"> **说明：**\",\"69\":\">\",\"70\":\"> 从API version 9开始，支持使用\\\\@Concurrent装饰器声明并校验并发函数。\",\"71\":\"\",\"72\":\"### 装饰器说明\",\"73\":\"\",\"74\":\"| \\\\@Concurrent并发装饰器 | 说明 |\",\"75\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "> 从API version 9开始，支持使用@Concurrent装饰器声明并校验并发函数。",
      "注意事项": "修复转义字符时需严格检查上下文格式要求，优先保持用户原有转义策略（如代码块/表格环境），避免在非必要场景下修改已正确渲染的符号格式。"
    },
    {
      "defect_id": 409183,
      "sentence": "默认unique_fd对应的type值，保留暂未使用。",
      "reference_sentence": "默认unique_fd对应的type值，保留暂未使用。",
      "line_num": 68,
      "context": "{\"63\":\"| -------------------------- | ------------------------------------------------------------ |\",\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\",\"70\":\"\",\"71\":\"**返回值：** 返回创建的tag，可以用于fdsan_exchange_owner_tag函数的输入。\",\"72\":\"\",\"73\":\"### fdsan_exchange_owner_tag\"}",
      "用户拒绝的修改": "默认文件描述符对应的type值，保留暂未使用。",
      "注意事项": "修复术语一致性时需优先保留代码中的专有名词（如unique_fd），仅在非技术术语场景下统一为自然语言表达（如\"文件描述符\"），并严格检查上下文是否涉及直接引用的常量/变量名。"
    },
    {
      "defect_id": 410946,
      "sentence": "例如[图库直方图绘制场景](cpu-intensive-task-development.md#使用taskpool进行图像直方图处理)，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。",
      "reference_sentence": "例如[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。",
      "line_num": 47,
      "context": "{\"42\":\"\",\"43\":\"- 运行时间超过3分钟的任务（不包括Promise和async/await异步调用的耗时，如网络下载、文件读写等I/O任务的耗时）：例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。场景示例可参考[常驻任务开发指导](resident-task-guide.md)。\",\"44\":\"\",\"45\":\"- 有关联的一系列同步任务：例如在一些需要创建、使用句柄的场景中，句柄每次创建都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。场景示例可参考[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。\",\"46\":\"\",\"47\":\"- 需要设置优先级的任务：在API version 18 之前，Worker不支持设置调度优先级，需要使用TaskPool。从API version 18 开始，Worker支持设置调度优先级，开发者可以根据使用场景和任务特性选择使用TaskPool或Worker。例如[图库直方图绘制场景](cpu-intensive-task-development.md#使用taskpool进行图像直方图处理)，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。\",\"48\":\"\",\"49\":\"- 需要频繁取消的任务：例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。\",\"50\":\"\",\"51\":\"- 大量或调度点分散的任务：例如大型应用的多个模块包含多个耗时任务，不方便使用Worker去做负载管理，推荐使用TaskPool。场景示例可参考[批量数据写数据库场景](batch-database-operations-guide.md)。\"}",
      "用户拒绝的修改": "例如[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。",
      "注意事项": "确保链接文本与当前上下文讨论的具体场景和任务类型严格对应，避免跨场景错误替换；修改前需交叉验证示例链接所属的文档章节是否与当前内容逻辑一致。"
    },
    {
      "defect_id": 412933,
      "sentence": "Sendable数据需要与[makeObserved](../ui/state-management/arkts-new-makeObserved.md)联用，才可以观察Sendable对象的数据变化，具体使用请参考[makeObserved和@Sendable装饰的class配合文档](../ui/state-management/arkts-new-makeObserved.md#makeobserved和sendable装饰的class配合使用)。",
      "reference_sentence": "Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "line_num": 495,
      "context": "{\"490\":\"| 不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。 |\",\"491\":\"\",\"492\":\"\",\"493\":\"## 与UI交互的规则\",\"494\":\"\",\"495\":\"Sendable数据需要与[makeObserved](../ui/state-management/arkts-new-makeObserved.md)联用，才可以观察Sendable对象的数据变化，具体使用请参考[makeObserved和@Sendable装饰的class配合文档](../ui/state-management/arkts-new-makeObserved.md#makeobserved和sendable装饰的class配合使用)。\",\"496\":\"\",\"497\":\"\",\"498\":\"## 在HAR包中的使用规则\",\"499\":\"\",\"500\":\"HAR中使用Sendable时，需开启编译生成TS文件的配置。具体使用请参考[编译生成TS文件](../quick-start/har-package.md#编译生成ts文件)。\"}",
      "用户拒绝的修改": "Sendable数据需要与[makeObserved](../ui/state-management/arkts-new-makeObserved.md)联用，才可以观察Sendable对象的数据布局，具体使用请参考[makeObserved和@Sendable装饰的class配合文档](../ui/state-management/arkts-new-makeObserved.md#makeobserved和sendable装饰的class配合使用)。",
      "注意事项": "优先确保技术术语的准确性而非单纯用词统一，替换近义词前需结合上下文核实概念范畴（如\"数据变化\"包含值变更，\"对象布局\"特指属性结构变化），避免因术语混用导致技术性偏差。"
    },
    {
      "defect_id": 410663,
      "sentence": "const workerPort: ThreadWorkerGlobalScope = worker.workerPort;",
      "reference_sentence": "const workerPort: ThreadWorkerGlobalScope = worker.workerPort;",
      "line_num": 263,
      "context": "{\"258\":\"\",\"259\":\"      ```ts\",\"260\":\"      // worker.ets\",\"261\":\"      import { ErrorEvent, MessageEvents, ThreadWorkerGlobalScope, worker } from '@kit.ArkTS';\",\"262\":\"\",\"263\":\"      const workerPort: ThreadWorkerGlobalScope = worker.workerPort;\",\"264\":\"\",\"265\":\"      // 注册onmessage回调，当Worker线程收到来自其宿主线程通过postMessage接口发送的消息时被调用，在Worker线程执行\",\"266\":\"      workerPort.onmessage = (e: MessageEvents) => {\",\"267\":\"        let data: string = e.data;\",\"268\":\"        console.info('workerPort onmessage is: ', data);\"}",
      "用户拒绝的修改": "const workerPort: WorkerGlobalScope = worker.workerPort;",
      "注意事项": "在修复术语不一致前必须严格检查上下文导入声明和类型定义，优先保持与项目现有依赖库和类型声明的一致性，避免用通用术语覆盖框架特定的合法类型名称。"
    },
    {
      "defect_id": 410662,
      "sentence": "let workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');",
      "reference_sentence": "let workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');",
      "line_num": 222,
      "context": "{\"217\":\"                center: { anchor: '__container__', align: VerticalAlign.Center },\",\"218\":\"                middle: { anchor: '__container__', align: HorizontalAlign.Center }\",\"219\":\"              })\",\"220\":\"              .onClick(() => {\",\"221\":\"                // 创建Worker对象\",\"222\":\"                let workerInstance = new worker.ThreadWorker('entry/ets/workers/worker.ets');\",\"223\":\"\",\"224\":\"                // 注册onmessage回调，当宿主线程接收到来自其创建的Worker通过workerPort.postMessage接口发送的消息时被调用，在宿主线程执行\",\"225\":\"                workerInstance.onmessage = (e: MessageEvents) => {\",\"226\":\"                  let data: string = e.data;\",\"227\":\"                  console.info('workerInstance onmessage is: ', data);\"}",
      "用户拒绝的修改": "let workerInstance = new worker.Worker('entry/ets/workers/worker.ets');",
      "注意事项": "修复前必须验证API名称在上下文中的实际存在性和正确性，优先保留框架/库的特定命名约定，避免将通用术语强加于专用API名称。"
    },
    {
      "defect_id": 412918,
      "sentence": "Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "reference_sentence": "Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "line_num": 474,
      "context": "{\"469\":\"\",\"470\":\"| 规则 |\",\"471\":\"| -------- |\",\"472\":\"| Sendable对象传入TS/JS的接口中，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"473\":\"| Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"474\":\"| Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"475\":\"\",\"476\":\"> **说明：**\",\"477\":\">\",\"478\":\"> 改变属性类型不包括Sendable对象类型的改变，例如从Sendable class A变为Sendable class B。\",\"479\":\"\"}",
      "用户拒绝的修改": "Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止增、删属性，改变属性类型。",
      "注意事项": "修复时应优先保留原文的术语结构和总分说明形式，确保技术文档的严谨性；若括号内内容为对前置术语的具体解释，不得删除术语仅保留解释项，需维持\"总括词+括号示例\"的规范表述结构。"
    },
    {
      "defect_id": 412917,
      "sentence": "Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "reference_sentence": "Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "line_num": 473,
      "context": "{\"468\":\"### ArkTS通用规则（目前只针对Sendable对象）\",\"469\":\"\",\"470\":\"| 规则 |\",\"471\":\"| -------- |\",\"472\":\"| Sendable对象传入TS/JS的接口中，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"473\":\"| Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"474\":\"| Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"475\":\"\",\"476\":\"> **说明：**\",\"477\":\">\",\"478\":\"> 改变属性类型不包括Sendable对象类型的改变，例如从Sendable class A变为Sendable class B。\"}",
      "用户拒绝的修改": "Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止增、删属性，改变属性类型。",
      "注意事项": "修复时应优先保留原文的关键术语和结构（如\"操作其对象布局\"），避免因局部用词统一而破坏专业表述；需确保修改后的句子与上下文同类规则保持完全一致的表达范式。"
    },
    {
      "defect_id": 412916,
      "sentence": "Sendable对象传入TS/JS的接口中，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "reference_sentence": "Sendable对象传入TS/JS的接口中，禁止操作其对象布局（增、删属性，改变属性类型）。",
      "line_num": 472,
      "context": "{\"467\":\"\",\"468\":\"### ArkTS通用规则（目前只针对Sendable对象）\",\"469\":\"\",\"470\":\"| 规则 |\",\"471\":\"| -------- |\",\"472\":\"| Sendable对象传入TS/JS的接口中，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"473\":\"| Sendable对象设置到TS/JS的对象上，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"474\":\"| Sendable对象放入TS/JS的容器中，TS中获取到这个Sendable对象后，禁止操作其对象布局（增、删属性，改变属性类型）。 |\",\"475\":\"\",\"476\":\"> **说明：**\",\"477\":\">\"}",
      "用户拒绝的修改": "Sendable对象传入TS/JS的接口中，禁止增、删属性，改变属性类型。",
      "注意事项": "保留原文括号内的具体说明以保持术语一致性，避免将概括性表述替换为具体行为列表，确保技术文档的严谨性和上下文连贯性。"
    },
    {
      "defect_id": 410690,
      "sentence": "4. 在entry模块中加载har包中的Worker线程文件。",
      "reference_sentence": "2. 在HAR中创建Worker线程文件相关内容。",
      "line_num": 320,
      "context": "{\"315\":\"     }\",\"316\":\"   }\",\"317\":\"   ```\",\"318\":\"   <!-- @[config_har_dependency](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/entry/oh-package.json5) -->\",\"319\":\"\",\"320\":\"4. 在entry模块中加载har包中的Worker线程文件。\",\"321\":\"\",\"322\":\"   ```ts\",\"323\":\"   // Index.ets\",\"324\":\"   import { worker } from '@kit.ArkTS';\",\"325\":\"\"}",
      "用户拒绝的修改": "4. 在entry模块中加载HAR包中的Worker线程文件。",
      "注意事项": "修复术语大小写不一致时，需结合上下文全局验证统一性（如检查用户提供的参考案例\"HAR\"全大写格式），并确保修改后的形式在文档中无其他冲突用法（如同时存在\"har\"/\"HAR\"会导致重复数据问题）。"
    },
    {
      "defect_id": 410688,
      "sentence": "1. 创建har详情参考[开发静态共享包](../quick-start/har-package.md)。",
      "reference_sentence": "## 跨har包加载Worker",
      "line_num": 289,
      "context": "{\"284\":\"      <!-- @[register_callback_function](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/entry/src/main/ets/workers/worker.ets) -->\",\"285\":\"\",\"286\":\"\",\"287\":\"## 跨har包加载Worker\",\"288\":\"\",\"289\":\"1. 创建har详情参考[开发静态共享包](../quick-start/har-package.md)。\",\"290\":\"\",\"291\":\"2. 在har中创建Worker线程文件相关内容。\",\"292\":\"\",\"293\":\"   ```ts\",\"294\":\"   // worker.ets\"}",
      "用户拒绝的修改": "1. 创建HAR详情参考[开发静态共享包](../quick-start/har-package.md)。",
      "注意事项": "修复术语大小写时应优先检查上下文现有用法，若原文已存在统一形式（如全小写\"har\"），需保持原有格式而非机械应用首字母大写规则；修改前必须核对文档中所有相关术语实例，避免因局部改动导致整体不一致。"
    },
    {
      "defect_id": 412858,
      "sentence": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时复用同一个C++对象，相比于JS对象的拷贝模式，传输效率高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。",
      "reference_sentence": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时复用同一个C++对象，相比于JS对象的拷贝模式，传输效率高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。",
      "line_num": 4,
      "context": "{\"1\":\"# Transferable对象（NativeBinding对象）\",\"2\":\"\",\"3\":\"\",\"4\":\"Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时复用同一个C++对象，相比于JS对象的拷贝模式，传输效率高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。开发者也可以自定义Transferable对象，详细示例请参考[自定义Native Transferable对象的多线程操作场景](napi-coerce-to-native-binding-object.md)。\",\"5\":\"\",\"6\":\"\",\"7\":\"## 共享模式\",\"8\":\"\",\"9\":\"如果C++实现能够保证线程安全性，则这个NativeBinding对象的C++部分支持共享传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到同一个C++对象上，实现C++对象的共享。通信过程如下图所示：\"}",
      "用户拒绝的修改": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传输时转移同一个C++对象，相比于JS对象的拷贝模式，传输效率高。因此，可共享或转移的NativeBinding对象也被称为Transferable对象。",
      "注意事项": "修复时应通读完整段落，确保术语替换不会导致前后重复或概念混淆；优先参考上下文已有术语（如\"共享或转移\"），保持\"复用\"与\"转移\"的区分性，避免同义替换破坏技术准确性。"
    },
    {
      "defect_id": 410947,
      "sentence": "例如[批量数据写数据库场景](batch-database-operations-guide.md)。",
      "reference_sentence": "例如[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"- 需要设置优先级的任务：在API version 18 之前，Worker不支持设置调度优先级，需要使用TaskPool。从API version 18 开始，Worker支持设置调度优先级，开发者可以根据使用场景和任务特性选择使用TaskPool或Worker。例如[图库直方图绘制场景](cpu-intensive-task-development.md#使用taskpool进行图像直方图处理)，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。\",\"48\":\"\",\"49\":\"- 需要频繁取消的任务：例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。\",\"50\":\"\",\"51\":\"- 大量或调度点分散的任务：例如大型应用的多个模块包含多个耗时任务，不方便使用Worker去做负载管理，推荐使用TaskPool。场景示例可参考[批量数据写数据库场景](batch-database-operations-guide.md)。\"}",
      "用户拒绝的修改": "例如[使用Worker处理关联的同步任务](sync-task-development.md#使用worker处理关联的同步任务)。",
      "注意事项": "修复时应优先核对上下文语义关联性，确保链接文本与当前段落的技术场景完全匹配，避免因格式统一需求牺牲内容准确性；当多个示例分属不同技术方案时，需保留原文差异化的描述方式而非强制统一。"
    },
    {
      "defect_id": 410689,
      "sentence": "2. 在har中创建Worker线程文件相关内容。",
      "reference_sentence": "1. 创建HAR详情参考[开发静态共享包](../quick-start/har-package.md)。",
      "line_num": 291,
      "context": "{\"286\":\"\",\"287\":\"## 跨har包加载Worker\",\"288\":\"\",\"289\":\"1. 创建har详情参考[开发静态共享包](../quick-start/har-package.md)。\",\"290\":\"\",\"291\":\"2. 在har中创建Worker线程文件相关内容。\",\"292\":\"\",\"293\":\"   ```ts\",\"294\":\"   // worker.ets\",\"295\":\"   workerPort.onmessage = (e: MessageEvents) => {\",\"296\":\"     console.info('worker thread receive message: ', e.data);\"}",
      "用户拒绝的修改": "2. 在HAR中创建Worker线程文件相关内容。",
      "注意事项": "在统一术语大小写时，需全局检查上下文是否已存在固定写法（如\"HAR\"为专有缩写），避免因局部修改导致重复或歧义；优先遵循文档现有规则而非机械替换。"
    },
    {
      "defect_id": 410659,
      "sentence": "加载HSP中worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "reference_sentence": "加载HSP中Worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "line_num": 102,
      "context": "{\"97\":\"const workerStage2: worker.ThreadWorker = new worker.ThreadWorker('testworkers/ets/ThreadFile/workers/worker.ets');\",\"98\":\"```\",\"99\":\"\",\"100\":\"2） 加载[HSP](../quick-start/in-app-hsp.md)中Worker线程文件场景\",\"101\":\"\",\"102\":\"加载HSP中worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。\",\"103\":\"\",\"104\":\"```ts\",\"105\":\"import { worker } from '@kit.ArkTS';\",\"106\":\"\",\"107\":\"// worker线程文件所在路径： \\\"hsp/src/main/ets/workers/worker.ets\\\"\"}",
      "用户拒绝的修改": "加载HSP中Worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "注意事项": "修复术语一致性时必须严格检查上下文中的代码变量命名和导入语句，区分通用名词与技术术语（如`worker`变量 vs `Worker`类型），避免脱离代码实际引用场景修改大小写。"
    },
    {
      "defect_id": 410715,
      "sentence": "不建议在父Worker销毁后，子Worker仍向父Worker发送消息。",
      "reference_sentence": "如果销毁父Worker时未能终止其子Worker的运行，可能会导致不可预期的结果。因此需确保子Worker的生命周期在父Worker生命周期范围内，销毁父Worker前，先销毁所有子Worker。",
      "line_num": 442,
      "context": "{\"437\":\"<!-- @[recommended_example](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/entry/src/main/ets/recommendworkers/childworker.ets) -->\",\"438\":\"\",\"439\":\"\",\"440\":\"### 不推荐使用示例\",\"441\":\"\",\"442\":\"不建议在父Worker销毁后，子Worker仍向父Worker发送消息。\",\"443\":\"\",\"444\":\"```ts\",\"445\":\"// main thread\",\"446\":\"import { worker, MessageEvents, ErrorEvent } from '@kit.ArkTS';\",\"447\":\"\"}",
      "用户拒绝的修改": "不建议在父Worker销毁前，子Worker仍向父Worker发送消息。",
      "注意事项": "修复时必须严格对照上下文中的生命周期顺序（父Worker销毁前需先销毁子Worker），确保时间状语（\"前/后\"）与逻辑关系完全匹配；修改时要同步检查技术逻辑的准确性，避免因局部调整导致整体语义矛盾。"
    },
    {
      "defect_id": 410660,
      "sentence": "加载HAR中worker线程文件存在以下两种情况：",
      "reference_sentence": "加载HAR中Worker线程文件存在以下两种情况：",
      "line_num": 113,
      "context": "{\"108\":\"const workerStage3: worker.ThreadWorker = new worker.ThreadWorker('hsp/ets/workers/worker.ets');\",\"109\":\"```\",\"110\":\"\",\"111\":\"3） 加载[HAR](../quick-start/har-package.md)中Worker线程文件场景\",\"112\":\"\",\"113\":\"加载HAR中worker线程文件存在以下两种情况：\",\"114\":\"\",\"115\":\"- @标识路径加载形式：所有种类的模块加载本地HAR中的Worker线程文件，加载路径规则：@{moduleName}/ets/{relativePath}。\",\"116\":\"\",\"117\":\"- 相对路径加载形式：本地HAR加载该包内的Worker线程文件，加载路径规则：创建Worker对象所在文件与Worker线程文件的相对路径。\",\"118\":\"\"}",
      "用户拒绝的修改": "加载HAR中Worker线程文件存在以下两种情况：",
      "注意事项": "修复术语一致性时应严格匹配上下文代码中的命名规范（如`worker.ThreadWorker`中的模块名小写），同时保持文档内术语使用统一（如\"Worker线程\"需首字母大写），避免仅修改局部而忽略整体一致性。"
    },
    {
      "defect_id": 410641,
      "sentence": "手动创建：开发者手动创建相关目录及文件，通常是在ets目录下创建一个workers文件夹，用于存放worker.ets文件，需要配置build-profile.json5的相关字段信息，确保Worker线程文件被打包到应用中。",
      "reference_sentence": "手动创建：开发者手动创建相关目录及文件，通常是在ets目录下创建一个workers文件夹，用于存放worker.ets文件，需要配置build-profile.json5的相关字段信息，确保Worker线程文件被打包到应用中。",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"### 创建Worker的注意事项\",\"31\":\"\",\"32\":\"Worker线程文件需要放在\\\"{moduleName}/src/main/ets/\\\"目录层级之下，否则不会被打包到应用中。有手动和自动两种创建Worker线程目录及文件的方式。\",\"33\":\"\",\"34\":\"- 手动创建：开发者手动创建相关目录及文件，通常是在ets目录下创建一个workers文件夹，用于存放worker.ets文件，需要配置build-profile.json5的相关字段信息，确保Worker线程文件被打包到应用中。\",\"35\":\"\",\"36\":\"  Stage模型：\",\"37\":\"\",\"38\":\"  ```json\",\"39\":\"  \\\"buildOption\\\": {\"}",
      "用户拒绝的修改": "手动创建：开发者手动创建相关目录及文件，通常是在ets目录下创建一个workers文件夹，用于存放Worker线程文件，需要配置build-profile.json5的相关字段信息，确保Worker线程文件被打包到应用中。",
      "注意事项": "修复术语一致性时必须严格区分具体文件名（如worker.ets）与抽象概念（Worker线程文件），在涉及文件路径/扩展名的上下文中优先保留原始文件名；同时需检查术语在段落中的首次定义位置，确保前后指代逻辑连贯。"
    },
    {
      "defect_id": 410658,
      "sentence": "加载Ability中的worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "reference_sentence": "加载Ability中的Worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "line_num": 88,
      "context": "{\"83\":\"- scriptURL的组成包含{moduleName}/ets和相对路径relativePath。\",\"84\":\"- relativePath是Worker线程文件相对于\\\"{moduleName}/src/main/ets/\\\"目录的相对路径。\",\"85\":\"\",\"86\":\"1） 加载Ability中Worker线程文件场景\",\"87\":\"\",\"88\":\"加载Ability中的worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。\",\"89\":\"\",\"90\":\"```ts\",\"91\":\"import { worker } from '@kit.ArkTS';\",\"92\":\"\",\"93\":\"// worker线程文件所在路径：\\\"entry/src/main/ets/workers/worker.ets\\\"\"}",
      "用户拒绝的修改": "加载Ability中的Worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "注意事项": "修复术语一致性时需严格核对代码示例中的实际命名（如示例代码中的`worker`变量），同时区分通用术语与专有名词（如\"Worker线程\"作为技术概念应首字母大写），避免脱离上下文孤立修改大小写。"
    },
    {
      "defect_id": 412986,
      "sentence": "Sendable interface需同时满足以下两个规则：",
      "reference_sentence": "ISendable是所有Sendable类型（除了null和undefined）的父类型。",
      "line_num": 59,
      "context": "{\"54\":\"\",\"55\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"56\":\"\",\"57\":\"### Sendable interface\",\"58\":\"\",\"59\":\"Sendable interface需同时满足以下两个规则：\",\"60\":\"\",\"61\":\"1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。\",\"62\":\"\",\"63\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"64\":\"\"}",
      "用户拒绝的修改": "ISendable需同时满足以下两个规则：",
      "注意事项": "修改前必须确认术语在上下文中的具体指代关系，严格区分接口名称（如ISendable）与抽象概念（如Sendable interface），避免将类型命名与功能描述混用。"
    },
    {
      "defect_id": 416958,
      "sentence": "表示期望或可提供的最大数据记录数，默认值为0，取值范围为[0, 2<sup>32</sup>-1]。超过取值范围时会按默认值处理。设置为浮点数时，仅使用整数部分。",
      "reference_sentence": "在**数据发送方**中使用，表示实际可提供的数据范围，必须设置该字段。",
      "line_num": 1387,
      "context": "{\"1382\":\"**参数：**\",\"1383\":\"\",\"1384\":\"| 名称                   | 类型                                              | 必填 | 说明                                                                                                                                                 |\",\"1385\":\"|----------------------|-------------------------------------------------| ---- |----------------------------------------------------------------------------------------------------------------------------------------------------|\",\"1386\":\"| types    | Set\\\\<string\\\\>       | 否 | 表示数据类型集合，默认为空集合。                                                                                                                         |\",\"1387\":\"| recordCount | number | 否 | 表示期望或可提供的最大数据记录数，默认值为0，取值范围为[0, 2<sup>32</sup>-1]。超过取值范围时会按默认值处理。设置为浮点数时，仅使用整数部分。                             |\",\"1388\":\"\",\"1389\":\"## DataLoadHandler<sup>20+</sup>\",\"1390\":\"\",\"1391\":\"type DataLoadHandler = (acceptableInfo?: DataLoadInfo) => UnifiedData | null\",\"1392\":\"\"}",
      "用户拒绝的修改": "表示可提供的最大数据记录数，默认值为0，取值范围为[0, 2<sup>32</sup>-1]。超过取值范围时会按默认值处理。设置为浮点数时，仅使用整数部分。",
      "注意事项": "保持术语使用场景的精确区分，当参数存在多角色应用场景时（如发送方/接收方），应明确保留\"期望\"和\"可提供的\"双重表述，不可强行合并不同语义的限定词。需结合上下文参考句子中\"数据发送方\"的特定使用场景进行交叉验证。"
    },
    {
      "defect_id": 413008,
      "sentence": "2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。",
      "reference_sentence": "无",
      "line_num": 124,
      "context": "{\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\",\"128\":\"**装饰器修饰Class使用示例：**\",\"129\":\"\"}",
      "用户拒绝的修改": "2. 不增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不修改方法。",
      "注意事项": "确保句式结构严格统一，使用\"禁止\"替代\"不支持\"等否定表述，保持与上下文\"必须\"、\"不能\"等祈使句动词的强制语气一致性；修复时需完整保留原句的\"允许...，禁止...\"对比结构，避免破坏规则描述的完整性。"
    },
    {
      "defect_id": 412985,
      "sentence": "### Sendable interface",
      "reference_sentence": "### ISendable",
      "line_num": 57,
      "context": "{\"52\":\"\",\"53\":\"1. 当且仅当被标注了[@Sendable装饰器](#sendable装饰器)。\",\"54\":\"\",\"55\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"56\":\"\",\"57\":\"### Sendable interface\",\"58\":\"\",\"59\":\"Sendable interface需同时满足以下两个规则：\",\"60\":\"\",\"61\":\"1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。\",\"62\":\"\"}",
      "用户拒绝的修改": "### ISendable",
      "注意事项": "修改术语一致性时需优先确认用户是否允许调整标题或标签，避免直接修改用户明确保留的固定标记（如\"### Sendable interface\"章节标题），应仅修正正文中混用的概念表述（如将内容中的\"Sendable interface\"改为\"ISendable\"）。"
    },
    {
      "defect_id": 413006,
      "sentence": "3. 不支持通过\\#定义私有属性，需用private。",
      "reference_sentence": "无",
      "line_num": 123,
      "context": "{\"118\":\"| -------- | -------- |\",\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\",\"128\":\"**装饰器修饰Class使用示例：**\"}",
      "用户拒绝的修改": "3. 不通过\\#定义私有属性，需用private。",
      "注意事项": "在调整句式保持一致性时，需优先保留原句的关键否定词（如\"不支持\"）以维持技术表达的准确性，同时应检查上下文同类规则的表达习惯（如\"禁止\"\"不支持\"的固定搭配），避免机械套用句式规则破坏术语统一性。"
    },
    {
      "defect_id": 417366,
      "sentence": "当前所有import中使用的模块名是依赖方oh-package.json5的dependencies中的别名。",
      "reference_sentence": "当前所有import中使用的模块名是依赖方oh-package.json5的dependencies中的别名。",
      "line_num": 91,
      "context": "{\"86\":\"| API            | 动态import @arkui-x.*          | -                                                        |\",\"87\":\"| 模块Native库   | 动态import libNativeLibrary.so | -                                                        |\",\"88\":\"\",\"89\":\">**说明：**\",\"90\":\"> \",\"91\":\"> 1.当前所有import中使用的模块名是依赖方oh-package.json5的dependencies中的别名。\",\"92\":\"> 2.本地模块在依赖方的dependencies中配置的别名建议与moduleName以及packageName三者一致。moduleName指的是被依赖的HSP/HAR的module.json5中配置的名字，packageName指的是被依赖的HSP/HAR的oh-package.json5中配置的名字。\",\"93\":\"> 3.import一个模块名，实际的行为是import该模块的入口文件，一般为Index.ets/ts。\",\"94\":\"\",\"95\":\"## 动态import实现中的关键点\",\"96\":\"\"}",
      "用户拒绝的修改": "当前所有import中使用的模块名是依赖方oh-package.json5的dependencies中的别称。",
      "注意事项": "保持技术术语一致性时需优先尊重原文用词，在修改前应确认目标词汇是否为领域专用术语；当同义词替换可能引发歧义时，应结合上下文验证修改必要性而非单纯追求词汇统一。"
    },
    {
      "defect_id": 417380,
      "sentence": "DevEco Studio中模块间的依赖关系通过oh-package.json5中的dependencies进行配置。dependencies列表中所有模块默认都会进行安装（本地模块）或下载（远程模块），但是不会默认参与编译。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。",
      "line_num": 293,
      "context": "{\"288\":\"  import('@ohos.hilog').then((ns:ESObject) => { ns.default.info(0x0000, 'testTag', '%{public}s', 'DynamicImport @ohos.hilog.'); });\",\"289\":\"  ```\",\"290\":\"\",\"291\":\"### 动态import变量表达式\",\"292\":\"\",\"293\":\"DevEco Studio中模块间的依赖关系通过oh-package.json5中的dependencies进行配置。dependencies列表中所有模块默认都会进行安装（本地模块）或下载（远程模块），但是不会默认参与编译。HAP/HSP编译时会以入口文件（一般为Index.ets/ts）开始搜索依赖关系，搜索到的模块或文件才会加入编译。\",\"294\":\"在编译期，静态import和常量动态import可以被打包工具rollup及其插件识别解析，加入依赖树中，参与编译流程，最终生成方舟字节码。但是，如果是变量动态import，该变量值可能需要进行运算或外部传入才能得到，在编译态无法解析其内容，也就无法加入编译。为了将这部分模块/文件加入编译，还需要额外增加一个runtimeOnly的buildOption配置，用于配置动态import的变量实际的模块名或文件路径。\",\"295\":\"\",\"296\":\"**1. runtimeOnly字段schema配置格式**\",\"297\":\"\",\"298\":\"在HAP/HSP/HAR的build-profile.json5中的buildOption中增加runtimeOnly配置项，仅在通过变量动态import时配置，静态import和常量动态import无需配置；并且，通过变量动态import加载API时也无需配置runtimeOnly。如下实例说明如何配置通过变量动态import其他模块，以及变量动态import本模块自己的单文件：\"}",
      "用户拒绝的修改": "DevEco Studio中模块间的依赖关系通过oh-package.json5中的dependencies进行配置。dependencies列表中所有模块默认都会进行下载（本地模块）或下载（远程模块），但是不会默认参与编译。",
      "注意事项": "在统一术语前需先确认操作实质是否相同，避免为追求一致性牺牲准确性；当不同对象（如本地/远程模块）存在实质差异时，应保留区分性动词（安装/下载）而非强行统一。"
    },
    {
      "defect_id": 418611,
      "sentence": "（1）drawModifier接口参数从DrawModifier对象变为undefined后，生效的仍旧是原来的DrawModifier对象。（2）任何组件，只要设置了drawModifier属性，即使跳过测量，也会触发重绘。",
      "reference_sentence": "（1）当drawModifier接口参数从DrawModifier对象变为undefined时，实际生效的仍是原来的DrawModifier对象。开发者无法重置其值，这与通用属性接口的规范不符。（2）当前实现中，若组件设置了drawModifier属性，则默认会在生命周期的布局阶段之后触发重绘。对于绘制内容和尺寸均未发生变化的场景，这将导致多余的重绘，造成性能损耗。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"**变更影响**\",\"16\":\"\",\"17\":\"此变更涉及应用适配。\",\"18\":\"\",\"19\":\"- 变更前：（1）drawModifier接口参数从DrawModifier对象变为undefined后，生效的仍旧是原来的DrawModifier对象。（2）任何组件，只要设置了drawModifier属性，即使跳过测量，也会触发重绘。\",\"20\":\"  \",\"21\":\"- 变更后：（1）drawModifier接口参数从DrawModifier对象变为undefined后，会将原来设置的值重置为undefined。（2）若容器组件设置了drawModifier属性，则当其跳过测量时，不执行重绘。其他组件的重绘触发机制与是否使用drawModifier属性无关。\",\"22\":\"\",\"23\":\"**起始API Level**\",\"24\":\"\"}",
      "用户拒绝的修改": "（1）drawModifier接口参数从DrawModifier对象变为undefined后，实际生效的仍是原来的DrawModifier对象。开发者无法重置其值，这与通用属性接口的规范不符。（2）当前实现中，若组件设置了drawModifier属性，则默认会在生命周期的布局阶段之后触发重绘。对于绘制内容和尺寸均未发生变化的场景，这将导致多余的重绘，造成性能损耗。",
      "注意事项": "修复时需严格保持原句语义结构和逻辑分层，禁止擅自调整\"变更原因\"与\"变更影响\"的表述边界；对于问题描述中的关键动词（如\"变为/生效/触发\"）和限定词（如\"仍旧/即使\"），必须采用镜像式还原而非近义词替换。"
    },
    {
      "defect_id": 418278,
      "sentence": "字型对象。",
      "reference_sentence": "字体对象。",
      "line_num": 1289,
      "context": "{\"1284\":\"**参数**\",\"1285\":\"\",\"1286\":\"| 参数名 | 类型                | 必填 | 说明        |\",\"1287\":\"| ------ | ------------------- | ---- | ----------- |\",\"1288\":\"| text | string | 是 | 待绘制的单个字符，字符串长度必须为1。 |\",\"1289\":\"| font   | [Font](arkts-apis-graphics-drawing-Font.md) | 是   | 字型对象。  |\",\"1290\":\"| x | number | 是 | 所绘制字符基线左端点的横坐标，该参数为浮点数。 |\",\"1291\":\"| y | number | 是 | 所绘制字符基线左端点的纵坐标，该参数为浮点数。 |\",\"1292\":\"| features | Array\\\\<[FontFeature](arkts-apis-graphics-drawing-i.md#fontfeature20)\\\\> | 是 | 字体特征对象数组。|\",\"1293\":\"\",\"1294\":\"**示例：**\"}",
      "用户拒绝的修改": "字体对象。",
      "注意事项": "修复前必须全面检查文档上下文中的术语统一性，优先保留接口定义和参数列表中的原始表述，避免因局部优化破坏技术文档的术语一致性规范。"
    },
    {
      "defect_id": 417402,
      "sentence": "har1对har2的依赖dependencies和runtimeOnly配置转移到HAP中，har1不需要配置对har2的dependencies和runtimeOnly配置：",
      "reference_sentence": "HAR之间的依赖关系转移至HAP/HSP后：",
      "line_num": 635,
      "context": "{\"630\":\"  console.info('DynamicImport I am har2, %d + %d = %d', a, b, c);\",\"631\":\"  return c;\",\"632\":\"}\",\"633\":\"```\",\"634\":\"\",\"635\":\"har1对har2的依赖dependencies和runtimeOnly配置转移到HAP中，har1不需要配置对har2的dependencies和runtimeOnly配置：\",\"636\":\"\",\"637\":\"```json5\",\"638\":\"// HAP's oh-package.json5\",\"639\":\"\\\"dependencies\\\": {\",\"640\":\"  \\\"har1\\\": \\\"file:../har1\\\",\"}",
      "用户拒绝的修改": "har1对har2的依赖dependencies和runtimeOnly配置转移到HAP中，har1不需要配置对har2的dependencies和runtimeOnly配置。",
      "注意事项": "修复时必须严格对照上下文术语使用（如\"HAP/HSP\"与\"HAP\"的差异），避免机械重复原句；当上下文存在明确规范表达时，需优先采用完整统一的命名方式保持全篇一致性。"
    },
    {
      "defect_id": 417401,
      "sentence": "当应用包含多个HAR包，且HAR包之间依赖关系比较复杂。在DevEco Studio中配置依赖关系时，可能会形成循环依赖。这时，如果HAR之间的依赖关系中仅有变量动态import，可以将HAR包之间直接依赖关系转移到HAP/HSP中配置，HAR包之间无需配置依赖关系，从而达到HAR包间依赖解耦的目的。如下示意图：",
      "reference_sentence": "在DevEco Studio中模块间的依赖关系通过oh-package.json5中的dependencies进行配置。",
      "line_num": 540,
      "context": "{\"535\":\"  import(packageName).then((ns:ESObject) => { ns.default.info(0x0000, 'testTag', '%{public}s', 'DynamicImport @ohos.hilog.'); });\",\"536\":\"  ```\",\"537\":\"变量动态import加载API时无需配置runtimeOnly。\",\"538\":\"\",\"539\":\"### HAR模块间动态import依赖解耦\",\"540\":\"当应用包含多个HAR包，且HAR包之间依赖关系比较复杂。在DevEco Studio中配置依赖关系时，可能会形成循环依赖。这时，如果HAR之间的依赖关系中仅有变量动态import，可以将HAR包之间直接依赖关系转移到HAP/HSP中配置，HAR包之间无需配置依赖关系，从而达到HAR包间依赖解耦的目的。如下示意图：\",\"541\":\"\",\"542\":\"![变量动态import HAR包形成循环依赖](figures/dynamicimport1.png)\",\"543\":\"\",\"544\":\"HAR之间的依赖关系转移至HAP/HSP后：\",\"545\":\"\"}",
      "用户拒绝的修改": "当应用包含多个HAR包，且HAR包之间依赖关系比较复杂。在DevEco Studio中，通过oh-package.json5中的dependencies配置依赖关系时，可能会形成循环依赖。这时，如果HAR之间的依赖关系中仅有变量动态import，可以将HAR包之间直接依赖关系转移到HAP/HSP中配置，HAR包之间无需配置依赖关系，从而达到HAR包间依赖解耦的目的。如下示意图：",
      "注意事项": "在补充技术细节时需确认上下文是否存在重复说明，若前文已明确配置方式且当前段落侧重操作逻辑，应优先保持语句简洁性而非机械重复，避免破坏技术文档的信息密度和阅读流畅度。"
    },
    {
      "defect_id": 418277,
      "sentence": "所绘制字符基线左端点的纵坐标，该参数为浮点数。",
      "reference_sentence": "所绘制出的字符基线（下图蓝线）的左端点（下图红点）的纵坐标，该参数为浮点数。",
      "line_num": 1291,
      "context": "{\"1286\":\"| 参数名 | 类型                | 必填 | 说明        |\",\"1287\":\"| ------ | ------------------- | ---- | ----------- |\",\"1288\":\"| text | string | 是 | 待绘制的单个字符，字符串长度必须为1。 |\",\"1289\":\"| font   | [Font](arkts-apis-graphics-drawing-Font.md) | 是   | 字型对象。  |\",\"1290\":\"| x | number | 是 | 所绘制字符基线左端点的横坐标，该参数为浮点数。 |\",\"1291\":\"| y | number | 是 | 所绘制字符基线左端点的纵坐标，该参数为浮点数。 |\",\"1292\":\"| features | Array\\\\<[FontFeature](arkts-apis-graphics-drawing-i.md#fontfeature20)\\\\> | 是 | 字体特征对象数组。|\",\"1293\":\"\",\"1294\":\"**示例：**\",\"1295\":\"\",\"1296\":\"```ts\"}",
      "用户拒绝的修改": "所绘制出的字符基线（下图蓝线）的左端点（下图红点）的纵坐标，该参数为浮点数。",
      "注意事项": "修复时应全局校验文档中同一术语的完整表述形式，避免在已保持一致的语境中添加冗余修饰词；优先维持参数说明的术语统一性，仅在明确存在跨段落混用时进行修正。"
    },
    {
      "defect_id": 418276,
      "sentence": "所绘制字符基线左端点的横坐标，该参数为浮点数。",
      "reference_sentence": "所绘制出的字符基线（下图蓝线）的左端点（下图红点）的横坐标，该参数为浮点数。",
      "line_num": 1290,
      "context": "{\"1285\":\"\",\"1286\":\"| 参数名 | 类型                | 必填 | 说明        |\",\"1287\":\"| ------ | ------------------- | ---- | ----------- |\",\"1288\":\"| text | string | 是 | 待绘制的单个字符，字符串长度必须为1。 |\",\"1289\":\"| font   | [Font](arkts-apis-graphics-drawing-Font.md) | 是   | 字型对象。  |\",\"1290\":\"| x | number | 是 | 所绘制字符基线左端点的横坐标，该参数为浮点数。 |\",\"1291\":\"| y | number | 是 | 所绘制字符基线左端点的纵坐标，该参数为浮点数。 |\",\"1292\":\"| features | Array\\\\<[FontFeature](arkts-apis-graphics-drawing-i.md#fontfeature20)\\\\> | 是 | 字体特征对象数组。|\",\"1293\":\"\",\"1294\":\"**示例：**\",\"1295\":\"\"}",
      "用户拒绝的修改": "所绘制出的字符基线（下图蓝线）的左端点（下图红点）的横坐标，该参数为浮点数。",
      "注意事项": "修复时应确保补充说明与上下文格式规范统一，避免在参数表格等结构化内容中添加图示类注释；优先保持术语简洁性，仅在确实存在歧义时补充限定词。"
    },
    {
      "defect_id": 417980,
      "sentence": "测量单个字符的宽度，字符带有字体特征。当前字型中的字体不支持待测量字符时，退化到使用系统字体测量字符宽度。",
      "reference_sentence": "测量单个字符的宽度。当前字型中的字体不支持待测量字符时，退化到使用系统字体测量字符宽度。",
      "line_num": 502,
      "context": "{\"497\":\"\",\"498\":\"### measureSingleCharacterWithFeatures<sup>20+</sup>\",\"499\":\"\",\"500\":\"measureSingleCharacterWithFeatures(text: string, features: Array<FontFeature>): number\",\"501\":\"\",\"502\":\"测量单个字符的宽度，字符带有字体特征。当前字型中的字体不支持待测量字符时，退化到使用系统字体测量字符宽度。\",\"503\":\"\",\"504\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"505\":\"\",\"506\":\"**参数**\",\"507\":\"\"}",
      "用户拒绝的修改": "测量单个字符的宽度，字符带有字体特征。如果当前字型中的字体不支持待测量字符，则退化到使用系统字体测量字符宽度。",
      "注意事项": "修复时应先识别并删除冗余描述（如\"字符带有字体特征\"已在方法名/参数中体现），确保逻辑主线单一；修改需同时关注语法修正和上下文信息去重，避免局部调整导致整体表述割裂。"
    },
    {
      "defect_id": 420010,
      "sentence": "开启混淆后，需根据不同的混淆规则配置保留选项。保留选项配置方法可参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "reference_sentence": "在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。",
      "line_num": 50,
      "context": "{\"45\":\"    >\",\"46\":\"    > 1. 在DevEco Studio5.0.3.600之前，新建工程的默认设置是开启代码混淆，自动对API 10及更高版本的Stage模型进行混淆。\",\"47\":\"    > 2. 在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。\",\"48\":\"\",\"49\":\"* 配置混淆保留选项\",\"50\":\"    开启混淆后，需根据不同的混淆规则配置保留选项。保留选项配置方法可参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。\",\"51\":\"\",\"52\":\"* 指定release编译  \",\"53\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"54\":\"\",\"55\":\"    > **注意：**\"}",
      "用户拒绝的修改": "开启混淆后，需根据不同的混淆规则配置混淆选项。混淆选项配置方法可参考[混淆选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置混淆选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "注意事项": "在修改技术文档时需严格区分专业术语的准确含义，确保替换词汇与上下文逻辑一致，避免将功能相反的概念（如\"保留选项\"和\"混淆选项\"）进行错误替换。修改后应交叉验证术语在参考段落中的使用场景，保持全文档概念体系的完整性。"
    },
    {
      "defect_id": 420446,
      "sentence": "开启混淆后，需根据不同的混淆规则配置保留选项。保留选项的配置方法，参考[保留选项](source-obfuscation.md#保留选项)。",
      "reference_sentence": "混淆选项的配置推荐参考[混淆选项配置指导](#混淆选项配置指导)，混淆过程中涉及的所有配置文件的详情介绍请参考[三种混淆配置文件](#三种混淆配置文件)。",
      "line_num": 50,
      "context": "{\"45\":\"    >\",\"46\":\"    > 1. 在DevEco Studio5.0.3.600之前，新建工程的默认设置是开启代码混淆，自动对API 10及更高版本的Stage模型进行混淆。\",\"47\":\"    > 2. 在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。\",\"48\":\"\",\"49\":\"* 配置混淆保留选项\",\"50\":\"    开启混淆后，需根据不同的混淆规则配置保留选项。保留选项的配置方法，参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。\",\"51\":\"\",\"52\":\"* 指定release编译  \",\"53\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"54\":\"\",\"55\":\"    > **注意：**\"}",
      "用户拒绝的修改": "开启混淆后，需根据不同的混淆规则配置混淆选项。混淆选项的配置方法，参考[混淆选项配置指导](source-obfuscation.md#混淆选项配置指导)。",
      "注意事项": "修改术语前必须严格校验上下文语境，区分\"保留选项\"（用于排除混淆）和\"混淆选项\"（用于启用混淆）的语义边界，避免将不同功能的配置项强行统一命名。"
    },
    {
      "defect_id": 420447,
      "sentence": "推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "reference_sentence": "混淆选项的配置推荐参考[混淆选项配置指导](#混淆选项配置指导)，混淆过程中涉及的所有配置文件的详情介绍请参考[三种混淆配置文件](#三种混淆配置文件)。",
      "line_num": 50,
      "context": "{\"45\":\"    >\",\"46\":\"    > 1. 在DevEco Studio5.0.3.600之前，新建工程的默认设置是开启代码混淆，自动对API 10及更高版本的Stage模型进行混淆。\",\"47\":\"    > 2. 在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。\",\"48\":\"\",\"49\":\"* 配置混淆保留选项\",\"50\":\"    开启混淆后，需根据不同的混淆规则配置保留选项。保留选项的配置方法，参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。\",\"51\":\"\",\"52\":\"* 指定release编译  \",\"53\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"54\":\"\",\"55\":\"    > **注意：**\"}",
      "用户拒绝的修改": "推荐使用[混淆助手配置混淆选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "注意事项": "修复术语不一致时需优先验证上下文术语体系，若原文存在\"保留选项\"和\"混淆选项\"两个独立概念，应通过上下文定位具体功能场景（如混淆配置中的保留规则配置场景）而非机械替换。"
    },
    {
      "defect_id": 428572,
      "sentence": "开启MCS并配置安全级别后，使用命令`ps -efZ`查询MCS配置状况。示例如下：",
      "reference_sentence": "开启MCS并配置安全级别后，使用命令 `ps -efZ` 查询MCS配置状况。示例如下：",
      "line_num": 32,
      "context": "{\"27\":\" | user | 根据userId确认级别。 | \\\"s0:x%u,x%u\\\", 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\",\"28\":\" | all | 根据进程appId和userId确认级别。 | \\\"s0:x%u,x%u,x%u,x%u,x%u\\\", appId & 0xff, 256 + (appId>>8 & 0xff), 512 + (appId>>16 & 0xff), 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\",\"29\":\"\",\"30\":\"## MCS生效验证\",\"31\":\"\",\"32\":\"开启MCS并配置安全级别后，使用命令`ps -efZ`查询MCS配置状况。示例如下：\",\"33\":\"```text\",\"34\":\"o:r:normal_hap:s0:x55,x334,x512,x868,x1024\",\"35\":\"```\"}",
      "用户拒绝的修改": "开启MCS并配置安全级别后，使用命令 `ps -efZ` 查询MCS配置状况。示例如下：",
      "注意事项": "修复命令格式时应严格保持反引号与内容零间距，并通过交叉验证上下文相邻代码块格式确保全文档符号使用一致性。"
    },
    {
      "defect_id": 420108,
      "sentence": "开启混淆后，需根据不同的混淆规则配置保留选项。保留选项的配置方法可参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "reference_sentence": "混淆选项的配置推荐参考[混淆选项配置指导](#混淆选项配置指导)，混淆过程中涉及的所有配置文件的详情介绍请参考[三种混淆配置文件](#三种混淆配置文件)。",
      "line_num": 50,
      "context": "{\"45\":\"    >\",\"46\":\"    > 1. 在DevEco Studio5.0.3.600之前，新建工程的默认设置是开启代码混淆，自动对API 10及更高版本的Stage模型进行混淆。\",\"47\":\"    > 2. 在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。\",\"48\":\"\",\"49\":\"* 配置混淆保留选项\",\"50\":\"    开启混淆后，需根据不同的混淆规则配置保留选项。保留选项的配置方法可参考[保留选项](source-obfuscation.md#保留选项)。推荐使用[混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。\",\"51\":\"\",\"52\":\"* 指定release编译  \",\"53\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"54\":\"\",\"55\":\"    > **注意：**\"}",
      "用户拒绝的修改": "开启混淆后，需根据不同的混淆规则配置混淆选项。混淆选项的配置方法可参考[混淆选项配置指导](source-obfuscation.md#混淆选项配置指导)。推荐使用[混淆助手配置混淆选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。",
      "注意事项": "修复时必须严格区分上下文中的核心术语差异（如\"保留选项\"指不被混淆的内容，\"混淆选项\"指启用混淆的配置），避免过度统一术语导致概念混淆，修改前应交叉验证文档中相关章节的用词一致性。"
    },
    {
      "defect_id": 429386,
      "sentence": "BuilderNode节点只有通过以下方式上下树时，才会根据该节点是否继承父自定义组件的冻结策略，来更新自己的冻结策略：",
      "reference_sentence": "从API version 20开始，BuilderNode节点可以通过[inheritFreezeOptions](../reference/apis-arkui/js-apis-arkui-builderNode.md#inheritfreezeoptions20)接口继承父自定义组件（即从该BuilderNode节点向上查找的第一个自定义组件）的冻结策略。",
      "line_num": 1091,
      "context": "{\"1086\":\"\",\"1087\":\"ArkUI支持[自定义组件冻结](./state-management/arkts-custom-components-freeze.md)，该功能冻结非激活状态组件的刷新能力。当组件处于非激活状态时，即便其绑定状态变量发生变化，也不会触发组件UI的重新渲染，从而减少复杂UI场景的刷新负载。\",\"1088\":\"\",\"1089\":\"从API version 20开始，BuilderNode节点可以通过[inheritFreezeOptions](../reference/apis-arkui/js-apis-arkui-builderNode.md#inheritfreezeoptions20)接口继承父自定义组件（即从该BuilderNode节点向上查找的第一个自定义组件）的冻结策略。当BuilderNode节点继承父自定义组件的冻结策略时，若父自定义组件的冻结策略设置为开启组件冻结（即[freezeWhenInactive](./state-management/arkts-create-custom-components.md#freezewheninactive11)选项设为true），则BuilderNode节点在不活跃时将会冻结，当切换至活跃状态时解冻，并使用缓存的数据更新节点。\",\"1090\":\"\",\"1091\":\"BuilderNode节点只有通过以下方式上下树时，才会根据该节点是否继承父自定义组件的冻结策略，来更新自己的冻结策略：\",\"1092\":\"\",\"1093\":\"| 类 | 接口 |\",\"1094\":\"| -------- | -------- |\",\"1095\":\"| [FrameNode](../reference/apis-arkui/js-apis-arkui-frameNode.md) | [appendChild](../reference/apis-arkui/js-apis-arkui-frameNode.md#appendchild12)、[insertChildAfter](../reference/apis-arkui/js-apis-arkui-frameNode.md#insertchildafter12)、[removeChild](../reference/apis-arkui/js-apis-arkui-frameNode.md#removechild12)、[clearChildren](../reference/apis-arkui/js-apis-arkui-frameNode.md#clearchildren12)、[addComponentContent](../reference/apis-arkui/js-apis-arkui-frameNode.md#addcomponentcontent12) |\",\"1096\":\"| [NodeContent](../reference/apis-arkui/js-apis-arkui-NodeContent.md) | [addFrameNode](../reference/apis-arkui/js-apis-arkui-NodeContent.md#addframenode12)、[removeFrameNode](../reference/apis-arkui/js-apis-arkui-NodeContent.md#removeframenode12) |\"}",
      "用户拒绝的修改": "从API version 20开始，BuilderNode节点只有通过以下方式上下树时，才会根据该节点是否继承父自定义组件的冻结策略，来更新自己的冻结策略：",
      "注意事项": "修复时需全面核查上下文版本约束范围，避免机械重复版本号导致冗余信息；对条件限制的补充必须精准匹配关联段落，确保新增内容与原始语境逻辑完全自洽。"
    },
    {
      "defect_id": 428679,
      "sentence": "  OpenHarmony SELinux支持两种运行模式：",
      "reference_sentence": "  OpenHarmony SELinux支持两种运行模式：",
      "line_num": 49,
      "context": "{\"44\":\"\",\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\"}",
      "用户拒绝的修改": "  OpenHarmony SELINUX支持两种运行模式：",
      "注意事项": "修复术语大小写时应先检查上下文及行业标准，确保与已有拼写（如\"SELinux\"）严格一致，避免过度统一化修改。"
    },
    {
      "defect_id": 430118,
      "sentence": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。",
      "reference_sentence": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。",
      "line_num": 27,
      "context": "{\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\"}",
      "用户拒绝的修改": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的命名空间。",
      "注意事项": "修复术语一致性时需先确认上下文是否明确定义缩写（例如\"ns=命名空间\"），若原文已建立术语对应关系且涉及参数/变量名时，应优先保留缩写形式以保持技术准确性。"
    },
    {
      "defect_id": 430119,
      "sentence": "default ns和ndk ns可以互相访问全部so，不能访问app ns的so。",
      "reference_sentence": "default ns和ndk ns可以互相访问全部so，不能访问app ns的so。",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\"}",
      "用户拒绝的修改": "default命名空间和ndk命名空间可以互相访问全部so，不能访问app命名空间的so。",
      "注意事项": "严格区分参数名称与术语概念，若\"ns\"在上下文中作为参数变量使用时应保持原文缩写，仅在普通叙述场景才可展开为\"命名空间\"；修改前需核查术语是否涉及代码参数/接口名称等不可变更元素。"
    },
    {
      "defect_id": 428680,
      "sentence": "OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。",
      "reference_sentence": "OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。",
      "line_num": 55,
      "context": "{\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\",\"55\":\"OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。\",\"56\":\"\",\"57\":\"**图1** OpenHarmony SELinux分层架构图\",\"58\":\"\",\"59\":\"![selinux_architect](./figures/SELinux-architecture.png)\"}",
      "用户拒绝的修改": "OpenHarmony SELINUX通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。",
      "注意事项": "修复术语时应严格遵循行业标准大小写形式（如SELinux而非SELINUX），并交叉验证上下文中的既有写法（如第55行已正确使用SELinux），避免仅依赖局部拼写规则进行机械修改。"
    },
    {
      "defect_id": 428678,
      "sentence": "  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。",
      "reference_sentence": "  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"  访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。\",\"42\":\"\",\"43\":\"- **TE**\",\"44\":\"\",\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\"}",
      "用户拒绝的修改": "  类型强制(**T**ype **E**nforcement)，SELINUX策略是由多条类型强制规则构成的。",
      "注意事项": "修复术语大小写时应首先核查该术语的标准拼写形式(如\"SELinux\"为官方固定写法)，同时结合上下文确认是否存在连续使用场景，避免将专有名词的固定格式误判为普通词汇进行机械统一。"
    },
    {
      "defect_id": 430115,
      "sentence": "OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。",
      "reference_sentence": "OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。",
      "line_num": 3,
      "context": "{\"1\":\"# C/C++标准库机制概述\",\"2\":\"\",\"3\":\"OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。\",\"4\":\"\",\"5\":\"## 1. C++兼容性\",\"6\":\"\",\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\"}",
      "用户拒绝的修改": "OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍标准C++库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。",
      "注意事项": "在统一术语表述时需严格验证上下文指代范围，若原文存在多类型标准库（如同时涉及C/C++）时，禁止将复合表述（如\"C/C++标准库\"）简化为单一类型（如\"标准C++库\"），必须保留完整指代避免信息缺失。"
    },
    {
      "defect_id": 430176,
      "sentence": "宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "reference_sentence": "宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"### 支持symbol-version机制\",\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\",\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\"}",
      "用户拒绝的修改": "宏定义`FD_SET`和`FD_CLR`增加了对`fd`有效值的检查。如果传入的`fd`不在区间`[0, 1024)`中，将触发abort crash。",
      "注意事项": "修复时应全面检查所有技术术语（如宏名、变量名、区间表示）的格式一致性，确保反引号` `的使用范围与上下文现有规范完全匹配，避免仅局部修正导致新的格式冲突。"
    },
    {
      "defect_id": 428789,
      "sentence": "2. 在type.te中定义对应的init_svc_param，使对应的标签合法。",
      "reference_sentence": "1. 在parameter_contexts文件内，新增映射关系。",
      "line_num": 38,
      "context": "{\"33\":\"1. 在parameter_contexts文件内，新增映射关系。\",\"34\":\"    ```text\",\"35\":\"    init.svc. u:object_r:init_svc_param:s0\",\"36\":\"    ```\",\"37\":\"\",\"38\":\"2. 在type.te中定义对应的init_svc_param，使对应的标签合法。\",\"39\":\"    ```text\",\"40\":\"    type init_svc_param, parameter_attr;\",\"41\":\"    ```\"}",
      "用户拒绝的修改": "定义对应的 `init_svc_param`，使对应的标签合法。",
      "注意事项": "修复时必须保留原句关键路径信息（如\"在type.te中\"），同时确保句式统一为\"在[文件]中，执行[操作]\"的祈使句结构，避免因过度简化丢失定位信息。"
    },
    {
      "defect_id": 428788,
      "sentence": "参数`'const.secure'`的标签是`u:object_r:secure_param:s0`：",
      "reference_sentence": "参数`'const.secure'`的标签是`u:object_r:secure_param:s0`：",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"通配参数标签映射方法，表示以`'init.svc.'`开头的参数的标签都是`u:object_r:init_svc_param:s0`：\",\"12\":\"```text\",\"13\":\"init.svc. u:object_r:init_svc_param:s0\",\"14\":\"```\",\"15\":\"固定参数标签映射方法，表示参数`'const.secure'`的标签是`u:object_r:secure_param:s0`：\",\"16\":\"```text\",\"17\":\"const.secure u:object_r:secure_param:s0\",\"18\":\"```\",\"19\":\"\",\"20\":\"当使用通配参数标签映射方法时，按最合适的前缀进行匹配，如paramter_contexts同时存在标签映射：\"}",
      "用户拒绝的修改": "参数`'const.secure'`的标签是`u:object_r:Secure_Param:s0`：",
      "注意事项": "修复时必须严格遵循上下文中的命名规范（如全小写格式），并交叉验证所有关联实例（如`init_svc_param`和`secure_param`）的格式一致性，避免仅依赖局部匹配而忽略全局语法规则。"
    },
    {
      "defect_id": 430116,
      "sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "reference_sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "line_num": 12,
      "context": "{\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\",\"9\":\"- 系统库：使用libc++.so，随系统镜像发布。\",\"10\":\"- 应用Native库：使用libc++_shared.so，随应用发布。\",\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\"}",
      "用户拒绝的修改": "两个库使用的命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "注意事项": "修复时必须保留技术限定词（如\"C++\"），避免过度简化导致专业术语缺失；需结合上下文判断术语使用场景，技术文档中特定前缀的重复使用可能具有区分技术细节的重要作用。"
    },
    {
      "defect_id": 430175,
      "sentence": "支持使用dlclose真实卸载动态库的能力。",
      "reference_sentence": "支持使用`dlclose`真实卸载动态库的能力。",
      "line_num": 57,
      "context": "{\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\",\"53\":\"```\",\"54\":\"![zh-cn_image_musl_ld_rpath](figures/dl_rpath.png)\",\"55\":\"\",\"56\":\"### 支持dlclose\",\"57\":\"支持使用dlclose真实卸载动态库的能力。\",\"58\":\"\",\"59\":\"### 支持symbol-version机制\",\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\"}",
      "用户拒绝的修改": "支持使用`dlclose`真实卸载动态库的能力。",
      "注意事项": "在修改代码元素格式时，必须优先检查上下文相同术语的呈现方式（如`dlclose`在参考句中的反引号用法），并确保全文档同类元素的格式统一性，避免局部修改破坏整体一致性规范。"
    },
    {
      "defect_id": 428673,
      "sentence": "OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**",
      "reference_sentence": "OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux概述\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**\",\"6\":\"，以下简称SELinux）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。本文基于SELinux访问控制模型，提供OpenHarmony SELinux功能的开发指导。\",\"7\":\"\",\"8\":\"OpenHarmony SELinux支持以下功能：\",\"9\":\"\",\"10\":\"1. 支持访问参数、SA、HDF管控。\"}",
      "用户拒绝的修改": "OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **LINUX**",
      "注意事项": "修复术语大小写时应严格遵循上下文标准写法，优先核对专有名词的标准格式（如\"Linux\"首字母大写而非全大写），避免将缩写规则错误套用到全称组成部分。"
    },
    {
      "defect_id": 428707,
      "sentence": "由init、chipset_init通过cfg文件孵化的Native进程，例如ueventd、installs。",
      "reference_sentence": "由init、chipset_init通过cfg文件孵化的HDF服务进程，例如wifi_host、camera_host。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 新增Native进程\",\"4\":\"\",\"5\":\"**适用场景**\",\"6\":\"\",\"7\":\"由init、chipset_init通过cfg文件孵化的Native进程，例如ueventd、installs。\",\"8\":\"\",\"9\":\"**配置指导**\",\"10\":\"\",\"11\":\"1. 在本进程的cfg文件中，新增secon字段，建立进程与标签的映射关系。如果未配置secon字段，进程在SELinux使能状态会被拦截启动。\",\"12\":\"    ```json\"}",
      "用户拒绝的修改": "由init、chipset_init通过cfg文件孵化的HDF服务进程，例如ueventd、installs。",
      "注意事项": "修复时必须严格遵循上下文中的术语定义和章节标题（如\"新增Native进程\"），避免跨概念替换；区分不同技术术语的适用场景（如Native进程与HDF服务进程），不可仅凭句式相似性修改核心名词。"
    },
    {
      "defect_id": 430120,
      "sentence": "app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "reference_sentence": "app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "line_num": 40,
      "context": "{\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\"}",
      "用户拒绝的修改": "app命名空间能访问ndk命名空间的全部so，不能访问default命名空间的so。",
      "注意事项": "修复术语一致性时需优先识别参数传递场景，若\"ns\"在上下文中作为固定参数名称或技术术语出现（如代码变量/接口参数），应保留原始缩写形式而非强制展开为全称。"
    },
    {
      "defect_id": 429387,
      "sentence": "当BuilderNode节点设置为继承父自定义组件的冻结策略时，BuilderNode节点的冻结策略将与其上层最近的自定义组件或BuilderNode节点的冻结策略保持一致。",
      "reference_sentence": "从API version 20开始，BuilderNode节点可以通过[inheritFreezeOptions](../reference/apis-arkui/js-apis-arkui-builderNode.md#inheritfreezeoptions20)接口继承父自定义组件（即从该BuilderNode节点向上查找的第一个自定义组件）的冻结策略。",
      "line_num": 1103,
      "context": "{\"1098\":\"| [RenderNode](../reference/apis-arkui/js-apis-arkui-RenderNode.md) | [appendChild](../reference/apis-arkui/js-apis-arkui-RenderNode.md#appendchild)、[insertChildAfter](../reference/apis-arkui/js-apis-arkui-RenderNode.md#insertchildafter)、[removeChild](../reference/apis-arkui/js-apis-arkui-RenderNode.md#removechild)、[clearChildren](../reference/apis-arkui/js-apis-arkui-RenderNode.md#clearchildren) |\",\"1099\":\"| [NodeAdaper](../reference/apis-arkui/js-apis-arkui-frameNode.md#nodeadapter12) | 节点通过[懒加载](../reference/apis-arkui/arkui-ts/ts-rendering-control-lazyforeach.md)方式上下树时 |\",\"1100\":\"\",\"1101\":\"> **说明：**\",\"1102\":\">\",\"1103\":\"> 当BuilderNode节点设置为继承父自定义组件的冻结策略时，BuilderNode节点的冻结策略将与其上层最近的自定义组件或BuilderNode节点的冻结策略保持一致。\",\"1104\":\">\",\"1105\":\"> 当BuilderNode节点被冻结时，调用[update](../reference/apis-arkui/js-apis-arkui-builderNode.md#update)接口不会触发节点的更新，等其被解冻时再更新节点。\",\"1106\":\"\",\"1107\":\"```ts\",\"1108\":\"\"}",
      "用户拒绝的修改": "从API version 20开始，当BuilderNode节点设置为继承父自定义组件的冻结策略时，BuilderNode节点的冻结策略将与其上层最近的自定义组件或BuilderNode节点的冻结策略保持一致。",
      "注意事项": "修复时应严格核对上下文中的版本限制条件范围，确保新增的版本说明在问题句所在段落已有明确依据，避免将其他段落的版本信息错误移植到未提及该条件的说明位置。"
    },
    {
      "defect_id": 430117,
      "sentence": "动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。",
      "reference_sentence": "动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。",
      "line_num": 25,
      "context": "{\"20\":\"应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。解决此问题需要更新应用或者共享库HAR包的SDK版本。\",\"21\":\"\",\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\"}",
      "用户拒绝的修改": "动态库加载命名空间（命名空间，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。",
      "注意事项": "保留必要英文术语时需维持括号内外一致性，确保技术缩写来源清晰（如\"namespace\"对应\"ns\"），避免因过度统一中文翻译导致概念混淆。"
    },
    {
      "defect_id": 428674,
      "sentence": "，以下简称SELinux）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。",
      "reference_sentence": "，以下简称SELinux）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。",
      "line_num": 6,
      "context": "{\"1\":\"# OpenHarmony SELinux概述\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**\",\"6\":\"，以下简称SELinux）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。本文基于SELinux访问控制模型，提供OpenHarmony SELinux功能的开发指导。\",\"7\":\"\",\"8\":\"OpenHarmony SELinux支持以下功能：\",\"9\":\"\",\"10\":\"1. 支持访问参数、SA、HDF管控。\",\"11\":\"2. 支持设置应用标签。\"}",
      "用户拒绝的修改": "，以下简称SELINUX）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。",
      "注意事项": "修复术语大小写时应先确认其标准形式（如SELinux为固定首字母大写），避免机械统一；同时需结合上下文识别首次定义时的正确格式，确保后续引用完全一致。"
    },
    {
      "defect_id": 430178,
      "sentence": "自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。",
      "reference_sentence": "自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。",
      "line_num": 68,
      "context": "{\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\"}",
      "用户拒绝的修改": "自API12起，newlocale及setlocale接口支持将locale设置为C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。",
      "注意事项": "修复时需严格对照上下文格式规范，保持术语使用和句式结构的完全统一，避免因添加/删除介词破坏原有表达模式；特别注意检查同类语句是否存在隐性格式约定。"
    },
    {
      "defect_id": 428024,
      "sentence": "当整改了不合理的基线策略后，删除了不合理的策略，但是未同时删除基线时，也会触发编译报错，关键报错信息`check 'xxx' baseline in user mode failed`，xxx表示高危进程标签，报错如下：",
      "reference_sentence": "当整改了不合理的权限组合配置后，删除了不合理的策略，但是未同时删除白名单时，也会触发编译报错，关键报错信息`remove the following unnecessary whitelists in rule 'xxx' part 'user'`，这里的`xxx`表示被拦截的检查项`name`，报错如下：",
      "line_num": 262,
      "context": "{\"257\":\"\",\"258\":\"- 方式二：修改不合理的策略，以满足要求，例如，更改方案，避免违反基线。\",\"259\":\"\",\"260\":\"### 删除冗余的基线\",\"261\":\"\",\"262\":\"当整改了不合理的基线策略后，删除了不合理的策略，但是未同时删除基线时，也会触发编译报错，关键报错信息`check 'xxx' baseline in user mode failed`，xxx表示高危进程标签，报错如下：\",\"263\":\"```\",\"264\":\"        check 'sh' baseline in user mode failed\",\"265\":\"                expect rule: (allow sh rootfs (dir (search))); actual rule: (allow sh rootfs (dir ()))\",\"266\":\"        There are two solutions:\",\"267\":\"        1. Add the above actual rule to baseline file 'sh.baseline' under 'base/security/selinux_adapter/sepolicy'\"}",
      "用户拒绝的修改": "当整改了不合理的权限组合配置后，删除了不合理的策略，但是未同时删除白名单时，也会触发编译报错，关键报错信息`check 'xxx' baseline in user mode failed`，xxx表示高危进程标签，报错如下：",
      "注意事项": "修复时必须严格核查上下文术语使用场景，优先保持原文核心概念（如\"基线\"）的稳定性，避免机械替换导致概念混淆；若需统一用词，需确保整个文档中所有相关术语同步调整且符合技术定义。"
    },
    {
      "defect_id": 431688,
      "sentence": "系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)）",
      "reference_sentence": "系统库与应用Native库都在使用C++标准库（参考[标准C++库](../reference/native-lib/cpp.md)）",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。\",\"4\":\"\",\"5\":\"## 1. C++兼容性\",\"6\":\"\",\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\",\"9\":\"- 系统库：使用libc++.so，随系统镜像发布。\",\"10\":\"- 应用Native库：使用libc++_shared.so，随应用发布。\",\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\"}",
      "用户拒绝的修改": "系统库与应用Native库都在使用C++标准库（参考[标准C++库](../reference/native-lib/cpp.md)）",
      "注意事项": "修复术语不一致时需全面检查上下文已确立的规范名称，确保链接文本与目标内容强相关（如保留\"libc++版本\"的版本指向性），避免因过度统一术语而丢失关键技术细节。"
    },
    {
      "defect_id": 428025,
      "sentence": "需要同时删除基线，将`//base/security/selinux_adapter/sepolicy/`下的基线文件`sh.baseline`中的相关基线删除。",
      "reference_sentence": "需要同时删除白名单，将`//base/security/selinux_adapter/sepolicy/`下的白名单文件`perm_group_whitelist.json`中的相关白名单删除。",
      "line_num": 277,
      "context": "{\"272\":\"        There are two solutions:\",\"273\":\"        1. Add the above actual rule to baseline file 'sh.baseline' under 'base/security/selinux_adapter/sepolicy' and add developer_only\",\"274\":\"        2. Change the policy to satisfy expect rule\",\"275\":\"```\",\"276\":\"\",\"277\":\"需要同时删除基线，将`//base/security/selinux_adapter/sepolicy/`下的基线文件`sh.baseline`中的相关基线删除。\",\"278\":\"\",\"279\":\"这里根据报错，要删除基线`\\\"(allow sh rootfs (dir (search)))\\\"`，另外，以符合`\\\"actual rule\\\"`，其他冗余基线报错的删除位置参考下表：\",\"280\":\"\",\"281\":\"**表4** 篡改高危进程基线检查冗余基线与报错对应关系\",\"282\":\"| user基线冗余 | developer基线冗余 | 删除基线字段位置 |\"}",
      "用户拒绝的修改": "需要同时删除白名单，将`//base/security/selinux_adapter/sepolicy/`下的白名单文件`sh.baseline`中的相关白名单删除。",
      "注意事项": "修复时应优先验证原文术语在上下文中的正确性和一致性，避免将不同场景的专用术语（如\"基线\"与\"白名单\"）强制统一；若原文术语与上下文存在明确关联（如问题句中的`sh.baseline`文件与\"基线\"的对应关系），则禁止替换为其他术语。"
    },
    {
      "defect_id": 430179,
      "sentence": "新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。",
      "reference_sentence": "新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。",
      "line_num": 68,
      "context": "{\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\"}",
      "用户拒绝的修改": "新增在zh_CN及zh_CN.UTF-8的locale设置下对`strtod_l`、`wcstod_l`和`localeconv`的支持。",
      "注意事项": "保持同一句子中同类元素的格式统一，特别注意locale名称（如zh_CN.UTF-8）与函数名（如strtod_l）的符号标记方式需与上下文规范一致，避免混合使用纯文本与代码符号格式。"
    },
    {
      "defect_id": 428028,
      "sentence": "### 修复方法",
      "reference_sentence": "### 修复方法主要有两种修复方式：",
      "line_num": 310,
      "context": "{\"305\":\"\",\"306\":\"### 拦截原因\",\"307\":\"\",\"308\":\"仅添加`allow scontext tcontext:tclass ioctl`规则会导致主体有对tcontext:tclass所有ioctl的权限，权限过大被编译拦截，需添加具体的allowxperm对ioctl权限精细化管控，达到权限最小化。\",\"309\":\"\",\"310\":\"### 修复方法\",\"311\":\"\",\"312\":\"主要有两种修复方式：\",\"313\":\"- 方式一：根据avc日志对ioctl的ioctlcmd进行限制。例如，有下面的avc日志：\",\"314\":\"    ```text\",\"315\":\"    #avc:  denied  { ioctl } for  pid=1 comm=\\\"init\\\" path=\\\"/data/app/el1/bundle/public\\\" dev=\\\"mmcblk0p11\\\" ino=652804 ioctlcmd=0x6613 scontext=u:r:init:s0 tcontext=u:object_r:data_app_el1_file:s0 tclass=dir permissive=0\"}",
      "用户拒绝的修改": "### 修复方法主要有两种修复方式：",
      "注意事项": "严格保持标题层级与格式统一，修复时需确保标题行不添加额外说明性文字；核对上下文标点符号和段落间距，保证修改后的标题与相邻章节保持完全一致的排版风格。"
    },
    {
      "defect_id": 428026,
      "sentence": "**表4** 篡改高危进程基线检查冗余基线与报错对应关系",
      "reference_sentence": "**表2** 主客体组合权限检查项冗余白名单字段与报错对应关系",
      "line_num": 281,
      "context": "{\"276\":\"\",\"277\":\"需要同时删除基线，将`//base/security/selinux_adapter/sepolicy/`下的基线文件`sh.baseline`中的相关基线删除。\",\"278\":\"\",\"279\":\"这里根据报错，要删除基线`\\\"(allow sh rootfs (dir (search)))\\\"`，另外，以符合`\\\"actual rule\\\"`，其他冗余基线报错的删除位置参考下表：\",\"280\":\"\",\"281\":\"**表4** 篡改高危进程基线检查冗余基线与报错对应关系\",\"282\":\"| user基线冗余 | developer基线冗余 | 删除基线字段位置 |\",\"283\":\"| -------- | -------- | -------- |\",\"284\":\"| 是 | 是 | developer_only外 |\",\"285\":\"| 否 | 是 | developer_only内 |\",\"286\":\"| 是 | 否 | developer_only外 |\"}",
      "用户拒绝的修改": "**表2** 主客体组合权限检查项冗余白名单字段与报错对应关系",
      "注意事项": "修复时应严格区分术语准确性和编号一致性，优先保持原文核心术语（如\"基线\"）不变，仅修正真正冲突的编号或命名（如\"表4\"→\"表2\"），并通过上下文验证表格内容的关联性。"
    },
    {
      "defect_id": 428023,
      "sentence": "### 删除冗余的基线",
      "reference_sentence": "### 删除冗余的白名单",
      "line_num": 260,
      "context": "{\"255\":\"    | 否 | 是 | 是 |\",\"256\":\"    | 是 | 否 | 将developer_only内的基线挪到外部 |\",\"257\":\"\",\"258\":\"- 方式二：修改不合理的策略，以满足要求，例如，更改方案，避免违反基线。\",\"259\":\"\",\"260\":\"### 删除冗余的基线\",\"261\":\"\",\"262\":\"当整改了不合理的基线策略后，删除了不合理的策略，但是未同时删除基线时，也会触发编译报错，关键报错信息`check 'xxx' baseline in user mode failed`，xxx表示高危进程标签，报错如下：\",\"263\":\"```\",\"264\":\"        check 'sh' baseline in user mode failed\",\"265\":\"                expect rule: (allow sh rootfs (dir (search))); actual rule: (allow sh rootfs (dir ()))\"}",
      "用户拒绝的修改": "### 删除冗余的白名单",
      "注意事项": "在修复语言表达一致性时，需优先确认上下文术语是否具备局部一致性（如当前章节的“基线”），避免机械匹配全局标题而错误替换正确术语；若上下文明确存在术语复用逻辑，应以当前段落语义为核心保留原表述。"
    },
    {
      "defect_id": 428029,
      "sentence": "### 编译拦截",
      "reference_sentence": "### 编译拦截新增和删除高危进程策略，都会触发编译报错，关键报错信息`check 'xxx' baseline in user mode failed`，xxx表示高危进程标签，报错如下：",
      "line_num": 294,
      "context": "{\"289\":\"\",\"290\":\"### 检查说明\",\"291\":\"\",\"292\":\"涉及配置ioctl相关的SELinux策略时，除了配置allow规则以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。\",\"293\":\"\",\"294\":\"### 编译拦截\",\"295\":\"\",\"296\":\"配置的 allow 规则访问权限包含了 ioctl，但未限定 ioctl 权限参数时，会触发编译报错，关键报错信息`check ioctl rule in user mode failed.`，报错如下：\",\"297\":\"```text\",\"298\":\" check ioctl rule in user mode failed.\",\"299\":\" violation list (allow scontext tcontext:tclass ioctl)\"}",
      "用户拒绝的修改": "### 编译拦截配置的 allow 规则访问权限包含了 ioctl，但未限定 ioctl 权限参数时，会触发编译报错，关键报错信息`check ioctl rule in user mode failed.`，报错如下：",
      "注意事项": "保持标题与内容结构的严格统一，避免在章节标题后直接添加条件描述（应参照示例统一使用\"策略+触发结果\"结构）；报错信息中的变量部分需使用'xxx'占位符格式（如`check 'xxx' baseline`），避免直接固化字段导致模式不一致。"
    },
    {
      "defect_id": 428540,
      "sentence": "所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。",
      "reference_sentence": "所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"SELinux对外提供更新文件或目录SELinux标签的接口。\",\"6\":\"\",\"7\":\"## 接口说明\",\"8\":\"\",\"9\":\"所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。相关接口列表如下：\",\"10\":\"\",\"11\":\"| 接口名 | 接口说明 | 参数说明 |\",\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\"}",
      "用户拒绝的修改": "所有接口均为Native C内部接口，仅提供底层能力，不对应用程序开放。",
      "注意事项": "修复时应优先检查上下文术语使用习惯，保持现有文档的术语一致性；在规范性和用户认知度冲突时，优先选择用户更熟悉且上下文已统一的高频词汇（如\"应用\"），避免因过度规范化破坏表达连贯性。"
    },
    {
      "defect_id": 428187,
      "sentence": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：",
      "reference_sentence": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"## 使用neverallow对业务做安全防护\",\"62\":\"\",\"63\":\"neverallow可以阻止不合理的策略配置，因此可以作为安全防护手段，避免本业务的SELinux业务被恶意修改。\",\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\",\"69\":\"表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。\"}",
      "用户拒绝的修改": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行阻止：",
      "注意事项": "在统一术语时应优先检查上下文已有用词规范，确保修改后的术语既符合技术场景准确性（如\"限制\"对应权限管理场景），又与文档前后表述保持严格一致。"
    },
    {
      "defect_id": 428815,
      "sentence": "1. 在service_contexts文件内，新增SAID与SA标签的映射关系，",
      "reference_sentence": "1. 在service_contexts文件内，新增HDF服务名与HDF标签的映射关系，",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"某个进程向samgr注册SA服务，其他进程在与该进程进行IPC通信之前，需要获取该SA服务，SA提供方需要为该SA配置SELinux标签，否则该SA会被SELinux配置为`u:object_r:default_service:s0`标签，配置访问`default_service`的策略会被neverallow禁止。\",\"8\":\"\",\"9\":\"**配置指导**\",\"10\":\"\",\"11\":\"1. 在service_contexts文件内，新增SAID与SA标签的映射关系，\",\"12\":\"    ```text\",\"13\":\"    10      u:object_r:sa_render_service:s0\",\"14\":\"    ```\",\"15\":\"\",\"16\":\"2. 在type.te中定义对应的`sa_render_service`，使对应的标签合法。\"}",
      "用户拒绝的修改": "1. 在service_contexts文件内，新增SA服务名与SA标签的映射关系，",
      "注意事项": "在统一术语表述前必须优先确认上下文中的技术名词准确性，避免将文档规范一致性需求覆盖实际参数名称要求；针对不同组件体系（如SA/HDF）需保持各自术语闭环，跨体系替换前需交叉验证文件规范和技术实现。"
    },
    {
      "defect_id": 428033,
      "sentence": "规则中存在新增的 permissive 主体类型。",
      "reference_sentence": "规则中存在新增的 permissive 主体类型。",
      "line_num": 361,
      "context": "{\"356\":\"    2. Change the policy to avoid violating rule.\",\"357\":\"```\",\"358\":\"\",\"359\":\"### 拦截原因\",\"360\":\"\",\"361\":\"规则中存在新增的 permissive 主体类型。\",\"362\":\"\",\"363\":\"### 修复方法\",\"364\":\"\",\"365\":\"主要有两种修复方式：\",\"366\":\"- 方式一：删除不必要的 permissive 定义。\"}",
      "用户拒绝的修改": "检查规则中是否新增了 permissive 主体类型。",
      "注意事项": "拦截原因描述需保持肯定陈述句式，修复建议才使用祈使句。严格区分文档中\"拦截原因\"与\"修复方法\"的句式规范，前者用判断句说明问题事实，后者用动作导向句式指导操作。"
    },
    {
      "defect_id": 428362,
      "sentence": "## 基础策略文件介绍基础策略文件，是指SELinux基础框架的SELinux策略文件，一般不涉及修改。",
      "reference_sentence": "## 通用策略文件介绍通用策略文件，是指设备开发者进行SELinux策略配置时，涉及修改的文件。",
      "line_num": 34,
      "context": "{\"29\":\"| sevice_contexts | SA服务标签映射文件，体现SA服务与标签的映射关系。 |\",\"30\":\"| hdf_service_contexts | HDF服务标签映射文件，体现HDF服务与标签的映射关系。 |\",\"31\":\"\",\"32\":\"## 基础策略文件介绍\",\"33\":\"\",\"34\":\"基础策略文件，是指SELinux基础框架的SELinux策略文件，一般不涉及修改。\",\"35\":\"\",\"36\":\"| 文件名 | 文件说明 |\",\"37\":\"| -------- | -------- |\",\"38\":\"| security_classes | class定义。 |\",\"39\":\"| initial_sids | sid定义。 |\"}",
      "用户拒绝的修改": "## 基础策略文件介绍基础策略文件，是指SELinux基础框架的SELinux策略文件，通常不涉及修改。",
      "注意事项": "修复时需严格检查术语一致性（如\"基础策略文件\"与上下文其他\"通用策略文件\"的区分），并保持句式结构平行（如\"涉及修改的文件\"对应\"不涉及修改\"的否定表达模式）。"
    },
    {
      "defect_id": 428363,
      "sentence": "  - `tcontext=u:object_r:selinuxfs:s0`，表示被访问客体SELinux标签为`u:object_r:selinuxfs:s0`。",
      "reference_sentence": "  - `scontext=u:r:hdcd:s0`，表示主体SELinux标签为`u:r:hdcd:s0`。",
      "line_num": 66,
      "context": "{\"61\":\"  - `comm=\\\"setenforce\\\"`，表示主体进程名为`setenforce`。\",\"62\":\"  - `path=\\\"/sys/fs/selinux/enforce\\\"`，表示被访问客体为`/sys/fs/selinux/enforce`。\",\"63\":\"  - `dev=\\\"selinuxfs\\\"`，表示被访问客体属于selinuxfs这一文件系统。\",\"64\":\"  - `ino=4`，表示文件节点编号为4。\",\"65\":\"  - `scontext=u:r:hdcd:s0`，表示主体SELinux标签为`u:r:hdcd:s0`。\",\"66\":\"  - `tcontext=u:object_r:selinuxfs:s0`，表示被访问客体SELinux标签为`u:object_r:selinuxfs:s0`。\",\"67\":\"  - `tclass=file`，表示当前执行file的操作类型。\",\"68\":\"  - `permissive=1`，表示当前SELinux处于宽容模式，只告警不拦截。另外，当`permissive=0`时，表示强制模式，会告警并拦截。\",\"69\":\"\",\"70\":\"开发者可以使用关键字`avc denied`来过滤日志，对于影响业务的avc告警，可以利用告警提供的信息来编写相应的SELinux策略，例如：\",\"71\":\"```text\"}",
      "用户拒绝的修改": "  - `tcontext=u:object_r:selinuxfs:s0`，表示被访问对象SELinux标签为`u:object_r:selinuxfs:s0`。",
      "注意事项": "修复时应严格保持技术术语一致性（如\"客体\"不可替换为近义词\"对象\"），并确保对偶概念（主体/客体）的用词准确对应，同时需检查上下文句式结构保持平行统一。"
    },
    {
      "defect_id": 431693,
      "sentence": "1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。",
      "reference_sentence": "2. app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\"}",
      "用户拒绝的修改": "1. default命名空间和ndk命名空间可以互相访问全部so，不能访问app命名空间的so。",
      "注意事项": "修复时应优先保留原文的术语缩写形式（如\"ns\"），仅在首次出现或定义时补充全称，确保上下文术语使用一致性；修改前需检查问题句所在段落及参考句的用词习惯，避免破坏文档已有术语体系。"
    },
    {
      "defect_id": 431691,
      "sentence": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。",
      "reference_sentence": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。",
      "line_num": 27,
      "context": "{\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\"}",
      "用户拒绝的修改": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的命名空间。",
      "注意事项": "修复术语不一致前需确认上下文是否已明确定义缩写/全称对应关系，优先沿用文档已有术语形式（如示例中\"ns\"已在括号内定义），避免在已规范缩写的场景中强行展开全称。"
    },
    {
      "defect_id": 428027,
      "sentence": "## ioctl的权限策略检查",
      "reference_sentence": "## 篡改高危进程基线检查",
      "line_num": 288,
      "context": "{\"283\":\"| -------- | -------- | -------- |\",\"284\":\"| 是 | 是 | developer_only外 |\",\"285\":\"| 否 | 是 | developer_only内 |\",\"286\":\"| 是 | 否 | developer_only外 |\",\"287\":\"\",\"288\":\"## ioctl的权限策略检查\",\"289\":\"\",\"290\":\"### 检查说明\",\"291\":\"\",\"292\":\"涉及配置ioctl相关的SELinux策略时，除了配置allow规则以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。\",\"293\":\"\"}",
      "用户拒绝的修改": "## 篡改高危进程基线检查",
      "注意事项": "修复时必须同时验证标题与上下文内容主题的严格匹配性，避免仅依赖格式一致性而忽略语义关联；参考其他标题时应先确认其与当前章节功能描述的逻辑对应关系。"
    },
    {
      "defect_id": 428034,
      "sentence": "主要有两种修复方式：",
      "reference_sentence": "主要有两种修复方式：",
      "line_num": 365,
      "context": "{\"360\":\"\",\"361\":\"规则中存在新增的 permissive 主体类型。\",\"362\":\"\",\"363\":\"### 修复方法\",\"364\":\"\",\"365\":\"主要有两种修复方式：\",\"366\":\"- 方式一：删除不必要的 permissive 定义。\",\"367\":\"- 方式二：添加主体类型scontext到 `//base/security/selinux_adapter/sepolicy/` 下白名单 `permissive_whitelist.json` 中，修改该白名单需要评估合理性。\",\"368\":\"    拦截日志中 `user mode` 表示该策略是user和开发者模式共用的基线，另外 `developer mode` 则表示该策略仅作为开发者模式下的基线，相应添加到白名单文件。\",\"369\":\"    ```text\",\"370\":\"    {\"}",
      "用户拒绝的修改": "提供两种修复方式：",
      "注意事项": "修复时应区分引导性陈述句和操作步骤祈使句的语境差异，保留章节标题/总起句的中性陈述特征，仅对具体操作步骤强制要求祈使句式，避免破坏技术文档的层级结构。"
    },
    {
      "defect_id": 428379,
      "sentence": "表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：",
      "reference_sentence": "表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：",
      "line_num": 89,
      "context": "{\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\"}",
      "用户拒绝的修改": "允许`subject`对`object`进行`class`中的`permissions`操作，其中：",
      "注意事项": "修复时必须完整检查上下文所有同类语句的句式特征，确保修改后的表达方式与相邻语句的语法结构、时态和语态完全匹配，优先保持原有文本风格而非机械套用语法规则。"
    },
    {
      "defect_id": 431689,
      "sentence": "应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。",
      "reference_sentence": "应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。",
      "line_num": 20,
      "context": "{\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\",\"18\":\"**已知C++兼容性问题：**\",\"19\":\"\",\"20\":\"应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。解决此问题需要更新应用或者共享库HAR包的SDK版本。\",\"21\":\"\",\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\"}",
      "用户拒绝的修改": "应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so包含此符号。",
      "注意事项": "在确保语言简洁性的同时，需优先保留技术术语的重复以维持对比结构的准确性，避免因过度简化导致关键信息弱化；处理对比句式时，应通过明确代词指代（如\"后者\"）或调整句式（如\"而API11之后版本则包含该符号\"）替代机械重复，而非直接省略核心名词。"
    },
    {
      "defect_id": 428541,
      "sentence": "根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。",
      "reference_sentence": "单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。",
      "line_num": 17,
      "context": "{\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\",\"19\":\"## 开发步骤\",\"20\":\"\",\"21\":\"1. 编译依赖添加\",\"22\":\"\"}",
      "用户拒绝的修改": "根据当前目录的父目录标签，单线程更新当前目录的标签，递归遍历更新整个目录。",
      "注意事项": "修复时应严格区分\"路径\"（指代文件系统地址字符串）和\"目录\"（指代实体文件夹）的技术定义，特别关注参数命名（如path）与操作对象（如目录）的对应关系，保持参数描述与接口定义中\"path表示绝对路径\"的术语一致性。"
    },
    {
      "defect_id": 428364,
      "sentence": "  - `tclass=file`，表示当前执行file的操作类型。",
      "reference_sentence": "  - `open`，表示当前执行的操作权限。",
      "line_num": 67,
      "context": "{\"62\":\"  - `path=\\\"/sys/fs/selinux/enforce\\\"`，表示被访问客体为`/sys/fs/selinux/enforce`。\",\"63\":\"  - `dev=\\\"selinuxfs\\\"`，表示被访问客体属于selinuxfs这一文件系统。\",\"64\":\"  - `ino=4`，表示文件节点编号为4。\",\"65\":\"  - `scontext=u:r:hdcd:s0`，表示主体SELinux标签为`u:r:hdcd:s0`。\",\"66\":\"  - `tcontext=u:object_r:selinuxfs:s0`，表示被访问客体SELinux标签为`u:object_r:selinuxfs:s0`。\",\"67\":\"  - `tclass=file`，表示当前执行file的操作类型。\",\"68\":\"  - `permissive=1`，表示当前SELinux处于宽容模式，只告警不拦截。另外，当`permissive=0`时，表示强制模式，会告警并拦截。\",\"69\":\"\",\"70\":\"开发者可以使用关键字`avc denied`来过滤日志，对于影响业务的avc告警，可以利用告警提供的信息来编写相应的SELinux策略，例如：\",\"71\":\"```text\",\"72\":\"audit: type=1400 audit(1502458430.566:4): avc:  denied  { open } for  pid=1658 comm=\\\"setenforce\\\" path=\\\"/sys/fs/selinux/enforce\\\" dev=\\\"selinuxfs\\\" ino=4 scontext=u:r:hdcd:s0 tcontext=u:object_r:selinuxfs:s0 tclass=file permissive=1\"}",
      "用户拒绝的修改": "  - `tclass=file`，表示当前执行的操作类型为file。",
      "注意事项": "严格区分技术术语的客体类型（tclass）与操作类型（operation），修复时必须保持上下文句式统一（如\"表示被访问客体为...\"），避免混淆权限、类型等核心概念。"
    },
    {
      "defect_id": 431694,
      "sentence": "2. app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "reference_sentence": "2. app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "line_num": 40,
      "context": "{\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\"}",
      "用户拒绝的修改": "2. app命名空间能访问ndk命名空间的全部so，不能访问default命名空间的so。",
      "注意事项": "修复术语一致性时需优先检查上下文中的缩写使用习惯，若原文已统一使用缩写（如\"ns\"），则无需强制替换为全称（如\"命名空间\"），避免破坏上下文术语的统一性。"
    },
    {
      "defect_id": 431690,
      "sentence": "### 动态库加载命名空间隔离",
      "reference_sentence": "动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。",
      "line_num": 24,
      "context": "{\"19\":\"\",\"20\":\"应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。解决此问题需要更新应用或者共享库HAR包的SDK版本。\",\"21\":\"\",\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\"}",
      "用户拒绝的修改": "### 动态库加载命名空间隔离（namespace，下面统称为ns）",
      "注意事项": "技术文档首次出现英文术语时应采用\"中文（英文）\"格式并定义简称，后续统一使用中文或简称，避免中英文混用；需严格检查同一术语在全文档中的表达形式一致性，特别是标题与正文、首次出现与后续引用的统一性。"
    },
    {
      "defect_id": 428380,
      "sentence": "表示不允许`subject`对`object`进行`class`中的`permissions`操作。",
      "reference_sentence": "表示不允许`subject`对`object`进行`class`中的`permissions`操作。",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\",\"95\":\"```\",\"96\":\"表示不允许`subject`对`object`进行`class`中的`permissions`操作。\",\"97\":\"\",\"98\":\"## 策略宏隔离\",\"99\":\"\",\"100\":\"在考虑设备开发者便利的同时，需要兼顾商用设备安全性，因此OpenHarmony SELinux提供了策略隔离宏，决定在不同版本上策略是否生效。OpenHarmony SELinux中支持对仅在root版本生效的策略做宏隔离，宏名称为`debug_only`。在用于设备开发者调试的root版本中，也就是在版本编译命令中指定`--build-variant root`时，宏开启。在用于商用发布的user版本中，也就是在版本编译命令中指定`--build-variant user`时，宏关闭。该宏的使用方法参考如下:\",\"101\":\"```text\"}",
      "用户拒绝的修改": "不允许`subject`对`object`进行`class`中的`permissions`操作。",
      "注意事项": "修复时应优先保持与上下文句式结构一致，明确用户指定的祈使句等特定表达要求，避免孤立处理句子而忽略相邻语句的语法连贯性。"
    },
    {
      "defect_id": 431692,
      "sentence": "OpenHarmony中动态库加载namespace配置的情况",
      "reference_sentence": "OpenHarmony中动态库加载namespace配置的情况",
      "line_num": 29,
      "context": "{\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\",\"33\":\"- ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。\",\"34\":\"\"}",
      "用户拒绝的修改": "OpenHarmony中动态库加载命名空间配置的情况",
      "注意事项": "修复术语一致性时需严格区分技术专有名词的中英文使用场景，若上下文已明确混用定义（如\"namespace\"在文档中被特别解释为\"ns\"缩写），应优先保留原文术语而非强制统一翻译，避免改变技术语义。"
    },
    {
      "defect_id": 431915,
      "sentence": "宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。",
      "reference_sentence": "宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。",
      "line_num": 65,
      "context": "{\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\",\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\"}",
      "用户拒绝的修改": "在宏定义FD_ISSET中增加对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。",
      "注意事项": "修复时应优先保持与原文档上下文句式风格一致，若相邻条目均使用陈述句描述功能变更，则无需强制改为祈使句，避免破坏文档整体统一性。"
    },
    {
      "defect_id": 431931,
      "sentence": "管道损坏",
      "reference_sentence": "管道损坏",
      "line_num": 95,
      "context": "{\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\"}",
      "用户拒绝的修改": "管道损坏信号",
      "注意事项": "修复术语不一致时应优先核对上下文现有用法，避免机械添加后缀；当参考句子本身符合上下文规范时，应保留原表述而非强制统一。"
    },
    {
      "defect_id": 431929,
      "sentence": "无效内存访问",
      "reference_sentence": "无效内存访问",
      "line_num": 93,
      "context": "{\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\"}",
      "用户拒绝的修改": "无效内存访问信号",
      "注意事项": "修复时应严格遵循上下文已有术语格式（如\"SIG名称+纯描述\"结构），避免添加冗余限定词；需特别检查相邻条目的一致性模式，确保不破坏现有统一命名体系。"
    },
    {
      "defect_id": 431937,
      "sentence": "停止在终端输入",
      "reference_sentence": "停止在终端输入",
      "line_num": 102,
      "context": "{\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "停止在终端输入信号",
      "注意事项": "修复术语不一致时必须严格对照上下文现有用法，避免添加冗余限定词（如\"信号\"）破坏原有表述体系；优先保持上下文术语的统一性而非机械补全术语成分。"
    },
    {
      "defect_id": 431919,
      "sentence": "SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。",
      "reference_sentence": "SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。",
      "line_num": 77,
      "context": "{\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\",\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\"}",
      "用户拒绝的修改": "了解SIGRTMIN和__libc_current_sigrtmin的值是35，表示可供应用程序使用的实时信号起始编号（应用实际只能使用46及以上的信号）。",
      "注意事项": "修复时应优先检查上下文句式风格一致性，避免机械套用规则破坏原有技术准确性；在技术文档中应尊重陈述句的规范表达方式，仅在明确需要指导性语句时才使用祈使句。"
    },
    {
      "defect_id": 431923,
      "sentence": "调试断点",
      "reference_sentence": "调试断点",
      "line_num": 87,
      "context": "{\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\",\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\"}",
      "用户拒绝的修改": "调试断点信号",
      "注意事项": "修复时应优先检查上下文术语使用习惯，避免在已有统一命名规范的场景中（如信号列表）冗余添加\"信号\"等后缀，保持与相邻条目表述方式严格一致。"
    },
    {
      "defect_id": 431921,
      "sentence": "中断",
      "reference_sentence": "中断",
      "line_num": 84,
      "context": "{\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\",\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\",\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\"}",
      "用户拒绝的修改": "中断信号",
      "注意事项": "修复术语不一致时应先检查相邻条目格式，若上下文存在同类术语未带\"信号\"后缀的情况（如SIGQUIT对应\"键盘退出\"），应优先保持列内统一性而非强制添加修饰词。"
    },
    {
      "defect_id": 431935,
      "sentence": "继续执行",
      "reference_sentence": "继续执行",
      "line_num": 100,
      "context": "{\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "继续执行信号",
      "注意事项": "修改前需确认上下文是否存在统一的术语后缀模式，避免在无明确规范的情况下添加冗余词汇；优先保持原文术语完整性，仅在确实存在术语冲突时进行必要调整。"
    },
    {
      "defect_id": 431926,
      "sentence": "算术异常",
      "reference_sentence": "算术异常",
      "line_num": 90,
      "context": "{\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\"}",
      "用户拒绝的修改": "算术异常信号",
      "注意事项": "修复术语时必须严格对照上下文已有用法模式，优先保持表格内现有译名的统一性（如\"SIGFPE\"对应\"算术异常\"而非\"信号\"），避免添加冗余限定词破坏原始文档的术语体系。"
    },
    {
      "defect_id": 431925,
      "sentence": "总线错误",
      "reference_sentence": "总线错误",
      "line_num": 89,
      "context": "{\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\"}",
      "用户拒绝的修改": "总线错误信号",
      "注意事项": "在修复术语一致性时需优先确认上下文格式规范，避免添加冗余修饰词（如\"信号\"）破坏现有术语体系，应严格参照同类型条目（如\"SIGINT→中断\"）保持命名简洁性。"
    },
    {
      "defect_id": 431933,
      "sentence": "协处理器栈错误",
      "reference_sentence": "协处理器栈错误",
      "line_num": 98,
      "context": "{\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\"}",
      "用户拒绝的修改": "协处理器栈错误信号",
      "注意事项": "修复时应优先保持上下文术语结构统一，若参考句和相邻条目均未添加\"信号\"后缀，则不应擅自扩展术语名称，避免破坏文档整体一致性模式。"
    },
    {
      "defect_id": 431934,
      "sentence": "子进程退出/停止",
      "reference_sentence": "子进程退出/停止",
      "line_num": 99,
      "context": "{\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\"}",
      "用户拒绝的修改": "子进程退出或停止信号",
      "注意事项": "修复时应严格遵循上下文术语使用惯例，避免添加冗余词汇（如\"信号\"）破坏原有表述结构；优先保持问题描述与参考句式的动词化表达（如\"退出/停止\"），仅在明确缺失核心术语时进行补充。"
    },
    {
      "defect_id": 431914,
      "sentence": "宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "reference_sentence": "宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"### 支持symbol-version机制\",\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\",\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\"}",
      "用户拒绝的修改": "在宏定义FD_SET和FD_CLR中增加对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "注意事项": "在应用语言规则前必须首先确认文档现有风格，若上下文已采用陈述句描述技术事实，应优先保持整体一致性而非强制统一句式；修复时要结合上下文判断句式是否真正构成混用，避免将技术文档中合理的陈述性表达误判为语法问题。"
    },
    {
      "defect_id": 431913,
      "sentence": "支持使用dlclose真实卸载动态库的能力。",
      "reference_sentence": "支持使用dlclose真实卸载动态库的能力。",
      "line_num": 57,
      "context": "{\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\",\"53\":\"```\",\"54\":\"![zh-cn_image_musl_ld_rpath](figures/dl_rpath.png)\",\"55\":\"\",\"56\":\"### 支持dlclose\",\"57\":\"支持使用dlclose真实卸载动态库的能力。\",\"58\":\"\",\"59\":\"### 支持symbol-version机制\",\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\"}",
      "用户拒绝的修改": "支持使用dlclose真实卸载动态库。",
      "注意事项": "在修改技术文档时，需优先确认原句实际语气类型（如陈述句/祈使句），避免误判句式混用；同时应保留技术场景下的固定表达（如\"能力\"在功能描述中的必要性），避免过度简化导致语义缺失。"
    },
    {
      "defect_id": 431938,
      "sentence": "后台读终端",
      "reference_sentence": "后台读终端",
      "line_num": 103,
      "context": "{\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "后台读终端信号",
      "注意事项": "修复前必须严格核对上下文术语使用习惯，仅在确实存在术语不一致且上下文明确使用其他表述时进行修改，避免过度校正用户已确认正确的原始表述。"
    },
    {
      "defect_id": 431922,
      "sentence": "键盘退出",
      "reference_sentence": "键盘退出",
      "line_num": 85,
      "context": "{\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\",\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\",\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\"}",
      "用户拒绝的修改": "键盘退出信号",
      "注意事项": "修复术语不一致时需优先核查上下文现有用法模式，避免在原始文档存在合理变体的情况下强行统一；修改前应确认目标术语是否与相邻条目保持平行结构。"
    },
    {
      "defect_id": 431936,
      "sentence": "强制停止",
      "reference_sentence": "强制停止",
      "line_num": 101,
      "context": "{\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "强制停止信号",
      "注意事项": "修复时应优先检查上下文术语使用习惯，若原术语在文档中已统一使用（如\"强制停止\"）且无歧义，避免机械添加修饰词（如\"信号\"）破坏一致性。"
    },
    {
      "defect_id": 431930,
      "sentence": "用户自定义信号 2",
      "reference_sentence": "用户自定义信号 2",
      "line_num": 94,
      "context": "{\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\"}",
      "用户拒绝的修改": "用户自定义信号2",
      "注意事项": "修复时应优先检查上下文中的术语使用惯例，确保数字与中文成分间的空格处理与文档现有格式完全一致，避免因机械应用通用规则破坏内部统一性。"
    },
    {
      "defect_id": 431920,
      "sentence": "控制终端挂起",
      "reference_sentence": "控制终端挂起",
      "line_num": 83,
      "context": "{\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\",\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\",\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\"}",
      "用户拒绝的修改": "控制终端断开",
      "注意事项": "在修复术语不一致时需优先识别并保留技术专用名词，修改前应检查上下文是否存在已确定的术语使用惯例，避免将专业表述替换为通用词汇。"
    },
    {
      "defect_id": 431932,
      "sentence": "程序终止请求",
      "reference_sentence": "程序终止请求",
      "line_num": 97,
      "context": "{\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\",\"98\":\"| 16   | SIGSTKFLT |  协处理器栈错误    | 39  | MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)          | 系统自留                  |\",\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\"}",
      "用户拒绝的修改": "程序终止请求信号",
      "注意事项": "在修改术语一致性时，需优先检查上下文现有术语模式（如信号类描述是否统一带\"信号\"后缀），若同一表格中存在混合格式，应保持原条目风格而非强制统一；同时需区分核心术语（如\"SIGTERM\"）与其描述字段的命名规范差异。"
    },
    {
      "defect_id": 431918,
      "sentence": "为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：",
      "reference_sentence": "为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：",
      "line_num": 74,
      "context": "{\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\"}",
      "用户拒绝的修改": "为了避免与系统保留信号冲突，开发者在使用信号时应遵循以下规则：",
      "注意事项": "准确识别祈使句与陈述句的语法特征，优先保持上下文原有句式风格的一致性；修改前需全面检查文档整体语言风格，避免因局部调整破坏整体表达统一性。"
    },
    {
      "defect_id": 431928,
      "sentence": "用户自定义信号 1",
      "reference_sentence": "用户自定义信号 1",
      "line_num": 92,
      "context": "{\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\",\"97\":\"| 15   | SIGTERM   |  程序终止请求     | 38   | MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)    | 系统自留                  |\"}",
      "用户拒绝的修改": "用户自定义信号1",
      "注意事项": "修复术语一致性时必须严格检查上下文格式规范（如空格使用），确保修改后的术语与文档现有格式完全匹配，避免仅关注文字内容而忽略排版细节。"
    },
    {
      "defect_id": 431927,
      "sentence": "强制终止",
      "reference_sentence": "强制终止",
      "line_num": 91,
      "context": "{\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\",\"94\":\"| 12   | SIGUSR2   |  用户自定义信号 2 | 35   | MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)   | 系统自留                   |\",\"95\":\"| 13   | SIGPIPE   |  管道损坏         | 36   | MUSL_SIGNAL_HOOK (SIGRTMIN + 1)            | 系统自留                  |\",\"96\":\"| 14   | SIGALRM   |  定时器信号       | 37   | MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)          | 系统自留                  |\"}",
      "用户拒绝的修改": "强制终止信号",
      "注意事项": "修复术语时必须全面检查上下文现有用法，优先保持文档内部统一性而非添加冗余限定词，当参考句子与上下文格式一致时不应强制添加\"信号\"等后缀。"
    },
    {
      "defect_id": 431917,
      "sentence": "[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。",
      "reference_sentence": "[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\"}",
      "用户拒绝的修改": "使用[fdsan使用指导](./fdsan.md)检测文件的重复关闭和关闭后使用问题。",
      "注意事项": "在统一句式前需优先检查上下文整体风格，技术文档中陈述句和祈使句应根据内容类型（功能说明/操作指引）区分使用，避免机械统一破坏技术文档的客观性特征。"
    },
    {
      "defect_id": 431924,
      "sentence": "中止信号",
      "reference_sentence": "中止信号",
      "line_num": 88,
      "context": "{\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\",\"85\":\"| 3    | SIGQUIT   |  键盘退出        | 26   | SIGVTALRM                                  | 虚拟定时器                 |\",\"86\":\"| 4    | SIGILL    |  非法指令        | 27   | SIGPROF                                    | profiling 计时器到期       |\",\"87\":\"| 5    | SIGTRAP   |  调试断点        | 28   | SIGWINCH                                   | 终端窗口大小变化           |\",\"88\":\"| 6    | SIGABRT   |  中止信号        | 29   | SIGIO                                      | I/O 可用通知               |\",\"89\":\"| 7    | SIGBUS    |  总线错误        | 30   | SIGPWR                                     | 电源故障                   |\",\"90\":\"| 8    | SIGFPE    |  算术异常        | 31   | SIGSYS                                     | 非法系统调用               |\",\"91\":\"| 9    | SIGKILL   |  强制终止        | 32   | SIGTIMER                                   | 定时器定时信号             |\",\"92\":\"| 10   | SIGUSR1   |  用户自定义信号 1 | 33   | SIGCANCEL                                  | 线程取消信号               |\",\"93\":\"| 11   | SIGSEGV   |  无效内存访问     | 34   | SIGSYNCCALL                                | 同步调用信号               |\"}",
      "用户拒绝的修改": "中止",
      "注意事项": "修复前必须全面核查上下文所有相关术语的使用情况，避免因局部调整破坏文档整体一致性；优先保留原文中具有明确表意功能的必要词汇（如\"信号\"），除非存在明确的全局统一规范。"
    },
    {
      "defect_id": 431939,
      "sentence": "后台写终端",
      "reference_sentence": "后台写终端",
      "line_num": 104,
      "context": "{\"99\":\"| 17   | SIGCHLD   |  子进程退出/停止   | 40  | MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)     | 系统自留                  |\",\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "后台写终端信号",
      "注意事项": "在修复术语不一致时，必须严格对照上下文中的已有术语格式（如\"后台读终端\"与\"后台写终端\"），避免擅自添加冗余词汇（如\"信号\"）破坏原有术语体系；优先保持上下文统一性而非机械套用规则。"
    },
    {
      "defect_id": 434172,
      "sentence": "maxWidth是数字类型，支持float和integer，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')",
      "reference_sentence": "maxWidth<sup>18+</sup> | [Dimension](ts-types.md#dimension10) | 否 | 设置popup的最大宽度，通过此接口popup可以自定义宽度显示。",
      "line_num": 54,
      "context": "{\"49\":\"| message   | [PopupTextOptions](#popuptextoptions)                        | 是   | 设置popup内容文本。<br />**说明：**<br />message不支持设置fontWeight。 |\",\"50\":\"| showClose | boolean \\\\| [Resource](ts-types.md#resource)                | 否   | 设置popup关闭按钮。值为true时，显示关闭按钮，值为false时，不显示关闭按钮。设置为Resource，显示对应的图标。<br />默认值：true |\",\"51\":\"| onClose   | () => void                                                   | 否   | 设置popup关闭按钮回调函数。|\",\"52\":\"| buttons   | [[PopupButtonOptions](#popupbuttonoptions)?,[PopupButtonOptions](#popupbuttonoptions)?] | 否   | 设置popup操作按钮,按钮最多设置两个。 |\",\"53\":\"| direction<sup>12+</sup> | [Direction](ts-appendix-enums.md#direction)                                             | 否                                | 布局方向。<br/>默认值：Direction.Auto                                |\",\"54\":\"| maxWidth<sup>18+</sup> | [Dimension](ts-types.md#dimension10)                                             | 否                                | 设置popup的最大宽度，通过此接口popup可以自定义宽度显示。<br />**说明：** <br />在使用引用资源类型时，规定其参数类型要与属性方法本身类型一致。maxWidth是数字类型，支持float和integer，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')。<br/>默认值：400vp<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"55\":\"\",\"56\":\"## PopupTextOptions\",\"57\":\"\",\"58\":\"设置文本样式。\",\"59\":\"\"}",
      "用户拒绝的修改": "maxWidth是Dimension类型，支持float和integer，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')",
      "注意事项": "修复时必须严格遵循文档中已定义的技术类型层级（如Dimension包含数字类型），避免擅自替换核心概念；同时需核对上下文参数说明是否涉及特殊用法（如资源引用类型限制），确保技术描述与文档结构完全一致。"
    },
    {
      "defect_id": 431940,
      "sentence": "套接字有紧急数据",
      "reference_sentence": "套接字有紧急数据",
      "line_num": 105,
      "context": "{\"100\":\"| 18   | SIGCONT   |  继续执行         | 41   | MUSL_SIGNAL_SAMPLE_STACK (SIGRTMIN + 6)    | 系统自留                  |\",\"101\":\"| 19   | SIGSTOP   |  强制停止         | 42   | MUSL_SIGNAL_LEAK_STACK (SIGRTMIN + 7)      | 系统自留                  |\",\"102\":\"| 20   | SIGTSTP   |  停止在终端输入   | 43   | MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8) | 系统自留                  |\",\"103\":\"| 21   | SIGTTIN   |  后台读终端       | 44   | MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)         | 系统自留                  |\",\"104\":\"| 22   | SIGTTOU   |  后台写终端       | 45   | MUSL_SIGNAL_FDTRACK (SIGRTMIN + 10)         | 系统自留                  |\",\"105\":\"| 23   | SIGURG    |  套接字有紧急数据  |      |                                             |                          |\"}",
      "用户拒绝的修改": "套接字有紧急数据信号",
      "注意事项": "修复术语不一致时需全面检查上下文统一性，避免添加冗余修饰词；优先保持与相邻条目格式一致，若参考句子本身符合上下文规范则无需修改。"
    },
    {
      "defect_id": 432328,
      "sentence": "maxWidth是数字类型，支持float和integer，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')",
      "reference_sentence": "在使用引用资源类型时，规定其参数类型要与属性方法本身类型一致",
      "line_num": 54,
      "context": "{\"49\":\"| message   | [PopupTextOptions](#popuptextoptions)                        | 是   | 设置popup内容文本。<br />**说明：**<br />message不支持设置fontWeight。 |\",\"50\":\"| showClose | boolean \\\\| [Resource](ts-types.md#resource)                | 否   | 设置popup关闭按钮。值为true时，显示关闭按钮，值为false时，不显示关闭按钮。设置为Resource，显示对应的图标。<br />默认值：true |\",\"51\":\"| onClose   | () => void                                                   | 否   | 设置popup关闭按钮回调函数。|\",\"52\":\"| buttons   | [[PopupButtonOptions](#popupbuttonoptions)?,[PopupButtonOptions](#popupbuttonoptions)?] | 否   | 设置popup操作按钮,按钮最多设置两个。 |\",\"53\":\"| direction<sup>12+</sup> | [Direction](ts-appendix-enums.md#direction)                                             | 否                                | 布局方向。<br/>默认值：Direction.Auto                                |\",\"54\":\"| maxWidth<sup>18+</sup> | [Dimension](ts-types.md#dimension10)                                             | 否                                | 设置popup的最大宽度，通过此接口popup可以自定义宽度显示。<br />**说明：** <br />在使用引用资源类型时，规定其参数类型要与属性方法本身类型一致。maxWidth是数字类型，支持float和integer，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')。<br/>默认值：400vp<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"55\":\"\",\"56\":\"## PopupTextOptions\",\"57\":\"\",\"58\":\"设置文本样式。\",\"59\":\"\"}",
      "用户拒绝的修改": "maxWidth支持float和integer类型，例如$r('app.float.maxWidth')、$r('app.integer.maxWidth')",
      "注意事项": "修复时应严格遵循文档中已定义的术语（如\"数字类型\"），避免擅自替换为具体子类型（如\"float和integer\"），需优先保持上下文术语一致性，仅在必要处补充说明支持的子类型。"
    },
    {
      "defect_id": 436102,
      "sentence": "<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。 |",
      "reference_sentence": "<br/>- fingerprint：设备指纹认证能力，当前仅支持2in1设备使用。",
      "line_num": 134,
      "context": "{\"129\":\"**参数：**\",\"130\":\"\",\"131\":\"| 参数名   | 类型                                                    | 必填 | 说明                                                         |\",\"132\":\"| -------- | ------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"133\":\"| admin    | [Want](../apis-ability-kit/js-apis-app-ability-want.md) | 是   | 企业设备管理扩展组件。                                   |\",\"134\":\"| feature  | string                                                  | 是   | feature名称。<br/>- fingerprint：设备指纹认证能力，当前仅支持2in1设备使用。使用此参数时有以下规则：<br/>1. 通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用了设备指纹认证能力，再使用本接口传入此参数，会报策略冲突。<br/>2. 通过本接口设置禁用/启用指定用户的设备指纹认证能力后，再通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用设备指纹认证能力时，后者会覆盖前者的策略。此后再通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口启用设备指纹认证能力，则所有用户都允许使用设备指纹认证能力。<br/>- mtpClient<sup>20+</sup>：MTP客户端能力（仅包含写入），当前仅支持2in1设备使用。MTP（MediaTransferProtocol，媒体传输协议），该协议允许用户在移动设备上线性访问媒体文件。当已经通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用了设备MTP客户端能力时，再通过本接口禁用某用户MTP客户端写入能力，会报策略冲突。<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。 |\",\"135\":\"| disallow | boolean                                                 | 是   | true表示禁用，false表示启用。                        |\",\"136\":\"| accountId | number                                                 | 是   | 用户ID，取值范围：大于等于0。<br/>accountId可以通过[getOsAccountLocalId](../apis-basic-services-kit/js-apis-osAccount.md#getosaccountlocalid9)等接口来获取。 |\",\"137\":\"\",\"138\":\"**错误码**：\",\"139\":\"\"}",
      "用户拒绝的修改": "<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。",
      "注意事项": "确保参数说明中的能力命名格式严格统一（参数名+冒号+能力名称+逗号），避免混用\"能力\"后缀与其他表述，并交叉验证上下文同类参数的结构一致性。"
    },
    {
      "defect_id": 436877,
      "sentence": "将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "line_num": 665,
      "context": "{\"660\":\"\",\"661\":\"| 名称     | 值    | 说明                    |\",\"662\":\"| ------ | -------------------------- | -------------------------- |\",\"663\":\"| AUTO | 0 | 读取图片携带的EXIF元数据作为显示方向，支持旋转和镜像。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_0](figures/imageRotateOrientation_0.png) |\",\"664\":\"| UP | 1 | 默认按照当前图片的像素数据进行显示，不做任何处理。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\",\"665\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"666\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"667\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"668\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\",\"669\":\"| RIGHT_MIRRORED<sup>20+</sup> | 6 | 将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_6](figures/imageRotateOrientation_6.png) |\",\"670\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\"}",
      "用户拒绝的修改": "将当前图片顺时针旋转90度后显示。",
      "注意事项": "在修复重复描述时需重点核对上下文版本号差异，保留API版本等关键变量信息，避免因删除技术参数导致信息缺失；应优先识别重复内容中的动态元素（如API version 14/20），而非机械删除相同句式。"
    },
    {
      "defect_id": 436142,
      "sentence": "<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。 |",
      "reference_sentence": "<br/>- fingerprint：设备指纹认证能力，当前仅支持2in1设备使用。",
      "line_num": 134,
      "context": "{\"129\":\"**参数：**\",\"130\":\"\",\"131\":\"| 参数名   | 类型                                                    | 必填 | 说明                                                         |\",\"132\":\"| -------- | ------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"133\":\"| admin    | [Want](../apis-ability-kit/js-apis-app-ability-want.md) | 是   | 企业设备管理扩展组件。                                   |\",\"134\":\"| feature  | string                                                  | 是   | feature名称。<br/>- fingerprint：设备指纹认证能力，当前仅支持2in1设备使用。使用此参数时有以下规则：<br/>1. 通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用了设备指纹认证能力，再使用本接口传入此参数，会报策略冲突。<br/>2. 通过本接口设置禁用/启用指定用户的设备指纹认证能力后，再通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用设备指纹认证能力时，后者会覆盖前者的策略。此后再通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口启用设备指纹认证能力，则所有用户都允许使用设备指纹认证能力。<br/>- mtpClient<sup>20+</sup>：MTP客户端能力（仅包含写入），当前仅支持2in1设备使用。MTP（MediaTransferProtocol，媒体传输协议），该协议允许用户在移动设备上线性访问媒体文件。当已经通过[setDisallowedPolicy](#restrictionssetdisallowedpolicy)接口禁用了设备MTP客户端能力时，再通过本接口禁用某用户MTP客户端写入能力，会报策略冲突。<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。 |\",\"135\":\"| disallow | boolean                                                 | 是   | true表示禁用，false表示启用。                        |\",\"136\":\"| accountId | number                                                 | 是   | 用户ID，取值范围：大于等于0。<br/>accountId可以通过[getOsAccountLocalId](../apis-basic-services-kit/js-apis-osAccount.md#getosaccountlocalid9)等接口来获取。 |\",\"137\":\"\",\"138\":\"**错误码**：\",\"139\":\"\"}",
      "用户拒绝的修改": "<br/>- diskRecoveryKey：恢复密钥导出能力，当前仅支持2in1设备使用。",
      "注意事项": "修复时应全面检查文档中同一术语的所有实例（如\"2in1设备\"和\"2in1\"），确保在相同语义场景下保持完全一致的表述形式，特别注意参数说明中重复出现的专业术语需全局统一。"
    },
    {
      "defect_id": 437007,
      "sentence": "从图像源中读取图片的EXIF方向信息。",
      "reference_sentence": "从图像源中读取图像的EXIF方向信息。",
      "line_num": 2005,
      "context": "{\"2000\":\"    if (!context) {\",\"2001\":\"      return;\",\"2002\":\"    }\",\"2003\":\"    this.getFileBuffer(context).then((buf: ArrayBuffer | undefined) => {\",\"2004\":\"      let imageSource = image.createImageSource(buf);\",\"2005\":\"      // 从图像源中读取图片的EXIF方向信息。\",\"2006\":\"      imageSource.getImageProperty(image.PropertyKey.ORIENTATION).then((orientation) => {\",\"2007\":\"        this.rotateOrientation = this.getOrientation(orientation);\",\"2008\":\"        this.text1 = this.text1 + orientation;\",\"2009\":\"      })\",\"2010\":\"      let options: image.DecodingOptions = {\"}",
      "用户拒绝的修改": "从图像源中读取图像的EXIF方向信息。",
      "注意事项": "修改前需检查上下文术语使用惯例，若同义词在上下文中已形成明确指代关系且不影响理解时，应优先保留原始表述；统一用词时应以代码变量命名(imageSource)和API接口(image.PropertyKey)为基准，而非机械替换表面词汇。"
    },
    {
      "defect_id": 436881,
      "sentence": "将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。",
      "line_num": 669,
      "context": "{\"664\":\"| UP | 1 | 默认按照当前图片的像素数据进行显示，不做任何处理。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\",\"665\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"666\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"667\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"668\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\",\"669\":\"| RIGHT_MIRRORED<sup>20+</sup> | 6 | 将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_6](figures/imageRotateOrientation_6.png) |\",\"670\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\",\"671\":\"| LEFT_MIRRORED<sup>20+</sup> | 8 | 将当前图片水平翻转再顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_8](figures/imageRotateOrientation_8.png) |\",\"672\":\"\",\"673\":\"## ImageSourceSize<sup>18+</sup>对象说明\",\"674\":\"\"}",
      "用户拒绝的修改": "将当前图片水平翻转再顺时针旋转90度后显示。",
      "注意事项": "修复时应优先识别上下文结构特征，保留不同条目间必要的重复性说明模板(如原子化服务API标注)，避免因局部相似而误删关键版本信息；需结合相邻行模式判断是否属于标准化的文档结构而非冗余内容。"
    },
    {
      "defect_id": 436879,
      "sentence": "将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "line_num": 667,
      "context": "{\"662\":\"| ------ | -------------------------- | -------------------------- |\",\"663\":\"| AUTO | 0 | 读取图片携带的EXIF元数据作为显示方向，支持旋转和镜像。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_0](figures/imageRotateOrientation_0.png) |\",\"664\":\"| UP | 1 | 默认按照当前图片的像素数据进行显示，不做任何处理。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\",\"665\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"666\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"667\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"668\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\",\"669\":\"| RIGHT_MIRRORED<sup>20+</sup> | 6 | 将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_6](figures/imageRotateOrientation_6.png) |\",\"670\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\",\"671\":\"| LEFT_MIRRORED<sup>20+</sup> | 8 | 将当前图片水平翻转再顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_8](figures/imageRotateOrientation_8.png) |\",\"672\":\"\"}",
      "用户拒绝的修改": "将当前图片顺时针旋转270度后显示。",
      "注意事项": "修复时应优先检查上下文中的重复模式是否属于文档结构要求，保留必要的格式统一性描述；避免孤立处理单一句子，需结合相邻段落/表格项判断是否存在结构化重复需求。"
    },
    {
      "defect_id": 436372,
      "sentence": "该示例利用ignoreLayoutSafeArea和LayoutPolicy.matchParent同时改变组件大小和位置。相比未使用该属性，配置ignoreLayoutSafeArea后，Row组件基于Stack内容区、Stack组件级安全区，取其右下部分并撑满可用空间。",
      "reference_sentence": "eLayoutSafeArea后，Row组件基于Stack内容区、Stack组件级安全区、系统状态栏共同组成的范围，取其左上部分，作左上对齐。",
      "line_num": 495,
      "context": "{\"490\":\"```\",\"491\":\"![ignoreLayoutSafeArea1](figures/ignoreLayoutSafeArea1.jpg)\",\"492\":\"\",\"493\":\"### 示例9（ignoreLayoutSafeArea配合LayoutPolicy.matchParent延伸组件布局范围）\",\"494\":\"\",\"495\":\"该示例利用ignoreLayoutSafeArea和LayoutPolicy.matchParent同时改变组件大小和位置。相比未使用该属性，配置ignoreLayoutSafeArea后，Row组件基于Stack内容区、Stack组件级安全区，取其右下部分并撑满可用空间。\",\"496\":\"\",\"497\":\"```ts\",\"498\":\"import { LengthMetrics } from '@kit.ArkUI'\",\"499\":\"\",\"500\":\"@Entry\"}",
      "用户拒绝的修改": "该示例利用ignoreLayoutSafeArea和LayoutPolicy.matchParent同时改变组件大小和位置。相比未使用该属性，配置ignoreLayoutSafeArea后，Row组件基于Stack内容区、Stack组件级安全区、系统状态栏共同组成的范围，取其右下部分并撑满可用空间。",
      "注意事项": "修复时必须严格核对上下文提及的方位描述（如\"左上/右下\"）和组件范围要素（如系统状态栏），确保新增内容与参考句子的空间逻辑完全一致，避免因局部修正导致整体表述与上下文产生矛盾。"
    },
    {
      "defect_id": 436878,
      "sentence": "将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。",
      "line_num": 666,
      "context": "{\"661\":\"| 名称     | 值    | 说明                    |\",\"662\":\"| ------ | -------------------------- | -------------------------- |\",\"663\":\"| AUTO | 0 | 读取图片携带的EXIF元数据作为显示方向，支持旋转和镜像。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_0](figures/imageRotateOrientation_0.png) |\",\"664\":\"| UP | 1 | 默认按照当前图片的像素数据进行显示，不做任何处理。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\",\"665\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"666\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"667\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"668\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\",\"669\":\"| RIGHT_MIRRORED<sup>20+</sup> | 6 | 将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_6](figures/imageRotateOrientation_6.png) |\",\"670\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\",\"671\":\"| LEFT_MIRRORED<sup>20+</sup> | 8 | 将当前图片水平翻转再顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_8](figures/imageRotateOrientation_8.png) |\"}",
      "用户拒绝的修改": "将当前图片顺时针旋转180度后显示。",
      "注意事项": "在修复重复描述时必须先核对上下文差异，保留API版本等关键信息的特异性说明（如API version 14/20的版本号差异），避免误删必要的原子化服务适配声明。"
    },
    {
      "defect_id": 436882,
      "sentence": "将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。",
      "line_num": 670,
      "context": "{\"665\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"666\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"667\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"668\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\",\"669\":\"| RIGHT_MIRRORED<sup>20+</sup> | 6 | 将当前图片水平翻转再顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_6](figures/imageRotateOrientation_6.png) |\",\"670\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\",\"671\":\"| LEFT_MIRRORED<sup>20+</sup> | 8 | 将当前图片水平翻转再顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_8](figures/imageRotateOrientation_8.png) |\",\"672\":\"\",\"673\":\"## ImageSourceSize<sup>18+</sup>对象说明\",\"674\":\"\",\"675\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\"}",
      "用户拒绝的修改": "将当前图片垂直翻转后显示。",
      "注意事项": "修复时应优先保持条目化内容的结构一致性，避免删除必要的API版本说明；需结合上下文判断重复内容是否为必要信息，确保技术文档的完整性和规范性。"
    },
    {
      "defect_id": 437006,
      "sentence": "该示例通过[getImageProperty](../../apis-image-kit/arkts-apis-image-ImageSource.md#getimageproperty11)接口，获取图片的exif信息，再根据获取到的exif信息，通过[orientation](#orientation14)属性设置图像内容显示为正确方向。",
      "reference_sentence": "该示例通过[getImageProperty](../../apis-image-kit/arkts-apis-image-ImageSource.md#getimageproperty11)接口，获取图片的exif信息，再根据获取到的exif信息，通过[orientation](#orientation14)属性设置图像内容显示为正确方向。",
      "line_num": 1937,
      "context": "{\"1932\":\"\",\"1933\":\"![orientation](figures/orientation.png)\",\"1934\":\"\",\"1935\":\"### 示例22（获取图片的exif信息并设置图像内容的显示方向）\",\"1936\":\"\",\"1937\":\"该示例通过[getImageProperty](../../apis-image-kit/arkts-apis-image-ImageSource.md#getimageproperty11)接口，获取图片的exif信息，再根据获取到的exif信息，通过[orientation](#orientation14)属性设置图像内容显示为正确方向。\",\"1938\":\"\",\"1939\":\"```ts\",\"1940\":\"import { image } from '@kit.ImageKit';\",\"1941\":\"import { resourceManager } from '@kit.LocalizationKit';\",\"1942\":\"\"}",
      "用户拒绝的修改": "该示例通过[getImageProperty](../../apis-image-kit/arkts-apis-image-ImageSource.md#getimageproperty11)接口，获取图像的exif信息，再根据获取到的exif信息，通过[orientation](#orientation14)属性设置图像内容显示为正确方向。",
      "注意事项": "在确保术语一致性前需优先验证技术文档中是否存在同义词的专业性区分（如\"图片\"指文件对象，\"图像\"指显示内容），避免机械统一导致技术表述错误；修改时应结合上下文标题、API名称等显性技术线索进行综合判断。"
    },
    {
      "defect_id": 436373,
      "sentence": "两种设置下，容器都可见地进行了延伸，但前者的子组件不受延伸影响，后者的子组件因父容器的延伸改变了位置。",
      "reference_sentence": "该示例展示了容器分别设置了expandSafeArea和ignoreLayoutSafeArea的布局效果和各自对子组件布局效果的影响。",
      "line_num": 533,
      "context": "{\"528\":\"```\",\"529\":\"![ignoreLayoutSafeArea2](figures/ignoreLayoutSafeArea2.jpg)\",\"530\":\"\",\"531\":\"### 示例10（expandSafeArea与ignoreLayoutSafeArea的区别）\",\"532\":\"\",\"533\":\"该示例展示了容器分别设置了expandSafeArea和ignoreLayoutSafeArea的布局效果和各自对子组件布局效果的影响。两种设置下，容器都可见地进行了延伸，但前者的子组件不受延伸影响，后者的子组件因父容器的延伸改变了位置。\",\"534\":\"\",\"535\":\"```ts\",\"536\":\"import { LengthMetrics } from '@kit.ArkUI'\",\"537\":\"\",\"538\":\"@Entry\"}",
      "用户拒绝的修改": "两种设置下，容器都可见地进行了延伸，但前者的子组件位置保持不变，后者的子组件因父容器的延伸改变了位置。",
      "注意事项": "修复时应优先保持技术术语的准确性，避免为追求词汇一致性而牺牲语义完整性；需结合上下文判断\"不一致\"是否实际影响表意，技术文档中特定术语的重复使用可能具有强调作用，不宜机械替换。"
    },
    {
      "defect_id": 439580,
      "sentence": "组件使用方",
      "reference_sentence": "无",
      "line_num": 58,
      "context": "{\"53\":\"> - 若原子化服务通过调用[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)退出，上述回调函数的入参中，\\\"code\\\"取默认值\\\"0\\\"，\\\"want\\\"为\\\"undefined\\\"。\",\"54\":\"\",\"55\":\"## 示例\",\"56\":\"本示例仅展示组件使用的方法和扩展的原服务，实际运行以开发者自己的原子化服务appId为准。\",\"57\":\"\",\"58\":\"**组件使用方**\",\"59\":\"\",\"60\":\"使用方入口界面Index.ets内容如下:\",\"61\":\"```ts\",\"62\":\"import { FullScreenLaunchComponent } from '@kit.ArkUI';\",\"63\":\"\"}",
      "用户拒绝的修改": "使用方",
      "注意事项": "在统一术语前需优先确认上下文是否存在技术性定义或特定语境差异，避免因过度简化导致核心语义偏移；若参考信息不足，应主动询问或保留原表达并标注风险。"
    },
    {
      "defect_id": 439578,
      "sentence": "当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方跳出式拉起原子化服务。",
      "reference_sentence": "无",
      "line_num": 4,
      "context": "{\"1\":\"# FullScreenLaunchComponent\",\"2\":\"\",\"3\":\"\",\"4\":\"全屏启动原子化服务组件，当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方跳出式拉起原子化服务。\",\"5\":\"\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 该组件从API Version 12开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\"}",
      "用户拒绝的修改": "当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方拉起原子化服务。",
      "注意事项": "在统一术语时应优先保留原文关键修饰词（如\"跳出式\"）以确保技术准确性，避免因过度简化导致语义缺失；修改前需结合上下文确认术语是否承担区分功能，防止误删核心语义要素。"
    },
    {
      "defect_id": 439579,
      "sentence": "需要拉起的原子化服务appId，appId是原子化服务的唯一标识。",
      "reference_sentence": "无",
      "line_num": 44,
      "context": "{\"39\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"40\":\"\",\"41\":\"| 名称 | 类型 | 必填 | 装饰器类型 | 说明 |\",\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\"}",
      "用户拒绝的修改": "需要的原子化服务appId，appId是原子化服务的唯一标识。",
      "注意事项": "在保持语言简洁性时需优先保留关键术语的技术含义，确保\"拉起\"等操作动词不被省略；修改前应结合上下文确认参数用途，避免因过度统一用词破坏技术准确性。"
    },
    {
      "defect_id": 438401,
      "sentence": "4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "reference_sentence": "4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "line_num": 16,
      "context": "{\"11\":\"   ```\",\"12\":\"2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)创建cmsGenerator对象。\",\"13\":\"\",\"14\":\"3. 调用[cmsGenerator.addSigner](../../reference/apis-device-certificate-kit/js-apis-cert.md#addsigner18)添加签名者信息。\",\"15\":\"\",\"16\":\"4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。\",\"17\":\"\",\"18\":\"5. 调用[cmsGenerator.doFinal](../../reference/apis-device-certificate-kit/js-apis-cert.md#dofinal18)获取Cms最终签名数据。\",\"19\":\"\",\"20\":\"- 异步方法示例：\",\"21\":\"\"}",
      "用户拒绝的修改": "4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)增加证书。",
      "注意事项": "修复时应全面检查上下文术语一致性（如相邻步骤中的\"添加签名者\"），优先保持与API方法名称动词（addCert对应\"添加\"）及上下文用词统一，避免孤立替换词汇。"
    },
    {
      "defect_id": 438399,
      "sentence": "2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)创建cmsGenerator对象。",
      "reference_sentence": "2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)创建cmsGenerator对象。",
      "line_num": 12,
      "context": "{\"7\":\"1. 导入[证书算法库框架模块](../../reference/apis-device-certificate-kit/js-apis-cert.md)。\",\"8\":\"\",\"9\":\"   ```ts\",\"10\":\"   import { cert } from '@kit.DeviceCertificateKit';\",\"11\":\"   ```\",\"12\":\"2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)创建cmsGenerator对象。\",\"13\":\"\",\"14\":\"3. 调用[cmsGenerator.addSigner](../../reference/apis-device-certificate-kit/js-apis-cert.md#addsigner18)添加签名者信息。\",\"15\":\"\",\"16\":\"4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。\",\"17\":\"\"}",
      "用户拒绝的修改": "2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)生成cmsGenerator对象。",
      "注意事项": "修改术语时必须严格检查上下文已有用词习惯，优先保持与API方法名动词的一致性（如create对应\"创建\"），避免脱离上下文孤立替换同义词。"
    },
    {
      "defect_id": 444206,
      "sentence": "胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。",
      "reference_sentence": "指定进度条样式。<br/>该参数从API version8开始废弃，建议使用type替代。<br/>默认值：ProgressStyle.Linear",
      "line_num": 75,
      "context": "{\"70\":\"| --------- | - | ---------------------------------------- |\",\"71\":\"| Linear    | 0 | 线性样式。                                    |\",\"72\":\"| Ring<sup>8+</sup>      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"73\":\"| Eclipse   | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"74\":\"| ScaleRing<sup>8+</sup> | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。               |\",\"75\":\"| Capsule<sup>8+</sup>   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"76\":\"\",\"77\":\"##  ProgressStyleMap对象说明 \",\"78\":\"\",\"79\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"80\":\"\"}",
      "用户拒绝的修改": "Capsule样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。",
      "注意事项": "确保术语中英文使用形式全文统一，优先采用上下文已有的命名形式（如参考句子中\"Linear\"保持英文），专有名词和样式名称禁止自行中译英或英译中转换。"
    },
    {
      "defect_id": 444202,
      "sentence": "线性样式。",
      "reference_sentence": "指定进度条样式。<br/>该参数从API version8开始废弃，建议使用type替代。<br/>默认值：ProgressStyle.Linear",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"68\":\"\",\"69\":\"| 名称        | 值 | 说明                                     |\",\"70\":\"| --------- | - | ---------------------------------------- |\",\"71\":\"| Linear    | 0 | 线性样式。                                    |\",\"72\":\"| Ring<sup>8+</sup>      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"73\":\"| Eclipse   | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"74\":\"| ScaleRing<sup>8+</sup> | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。               |\",\"75\":\"| Capsule<sup>8+</sup>   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"76\":\"\"}",
      "用户拒绝的修改": "Linear样式。从API version 9开始，高度大于宽度时，自适应垂直显示。",
      "注意事项": "确保术语中英文使用场景严格统一，表格字段名使用英文时应保持对应中文描述的术语一致性，避免在中文解释中直接插入未经翻译的英文词汇，同时需检查上下文是否存在已定义的中文术语映射关系。"
    },
    {
      "defect_id": 444205,
      "sentence": "环形有刻度样式，显示类似时钟刻度形式的进度展示效果。",
      "reference_sentence": "指定进度条样式。<br/>该参数从API version8开始废弃，建议使用type替代。<br/>默认值：ProgressStyle.Linear",
      "line_num": 74,
      "context": "{\"69\":\"| 名称        | 值 | 说明                                     |\",\"70\":\"| --------- | - | ---------------------------------------- |\",\"71\":\"| Linear    | 0 | 线性样式。                                    |\",\"72\":\"| Ring<sup>8+</sup>      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"73\":\"| Eclipse   | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"74\":\"| ScaleRing<sup>8+</sup> | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。               |\",\"75\":\"| Capsule<sup>8+</sup>   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"76\":\"\",\"77\":\"##  ProgressStyleMap对象说明 \",\"78\":\"\",\"79\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\"}",
      "用户拒绝的修改": "ScaleRing样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。",
      "注意事项": "确保术语中英文严格对应，避免在中文描述中直接插入未翻译的英文组件名称（如ScaleRing应统一译为\"环形有刻度样式\"），同时保持上下文术语与文档定义完全一致（如问题上下文中ScaleRing已明确对应\"环形有刻度样式\"）。"
    },
    {
      "defect_id": 444204,
      "sentence": "圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。",
      "reference_sentence": "指定进度条样式。<br/>该参数从API version8开始废弃，建议使用type替代。<br/>默认值：ProgressStyle.Linear",
      "line_num": 73,
      "context": "{\"68\":\"\",\"69\":\"| 名称        | 值 | 说明                                     |\",\"70\":\"| --------- | - | ---------------------------------------- |\",\"71\":\"| Linear    | 0 | 线性样式。                                    |\",\"72\":\"| Ring<sup>8+</sup>      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"73\":\"| Eclipse   | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"74\":\"| ScaleRing<sup>8+</sup> | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。               |\",\"75\":\"| Capsule<sup>8+</sup>   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"76\":\"\",\"77\":\"##  ProgressStyleMap对象说明 \",\"78\":\"\"}",
      "用户拒绝的修改": "Eclipse样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。",
      "注意事项": "在术语替换时必须严格遵循上下文中的中英文对应关系（如\"Eclipse\"对应\"圆形样式\"），保持同一语言体系内的术语一致性，避免跨语言混用。修改前需核查文档中现有术语映射表，确保全局统一。"
    },
    {
      "defect_id": 444110,
      "sentence": "环形有刻度样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。",
      "reference_sentence": "线性样式。从API version 9开始，高度大于宽度时，自适应垂直显示。",
      "line_num": 58,
      "context": "{\"53\":\"| 名称                     | 值 | 说明                                     |\",\"54\":\"| ---------------------- | - | ---------------------------------------- |\",\"55\":\"| Linear                 | 0 | 线性样式。从API version 9开始，高度大于宽度时，自适应垂直显示。   |\",\"56\":\"| Ring      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"57\":\"| Eclipse  | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"58\":\"| ScaleRing | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。 |\",\"59\":\"| Capsule   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"60\":\"\",\"61\":\"##  ProgressStyle枚举说明 \",\"62\":\"\",\"63\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\"}",
      "用户拒绝的修改": "环形有刻度样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。高度大于宽度时，自适应垂直显示。",
      "注意事项": "修复时应严格遵循上下文已有内容的描述范围，避免跨条目强行统一未明确关联的规则，确保新增信息在原始文档中存在直接依据或相邻条目显性关联。"
    },
    {
      "defect_id": 444203,
      "sentence": "环形无刻度样式，环形圆环逐渐显示至完全填充效果。",
      "reference_sentence": "指定进度条样式。<br/>该参数从API version8开始废弃，建议使用type替代。<br/>默认值：ProgressStyle.Linear",
      "line_num": 72,
      "context": "{\"67\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"68\":\"\",\"69\":\"| 名称        | 值 | 说明                                     |\",\"70\":\"| --------- | - | ---------------------------------------- |\",\"71\":\"| Linear    | 0 | 线性样式。                                    |\",\"72\":\"| Ring<sup>8+</sup>      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"73\":\"| Eclipse   | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"74\":\"| ScaleRing<sup>8+</sup> | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。               |\",\"75\":\"| Capsule<sup>8+</sup>   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"76\":\"\",\"77\":\"##  ProgressStyleMap对象说明 \"}",
      "用户拒绝的修改": "Ring样式，环形圆环逐渐显示至完全填充效果。",
      "注意事项": "确保术语使用严格遵循上下文规范，在参数名称与描述文本间保持语言一致性，若参数名称为英文术语（如Ring），对应描述应使用中文译名（如\"环形\"）并保持全文统一，避免中英文混用。"
    },
    {
      "defect_id": 444109,
      "sentence": "圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。",
      "reference_sentence": "胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。",
      "line_num": 57,
      "context": "{\"52\":\"\",\"53\":\"| 名称                     | 值 | 说明                                     |\",\"54\":\"| ---------------------- | - | ---------------------------------------- |\",\"55\":\"| Linear                 | 0 | 线性样式。从API version 9开始，高度大于宽度时，自适应垂直显示。   |\",\"56\":\"| Ring      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"57\":\"| Eclipse  | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"58\":\"| ScaleRing | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。 |\",\"59\":\"| Capsule   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"60\":\"\",\"61\":\"##  ProgressStyle枚举说明 \",\"62\":\"\"}",
      "用户拒绝的修改": "圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。从API version 9开始，高度大于宽度时，自适应垂直显示。",
      "注意事项": "修复时必须严格核对上下文中的同类条目描述，确保特性说明（如自适应规则）在不同组件间保持完全一致，避免跨条目复制未明确标注的通用属性。"
    },
    {
      "defect_id": 444111,
      "sentence": "胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。",
      "reference_sentence": "线性样式。从API version 9开始，高度大于宽度时，自适应垂直显示。",
      "line_num": 59,
      "context": "{\"54\":\"| ---------------------- | - | ---------------------------------------- |\",\"55\":\"| Linear                 | 0 | 线性样式。从API version 9开始，高度大于宽度时，自适应垂直显示。   |\",\"56\":\"| Ring      | 1 | 环形无刻度样式，环形圆环逐渐显示至完全填充效果。                 |\",\"57\":\"| Eclipse  | 2 | 圆形样式，显示类似月圆月缺的进度展示效果，从月牙逐渐变化至满月。         |\",\"58\":\"| ScaleRing | 3 | 环形有刻度样式，显示类似时钟刻度形式的进度展示效果。从API version 9开始，刻度外圈出现重叠的时候自动转换为环形无刻度进度条。 |\",\"59\":\"| Capsule   | 4 | 胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。高度大于宽度时，自适应垂直显示。 |\",\"60\":\"\",\"61\":\"##  ProgressStyle枚举说明 \",\"62\":\"\",\"63\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"64\":\"\"}",
      "用户拒绝的修改": "胶囊样式，头尾两端圆弧处的进度展示效果与Eclipse相同，中段处的进度展示效果与Linear相同。从API version 9开始，高度大于宽度时，自适应垂直显示。",
      "注意事项": "修改前必须核实API版本适用范围是否在所有相关条目中一致，避免因局部统一破坏已有版本声明准确性；优先保持原始上下文完整性，仅当明确存在规范冲突时才进行最小化修正。"
    },
    {
      "defect_id": 447588,
      "sentence": "2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。",
      "reference_sentence": "2. 热加载：在启动界面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"ArkTS应用/元服务均支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现，可以查看当前UI界面效果。\",\"16\":\"\",\"17\":\"1. 选中需要预览的ets页面，点击右侧侧边栏的Previewer按钮，启动页面预览。\",\"18\":\"\",\"19\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"20\":\"\",\"21\":\"3. 路由能力：支持通过路由能力进行页面切换。查看其它页面预览效果。\",\"22\":\"\",\"23\":\"在页面预览的基础上，提供了极速预览和Inspector双向预览两种特性。下面将详细说明这两种特性。\",\"24\":\"\"}",
      "用户拒绝的修改": "2. 热加载：在启动界面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。",
      "注意事项": "修复术语一致性时必须严格核查上下文术语使用习惯，优先保持与上下文统一表述；避免机械替换同义词，需结合行业规范（如\"页面\"在开发场景中特指Page组件，\"界面\"更偏向UI表层概念）进行精准判断。"
    },
    {
      "defect_id": 447589,
      "sentence": "3. 路由能力：支持通过路由能力进行页面切换。查看其它页面预览效果。",
      "reference_sentence": "3. 路由能力：支持通过路由能力进行界面切换。查看其它界面预览效果。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"1. 选中需要预览的ets页面，点击右侧侧边栏的Previewer按钮，启动页面预览。\",\"18\":\"\",\"19\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"20\":\"\",\"21\":\"3. 路由能力：支持通过路由能力进行页面切换。查看其它页面预览效果。\",\"22\":\"\",\"23\":\"在页面预览的基础上，提供了极速预览和Inspector双向预览两种特性。下面将详细说明这两种特性。\",\"24\":\"\",\"25\":\"### 极速预览\",\"26\":\"\"}",
      "用户拒绝的修改": "3. 路由能力：支持通过路由能力进行界面切换。查看其它界面预览效果。",
      "注意事项": "修复前必须检查上下文术语一致性，优先沿用文档已有统一表述（如\"页面\"），避免因局部替换破坏全局术语统一性。"
    },
    {
      "defect_id": 444519,
      "sentence": "当enable的值为undefined时，默认值：true",
      "reference_sentence": "当hour、minute、second的值设置为undefined时，显示效果与其默认值规则一致。",
      "line_num": 327,
      "context": "{\"322\":\"\",\"323\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"324\":\"\",\"325\":\"| 参数名 | 类型                                          | 必填  | 说明                                                                                  |\",\"326\":\"| ------ | --------------------------------------------- |-----|-------------------------------------------------------------------------------------|\",\"327\":\"| enable  | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<boolean> | 是   | 是否支持触控反馈。<br/>当enable的值为undefined时，默认值：true<br/>true表示开启触控反馈，false表示不开启触控反馈。<br/>设置为true后，其是否生效取决于系统的硬件支持情况。 |\",\"328\":\"\",\"329\":\">  **说明：**\",\"330\":\">\",\"331\":\">  开启触控反馈时，需要在工程的module.json5中配置requestPermissions字段开启振动权限，配置如下：\",\"332\":\">  ```json\"}",
      "用户拒绝的修改": "当enable的值为未定义时，默认值：true",
      "注意事项": "严格保留技术术语的原始英文表述（如undefined/boolean等编程语言关键字），避免中英文混用；修复前需核对上下文是否存在统一表述范例（如参考句中的\"设置为undefined\"）。"
    },
    {
      "defect_id": 447586,
      "sentence": "预览支持页面预览和组件预览。图一中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)表示页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)表示组件预览。",
      "reference_sentence": "预览支持页面预览和组件预览。",
      "line_num": 3,
      "context": "{\"1\":\"# UI预览\",\"2\":\"\",\"3\":\"DevEco Studio为开发者提供了UI预览功能，方便查看UI效果并随时调整界面布局。预览支持页面预览和组件预览。图一中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)表示页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)表示组件预览。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 操作系统和真机设备的差异可能导致预览效果与真机效果不同。预览效果仅作参考，实际效果以真机为准。\",\"8\":\"\"}",
      "用户拒绝的修改": "预览支持界面预览和组件预览。图一中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)表示界面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)表示组件预览。",
      "注意事项": "修复时应严格保持术语一致性，优先采用上下文已明确使用的核心词汇（如\"页面\"），避免引入未经定义的同义词替换；修改前需完整扫描上下文2-3次确认术语使用模式，确保所有相关表述同步更新。"
    },
    {
      "defect_id": 447591,
      "sentence": "ArkTS 应用和元服务支持组件预览功能。组件预览通过在组件前添加 `@Preview` 装饰器实现。在单个源文件中，最多可以使用 10 个 `@Preview` 装饰自定义组件。不支持动态图。",
      "reference_sentence": "ArkTS 应用和元服务支持组件预览功能。组件预览通过在组件前添加 `@Preview` 装饰器实现。在单个源文件中，最多可以使用 10 个 `@Preview` 装饰自定义组件。不支持动态图。",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"![ide_previewer_002](figures/ide_previewer_002.gif)\",\"63\":\"\",\"64\":\"## 组件预览\",\"65\":\"\",\"66\":\"ArkTS 应用和元服务支持组件预览功能。组件预览通过在组件前添加 `@Preview` 装饰器实现。在单个源文件中，最多可以使用 10 个 `@Preview` 装饰自定义组件。不支持动态图。\",\"67\":\"\",\"68\":\"@Preview的使用参考如下示例：\",\"69\":\"\",\"70\":\"```ts\",\"71\":\"@Preview\"}",
      "用户拒绝的修改": "ArkTS 应用和元服务支持组件预览功能。组件预览通过在组件前添加 `@Preview` 装饰器实现。在单个源文件中，最多可以使用 10 个 `@Preview` 装饰器自定义组件。不支持动态图。",
      "注意事项": "修复术语一致性时需严格区分名词性术语（如\"装饰器\"）和动词性用法（如\"装饰\"），确保同一概念在不同语法结构中保持词性适配，避免将功能描述与语法成分混为一谈。"
    },
    {
      "defect_id": 447492,
      "sentence": "设置菜单项图标。通过Modifier配置菜单项图标，若同时配置symbolIcon和icon的情况下，icon图标不显示。",
      "reference_sentence": "icon<sup>10+</sup>    | [ResourceStr](ts-types.md#resourcestr) | 否   | 菜单项图标。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 139,
      "context": "{\"134\":\"| --------------------- | -------------------------------------- | ---- | ------------------------------------------------------------ |\",\"135\":\"| value                 | [ResourceStr](ts-types.md#resourcestr) | 是   | 菜单项文本。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。                                                 |\",\"136\":\"| icon<sup>10+</sup>    | [ResourceStr](ts-types.md#resourcestr) | 否   | 菜单项图标。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。                                                 |\",\"137\":\"| enabled<sup>11+</sup> | boolean                                | 否   | 菜单条目是否可进行交互。<br/>默认值：true，菜单条目可以进行交互。<br/>值为false时，菜单条目不可以进行交互。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"138\":\"| action                | ()&nbsp;=&gt;&nbsp;void                | 是   | 点击菜单项的事件回调。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。                                       |\",\"139\":\"| symbolIcon<sup>12+</sup>                | [SymbolGlyphModifier](ts-universal-attributes-attribute-modifier.md)                | 否   | 设置菜单项图标。通过Modifier配置菜单项图标，若同时配置symbolIcon和icon的情况下，icon图标不显示。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。                                       |\",\"140\":\"\",\"141\":\"## MenuOptions<sup>10+</sup>\",\"142\":\"\",\"143\":\"继承自[ContextMenuOptions](#contextmenuoptions10)。\",\"144\":\"\"}",
      "用户拒绝的修改": "设置菜单项图标。通过Modifier配置菜单项图标，若同时配置symbolIcon和icon的情况下，icon不显示。",
      "注意事项": "在技术文档中必须严格保持属性名称的一致性，当涉及API参数时应直接使用原始属性名（如\"icon\"），避免添加额外描述性词汇（如\"图标\"）；同时需结合上下文确认术语使用场景，确保技术术语与代码级定义完全匹配。"
    },
    {
      "defect_id": 447587,
      "sentence": "1. 选中需要预览的ets页面，点击右侧侧边栏的Previewer按钮，启动页面预览。",
      "reference_sentence": "1. 选中需要预览的ets页面，点击右侧侧边栏的Previewer按钮，启动界面预览。",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"## 页面预览\",\"14\":\"\",\"15\":\"ArkTS应用/元服务均支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现，可以查看当前UI界面效果。\",\"16\":\"\",\"17\":\"1. 选中需要预览的ets页面，点击右侧侧边栏的Previewer按钮，启动页面预览。\",\"18\":\"\",\"19\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"20\":\"\",\"21\":\"3. 路由能力：支持通过路由能力进行页面切换。查看其它页面预览效果。\",\"22\":\"\"}",
      "用户拒绝的修改": "1. 选中需要预览的ets界面，点击右侧侧边栏的Previewer按钮，启动界面预览。",
      "注意事项": "修复时必须结合上下文准确识别术语指代对象，严格区分\"页面\"（指整体功能模块）和\"界面\"（指UI视觉层）的技术概念差异，同一功能描述中应保持核心术语一致性。"
    },
    {
      "defect_id": 449870,
      "sentence": "不配置时，默认不拦截任何用户在桌面的有效手势操作。手势操作拦截后，对应手势事件由LiveFormExtensionAbility响应。",
      "reference_sentence": "不配置时，默认不拦截任何用户在桌面的有效手势操作。手势操作拦截后，对应手势事件由LiveFormExtensionAbility响应。",
      "line_num": 19,
      "context": "{\"14\":\"| [formProvider.deactivateSceneAnimation(formId: string): Promise&lt;void&gt;](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#deactivatesceneanimation20) | 互动卡片请求切换到非激活态。 |\",\"15\":\"\",\"16\":\"\",\"17\":\"## 手势禁用配置\",\"18\":\"针对[场景动效类型互动卡片](arkts-ui-liveform-sceneanimation-overview.md)，若用户在桌面的长按、拖拽等操作会打断当前动效，卡片重新变成非激活态。系统应用可通过form_config.json中[disabledDesktopBehaviors](arkts-ui-widget-configuration.md#sceneanimationparams标签)字段进行配置取消该限制，确保用户在激活态卡片交互热区内操作时，不打断当前卡片动效。\",\"19\":\"不配置时，默认不拦截任何用户在桌面的有效手势操作。手势操作拦截后，对应手势事件由LiveFormExtensionAbility响应。\",\"20\":\"\",\"21\":\"```ts\",\"22\":\"// entry/src/main/resources/base/profile/form_config.json\",\"23\":\"{\",\"24\":\"  \\\"forms\\\": [\"}",
      "用户拒绝的修改": "不配置时，默认不拦截任何用户在桌面的有效手势操作。取消该限制后，对应手势事件由LiveFormExtensionAbility响应。",
      "注意事项": "保持术语一致性时需严格匹配原句动作方向（如\"拦截\"对应\"拦截后\"而非\"取消限制\"），修改前必须结合上下文确认逻辑因果关系，避免因反向替换导致语义反转。"
    },
    {
      "defect_id": 447590,
      "sentence": "支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。",
      "reference_sentence": "支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。",
      "line_num": 46,
      "context": "{\"41\":\"**图二**\",\"42\":\"![ide_previewer_001](figures/ide_previewer_001.gif)\",\"43\":\"\",\"44\":\"### inspector双向预览\",\"45\":\"\",\"46\":\"支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。\",\"47\":\"\",\"48\":\"开启双向预览功能后，支持代码编辑器、UI界面和组件树之间的联动：\",\"49\":\"\",\"50\":\"1. 选中预览器界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。\",\"51\":\"\"}",
      "用户拒绝的修改": "支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)开启双向预览功能。",
      "注意事项": "修复时应全面检查上下文中的术语使用频率，优先沿用文档已多次出现的动词（如上下文已使用\"开启\"）；核对用户提供的参考句子是否包含正确表达，避免过度修改引入新矛盾。"
    },
    {
      "defect_id": 449021,
      "sentence": "以下内容介绍基于声明式范式ArkTS UI卡片开发。",
      "reference_sentence": "## 亮点/特征1. 统一开发范式    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。",
      "line_num": 2,
      "context": "{\"1\":\"# ArkTS卡片概述\",\"2\":\"以下内容介绍基于声明式范式ArkTS UI卡片开发。\",\"3\":\"\",\"4\":\"## 亮点/特征\",\"5\":\"1. 统一开发范式\",\"6\":\"\",\"7\":\"    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。具体请参考图1 卡片工程结构对比。\"}",
      "用户拒绝的修改": "以下内容介绍基于声明式范式ArkTS卡片开发。",
      "注意事项": "在修复术语一致性时需严格核对上下文现有用词，避免修改非当前问题范畴的表述；处理近义词替换时优先采用文档中已确立的规范词汇（如上下文标题使用\"特征\"则保持统一，不替换为\"特点\"）。"
    },
    {
      "defect_id": 449022,
      "sentence": "## 亮点/特征",
      "reference_sentence": "## 亮点/特征1. 统一开发范式    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。",
      "line_num": 4,
      "context": "{\"1\":\"# ArkTS卡片概述\",\"2\":\"以下内容介绍基于声明式范式ArkTS UI卡片开发。\",\"3\":\"\",\"4\":\"## 亮点/特征\",\"5\":\"1. 统一开发范式\",\"6\":\"\",\"7\":\"    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。具体请参考图1 卡片工程结构对比。\",\"8\":\"\",\"9\":\"    **图1** 卡片工程结构对比   \"}",
      "用户拒绝的修改": "## 亮点/特点",
      "注意事项": "在替换近义词前必须核查上下文术语一致性，优先保留原文已建立的术语体系；仅修复当前修改任务引入的表述问题，避免对文档历史遗留的合理近义词混用进行非必要修改。"
    },
    {
      "defect_id": 449884,
      "sentence": "激活态加载复杂界面UI时（例如复杂物理仿真动效等），耗时较长容易造成页面页面切换不流畅。",
      "reference_sentence": "### 开发流程",
      "line_num": 88,
      "context": "{\"83\":\"}\",\"84\":\"```\",\"85\":\"\",\"86\":\"4. LiveFormExtensionAbility适配\",\"87\":\"\",\"88\":\"激活态加载复杂界面UI时（例如复杂物理仿真动效等），耗时较长容易造成页面页面切换不流畅。因此提供基于[UIExtensionContentSession](../reference/apis-ability-kit/js-apis-app-ability-uiExtensionContentSession.md)消息通知机制，当激活态页面加载完成，卡片提供方需通过UIExtensionContentSession发送信息通知卡片使用方，卡片使用方收到信息后再切换卡片激活态界面。\",\"89\":\"\",\"90\":\"```ts\",\"91\":\"// entry/src/main/ets/mysystemliveformextensionability/MySystemLiveFormExtensionAbility.ets \",\"92\":\"import { formInfo, LiveFormInfo, LiveFormExtensionAbility } from '@kit.FormKit';\",\"93\":\"import { UIExtensionContentSession } from '@kit.AbilityKit';\"}",
      "用户拒绝的修改": "激活态加载复杂界面时（例如复杂物理仿真动效等），耗时较长容易造成界面切换不流畅。",
      "注意事项": "修复时应优先检查上下文术语使用习惯，确保修改后的词汇与文档现有术语体系完全一致，避免因追求局部优化破坏整体用词统一性；对于重复用词问题，应采用直接删除冗余词汇而非替换术语的方式处理，除非上下文明确存在术语混用错误。"
    },
    {
      "defect_id": 449972,
      "sentence": "同时在 main_pages.json 文件中声明互动卡片页面。",
      "reference_sentence": "在form_config.json配置文件中，新增sceneAnimationParams配置项。",
      "line_num": 181,
      "context": "{\"176\":\"      }\",\"177\":\"    ]\",\"178\":\"    ...\",\"179\":\"```\",\"180\":\"\",\"181\":\"同时在 main_pages.json 文件中声明互动卡片页面。\",\"182\":\"\",\"183\":\"```ts\",\"184\":\"// entry/src/main/resources/base/profile/main_pages.json\",\"185\":\"{\",\"186\":\"  \\\"src\\\": [\"}",
      "用户拒绝的修改": "同时在 form_config.json 文件中声明互动卡片页面。",
      "注意事项": "修复时必须严格校验上下文提及的专有名词（如配置文件名）是否与问题句子的原始引用一致，禁止基于参考句子的术语进行跨文件替换，尤其需核对用户提供的行号上下文（如184行明确指向main_pages.json）。"
    },
    {
      "defect_id": 449958,
      "sentence": "通过[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)创建互动卡片，创建时加载互动卡片页面。",
      "reference_sentence": "通过[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)创建互动卡片，创建时加载互动卡片界面。",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"### 卡片激活态UI开发\",\"22\":\"\",\"23\":\"1. 创建互动卡片\",\"24\":\"\",\"25\":\"通过[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)创建互动卡片，创建时加载互动卡片页面。\",\"26\":\"\",\"27\":\"```ts\",\"28\":\"// entry/src/main/ets/myliveformextensionability/MyLiveFormExtensionAbility.ets\",\"29\":\"import { formInfo, LiveFormInfo, LiveFormExtensionAbility } from '@kit.FormKit';\",\"30\":\"import { UIExtensionContentSession } from '@kit.AbilityKit';\"}",
      "用户拒绝的修改": "通过[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)创建互动卡片，创建时加载互动卡片界面。",
      "注意事项": "修复前必须全面检查文档中相关术语的现有使用习惯，优先采用上下文已确定的统一词汇（如“界面”），并严格区分技术概念差异（如“页面”指代物理载体，“界面”侧重交互层）。"
    },
    {
      "defect_id": 449070,
      "sentence": "ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。",
      "line_num": 59,
      "context": "{\"54\":\"- router事件：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转应用内页面的交互功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。\",\"55\":\"- call事件：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。\",\"56\":\"- message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。\",\"57\":\"\",\"58\":\"### 静态卡片\",\"59\":\"ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。\",\"60\":\"请参见[FormLink](../reference/apis-arkui/arkui-ts/ts-container-formlink.md)。\",\"61\":\"\",\"62\":\"### 互动卡片\",\"63\":\"互动卡片提供卡片破框动效能力，能够动态展示普通卡片提供的静态信息或图片，并实现人机交互，提升信息提醒、浅层交互和可玩性体验。具体请参考[互动卡片概述](arkts-ui-liveform-overview.md)\",\"64\":\"\"}",
      "用户拒绝的修改": "ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件处理。",
      "注意事项": "修复时必须全面检查上下文术语一致性，确保修改后的术语与当前段落及相邻段落中的已有用词完全统一，避免仅根据局部信息做出可能导致全局不一致的修改。"
    },
    {
      "defect_id": 447399,
      "sentence": "用户点击图标启动应用场景动效开始点，由离手事件LAST_UP触发。",
      "reference_sentence": "用户场景（通常为具有动效的场景）触发模式枚举。",
      "line_num": 66,
      "context": "{\"61\":\"| startInputType | [ActionType](#actiontype)| 是 | 用户场景触发模式。 |\",\"62\":\"| note | string| 否 | 用户场景备注信息。长度限制30个字符，可以空缺不填，填写后性能指标上报会携带备注信息，不填无影响。 |\",\"63\":\"\",\"64\":\"**示例：** \",\"65\":\"\",\"66\":\"用户点击图标启动应用场景动效开始点，由离手事件LAST_UP触发。\",\"67\":\"  ```ts\",\"68\":\"performanceMonitor.begin(\\\"LAUNCHER_APP_LAUNCH_FROM_ICON\\\", performanceMonitor.ActionType.LAST_UP, \\\"APP_START_BEGIN\\\");\",\"69\":\"  ```\",\"70\":\"\",\"71\":\"\"}",
      "用户拒绝的修改": "用户点击图标启动用户场景动效开始点，由离手事件LAST_UP触发。",
      "注意事项": "修复时应严格遵循上下文术语一致性，优先核对问题句子所在段落及相邻字段的用词规范，避免跨场景术语替换；当用户明确指定替换对象时，需精准定位原始错误点而非机械匹配近义词。"
    },
    {
      "defect_id": 449234,
      "sentence": "卡片自身业务不能强依赖互动卡片动效能力",
      "reference_sentence": "卡片自身业务不能强依赖互动卡片动效能力",
      "line_num": 26,
      "context": "{\"21\":\"**图2** 场景动效类型互动卡片样例\",\"22\":\"\",\"23\":\"![live-form-weather-demo.gif](figures/live-form-weather-demo.gif)\",\"24\":\"\",\"25\":\"## 约束和限制\",\"26\":\"- 互动卡片作为卡片功能的增强，卡片自身业务不能强依赖互动卡片动效能力。\",\"27\":\"<!--RP1--><!--RP1End-->\"}",
      "用户拒绝的修改": "卡片自身业务不能依赖互动卡片动效能力",
      "注意事项": "修复时应同时检查上下文完整性，避免遗漏关键信息点（如\"体验闭环\"）；在保持用词一致性的同时，需优先保留原始语义强调程度（如\"强依赖\"的特殊语境），若需删减修饰词必须确认不影响核心约束表达。"
    },
    {
      "defect_id": 449071,
      "sentence": "不支持使用native语言开发，不支持加载native so。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。",
      "line_num": 74,
      "context": "{\"69\":\"\",\"70\":\"- 当导入模块时，仅支持导入标识“支持在ArkTS卡片中使用”的模块。若使用了不支持使用的API，卡片加载显示异常。\",\"71\":\"\",\"72\":\"- 支持导入[HAR](../quick-start/har-package.md)静态共享包，不支持导入[HSP](../quick-start/in-app-hsp.md)动态共享包。\",\"73\":\"\",\"74\":\"- 不支持使用native语言开发，不支持加载native so。\",\"75\":\"\",\"76\":\"- 仅支持[声明式范式](../ui/arkts-ui-development-overview.md)的部分组件、事件、动效、数据管理、状态管理和API能力。对于支持在ArkTS卡片中使用的接口，会添加“卡片能力”的标记：从API version x开始，该接口支持在ArkTS卡片中使用。\",\"77\":\"\",\"78\":\"- 卡片组件内容的事件处理和卡片使用方的事件处理是独立的，建议在使用方支持左右滑动的场景下卡片内容不要使用左右滑动功能的组件，以防手势冲突影响交互体验。\",\"79\":\"\"}",
      "用户拒绝的修改": "不支持使用原生语言开发，不支持加载原生 so。",
      "注意事项": "修复前需确认问题是否属于当前修改范围，避免引入无关变更；同时检查上下文及全文档术语一致性，确保修改仅针对本次混用问题，避免连带调整其他潜在不一致项。"
    },
    {
      "defect_id": 449973,
      "sentence": "在非激活态卡片页面实现点击卡片时，请求卡片动效。",
      "reference_sentence": "互动卡片通过调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发动效，调用时需要明确：（1）动效申请范围。（2）动效持续时间。（3）是否使用系统提供的默认切换动效。",
      "line_num": 197,
      "context": "{\"192\":\"\",\"193\":\"### 卡片非激活态UI开发\",\"194\":\"\",\"195\":\"1. 非激活态卡片页面实现\",\"196\":\"\",\"197\":\"非激活态卡片页面开发同普通卡片开发流程完全一致，在widgetCard.ets中完成。widgetCard.ets文件在卡片创建时自动生成，卡片创建流程可以参考[创建ArkTS卡片](arkts-ui-widget-creation.md)。在非激活态卡片页面实现点击卡片时，请求卡片动效。\",\"198\":\"\",\"199\":\"```ts\",\"200\":\"// entry/src/main/ets/widget/pages/WidgetCard.ets\",\"201\":\"@Entry\",\"202\":\"@Component\"}",
      "用户拒绝的修改": "在非激活态卡片页面实现点击卡片时，触发动效。",
      "注意事项": "修复时应严格遵循上下文已有的固定术语（如“请求卡片动效”），避免替换为近义词（如“触发”）；需结合参考句子中接口调用逻辑（requestOverflow）与用户反馈中的\"发起请求\"表述，精准匹配技术场景的语义一致性。"
    },
    {
      "defect_id": 449233,
      "sentence": "当用户点击卡片时，开始体验对应卡片小游戏",
      "reference_sentence": "单击卡片时，开始体验对应卡片小游戏",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"互动卡片包含两种类型：趣味交互类型互动卡片和场景动效类型互动卡片。\",\"8\":\"\",\"9\":\"### 趣味交互类型\",\"10\":\"\",\"11\":\"趣味交互类型互动卡片，提供卡片小游戏功能，当用户点击卡片时，开始体验对应卡片小游戏。当前仅支持基于[快游戏](https://developer.huawei.com/consumer/cn/doc/quickApp-Guides/quickgame-interact-card-0000002045917828)开发。详细请参考[趣味交互类型互动卡片开发指导](arkts-ui-liveform-funinteraction-development.md)。\",\"12\":\"\",\"13\":\"**图1** 趣味交互类型互动卡片样例\",\"14\":\"\",\"15\":\"![live-form-game-demo.gif](figures/live-form-game-demo.gif)\",\"16\":\"\"}",
      "用户拒绝的修改": "当用户单击卡片时，开始体验对应卡片小游戏",
      "注意事项": "修复前必须全局检索文档中相关术语的既有使用习惯（如“单击”在参考句子中的统一性），优先沿用已有高频用词，避免仅基于单句语境进行局部优化。"
    },
    {
      "defect_id": 449072,
      "sentence": "支持导入[HAR](../quick-start/har-package.md)静态共享包，不支持导入[HSP](../quick-start/in-app-hsp.md)动态共享包。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。",
      "line_num": 72,
      "context": "{\"67\":\"\",\"68\":\"- 当前仅支持基于ArkUI开发卡片，不支持跨平台开发。\",\"69\":\"\",\"70\":\"- 当导入模块时，仅支持导入标识“支持在ArkTS卡片中使用”的模块。若使用了不支持使用的API，卡片加载显示异常。\",\"71\":\"\",\"72\":\"- 支持导入[HAR](../quick-start/har-package.md)静态共享包，不支持导入[HSP](../quick-start/in-app-hsp.md)动态共享包。\",\"73\":\"\",\"74\":\"- 不支持使用native语言开发，不支持加载native so。\",\"75\":\"\",\"76\":\"- 仅支持[声明式范式](../ui/arkts-ui-development-overview.md)的部分组件、事件、动效、数据管理、状态管理和API能力。对于支持在ArkTS卡片中使用的接口，会添加“卡片能力”的标记：从API version x开始，该接口支持在ArkTS卡片中使用。\",\"77\":\"\"}",
      "用户拒绝的修改": "支持导入[HAR](../quick-start/har-package.md)静态包，不支持导入[HSP](../quick-start/in-app-hsp.md)动态包。",
      "注意事项": "修复时必须严格遵循上下文已有的术语使用（如“静态共享包”），禁止擅自简化或替换已统一的关键词；修改范围应仅限问题点，避免对原文档已规范表述进行无关调整。"
    },
    {
      "defect_id": 449023,
      "sentence": "与动态卡片相比，静态卡片整体的运行框架和渲染流程和动态卡片是一致的。",
      "reference_sentence": "## ArkTS卡片类型ArkTS卡片分为动态卡片、静态卡片、互动卡片三种类型。",
      "line_num": 39,
      "context": "{\"34\":\"与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widgets.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一应用提供方的渲染实例运行在同一个ArkTS虚拟机运行环境中，不同应用提供方的渲染实例运行在不同的ArkTS虚拟机运行环境中，通过ArkTS虚拟机运行环境隔离不同应用提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同应用提供方的卡片globalThis对象是同一个，不同应用提供方的卡片globalThis对象是不同的。\",\"35\":\"\",\"36\":\"## ArkTS卡片类型\",\"37\":\"ArkTS卡片分为动态卡片、静态卡片、互动卡片三种类型。\",\"38\":\"\",\"39\":\"与动态卡片相比，静态卡片整体的运行框架和渲染流程和动态卡片是一致的。主要区别在于，卡片渲染服务将卡片内容渲染完毕后，卡片使用方会使用最后一帧渲染的数据作为静态图片显示，其次卡片渲染服务中的卡片实例会释放该卡片的所有运行资源以节省内存。因此频繁的刷新会导致静态卡片运行时资源不断的创建和销毁，增加卡片功耗。<br/>\",\"40\":\"\",\"41\":\"| 卡片类型 | 支持的能力 | 适用场景 | 优缺点 |\",\"42\":\"| ------- | ------ | ------- | ------- | \",\"43\":\"| 静态卡片 | 仅支持UI组件和布局能力。| 主要用于展示静态信息（UI相对固定），仅可以通过FormLink组件跳转到指定的UIAbility。| 功能简单但可以有效控制内存开销。|\",\"44\":\"| 动态卡片 | 除了支持UI组件和布局能力，还支持通用事件能力和自定义动效能力。 | 用于有复杂业务逻辑和交互的场景。例如：卡片页面图片的刷新、卡片内容的刷新等。| 功能丰富但内存开销较大。|\"}",
      "用户拒绝的修改": "与动态卡片相比，静态卡片的整体运行框架和渲染流程是一致的。",
      "注意事项": "在修复重复概念时需结合上下文判断是否为必要强调或合理对比，避免机械删除合理重复；优先确认问题是否属于当前修改范围，防止引入无关变更。"
    },
    {
      "defect_id": 450116,
      "sentence": "场景动效类型互动卡片，支持卡片在特定场景下触发互动卡片特有动效，例如开发者可以选择将动效渲染区域超出卡片自身渲染区域，营造“破框”效果。",
      "reference_sentence": "场景动效类型互动卡片，支持卡片在特定场景下触发互动卡片特有动效，例如开发者可以选择将动效渲染区域超出卡片自身渲染区域，营造“破框”效果。",
      "line_num": 3,
      "context": "{\"1\":\"# 场景动效类型互动卡片概述\",\"2\":\"\",\"3\":\"场景动效类型互动卡片，支持卡片在特定场景下触发互动卡片特有动效，例如开发者可以选择将动效渲染区域超出卡片自身渲染区域，营造“破框”效果。\",\"4\":\"\",\"5\":\"## 基本概念\",\"6\":\"\",\"7\":\"场景动效类型互动卡片主要包含两个状态：激活态和非激活态。在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，切回非激活态。\",\"8\":\"\"}",
      "用户拒绝的修改": "场景动效类型互动卡片，支持卡片在特定场景下触发互动卡片特有动效，例如开发者可以触发将动效渲染区域超出卡片自身渲染区域，营造“破框”效果。",
      "注意事项": "在确保动词一致性前需优先确认术语准确性，区分主动操作（开发者选择）与系统行为（卡片触发），避免将技术文档中的合理术语误判为不一致。"
    },
    {
      "defect_id": 449069,
      "sentence": "ArkTS卡片中提供了[postCardAction](../reference/apis-arkui/js-apis-postCardAction.md#postcardaction)接口用于动态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片控件的点击事件中可以调用。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。",
      "line_num": 48,
      "context": "{\"43\":\"| 静态卡片 | 仅支持UI组件和布局能力。| 主要用于展示静态信息（UI相对固定），仅可以通过FormLink组件跳转到指定的UIAbility。| 功能简单但可以有效控制内存开销。|\",\"44\":\"| 动态卡片 | 除了支持UI组件和布局能力，还支持通用事件能力和自定义动效能力。 | 用于有复杂业务逻辑和交互的场景。例如：卡片页面图片的刷新、卡片内容的刷新等。| 功能丰富但内存开销较大。|\",\"45\":\"| 互动卡片 | 在动态卡片基础上，额外支持破框动效能力。 | 用于有复杂业务逻辑和交互，需要执行破框动效呈现更好视觉体验的场景。例如：桌面卡片游戏等。| 功能丰富但内存开销较大。|\",\"46\":\"\",\"47\":\"### 动态卡片\",\"48\":\"ArkTS卡片中提供了[postCardAction](../reference/apis-arkui/js-apis-postCardAction.md#postcardaction)接口用于动态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片控件的点击事件中可以调用。\",\"49\":\"\",\"50\":\"**图4** 动态卡片事件实现原理  \",\"51\":\"![WidgetPostCardAction](figures/WidgetPostCardAction.png)\",\"52\":\"\",\"53\":\"动态卡片事件的主要使用场景如下：\"}",
      "用户拒绝的修改": "ArkTS卡片中提供了[postCardAction](../reference/apis-arkui/js-apis-postCardAction.md#postcardaction)接口用于动态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片控件的单击事件中可以调用。",
      "注意事项": "修复术语不一致时需优先确认上下文中的现有用词规范（如参考问题上下文中的\"点击事件\"是否与其他部分统一），避免引入与当前修改范围无关的词汇变更；若修改涉及全局一致性，应提示用户进行全文档排查而非局部替换。"
    },
    {
      "defect_id": 450118,
      "sentence": "在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，切回非激活态。",
      "reference_sentence": "在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，切回非激活态。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"场景动效类型互动卡片，支持卡片在特定场景下触发互动卡片特有动效，例如开发者可以选择将动效渲染区域超出卡片自身渲染区域，营造“破框”效果。\",\"4\":\"\",\"5\":\"## 基本概念\",\"6\":\"\",\"7\":\"场景动效类型互动卡片主要包含两个状态：激活态和非激活态。在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，切回非激活态。\",\"8\":\"\",\"9\":\"**非激活态**：在此状态下，卡片与普通卡片行为无异，遵循既有的卡片开发规范，卡片UI由卡片提供方widgetCard.ets中的内容所承载。\",\"10\":\"\",\"11\":\"**激活态**： 表示互动卡片动效渲染状态，在此状态下，卡片UI由卡片提供方所开发的[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)对应page页面完成渲染。详细可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"12\":\"\"}",
      "用户拒绝的修改": "在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，触发非激活态。",
      "注意事项": "在统一动词前需优先确认上下文语义准确性，技术场景中\"触发\"适用于启动动作，\"切回/切换\"更适合状态回转，应结合专业术语使用场景选择最贴切的动词而非机械统一。"
    },
    {
      "defect_id": 450121,
      "sentence": "开发者可以通过[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发互动卡片动效，例如在用户点击时触发，典型时序图如下。",
      "reference_sentence": "开发者可以通过[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发互动卡片动效，例如在用户点击时触发，典型时序图如下。",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"![live-form-judge.PNG](figures/live-form-judge.PNG)\",\"20\":\"\",\"21\":\"## 实现原理\",\"22\":\"\",\"23\":\"开发者可以通过[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发互动卡片动效，例如在用户点击时触发，典型时序图如下。\",\"24\":\"\",\"25\":\"**图3** 点击触发互动卡片动效时序图\",\"26\":\"\",\"27\":\"![live-form-click-timeline.png](figures/live-form-click-timeline.png)\",\"28\":\"\"}",
      "用户拒绝的修改": "开发者可以通过[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发互动卡片动效，例如在用户触发时触发，典型时序图如下。",
      "注意事项": "在统一动词时需确保不改变原句核心语义，优先保留上下文中的技术术语（如“点击”为具体操作，“触发”为抽象行为），并检查问题上下文中的图表标题（如“点击触发时序图”）以保持全局一致性。"
    },
    {
      "defect_id": 447400,
      "sentence": "用户点击图标应用场景动效结束点",
      "reference_sentence": "用户场景（通常为具有动效的场景）触发模式枚举。",
      "line_num": 87,
      "context": "{\"82\":\"| -- | -- | -- | -- |\",\"83\":\"| scene | string | 是 | 用户场景id，与begin配对严格保持一致，否则本次场景监测无效 |\",\"84\":\"\",\"85\":\"**示例：** \",\"86\":\"\",\"87\":\"用户点击图标应用场景动效结束点\",\"88\":\"  ```ts\",\"89\":\"performanceMonitor.end(\\\"LAUNCHER_APP_LAUNCH_FROM_ICON\\\");\",\"90\":\"  ```\",\"91\":\"\",\"92\":\"## performanceMonitor.recordInputEventTime<sup>12+</sup>\"}",
      "用户拒绝的修改": "用户点击图标用户场景动效结束点",
      "注意事项": "修复时必须严格对照上下文术语定义（如\"用户场景id\"）和参考示例，避免机械替换；优先确认原始问题句子中的术语是否与文档内已有规范冲突，而非直接统一同义词。"
    },
    {
      "defect_id": 450119,
      "sentence": "**图1** 互动卡片状态切换说明",
      "reference_sentence": "**图1** 互动卡片状态切换说明",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"**非激活态**：在此状态下，卡片与普通卡片行为无异，遵循既有的卡片开发规范，卡片UI由卡片提供方widgetCard.ets中的内容所承载。\",\"10\":\"\",\"11\":\"**激活态**： 表示互动卡片动效渲染状态，在此状态下，卡片UI由卡片提供方所开发的[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)对应page页面完成渲染。详细可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"12\":\"\",\"13\":\"**图1** 互动卡片状态切换说明\",\"14\":\"\",\"15\":\"![live-form-status-change.png](figures/live-form-status-change.png)\",\"16\":\"\",\"17\":\"**图2** 互动卡片动效触发流程\",\"18\":\"\"}",
      "用户拒绝的修改": "**图1** 互动卡片状态切换流程",
      "注意事项": "在统一术语前需确认上下文是否存在合理的差异化表达，优先保留原文中已形成对照关系的专业表述（如\"说明\"对应静态描述，\"流程\"对应动态步骤），避免过度统一破坏文档结构逻辑。"
    },
    {
      "defect_id": 450391,
      "sentence": "其中键名称为固定字符串“ohos.extension.form”，资源为[卡片具体配置信息的资源索引](#卡片配置)。",
      "reference_sentence": "其中键名称为固定字符串“ohos.extension.form”，资源为[卡片具体配置信息的资源索引](#卡片配置)。",
      "line_num": 8,
      "context": "{\"3\":\"\",\"4\":\"卡片相关的配置文件主要包含[FormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-formExtensionAbility.md)配置和卡片配置。\",\"5\":\"\",\"6\":\"## FormExtensionAbility配置\",\"7\":\"\",\"8\":\"卡片需要在[module.json5配置文件](../quick-start/module-configuration-file.md)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串“ohos.extension.form”，资源为[卡片具体配置信息的资源索引](#卡片配置)。\",\"9\":\"\",\"10\":\"   配置示例如下：\",\"11\":\"\",\"12\":\"\",\"13\":\"   ```json\"}",
      "用户拒绝的修改": "其中键名为固定字符串“ohos.extension.form”，资源为[卡片具体配置信息的资源索引](#卡片配置)。",
      "注意事项": "修复时应严格限定修改范围为当前问题点，避免改动上下文已统一的关键术语；优先检查问题句子的上下文是否存在已固定的表述习惯，确保术语一致性高于局部优化。"
    },
    {
      "defect_id": 450120,
      "sentence": "**图2** 互动卡片动效触发流程",
      "reference_sentence": "**图2** 互动卡片动效触发流程",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"**图1** 互动卡片状态切换说明\",\"14\":\"\",\"15\":\"![live-form-status-change.png](figures/live-form-status-change.png)\",\"16\":\"\",\"17\":\"**图2** 互动卡片动效触发流程\",\"18\":\"\",\"19\":\"![live-form-judge.PNG](figures/live-form-judge.PNG)\",\"20\":\"\",\"21\":\"## 实现原理\",\"22\":\"\"}",
      "用户拒绝的修改": "**图2** 互动卡片动效触发说明",
      "注意事项": "在统一术语前需确认上下文是否存在实际不一致，优先保留原文合理表述；区分\"流程\"侧重步骤顺序、\"说明\"侧重功能解析的语义差异，避免过度纠错。"
    },
    {
      "defect_id": 450398,
      "sentence": "当取值为正整数N时，表示刷新周期为30\\*N分钟。",
      "reference_sentence": "当取值为正整数N时，表示刷新周期为30\\*N分钟。",
      "line_num": 58,
      "context": "{\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\"}",
      "用户拒绝的修改": "当取值为正整数n时，表示刷新周期为30\\*n分钟。",
      "注意事项": "修改前需严格验证上下文变量命名规范，确保修改对象确实属于当前问题范围；优先保持文档历史一致性而非单纯遵循通用命名规则，避免引入无关变量大小写变更。"
    },
    {
      "defect_id": 450122,
      "sentence": "**图3** 点击触发互动卡片动效时序图",
      "reference_sentence": "**图3** 点击触发互动卡片动效时序图",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"## 实现原理\",\"22\":\"\",\"23\":\"开发者可以通过[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发互动卡片动效，例如在用户点击时触发，典型时序图如下。\",\"24\":\"\",\"25\":\"**图3** 点击触发互动卡片动效时序图\",\"26\":\"\",\"27\":\"![live-form-click-timeline.png](figures/live-form-click-timeline.png)\",\"28\":\"\",\"29\":\"在卡片定时定点刷新场景下，典型时序图如下。\",\"30\":\"\"}",
      "用户拒绝的修改": "**图3** 触发互动卡片动效时序图",
      "注意事项": "在保持术语统一时需优先保留原句核心动作信息（如\"点击\"），若上下文存在功能差异说明（如触发方式影响操作逻辑），应通过补充说明而非直接删除关键限定词来实现一致性。"
    },
    {
      "defect_id": 450123,
      "sentence": "例如：某设备上一个2*2卡片宽度为158vp，高度为158vp。对应上图则有：",
      "reference_sentence": "例如：某设备上一个2*2卡片宽度为158vp，高度为158vp。对应上图则有：",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"**图5** 互动卡片动效区域申请规则说明\",\"51\":\"\",\"52\":\"![live-form-overflow-rule.png](figures/live-form-overflow-rule.png)\",\"53\":\"\",\"54\":\"例如：某设备上一个2*2卡片宽度为158vp，高度为158vp。对应上图则有：\",\"55\":\"（1）AD=158vp，AB=158vp，IJ=158\\\\*1.5=237vp，IL=158\\\\*1.5=237vp。\",\"56\":\"（2）IA两点水平相距39.5vp，垂直相距39.5vp。\",\"57\":\"\",\"58\":\"因此，以A点为原点，向右为X轴正方向，向下为Y轴正方向，图5中E点的合法坐标可以是（-20，-20），EF边长合法值可以是200vp，EH边长合法值可以是200vp。\",\"59\":\"\"}",
      "用户拒绝的修改": "例如：某设备上一个2*2卡片宽度为158vp，高度为158vp。如下图所示：",
      "注意事项": "修复时应优先保持原句指代关系的准确性，在涉及图表引用时需结合上下文确认图示位置，避免因统一表达方式而改变原有语义指向。"
    },
    {
      "defect_id": 450392,
      "sentence": "在上述FormExtensionAbility的元信息metadata配置项中，可以指定卡片具体配置信息的资源索引。",
      "reference_sentence": "在上述FormExtensionAbility的元信息metadata配置项中，可以指定卡片具体配置信息的资源索引。",
      "line_num": 37,
      "context": "{\"32\":\"     }\",\"33\":\"   }\",\"34\":\"   ```\",\"35\":\"## 卡片配置\",\"36\":\"\",\"37\":\"在上述FormExtensionAbility的元信息metadata配置项中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。在[创建卡片](./arkts-ui-widget-creation.md)时会自动生成form_config.json配置文件。\",\"38\":\"\",\"39\":\"### 配置文件字段说明\",\"40\":\"\",\"41\":\"   **表1** 卡片form_config.json配置文件\",\"42\":\"\"}",
      "用户拒绝的修改": "在上述FormExtensionAbility的元数据配置项中，可以指定卡片具体配置信息的资源索引。",
      "注意事项": "修改术语时应优先检查上下文和参考句子的现有用词，确保不引入与当前文档其他部分不一致的变更；若用户未明确要求术语优化，避免在修复时主动替换已存在的规范表述（如“元信息metadata”），除非能确认全局一致性。"
    },
    {
      "defect_id": 450401,
      "sentence": "仅对系统应用的ArkTS卡片生效。",
      "reference_sentence": "仅对系统应用的ArkTS卡片生效。",
      "line_num": 67,
      "context": "{\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\"}",
      "用户拒绝的修改": "仅限系统应用的ArkTypeScript卡片生效。",
      "注意事项": "修复时应优先检查上下文术语一致性，避免替换原文已有且上下文统一的表达（如“仅对”）；确保修改仅针对当前问题，不引入无关术语变更（如“ArkTS”改为“ArkTypeScript”）。"
    },
    {
      "defect_id": 450397,
      "sentence": "仅支持系统应用配置，且仅在锁屏场景下配置生效。",
      "reference_sentence": "仅支持系统应用配置，且仅在锁屏场景下配置生效。",
      "line_num": 54,
      "context": "{\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\"}",
      "用户拒绝的修改": "仅限系统应用配置，且仅在锁屏场景下配置生效。",
      "注意事项": "修改前需全面检查文档中相关术语的一致性，避免局部修改破坏全局统一性；严格区分用户反馈的具体问题范围，确保修复仅针对当前上下文而非无关内容。"
    },
    {
      "defect_id": 450395,
      "sentence": "该字段仅对JS卡片生效。",
      "reference_sentence": "该字段仅对JS卡片生效。",
      "line_num": 51,
      "context": "{\"46\":\"   | name | 表示卡片的名称，字符串最大长度为127字节。 | 字符串 | 否 |\",\"47\":\"   | displayName | 表示卡片的展示名称。主要在卡片管理页面显示，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。 | 字符串 | 否 |\",\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\"}",
      "用户拒绝的修改": "该字段仅对JavaScript卡片生效。",
      "注意事项": "修复时应严格检查上下文术语是否统一，若原文已统一使用缩写（如“JS卡片”），且无明确规范要求使用全称时，应优先保持原文一致性，避免因过度规范化破坏现有术语体系。"
    },
    {
      "defect_id": 450393,
      "sentence": "支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。",
      "reference_sentence": "支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。",
      "line_num": 48,
      "context": "{\"43\":\"   | 属性名称 | 含义 | 数据类型 | 是否可缺省 |\",\"44\":\"   | -------- | -------- | -------- | -------- |\",\"45\":\"   | forms | 表示应用的全部卡片配置信息。<br/>最多支持配置16个卡片，若超过16个，则保留配置的前16个。 | 数组 | 否 |\",\"46\":\"   | name | 表示卡片的名称，字符串最大长度为127字节。 | 字符串 | 否 |\",\"47\":\"   | displayName | 表示卡片的展示名称。主要在卡片管理页面显示，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。 | 字符串 | 否 |\",\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\"}",
      "用户拒绝的修改": "支持字符串或字符串资源，建议使用字符串资源方式声明，以支持完整多语言能力。",
      "注意事项": "修复时应严格核对上下文术语一致性，避免擅自删除关键技术术语（如“索引”），确保修改仅针对当前问题且不破坏已有规范表述。"
    },
    {
      "defect_id": 450396,
      "sentence": "该接口废弃，卡片主题样式统一跟随系统的颜色模式。",
      "reference_sentence": "该接口废弃，卡片主题样式统一跟随系统的颜色模式。",
      "line_num": 53,
      "context": "{\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\"}",
      "用户拒绝的修改": "该接口弃用，卡片主题样式统一跟随系统的颜色模式。",
      "注意事项": "修复时应严格核对上下文术语一致性，避免在非必要场景下替换已有规范术语；优先保持文档内部用词统一性，仅在明确违反规范或存在歧义时调整表述。"
    },
    {
      "defect_id": 450400,
      "sentence": "仅对系统应用的卡片生效。",
      "reference_sentence": "仅对系统应用的卡片生效。",
      "line_num": 66,
      "context": "{\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\"}",
      "用户拒绝的修改": "仅限系统应用的卡片生效。",
      "注意事项": "在修改术语或表达时，需优先检查上下文中的现有用词一致性（如上下文已多次使用“仅对”），避免孤立替换近义词；若用户强调“非本次修改引入”，应确认修改是否与当前问题范围及历史表述冲突。"
    },
    {
      "defect_id": 450394,
      "sentence": "支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。",
      "reference_sentence": "支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。",
      "line_num": 49,
      "context": "{\"44\":\"   | -------- | -------- | -------- | -------- |\",\"45\":\"   | forms | 表示应用的全部卡片配置信息。<br/>最多支持配置16个卡片，若超过16个，则保留配置的前16个。 | 数组 | 否 |\",\"46\":\"   | name | 表示卡片的名称，字符串最大长度为127字节。 | 字符串 | 否 |\",\"47\":\"   | displayName | 表示卡片的展示名称。主要在卡片管理页面显示，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。 | 字符串 | 否 |\",\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\"}",
      "用户拒绝的修改": "支持字符串或字符串资源，建议使用字符串资源方式声明，以支持完整多语言能力。",
      "注意事项": "修复时应严格保持技术术语的完整性（如\"字符串资源索引\"为固定概念不可拆分），修改前需交叉验证上下文是否已存在统一表述，避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 450402,
      "sentence": "仅对系统应用的ArkTS卡片生效。",
      "reference_sentence": "仅对系统应用的ArkTS卡片生效。",
      "line_num": 68,
      "context": "{\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\"}",
      "用户拒绝的修改": "仅限系统应用的ArkTypeScript卡片生效。",
      "注意事项": "修改时应严格保持技术术语的原始表述（如\"ArkTS\"不可随意改写为\"ArkTypeScript\"），并在调整用词一致性前全面检查上下文是否存在已确立的固定表达模式。"
    },
    {
      "defect_id": 450390,
      "sentence": "卡片需要在[module.json5配置文件](../quick-start/module-configuration-file.md)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。",
      "reference_sentence": "卡片需要在[module.json5配置文件](../quick-start/module-configuration-file.md)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。",
      "line_num": 8,
      "context": "{\"3\":\"\",\"4\":\"卡片相关的配置文件主要包含[FormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-formExtensionAbility.md)配置和卡片配置。\",\"5\":\"\",\"6\":\"## FormExtensionAbility配置\",\"7\":\"\",\"8\":\"卡片需要在[module.json5配置文件](../quick-start/module-configuration-file.md)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串“ohos.extension.form”，资源为[卡片具体配置信息的资源索引](#卡片配置)。\",\"9\":\"\",\"10\":\"   配置示例如下：\",\"11\":\"\",\"12\":\"\",\"13\":\"   ```json\"}",
      "用户拒绝的修改": "卡片需要在[module.json5配置文件](../quick-start/module-configuration-file.md)中的“扩展能力”标签下，配置FormExtensionAbility相关信息。",
      "注意事项": "修复术语一致性时需严格检查上下文现有用法，技术标签名称（如extensionAbilities）应保留原始英文形式，避免擅自替换为中文释义导致技术准确性缺失或混淆。"
    },
    {
      "defect_id": 450399,
      "sentence": "设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。",
      "reference_sentence": "设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。",
      "line_num": 62,
      "context": "{\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\"}",
      "用户拒绝的修改": "设置为true时，[定期刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。",
      "注意事项": "保持技术文档中已确立的术语一致性，优先沿用上下文已有的固定表述（如“定时刷新”），避免因同义词替换破坏技术概念精准性；修改前需核实现有链接锚点、参数说明等关联内容，确保全局术语统一。"
    },
    {
      "defect_id": 452104,
      "sentence": "当请求所指定的卡片ID未找到或不存在时，系统会报此错误码。",
      "reference_sentence": "指定卡片ID不存在，或传入无效卡片ID。",
      "line_num": 87,
      "context": "{\"82\":\"\",\"83\":\"The ID of the form to be operated does not exist.\",\"84\":\"\",\"85\":\"**错误描述**\",\"86\":\"\",\"87\":\"当请求所指定的卡片ID未找到或不存在时，系统会报此错误码。\",\"88\":\"\",\"89\":\"**可能原因**\",\"90\":\"\",\"91\":\"指定卡片ID不存在，或传入无效卡片ID。\",\"92\":\"\"}",
      "用户拒绝的修改": "当请求所指定的卡片ID不存在或传入无效卡片ID时，系统会报此错误码。",
      "注意事项": "修复时必须全面核查上下文关联内容，确保修改后的表述与文档其他部分的术语和逻辑结构完全一致；优先采用文档已有参考句式的标准化表达，避免引入新的表述差异。"
    },
    {
      "defect_id": 452105,
      "sentence": "当前卡片数量已达到上限，但仍继续请求添加卡片。",
      "reference_sentence": "当卡片数量已达到上限时继续请求添加卡片，系统会报此错误码。",
      "line_num": 109,
      "context": "{\"104\":\"\",\"105\":\"当卡片数量已达到上限时继续请求添加卡片，系统会报此错误码。\",\"106\":\"\",\"107\":\"**可能原因**\",\"108\":\"\",\"109\":\"当前卡片数量已达到上限，但仍继续请求添加卡片。\",\"110\":\"\",\"111\":\"**处理步骤**\",\"112\":\"\",\"113\":\"删除不必要卡片后再请求添加。\",\"114\":\"\"}",
      "用户拒绝的修改": "当前卡片数量已达到上限时，仍继续请求添加卡片。",
      "注意事项": "修改前必须严格核对上下文关联性，优先保持问题描述在原始语境中的完整性，仅当存在明确的前后矛盾且属于当前修改范围时，才进行句式统一调整。"
    },
    {
      "defect_id": 452109,
      "sentence": "服务繁忙。",
      "reference_sentence": "服务繁忙，请稍后重试。",
      "line_num": 183,
      "context": "{\"178\":\"\",\"179\":\"发送卡片加桌请求后，等待卡片加桌超时，系统会报此错误码。\",\"180\":\"\",\"181\":\"**可能原因**\",\"182\":\"\",\"183\":\"服务繁忙。\",\"184\":\"\",\"185\":\"**处理步骤**\",\"186\":\"\",\"187\":\"服务繁忙，请稍后重试。\",\"188\":\"<!--DelEnd-->\"}",
      "用户拒绝的修改": "服务繁忙，请稍后重试。",
      "注意事项": "修复前需确认上下文是否存在历史遗留的不一致，避免将既有问题误判为当前修改导致；统一表述时应区分功能场景（如原因描述与操作指引），允许合理差异存在。"
    },
    {
      "defect_id": 452748,
      "sentence": "卡片位置和大小信息。",
      "reference_sentence": "卡片位置和大小信息。",
      "line_num": 111,
      "context": "{\"106\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"107\":\"\",\"108\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"109\":\"| ------ | ------ | ---- | ---- | -------- |\",\"110\":\"| formId | string | 否 | 否 | 卡片id。 |\",\"111\":\"| rect | [formInfo.Rect](js-apis-app-form-formInfo.md#rect20) | 否 | 否 | 卡片位置和大小信息。 |\",\"112\":\"| borderRadius | number | 否 | 否 | 卡片圆角半径信息。取值大于0，单位vp。 |\",\"113\":\"\",\"114\":\"### 禁用API\",\"115\":\"- [@ohos.ability.featureAbility (FeatureAbility模块)](../apis-ability-kit/js-apis-ability-featureAbility.md)\",\"116\":\"- [@ohos.ability.particleAbility (ParticleAbility模块)](../apis-ability-kit/js-apis-ability-particleAbility.md)\"}",
      "用户拒绝的修改": "卡片位置和大小。",
      "注意事项": "修改前必须全面检查上下文所有相关术语使用情况，确认修改范围仅限于当前问题点；若参考句子本身存在术语不一致，需优先核实文档整体规范而非局部匹配。"
    },
    {
      "defect_id": 450115,
      "sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "reference_sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"配置的SELinux策略时，如果涉及应用SELinux类型，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围的详细对应关系，参考下表：\"}",
      "用户拒绝的修改": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有进程提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "注意事项": "修复时必须严格保持技术术语与上下文定义的一致性，优先采用原文已确立的核心主体称谓（如\"应用\"），避免因局部统一性破坏整体技术准确性；修改前需完整分析上下文逻辑关系，确认被替换词汇在专业领域中的指代范围是否等同。"
    },
    {
      "defect_id": 452131,
      "sentence": "获取卡片管理服务失败。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 314,
      "context": "{\"309\":\"\",\"310\":\"Get fms rpc failed.\",\"311\":\"\",\"312\":\"**错误描述**\",\"313\":\"\",\"314\":\"获取卡片管理服务失败。\",\"315\":\"\",\"316\":\"**可能原因**\",\"317\":\"\",\"318\":\"系统业务内部执行异常。\",\"319\":\"\"}",
      "用户拒绝的修改": "获取卡片管理服务失败，系统会报告此错误码。",
      "注意事项": "修改前必须全面检查上下文中的现有术语使用情况，优先沿用文档已有统一表述（如\"报\"而非\"报告\"），避免因局部修改破坏全局一致性。"
    },
    {
      "defect_id": 452128,
      "sentence": "系统执行当前请求时发生内部错误。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 234,
      "context": "{\"229\":\"\",\"230\":\"Some internal server error occurs.\",\"231\":\"\",\"232\":\"**错误描述**\",\"233\":\"\",\"234\":\"系统执行当前请求时发生内部错误。\",\"235\":\"\",\"236\":\"**可能原因**\",\"237\":\"\",\"238\":\"系统业务内部执行异常。\",\"239\":\"\"}",
      "用户拒绝的修改": "系统内为执行当前请求时发生内部错误，系统会报告此错误码。",
      "注意事项": "修复时应严格对照上下文现有表述，优先保持原文用词一致性；修改范围需精准限定在用户指出的具体不一致点，避免引入无关的术语变更。"
    },
    {
      "defect_id": 452107,
      "sentence": "服务繁忙。",
      "reference_sentence": "服务繁忙，请稍后重试。",
      "line_num": 146,
      "context": "{\"141\":\"\",\"142\":\"无法连接卡片渲染服务时，系统会报此错误码。\",\"143\":\"\",\"144\":\"**可能原因**\",\"145\":\"\",\"146\":\"服务繁忙。\",\"147\":\"\",\"148\":\"**处理步骤**\",\"149\":\"\",\"150\":\"服务繁忙，请稍后重试。\",\"151\":\"\"}",
      "用户拒绝的修改": "服务繁忙，请稍后重试。",
      "注意事项": "修复前必须确认问题是否属于当前修改范围，避免修改历史遗留问题；需全面检查上下文所有相关句子的表述一致性，确保修复覆盖全部关联内容。"
    },
    {
      "defect_id": 452753,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 177,
      "context": "{\"172\":\"- [DocumentScanner（文档扫描控件）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-document-scanner#section143611912403)\",\"173\":\"- [Scan Kit（统一扫码服务）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-api)<!--Del-->\",\"174\":\"- [@ohos.accessibility.config (系统辅助功能配置)(系统接口)](../apis-accessibility-kit/js-apis-accessibility-config-sys.md)\",\"175\":\"- [@ohos.app.ability.quickFixManager (quickFixManager)(系统接口)](../apis-ability-kit/js-apis-app-ability-quickFixManager-sys.md)\",\"176\":\"- [@ohos.app.form.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-app-form-formHost-sys.md)\",\"177\":\"- [@ohos.application.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-application-formHost-sys.md)\",\"178\":\"- [@ohos.bundle.bundleMonitor (bundleMonitor模块)(系统接口)](../apis-ability-kit/js-apis-bundleMonitor-sys.md)\",\"179\":\"- [@ohos.bundle.distributedBundleManager (distributedBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-distributedBundleManager-sys.md)\",\"180\":\"- [@ohos.bundle.freeInstall (freeInstall模块)(系统接口)](../apis-ability-kit/js-apis-freeInstall-sys.md)\",\"181\":\"- [@ohos.bundle.innerBundleManager (innerBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-Bundle-InnerBundleManager-sys.md)\",\"182\":\"- [@ohos.bundle.installer (installer模块)(系统接口)](../apis-ability-kit/js-apis-installer-sys.md)\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "确保补充说明内容与上下文格式模式匹配，避免重复术语本身，应使用括号标注接口类型或模块说明（如\"（系统接口）\"）而非重复术语，并严格参照已有条目中的括号使用规范。"
    },
    {
      "defect_id": 452755,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 179,
      "context": "{\"174\":\"- [@ohos.accessibility.config (系统辅助功能配置)(系统接口)](../apis-accessibility-kit/js-apis-accessibility-config-sys.md)\",\"175\":\"- [@ohos.app.ability.quickFixManager (quickFixManager)(系统接口)](../apis-ability-kit/js-apis-app-ability-quickFixManager-sys.md)\",\"176\":\"- [@ohos.app.form.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-app-form-formHost-sys.md)\",\"177\":\"- [@ohos.application.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-application-formHost-sys.md)\",\"178\":\"- [@ohos.bundle.bundleMonitor (bundleMonitor模块)(系统接口)](../apis-ability-kit/js-apis-bundleMonitor-sys.md)\",\"179\":\"- [@ohos.bundle.distributedBundleManager (distributedBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-distributedBundleManager-sys.md)\",\"180\":\"- [@ohos.bundle.freeInstall (freeInstall模块)(系统接口)](../apis-ability-kit/js-apis-freeInstall-sys.md)\",\"181\":\"- [@ohos.bundle.innerBundleManager (innerBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-Bundle-InnerBundleManager-sys.md)\",\"182\":\"- [@ohos.bundle.installer (installer模块)(系统接口)](../apis-ability-kit/js-apis-installer-sys.md)\",\"183\":\"- [@ohos.distributedBundle (分布式包管理)(系统接口)](../apis-ability-kit/js-apis-Bundle-distributedBundle-sys.md)\",\"184\":\"- [@ohos.distributedMissionManager (分布式任务管理)(系统接口)](../apis-ability-kit/js-apis-distributedMissionManager-sys.md)\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "确保标注格式与上下文规范严格对齐，避免在术语后冗余添加重复内容，优先采用统一的后缀标注形式（如“（系统接口）”）而非重复术语本身。"
    },
    {
      "defect_id": 452130,
      "sentence": "获取包管理服务失败。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 295,
      "context": "{\"290\":\"\",\"291\":\"Get bms rpc failed.\",\"292\":\"\",\"293\":\"**错误描述**\",\"294\":\"\",\"295\":\"获取包管理服务失败。\",\"296\":\"\",\"297\":\"**可能原因**\",\"298\":\"\",\"299\":\"系统业务内部执行异常。\",\"300\":\"\"}",
      "用户拒绝的修改": "获取包管理服务失败，系统会报告此错误码。",
      "注意事项": "修改前必须全面核对上下文中的统一用词规范，确保修改范围严格限定在本次需修复的语句内，避免因扩大修改范围导致非问题语句被错误调整。"
    },
    {
      "defect_id": 452760,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 184,
      "context": "{\"179\":\"- [@ohos.bundle.distributedBundleManager (distributedBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-distributedBundleManager-sys.md)\",\"180\":\"- [@ohos.bundle.freeInstall (freeInstall模块)(系统接口)](../apis-ability-kit/js-apis-freeInstall-sys.md)\",\"181\":\"- [@ohos.bundle.innerBundleManager (innerBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-Bundle-InnerBundleManager-sys.md)\",\"182\":\"- [@ohos.bundle.installer (installer模块)(系统接口)](../apis-ability-kit/js-apis-installer-sys.md)\",\"183\":\"- [@ohos.distributedBundle (分布式包管理)(系统接口)](../apis-ability-kit/js-apis-Bundle-distributedBundle-sys.md)\",\"184\":\"- [@ohos.distributedMissionManager (分布式任务管理)(系统接口)](../apis-ability-kit/js-apis-distributedMissionManager-sys.md)\",\"185\":\"- [@ohos.enterprise.dateTimeManager （系统时间管理）(系统接口)](../apis-mdm-kit/js-apis-enterprise-dateTimeManager-sys.md)\",\"186\":\"- [@ohos.filemanagement.userFileManager (用户数据管理)(系统接口)](../apis-core-file-kit/js-apis-userFileManager-sys.md)\",\"187\":\"- [@ohos.notificationSubscribe (NotificationSubscribe模块)(系统接口)](../apis-notification-kit/js-apis-notificationSubscribe-sys.md)\",\"188\":\"- [@ohos.privacyManager (隐私管理)(系统接口)](../apis-ability-kit/js-apis-privacyManager-sys.md)\",\"189\":\"- [@ohos.resourceschedule.usageStatistics (设备使用信息统计)(系统接口)](../apis-backgroundtasks-kit/js-apis-resourceschedule-deviceUsageStatistics-sys.md)\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "修复时应严格匹配上下文中的括号使用规范，确保补充内容仅添加在模块名称后的括号内而非重复术语；优先检查已有参考句子的格式一致性，避免冗余标注破坏原有结构。"
    },
    {
      "defect_id": 452129,
      "sentence": "系统执行获取请求的应用包名不存在，该错误属于内部错误。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 253,
      "context": "{\"248\":\"\",\"249\":\"The requested bundle name does not exist.\",\"250\":\"\",\"251\":\"**错误描述**\",\"252\":\"\",\"253\":\"系统执行获取请求的应用包名不存在，该错误属于内部错误。\",\"254\":\"\",\"255\":\"**可能原因**\",\"256\":\"\",\"257\":\"包管理获取请求方的bundleName时出错，属于系统业务内部执行异常。\",\"258\":\"\"}",
      "用户拒绝的修改": "系统内为执行获取请求的应用包名时不存在，该错误属于内部错误，系统会报告此错误码。",
      "注意事项": "修复时必须严格核查上下文及参考句子的统一用词规范，避免局部修改引发新的术语/句式不一致；优先采用文档既有表达方式（如\"报\"而非\"报告\"），禁止引入未经全局验证的词汇变更。"
    },
    {
      "defect_id": 450117,
      "sentence": "表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。",
      "reference_sentence": "表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。",
      "line_num": 69,
      "context": "{\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\",\"69\":\"表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。\"}",
      "用户拒绝的修改": "表示不允许除了accesstoken_service进程以外的其他进程对accesstoken_data_file进行文件操作。",
      "注意事项": "修复时必须严格核对上下文术语定义，若原句已通过上下文明确主体类型（如\"accesstoken_service\"在上下文中被定义为进程），禁止添加冗余限定词（如\"进程\"），避免破坏原有精准表述。"
    },
    {
      "defect_id": 452750,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 174,
      "context": "{\"169\":\"- [systemShare（分享）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/share-system-share)\",\"170\":\"- [harmonyShare（华为分享）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/share-harmony-share)\",\"171\":\"- [CardRecognition（卡证识别控件）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section143611912403)\",\"172\":\"- [DocumentScanner（文档扫描控件）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-document-scanner#section143611912403)\",\"173\":\"- [Scan Kit（统一扫码服务）](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/scan-api)<!--Del-->\",\"174\":\"- [@ohos.accessibility.config (系统辅助功能配置)(系统接口)](../apis-accessibility-kit/js-apis-accessibility-config-sys.md)\",\"175\":\"- [@ohos.app.ability.quickFixManager (quickFixManager)(系统接口)](../apis-ability-kit/js-apis-app-ability-quickFixManager-sys.md)\",\"176\":\"- [@ohos.app.form.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-app-form-formHost-sys.md)\",\"177\":\"- [@ohos.application.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-application-formHost-sys.md)\",\"178\":\"- [@ohos.bundle.bundleMonitor (bundleMonitor模块)(系统接口)](../apis-ability-kit/js-apis-bundleMonitor-sys.md)\",\"179\":\"- [@ohos.bundle.distributedBundleManager (distributedBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-distributedBundleManager-sys.md)\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "修复时必须严格对照上下文现有格式，避免重复添加冗余标注；优先检查术语标注位置是否与上下文统一（如模块名后而非术语后），确保修改仅针对本次问题而非历史内容。"
    },
    {
      "defect_id": 452747,
      "sentence": "卡片id。",
      "reference_sentence": "卡片id。",
      "line_num": 110,
      "context": "{\"105\":\"\",\"106\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"107\":\"\",\"108\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"109\":\"| ------ | ------ | ---- | ---- | -------- |\",\"110\":\"| formId | string | 否 | 否 | 卡片id。 |\",\"111\":\"| rect | [formInfo.Rect](js-apis-app-form-formInfo.md#rect20) | 否 | 否 | 卡片位置和大小信息。 |\",\"112\":\"| borderRadius | number | 否 | 否 | 卡片圆角半径信息。取值大于0，单位vp。 |\",\"113\":\"\",\"114\":\"### 禁用API\",\"115\":\"- [@ohos.ability.featureAbility (FeatureAbility模块)](../apis-ability-kit/js-apis-ability-featureAbility.md)\"}",
      "用户拒绝的修改": "卡片 ID。",
      "注意事项": "修复前需确认问题是否属于当前修改范围，避免修改历史遗留的不一致；严格依据用户提供的上下文和参考示例进行术语统一，避免过度依赖通用规则导致误判。"
    },
    {
      "defect_id": 452749,
      "sentence": "卡片圆角半径信息。取值大于0，单位vp。",
      "reference_sentence": "卡片圆角半径信息。取值大于0，单位vp。",
      "line_num": 112,
      "context": "{\"107\":\"\",\"108\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"109\":\"| ------ | ------ | ---- | ---- | -------- |\",\"110\":\"| formId | string | 否 | 否 | 卡片id。 |\",\"111\":\"| rect | [formInfo.Rect](js-apis-app-form-formInfo.md#rect20) | 否 | 否 | 卡片位置和大小信息。 |\",\"112\":\"| borderRadius | number | 否 | 否 | 卡片圆角半径信息。取值大于0，单位vp。 |\",\"113\":\"\",\"114\":\"### 禁用API\",\"115\":\"- [@ohos.ability.featureAbility (FeatureAbility模块)](../apis-ability-kit/js-apis-ability-featureAbility.md)\",\"116\":\"- [@ohos.ability.particleAbility (ParticleAbility模块)](../apis-ability-kit/js-apis-ability-particleAbility.md)\",\"117\":\"- [@ohos.account.appAccount (应用账号管理)](../apis-basic-services-kit/js-apis-appAccount.md)\"}",
      "用户拒绝的修改": "卡片圆角半径。取值大于0，单位为vp。",
      "注意事项": "修复前必须严格核对上下文现有术语使用情况，避免修改未被明确标注为不一致的字段；优先确认问题是否属于当前修改范围，防止对历史正确内容进行不必要调整。"
    },
    {
      "defect_id": 452110,
      "sentence": "传入背景图资源无效。",
      "reference_sentence": "设置互动卡片背景图时，传入背景图资源无效，系统会报此错误码。",
      "line_num": 202,
      "context": "{\"197\":\"\",\"198\":\"设置互动卡片背景图时，传入背景图资源无效，系统会报此错误码。\",\"199\":\"\",\"200\":\"**可能原因**\",\"201\":\"\",\"202\":\"背景图资源无效。\",\"203\":\"\",\"204\":\"**处理步骤**\",\"205\":\"\",\"206\":\"检查传入的背景图资源是否有效。\",\"207\":\"\"}",
      "用户拒绝的修改": "传入的背景图资源无效。",
      "注意事项": "在修复语言表达一致性时，需优先核对上下文已有表述，避免修改与上下文无关的独立正确句子；若问题句子本身在上下文中已存在对应表述，应保持原句结构仅修复真正的不一致部分。"
    },
    {
      "defect_id": 452106,
      "sentence": "指定的卡片非当前应用所有。",
      "reference_sentence": "当前应用无法对指定卡片进行操作时，系统会报此错误码。",
      "line_num": 127,
      "context": "{\"122\":\"\",\"123\":\"当前应用无法对指定卡片进行操作时，系统会报此错误码。\",\"124\":\"\",\"125\":\"**可能原因**\",\"126\":\"\",\"127\":\"指定的卡片非当前应用所有。\",\"128\":\"\",\"129\":\"**处理步骤**\",\"130\":\"\",\"131\":\"1. 检查传入卡片ID所有权。\",\"132\":\"2. 升级权限为SystemApp。\"}",
      "用户拒绝的修改": "指定的卡片不属于当前应用。",
      "注意事项": "修复时必须全面检查上下文关联表述，优先保持原有术语和结构一致性；若修改涉及跨段落统一，需明确标注影响范围并验证是否属于当前修改任务范畴。"
    },
    {
      "defect_id": 452108,
      "sentence": "卡片代码存在死循环、内存泄漏等问题导致系统异常。",
      "reference_sentence": "卡片不受信任。",
      "line_num": 164,
      "context": "{\"159\":\"\",\"160\":\"卡片不受信任。\",\"161\":\"\",\"162\":\"**可能原因**\",\"163\":\"\",\"164\":\"卡片代码存在死循环、内存泄漏等问题导致系统异常。\",\"165\":\"\",\"166\":\"**处理步骤**\",\"167\":\"\",\"168\":\"检查卡片代码的死循环、内存泄漏等问题。\",\"169\":\"\"}",
      "用户拒绝的修改": "卡片代码存在死循环、内存泄漏等问题，导致系统异常。",
      "注意事项": "修复时必须全面检查上下文中的相关表述，优先根据用户提供的参考句式和术语进行统一调整，避免仅关注局部语法而忽略整体表述一致性；特别注意用户标注的\"非本次修改引入\"提示，需精准识别需要保持原样的内容。"
    },
    {
      "defect_id": 452132,
      "sentence": "获取系统能力管理服务失败。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 333,
      "context": "{\"328\":\"\",\"329\":\"Get system manager service failed.\",\"330\":\"\",\"331\":\"**错误描述**\",\"332\":\"\",\"333\":\"获取系统能力管理服务失败。\",\"334\":\"\",\"335\":\"**可能原因**\",\"336\":\"\",\"337\":\"系统业务内部执行异常。\",\"338\":\"\"}",
      "用户拒绝的修改": "获取系统能力管理服务失败，系统会报告此错误码。",
      "注意事项": "修复时必须严格核对上下文现有术语使用情况（如\"报\"与\"报告\"），仅针对当前问题调整表达方式，禁止扩大修改范围至其他未变更内容。"
    },
    {
      "defect_id": 452730,
      "sentence": "LiveFormExtensionAbility界面内容对象创建后调用。",
      "reference_sentence": "LiveFormExtensionAbility界面内容相关信息。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"### onLiveFormCreate\",\"34\":\"\",\"35\":\"onLiveFormCreate(liveFormInfo: LiveFormInfo, session: UIExtensionContentSession): void\",\"36\":\"\",\"37\":\"LiveFormExtensionAbility界面内容对象创建后调用。\",\"38\":\"\",\"39\":\"**模型约束：** 此接口仅可在Stage模型下使用。\",\"40\":\"\",\"41\":\"**系统能力**：SystemCapability.Ability.Form\",\"42\":\"\"}",
      "用户拒绝的修改": "LiveFormExtensionAbility界面内容相关信息创建后调用。",
      "注意事项": "修复术语一致性时必须严格验证上下文术语定义及使用场景，避免混淆不同概念；同时需全局检查文档中相关术语的引用情况，确保修改符合整体一致性而非局部片段。"
    },
    {
      "defect_id": 452746,
      "sentence": "取值大于0，单位vp。",
      "reference_sentence": "卡片圆角半径信息。取值大于0，单位vp。",
      "line_num": 112,
      "context": "{\"107\":\"\",\"108\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"109\":\"| ------ | ------ | ---- | ---- | -------- |\",\"110\":\"| formId | string | 否 | 否 | 卡片id。 |\",\"111\":\"| rect | [formInfo.Rect](js-apis-app-form-formInfo.md#rect20) | 否 | 否 | 卡片位置和大小信息。 |\",\"112\":\"| borderRadius | number | 否 | 否 | 卡片圆角半径信息。取值大于0，单位vp。 |\",\"113\":\"\",\"114\":\"### 禁用API\",\"115\":\"- [@ohos.ability.featureAbility (FeatureAbility模块)](../apis-ability-kit/js-apis-ability-featureAbility.md)\",\"116\":\"- [@ohos.ability.particleAbility (ParticleAbility模块)](../apis-ability-kit/js-apis-ability-particleAbility.md)\",\"117\":\"- [@ohos.account.appAccount (应用账号管理)](../apis-basic-services-kit/js-apis-appAccount.md)\"}",
      "用户拒绝的修改": "取值大于0，单位为vp。",
      "注意事项": "修复时应严格检查上下文已有表述格式，仅在必要范围内调整不一致内容，避免对文档中已存在的规范表述进行无谓修改；优先保持原文格式统一性，除非用户明确要求否则不擅自添加/删除修饰词。"
    },
    {
      "defect_id": 452127,
      "sentence": "卡片不支持调用当前接口，系统会报此错误码。",
      "reference_sentence": "系统内为执行当前请求时发生内部错误，系统会报此错误码。",
      "line_num": 216,
      "context": "{\"211\":\"\",\"212\":\"The form can not support this operation.\",\"213\":\"\",\"214\":\"**错误描述**\",\"215\":\"\",\"216\":\"卡片不支持调用当前接口，系统会报此错误码。\",\"217\":\"\",\"218\":\"**可能原因**\",\"219\":\"\",\"220\":\"普通卡片发起互动卡片动效请求，或者当前互动卡片配置错误。\",\"221\":\"\"}",
      "用户拒绝的修改": "卡片不支持调用当前接口，系统会报告此错误码。",
      "注意事项": "修改前必须严格核对上下文用词一致性，确认修改范围仅限于实际存在矛盾的表述；同时需验证目标修改内容是否属于当前任务范畴，避免对已统一表述进行不必要修改。"
    },
    {
      "defect_id": 452758,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 182,
      "context": "{\"177\":\"- [@ohos.application.formHost (formHost)(系统接口)](../apis-form-kit/js-apis-application-formHost-sys.md)\",\"178\":\"- [@ohos.bundle.bundleMonitor (bundleMonitor模块)(系统接口)](../apis-ability-kit/js-apis-bundleMonitor-sys.md)\",\"179\":\"- [@ohos.bundle.distributedBundleManager (distributedBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-distributedBundleManager-sys.md)\",\"180\":\"- [@ohos.bundle.freeInstall (freeInstall模块)(系统接口)](../apis-ability-kit/js-apis-freeInstall-sys.md)\",\"181\":\"- [@ohos.bundle.innerBundleManager (innerBundleManager模块)(系统接口)](../apis-ability-kit/js-apis-Bundle-InnerBundleManager-sys.md)\",\"182\":\"- [@ohos.bundle.installer (installer模块)(系统接口)](../apis-ability-kit/js-apis-installer-sys.md)\",\"183\":\"- [@ohos.distributedBundle (分布式包管理)(系统接口)](../apis-ability-kit/js-apis-Bundle-distributedBundle-sys.md)\",\"184\":\"- [@ohos.distributedMissionManager (分布式任务管理)(系统接口)](../apis-ability-kit/js-apis-distributedMissionManager-sys.md)\",\"185\":\"- [@ohos.enterprise.dateTimeManager （系统时间管理）(系统接口)](../apis-mdm-kit/js-apis-enterprise-dateTimeManager-sys.md)\",\"186\":\"- [@ohos.filemanagement.userFileManager (用户数据管理)(系统接口)](../apis-core-file-kit/js-apis-userFileManager-sys.md)\",\"187\":\"- [@ohos.notificationSubscribe (NotificationSubscribe模块)(系统接口)](../apis-notification-kit/js-apis-notificationSubscribe-sys.md)\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "在修复术语一致性时需优先分析上下文标注结构，避免重复添加冗余括号，应严格按照参考格式\"模块中文名(系统接口)\"在对应位置统一标注，而非简单重复术语本身。"
    },
    {
      "defect_id": 452767,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 191,
      "context": "{\"186\":\"- [@ohos.filemanagement.userFileManager (用户数据管理)(系统接口)](../apis-core-file-kit/js-apis-userFileManager-sys.md)\",\"187\":\"- [@ohos.notificationSubscribe (NotificationSubscribe模块)(系统接口)](../apis-notification-kit/js-apis-notificationSubscribe-sys.md)\",\"188\":\"- [@ohos.privacyManager (隐私管理)(系统接口)](../apis-ability-kit/js-apis-privacyManager-sys.md)\",\"189\":\"- [@ohos.resourceschedule.usageStatistics (设备使用信息统计)(系统接口)](../apis-backgroundtasks-kit/js-apis-resourceschedule-deviceUsageStatistics-sys.md)\",\"190\":\"- [@ohos.update (升级)(系统接口)](../apis-basic-services-kit/js-apis-update-sys.md)\",\"191\":\"- [@ohos.userIAM.faceAuth (人脸认证)(系统接口)](../apis-user-authentication-kit/js-apis-useriam-faceauth-sys.md)<!--DelEnd-->\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "修复时必须严格遵循上下文已有的\"（模块名称)(系统接口)\"括号嵌套结构，避免在术语后单独添加冗余括号；需通过交叉验证相邻条目的格式特征，确保修改后的表达与上下文排版模式完全匹配。"
    },
    {
      "defect_id": 452766,
      "sentence": "系统接口",
      "reference_sentence": "系统接口",
      "line_num": 190,
      "context": "{\"185\":\"- [@ohos.enterprise.dateTimeManager （系统时间管理）(系统接口)](../apis-mdm-kit/js-apis-enterprise-dateTimeManager-sys.md)\",\"186\":\"- [@ohos.filemanagement.userFileManager (用户数据管理)(系统接口)](../apis-core-file-kit/js-apis-userFileManager-sys.md)\",\"187\":\"- [@ohos.notificationSubscribe (NotificationSubscribe模块)(系统接口)](../apis-notification-kit/js-apis-notificationSubscribe-sys.md)\",\"188\":\"- [@ohos.privacyManager (隐私管理)(系统接口)](../apis-ability-kit/js-apis-privacyManager-sys.md)\",\"189\":\"- [@ohos.resourceschedule.usageStatistics (设备使用信息统计)(系统接口)](../apis-backgroundtasks-kit/js-apis-resourceschedule-deviceUsageStatistics-sys.md)\",\"190\":\"- [@ohos.update (升级)(系统接口)](../apis-basic-services-kit/js-apis-update-sys.md)\",\"191\":\"- [@ohos.userIAM.faceAuth (人脸认证)(系统接口)](../apis-user-authentication-kit/js-apis-useriam-faceauth-sys.md)<!--DelEnd-->\"}",
      "用户拒绝的修改": "系统接口（系统接口）",
      "注意事项": "修复时应严格匹配上下文已有的括号位置和层级结构，确保补充说明统一置于模块功能描述后的独立括号内（例如“（系统时间管理）(系统接口)”），避免在术语后直接重复添加冗余括号导致格式错乱。"
    },
    {
      "defect_id": 452731,
      "sentence": "LiveFormExtensionAbility生命周期回调，在销毁时回调，执行资源清理等操作。",
      "reference_sentence": "LiveFormExtensionAbility界面内容相关信息创建后调用。",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"### onLiveFormDestroy\",\"68\":\"\",\"69\":\"onLiveFormDestroy(liveFormInfo: LiveFormInfo): void\",\"70\":\"\",\"71\":\"LiveFormExtensionAbility生命周期回调，在销毁时回调，执行资源清理等操作。\",\"72\":\"\",\"73\":\"**模型约束：** 此接口仅可在Stage模型下使用。\",\"74\":\"\",\"75\":\"**系统能力**：SystemCapability.Ability.Form\",\"76\":\"\"}",
      "用户拒绝的修改": "LiveFormExtensionAbility生命周期回调在销毁时调用，执行资源清理等操作。",
      "注意事项": "严格区分技术术语的上下文适用性（如\"回调\"用于生命周期事件，\"调用\"用于主动操作），修复时需确保修改范围仅涉及当前语义冲突点，避免改动原本正确的技术表述。"
    },
    {
      "defect_id": 452811,
      "sentence": "获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。",
      "reference_sentence": "获取设备上当前应用程序的卡片信息，使用callback异步回调。",
      "line_num": 290,
      "context": "{\"285\":\"```\",\"286\":\"## formProvider.getFormsInfo\",\"287\":\"\",\"288\":\"getFormsInfo(filter: formInfo.FormInfoFilter, callback: AsyncCallback&lt;Array&lt;formInfo.FormInfo&gt;&gt;): void\",\"289\":\"\",\"290\":\"获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。\",\"291\":\"\",\"292\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"293\":\"\",\"294\":\"**系统能力：** SystemCapability.Ability.Form\",\"295\":\"\"}",
      "用户拒绝的修改": "获取设备上当前应用程序的卡片信息，使用callback异步回调。",
      "注意事项": "在修复语言表达一致性时需严格核对上下文参数定义和技术背景，避免因过度简化删除关键功能描述；优先保留与接口参数直接相关的技术细节，确保文档准确性和功能完整性。"
    },
    {
      "defect_id": 452844,
      "sentence": "Capability not supported.function cancelOverflow can not work correctly due to limited device capabilities.",
      "reference_sentence": "Capability not supported.function requestOverflow can not work correctly due to limited device capabilities.",
      "line_num": 694,
      "context": "{\"689\":\"\",\"690\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"691\":\"\",\"692\":\"| 错误码ID | 错误信息 |\",\"693\":\"| -------- | -------- |\",\"694\":\"| 801 | Capability not supported.function cancelOverflow can not work correctly due to limited device capabilities. |\",\"695\":\"| 16500050 | IPC connection error. |\",\"696\":\"| 16500060 | Service connection error. |\",\"697\":\"| 16500100 | Failed to obtain the configuration information. |\",\"698\":\"| 16501000 | An internal functional error occurred. |\",\"699\":\"| 16501001 | The ID of the form to be operated does not exist. |\"}",
      "用户拒绝的修改": "Capability not supported. function cancelOverflow can not work correctly due to limited device capabilities.",
      "注意事项": "修复时必须严格核对技术术语与上下文一致性（如函数名`requestOverflow`与`cancelOverflow`不可混淆），避免仅修正格式而忽略核心概念准确性；同时需交叉验证参考句子的关键参数，确保逻辑与事实匹配。"
    },
    {
      "defect_id": 452795,
      "sentence": "| Promise\\<void> | 无返回结果的Promise对象。 |",
      "reference_sentence": "| AsyncCallback\\<void> | 回调函数。 |",
      "line_num": 202,
      "context": "{\"197\":\"\",\"198\":\"**返回值：**\",\"199\":\"\",\"200\":\"| 类型           | 说明                                |\",\"201\":\"| -------------- | ----------------------------------- |\",\"202\":\"| Promise\\\\<void> | 无返回结果的Promise对象。 |\",\"203\":\"\",\"204\":\"**错误码：**\",\"205\":\"\",\"206\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"207\":\"\"}",
      "用户拒绝的修改": "| AsyncCallback\\<void> | 回调函数。 |",
      "注意事项": "修改前需全面检查上下文所有相关术语的使用情况，确保修改后的术语与文档整体表述完全一致；特别注意区分历史遗留问题和本次修改范围，避免将既有正确表述误判为错误进行修复。"
    },
    {
      "defect_id": 452792,
      "sentence": "## formProvider.updateForm",
      "reference_sentence": "## formProvider.updateFormupdateForm(formId: string, formBindingData: formBindingData.FormBindingData,callback: AsyncCallback&lt;void&gt;): void",
      "line_num": 181,
      "context": "{\"176\":\"} catch (error) {\",\"177\":\"  console.error(`catch error, code: ${(error as BusinessError).code}, message: ${(error as BusinessError).message})`);\",\"178\":\"}\",\"179\":\"```\",\"180\":\"\",\"181\":\"## formProvider.updateForm\",\"182\":\"\",\"183\":\"updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;\",\"184\":\"\",\"185\":\"更新指定的卡片，使用Promise异步回调。\",\"186\":\"\"}",
      "用户拒绝的修改": "## formProvider.updateFormupdateForm",
      "注意事项": "修复前必须严格核对上下文和参考句子的实际使用场景，确保修改仅针对当前问题而非历史正确内容，避免过度修正或误判命名一致性。"
    },
    {
      "defect_id": 452790,
      "sentence": "请求更新的卡片标识。",
      "reference_sentence": "卡片标识。",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"**参数：**\",\"135\":\"\",\"136\":\"| 参数名 | 类型                                                                    | 必填 | 说明             |\",\"137\":\"| ------ | ---------------------------------------------------------------------- | ---- | ---------------- |\",\"138\":\"| formId | string                                                                 | 是   | 请求更新的卡片标识。 |\",\"139\":\"| formBindingData | [formBindingData.FormBindingData](js-apis-app-form-formBindingData.md#formbindingdata) | 是   | 用于更新的数据。    |\",\"140\":\"| callback | AsyncCallback&lt;void&gt; | 是 | 回调函数。 |\",\"141\":\"\",\"142\":\"**错误码：**\",\"143\":\"\"}",
      "用户拒绝的修改": "卡片标识。",
      "注意事项": "在修复术语不一致时，需先全局检索文档确认该术语是否已在其他位置统一使用，避免将原有正确表述误判为错误；同时需结合修改记录验证问题是否属于本次新增内容，防止过度修正历史版本。"
    },
    {
      "defect_id": 452793,
      "sentence": "updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;",
      "reference_sentence": "formProvider.updateFormupdateForm(formId: string, formBindingData: formBindingData.FormBindingData,callback: AsyncCallback&lt;void&gt;): void",
      "line_num": 183,
      "context": "{\"178\":\"}\",\"179\":\"```\",\"180\":\"\",\"181\":\"## formProvider.updateForm\",\"182\":\"\",\"183\":\"updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;\",\"184\":\"\",\"185\":\"更新指定的卡片，使用Promise异步回调。\",\"186\":\"\",\"187\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"188\":\"\"}",
      "用户拒绝的修改": "formProvider.updateFormupdateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;",
      "注意事项": "修复方法签名时必须严格匹配上下文中的命名和参数结构，避免引入重复方法名或多余字符；修改前需验证问题是否由当前变更引起，防止误改无关内容。"
    },
    {
      "defect_id": 452794,
      "sentence": "更新指定的卡片，使用Promise异步回调。",
      "reference_sentence": "更新指定的卡片，使用callback异步回调。",
      "line_num": 185,
      "context": "{\"180\":\"\",\"181\":\"## formProvider.updateForm\",\"182\":\"\",\"183\":\"updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;\",\"184\":\"\",\"185\":\"更新指定的卡片，使用Promise异步回调。\",\"186\":\"\",\"187\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"188\":\"\",\"189\":\"**系统能力：** SystemCapability.Ability.Form\",\"190\":\"\"}",
      "用户拒绝的修改": "更新指定的卡片，使用callback异步回调。",
      "注意事项": "修复时必须全面检查文档所有相关上下文（包括参数定义、接口说明等），优先保持与当前API版本核心术语的一致性，若发现历史遗留术语冲突应主动标注说明而非局部修改。"
    },
    {
      "defect_id": 452813,
      "sentence": "Promise对象。返回查询到符合条件的卡片信息。",
      "reference_sentence": "返回查询到的卡片信息。",
      "line_num": 357,
      "context": "{\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\",\"355\":\"| 类型          | 说明                                |\",\"356\":\"| :------------ | :---------------------------------- |\",\"357\":\"| Promise&lt;Array&lt;[formInfo.FormInfo](js-apis-app-form-formInfo.md)&gt;&gt; | Promise对象。返回查询到符合条件的卡片信息。 |\",\"358\":\"\",\"359\":\"**错误码：**\",\"360\":\"\",\"361\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"362\":\"\"}",
      "用户拒绝的修改": "Promise对象。返回查询到的卡片信息。",
      "注意事项": "修复前必须严格验证问题是否由当前上下文引入，避免修改历史遗留问题；同时需核对文档全局表述一致性，确保修改内容与前后文逻辑及术语使用完全匹配。"
    },
    {
      "defect_id": 452830,
      "sentence": "获取设备上当前应用程序已经加桌的指定卡片信息，使用Promise异步回调。",
      "reference_sentence": "获取设备上当前应用程序所有已经加桌的卡片信息，使用Promise异步回调。",
      "line_num": 510,
      "context": "{\"505\":\"\",\"506\":\"## formProvider.getPublishedFormInfoById<sup>18+</sup>\",\"507\":\"\",\"508\":\"getPublishedFormInfoById(formId: string): Promise&lt;formInfo.FormInfo&gt;\",\"509\":\"\",\"510\":\"获取设备上当前应用程序已经加桌的指定卡片信息，使用Promise异步回调。\",\"511\":\"\",\"512\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"513\":\"\",\"514\":\"**系统能力：** SystemCapability.Ability.Form\",\"515\":\"\"}",
      "用户拒绝的修改": "获取设备上当前应用程序已经加桌的卡片信息，使用Promise异步回调。",
      "注意事项": "在修复表述一致性时需严格保留原文关键限定词（如\"指定\"），避免因过度简化丢失重要语义信息；修改前必须核对上下文参数定义（如formId参数与\"指定\"的对应关系）和参考句式结构，确保术语使用与API描述逻辑完全一致。"
    },
    {
      "defect_id": 452812,
      "sentence": "返回查询到符合条件的卡片信息。",
      "reference_sentence": "返回查询到的卡片信息。",
      "line_num": 301,
      "context": "{\"296\":\"**参数：**\",\"297\":\"\",\"298\":\"| 参数名 | 类型    | 必填 | 说明    |\",\"299\":\"| ------ | ------ | ---- | ------- |\",\"300\":\"| filter | [formInfo.FormInfoFilter](js-apis-app-form-formInfo.md#forminfofilter) | 是 | 卡片信息过滤器。 |\",\"301\":\"| callback | AsyncCallback&lt;Array&lt;[formInfo.FormInfo](js-apis-app-form-formInfo.md)&gt;&gt; | 是 | 回调函数。返回查询到符合条件的卡片信息。 |\",\"302\":\"\",\"303\":\"**错误码：**\",\"304\":\"\",\"305\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"306\":\"\"}",
      "用户拒绝的修改": "返回查询到的卡片信息。",
      "注意事项": "修复时应严格验证问题句子的关键描述（如“符合条件的”）是否在上下文中有明确对应，避免因参数或功能隐含逻辑而误删必要信息；同时需确认修改范围仅限于当前问题点，防止引入无关变更。"
    },
    {
      "defect_id": 453017,
      "sentence": "1 x 2 form。",
      "reference_sentence": "1 x 2 form。",
      "line_num": 136,
      "context": "{\"131\":\"\",\"132\":\"**系统能力：** SystemCapability.Ability.Form\",\"133\":\"\",\"134\":\"| 名称        | 值   | 说明         |\",\"135\":\"| ----------- | ---- | ------------ |\",\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "1 x 2 服务卡片。",
      "注意事项": "修复前需全面检查文档中所有相关实例，确保统一修改所有历史遗留的不一致表述，避免局部修正导致上下文术语不统一；同时需确认修改范围是否属于当前任务要求，防止越界修改未被授权的历史内容。"
    },
    {
      "defect_id": 453023,
      "sentence": "6 x 4 form。",
      "reference_sentence": "6 x 4 form。",
      "line_num": 142,
      "context": "{\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"145\":\"\",\"146\":\"## FormShape<sup>12+</sup> \",\"147\":\"\"}",
      "用户拒绝的修改": "6 x 4 服务卡片。",
      "注意事项": "修复术语不一致时必须全面检查上下文中的所有相关实例，确认修改范围是否涉及历史遗留问题，若上下文存在多个相同术语但未被要求统一修改的情况，应优先保持现有表述一致性而非强制替换。"
    },
    {
      "defect_id": 452990,
      "sentence": "卡片状态信息。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 78,
      "context": "{\"73\":\"| MODE_DARK    | 0   | 表示暗色。   |\",\"74\":\"| MODE_LIGHT     | 1   | 表示亮色。   |\",\"75\":\"\",\"76\":\"## FormStateInfo\",\"77\":\"\",\"78\":\"卡片状态信息。\",\"79\":\"\",\"80\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"81\":\"\",\"82\":\"**系统能力：** SystemCapability.Ability.Form\",\"83\":\"\"}",
      "用户拒绝的修改": "卡片状态信息。",
      "注意事项": "修复时应优先确认上下文中的参考句式结构（如“## 标题+描述性语句”），确保修改后的句子不仅语法一致，还需符合章节层级和语义完整性；同时需验证修改点是否为当前版本实际需调整的内容，避免误判历史遗留问题。"
    },
    {
      "defect_id": 453018,
      "sentence": "2 x 2 form。",
      "reference_sentence": "2 x 2 form。",
      "line_num": 137,
      "context": "{\"132\":\"**系统能力：** SystemCapability.Ability.Form\",\"133\":\"\",\"134\":\"| 名称        | 值   | 说明         |\",\"135\":\"| ----------- | ---- | ------------ |\",\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "2 x 2 服务卡片。",
      "注意事项": "修复术语不一致时需全面检查上下文所有相关实例，确保全局统一性而非局部替换；同时确认修改范围是否属于当前任务目标，避免引入超出本次修订需求的变更。"
    },
    {
      "defect_id": 452995,
      "sentence": "## FormDimension",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 115,
      "context": "{\"110\":\"| ----------- | ---- | ------------ |\",\"111\":\"| IDENTITY_KEY     | 'ohos.extra.param.key.form_identity'    | 卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"117\":\"| TEMPORARY_KEY          | 'ohos.extra.param.key.form_temporary'   | 临时卡片。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"118\":\"| ABILITY_NAME_KEY   | 'ohos.extra.param.key.ability_name'   | ability名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"119\":\"| BUNDLE_NAME_KEY    | 'ohos.extra.param.key.bundle_name'   | Bundle名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"120\":\"| LAUNCH_REASON_KEY<sup>10+</sup>    | 'ohos.extra.param.key.form_launch_reason'   | 卡片创建原因。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "## FormDimension枚举",
      "注意事项": "修复时应严格验证上下文中的实际使用模式，避免基于单一参考案例过度泛化；优先保持现有结构的稳定性，仅在确认属于当前修改范围且存在明确不一致时进行调整。"
    },
    {
      "defect_id": 452997,
      "sentence": "| eTS     | 2    | 卡片类型为ArkTS。 |",
      "reference_sentence": "| JS      | 1    | 卡片类型为JS。   |",
      "line_num": 58,
      "context": "{\"53\":\"**系统能力：** SystemCapability.Ability.Form\",\"54\":\"\",\"55\":\"| 名称        | 值   | 说明         |\",\"56\":\"| ----------- | ---- | ------------ |\",\"57\":\"| JS      | 1    | 卡片类型为JS。   |\",\"58\":\"| eTS     | 2    | 卡片类型为ArkTS。 |\",\"59\":\"\",\"60\":\"## ColorMode<sup>(deprecated)</sup>\",\"61\":\"\",\"62\":\"从API version 11开始支持，从API version 20开始废弃，卡片主题样式统一跟随系统的颜色模式。\",\"63\":\"\"}",
      "用户拒绝的修改": "| ArkTS     | 2    | 卡片类型为ArkTS。 |",
      "注意事项": "修复术语前需确认修改范围是否属于当前任务，避免修改历史遗留问题；同时应全面检查文档中所有相关术语的一致性，确保不遗漏其他潜在冲突项。"
    },
    {
      "defect_id": 452987,
      "sentence": "## ColorMode<sup>(deprecated)</sup>",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 60,
      "context": "{\"55\":\"| 名称        | 值   | 说明         |\",\"56\":\"| ----------- | ---- | ------------ |\",\"57\":\"| JS      | 1    | 卡片类型为JS。   |\",\"58\":\"| eTS     | 2    | 卡片类型为ArkTS。 |\",\"59\":\"\",\"60\":\"## ColorMode<sup>(deprecated)</sup>\",\"61\":\"\",\"62\":\"从API version 11开始支持，从API version 20开始废弃，卡片主题样式统一跟随系统的颜色模式。\",\"63\":\"\",\"64\":\"卡片支持的颜色模式枚举。\",\"65\":\"\"}",
      "用户拒绝的修改": "## ColorMode枚举<sup>(deprecated)</sup>",
      "注意事项": "修复标题一致性时应严格限定修改范围，仅调整当前问题上下文明确涉及的格式问题，避免引入未在参考示例中出现的新增修饰词（如\"枚举\"），确保修改不涉及历史遗留内容或无关上下文。"
    },
    {
      "defect_id": 452956,
      "sentence": "卡片描述id。",
      "reference_sentence": "卡片描述id。",
      "line_num": 30,
      "context": "{\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片描述ID。",
      "注意事项": "修复术语不一致时需优先检查上下文已有用法（如\"descriptionId\"中的小写\"id\"），确保修改后的术语与文档现有格式完全统一，避免仅根据局部信息机械调整。"
    },
    {
      "defect_id": 453020,
      "sentence": "4 x 4 form。",
      "reference_sentence": "4 x 4 form。",
      "line_num": 139,
      "context": "{\"134\":\"| 名称        | 值   | 说明         |\",\"135\":\"| ----------- | ---- | ------------ |\",\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\"}",
      "用户拒绝的修改": "4 x 4 服务卡片。",
      "注意事项": "修复术语不一致时必须全局检查文档中所有相关实例，确保统一修改；修改前需确认问题是否属于当前修订范围，避免修复非目标内容。"
    },
    {
      "defect_id": 453025,
      "sentence": "3 x 3 form。",
      "reference_sentence": "3 x 3 form。",
      "line_num": 144,
      "context": "{\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"145\":\"\",\"146\":\"## FormShape<sup>12+</sup> \",\"147\":\"\",\"148\":\"定义卡片形状枚举。\",\"149\":\"\"}",
      "用户拒绝的修改": "3 x 3 服务卡片。",
      "注意事项": "修复术语不一致时必须先全面检查上下文中的现有用法，确保修改后的术语与相邻条目及文档整体保持统一，避免因局部修改导致上下文矛盾；同时需明确区分历史遗留问题与当前修改范围，仅处理本次需修复的内容。"
    },
    {
      "defect_id": 452994,
      "sentence": "卡片参数枚举。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 105,
      "context": "{\"100\":\"| DEFAULT     | 0   | 表示默认状态。   |\",\"101\":\"| READY      | 1   | 表示就绪状态。   |\",\"102\":\"\",\"103\":\"## FormParam\",\"104\":\"\",\"105\":\"卡片参数枚举。\",\"106\":\"\",\"107\":\"**系统能力：** SystemCapability.Ability.Form\",\"108\":\"\",\"109\":\"| 名称        | 值   | 说明         |\",\"110\":\"| ----------- | ---- | ------------ |\"}",
      "用户拒绝的修改": "卡片参数枚举。",
      "注意事项": "修复前需确认问题句段是否属于当前编辑范围，避免修改历史遗留问题；句式调整应结合上下文判断章节属性，确保标题型语句与描述型语句的分类准确性。"
    },
    {
      "defect_id": 452992,
      "sentence": "卡片状态枚举。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 91,
      "context": "{\"86\":\"| formState  | [FormState](#formstate)               | 是    | 否     | 卡片状态。                          |\",\"87\":\"| want  | [Want](../apis-ability-kit/js-apis-app-ability-want.md)         | 是    | 否     | Want文本内容。    |\",\"88\":\"\",\"89\":\"## FormState\",\"90\":\"\",\"91\":\"卡片状态枚举。\",\"92\":\"\",\"93\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"94\":\"\",\"95\":\"**系统能力：** SystemCapability.Ability.Form\",\"96\":\"\"}",
      "用户拒绝的修改": "卡片状态枚举。",
      "注意事项": "修复前需严格验证问题是否属于当前修改范围，避免修改历史遗留问题；统一句式时应结合上下文判断目标句是否需要调整为描述性语句，防止机械套用参考句式破坏原有语义结构。"
    },
    {
      "defect_id": 453024,
      "sentence": "2 x 3 form。",
      "reference_sentence": "2 x 3 form。",
      "line_num": 143,
      "context": "{\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"145\":\"\",\"146\":\"## FormShape<sup>12+</sup> \",\"147\":\"\",\"148\":\"定义卡片形状枚举。\"}",
      "用户拒绝的修改": "2 x 3 服务卡片。",
      "注意事项": "修复前必须全面检查上下文所有相同术语的使用情况，确认是否为系统性术语不一致；若问题属于历史遗留错误，需与用户确认是否需要进行批量统一修改而非单独修复。"
    },
    {
      "defect_id": 452996,
      "sentence": "支持的卡片规格枚举。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 117,
      "context": "{\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"117\":\"| TEMPORARY_KEY          | 'ohos.extra.param.key.form_temporary'   | 临时卡片。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"118\":\"| ABILITY_NAME_KEY   | 'ohos.extra.param.key.ability_name'   | ability名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"119\":\"| BUNDLE_NAME_KEY    | 'ohos.extra.param.key.bundle_name'   | Bundle名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"120\":\"| LAUNCH_REASON_KEY<sup>10+</sup>    | 'ohos.extra.param.key.form_launch_reason'   | 卡片创建原因。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"121\":\"| PARAM_FORM_CUSTOMIZE_KEY<sup>10+</sup>    | 'ohos.extra.param.key.form_customize'   | 自定义数据。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"122\":\"| FORM_RENDERING_MODE_KEY<sup>11+</sup>    | 'ohos.extra.param.key.form_rendering_mode'   | 卡片渲染模式。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "支持的卡片规格枚举。",
      "注意事项": "修复时应优先核对上下文表达模式，确保句式与相邻条目保持完全一致；需明确区分新增修改与历史内容，避免对已合规的语句进行不必要改动。"
    },
    {
      "defect_id": 453022,
      "sentence": "1 x 1 form。",
      "reference_sentence": "1 x 1 form。",
      "line_num": 141,
      "context": "{\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"145\":\"\",\"146\":\"## FormShape<sup>12+</sup> \"}",
      "用户拒绝的修改": "1 x 1 服务卡片。",
      "注意事项": "在替换术语前必须验证上下文统一性，若同一文档中存在多个相同表述且未被修改的实例，应保留原始表述或进行全局统一调整，避免局部修改导致术语混用。"
    },
    {
      "defect_id": 452986,
      "sentence": "支持的卡片类型枚举。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 49,
      "context": "{\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\",\"48\":\"\",\"49\":\"支持的卡片类型枚举。\",\"50\":\"\",\"51\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"52\":\"\",\"53\":\"**系统能力：** SystemCapability.Ability.Form\",\"54\":\"\"}",
      "用户拒绝的修改": "支持的卡片类型枚举。",
      "注意事项": "修复时应优先检查上下文格式规范，确保标题层级（如##前缀）和命名结构（如\"FormInfo卡片配置信息\"）统一，避免仅修改句式而忽略文档结构一致性；需区分内容修正与格式调整，若原句为标题需补全格式而非单纯改写描述。"
    },
    {
      "defect_id": 452958,
      "sentence": "卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。",
      "reference_sentence": "卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。",
      "line_num": 38,
      "context": "{\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片配置Ability。指定长按卡片弹出的选择框内，编辑选项所对应的Ability。",
      "注意事项": "修改前需确认问题是否属于当前上下文引入的不一致，优先保持原有术语格式；若需统一术语，应全局检查所有相关字段并确保用户反馈中的参考用法与修改建议完全匹配。"
    },
    {
      "defect_id": 453021,
      "sentence": "2 x 1 form。",
      "reference_sentence": "2 x 1 form。",
      "line_num": 140,
      "context": "{\"135\":\"| ----------- | ---- | ------------ |\",\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"144\":\"| DIMENSION_3_3<sup>18+<sup>      | 9   | 3 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\",\"145\":\"\"}",
      "用户拒绝的修改": "2 x 1 服务卡片。",
      "注意事项": "修复前必须全面检查上下文中的术语使用频率和一致性模式，若问题术语在上下文中被广泛沿用且未被术语表覆盖，应优先保持现有表述统一性而非机械替换；同时需结合版本注释判断术语变更时效性，避免将历史遗留问题误判为当前修改范围。"
    },
    {
      "defect_id": 452991,
      "sentence": "## FormState",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 89,
      "context": "{\"84\":\"| 名称        | 类型                 | 可读    | 可写    | 说明                                                         |\",\"85\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"86\":\"| formState  | [FormState](#formstate)               | 是    | 否     | 卡片状态。                          |\",\"87\":\"| want  | [Want](../apis-ability-kit/js-apis-app-ability-want.md)         | 是    | 否     | Want文本内容。    |\",\"88\":\"\",\"89\":\"## FormState\",\"90\":\"\",\"91\":\"卡片状态枚举。\",\"92\":\"\",\"93\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"94\":\"\"}",
      "用户拒绝的修改": "## FormState枚举",
      "注意事项": "修复时应严格验证上下文标题风格是否真正存在不一致，避免仅基于局部匹配误判；优先确认修改范围是否属于当前任务目标，防止引入无关的历史遗留问题。"
    },
    {
      "defect_id": 452988,
      "sentence": "卡片支持的颜色模式枚举。\r",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 64,
      "context": "{\"59\":\"\",\"60\":\"## ColorMode<sup>(deprecated)</sup>\",\"61\":\"\",\"62\":\"从API version 11开始支持，从API version 20开始废弃，卡片主题样式统一跟随系统的颜色模式。\",\"63\":\"\",\"64\":\"卡片支持的颜色模式枚举。\",\"65\":\"\",\"66\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"67\":\"\",\"68\":\"**系统能力：** SystemCapability.Ability.Form\",\"69\":\"\"}",
      "用户拒绝的修改": "卡片支持的颜色模式枚举。",
      "注意事项": "修复前需验证问题是否属于当前修改范围，避免对历史遗留问题进行无关修正；确保句式统一调整与上下文修改意图严格相关，优先处理用户明确指出的不一致问题。"
    },
    {
      "defect_id": 453019,
      "sentence": "2 x 4 form。",
      "reference_sentence": "2 x 4 form。",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"| 名称        | 值   | 说明         |\",\"135\":\"| ----------- | ---- | ------------ |\",\"136\":\"| Dimension_1_2      | 1   | 1 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"137\":\"| Dimension_2_2      | 2   | 2 x 2 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"138\":\"| Dimension_2_4      | 3   | 2 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"139\":\"| Dimension_4_4      | 4   | 4 x 4 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"140\":\"| Dimension_2_1      | 5   | 2 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"141\":\"| DIMENSION_1_1<sup>11+<sup>      | 6   | 1 x 1 form。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"142\":\"| DIMENSION_6_4<sup>12+<sup>      | 7   | 6 x 4 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"143\":\"| DIMENSION_2_3<sup>18+<sup>      | 8   | 2 x 3 form。<br>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用，为穿戴设备使用。|\"}",
      "用户拒绝的修改": "2 x 4 服务卡片。",
      "注意事项": "修复术语一致性时必须全面扫描上下文所有相关实例，确保批量修改避免局部遗漏；同时需确认术语变更是否属于当前修订范围，避免擅自扩大修改边界破坏历史记录。"
    },
    {
      "defect_id": 452993,
      "sentence": "## FormParam",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 103,
      "context": "{\"98\":\"| ----------- | ---- | ------------ |\",\"99\":\"| UNKNOWN    | -1    | 表示未知状态。   |\",\"100\":\"| DEFAULT     | 0   | 表示默认状态。   |\",\"101\":\"| READY      | 1   | 表示就绪状态。   |\",\"102\":\"\",\"103\":\"## FormParam\",\"104\":\"\",\"105\":\"卡片参数枚举。\",\"106\":\"\",\"107\":\"**系统能力：** SystemCapability.Ability.Form\",\"108\":\"\"}",
      "用户拒绝的修改": "## FormParam枚举",
      "注意事项": "修复时需严格限定修改范围为当前明确不一致的标题，避免基于假设扩展修改内容；必须验证参考句子的实际格式是否构成有效规范，而非自行推断统一规则。"
    },
    {
      "defect_id": 453026,
      "sentence": "方形 form。",
      "reference_sentence": "方形 form。",
      "line_num": 154,
      "context": "{\"149\":\"\",\"150\":\"**系统能力：** SystemCapability.Ability.Form\",\"151\":\"\",\"152\":\"| 名称        | 值   | 说明         |\",\"153\":\"| ----------- | ---- | ------------ |\",\"154\":\"| RECT        | 1   | 方形 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"155\":\"| CIRCLE      | 2   | 圆形 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"156\":\"\",\"157\":\"## FormInfoFilter\",\"158\":\"\",\"159\":\"卡片信息过滤器，仅将符合过滤器内要求的卡片信息返回。\"}",
      "用户拒绝的修改": "方形 服务卡片。",
      "注意事项": "修复术语不一致时必须先确认上下文中的术语实际使用场景，若问题句子中的术语属于代码/系统能力名称等固定表述（如\"Form\"），应保留原始术语而非强制替换为通用译名，同时需检查整个段落是否存在统一表述要求（如表格内所有\"form\"是否都需保持英文）。"
    },
    {
      "defect_id": 452957,
      "sentence": "js卡片的组件名。",
      "reference_sentence": "js卡片的组件名。",
      "line_num": 32,
      "context": "{\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "JS卡片的组件名。",
      "注意事项": "修复时应严格限定修改范围仅针对当前不一致项（如\"组件名\"），避免引入无关格式调整（如JS大小写）；需交叉验证上下文所有相关术语使用情况，确保修改后的表述与文档现有规范完全统一。"
    },
    {
      "defect_id": 452985,
      "sentence": "## FormType",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 47,
      "context": "{\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\",\"48\":\"\",\"49\":\"支持的卡片类型枚举。\",\"50\":\"\",\"51\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"52\":\"\"}",
      "用户拒绝的修改": "## FormType枚举",
      "注意事项": "修复时应严格验证问题是否由当前修改引入，避免修正历史遗留的不一致；需确保标题形式调整符合上下文已有规范，优先参照相邻章节的命名风格而非全局统一。"
    },
    {
      "defect_id": 452989,
      "sentence": "## FormStateInfo",
      "reference_sentence": "## FormInfo卡片配置信息。",
      "line_num": 76,
      "context": "{\"71\":\"| ----------- | ---- | ------------ |\",\"72\":\"| MODE_AUTO   | -1    | 表示自动模式。   |\",\"73\":\"| MODE_DARK    | 0   | 表示暗色。   |\",\"74\":\"| MODE_LIGHT     | 1   | 表示亮色。   |\",\"75\":\"\",\"76\":\"## FormStateInfo\",\"77\":\"\",\"78\":\"卡片状态信息。\",\"79\":\"\",\"80\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"81\":\"\"}",
      "用户拒绝的修改": "## FormStateInfo结构",
      "注意事项": "修复时应严格限定修改范围为当前问题上下文，避免追溯调整历史遗留格式问题；应用标题风格统一规则前需交叉验证文档内其他同级标题的实际使用惯例，防止过度修正。"
    },
    {
      "defect_id": 453027,
      "sentence": "圆形 form。",
      "reference_sentence": "圆形 form。",
      "line_num": 155,
      "context": "{\"150\":\"**系统能力：** SystemCapability.Ability.Form\",\"151\":\"\",\"152\":\"| 名称        | 值   | 说明         |\",\"153\":\"| ----------- | ---- | ------------ |\",\"154\":\"| RECT        | 1   | 方形 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"155\":\"| CIRCLE      | 2   | 圆形 form。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"156\":\"\",\"157\":\"## FormInfoFilter\",\"158\":\"\",\"159\":\"卡片信息过滤器，仅将符合过滤器内要求的卡片信息返回。\",\"160\":\"\"}",
      "用户拒绝的修改": "圆形 服务卡片。",
      "注意事项": "修复术语不一致时必须全面检查上下文所有相关实例，确保同步修改所有相同术语；确认修改范围是否仅限于当前问题点，避免引入未授权的全局性变更。"
    },
    {
      "defect_id": 453032,
      "sentence": "**系统能力**：SystemCapability.Ability.Form",
      "reference_sentence": "**系统能力：** SystemCapability.Ability.Form",
      "line_num": 231,
      "context": "{\"226\":\"| height | number | 否 | 否   | 描述矩形的高度，单位：vp。|\",\"227\":\"## FormLocation<sup>20+</sup>\",\"228\":\"\",\"229\":\"卡片当前位置枚举。\",\"230\":\"\",\"231\":\"**系统能力**：SystemCapability.Ability.Form\",\"232\":\"\",\"233\":\"| 名称                         | 值   | 说明                             |\",\"234\":\"| ---------------------------- | ---- | -------------------------------- |\",\"235\":\"| DESKTOP                      | 0    | 表示卡片位于桌面。               |\",\"236\":\"| FORM_CENTER                  | 1    | 表示卡片位于桌面的卡片中心。     |\"}",
      "用户拒绝的修改": "**系统能力：** SystemCapability.Ability.Form",
      "注意事项": "修复时应先确认问题是否属于当前修改范围，避免修改历史遗留问题；需结合上下文判断用户实际修改意图，避免机械统一格式导致无效修改。"
    },
    {
      "defect_id": 454119,
      "sentence": "一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。",
      "reference_sentence": "一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。",
      "line_num": 1,
      "context": "{\"1\":\"页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。\",\"2\":\"\",\"3\":\"- 在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。\",\"4\":\"- 在页面路由（@ohos.router）框架下，“页面”特指@Entry装饰的自定义组件。\",\"5\":\"\",\"6\":\"相较而言，组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。\"}",
      "用户拒绝的修改": "一个完整的应用往往由多个界面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的界面跳转能力。",
      "注意事项": "修复术语一致性时必须优先识别上下文中的明确定义（如问题上下文第3/4/6段明确将\"NavDestination组件\"和\"@Entry装饰组件\"定义为\"页面\"），避免将技术术语替换为同义词；当存在多层级表述时（如第1段用\"界面\"指代用户交互载体，\"页面\"作为技术术语），应保留术语的精准性而非强制统一非关键描述词。"
    },
    {
      "defect_id": 453031,
      "sentence": "卡片当前位置枚举。",
      "reference_sentence": "FormDimension定义卡片尺寸枚举。",
      "line_num": 229,
      "context": "{\"224\":\"| top    | number | 否 | 否   | 描述矩形的左上角顶点的 y 坐标，单位：vp。|\",\"225\":\"| width  | number | 否 | 否   | 描述矩形的宽度，单位：vp。|\",\"226\":\"| height | number | 否 | 否   | 描述矩形的高度，单位：vp。|\",\"227\":\"## FormLocation<sup>20+</sup>\",\"228\":\"\",\"229\":\"卡片当前位置枚举。\",\"230\":\"\",\"231\":\"**系统能力**：SystemCapability.Ability.Form\",\"232\":\"\",\"233\":\"| 名称                         | 值   | 说明                             |\",\"234\":\"| ---------------------------- | ---- | -------------------------------- |\"}",
      "用户拒绝的修改": "定义卡片当前位置枚举。",
      "注意事项": "修复前需确认上下文是否已存在统一术语规范，并严格区分当前修改范围与历史遗留问题，避免过度纠正非本次任务相关的表达不一致。"
    },
    {
      "defect_id": 454123,
      "sentence": "推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。",
      "reference_sentence": "推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。",
      "line_num": 6,
      "context": "{\"1\":\"页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。\",\"2\":\"\",\"3\":\"- 在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。\",\"4\":\"- 在页面路由（@ohos.router）框架下，“页面”特指@Entry装饰的自定义组件。\",\"5\":\"\",\"6\":\"相较而言，组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。\",\"7\":\"\",\"8\":\"## SheetKeyboardAvoidMode<sup>13+</sup>枚举说明\",\"9\":\"\",\"10\":\"半模态激活输入法时对软键盘的避让方式。\",\"11\":\"\"}",
      "用户拒绝的修改": "推荐使用组件导航（Navigation）来实现界面跳转以及组件内的跳转，以获得更佳的使用体验。",
      "注意事项": "修复前需验证术语在上下文中的明确定义和使用频率，优先保持与核心概念定义（如\"页面\"在上下文中的技术定义）的一致性，避免机械替换近义词导致技术准确性受损。"
    },
    {
      "defect_id": 456004,
      "sentence": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。",
      "reference_sentence": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。",
      "line_num": 3742,
      "context": "{\"3737\":\"| NODE_IMAGE_DRAGGABLE  | 图片拖拽效果属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否支持拖拽，设置为true表示支持。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否支持拖拽。 |\",\"3738\":\"| NODE_IMAGE_RENDER_MODE  | 图片渲染模式属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 参数类型[ArkUI_ImageRenderMode](#arkui_imagerendermode)。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 参数类型[ArkUI_ImageRenderMode](#arkui_imagerendermode)。 |\",\"3739\":\"| NODE_IMAGE_FIT_ORIGINAL_SIZE  | 设置图片的显示尺寸是否跟随图源尺寸，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32，设置图片的显示尺寸是否跟随图源尺寸，1表示跟随，0表示不跟随，默认值为0。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32，1表示图片的显示尺寸跟随图源尺寸，0表示图片的显示尺寸不跟随图源尺寸。 |\",\"3740\":\"| NODE_IMAGE_FILL_COLOR  | 设置填充颜色，设置后填充颜色会覆盖在图片上，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：填充色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：填充色数值，0xargb格式。 |\",\"3741\":\"| NODE_IMAGE_RESIZABLE  | 设置图像拉伸时，可调整大小的图像选项。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32 图片左部拉伸时，保持不变距离。单位vp。<br/>.value[1].f32 图片上部拉伸时，保持不变距离。单位vp。<br/>.value[2].f32 图片右部拉伸时，保持不变距离。单位vp。<br/>.value[3].f32 图片下部拉伸时，保持不变距离。单位vp。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32 图片左部拉伸时，保持不变距离。单位vp。<br/>.value[1].f32 图片上部拉伸时，保持不变距离。单位vp。<br/>.value[2].f32 图片右部拉伸时，保持不变距离。单位vp。<br/>.value[3].f32 图片下部拉伸时，保持不变距离。单位vp。 |\",\"3742\":\"| NODE_IMAGE_SYNC_LOAD  | 图源同步加载属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。 <br/>**起始版本：** 20 |\",\"3743\":\"| NODE_TOGGLE_SELECTED_COLOR  | 组件打开状态的背景颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式。 |\",\"3744\":\"| NODE_TOGGLE_SWITCH_POINT_COLOR  | Switch类型的圆形滑块颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：圆形滑块颜色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：圆形滑块颜色数值，0xargb格式。 |\",\"3745\":\"| NODE_TOGGLE_VALUE  | Switch类型的开关值，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：设置开关的值，true表示开启。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：设置开关的值。 |\",\"3746\":\"| NODE_TOGGLE_UNSELECTED_COLOR  | 组件关闭状态的背景颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式。 |\",\"3747\":\"| NODE_LOADING_PROGRESS_COLOR  | 加载进度条前景色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：前景颜色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：前景颜色数值，0xargb格式。 |\"}",
      "用户拒绝的修改": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步加载，1表示同步加载，0表示异步加载。",
      "注意事项": "修复时应严格保持术语与上下文完全一致，避免在未明确扩展场景时擅自添加修饰词（如\"加载\"），需同时检查属性设置方法、属性获取方法及相关条目中的表述统一性。"
    },
    {
      "defect_id": 455978,
      "sentence": "| value  | number | 是   | SVG图源抗锯齿效果。<br/>默认值：0.0 |",
      "reference_sentence": "| value  | number | 是   | SVG图源抗锯齿效果。<br/>默认值：0.0 |",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"**参数：** \",\"42\":\"\",\"43\":\"| 参数名 | 类型   | 必填 | 说明                                |\",\"44\":\"| ------ | ------ | ---- | ----------------------------------- |\",\"45\":\"| value  | number | 是   | SVG图源抗锯齿效果。<br/>默认值：0.0 |\",\"46\":\"\",\"47\":\"### pointLight<sup>11+</sup>\",\"48\":\"\",\"49\":\"pointLight(value: PointLightStyle)\",\"50\":\"\"}",
      "用户拒绝的修改": "| value  | number | 是   | SVG图源抗锯齿优化。<br/>默认值：0.0 |",
      "注意事项": "修复前需严格验证上下文是否存在已确定的统一术语，避免将原本正确的专业表述误判为不一致；修改时应以参数说明栏位已有用词为基准，禁止在无明确错误的情况下进行同义词替换。"
    },
    {
      "defect_id": 453029,
      "sentence": "互动卡片动效信息。",
      "reference_sentence": "FormDimension定义卡片尺寸枚举。",
      "line_num": 201,
      "context": "{\"196\":\"| FORM_DEFAULT | 1   | 表示卡片创建原因为默认创建。 |\",\"197\":\"| FORM_SHARE   | 2   | 表示卡片创建原因为共享创建。 |\",\"198\":\"\",\"199\":\"## OverflowInfo<sup>20+</sup>\",\"200\":\"\",\"201\":\"互动卡片动效信息。\",\"202\":\"\",\"203\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"204\":\"\",\"205\":\"**系统能力：** SystemCapability.Ability.Form\",\"206\":\"\"}",
      "用户拒绝的修改": "定义互动卡片动效信息。",
      "注意事项": "在修复语言表达一致性时，需优先确认问题句子的上下文结构是否与参考句同属同一层级（如是否均为标题/正文/枚举项），避免跨层级强加统一用词；若问题句子位于独立章节或空行分隔的区块，应保持其原有语法结构不作冗余修改。"
    },
    {
      "defect_id": 454313,
      "sentence": "查询是否启用了默认错误页面功能。",
      "reference_sentence": "设置是否启用错误页面。当页面发生错误时，将触发onOverrideErrorPage回调。",
      "line_num": 9351,
      "context": "{\"9346\":\"\",\"9347\":\"## getErrorPageEnabled<sup>20+</sup>\",\"9348\":\"\",\"9349\":\"getErrorPageEnabled(): boolean\",\"9350\":\"\",\"9351\":\"查询是否启用了默认错误页面功能。\",\"9352\":\"\",\"9353\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9354\":\"\",\"9355\":\"**返回值：**\",\"9356\":\"\"}",
      "用户拒绝的修改": "查询是否启用错误页面功能。",
      "注意事项": "在修改操作动词前必须结合上下文确认方法类型（如get/set），保留原文中的关键术语（如\"默认\"）除非明确冗余，避免破坏接口命名一致性。"
    },
    {
      "defect_id": 454124,
      "sentence": "如果设置的对齐方式导致组件布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至组件完全显示在窗口内。",
      "reference_sentence": "如果设置的对齐方式导致组件布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至组件完全显示在窗口内。",
      "line_num": 20,
      "context": "{\"15\":\"| ------------------------- | ---- | -------------------------------- |\",\"16\":\"| NONE | 0    | 设置半模态不避让软键盘。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。 |\",\"17\":\"| TRANSLATE_AND_RESIZE    | 1    | 设置半模态先上抬面板避让软键盘；<br/>当上抬至最大高度仍不足以避让软键盘时，则通过压缩整体内容完成避让。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"18\":\"| RESIZE_ONLY    | 2    | 设置半模态通过压缩整体内容避让软键盘。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"19\":\"| TRANSLATE_AND_SCROLL    | 3    | 设置半模态先上抬面板避让软键盘；<br/>当上抬至最大高度仍不足以避让软键盘时，则通过滚动内容完成避让。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"20\":\"| POPUP_SHEET<sup>20+</sup>    | 4    | 设置半模态popup样式弹窗避让软键盘。<br /> 1. 避让软键盘时，在popup样式弹窗当前显示位置无法容纳弹窗尺寸的前提下，遵循先垂直翻转避让，后尝试90°水平旋转避让的规则调整显示位置，以预设方向为下方为例，调整避让顺序依次为：下、上、右、左。<br />2. 如果设置的对齐方式导致组件布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至组件完全显示在窗口内。<br />3. 避让软键盘时，如果在四个方向上均无法容纳当前的popup样式弹窗，处理方式遵循开发者设置的placementOnTarget属性：<br />（1）若属性值为true，将依据设定的placement，向其镜像方向平移，直至弹窗能够完全显示。<br />（2）若属性值为false，则在四个方向中，选择能够完全展示弹窗宽度且剩余高度最大的方向，通过调整半模态高度以适应当前方向，确保弹窗能够放下，同时保持预设placement对应的对齐方式不变。<br />4. 若此时半模态不是跟手样式，则不具备避让软件盘能力。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"21\":\"\",\"22\":\"> **说明：**\",\"23\":\">\",\"24\":\"> 设置POPUP_SHEET避让方式时，半模态只避让由面板内的文本框组件拉起的软键盘场景，其他场景半模态无需避让。\",\"25\":\">\"}",
      "用户拒绝的修改": "如果设置的对齐方式导致界面布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至界面完全显示在窗口内。",
      "注意事项": "在统一术语前必须确认上下文是否存在明确的术语定义或既定用法，避免将技术文档中具有特定含义的词汇（如\"组件\"）误判为普通表达；优先保留原文核心概念，仅在上下文明确要求统一时调整术语。"
    },
    {
      "defect_id": 454120,
      "sentence": "在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。",
      "reference_sentence": "在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。",
      "line_num": 3,
      "context": "{\"1\":\"页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。\",\"2\":\"\",\"3\":\"- 在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。\",\"4\":\"- 在页面路由（@ohos.router）框架下，“页面”特指@Entry装饰的自定义组件。\",\"5\":\"\",\"6\":\"相较而言，组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。\",\"7\":\"\",\"8\":\"## SheetKeyboardAvoidMode<sup>13+</sup>枚举说明\"}",
      "用户拒绝的修改": "在组件导航（Navigation）框架下，“界面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。",
      "注意事项": "修复前需优先确认上下文术语定义及使用场景，避免机械替换同义词破坏已有术语体系；对于存在多套技术框架的场景，应严格区分不同框架下的专属术语并保持各自体系内一致性。"
    },
    {
      "defect_id": 454118,
      "sentence": "页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。",
      "reference_sentence": "页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。",
      "line_num": 1,
      "context": "{\"1\":\"页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。\",\"2\":\"\",\"3\":\"- 在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。\",\"4\":\"- 在页面路由（@ohos.router）框架下，“页面”特指@Entry装饰的自定义组件。\",\"5\":\"\",\"6\":\"相较而言，组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。\"}",
      "用户拒绝的修改": "界面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。",
      "注意事项": "修复语言一致性时需优先确认术语在上下文中的明确定义和使用场景，若存在多个相关术语共存的情况，应通过上下文分析判断是否需要区分专业概念而非强制统一用词。"
    },
    {
      "defect_id": 453030,
      "sentence": "通用矩形区域信息。可用于描述卡片位置、互动卡片动效区域等信息。",
      "reference_sentence": "FormDimension定义卡片尺寸枚举。",
      "line_num": 215,
      "context": "{\"210\":\"| duration | number | 否 | 否   | 互动卡片动效持续时长。取值为大于0、小于等于3500的整数，单位ms。 |\",\"211\":\"| useDefaultAnimation | boolean | 否 | 是   | 互动卡片状态切换时是否启动系统提供的默认动效，默认为true。取值为false表示系统不提供切换动效，画面直接切换，适合切换时非激活态和激活态UI完全一致的场景。 |\",\"212\":\"\",\"213\":\"## Rect<sup>20+</sup>\",\"214\":\"\",\"215\":\"通用矩形区域信息。可用于描述卡片位置、互动卡片动效区域等信息。\",\"216\":\"\",\"217\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"218\":\"\",\"219\":\"**系统能力：** SystemCapability.Ability.Form\",\"220\":\"\"}",
      "用户拒绝的修改": "定义通用矩形区域信息。可用于描述卡片位置、互动卡片动效区域等信息。",
      "注意事项": "修复前需确认修改范围是否属于当前上下文，避免对已存在的规范术语进行冗余调整；统一用词时应区分术语定义和使用场景，标题性描述无需强制添加\"定义\"等动作词。"
    },
    {
      "defect_id": 454122,
      "sentence": "组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。",
      "reference_sentence": "组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。",
      "line_num": 6,
      "context": "{\"1\":\"页面是指由布局、组件、交互逻辑等构成的可视化交互单元，承载着特定功能逻辑与信息展示，是用户与应用进行操作交互的核心界面载体。一个完整的应用往往由多个页面组成，组件导航（Navigation）和页面路由（@ohos.router）均提供了应用内的页面跳转能力。\",\"2\":\"\",\"3\":\"- 在组件导航（Navigation）框架下，“页面”通过NavDestination组件承载，特指一个NavDestination组件包含的内容。\",\"4\":\"- 在页面路由（@ohos.router）框架下，“页面”特指@Entry装饰的自定义组件。\",\"5\":\"\",\"6\":\"相较而言，组件导航（Navigation）将页面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的页面栈操作，同时支持更丰富的动效和生命周期。因此，推荐使用组件导航（Navigation）来实现页面跳转以及组件内的跳转，以获得更佳的使用体验。\",\"7\":\"\",\"8\":\"## SheetKeyboardAvoidMode<sup>13+</sup>枚举说明\",\"9\":\"\",\"10\":\"半模态激活输入法时对软键盘的避让方式。\",\"11\":\"\"}",
      "用户拒绝的修改": "组件导航（Navigation）将界面放在Navigation组件内部进行跳转，具备更强的一次开发多端部署能力，可以进行更加灵活的界面栈操作，同时支持更丰富的动效和生命周期。",
      "注意事项": "修复术语一致性时必须优先核对上下文中的技术定义和已有用例，避免将领域专用术语（如\"页面\"）误判为普通词汇替换；若同一文档中存在多个相似术语（如\"页面\"和\"界面\"），需结合具体技术场景判断是否属于同义词替换范畴。"
    },
    {
      "defect_id": 454328,
      "sentence": "onOverrideUrlLoading的回调。",
      "reference_sentence": "拦截网页可编辑元素拉起软键盘的回调，一般在点击网页input标签时触发。",
      "line_num": 236,
      "context": "{\"231\":\"\",\"232\":\"## OnOverrideErrorPageCallback<sup>20+</sup>\",\"233\":\"\",\"234\":\"type OnOverrideErrorPageCallback= (webResourceRequest: WebResourceRequest, error: WebResourceError) => string\",\"235\":\"\",\"236\":\"onOverrideUrlLoading的回调。\",\"237\":\"\",\"238\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"239\":\"\",\"240\":\"**参数：**\",\"241\":\"\"}",
      "用户拒绝的修改": "onOverrideUrlLoading的回调函数。",
      "注意事项": "修复前必须严格检查上下文术语一致性，优先沿用原文用词习惯；避免过度纠正技术细节，若原文已统一使用简称（如“回调”）且无歧义，无需强制补全为全称（如“回调函数”）。"
    },
    {
      "defect_id": 453028,
      "sentence": "卡片创建原因枚举。",
      "reference_sentence": "FormDimension定义卡片尺寸枚举。",
      "line_num": 188,
      "context": "{\"183\":\"| FORM_INVISIBLE   | 2   | 表示卡片为不可见。 |\",\"184\":\"\",\"185\":\"\",\"186\":\"## LaunchReason<sup>10+</sup>\",\"187\":\"\",\"188\":\"卡片创建原因枚举。\",\"189\":\"\",\"190\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"191\":\"\",\"192\":\"**系统能力：** SystemCapability.Ability.Form\",\"193\":\"\"}",
      "用户拒绝的修改": "定义卡片创建原因枚举。",
      "注意事项": "在统一术语前必须严格验证上下文是否存在已确立的命名规范，优先维持当前模块的原始表述习惯；若修改涉及跨模块一致性，需额外提供关联证据或明确用户需求后再执行。"
    },
    {
      "defect_id": 454314,
      "sentence": "返回是否启用了默认错误页面功能。<br>true：启用了默认错误页面功能；false：不启用默认错误页面功能。",
      "reference_sentence": "表示是否启用错误页面。<br>true表示设置启用错误页面，false表示设置不启用错误页面。",
      "line_num": 9359,
      "context": "{\"9354\":\"\",\"9355\":\"**返回值：**\",\"9356\":\"\",\"9357\":\"| 类型                 | 说明                      |\",\"9358\":\"| -------------------- | ------------------------- |\",\"9359\":\"| boolean              | 返回是否启用了默认错误页面功能。<br>true：启用了默认错误页面功能；false：不启用默认错误页面功能。 |\",\"9360\":\"\",\"9361\":\"**错误码：**\",\"9362\":\"\",\"9363\":\"以下错误码的详细介绍请参见[Webview错误码](errorcode-webview.md)。\",\"9364\":\"\"}",
      "用户拒绝的修改": "返回是否启用错误页面功能。<br>true：启用错误页面功能；false：不启用错误页面功能。",
      "注意事项": "修复时应优先确认术语是否涉及专有概念或上下文依赖词汇（如\"默认\"），避免因过度统一表述而误删关键限定词；同时需结合问题上下文和参考句子的实际应用场景判断一致性调整的必要性。"
    },
    {
      "defect_id": 456003,
      "sentence": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。",
      "reference_sentence": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。",
      "line_num": 3742,
      "context": "{\"3737\":\"| NODE_IMAGE_DRAGGABLE  | 图片拖拽效果属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否支持拖拽，设置为true表示支持。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否支持拖拽。 |\",\"3738\":\"| NODE_IMAGE_RENDER_MODE  | 图片渲染模式属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 参数类型[ArkUI_ImageRenderMode](#arkui_imagerendermode)。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 参数类型[ArkUI_ImageRenderMode](#arkui_imagerendermode)。 |\",\"3739\":\"| NODE_IMAGE_FIT_ORIGINAL_SIZE  | 设置图片的显示尺寸是否跟随图源尺寸，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32，设置图片的显示尺寸是否跟随图源尺寸，1表示跟随，0表示不跟随，默认值为0。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32，1表示图片的显示尺寸跟随图源尺寸，0表示图片的显示尺寸不跟随图源尺寸。 |\",\"3740\":\"| NODE_IMAGE_FILL_COLOR  | 设置填充颜色，设置后填充颜色会覆盖在图片上，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：填充色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：填充色数值，0xargb格式。 |\",\"3741\":\"| NODE_IMAGE_RESIZABLE  | 设置图像拉伸时，可调整大小的图像选项。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32 图片左部拉伸时，保持不变距离。单位vp。<br/>.value[1].f32 图片上部拉伸时，保持不变距离。单位vp。<br/>.value[2].f32 图片右部拉伸时，保持不变距离。单位vp。<br/>.value[3].f32 图片下部拉伸时，保持不变距离。单位vp。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32 图片左部拉伸时，保持不变距离。单位vp。<br/>.value[1].f32 图片上部拉伸时，保持不变距离。单位vp。<br/>.value[2].f32 图片右部拉伸时，保持不变距离。单位vp。<br/>.value[3].f32 图片下部拉伸时，保持不变距离。单位vp。 |\",\"3742\":\"| NODE_IMAGE_SYNC_LOAD  | 图源同步加载属性，支持属性设置，属性重置，属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步，1表示同步，0表示异步。 <br/>**起始版本：** 20 |\",\"3743\":\"| NODE_TOGGLE_SELECTED_COLOR  | 组件打开状态的背景颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式。 |\",\"3744\":\"| NODE_TOGGLE_SWITCH_POINT_COLOR  | Switch类型的圆形滑块颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：圆形滑块颜色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：圆形滑块颜色数值，0xargb格式。 |\",\"3745\":\"| NODE_TOGGLE_VALUE  | Switch类型的开关值，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：设置开关的值，true表示开启。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：设置开关的值。 |\",\"3746\":\"| NODE_TOGGLE_UNSELECTED_COLOR  | 组件关闭状态的背景颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：背景色数值，0xargb格式。 |\",\"3747\":\"| NODE_LOADING_PROGRESS_COLOR  | 加载进度条前景色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：前景颜色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：前景颜色数值，0xargb格式。 |\"}",
      "用户拒绝的修改": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32 表示是否同步加载，1表示同步加载，0表示异步加载。",
      "注意事项": "修复时应严格保持术语与上下文完全一致，避免添加原文未出现的修饰词（如\"加载\"），并优先参照同属性其他接口（如属性获取方法）的表述方式确保全局统一。"
    },
    {
      "defect_id": 454306,
      "sentence": "网页加载遇到错误时触发。",
      "reference_sentence": "网页加载遇到错误时触发。",
      "line_num": 4296,
      "context": "{\"4291\":\"\",\"4292\":\"**参数：**\",\"4293\":\"\",\"4294\":\"| 参数名     | 类型                                     | 必填   | 说明            |\",\"4295\":\"| ------- | ---------------------------------------- | ---- | --------------- |\",\"4296\":\"| callback | [OnOverrideErrorPageCallback](./arkts-basic-components-web-t.md#onoverrideerrorpagecallback20) | 是    | 网页加载遇到错误时触发。      |\",\"4297\":\"\",\"4298\":\"**示例：**\",\"4299\":\"\",\"4300\":\"  ```ts\",\"4301\":\"// xxx.ets\"}",
      "用户拒绝的修改": "触发，当网页加载遇到错误时。",
      "注意事项": "修复时应优先检查上下文中的句式惯例和文档类型规范，避免机械套用语法规则；技术文档参数说明通常采用陈述句而非祈使句，需结合领域特性判断表达一致性。"
    },
    {
      "defect_id": 455977,
      "sentence": "适用于超低分辨率设备（PPI低于200的设备）的SVG图源的锯齿优化，存在一定的性能影响，请谨慎使用。",
      "reference_sentence": "适用于超低分辨率设备（PPI低于200的设备）的SVG图源的锯齿优化，存在一定的性能影响，请谨慎使用。",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"edgeAntialiasing(value: number)\",\"32\":\"\",\"33\":\"设置SVG图源抗锯齿效果，仅对SVG图源生效。取值范围为$(0.333, 1.333]$，有效数字保留小数点后3位。\",\"34\":\"\",\"35\":\"适用于超低分辨率设备（PPI低于200的设备）的SVG图源的锯齿优化，存在一定的性能影响，请谨慎使用。\",\"36\":\"\",\"37\":\"**系统接口：** 此接口为系统接口。\",\"38\":\"\",\"39\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"40\":\"\"}",
      "用户拒绝的修改": "适用于超低分辨率设备（PPI低于200的设备）的SVG图源的抗锯齿优化，存在一定的性能影响，请谨慎使用。",
      "注意事项": "修复术语一致性时必须先核对上下文术语的实际使用情况，若问题句子与参考句子保持统一且上下文存在术语混用，应优先维持原句表述并建议全局术语统一，而非直接修改局部表述。"
    },
    {
      "defect_id": 454305,
      "sentence": "网页加载遇到错误时触发该回调。只有主资源出错会回调该接口。",
      "reference_sentence": "网页加载遇到错误时触发该回调。只有主资源出错会回调该接口。",
      "line_num": 4288,
      "context": "{\"4283\":\"\",\"4284\":\"## onOverrideErrorPage<sup>20+</sup>\",\"4285\":\"\",\"4286\":\"onOverrideErrorPage(callback: OnOverrideErrorPageCallback)\",\"4287\":\"\",\"4288\":\"网页加载遇到错误时触发该回调。只有主资源出错会回调该接口。\",\"4289\":\"\",\"4290\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"4291\":\"\",\"4292\":\"**参数：**\",\"4293\":\"\"}",
      "用户拒绝的修改": "触发该回调，当网页加载遇到错误时。只有主资源出错会回调该接口。",
      "注意事项": "准确识别句式类型，技术文档中条件状语从句前置属于常见规范表达，无需强制调整为后置结构；优先保持行业惯例和上下文一致性，避免过度修正符合专业场景的既定表述方式。"
    },
    {
      "defect_id": 458192,
      "sentence": "  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\<module-name>**/cache |",
      "reference_sentence": "  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\<module-name>**/files |",
      "line_num": 290,
      "context": "{\"285\":\"\",\"286\":\"  **表1** 不同级别Context获取的应用文件路径说明\",\"287\":\"  | 属性 | 说明 | ApplicationContext获取的路径 | AbilityStageContext、UIAbilityContext、ExtensionContext获取的路径 |\",\"288\":\"  | -------- | -------- | -------- | -------- |\",\"289\":\"  | bundleCodeDir | 安装包目录。 | <路径前缀>/el1/bundle | <路径前缀>/el1/bundle |\",\"290\":\"  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/cache |\",\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\",\"292\":\"  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/preferences |\",\"293\":\"  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/temp |\",\"294\":\"  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\\\<module-name>** |\",\"295\":\"  | distributedFilesDir | 分布式文件目录。 | <路径前缀>/el2/distributedFiles | <路径前缀>/el2/distributedFiles/ |\"}",
      "用户拒绝的修改": "  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\<Module-name>**/cache |",
      "注意事项": "保持术语中英文对应一致性，变量命名需严格遵循上下文格式（如全小写\"module-name\"），禁止混合使用中文\"模块\"与英文\"Module\"两种表述形式。"
    },
    {
      "defect_id": 458003,
      "sentence": "如果需要在页面中获得当前Ability的Context，可使用[UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md)中的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)接口获取当前页面关联的UIAbilityContext或[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)。",
      "reference_sentence": "如果需要在页面中获得当前Ability的Context，可使用[UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md)中的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)接口获取当前页面关联的UIAbilityContext或[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)。",
      "line_num": 113,
      "context": "{\"108\":\"  ```\",\"109\":\"\",\"110\":\"### 获取UIAbilityContext（组件级的Context）\",\"111\":\"\",\"112\":\"[UIAbility](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md)类拥有自身的上下文信息，该信息为[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)类的实例，[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)类拥有abilityInfo、currentHapModuleInfo等属性。通过UIAbilityContext可以获取UIAbility的相关配置信息，如包代码路径、Bundle名称、Ability名称和应用程序需要的环境状态等属性信息，以及可以获取操作UIAbility实例的方法（如[startAbility()](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#startability)、[connectServiceExtensionAbility()](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#connectserviceextensionability)、[terminateSelf()](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)等）。\",\"113\":\"如果需要在页面中获得当前Ability的Context，可使用[UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md)中的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)接口获取当前页面关联的UIAbilityContext或[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)。\",\"114\":\"\",\"115\":\"- 在UIAbility中可以通过`this.context`获取UIAbility实例的上下文信息。\",\"116\":\"  \",\"117\":\"  ```ts\",\"118\":\"  import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\"}",
      "用户拒绝的修改": "如果需要在界面中获得当前Ability的Context，可使用[UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md)中的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)接口获取当前界面关联的UIAbilityContext或[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)。",
      "注意事项": "在修复术语不一致时，需优先确认上下文及文档中是否已存在固定术语（如“页面”在技术文档中可能特指Page组件），避免机械替换同义词；同时应检查关联段落（如问题上下文中的UIAbility描述）是否存在相同术语的隐性关联，确保全局一致性。"
    },
    {
      "defect_id": 458193,
      "sentence": "  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\<module-name>**/files |",
      "reference_sentence": "  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\<module-name>**/preferences |",
      "line_num": 291,
      "context": "{\"286\":\"  **表1** 不同级别Context获取的应用文件路径说明\",\"287\":\"  | 属性 | 说明 | ApplicationContext获取的路径 | AbilityStageContext、UIAbilityContext、ExtensionContext获取的路径 |\",\"288\":\"  | -------- | -------- | -------- | -------- |\",\"289\":\"  | bundleCodeDir | 安装包目录。 | <路径前缀>/el1/bundle | <路径前缀>/el1/bundle |\",\"290\":\"  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/cache |\",\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\",\"292\":\"  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/preferences |\",\"293\":\"  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/temp |\",\"294\":\"  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\\\<module-name>** |\",\"295\":\"  | distributedFilesDir | 分布式文件目录。 | <路径前缀>/el2/distributedFiles | <路径前缀>/el2/distributedFiles/ |\",\"296\":\"  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\\\<module-name>\\\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\\\<module-name>**/resources/resfile |\"}",
      "用户拒绝的修改": "  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\<Module-name>**/files |",
      "注意事项": "修复路径变量时应严格保持命名风格一致性（如全小写\"module-name\"），并交叉验证上下文已有实例（如preferencesDir/databaseDir中的写法），避免中英文术语混用和大小写格式偏差。"
    },
    {
      "defect_id": 458191,
      "sentence": "通过[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)可以获取应用级的文件路径。该路径用于存放应用全局信息，路径下的文件会跟随应用的卸载而删除。",
      "reference_sentence": "通过[AbilityStageContext](../reference/apis-ability-kit/js-apis-inner-application-abilityStageContext.md)、[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)、[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)，可以获取[Module](../quick-start/application-package-overview.md)级的文件路径。该路径用于存放Module相关信息，路径下的文件会跟随[HAP](../quick-start/hap-package.md)/[HSP](../quick-start/in-app-hsp.md)的卸载而删除。",
      "line_num": 286,
      "context": "{\"281\":\"\",\"282\":\">**说明：**\",\"283\":\">\",\"284\":\"> 应用文件路径属于应用沙箱路径，具体请参见[应用沙箱目录](../file-management/app-sandbox-directory.md)。\",\"285\":\"\",\"286\":\"  **表1** 不同级别Context获取的应用文件路径说明\",\"287\":\"  | 属性 | 说明 | ApplicationContext获取的路径 | AbilityStageContext、UIAbilityContext、ExtensionContext获取的路径 |\",\"288\":\"  | -------- | -------- | -------- | -------- |\",\"289\":\"  | bundleCodeDir | 安装包目录。 | <路径前缀>/el1/bundle | <路径前缀>/el1/bundle |\",\"290\":\"  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/cache |\",\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\"}",
      "用户拒绝的修改": "通过[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)可以获取应用级的文件路径。该路径用于存放应用全局信息，路径下的文件会跟随应用的卸载而删除。通过[AbilityStageContext](../reference/apis-ability-kit/js-apis-inner-application-abilityStageContext.md)、[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)、[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)，可以获取[Module](../quick-start/application-package-overview.md)级的文件路径。该路径用于存放Module相关信息，路径下的文件会跟随应用的卸载而删除。",
      "注意事项": "严格区分\"应用级\"与\"Module级\"上下文的生命周期差异，确保技术术语(应用卸载/HAP卸载/HSP卸载)与操作粒度的精确对应，避免跨层级表述混用。"
    },
    {
      "defect_id": 458197,
      "sentence": "  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\<module-name>\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\<module-name>**/resources/resfile |",
      "reference_sentence": "  | cloudFileDir<sup>12+</sup> | 云文件目录。 | <路径前缀>/el2/cloud | <路径前缀>/el2/cloud/ |",
      "line_num": 296,
      "context": "{\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\",\"292\":\"  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/preferences |\",\"293\":\"  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/temp |\",\"294\":\"  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\\\<module-name>** |\",\"295\":\"  | distributedFilesDir | 分布式文件目录。 | <路径前缀>/el2/distributedFiles | <路径前缀>/el2/distributedFiles/ |\",\"296\":\"  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\\\<module-name>\\\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\\\<module-name>**/resources/resfile |\",\"297\":\"  | cloudFileDir<sup>12+</sup> | 云文件目录。 | <路径前缀>/el2/cloud | <路径前缀>/el2/cloud/ |\",\"298\":\"\",\"299\":\"本节以使用ApplicationContext获取cacheDir和filesDir为例，分别介绍如何获取应用缓存目录，以及如何获取应用文件目录，并用于新建文件和读写文件。\",\"300\":\"\",\"301\":\"- **获取应用缓存目录**\"}",
      "用户拒绝的修改": "  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\<Module-name>\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\<Module-name>**/resources/resfile |",
      "注意事项": "严格保持术语统一性，确保路径占位符`\\<module-name>`的格式（全小写+连字符）与上下文完全一致，禁止混合使用\"Module\"等大小写变体；修复时需交叉验证文档中同类占位符的书写规范（如291-296行均采用小写`\\<module-name>`）。"
    },
    {
      "defect_id": 458196,
      "sentence": "  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\<module-name>** |",
      "reference_sentence": "  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\<module-name>\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\<module-name>**/resources/resfile |",
      "line_num": 294,
      "context": "{\"289\":\"  | bundleCodeDir | 安装包目录。 | <路径前缀>/el1/bundle | <路径前缀>/el1/bundle |\",\"290\":\"  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/cache |\",\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\",\"292\":\"  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/preferences |\",\"293\":\"  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/temp |\",\"294\":\"  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\\\<module-name>** |\",\"295\":\"  | distributedFilesDir | 分布式文件目录。 | <路径前缀>/el2/distributedFiles | <路径前缀>/el2/distributedFiles/ |\",\"296\":\"  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\\\<module-name>\\\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\\\<module-name>**/resources/resfile |\",\"297\":\"  | cloudFileDir<sup>12+</sup> | 云文件目录。 | <路径前缀>/el2/cloud | <路径前缀>/el2/cloud/ |\",\"298\":\"\",\"299\":\"本节以使用ApplicationContext获取cacheDir和filesDir为例，分别介绍如何获取应用缓存目录，以及如何获取应用文件目录，并用于新建文件和读写文件。\"}",
      "用户拒绝的修改": "  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\<Module-name>** |",
      "注意事项": "严格保持变量命名的大小写一致性，修复时应核对上下文已有格式（如全小写的\\<module-name>）；避免中英文术语混用，同一概念应使用统一表述（如固定使用\"module\"或\"模块\"，不可交叉使用）。"
    },
    {
      "defect_id": 461885,
      "sentence": "共享模块加载时，导入的非共享模块不会立刻加载。在共享模块内访问依赖的非共享模块导出变量时，会在当前线程懒加载对应的非共享模块，非共享模块在线程间是隔离的，不同线程访问非共享模块时，各个线程均会触发至多一次的非共享模块懒加载。",
      "reference_sentence": "非共享模块在同一线程内只加载一次，而在不同线程中会加载多次，每个线程都会生成新的模块对象。因此，目前只能使用共享模块来实现进程单例。",
      "line_num": 20,
      "context": "{\"15\":\"- 共享模块只支持ets文件。\",\"16\":\"\",\"17\":\"- 共享模块内不允许使用side-effects-import。\",\"18\":\"\",\"19\":\"  共享模块在同一进程内只加载一次，可在不同线程间共享。<br/>\",\"20\":\"  共享模块加载时，导入的非共享模块不会立刻加载。在共享模块内访问依赖的非共享模块导出变量时，会在当前线程懒加载对应的非共享模块，非共享模块在线程间是隔离的，不同线程访问非共享模块时，各个线程均会触发至多一次的非共享模块懒加载。<br/>\",\"21\":\"  由于side-effects-import不涉及导出变量，所以永远不会被加载，因此不支持。\",\"22\":\"\",\"23\":\"  ```ts\",\"24\":\"  // 不允许使用side-effects-import\",\"25\":\"  import \\\"./sharedModule\\\";\"}",
      "用户拒绝的修改": "共享模块加载时，导入的非共享模块不会立即加载。在共享模块内访问依赖的非共享模块导出变量时，会在当前线程懒加载对应的非共享模块，非共享模块在线程间是隔离的，不同线程访问非共享模块时，各个线程均会触发至多一次的非共享模块懒加载。",
      "注意事项": "保持原文术语一致性高于同义替换需求，仅修正实际矛盾表述（如\"立刻\"vs\"立即\"），避免过度修改重复出现的核心概念词汇（如\"非共享模块\"），技术文档中重复使用规范术语不属于冗余问题。"
    },
    {
      "defect_id": 458195,
      "sentence": "  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\<module-name>**/temp |",
      "reference_sentence": "  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\<module-name>** |",
      "line_num": 293,
      "context": "{\"288\":\"  | -------- | -------- | -------- | -------- |\",\"289\":\"  | bundleCodeDir | 安装包目录。 | <路径前缀>/el1/bundle | <路径前缀>/el1/bundle |\",\"290\":\"  | cacheDir | 缓存目录。 | <路径前缀>/<加密等级>/base/cache | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/cache |\",\"291\":\"  | filesDir | 文件目录。 | <路径前缀>/<加密等级>/base/files | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/files |\",\"292\":\"  | preferencesDir | preferences目录。 | <路径前缀>/<加密等级>/base/preferences | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/preferences |\",\"293\":\"  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\\\<module-name>**/temp |\",\"294\":\"  | databaseDir | 数据库目录。 | <路径前缀>/<加密等级>/database | <路径前缀>/<加密等级>/database/**\\\\<module-name>** |\",\"295\":\"  | distributedFilesDir | 分布式文件目录。 | <路径前缀>/el2/distributedFiles | <路径前缀>/el2/distributedFiles/ |\",\"296\":\"  | resourceDir<sup>11+<sup> | 资源目录。<br/>**说明：**<br/> 需要开发者手动在`\\\\<module-name>\\\\resource`路径下创建`resfile`目录。 | 不涉及 | <路径前缀>/el1/bundle/**\\\\<module-name>**/resources/resfile |\",\"297\":\"  | cloudFileDir<sup>12+</sup> | 云文件目录。 | <路径前缀>/el2/cloud | <路径前缀>/el2/cloud/ |\",\"298\":\"\"}",
      "用户拒绝的修改": "  | tempDir | 临时目录。 | <路径前缀>/<加密等级>/base/temp | <路径前缀>/<加密等级>/base/**haps/\\<Module-name>**/temp |",
      "注意事项": "严格保持变量命名的大小写一致性，修复时必须逐字核对上下文已有格式；优先采用文档中已确立的中文术语（如\"模块\"），避免中英文混合表述。"
    },
    {
      "defect_id": 465024,
      "sentence": "onConnect(want: Want): rpc.RemoteObject",
      "reference_sentence": "onConnect(want: Want): rpc.RemoteObject",
      "line_num": 26,
      "context": "{\"21\":\"| -------- | -------- | -------- | -------- | -------- |\",\"22\":\"| context | [SelectionExtensionContext](./js-apis-selectionInput-selectionExtensionContext.md) | 否 | 否 | SelectionExtensionAbility的上下文环境，继承自ExtensionContext。 |\",\"23\":\"\",\"24\":\"### onConnect\",\"25\":\"\",\"26\":\"onConnect(want: Want): rpc.RemoteObject\",\"27\":\"\",\"28\":\"Extension生命周期回调函数，划词SA在拉起划词扩展时调用，执行划词扩展初始化操作。\",\"29\":\"\",\"30\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"31\":\"\"}",
      "用户拒绝的修改": "onConnect(want: Want): RemoteObject",
      "注意事项": "修复前必须优先验证接口定义的实际命名规范，若上下文或参考代码明确使用带命名空间的完整形式（如rpc.RemoteObject），需保留原始结构而非强制简化术语；同时需区分\"术语一致性\"与\"接口定义准确性\"的边界，当用户明确强调接口定义约束时，应以保留技术准确性为最高优先级。"
    },
    {
      "defect_id": 465274,
      "sentence": "This selection window has been destroyed.",
      "reference_sentence": "此划词窗口已被销毁",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"## 33600002 此划词窗口已被销毁\",\"26\":\"\",\"27\":\"**错误信息**\",\"28\":\"\",\"29\":\"This selection window has been destroyed.\",\"30\":\"\",\"31\":\"**错误描述**\",\"32\":\"\",\"33\":\"此划词窗口已被销毁。\",\"34\":\"\"}",
      "用户拒绝的修改": "此划词窗口已被销毁。",
      "注意事项": "修复术语不一致时需优先检查上下文中的现有术语使用情况，避免机械直译导致语义偏差；若参考句与问题句上下文存在重复术语，应直接沿用而非重新翻译。"
    },
    {
      "defect_id": 465273,
      "sentence": "Selection service exception.",
      "reference_sentence": "划词服务异常",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 33600001 划词服务异常\",\"8\":\"\",\"9\":\"**错误信息**\",\"10\":\"\",\"11\":\"Selection service exception.\",\"12\":\"\",\"13\":\"**错误描述**\",\"14\":\"\",\"15\":\"划词服务异常，会报此错误码。\",\"16\":\"\"}",
      "用户拒绝的修改": "划词服务异常。",
      "注意事项": "修复术语时应区分需翻译内容（如界面文案）与需保留原文内容（如错误码或日志信息），并在同一上下文中优先沿用已有中文术语（如参考句中的“划词服务异常”）。"
    },
    {
      "defect_id": 465108,
      "sentence": "为当前的划词面板加载具体页面内容。使用Promise异步回调。",
      "reference_sentence": "显示划词面板，使用promise异步回调。",
      "line_num": 228,
      "context": "{\"223\":\"\",\"224\":\"### setUiContent\",\"225\":\"\",\"226\":\"setUiContent(path: string): Promise\\\\<void>\",\"227\":\"\",\"228\":\"为当前的划词面板加载具体页面内容。使用Promise异步回调。\",\"229\":\"\",\"230\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"231\":\"\",\"232\":\"**参数：**\",\"233\":\"\"}",
      "用户拒绝的修改": "为当前的划词面板加载具体页面内容。使用promise异步回调。",
      "注意事项": "修复时需严格检查技术术语的大小写规范（如\"Promise\"为JavaScript对象应保持首字母大写），并全局核对上下文中的术语使用一致性，避免仅依赖局部匹配而忽略整体规范。"
    },
    {
      "defect_id": 466671,
      "sentence": "该示例演示了BuilderNode设置BuildOptions的enableProvideConsumeCrossing为true，实现将BuilderNode内部的自定义组件的@Consume与它所在的自定义组件的@Provide数据互通。",
      "reference_sentence": "关于消息变更的按钮描述为'Click to change message to append C'",
      "line_num": 1894,
      "context": "{\"1889\":\"\",\"1890\":\"![inheritFreezeOptions](figures/builderNode_inheritFreezeOptions.gif)\",\"1891\":\"\",\"1892\":\"### 示例7（BuilderNode支持内部@Consume接收外部的@Provide数据）\",\"1893\":\"\",\"1894\":\"该示例演示了BuilderNode设置BuildOptions的enableProvideConsumeCrossing为true，实现将BuilderNode内部的自定义组件的@Consume与它所在的自定义组件的@Provide数据互通。\",\"1895\":\"\",\"1896\":\"```ts\",\"1897\":\"import { BuilderNode, NodeContent } from '@kit.ArkUI';\",\"1898\":\"\",\"1899\":\"@Component\"}",
      "用户拒绝的修改": "该示例演示了BuilderNode设置BuildOptions的enableProvideConsumeCrossing为true，实现将BuilderNode内部的自定义组件的@Consume与它所在的自定义组件的@Provide数据互通。关于消息变更的按钮描述为'Click to change message to append C'",
      "注意事项": "修复时应严格保持上下文主题一致性，避免跨内容块混合不同功能描述，确保修改仅针对当前段落核心功能说明，不引入相邻模块的测试用例细节。"
    },
    {
      "defect_id": 466670,
      "sentence": "关于消息变更的按钮描述为'Click to change message to append I'",
      "reference_sentence": "关于消息变更的按钮描述为'Click to change message to append C'",
      "line_num": 1950,
      "context": "{\"1945\":\"      Text(this.message)\",\"1946\":\"        .fontWeight(FontWeight.Bold)\",\"1947\":\"        .fontSize(20)\",\"1948\":\"      Button(\\\"Click to change message to append I\\\")\",\"1949\":\"        .fontWeight(FontWeight.Bold)\",\"1950\":\"        .onClick(() => {\",\"1951\":\"          this.message = this.message + \\\"I\\\";\",\"1952\":\"        })\",\"1953\":\"      Column() {\",\"1954\":\"        ContentSlot(this.content)\",\"1955\":\"      }\"}",
      "用户拒绝的修改": "关于消息变更的按钮描述为'Click to change message to append C'",
      "注意事项": "修复时必须严格区分不同UI组件的独立功能描述，确保修改仅针对真正重复/冲突的相同功能文本，不同控件的行为差异需保留原始准确性。"
    },
    {
      "defect_id": 465275,
      "sentence": "Invalid operation. The selection app is not valid.",
      "reference_sentence": "非法操作，划词应用无效",
      "line_num": 49,
      "context": "{\"44\":\"\",\"45\":\"## 33600003 无效操作，划词应用无效。\",\"46\":\"\",\"47\":\"**错误信息**\",\"48\":\"\",\"49\":\"Invalid operation. The selection app is not valid.\",\"50\":\"\",\"51\":\"**错误描述**\",\"52\":\"\",\"53\":\"非法操作，划词应用无效。\",\"54\":\"\"}",
      "用户拒绝的修改": "非法操作。划词应用无效。",
      "注意事项": "修复前必须严格核对上下文中的现有术语使用情况，优先沿用已统一的中文翻译；避免机械替换术语，需结合语境确认是否真正存在不一致问题。"
    },
    {
      "defect_id": 466110,
      "sentence": "从API version 20开始，支持该字段。",
      "reference_sentence": "从API version 17开始，支持该字段。",
      "line_num": 158,
      "context": "{\"153\":\"| [hnpPackages](#hnppackages标签) | 标识当前应用包含的Native软件包信息。只允许entry类型模块配置。 | 对象数组 | 该标签可缺省，缺省值为空。 |\",\"154\":\"| [systemTheme](#systemtheme标签) | 标识当前使用的系统主题配置项。只允许entry类型模块配置。取值为不超过255字节的字符串。<br/>**说明：** <br/>从API version 20开始，支持该字段。 | 字符串 | 该标签可缺省，缺省值为空。 |\",\"155\":\"| abilitySrcEntryDelegator | 标识当前Module需要重定向到的UIAbility的名称，与abilityStageSrcEntryDelegator字段组合使用，共同指定重定向的目标对象。<br/>**说明：**<br/>1.从API version 17开始，支持该字段。<br/>2.当UIAbility是通过[startAbilityByCall](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#startabilitybycall)接口启动时，该字段不生效。<br/>3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。 | 字符串 | 该标签可缺省，缺省值为空。 |\",\"156\":\"| abilityStageSrcEntryDelegator | 标识当前Module需要重定向到的UIAbility对应的Module名称（不可为当前Module名称），与abilitySrcEntryDelegator字段组合使用，共同指定重定向的目标对象。<br/>**说明：**<br/>1.从API version 17开始，支持该字段。<br/>2.当UIAbility是通过[startAbilityByCall](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#startabilitybycall)接口启动时，该字段不生效。<br/>3.不支持在HAR的配置文件中配置该字段，也不支持重定向到HAR的UIAbility。 | 字符串 | 该标签可缺省，缺省值为空。 |\",\"157\":\"| deviceFeatures | 标识当前Module需要的特定的设备能力，应用市场可以根据此配置，将应用分发给支持该能力的设备。该字段支持配置0-3个枚举值，无顺序要求，枚举值取值如下：<br/>-&nbsp;multi_process：多进程能力，表示设备支持创建子进程的能力。<br/>-&nbsp;free_multi_window：自由多窗能力，表示设备支持窗口最大化、最小化、悬浮、矩形区域变化的能力。<br/>-&nbsp;directory_permission：公共目录授权能力，表示当前Module需要被设备授权，能够访问文档、图片等公共目录。<br/>**说明：**<br/>1.从API version 19开始，支持该字段。<br/>2.不支持插件应用配置。 | 字符串数组 | 该标签可缺省，缺省值为空。 |\",\"158\":\"| crossAppSharedConfig | 标识应用间共享配置的配置文件名。取值为不超过255字节的字符串。用于发布配置给其他应用读取，在应用安装时生效，应用卸载时失效。详细使用方式见[共享配置使用](../database/share-config.md#配置发布方)。<br/>从API version 20开始，支持该字段。 | 字符串 | 该标签可缺省，缺省值为空。 |\",\"159\":\"\",\"160\":\"## deviceTypes标签\",\"161\":\"\",\"162\":\"  **表2** deviceTypes标签说明\",\"163\":\"<!--RP2-->\"}",
      "用户拒绝的修改": "从API version 17开始，支持该字段。",
      "注意事项": "修复时必须严格核对上下文中的具体版本号，避免跨标签引用错误；确保版本号修改与用户反馈的实际支持版本完全匹配，不可依赖其他标签的版本信息进行推断。"
    },
    {
      "defect_id": 465091,
      "sentence": "销毁划词面板。使用promise异步回调。",
      "reference_sentence": "创建划词面板，仅支持带有划词功能的三方应用调用。使用Promise异步回调。",
      "line_num": 139,
      "context": "{\"134\":\"  });\",\"135\":\"```\",\"136\":\"\",\"137\":\"## destroyPanel\",\"138\":\"\",\"139\":\"destroyPanel(panel: Panel): Promise\\\\<void>\",\"140\":\"\",\"141\":\"销毁划词面板。使用promise异步回调。\",\"142\":\"\",\"143\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"144\":\"\"}",
      "用户拒绝的修改": "销毁划词面板。使用Promise异步回调。",
      "注意事项": "修复术语大小写不一致时，需优先检查相邻上下文和已有参考句子的统一风格，避免仅依据局部规则修改而破坏文档整体一致性；若用户已明确声明特定位置的统一规则，应以用户指示为准。"
    },
    {
      "defect_id": 465109,
      "sentence": "显示划词面板，使用promise异步回调。",
      "reference_sentence": "隐藏当前划词面板，使用promise异步回调。",
      "line_num": 273,
      "context": "{\"268\":\"\",\"269\":\"### show\",\"270\":\"\",\"271\":\"show(): Promise\\\\<void>\",\"272\":\"\",\"273\":\"显示划词面板，使用promise异步回调。\",\"274\":\"\",\"275\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"276\":\"\",\"277\":\"**返回值：**\",\"278\":\"\"}",
      "用户拒绝的修改": "显示当前划词面板，使用promise异步回调。",
      "注意事项": "修复时需全面核查上下文术语一致性，优先保持已有统一表述，避免在已规范化的术语中新增冗余修饰词（如\"当前\"），除非上下文明确存在对比需求。"
    },
    {
      "defect_id": 465255,
      "sentence": "划词面板类型枚举。",
      "reference_sentence": "划词面板属性信息。",
      "line_num": 31,
      "context": "{\"26\":\"| width | number | 否 | 否 | 划词面板宽度。 |\",\"27\":\"| height | number | 否 | 否 | 划词面板高度。 |\",\"28\":\"\",\"29\":\"## PanelType\",\"30\":\"\",\"31\":\"划词面板类型枚举。\",\"32\":\"\",\"33\":\"**系统能力**：SystemCapability.SelectionInput.Selection\",\"34\":\"\",\"35\":\"| 名称          | 值   | 说明         |\",\"36\":\"| ------------- | ---- | ------------ |\"}",
      "用户拒绝的修改": "划词面板类型枚举值。",
      "注意事项": "修复时应严格对照上下文相邻条目和参考句子的命名结构（如\"属性信息\"与\"类型枚举\"的后缀匹配），避免在未明确歧义的情况下擅自添加/删减术语成分（如\"值\"）。"
    },
    {
      "defect_id": 465110,
      "sentence": "移动划词面板，使用promise异步回调。",
      "reference_sentence": "隐藏当前划词面板，使用promise异步回调。",
      "line_num": 343,
      "context": "{\"338\":\"\",\"339\":\"### startMoving\",\"340\":\"\",\"341\":\"startMoving(): Promise\\\\<void>\",\"342\":\"\",\"343\":\"移动划词面板，使用promise异步回调。\",\"344\":\"\",\"345\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"346\":\"\",\"347\":\"**返回值：**\",\"348\":\"\"}",
      "用户拒绝的修改": "移动当前划词面板，使用promise异步回调。",
      "注意事项": "修复时应优先核查上下文及全局文档的术语统一性，避免仅依赖局部参考；确认用户是否已完成全局修改，避免重复添加已统一的关键词（如\"当前\"）。"
    },
    {
      "defect_id": 465119,
      "sentence": "移动面板至屏幕指定位置，使用promise异步回调。",
      "reference_sentence": "移动划词面板，使用promise异步回调。",
      "line_num": 386,
      "context": "{\"381\":\"\",\"382\":\"### moveTo\",\"383\":\"\",\"384\":\"moveTo(x: number, y: number): Promise\\\\<void>\",\"385\":\"\",\"386\":\"移动面板至屏幕指定位置，使用promise异步回调。\",\"387\":\"\",\"388\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"389\":\"\",\"390\":\"**参数：**\",\"391\":\"\"}",
      "用户拒绝的修改": "移动划词面板至屏幕指定位置，使用promise异步回调。",
      "注意事项": "修复术语不一致时需优先核对当前上下文中的现有术语用法，若原文未出现全称/简称混用则保持原词；参考句子的术语使用必须与问题句所在上下文完全匹配时才适用替换。"
    },
    {
      "defect_id": 465079,
      "sentence": "取消订阅划词完成事件。使用callback异步回调。",
      "reference_sentence": "订阅划词完成事件，使用callback异步回调。",
      "line_num": 58,
      "context": "{\"53\":\"\",\"54\":\"## off('selectionCompleted')\",\"55\":\"\",\"56\":\"off(type: 'selectionCompleted', callback?: Callback\\\\<SelectionInfo>): void\",\"57\":\"\",\"58\":\"取消订阅划词完成事件。使用callback异步回调。\",\"59\":\"\",\"60\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"61\":\"\",\"62\":\"**参数：**\",\"63\":\"\"}",
      "用户拒绝的修改": "取消订阅划词完成事件，使用callback异步回调。",
      "注意事项": "修复时应严格区分\"订阅\"与\"取消订阅\"的语法场景，避免机械套用句式一致性规则；需结合API上下文验证标点修改的必要性，技术文档中分句用句号分隔是常见规范。"
    },
    {
      "defect_id": 465090,
      "sentence": "使用promise异步回调。",
      "reference_sentence": "使用Promise异步回调。",
      "line_num": 141,
      "context": "{\"136\":\"\",\"137\":\"## destroyPanel\",\"138\":\"\",\"139\":\"destroyPanel(panel: Panel): Promise\\\\<void>\",\"140\":\"\",\"141\":\"销毁划词面板。使用promise异步回调。\",\"142\":\"\",\"143\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"144\":\"\",\"145\":\"**参数：**\",\"146\":\"\"}",
      "用户拒绝的修改": "使用Promise异步回调。",
      "注意事项": "修复前需结合上下文确认术语实际使用场景，区分普通词汇与技术术语(如JavaScript的Promise对象)，避免机械统一大小写导致误判；优先参照同类API文档中的规范写法进行一致性修复。"
    },
    {
      "defect_id": 465080,
      "sentence": "单个划词应用仅允许创建一个[主面板类型](./js-apis-selectionInput-selectionPanel.md)和[菜单面板类型](./js-apis-selectionInput-selectionPanel.md)的窗口。",
      "reference_sentence": "创建划词面板，仅支持带有划词功能的三方应用调用。使用promise异步回调。",
      "line_num": 92,
      "context": "{\"87\":\"\",\"88\":\"createPanel(ctx: Context, info: PanelInfo): Promise\\\\<Panel>\",\"89\":\"\",\"90\":\"创建划词面板，仅支持带有划词功能的三方应用调用。使用promise异步回调。\",\"91\":\"\",\"92\":\"单个划词应用仅允许创建一个[主面板类型](./js-apis-selectionInput-selectionPanel.md)和[菜单面板类型](./js-apis-selectionInput-selectionPanel.md)的窗口。\",\"93\":\"\",\"94\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"95\":\"\",\"96\":\"**参数：**\",\"97\":\"\"}",
      "用户拒绝的修改": "单个划词应用仅允许创建一个[主面板类型](./js-apis-selectionInput-selectionPanel.md)和一个[菜单面板类型](./js-apis-selectionInput-selectionPanel.md)的窗口。",
      "注意事项": "修复时应优先确保技术术语和逻辑准确性，避免机械追求句式统一而忽略上下文语义；需严格区分语法错误与合理表达差异，仅在确实存在歧义或不一致时进行修正。"
    },
    {
      "defect_id": 465256,
      "sentence": "本模块提供划词面板的属性信息和类型。",
      "reference_sentence": "划词面板属性信息。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.selectionInput.SelectionPanel (划词面板)\",\"2\":\"\",\"3\":\"本模块提供划词面板的属性信息和类型。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\">本模块首批接口从API version 20开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\"\"}",
      "用户拒绝的修改": "本模块提供划词面板的属性信息。",
      "注意事项": "修复时应先确认上下文是否存在其他相关术语或技术概念（如\"类型\"是否在模块中实际存在），避免仅依据单一参考句子过度简化表述，同时需结合技术准确性判断是否属于冗余信息或必要内容。"
    },
    {
      "defect_id": 469399,
      "sentence": "在[ContentCoverOptions](ts-universal-attributes-modal-transition.md#contentcoveroptions)中，从API version 11开始，该接口支持在原子化服务中使用。在[BindOptions](#bindoptions)中从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "默认值：Color.White。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 106,
      "context": "{\"101\":\"半模态、全模态的公共配置接口。\",\"102\":\"\",\"103\":\"| 名称            | 类型                                       | 必填 | 说明                     |\",\"104\":\"| --------------- | ------------------------------------------ | ---- | ------------------------ |\",\"105\":\"| backgroundColor | [ResourceColor](ts-types.md#resourcecolor) | 否   | 半模态页面的背板颜色。<br />默认值：Color.White。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"106\":\"| modalTransition | [ModalTransition](ts-types.md#modaltransition10) | 否 | 半模态全屏样式和全屏模态的系统转场方式。<br/>默认值：ModalTransition.DEFAULT<br/>**说明：**<br />和transition同时设置时，此属性不生效。<br />**原子化服务API：** 在[ContentCoverOptions](ts-universal-attributes-modal-transition.md#contentcoveroptions)中，从API version 11开始，该接口支持在原子化服务中使用。在[BindOptions](#bindoptions)中从API version 20开始，该接口支持在原子化服务中使用。 |\",\"107\":\"| onWillAppear<sup>12+</sup>        | () => void                                 | 否   | 半模态页面显示（动画开始前）回调函数。**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"108\":\"| onAppear        | () => void                                 | 否   | 半模态页面显示（动画结束后）回调函数。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"109\":\"| onWillDisappear<sup>12+</sup>     | () => void                                 | 否   | 半模态页面回退（动画开始前）回调函数。<br />**说明：**<br />不允许在onWillDisappear函数中修改状态变量，可能会导致组件行为不稳定。**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"110\":\"| onDisappear     | () => void                                 | 否   | 半模态页面回退（动画结束后）回调函数。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"111\":\"\"}",
      "用户拒绝的修改": "在[ContentCoverOptions](ts-universal-attributes-modal-transition.md#contentcoveroptions)中，从API version 11开始，该接口支持在原子化服务中使用。在[BindOptions](#bindoptions)中，从API version 20开始，该接口支持在原子化服务中使用。",
      "注意事项": "修复时需同时检查技术背景准确性（如接口层级变化导致的版本号差异）和格式一致性，确保修改不仅符合标点规范，还要验证版本变更原因是否与上下文中的接口迁移说明一致。"
    },
    {
      "defect_id": 470404,
      "sentence": "表示数据更新。",
      "reference_sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "line_num": 67,
      "context": "{\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\",\"71\":\"共享配置的数据结构。\",\"72\":\"\"}",
      "用户拒绝的修改": "表示数据的更新。",
      "注意事项": "修复时应优先检查上下文中的现有表达模式（如\"数据添加\"/\"数据删除\"的无\"的\"结构），避免机械添加修饰词破坏整体一致性，确保修改后的句式与相邻条目保持完全平行。"
    },
    {
      "defect_id": 470401,
      "sentence": "返回DataProxyHandle实例。",
      "reference_sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"**返回值：**\",\"28\":\"\",\"29\":\"| 类型                                               | 说明                                   |\",\"30\":\"| -------------------------------------------------- | -------------------------------------- |\",\"31\":\"| Promise&lt;[DataProxyHandle](#dataproxyhandle20)&gt; | Promise对象。返回DataProxyHandle实例。 |\",\"32\":\"\",\"33\":\"**错误码：**\",\"34\":\"\",\"35\":\"错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。\",\"36\":\"\"}",
      "用户拒绝的修改": "Promise对象。返回DataProxyHandle的实例。",
      "注意事项": "修复时应优先保持技术术语的惯用表达，避免机械添加助词破坏术语完整性；同时需结合上下文格式（如表格中的简洁性要求）判断修改必要性，确保语法调整不影响技术文档的专业性和功能性。"
    },
    {
      "defect_id": 470403,
      "sentence": "表示数据删除。",
      "reference_sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "line_num": 66,
      "context": "{\"61\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\",\"71\":\"共享配置的数据结构。\"}",
      "用户拒绝的修改": "表示数据的删除。",
      "注意事项": "修复时应优先检查相邻条目或上下文的结构一致性，确保修改后的句式与周边内容保持统一；在技术文档中需尊重术语简洁性，避免添加冗余助词（如“的”）破坏原有术语规范。"
    },
    {
      "defect_id": 470400,
      "sentence": "数据变更类型枚举。",
      "reference_sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "line_num": 59,
      "context": "{\"54\":\"};\",\"55\":\"```\",\"56\":\"\",\"57\":\"## ChangeType<sup>20+</sup>\",\"58\":\"\",\"59\":\"数据变更类型枚举。\",\"60\":\"\",\"61\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\"}",
      "用户拒绝的修改": "数据变更类型的枚举。",
      "注意事项": "在确保用词一致性的同时需优先保持技术文档的简洁性，避免过度添加冗余助词（如\"的\"）；修复前应结合上下文判断原句是否为符合技术文档惯例的紧凑型表达（如标题/枚举项）。"
    },
    {
      "defect_id": 470482,
      "sentence": "如果获取操作成功，则为共享配置的值；如果获取操作失败，则未定义。",
      "reference_sentence": "如果获取操作成功，则为共享配置的值；如果获取操作失败，则未定义。",
      "line_num": 127,
      "context": "{\"122\":\"\",\"123\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"124\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\",\"125\":\"| uri        | string                                                      | 是   | 被操作的URI。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"126\":\"| result  |  [DataProxyErrorCode](#dataproxyerrorcode20)                   | 是   | 操作结果的错误码。|\",\"127\":\"| value  |  [ValueType](js-apis-data-valuesBucket.md#valuetype) \\\\| undefined  | 是   | 如果获取操作成功，则为共享配置的值；如果获取操作失败，则未定义。|\",\"128\":\"| allowList  |  string\\\\[] \\\\| undefined                             | 是   | 如果获取操作成功，则为共享配置的允许列表；如果获取操作失败，则未定义。只有发布者才能获取允许列表，其他应用只能获取值。|\",\"129\":\"\",\"130\":\"## DataProxyType<sup>20+</sup>\",\"131\":\"\",\"132\":\"数据代理类型的枚举。\"}",
      "用户拒绝的修改": "如果获取操作成功，则为共享配置的值；如果获取操作失败，则为undefined。",
      "注意事项": "修复时应严格区分中英文术语使用场景，在中文说明部分优先使用中文技术术语\"未定义\"，仅在代码字段或类型定义等特定语境保留英文术语\"undefined\"，避免破坏文档语境一致性。"
    },
    {
      "defect_id": 470457,
      "sentence": "通知订阅者共享配置变更的数据结构。包括数据变更类型、变化的URI、变更的数据内容。",
      "reference_sentence": "共享配置的数据结构。",
      "line_num": 83,
      "context": "{\"78\":\"| value      | [ValueType](js-apis-data-valuesBucket.md#valuetype)         | 否   | 共享配置的值。不填则为空字符串。字符串长度不超过4096个字节。当首次发布共享配置时，如果未填写，将默认设置为空字符串。在更新共享配置时，如果未填写，共享配置的值将不会被更新。     |\",\"79\":\"| allowList  | string\\\\[]                                         | 否   | 允许订阅和读取共享配置的应用程序列表。不填则为空的字符串数组。数组最大长度为256，超过256的部分不生效。数组中每个元素为应用的[appIdentifier](../../quick-start/common_problem_of_application.md#什么是appidentifier)，单个appIdentifier最大长度128字节，超过128字节的appIdentifier不会生效。当首次发布共享配置时，如果未填写，将默认为空的允许列表。在更新共享配置时，如果未填写，共享配置的允许列表将不会被更新。一个空的允许列表表示只有发布者能够访问该共享配置。 |\",\"80\":\"\",\"81\":\"## DataProxyChangeInfo<sup>20+</sup>\",\"82\":\"\",\"83\":\"通知订阅者共享配置变更的数据结构。包括数据变更类型、变化的URI、变更的数据内容。\",\"84\":\"\",\"85\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"86\":\"\",\"87\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"88\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\"}",
      "用户拒绝的修改": "通知订阅者配置共享变更的数据结构。包括数据变更类型、变化的URI、变更的数据内容。",
      "注意事项": "保持原文固定术语的完整性和词序一致性，避免调整已形成技术概念的复合词组（如\"共享配置\"）；修改前需核对上下文术语使用情况，确保同一概念在全文中保持完全一致的表达方式。"
    },
    {
      "defect_id": 470402,
      "sentence": "表示数据添加。",
      "reference_sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\"}",
      "用户拒绝的修改": "表示数据的添加。",
      "注意事项": "修复时应优先检查上下文中的现有表达模式（如表格中其他条目均未使用\"的\"字），确保局部一致性高于机械遵循语法规则，避免过度修正破坏原有格式统一性。"
    },
    {
      "defect_id": 470405,
      "sentence": "| ARKUI_HIT_TEST_MODE_BLOCK_DESCENDANTS  | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试。  |\r",
      "reference_sentence": "| ARKUI_HIT_TEST_MODE_NONE  | 自身不响应触摸测试。  |",
      "line_num": 3005,
      "context": "{\"3000\":\"| ARKUI_HIT_TEST_MODE_DEFAULT  | 默认触摸测试效果。  |\",\"3001\":\"| ARKUI_HIT_TEST_MODE_BLOCK  | 自身响应触摸测试。  |\",\"3002\":\"| ARKUI_HIT_TEST_MODE_TRANSPARENT  | 自身和子节点都响应触摸测试。  |\",\"3003\":\"| ARKUI_HIT_TEST_MODE_NONE  | 自身不响应触摸测试。  |\",\"3004\":\"| ARKUI_HIT_TEST_MODE_BLOCK_HIERARCHY  | 阻止所有优先级较低的兄弟节点和父节点参与触摸测试，自身和子节点响应触摸测试。  |\",\"3005\":\"| ARKUI_HIT_TEST_MODE_BLOCK_DESCENDANTS  | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试。  |\",\"3006\":\"\",\"3007\":\"\",\"3008\":\"### ArkUI_HorizontalAlignment\",\"3009\":\"\",\"3010\":\"```\"}",
      "用户拒绝的修改": "| ARKUI_HIT_TEST_MODE_BLOCK_DESCENDANTS  | 自身不响应触摸测试，并且所有的子节点也不响应触摸测试。  |\r",
      "注意事项": "修复时应优先检查文档中已存在的术语使用惯例，确保\"后代\"与\"子节点\"等层级关系术语的全局一致性，若上下文存在混合使用需确认具体技术定义，避免擅自替换已正确表达技术含义的词汇。"
    },
    {
      "defect_id": 470460,
      "sentence": "配置共享批量获取操作结果的数据结构。",
      "reference_sentence": "共享配置的数据结构。",
      "line_num": 119,
      "context": "{\"114\":\"| uri        | string                                                      | 是   | 被操作的URI。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"115\":\"| result  |  [DataProxyErrorCode](#dataproxyerrorcode20)                   | 是   | 操作结果的错误码。|\",\"116\":\"\",\"117\":\"## DataProxyGetResult<sup>20+</sup>\",\"118\":\"\",\"119\":\"配置共享批量获取操作结果的数据结构。\",\"120\":\"\",\"121\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"122\":\"\",\"123\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"124\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\"}",
      "用户拒绝的修改": "共享配置批量获取操作结果的数据结构。",
      "注意事项": "修复时应优先识别并沿用上下文中的固定术语（如“共享配置”），避免仅调整词序破坏技术概念的统一性；需结合领域规范判断词汇是否为专有名词，禁止机械式替换导致语义偏差。"
    },
    {
      "defect_id": 470459,
      "sentence": "配置共享批量操作结果的数据结构。",
      "reference_sentence": "共享配置的数据结构。",
      "line_num": 108,
      "context": "{\"103\":\"| NO_PERMISSION  | 2                                                       | 没有权限在该URI上执行此操作。 |\",\"104\":\"| OVER_LIMIT     | 3                                                       | 表示当前应用发布的配置超过32个配置的上限。  |\",\"105\":\"\",\"106\":\"## DataProxyResult<sup>20+</sup>\",\"107\":\"\",\"108\":\"配置共享批量操作结果的数据结构。\",\"109\":\"\",\"110\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"111\":\"\",\"112\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"113\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\"}",
      "用户拒绝的修改": "共享配置批量操作结果的数据结构。",
      "注意事项": "修复时应优先保留原文中的技术术语或固定搭配，避免调整已约定俗成的专业短语顺序；修改前需结合上下文确认是否存在统一表达范式，确保术语一致性高于语法优化。"
    },
    {
      "defect_id": 470576,
      "sentence": "线性进度条样式，支持属性设置，属性重置和属性获取接口，如果进度条类型不是线性样式则不生效。",
      "reference_sentence": "进度条的类型属性，支持属性设置，属性重置和属性获取接口。",
      "line_num": 3823,
      "context": "{\"3818\":\"| NODE_BUTTON_MAX_FONT_SCALE<sup>18+</sup>  | 设置文本最大的字体缩放倍数，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32: 设置Button按钮的最大字体缩放倍数，默认单位fp。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32: 获取Button按钮的最大字体缩放倍数，默认单位fp。 |\",\"3819\":\"| NODE_PROGRESS_VALUE  | 进度条的当前进度值属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32：进度条当前值。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32：进度条当前值。 |\",\"3820\":\"| NODE_PROGRESS_TOTAL  | 进度条的总长属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32：进度条总长。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].f32：进度条总长。 |\",\"3821\":\"| NODE_PROGRESS_COLOR  | 进度条显示进度值的颜色属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：颜色数值，0xargb格式，形如 0xFFFF0000 表示红色。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：颜色数值，0xargb格式。 |\",\"3822\":\"| NODE_PROGRESS_TYPE  | 进度条的类型属性，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：进度条类型枚举值[ArkUI_ProgressType](#arkui_progresstype)，默认值为ARKUI_PROGRESS_TYPE_LINEAR。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：进度条类型枚举值[ArkUI_ProgressType](#arkui_progresstype)。 |\",\"3823\":\"| NODE_PROGRESS_LINEAR_STYLE | 线性进度条样式，支持属性设置，属性重置和属性获取接口，如果进度条类型不是线性样式则不生效。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.object：使用{@link [ArkUI_ProgressLinearStyleOption](#arkui_progresslinearstyleoption)}对象设置组件样式。 <br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.object：使用{@link [ArkUI_ProgressLinearStyleOption](#arkui_progresslinearstyleoption)}对象获取组件样式。<br/>**起始版本：** 15|\",\"3824\":\"| NODE_CHECKBOX_SELECT  | CheckBox多选框是否选中，支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.value[0].i32：1表示选中，0表示不选中。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：1表示选中，0表示不选中。 |\",\"3825\":\"| NODE_CHECKBOX_SELECT_COLOR  | CheckBox多选框选中状态颜色，支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.value[0].u32：多选框选中状态颜色, 类型为0xargb，如0xFF1122FF。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：多选框选中状态颜色, 类型为0xargb，如0xFF1122FF。 |\",\"3826\":\"| NODE_CHECKBOX_UNSELECT_COLOR  | CheckBox多选框非选中状态边框颜色，支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.value[0].u32：边框颜色, 类型为0xargb，如0xFF1122FF。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：边框颜色, 类型为0xargb，如0xFF1122FF。 |\",\"3827\":\"| NODE_CHECKBOX_MARK  | CheckBox多选框内部图标样式，支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.value[0].u32：边框颜色, 类型为0xargb，如0xFF1122FF；<br/>.value[1]?.f32：可选，内部图标大小，单位vp；<br/>.value[2]?.f32：可选，内部图标粗细，单位vp，默认值2。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：边框颜色, 类型为0xargb，如0xFF1122FF；<br/>.value[1].f32：内部图标大小，单位vp；<br/>.value[2].f32：内部图标粗细，单位vp，默认值2。 |\",\"3828\":\"| NODE_CHECKBOX_SHAPE  | CheckBox组件形状, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.value[0].i32：组件形状，参数类型[ArkUI_CheckboxShape](#arkui_checkboxshape)。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：组件形状，参数类型[ArkUI_CheckboxShape](#arkui_checkboxshape)。 |\"}",
      "用户拒绝的修改": "线性进度条样式，支持属性设置、属性重置和属性获取接口，如果进度条类型不是线性样式则不生效。",
      "注意事项": "在修复并列结构标点一致性时，需优先检查文档全局惯例（如逗号/顿号使用偏好），若上下文同类描述均使用逗号分隔，则不应强行改为顿号；同时需区分\"接口\"是否属于独立术语，避免因过度统一破坏已有术语体系。"
    },
    {
      "defect_id": 470483,
      "sentence": "如果获取操作成功，则为共享配置的允许列表；如果获取操作失败，则未定义。只有发布者才能获取允许列表，其他应用只能获取值。",
      "reference_sentence": "如果获取操作成功，则为共享配置的允许列表；如果获取操作失败，则未定义。只有发布者才能获取允许列表，其他应用只能获取值。",
      "line_num": 128,
      "context": "{\"123\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"124\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\",\"125\":\"| uri        | string                                                      | 是   | 被操作的URI。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"126\":\"| result  |  [DataProxyErrorCode](#dataproxyerrorcode20)                   | 是   | 操作结果的错误码。|\",\"127\":\"| value  |  [ValueType](js-apis-data-valuesBucket.md#valuetype) \\\\| undefined  | 是   | 如果获取操作成功，则为共享配置的值；如果获取操作失败，则未定义。|\",\"128\":\"| allowList  |  string\\\\[] \\\\| undefined                             | 是   | 如果获取操作成功，则为共享配置的允许列表；如果获取操作失败，则未定义。只有发布者才能获取允许列表，其他应用只能获取值。|\",\"129\":\"\",\"130\":\"## DataProxyType<sup>20+</sup>\",\"131\":\"\",\"132\":\"数据代理类型的枚举。\",\"133\":\"\"}",
      "用户拒绝的修改": "如果获取操作成功，则为共享配置的允许列表；如果获取操作失败，则为undefined。只有发布者才能获取允许列表，其他应用只能获取值。",
      "注意事项": "在保持术语一致性时需区分代码字段与自然语言描述场景，若上下文存在中英文术语混用规范，应优先遵循原文的语义分层（代码字段用undefined，中文描述用\"未定义\"），避免跨语境强行统一用词。"
    },
    {
      "defect_id": 470545,
      "sentence": "当有其他用户触发了变更通知时会回调该函数。",
      "reference_sentence": "订阅指定URI对应共享配置变更事件。若订阅者已注册变更通知，当配置发布方修改配置时，订阅者将会接收到callback通知，通知携带数据变更类型、变化的URI、变更的共享配置内容。",
      "line_num": 172,
      "context": "{\"167\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"168\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"169\":\"| event     | string                        | 是   | 订阅的事件/回调类型，支持的事件为'dataChange'，当有其他用户触发了变更通知时，触发该事件。 |\",\"170\":\"| uris     | string\\\\[]             | 是   | 表示要订阅的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"171\":\"| config      | [DataProxyConfig](#dataproxyconfig20)               | 是   | 表示数据代理操作的配置。 |\",\"172\":\"| callback | AsyncCallback&lt;[DataProxyChangeInfo](#dataproxychangeinfo20)\\\\[]&gt; | 是   | 回调函数。当有其他用户触发了变更通知时会回调该函数。|\",\"173\":\"\",\"174\":\"**返回值：**\",\"175\":\"\",\"176\":\"| 类型             | 说明                                                         |\",\"177\":\"| ---------------- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "当有其他用户触发了变更通知时会接收到该函数的回调。",
      "注意事项": "严格区分动作主体和被动接收方，保持\"触发\"与\"接收\"的语义连贯性。当描述主动触发行为时，应保持\"触发+事件\"的固定搭配；描述被动接收时，需确保主语与\"接收\"动作的逻辑一致性（如参考句中的\"订阅者接收到通知\"）。"
    },
    {
      "defect_id": 470583,
      "sentence": "Promise对象。返回批量获取操作的结果数组。",
      "reference_sentence": "批量获取操作的结果数组。",
      "line_num": 383,
      "context": "{\"378\":\"\",\"379\":\"**返回值：**\",\"380\":\"\",\"381\":\"| 类型             | 说明                                                         |\",\"382\":\"| ---------------- | ------------------------------------------------------------ |\",\"383\":\"| Promise&lt;[DataProxyGetResult](#dataproxygetresult20)\\\\[]&gt; | Promise对象。返回批量获取操作的结果数组。|\",\"384\":\"\",\"385\":\"**错误码：**\",\"386\":\"\",\"387\":\"以下错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。\",\"388\":\"\"}",
      "用户拒绝的修改": "返回批量获取操作的结果数组。",
      "注意事项": "修复时应优先保留原句核心主语（如\"Promise对象\"），仅调整用词一致性而非删除必要信息；需结合上下文判断\"返回\"动作的主语是否隐含，若显式存在则保持\"主语+动词+宾语\"的完整结构。"
    },
    {
      "defect_id": 470546,
      "sentence": "取消订阅指定URI对应代理数据变更事件。",
      "reference_sentence": "订阅指定URI对应共享配置变更事件。",
      "line_num": 215,
      "context": "{\"210\":\"\",\"211\":\"### off('dataChange')<sup>20+</sup>\",\"212\":\"\",\"213\":\"off(event: 'dataChange', uris: string[], config: DataProxyConfig, callback?: AsyncCallBack&lt;DataProxyChangeInfo[]&gt;): DataProxyResult[]\",\"214\":\"\",\"215\":\"取消订阅指定URI对应代理数据变更事件。仅支持静默访问。\",\"216\":\"\",\"217\":\"**系统能力：**  SystemCapability.DistributedDataManager.DataShare.Consumer\",\"218\":\"\",\"219\":\"**参数：**\",\"220\":\"\"}",
      "用户拒绝的修改": "取消订阅指定URI对应共享配置变更事件。",
      "注意事项": "修复时必须严格匹配上下文中的术语使用（如“代理数据”与接口参数dataChange的对应关系），避免跨上下文引用其他模块的术语（如“共享配置”）；优先检查问题句所在接口的原始参数命名和已有参考案例，确保术语一致性。"
    },
    {
      "defect_id": 470570,
      "sentence": "表示共享配置的类型。",
      "reference_sentence": "表示数据代理操作的配置。",
      "line_num": 331,
      "context": "{\"326\":\"**参数：**\",\"327\":\"\",\"328\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"329\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"330\":\"| uris     | string\\\\[]          | 是   | 表示需要删除的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"331\":\"| config   | [DataProxyConfig](#dataproxyconfig20)   | 是   | 表示共享配置的类型。 |\",\"332\":\"\",\"333\":\"**返回值：**\",\"334\":\"\",\"335\":\"| 类型             | 说明                                                         |\",\"336\":\"| ---------------- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "表示数据代理操作的配置。",
      "注意事项": "在统一术语时需结合上下文确认替换后的词汇是否准确匹配参数的技术定义（如\"类型\"特指数据类型时不可替换为\"配置\"），同时检查相邻参数描述中同类术语的使用一致性。"
    },
    {
      "defect_id": 470547,
      "sentence": "表示指定取消订阅的callback通知，如果为空、undefined或null，则取消订阅这些URI下所有的通知事件。",
      "reference_sentence": "当有其他用户触发了变更通知时会回调该函数。",
      "line_num": 226,
      "context": "{\"221\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"222\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"223\":\"| event     | string                        | 是   | 订阅的事件/回调类型，支持的事件为'dataChange'。 |\",\"224\":\"| uris     | string\\\\[]             | 是   | 表示要取消订阅的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"225\":\"| config      | [DataProxyConfig](#dataproxyconfig20)               | 是   | 表示数据代理操作的配置。 |\",\"226\":\"| callback | AsyncCallback&lt;[DataProxyChangeInfo](#dataproxychangeinfo20)\\\\[]&gt; | 否   | 回调函数。表示指定取消订阅的callback通知，如果为空、undefined或null，则取消订阅这些URI下所有的通知事件。|\",\"227\":\"\",\"228\":\"**返回值：**\",\"229\":\"\",\"230\":\"| 类型             | 说明                                                         |\",\"231\":\"| ---------------- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "表示指定取消订阅的回调通知，如果为空、undefined或null，则取消订阅这些URI下所有的通知事件。",
      "注意事项": "修复术语一致性时需严格检查上下文使用习惯，若参数名/字段保持英文形式（如\"callback\"），说明部分的中文翻译应保持\"回调\"对应，避免在中英文混用场景中强行统一术语。"
    },
    {
      "defect_id": 470543,
      "sentence": "触发通知：配置发布方调用[publish](#publish20)、[delete](#delete20)接口发布、删除配置时会自动触发通知。",
      "reference_sentence": "在调用DataProxyHandle提供的方法前，需要先通过[createDataProxyHandle](#datasharecreatedataproxyhandle20)构建一个实例。",
      "line_num": 161,
      "context": "{\"156\":\"\",\"157\":\"on(event: 'dataChange', uris: string[], config: DataProxyConfig, callback: AsyncCallBack&lt;DataProxyChangeInfo[]&gt;): DataProxyResult[]\",\"158\":\"\",\"159\":\"订阅指定URI对应共享配置变更事件。若订阅者已注册变更通知，当配置发布方修改配置时，订阅者将会接收到callback通知，通知携带数据变更类型、变化的URI、变更的共享配置内容。使用callback回调。仅支持静默访问。该功能不支持跨用户订阅通知，不支持订阅未发布的配置。订阅成功后若权限被收回，则后续不再通知订阅者。\",\"160\":\"\",\"161\":\"触发通知：配置发布方调用[publish](#publish20)、[delete](#delete20)接口发布、删除配置时会自动触发通知。\",\"162\":\"\",\"163\":\"**系统能力：**  SystemCapability.DistributedDataManager.DataShare.Consumer\",\"164\":\"\",\"165\":\"**参数：**\",\"166\":\"\"}",
      "用户拒绝的修改": "触发通知：配置发布方调用[publish](#publish20)、[delete](#delete20)接口发布或删除配置时会自动触发通知。",
      "注意事项": "保持并列动作的原始逻辑关系，优先使用原文的标点符号（如顿号）而非替换为逻辑连接词（如\"或\"），确保技术场景中\"同时触发\"的语义不被弱化为\"二选一\"。"
    },
    {
      "defect_id": 470458,
      "sentence": "配置共享批量操作返回值的状态码枚举。",
      "reference_sentence": "共享配置的数据结构。",
      "line_num": 95,
      "context": "{\"90\":\"| uri       | string                                                        | 是   | 通知变更指定URI。|\",\"91\":\"| value     | [ValueType](js-apis-data-valuesBucket.md#valuetype)             | 是   | 更新的数据。     |\",\"92\":\"\",\"93\":\"## DataProxyErrorCode<sup>20+</sup>\",\"94\":\"\",\"95\":\"配置共享批量操作返回值的状态码枚举。\",\"96\":\"\",\"97\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"98\":\"\",\"99\":\"| 名称       | 值                                                          | 说明           |\",\"100\":\"| ---------- | ----------------------------------------------------------| -------------- |\"}",
      "用户拒绝的修改": "共享配置批量操作返回值的状态码枚举。",
      "注意事项": "修复时应严格遵循上下文中的术语固定搭配（如“共享配置”在参考句子中作为固定名词使用），避免仅根据语感调整词语顺序导致语义偏移；修改前需确认原文是否存在实际表达问题，若仅为同义词替换但未影响一致性时优先保留原表述。"
    },
    {
      "defect_id": 470544,
      "sentence": "当有其他用户触发了变更通知时，触发该事件。",
      "reference_sentence": "订阅指定URI对应共享配置变更事件。若订阅者已注册变更通知，当配置发布方修改配置时，订阅者将会接收到callback通知，通知携带数据变更类型、变化的URI、变更的共享配置内容。",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"**参数：**\",\"166\":\"\",\"167\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"168\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"169\":\"| event     | string                        | 是   | 订阅的事件/回调类型，支持的事件为'dataChange'，当有其他用户触发了变更通知时，触发该事件。 |\",\"170\":\"| uris     | string\\\\[]             | 是   | 表示要订阅的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"171\":\"| config      | [DataProxyConfig](#dataproxyconfig20)               | 是   | 表示数据代理操作的配置。 |\",\"172\":\"| callback | AsyncCallback&lt;[DataProxyChangeInfo](#dataproxychangeinfo20)\\\\[]&gt; | 是   | 回调函数。当有其他用户触发了变更通知时会回调该函数。|\",\"173\":\"\",\"174\":\"**返回值：**\"}",
      "用户拒绝的修改": "当有其他用户触发了变更通知时，接收到该事件。",
      "注意事项": "严格区分事件触发主体和接收主体，确保\"触发\"仅用于描述主动发起动作的发布方，对订阅方统一使用\"接收\"类动词；修复时需交叉验证上下文术语使用一致性，避免单句内重复使用相同动词指代不同主体。"
    },
    {
      "defect_id": 470582,
      "sentence": "Promise对象。返回批量操作的结果数组。",
      "reference_sentence": "批量操作的结果数组。",
      "line_num": 337,
      "context": "{\"332\":\"\",\"333\":\"**返回值：**\",\"334\":\"\",\"335\":\"| 类型             | 说明                                                         |\",\"336\":\"| ---------------- | ------------------------------------------------------------ |\",\"337\":\"| Promise&lt;[DataProxyResult](#dataproxyresult20)\\\\[]&gt; | Promise对象。返回批量操作的结果数组。|\",\"338\":\"\",\"339\":\"**错误码：**\",\"340\":\"\",\"341\":\"以下错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。\",\"342\":\"\"}",
      "用户拒绝的修改": "返回批量操作的结果数组。",
      "注意事项": "修复时应优先保留必要上下文信息（如\"Promise对象\"），仅调整不一致的用词结构（如将\"返回\"改为\"操作的结果\"或统一使用单一动词），避免因过度删减导致语义缺失。"
    },
    {
      "defect_id": 470948,
      "sentence": "| dragBar         | 不支持拖动条。  |",
      "reference_sentence": "| dragBar         | 不支持DragBar。  |",
      "line_num": 186,
      "context": "{\"181\":\"| 名称             | 说明              |\",\"182\":\"| --------------- |  --------------- |\",\"183\":\"| height          | 高度只支持全屏高度。 |\",\"184\":\"| width           | 宽度只支持全屏宽度。 |\",\"185\":\"| detents | 无挡位能力。|\",\"186\":\"| dragBar         | 不支持拖动条。  |\",\"187\":\"| onDetentsDidChange | 无挡位能力。|\",\"188\":\"| showClose          | 不支持显示关闭按钮。 |\",\"189\":\"| title          | 不支持显示标题栏。 |\",\"190\":\"| uiContext | 不支持指定显示层级。|\",\"191\":\"| mode | 不支持指定显示层级。 |\"}",
      "用户拒绝的修改": "| dragBar         | 不支持DragBar。  |",
      "注意事项": "修复时应优先检查上下文语言环境，确保术语翻译与前后条目保持中文一致性，避免中英文混杂；若原文存在技术术语需保留英文，需通过用户反馈确认偏好后再调整。"
    },
    {
      "defect_id": 471901,
      "sentence": "cpp 部分代码：",
      "reference_sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"### OH_JSVM_CoerceToBool\",\"32\":\"\",\"33\":\"用于将一个给定的JavaScript值强制转为JavaScript boolean值。\",\"34\":\"\",\"35\":\"cpp 部分代码：\",\"36\":\"\",\"37\":\"```cpp\",\"38\":\"// hello.cpp\",\"39\":\"#include \\\"napi/native_api.h\\\"\",\"40\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "用户拒绝的修改": "C/C++ 部分代码：",
      "注意事项": "修复前需检查上下文及代码块标记（如```cpp）的术语一致性，优先匹配邻近段落和已有格式，而非全局统一替换。"
    },
    {
      "defect_id": 471629,
      "sentence": "## AnimationType<sup>20+</sup>",
      "reference_sentence": "## WindowLayoutMode<sup>9+</sup>",
      "line_num": 107,
      "context": "{\"102\":\"| OFF     | 0    | 表示关闭模糊。       |\",\"103\":\"| THIN    | 1    | 表示较薄的模糊类型。 |\",\"104\":\"| REGULAR | 2    | 表示适中的模糊类型。 |\",\"105\":\"| THICK   | 3    | 表示较厚的模糊类型。 |\",\"106\":\"\",\"107\":\"## AnimationType<sup>20+</sup>\",\"108\":\"\",\"109\":\"窗口动画类型枚举。\",\"110\":\"\",\"111\":\"**系统能力：**  SystemCapability.Window.SessionManager\",\"112\":\"\"}",
      "用户拒绝的修改": "## AnimationType<sup>9+</sup>",
      "注意事项": "修复时应优先验证版本号的实际准确性而非机械统一格式，确保版本号与API真实迭代版本一致；需结合上下文完整性和官方文档交叉核对，避免仅依据局部格式特征做出错误推断。"
    },
    {
      "defect_id": 471262,
      "sentence": "console.info('Succeeded in getting pip switch status. switchStatus: ' + JSON.stringify(data));",
      "reference_sentence": "console.info('Success in get pip window info. Info: ' + JSON.stringify(data));",
      "line_num": 880,
      "context": "{\"875\":\"let pipSwitchStatus: boolean | undefined = undefined;\",\"876\":\"try {\",\"877\":\"  let promise : Promise<boolean> = this.pipController.getPiPSettingSwitch();\",\"878\":\"  promise.then((data) => {\",\"879\":\"    pipSwitchStatus = data;\",\"880\":\"    console.info('Succeeded in getting pip switch status. switchStatus: ' + JSON.stringify(data));\",\"881\":\"  }).catch((err: BusinessError) => {\",\"882\":\"    console.error(`Failed to get pip switch status. Cause code: ${err.code}, message: ${err.message}`);\",\"883\":\"  });\",\"884\":\"} catch (exception) {\",\"885\":\"  console.error(`Failed to get pip switch status. Cause code: ${exception.code}, message: ${exception.message}`);\"}",
      "用户拒绝的修改": "console.info('Success in getting pip switch status. switchStatus: ' + JSON.stringify(data));",
      "注意事项": "保持动词时态和词性一致性，确保成功/失败提示使用相同语法结构（如\"Succeeded in\"/\"Failed to\"对应），避免同词性混用（动词过去式与名词混用）。"
    },
    {
      "defect_id": 471602,
      "sentence": "仅对同应用的不同ability间跳转生效。",
      "reference_sentence": "仅对全屏应用生效。",
      "line_num": 324,
      "context": "{\"319\":\"\",\"320\":\"## StartAnimationParams<sup>20+</sup>\",\"321\":\"\",\"322\":\"启动动画配置。\",\"323\":\"\",\"324\":\"仅对同应用的不同ability间跳转生效。\",\"325\":\"\",\"326\":\"仅在手机设备或平板设备的非自由多窗模式下生效。\",\"327\":\"\",\"328\":\"仅对全屏应用生效。\",\"329\":\"\"}",
      "用户拒绝的修改": "仅对同一应用的不同Ability间跳转生效。",
      "注意事项": "修复时应优先核对上下文中的统一术语（如“应用”而非“Ability”），避免引入新概念；仅在明显违反一致性规则时修改，若原句无歧义且用户认可，需尊重原始表述。"
    },
    {
      "defect_id": 472084,
      "sentence": "边框宽度类型，用于描述组件边框不同方向的宽度。",
      "reference_sentence": "边框宽度类型，用于描述组件边框不同方向的宽度。",
      "line_num": 632,
      "context": "{\"627\":\"| slice | [EdgeWidths](#edgewidths参数说明) |  否  | 边框宽度类型，用于描述组件边框不同方向的宽度。<br>**说明：**<br>只有当bottom和right同时大于0时，该属性生效。<br> 传入数字时默认单位为vp。|\",\"628\":\"| lattice<sup>12+</sup> | [DrawingLattice](#drawinglattice12) |  否  | 矩形网格对象。<br>**说明：**<br> 通过@ohos.graphics.drawing的createImageLattice接口创建Lattice类型作为入参。将图像划分为矩形网格，同时处于偶数列和偶数行上的网格图像是固定的，不会被拉伸。<br>该参数对[backgroundImageResizable](ts-universal-attributes-background.md#backgroundimageresizable12)接口不生效。<br> 传入数字时默认单位为px。 |\",\"629\":\"\",\"630\":\"## EdgeWidths参数说明\",\"631\":\"\",\"632\":\"边框宽度类型，用于描述组件边框不同方向的宽度。\",\"633\":\"\",\"634\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"635\":\"\",\"636\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"637\":\"\"}",
      "用户拒绝的修改": "边界宽度类型，用于描述组件边界不同方向的宽度。",
      "注意事项": "在修改术语前必须全局检查文档中该术语的使用频率和上下文一致性，优先沿用文档高频用词而非局部替换，若原文存在多处相同表述且无歧义时应保留原词。"
    },
    {
      "defect_id": 470086,
      "sentence": "设置无障碍节点获焦、失焦状态的回调函数。当状态发生变化时，触发回调函数。",
      "reference_sentence": "onAccessibilityFocus(callback: AccessibilityFocusCallback): T",
      "line_num": 14,
      "context": "{\"9\":\"\",\"10\":\"## onAccessibilityFocus\",\"11\":\"\",\"12\":\"onAccessibilityFocus(callback: AccessibilityFocusCallback): T\",\"13\":\"\",\"14\":\"设置无障碍节点获焦、失焦状态的回调函数。当状态发生变化时，触发回调函数。\",\"15\":\"\",\"16\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"17\":\"\",\"18\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"19\":\"\"}",
      "用户拒绝的修改": "设置无障碍节点获取焦点、失去焦点状态的回调函数。当状态发生变化时，触发回调函数。",
      "注意事项": "修复时应优先保持与上下文术语一致性，严格匹配参考句中的\"获焦/失焦\"而非替换为近义词；修改前需检查问题上下文和API名称中的固定搭配，避免破坏已有术语体系。"
    },
    {
      "defect_id": 472082,
      "sentence": "图片的插值效果。",
      "reference_sentence": "图片的插值效果。",
      "line_num": 587,
      "context": "{\"582\":\"| ------ | ----- | -------------------------- |\",\"583\":\"| EMPTY   | 0  | 空图像。                   |\",\"584\":\"\",\"585\":\"## ImageInterpolation\",\"586\":\"\",\"587\":\"图片的插值效果。\",\"588\":\"\",\"589\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"590\":\"\",\"591\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"592\":\"\"}",
      "用户拒绝的修改": "图像的插值效果。",
      "注意事项": "在统一术语前需确认上下文是否存在明确区分或约定俗成的用法，优先遵循文档现有术语体系而非机械替换；若修改涉及技术概念差异，应结合领域知识审慎判断。"
    },
    {
      "defect_id": 470947,
      "sentence": "9. 不支持避让软键盘，需自定义避让。",
      "reference_sentence": "6. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。",
      "line_num": 177,
      "context": "{\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认为全屏。\",\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，例如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。\",\"176\":\"\",\"177\":\"9. 不支持避让软键盘，需自定义避让。\",\"178\":\"\",\"179\":\"\",\"180\":\"**半模态全屏弹窗样式不支持的接口**\",\"181\":\"| 名称             | 说明              |\",\"182\":\"| --------------- |  --------------- |\"}",
      "用户拒绝的修改": "9. 无避让软键盘能力，需自定义避让。",
      "注意事项": "修复时必须严格检查上下文相邻条目的固定句式结构，优先保持同一章节内\"不支持\"的统一表述规范，避免跨章节参考不同句式导致术语混用。"
    },
    {
      "defect_id": 471537,
      "sentence": "表示窗口动画类型为淡入淡出。淡入动画在窗口显示过程中生效，淡出动画在窗口隐藏过程中生效。",
      "reference_sentence": "无",
      "line_num": 170,
      "context": "{\"165\":\"\",\"166\":\"**系统能力：**  SystemCapability.Window.SessionManager\",\"167\":\"\",\"168\":\"| 名称    | 值   | 说明                       |\",\"169\":\"| ------- | ---- | -------------------------- |\",\"170\":\"| FADE_IN_OUT | 0    | 表示窗口动画类型为淡入淡出。淡入动画在窗口显示过程中生效，淡出动画在窗口隐藏过程中生效。 |\",\"171\":\"\",\"172\":\"## WindowAnchor<sup>20+</sup>\",\"173\":\"\",\"174\":\"窗口锚点枚举。\",\"175\":\"\"}",
      "用户拒绝的修改": "表示窗口动画类型为淡入淡出。淡入动画在窗口显示时生效，淡出动画在窗口隐藏时生效。",
      "注意事项": "修复时应优先确保术语准确性，避免机械替换导致语义偏差；需结合上下文判断\"过程中\"与\"时\"是否属于技术时间范畴定义，若原文表述已符合领域规范则无需强制统一。"
    },
    {
      "defect_id": 471601,
      "sentence": "启动动画配置。",
      "reference_sentence": "窗口转场动画配置。",
      "line_num": 322,
      "context": "{\"317\":\"| config  | [WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20) | 是   | 本次转场动画配置。                                           |\",\"318\":\"| opacity | number                                            | 否   | 不透明度，转场动画作用的窗口属性，值为0时窗口完全透明。当动画类型为WindowTransitionType.DESTROY时，代表动画终点的不透明度。取值范围0~1，在动画结束时恢复为1。 |\",\"319\":\"\",\"320\":\"## StartAnimationParams<sup>20+</sup>\",\"321\":\"\",\"322\":\"启动动画配置。\",\"323\":\"\",\"324\":\"仅对同应用的不同ability间跳转生效。\",\"325\":\"\",\"326\":\"仅在手机设备或平板设备的非自由多窗模式下生效。\",\"327\":\"\"}",
      "用户拒绝的修改": "窗口转场动画配置。",
      "注意事项": "修复术语一致性时需优先确认上下文中的技术概念是否完全相同，避免将不同场景或功能模块的合理术语差异误判为不一致；同时应结合技术文档的领域特性和用户意图，仅在明确同义且上下文统一的情况下进行术语替换。"
    },
    {
      "defect_id": 470349,
      "sentence": "提供onAccessibilityActionIntercept中使用的回调函数参数类型。",
      "reference_sentence": "定义onAccessibilityFocus中使用的回调类型。",
      "line_num": 78,
      "context": "{\"73\":\"\",\"74\":\"## AccessibilityActionInterceptCallback<sup>20+</sup>\",\"75\":\"\",\"76\":\"type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult\",\"77\":\"\",\"78\":\"提供onAccessibilityActionIntercept中使用的回调函数参数类型。\",\"79\":\"\",\"80\":\"**卡片能力：** 从API version 20开始，该接口支持在ArkTS卡片中使用。\",\"81\":\"\",\"82\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"83\":\"\"}",
      "用户拒绝的修改": "定义onAccessibilityActionIntercept中使用的回调类型。",
      "注意事项": "修复时应精确区分\"定义类型\"和\"描述参数用途\"的上下文场景，若句子位于类型声明后的解释性段落（如第78行），需保留\"提供参数类型\"的说明性表达；若位于类型定义标题（如第74行）则使用\"定义回调类型\"的结构性表达。"
    },
    {
      "defect_id": 470945,
      "sentence": "7. 不支持宽高自定义，宽高默认为全屏。",
      "reference_sentence": "4. 不支持高度自定义，高度默认全屏。",
      "line_num": 173,
      "context": "{\"168\":\"\",\"169\":\"5. 不支持挡位能力，不支持 `detents`、`detentSelection` 接口。\",\"170\":\"\",\"171\":\"6. 不支持上下滑动，仅支持侧滑关闭。\",\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认为全屏。\",\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，例如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。\",\"176\":\"\",\"177\":\"9. 不支持避让软键盘，需自定义避让。\",\"178\":\"\"}",
      "用户拒绝的修改": "7. 不支持高度自定义，高度默认为全屏。",
      "注意事项": "修复时必须严格保持原文术语一致性（如\"宽高\"不可擅自拆分为\"高度\"），并交叉验证相邻条目表述逻辑（参考第5/6条的双维度描述模式），避免孤立参考单个相似句式。"
    },
    {
      "defect_id": 470087,
      "sentence": "在无障碍控制操作触发前，向注册回调函数方通知，由注册方决定是否拦截该次无障碍控制操作。",
      "reference_sentence": "onAccessibilityActionIntercept(callback: AccessibilityActionInterceptCallback): T",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"**参数：**\",\"63\":\"\",\"64\":\"| 参数名   | 类型    | 必填 | 说明                                                         |\",\"65\":\"| -------- | ------- | ---- | ------------------------------------------------------------ |\",\"66\":\"| callback | [AccessibilityActionInterceptCallback](ts-universal-accessibility-event.md#accessibilityactioninterceptcallback20) | 是   | 在无障碍控制操作触发前，向注册回调函数方通知，由注册方决定是否拦截该次无障碍控制操作。<br> 入参设置undefined时取消回调注册。 |\",\"67\":\"\",\"68\":\"**返回值：**\",\"69\":\"\",\"70\":\"| 类型    | 说明              |\",\"71\":\"| ------ | ---------------- |\"}",
      "用户拒绝的修改": "在无障碍控制操作发生前，向注册回调函数方通知，由注册方决定是否拦截该次无障碍控制操作。",
      "注意事项": "优先保留技术文档中已确立的术语一致性（如\"触发\"在参考句子中的固定用法），避免过度纠正近义词替换；需结合上下文参数定义和API命名规范进行双重验证。"
    },
    {
      "defect_id": 472086,
      "sentence": "图片右部拉伸时，图片的像素值保持不变。",
      "reference_sentence": "图片右部拉伸时，图片的像素值保持不变。",
      "line_num": 641,
      "context": "{\"636\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"637\":\"\",\"638\":\"| 名称 | 类型 | 必填 | 说明 |\",\"639\":\"| --------- |-----------|-----------|-----------|\",\"640\":\"|  top    |  [Length](ts-types.md#length)  |  否  | 图片顶部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"641\":\"|  right  |  [Length](ts-types.md#length)  |  否  | 图片右部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"642\":\"|  bottom |  [Length](ts-types.md#length)  |  否  | 图片底部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"643\":\"|  left   |  [Length](ts-types.md#length)  |  否  | 图片左部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"644\":\"\",\"645\":\"![edgewidths](figures/edgewidths.png)\",\"646\":\"\"}",
      "用户拒绝的修改": "图像右部拉伸时，图像的像素值保持不变。",
      "注意事项": "修复术语一致性时需优先检查上下文用词习惯，若原文存在统一术语（如\"图片\"）且无明确错误，应保持原有用词而非强行替换为同义词；修改前必须核对全部相关条目确保全局一致性。"
    },
    {
      "defect_id": 471668,
      "sentence": "启动动画参数配置。默认值为undefined，若不配置将保持系统默认动效。",
      "reference_sentence": "窗口动画参数配置。默认动画曲线为WindowAnimationCurve.LINEAR，duration为0。",
      "line_num": 218,
      "context": "{\"213\":\"应用启动时的窗口参数配置。\",\"214\":\"\",\"215\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"216\":\"| 名称             | 类型                                                                     | 只读 | 可选 | 说明                                                         |\",\"217\":\"| ---------------- | ----------------------------------------------------------------------- | ---- | ---- | ------------------------------------------------------------ |\",\"218\":\"| systemAnimationsParams             | [StartAnimationSystemParams](#startanimationsystemparams20)                 | 否   | 是   | 启动动画参数配置。默认值为undefined，若不配置将保持系统默认动效。|\",\"219\":\"\",\"220\":\"## window.minimizeAll<sup>9+</sup>\",\"221\":\"minimizeAll(id: number, callback: AsyncCallback&lt;void&gt;): void\",\"222\":\"\",\"223\":\"最小化某显示设备下的所有窗口。\"}",
      "用户拒绝的修改": "启动动画参数配置。默认动画曲线为WindowAnimationCurve.LINEAR，duration为0。",
      "注意事项": "修复时应优先检查上下文术语使用频率（如问题参数名\"systemAnimationsParams\"与上下文\"应用启动时的窗口参数配置\"均指向\"启动动画\"），避免强行替换为看似相关但上下文未高频出现的词汇（如\"窗口动画\"）；若需调整术语，必须确保参数名称、功能描述、系统能力字段形成完整逻辑链。"
    },
    {
      "defect_id": 471847,
      "sentence": "JSVM-API接口开发流程请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。",
      "reference_sentence": "JSVM-API接口开发流程请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。",
      "line_num": 29,
      "context": "{\"24\":\"| OH_JSVM_GetSymbolAsyncIterator         | 等价于JS中的Symbol.asyncIterator。   |\",\"25\":\"| OH_JSVM_GetSymbolIterator              | 等价于JS中的Symbol.iterator。   |\",\"26\":\"\",\"27\":\"## 使用示例\",\"28\":\"\",\"29\":\"JSVM-API接口开发流程请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。\",\"30\":\"\",\"31\":\"### 使用接口获取Well-known symbols（以OH_JSVM_GetSymbolToStringTag为例）\",\"32\":\"\",\"33\":\"cpp部分代码：\",\"34\":\"\"}",
      "用户拒绝的修改": "请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。",
      "注意事项": "修复时应优先保留原文的关键术语和上下文衔接词（如\"JSVM-API接口开发流程\"），避免因句式统一破坏文档结构连贯性；需综合判断句式调整是否影响技术文档的指代明确性，必要时容忍适度句式差异以保持专业表述习惯。"
    },
    {
      "defect_id": 471219,
      "sentence": "    - [@ohos.selectionInput.selectionManager (划词管理)](js-apis-selectionInput-selectionManager.md)\r",
      "reference_sentence": "    - [@ohos.app.ability.PrintExtensionAbility (打印扩展能力)](js-apis-app-ability-PrintExtensionAbility.md)",
      "line_num": 47,
      "context": "{\"42\":\"    - [@ohos.app.ability.PrintExtensionAbility (打印扩展能力)(系统接口)](js-apis-app-ability-PrintExtensionAbility-sys.md)\",\"43\":\"    - [@ohos.print (打印)(系统接口)](js-apis-print-sys.md)\",\"44\":\"    - [@ohos.request (上传下载)(系统接口)](js-apis-request-sys.md)\",\"45\":\"    - [@ohos.selectionInput.SelectionExtensionAbility (划词扩展能力)](js-apis-selectionInput-selectionExtensionAbility.md)\",\"46\":\"    - [@ohos.selectionInput.SelectionExtensionContext (划词扩展上下文)](js-apis-selectionInput-selectionExtensionContext.md)\",\"47\":\"    - [@ohos.selectionInput.selectionManager (划词管理)](js-apis-selectionInput-selectionManager.md)\",\"48\":\"    - [@ohos.selectionInput.SelectionPanel (划词面板)](js-apis-selectionInput-selectionPanel.md)\",\"49\":\"    <!--DelEnd-->\",\"50\":\"  - 进程线程通信<!--process-thread-communi-arkts-->\",\"51\":\"    - [系统定义的公共事件](common_event/commonEventManager-definitions.md)\",\"52\":\"    <!--Del-->\"}",
      "用户拒绝的修改": "    - [@ohos.selectionInput.SelectionManager (划词管理)](js-apis-selectionInput-selectionManager.md)\r",
      "注意事项": "修复时应优先确保同一模块内术语一致性（如\"划词管理\"需与同模块的\"划词扩展能力\"保持关联），跨模块参考时需确认功能场景是否匹配（如\"打印扩展能力\"属于不同功能域，不应直接套用命名模式）。"
    },
    {
      "defect_id": 472087,
      "sentence": "图片底部拉伸时，图片的像素值保持不变。",
      "reference_sentence": "图片底部拉伸时，图片的像素值保持不变。",
      "line_num": 642,
      "context": "{\"637\":\"\",\"638\":\"| 名称 | 类型 | 必填 | 说明 |\",\"639\":\"| --------- |-----------|-----------|-----------|\",\"640\":\"|  top    |  [Length](ts-types.md#length)  |  否  | 图片顶部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"641\":\"|  right  |  [Length](ts-types.md#length)  |  否  | 图片右部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"642\":\"|  bottom |  [Length](ts-types.md#length)  |  否  | 图片底部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"643\":\"|  left   |  [Length](ts-types.md#length)  |  否  | 图片左部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"644\":\"\",\"645\":\"![edgewidths](figures/edgewidths.png)\",\"646\":\"\",\"647\":\"## DynamicRangeMode<sup>12+</sup>枚举说明\"}",
      "用户拒绝的修改": "图像底部拉伸时，图像的像素值保持不变。",
      "注意事项": "修复术语一致性时必须优先确认上下文已有用词习惯，若问题句子与参考上下文使用相同术语（如\"图片\"），即使存在更规范表述也不应擅自修改，避免破坏文档内部统一性。"
    },
    {
      "defect_id": 472083,
      "sentence": "图片的渲染模式。",
      "reference_sentence": "图片的渲染模式。",
      "line_num": 604,
      "context": "{\"599\":\"| Medium | MipMap插值。                     |\",\"600\":\"| Low    | 双线性插值。                     |\",\"601\":\"\",\"602\":\"## ImageRenderMode\",\"603\":\"\",\"604\":\"图片的渲染模式。\",\"605\":\"\",\"606\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"607\":\"\",\"608\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"609\":\"\"}",
      "用户拒绝的修改": "图像的渲染模式。",
      "注意事项": "修复前必须优先确认上下文术语使用习惯，若原文已统一使用特定词汇（如“图片”）且无明确矛盾，应保留原词而非强制替换为近义词。"
    },
    {
      "defect_id": 472085,
      "sentence": "图片顶部拉伸时，图片的像素值保持不变。",
      "reference_sentence": "图片顶部拉伸时，图片的像素值保持不变。",
      "line_num": 640,
      "context": "{\"635\":\"\",\"636\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"637\":\"\",\"638\":\"| 名称 | 类型 | 必填 | 说明 |\",\"639\":\"| --------- |-----------|-----------|-----------|\",\"640\":\"|  top    |  [Length](ts-types.md#length)  |  否  | 图片顶部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"641\":\"|  right  |  [Length](ts-types.md#length)  |  否  | 图片右部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"642\":\"|  bottom |  [Length](ts-types.md#length)  |  否  | 图片底部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"643\":\"|  left   |  [Length](ts-types.md#length)  |  否  | 图片左部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"644\":\"\",\"645\":\"![edgewidths](figures/edgewidths.png)\"}",
      "用户拒绝的修改": "图像顶部拉伸时，图像的像素值保持不变。",
      "注意事项": "在统一术语前必须检查上下文是否存在既有术语体系，若原文已形成稳定的用词惯例（如全篇使用\"图片\"），应优先保持原文用词一致性而非机械替换同义词。"
    },
    {
      "defect_id": 472088,
      "sentence": "图片左部拉伸时，图片的像素值保持不变。",
      "reference_sentence": "图片左部拉伸时，图片的像素值保持不变。",
      "line_num": 643,
      "context": "{\"638\":\"| 名称 | 类型 | 必填 | 说明 |\",\"639\":\"| --------- |-----------|-----------|-----------|\",\"640\":\"|  top    |  [Length](ts-types.md#length)  |  否  | 图片顶部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"641\":\"|  right  |  [Length](ts-types.md#length)  |  否  | 图片右部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"642\":\"|  bottom |  [Length](ts-types.md#length)  |  否  | 图片底部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"643\":\"|  left   |  [Length](ts-types.md#length)  |  否  | 图片左部拉伸时，图片的像素值保持不变。<br>默认值：0<br>单位：vp |\",\"644\":\"\",\"645\":\"![edgewidths](figures/edgewidths.png)\",\"646\":\"\",\"647\":\"## DynamicRangeMode<sup>12+</sup>枚举说明\",\"648\":\"\"}",
      "用户拒绝的修改": "图像左部拉伸时，图像的像素值保持不变。",
      "注意事项": "修复术语时应优先检查上下文用词习惯，若原文已形成特定术语体系（如\"图片\"），即使存在同义词也应保持原有表述；修改前需确认修改对象是否属于需要统一的关键术语，避免在非必要场景下破坏文档内部一致性。"
    },
    {
      "defect_id": 472567,
      "sentence": "3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：",
      "reference_sentence": "3. 使用metadata标签配置主窗口启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗口最大化显示配置存在如下约束与限制：",
      "line_num": 26,
      "context": "{\"21\":\"    * name取值为ohos.ability.window.left表示主窗口默认左边的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、left和right，默认值为left；当偏移量为0时可以省略。\",\"22\":\"    * name取值为ohos.ability.window.top表示主窗口顶部的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、top和bottom，默认值为top。如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。\",\"23\":\"\",\"24\":\"2. 使用metadata标签配置是否移除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示移除启动页、取值为false表示不移除启动页，未配置时默认为false。\",\"25\":\"\",\"26\":\"3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：\",\"27\":\"\",\"28\":\"    * 该配置项仅在PC/2in1设备上生效。\",\"29\":\"    * 若使用[startOptions](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md)的supportWindowModes属性，需要配置FULL_SCREEN选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。\",\"30\":\"    * 若使用[module.json5](../quick-start/module-configuration-file.md#abilities标签)的supportWindowMode属性，需要配置fullscreen选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。\",\"31\":\"    * 主窗显示设置优先级排序为：全屏显示 > 使用[startOptions](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md)接口指定大小和位置 > 使用[setWindowRectAutoSave()](../reference/apis-arkui/arkts-apis-window-WindowStage.md#setwindowrectautosave14)方法开启窗口尺寸记忆 > 使用metadata标签配置最大化 > 使用metadata标签配置大小和位置。全屏显示配置方法包括如下三种：\"}",
      "用户拒绝的修改": "3. 使用metadata标签配置主窗口启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗口最大化显示配置存在如下约束与限制：",
      "注意事项": "修复时应严格核查上下文术语统一性，避免近义词混用，确保同一概念在全文档中保持完全一致的表述形式（如\"主窗口\"而非\"主窗\"），必要时建立领域术语表进行交叉验证。"
    },
    {
      "defect_id": 472089,
      "sentence": "图片解码尺寸。",
      "reference_sentence": "图片解码尺寸。",
      "line_num": 681,
      "context": "{\"676\":\"| DOWN_MIRRORED<sup>20+</sup> | 7 | 将当前图片垂直翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_7](figures/imageRotateOrientation_7.png) |\",\"677\":\"| LEFT_MIRRORED<sup>20+</sup> | 8 | 将当前图片水平翻转再顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_8](figures/imageRotateOrientation_8.png) |\",\"678\":\"\",\"679\":\"## ImageSourceSize<sup>18+</sup>对象说明\",\"680\":\"\",\"681\":\"图片解码尺寸。\",\"682\":\"\",\"683\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"684\":\"\",\"685\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"686\":\"\"}",
      "用户拒绝的修改": "图像解码尺寸。",
      "注意事项": "修复术语一致性时必须先检查上下文现有用词习惯，若原文已固定使用\"图片\"则无需替换为\"图像\"，避免过度依赖同义词替换而破坏文档内部术语统一性。"
    },
    {
      "defect_id": 471870,
      "sentence": "string是编程中常用的数据类型。",
      "reference_sentence": "string是编程中常用的数据类型。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用JSVM-API的六个字符串接口，可以实现JSVM模块与JavaScript字符串的交互。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"string是编程中常用的数据类型。它可以存储和操作文本数据，用于表示和处理字符序列。它还可以用于构建用户界面元素，如标签、按钮和文本框，处理用户输入，验证和格式化数据。不同的编码方案支持不同的字符集和语言，以下是一些主要的编码方案及其区别：\",\"10\":\"\",\"11\":\"- **ASCII**：ASCII是最早的字符编码方案之一，使用7位编码，只能表示英文字母、数字和一些基本符号。它是许多其他编码方案的基础。\",\"12\":\"- **UTF-8**：UTF-8是一种变长编码方案，可以表示全球范围的字符集。它使用8位编码，根据字符的不同范围使用不同长度的字节序列。UTF-8是互联网上广泛使用的编码方案。\",\"13\":\"- **UTF-16**：UTF-16是一种定长或变长编码方案，使用16位编码。它可以表示全球范围的字符集，并且适用于较大的字符集。\",\"14\":\"- **ISO-8859-1（Latin-1）**：ISO-8859-1是一种单字节编码方案，使用8位编码。它主要用于表示拉丁字母字符集，包括欧洲大部分语言。\"}",
      "用户拒绝的修改": "字符串是编程中常用的数据类型。",
      "注意事项": "在替换术语前必须全局检查文档中该术语的所有使用实例，确保全文统一；同时区分代码元素与普通文本，保留代码中的原生英文术语（如API名称），仅在叙述文本中使用本地化翻译。"
    },
    {
      "defect_id": 474696,
      "sentence": "异步线程期望传递给env所在的ArkTS线程的数据",
      "reference_sentence": "从异步线程向ArkTS线程投递任务",
      "line_num": 14,
      "context": "{\"9\":\"```\",\"10\":\"\",\"11\":\"| 参数            | 说明          |\",\"12\":\"| :------------- | :----------------------------- |\",\"13\":\"| func           | 线程安全方法                   |\",\"14\":\"| data           | 异步线程期望传递给env所在的ArkTS线程的数据  |\",\"15\":\"| priority       | 指定任务的优先级[napi_task_priority](napi-data-types-interfaces.md#线程安全任务优先级) |\",\"16\":\"| isTail         | 指定任务的入队方式，true代表任务从队列的尾部入队，false代表任务从队列的头部入队。 |\",\"17\":\"\",\"18\":\"## 场景介绍\",\"19\":\"异步线程向ArkTS主线程投递的任务需要根据任务指定的优先级和入队方式进行处理。\"}",
      "用户拒绝的修改": "异步线程期望投递到env所在的ArkTS线程的任务数据",
      "注意事项": "修复时应严格区分\"投递任务\"与\"传递数据\"的上下文语义差异，当原文明确指向具体数据对象时（如参数说明中的data字段），需保留\"数据\"描述；仅在与任务执行相关的动作性描述场景（如跨线程操作机制）使用\"投递任务\"统一术语。"
    },
    {
      "defect_id": 472601,
      "sentence": "5. 使用metadata标签配置主窗边角以直角显示。配置项为：name为ohos.ability.window.isRightAngle，value取值为true或false，取值为true表示窗口边角以直角显示、取值为false则使用系统默认圆角，未配置时默认为false。主窗直角配置仅在PC/2in1设备上生效，且仅支持系统应用。",
      "reference_sentence": "3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：",
      "line_num": 43,
      "context": "{\"38\":\"   自由多窗下的可支持窗口模式可以采用多种方法进行配置，配置优先级为：通过[SetSupportedWindowModes](../reference/apis-arkui/arkts-apis-window-WindowStage.md#setsupportedwindowmodes15)接口配置 > 通过StartAbility配置[StartOption](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md#startoptions)中的SupportWindowMode > 使用metadata配置 > 配置module.json5中[abilities](../quick-start/module-configuration-file.md#abilities标签)标签下的SupportWindowMode属性。\",\"39\":\"\",\"40\":\"   非自由多窗模式下只能通过配置module.json5中abilities标签下的SupportWindowMode属性配置窗口支持模式，其他配置方式均不生效。\",\"41\":\"\",\"42\":\"<!--Del-->\",\"43\":\"5. 使用metadata标签配置主窗边角以直角显示。配置项为：name为ohos.ability.window.isRightAngle，value取值为true或false，取值为true表示窗口边角以直角显示、取值为false则使用系统默认圆角，未配置时默认为false。主窗直角配置仅在PC/2in1设备上生效，且仅支持系统应用。<!--DelEnd-->\",\"44\":\"\",\"45\":\"\",\"46\":\"```json\",\"47\":\"{\",\"48\":\"  \\\"module\\\": {\"}",
      "用户拒绝的修改": "5. 使用metadata标签配置主窗口边角以直角显示。配置项为：name为ohos.ability.window.isRightAngle，value取值为true或false，取值为true表示窗口边角以直角显示、取值为false则使用系统默认圆角，未配置时默认为false。主窗口直角配置仅在PC/2in1设备上生效，且仅支持系统应用。",
      "注意事项": "修复时应严格检查上下文术语一致性（如“主窗”在参考句和问题上下文中均为统一表述），避免在无歧义情况下擅自调整术语长度或形式，优先沿用原文已确立的标准化表达。"
    },
    {
      "defect_id": 472565,
      "sentence": "2. 使用metadata标签配置是否移除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示移除启动页、取值为false表示不移除启动页，未配置时默认为false。",
      "reference_sentence": "2. 使用metadata标签配置是否移除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示删除启动页、取值为false表示不删除启动页，未配置时默认为false。",
      "line_num": 24,
      "context": "{\"19\":\"    * name取值为ohos.ability.window.height表示主窗口的默认高度，value表示高度大小。\",\"20\":\"    * name取值为ohos.ability.window.width表示主窗口的默认宽度，value表示宽度大小。\",\"21\":\"    * name取值为ohos.ability.window.left表示主窗口默认左边的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、left和right，默认值为left；当偏移量为0时可以省略。\",\"22\":\"    * name取值为ohos.ability.window.top表示主窗口顶部的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、top和bottom，默认值为top。如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。\",\"23\":\"\",\"24\":\"2. 使用metadata标签配置是否移除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示移除启动页、取值为false表示不移除启动页，未配置时默认为false。\",\"25\":\"\",\"26\":\"3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：\",\"27\":\"\",\"28\":\"    * 该配置项仅在PC/2in1设备上生效。\",\"29\":\"    * 若使用[startOptions](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md)的supportWindowModes属性，需要配置FULL_SCREEN选项，此时使用metadata标签配置主窗最大化启动生效，否则不生效。\"}",
      "用户拒绝的修改": "2. 使用metadata标签配置是否删除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示删除启动页、取值为false表示不删除启动页，未配置时默认为false。",
      "注意事项": "保持技术术语与配置项名称中的关键词严格对应（如配置项enable.remove.starting.window应统一使用\"移除\"），修复时需全局检查上下文术语一致性，避免近义词混用破坏技术文档严谨性。"
    },
    {
      "defect_id": 475448,
      "sentence": "当前节点对应的祖先节点中存在无法获焦节点。",
      "reference_sentence": "当前节点无法获得焦点。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"This component has an unfocusable ancestor.\",\"30\":\"\",\"31\":\"**错误描述**\",\"32\":\"\",\"33\":\"当前节点对应的祖先节点中存在无法获焦节点。\",\"34\":\"\",\"35\":\"**可能原因**\",\"36\":\"\",\"37\":\"祖先节点默认无法获焦、开发者通过focusable等属性方法设置祖先节点无法获焦等。\",\"38\":\"\"}",
      "用户拒绝的修改": "当前节点对应的祖先节点中存在无法获得焦点的节点。",
      "注意事项": "修复时应严格区分术语的动词与名词形式（如“获焦”vs“获得焦点”），优先保持与上下文已有表述（如参考句和问题上下文中的\"无法获焦\"）的动词形态一致性，避免过度规范化导致术语割裂。"
    },
    {
      "defect_id": 474927,
      "sentence": "拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。",
      "reference_sentence": "在无障碍控制操作触发前，向注册回调函数方通知，由注册方决定是否拦截该次无障碍控制操作。",
      "line_num": 125,
      "context": "{\"120\":\"\",\"121\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"122\":\"\",\"123\":\"| 名称 | 值  | 说明             |\",\"124\":\"| ---- | ---- | ------------------ |\",\"125\":\"| ACTION_INTERCEPT | 0 | 拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。 |\",\"126\":\"| ACTION_CONTINUE | 1 | 拦截当前组件接收的无障碍控制操作, 回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑。 |\",\"127\":\"| ACTION_RISE | 2 | 拦截执行当前组件接收的无障碍控制操作，回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑，并且将ACTION信息往父组件传递，传递到下一个使用了onAccessibilityActionIntercept的组件，触发当前组件中注册的回调，但不触发组件处理逻辑。处理完成后，可以继续使用RISE向父组件传递ACTION。 |\",\"128\":\"\",\"129\":\"## 示例\",\"130\":\"\"}",
      "用户拒绝的修改": "决定是否拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。",
      "注意事项": "修复时应严格遵循上下文中的预定义术语（如“拦截”在问题上下文中已明确为固定行为），避免引入不一致的动词或判断性短语（如“决定是否”），确保描述与系统能力定义保持逻辑统一，避免混淆动作的主动性与被动性。"
    },
    {
      "defect_id": 475449,
      "sentence": "祖先节点默认无法获焦、开发者通过focusable等属性方法设置祖先节点无法获焦等。",
      "reference_sentence": "当前节点无法获得焦点。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"当前节点对应的祖先节点中存在无法获焦节点。\",\"34\":\"\",\"35\":\"**可能原因**\",\"36\":\"\",\"37\":\"祖先节点默认无法获焦、开发者通过focusable等属性方法设置祖先节点无法获焦等。\",\"38\":\"\",\"39\":\"**处理步骤**\",\"40\":\"\",\"41\":\"NA\",\"42\":\"\"}",
      "用户拒绝的修改": "祖先节点默认无法获得焦点、开发者通过focusable等属性方法设置祖先节点无法获得焦点等。",
      "注意事项": "修复前需全面检查上下文术语使用情况，若原文已形成固定表述（如\"获焦\"）且上下文统一，应优先保留原术语而非强制统一为完整表达（如\"获得焦点\"）。"
    },
    {
      "defect_id": 474923,
      "sentence": "type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult",
      "reference_sentence": "type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult",
      "line_num": 76,
      "context": "{\"71\":\"| ------ | ---------------- |\",\"72\":\"| T | 返回当前组件。 |\",\"73\":\"\",\"74\":\"## AccessibilityActionInterceptCallback<sup>20+</sup>\",\"75\":\"\",\"76\":\"type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult\",\"77\":\"\",\"78\":\"提供onAccessibilityActionIntercept中使用的回调函数参数类型。\",\"79\":\"\",\"80\":\"**卡片能力：** 从API version 20开始，该接口支持在ArkTS卡片中使用。\",\"81\":\"\"}",
      "用户拒绝的修改": "type AccessibilityActionInterceptCallback<sup>20+</sup> = (action: AccessibilityAction<sup>20+</sup>) => AccessibilityActionInterceptResult<sup>20+</sup>",
      "注意事项": "修复时应精准识别需标记版本号的元素，仅对顶层类型名称添加版本标记（如`AccessibilityActionInterceptCallback<sup>20+</sup>`），避免对内部参数或返回值重复标记，并严格参照上下文及SDK官方格式规范。"
    },
    {
      "defect_id": 475476,
      "sentence": "表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。",
      "reference_sentence": "表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。",
      "line_num": 69,
      "context": "{\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\",\"69\":\"表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。\"}",
      "用户拒绝的修改": "表示不允许除了accesstoken_service以外的其他应用进程对accesstoken_data_file进行文件操作。",
      "注意事项": "严格保持技术文档中核心术语的一致性，修复时需先确认上下文中的原始用词规范；区分通用表述与领域专有概念，避免擅自添加限定词导致语义范围变化。"
    },
    {
      "defect_id": 475475,
      "sentence": "huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "reference_sentence": "huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"配置的SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围的详细对应关系，参考下表：\"}",
      "用户拒绝的修改": "huks_service会为所有应用进程提供huks能力，那么这里的normal_hap应该改为hap_domain，即",
      "注意事项": "修复时必须严格区分技术术语的上下文定义（如“应用”与“应用进程”），优先采用原文已有术语体系，若需调整需结合领域规范及上下文逻辑验证概念一致性。"
    },
    {
      "defect_id": 474929,
      "sentence": "拦截执行当前组件接收的无障碍控制操作，回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑，并且将ACTION信息往父组件传递，传递到下一个使用了onAccessibilityActionIntercept的组件，触发当前组件中注册的回调，但不触发组件处理逻辑。处理完成后，可以继续使用RISE向父组件传递ACTION。",
      "reference_sentence": "在无障碍控制操作触发前，向注册回调函数方通知，由注册方决定是否拦截该次无障碍控制操作。",
      "line_num": 127,
      "context": "{\"122\":\"\",\"123\":\"| 名称 | 值  | 说明             |\",\"124\":\"| ---- | ---- | ------------------ |\",\"125\":\"| ACTION_INTERCEPT | 0 | 拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。 |\",\"126\":\"| ACTION_CONTINUE | 1 | 拦截当前组件接收的无障碍控制操作, 回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑。 |\",\"127\":\"| ACTION_RISE | 2 | 拦截执行当前组件接收的无障碍控制操作，回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑，并且将ACTION信息往父组件传递，传递到下一个使用了onAccessibilityActionIntercept的组件，触发当前组件中注册的回调，但不触发组件处理逻辑。处理完成后，可以继续使用RISE向父组件传递ACTION。 |\",\"128\":\"\",\"129\":\"## 示例\",\"130\":\"\",\"131\":\"该示例主要演示通过使用onAccessibilityActionIntercept事件实现Toggle组件在无障碍模式下于点击事件发生之前拦截点击事件并确认是否拦截该点击事件的操作。\",\"132\":\"\"}",
      "用户拒绝的修改": "决定是否拦截当前组件接收的无障碍控制操作，回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑，并且将ACTION信息往父组件传递，传递到下一个使用了onAccessibilityActionIntercept的组件，触发当前组件中注册的回调，但不触发组件处理逻辑。处理完成后，可以继续使用RISE向父组件传递ACTION。",
      "注意事项": "修复时必须严格遵循上下文中的术语定义（如\"拦截执行\"与\"决定是否拦截\"在表格中有明确动作区分），优先采用原始文档已明确定义的动词短语，避免因局部参考导致全局术语冲突。"
    },
    {
      "defect_id": 474924,
      "sentence": "提供onAccessibilityActionIntercept中使用的回调函数参数类型。",
      "reference_sentence": "定义onAccessibilityFocus中使用的回调类型。",
      "line_num": 78,
      "context": "{\"73\":\"\",\"74\":\"## AccessibilityActionInterceptCallback<sup>20+</sup>\",\"75\":\"\",\"76\":\"type AccessibilityActionInterceptCallback = (action: AccessibilityAction) => AccessibilityActionInterceptResult\",\"77\":\"\",\"78\":\"提供onAccessibilityActionIntercept中使用的回调函数参数类型。\",\"79\":\"\",\"80\":\"**卡片能力：** 从API version 20开始，该接口支持在ArkTS卡片中使用。\",\"81\":\"\",\"82\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"83\":\"\"}",
      "用户拒绝的修改": "定义onAccessibilityActionIntercept中使用的回调函数参数类型。",
      "注意事项": "修复时应严格遵循上下文已确立的术语体系，优先复用相邻段落中的核心动词（如\"定义\"），避免同义替换导致用词割裂；修改前需全局扫描文档片段，确认目标术语在同类描述中的统一表达方式。"
    },
    {
      "defect_id": 476605,
      "sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即",
      "reference_sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"配置SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围的详细对应关系，参考下表：\"}",
      "用户拒绝的修改": "表示允许以hap_domain为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即",
      "注意事项": "修复时必须严格区分领域专用术语的语义边界，在上下文敏感的场景中应交叉验证术语定义表及策略引用关系，确保替换操作不会破坏原始逻辑分层（如将受限标签normal_hap误替换为全域标签hap_domain）。"
    },
    {
      "defect_id": 478551,
      "sentence": "          - [实现一个划词应用](basic-services/selectionInput/selection-services-application-guide.md)",
      "reference_sentence": "          - [使用剪贴板进行复制粘贴](basic-services/pasteboard/use_pasteboard_to_copy_and_paste.md)",
      "line_num": 1323,
      "context": "{\"1318\":\"          - [应用文件上传下载](basic-services/request/app-file-upload-download.md)\",\"1319\":\"        - 压缩与解压<!--compress-->\",\"1320\":\"          - [压缩与解压](basic-services/compress/deflate-and-inflate.md)\",\"1321\":\"        - 划词服务<!--selectionInput-->\",\"1322\":\"          - [划词服务概述](basic-services/selectionInput/selection-services-intro.md)\",\"1323\":\"          - [实现一个划词应用](basic-services/selectionInput/selection-services-application-guide.md)\",\"1324\":\"      - Function Flow Runtime Kit（任务并发调度服务）<!--ffrt-kit-->\",\"1325\":\"        - [Function Flow Runtime Kit概述](ffrt/ffrt-overview.md)\",\"1326\":\"        - [Function Flow Runtime并发范式](ffrt/ffrt-concurrency-paradigm.md)\",\"1327\":\"        - Function Flow Runtime开发样例(C)<!--ffrt-example-c-->\",\"1328\":\"          - [串行队列(C)](ffrt/ffrt-concurrency-serial-queue-c.md)\"}",
      "用户拒绝的修改": "          - [实现一个选择输入应用](basic-services/selectionInput/selection-services-application-guide.md)",
      "注意事项": "修复术语一致性时需优先检查上下文中的现有术语使用（如\"划词服务\"），避免脱离文档结构直接替换通用词汇；同时应确认服务模块的官方命名规则（如\"selectionInput\"对应\"划词\"而非\"选择输入\"），确保术语与模块目录及兄弟条目保持严格统一。"
    },
    {
      "defect_id": 476606,
      "sentence": "策略开放范围的详细对应关系，参考下表：",
      "reference_sentence": "策略开放范围的详细对应关系，参考下表：",
      "line_num": 30,
      "context": "{\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围的详细对应关系，参考下表：\",\"31\":\"\",\"32\":\"| 面向应用进程的开放范围 | 替换为attribute |\",\"33\":\"| -------- | -------- |\",\"34\":\"| 所有normal等级的应用 | normal_hap_attr |\",\"35\":\"| 所有system_basic等级的应用 | system_basic_hap_attr |\"}",
      "用户拒绝的修改": "策略开放范围的详细对应关系，参考下表：| 面向应用进程的开放范围 | 替换为attribute || -------- | -------- || 所有normal等级的应用 | normal_hap_attr || 所有system_basic等级的应用 | system_basic_hap_attr || 所有system_core等级的应用 | system_core_hap_attr || 所有应用 | hap_domain || 面向应用数据目录的开放范围 | 替换为attribute || -------- | -------- || 所有normal等级的应用数据目录 | normal_hap_data_file_attr || 所有system_basic等级的应用数据目录 | system_basic_hap_data_file_attr || 所有system_core等级的应用数据目录 | system_core_hap_data_file_attr || 所有应用的数据目录 | hap_domain_data_file_attr |",
      "注意事项": "确保表格内术语命名逻辑统一，同一语义层级的替换规则应采用平行结构；修复时必须同步检查上下文关联内容，避免出现跨表格或跨段落的属性映射不一致。"
    },
    {
      "defect_id": 476775,
      "sentence": "2. 通过日志观察划词服务拉起划词ExtensionAbility过程",
      "reference_sentence": "## 开发步骤开发者按照如下开发流程开发划词应用：",
      "line_num": 144,
      "context": "{\"139\":\"\",\"140\":\"- 从设置中打开划词开关\",\"141\":\"- 选择当前应用为划词应用\",\"142\":\"- 设置划词触发方式\",\"143\":\"\",\"144\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程\",\"145\":\"\",\"146\":\"- 使用DevEco Studio的Hilog窗口查看日志。\",\"147\":\"\",\"148\":\"3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口\"}",
      "用户拒绝的修改": "## 通过日志观察划词服务拉起划词ExtensionAbility过程",
      "注意事项": "修复标题级别时应严格对照上下文结构，区分章节标题与列表项编号，避免将有序列表项错误提升为二级标题；需结合用户提供的参考格式判断实际层级关系，而非仅依赖局部文本模式匹配。"
    },
    {
      "defect_id": 476776,
      "sentence": "3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口",
      "reference_sentence": "## 开发步骤开发者按照如下开发流程开发划词应用：",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程\",\"145\":\"\",\"146\":\"- 使用DevEco Studio的Hilog窗口查看日志。\",\"147\":\"\",\"148\":\"3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口\"}",
      "用户拒绝的修改": "## 使用鼠标左键单击选中文本，观察界面弹出划词窗口",
      "注意事项": "修复标题级别时需结合上下文结构判断实际层级，避免机械匹配符号；优先保持列表项格式连贯性，仅在明确需要子标题时才提升层级。"
    },
    {
      "defect_id": 478283,
      "sentence": "Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "reference_sentence": "Multi-Category Security (MCS) 是 SELinux 强制访问控制的一种模式，通过类别 (Category) 划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux支持MCS\",\"2\":\"\",\"3\":\"## MCS背景介绍\",\"4\":\"\",\"5\":\"Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。\",\"6\":\"\",\"7\":\"## MCS开关配置\",\"8\":\"当前MCS默认为开启状态，需要关闭MCS时，可在selinux_adapter部件里配置selinux_adapter_mcs_enable=false。\",\"9\":\"\",\"10\":\"## MCS安全级别配置\"}",
      "用户拒绝的修改": "Multi-Category Security (MCS) 是 SELinux 强制访问控制的一种模式，通过类别划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "注意事项": "技术文档首次出现的核心术语应保留中英文对照格式（例：\"类别 (Category)\"），后续重复出现时可统一使用中文；涉及首字母缩写的关键成分（如MCS中的C对应Category）必须保留英文原词以确保概念准确性。"
    },
    {
      "defect_id": 478447,
      "sentence": "4. 在划词扩展被拉起时使用划词Ability接口创建划词窗口。",
      "reference_sentence": "开发者按照如下开发流程开发划词应用：",
      "line_num": 78,
      "context": "{\"73\":\"    ```ts\",\"74\":\"    selectionManager.on('selectionCompleted', (info: selectionManager.SelectionInfo) => {\",\"75\":\"    });\",\"76\":\"    ```\",\"77\":\"\",\"78\":\"4. 在划词扩展被拉起时使用划词Ability接口创建划词窗口。\",\"79\":\"    ```ts\",\"80\":\"    let panelInfo: PanelInfo = {\",\"81\":\"      panelType: PanelType.MENU_PANEL,\",\"82\":\"      x: 0,\",\"83\":\"      y: 0,\"}",
      "用户拒绝的修改": "在划词扩展被拉起时使用划词Ability接口创建划词窗口。",
      "注意事项": "修复时应全面检查上下文相邻步骤的句式结构，优先保持同类型操作说明的祈使句统一性；区分技术文档中操作步骤与功能描述的语言差异，避免将说明性陈述句误判为祈使句结构问题。"
    },
    {
      "defect_id": 476823,
      "sentence": "          - [实现一个划词应用](basic-services/selectionIput/selection-services-application-guide.md)",
      "reference_sentence": "          - [划词服务概述](basic-services/selectionIput/selection-services-intro.md)",
      "line_num": 1323,
      "context": "{\"1318\":\"          - [应用文件上传下载](basic-services/request/app-file-upload-download.md)\",\"1319\":\"        - 压缩与解压<!--compress-->\",\"1320\":\"          - [压缩与解压](basic-services/compress/deflate-and-inflate.md)\",\"1321\":\"        - 划词服务<!--compress-->\",\"1322\":\"          - [划词服务概述](basic-services/selectionIput/selection-services-intro.md)\",\"1323\":\"          - [实现一个划词应用](basic-services/selectionIput/selection-services-application-guide.md)\",\"1324\":\"      - Function Flow Runtime Kit（任务并发调度服务）<!--ffrt-kit-->\",\"1325\":\"        - [Function Flow Runtime Kit概述](ffrt/ffrt-overview.md)\",\"1326\":\"        - [Function Flow Runtime并发范式](ffrt/ffrt-concurrency-paradigm.md)\",\"1327\":\"        - Function Flow Runtime开发样例(C)<!--ffrt-example-c-->\",\"1328\":\"          - [串行队列(C)](ffrt/ffrt-concurrency-serial-queue-c.md)\"}",
      "用户拒绝的修改": "          - [实现一个划词服务](basic-services/selectionIput/selection-services-application-guide.md)",
      "注意事项": "修复术语一致性时必须优先核查上下文层级结构和同级条目命名惯例，确保修改后的术语与当前条目所属功能模块的命名体系完全匹配，避免跨模块机械统一。"
    },
    {
      "defect_id": 478547,
      "sentence": "  - [划词服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供划词信息监听、划词窗口管理能力。",
      "reference_sentence": "  - [剪贴板](../reference/apis-basic-services-kit/js-apis-pasteboard.md)：提供内容复制粘贴能力，支持多种数据类型包括文本、HTML数据、URI、PixelMap等。",
      "line_num": 31,
      "context": "{\"26\":\"- 数据文件处理：\",\"27\":\"  - [剪贴板](../reference/apis-basic-services-kit/js-apis-pasteboard.md)：提供内容复制粘贴能力，支持多种数据类型包括文本、HTML数据、URI、PixelMap等。\",\"28\":\"  - [压缩](../reference/apis-basic-services-kit/js-apis-zlib.md)：提供文件压缩解压缩的能力。\",\"29\":\"  - [打印](../reference/apis-basic-services-kit/js-apis-print.md)：提供基础文件打印的能力，比如传入文件进行打印、设置打印参数等。\",\"30\":\"  - [上传下载](../reference/apis-basic-services-kit/js-apis-request.md)：提供文件上传下载、后台传输代理的基础能力。\",\"31\":\"  - [划词服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供划词信息监听、划词窗口管理能力。\",\"32\":\"\",\"33\":\"- 进程间/线程间通信：\",\"34\":\"  - [公共事件](../reference/apis-basic-services-kit/js-apis-commonEventManager.md)：提供进程间通信的能力，包括订阅、发布、退订公共事件等，相关开发指南请参考[公共事件简介](common-event/common-event-overview.md)。\",\"35\":\"  - [Emitter](../reference/apis-basic-services-kit/js-apis-emitter.md)：提供线程内通信的能力，包括订阅、发布、退订自定义事件等，相关开发指南请参考[使用Emitter进行线程间通信](common-event/itc-with-emitter.md)。\",\"36\":\"\"}",
      "用户拒绝的修改": "  - [选择输入服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供选择信息监听、选择窗口管理能力。",
      "注意事项": "在修复术语不一致时，需结合上下文和用户文档的命名惯例进行验证，优先保留用户侧已有固定译名或功能名称，避免仅依赖字面直译导致破坏已有术语体系。"
    },
    {
      "defect_id": 478285,
      "sentence": "配置levelFrom时，安全级别可选配置如下：",
      "reference_sentence": "配置levelFrom时，安全级别可选配置如下：",
      "line_num": 22,
      "context": "{\"17\":\"  配置user时，如果user未定义，需要先在users策略文件里定义，示例：\",\"18\":\"  ```text\",\"19\":\"  user o roles { r } level s0 range s0 - s0:c0.x1279;\",\"20\":\"  ```\",\"21\":\"\",\"22\":\"  配置levelFrom时，安全级别可选配置如下：\",\"23\":\"\",\"24\":\" | levelFrom | 释义 | level级别 |\",\"25\":\" | -------- | ---- | ------------- |\",\"26\":\" | app | 根据appId确认级别。 | \\\"s0:x%u,x%u,x%u\\\", appId & 0xff, 256 + (appId>>8 & 0xff), 512 + (appId>>16 & 0xff)|\",\"27\":\" | user | 根据userId确认级别。 | \\\"s0:x%u,x%u\\\", 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\"}",
      "用户拒绝的修改": "配置安全级别时，可选配置如下：",
      "注意事项": "修复时应严格区分技术术语和其释义，保留原始配置项名称（如\"levelFrom\"）同时用括号补充释义（如\"安全级别\"），确保文档既保持技术准确性又提升可读性。"
    },
    {
      "defect_id": 478448,
      "sentence": "5. 使用划词Ability接口销毁划词窗口。",
      "reference_sentence": "开发者按照如下开发流程开发划词应用：",
      "line_num": 100,
      "context": "{\"95\":\"      })\",\"96\":\"      .catch((error: BusinessError) => {\",\"97\":\"      });\",\"98\":\"    ```\",\"99\":\"\",\"100\":\"5. 使用划词Ability接口销毁划词窗口。\",\"101\":\"    ```ts\",\"102\":\"    selectionManager.destroyPanel(this.panel_);\",\"103\":\"    ```\",\"104\":\"\",\"105\":\"## 代码文件介绍\"}",
      "用户拒绝的修改": "使用划词Ability接口销毁划词窗口。",
      "注意事项": "修复前需全面检查相邻条目句式结构，避免将原本符合上下文祈使句规范的描述误判为不一致；优先确认问题条目在列表中的实际一致性状态，而非仅依赖局部参考句进行机械匹配。"
    },
    {
      "defect_id": 478465,
      "sentence": "应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。",
      "reference_sentence": "应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。",
      "line_num": 134,
      "context": "{\"129\":\"    }\",\"130\":\"    ```\",\"131\":\"\",\"132\":\"2. 划词ExtensionAbility实现类介绍。\",\"133\":\"\",\"134\":\"应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。\",\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\",\"138\":\"1. 通过设置系统参数设置划词配置。\",\"139\":\"\"}",
      "用户拒绝的修改": "应用划词ExtensionAbility类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。",
      "注意事项": "保持术语使用与上下文完全一致，避免将简写形式与全称混用（如\"扩展\"和\"ExtensionAbility\"），修改前需核实在同一文档段落中已确立的命名规范。"
    },
    {
      "defect_id": 478550,
      "sentence": "          - [划词服务概述](basic-services/selectionInput/selection-services-intro.md)",
      "reference_sentence": "          - [剪贴板服务概述](basic-services/pasteboard/get-pastedata-permission-guidelines.md)",
      "line_num": 1322,
      "context": "{\"1317\":\"        - 上传下载<!--upload-download-->\",\"1318\":\"          - [应用文件上传下载](basic-services/request/app-file-upload-download.md)\",\"1319\":\"        - 压缩与解压<!--compress-->\",\"1320\":\"          - [压缩与解压](basic-services/compress/deflate-and-inflate.md)\",\"1321\":\"        - 划词服务<!--selectionInput-->\",\"1322\":\"          - [划词服务概述](basic-services/selectionInput/selection-services-intro.md)\",\"1323\":\"          - [实现一个划词应用](basic-services/selectionInput/selection-services-application-guide.md)\",\"1324\":\"      - Function Flow Runtime Kit（任务并发调度服务）<!--ffrt-kit-->\",\"1325\":\"        - [Function Flow Runtime Kit概述](ffrt/ffrt-overview.md)\",\"1326\":\"        - [Function Flow Runtime并发范式](ffrt/ffrt-concurrency-paradigm.md)\",\"1327\":\"        - Function Flow Runtime开发样例(C)<!--ffrt-example-c-->\"}",
      "用户拒绝的修改": "          - [选择输入服务概述](basic-services/selectionInput/selection-services-intro.md)",
      "注意事项": "在确保术语一致性时必须严格区分不同服务模块的独立命名体系，避免跨模块术语混淆；修改前应通过路径上下文（如selectionInput/pasteboard）验证术语归属，仅在同一模块内保持表述统一。"
    },
    {
      "defect_id": 478445,
      "sentence": "2. 继承划词ExtensionAbility实现扩展生命周期函数。",
      "reference_sentence": "开发者按照如下开发流程开发划词应用：",
      "line_num": 37,
      "context": "{\"32\":\"    ├── module.json5                             # 配置文件\",\"33\":\"    ```\",\"34\":\"\",\"35\":\"    ![划词应用工程](figures/selection-application-project.png)\",\"36\":\"\",\"37\":\"2. 继承划词ExtensionAbility实现扩展生命周期函数。\",\"38\":\"    ```ts\",\"39\":\"    import { selectionManager, PanelInfo, PanelType, SelectionExtensionAbility } from '@kit.BasicServicesKit';\",\"40\":\"\",\"41\":\"    class SelectionAbilityStub extends rpc.RemoteObject {\",\"42\":\"      constructor(des) {\"}",
      "用户拒绝的修改": "继承划词ExtensionAbility实现扩展生命周期函数。",
      "注意事项": "修复前需准确识别上下文中的语法模式（如步骤说明统一使用祈使句），避免仅凭局部句式差异误判不一致；对于技术文档中的编号条目，需区分步骤说明与功能描述场景，保留技术术语固有表达方式。"
    },
    {
      "defect_id": 478446,
      "sentence": "3. 在划词扩展被拉起时使用划词Ability接口监听划词事件。",
      "reference_sentence": "开发者按照如下开发流程开发划词应用：",
      "line_num": 72,
      "context": "{\"67\":\"      onDisconnect(): void {\",\"68\":\"      }\",\"69\":\"    }\",\"70\":\"    ```\",\"71\":\"\",\"72\":\"3. 在划词扩展被拉起时使用划词Ability接口监听划词事件。\",\"73\":\"    ```ts\",\"74\":\"    selectionManager.on('selectionCompleted', (info: selectionManager.SelectionInfo) => {\",\"75\":\"    });\",\"76\":\"    ```\",\"77\":\"\"}",
      "用户拒绝的修改": "在划词扩展被拉起时使用划词Ability接口监听划词事件。",
      "注意事项": "修复前需结合上下文完整分析句式结构，确认实际存在不一致性；避免机械套用规则，优先识别技术文档中步骤描述的自然多样性表达。"
    },
    {
      "defect_id": 476774,
      "sentence": "1. 通过设置系统参数设置划词配置",
      "reference_sentence": "## 开发步骤开发者按照如下开发流程开发划词应用：",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"    应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法进行生命周期管理。其中，`onConnect` 方法在用户划词并启动划词扩展时触发。\",\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\",\"138\":\"1. 通过设置系统参数设置划词配置\",\"139\":\"\",\"140\":\"- 从设置中打开划词开关\",\"141\":\"- 选择当前应用为划词应用\",\"142\":\"- 设置划词触发方式\",\"143\":\"\"}",
      "用户拒绝的修改": "## 通过设置系统参数设置划词配置",
      "注意事项": "修复标题级别时必须结合上下文结构判断层级关系，避免将列表项或步骤描述误判为独立标题；优先检查问题句子的实际语义角色（如是否属于步骤说明）再决定是否应用标题格式。"
    },
    {
      "defect_id": 478284,
      "sentence": "配置user时，如果user未定义，需要先在users策略文件里定义，示例：",
      "reference_sentence": "配置user时，如果user未定义，需要先在users策略文件里定义，示例：",
      "line_num": 17,
      "context": "{\"12\":\"  为应用进程添加MCS配置，需要保证MCS开关开启，然后在sehap_contexts配置文件中按需配置levelFrom和user，如果未配置user，默认为user=u。示例如下：\",\"13\":\"  ```text\",\"14\":\"  apl=normal debuggable=true domain=debug_hap type=debug_hap_data_file levelFrom=all user=o\",\"15\":\"  ```\",\"16\":\"\",\"17\":\"  配置user时，如果user未定义，需要先在users策略文件里定义，示例：\",\"18\":\"  ```text\",\"19\":\"  user o roles { r } level s0 range s0 - s0:c0.x1279;\",\"20\":\"  ```\",\"21\":\"\",\"22\":\"  配置levelFrom时，安全级别可选配置如下：\"}",
      "用户拒绝的修改": "配置用户时，如果用户未定义，需要先在用户策略文件里定义，示例：",
      "注意事项": "修复时应严格区分技术术语在上下文中的具体指代（如变量名/文件名），保留原文关键英文术语作为专有名词，避免因过度统一中文表述破坏技术准确性。"
    },
    {
      "defect_id": 478549,
      "sentence": "        - 划词服务<!--selectionInput-->",
      "reference_sentence": "        - 剪贴板服务<!--pasteboard-->",
      "line_num": 1321,
      "context": "{\"1316\":\"          - [使用剪贴板进行延迟复制粘贴](basic-services/pasteboard/pasteboard-time-lapse-copy-and-paste.md)\",\"1317\":\"        - 上传下载<!--upload-download-->\",\"1318\":\"          - [应用文件上传下载](basic-services/request/app-file-upload-download.md)\",\"1319\":\"        - 压缩与解压<!--compress-->\",\"1320\":\"          - [压缩与解压](basic-services/compress/deflate-and-inflate.md)\",\"1321\":\"        - 划词服务<!--selectionInput-->\",\"1322\":\"          - [划词服务概述](basic-services/selectionInput/selection-services-intro.md)\",\"1323\":\"          - [实现一个划词应用](basic-services/selectionInput/selection-services-application-guide.md)\",\"1324\":\"      - Function Flow Runtime Kit（任务并发调度服务）<!--ffrt-kit-->\",\"1325\":\"        - [Function Flow Runtime Kit概述](ffrt/ffrt-overview.md)\",\"1326\":\"        - [Function Flow Runtime并发范式](ffrt/ffrt-concurrency-paradigm.md)\"}",
      "用户拒绝的修改": "        - 选择输入服务<!--selectionInput-->",
      "注意事项": "修复术语时必须严格对照上下文现有译法，优先保持同一注释标签的术语一致性，避免将注释标签进行独立字面翻译而破坏已有术语体系。"
    },
    {
      "defect_id": 478444,
      "sentence": "1. 创建划词应用工程。",
      "reference_sentence": "开发者按照如下开发流程开发划词应用：",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"## 开发步骤\",\"14\":\"\",\"15\":\"开发者按照如下开发流程开发划词应用：\",\"16\":\"\",\"17\":\"1. 创建划词应用工程。\",\"18\":\"\",\"19\":\"    (1) 在DevEco Studio工程Module对应的ets目录下，右键选择“New > Directory”，新建一个目录，并命名为ServiceExtAbility。\",\"20\":\"\",\"21\":\"    (2) 在目录pages下，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets；在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。目录如下：\",\"22\":\"\"}",
      "用户拒绝的修改": "创建划词应用工程。",
      "注意事项": "修复时应优先确认上下文中的主导句式结构，避免因局部参考句差异误判整体一致性要求；区分步骤总起句（陈述句）和具体操作项（祈使句）的层级关系，确保同级内容句式统一。"
    },
    {
      "defect_id": 476772,
      "sentence": "1. 划词应用配置文件介绍",
      "reference_sentence": "## 开发步骤开发者按照如下开发流程开发划词应用：",
      "line_num": 107,
      "context": "{\"102\":\"    selectionManager.destroyPanel(this.panel_);\",\"103\":\"    ```\",\"104\":\"\",\"105\":\"## 代码文件介绍\",\"106\":\"\",\"107\":\"1. 划词应用配置文件介绍\",\"108\":\"\",\"109\":\"    `module.json5`中需要在`requestPermissions`子项中添加应用所需权限，在`extensionAbilities`子项中指定划词扩展类文件路径。\",\"110\":\"\",\"111\":\"    ```json\",\"112\":\"    {\"}",
      "用户拒绝的修改": "## 划词应用配置文件介绍",
      "注意事项": "修复标题级别时应优先检查父级标题的层级关系，确保子标题不越级创建（如列表项\"1.\"不应直接提升为##二级标题）；需结合上下文判断内容属性，区分标题与列表项的结构差异。"
    },
    {
      "defect_id": 476762,
      "sentence": "继继承划词ExtensionAbility实现扩展生命周期函数",
      "reference_sentence": "使用一致的句式，不但使技术文档对外表现出一致的风格，也有助于用户在理解内容时，符合已经形成的思维惯性，理解起来更简单。",
      "line_num": 37,
      "context": "{\"32\":\"  ├── module.json5                             # 配置文件\",\"33\":\"  ```\",\"34\":\"\",\"35\":\"  ![划词应用工程](figures/selection-application-project.png)\",\"36\":\"\",\"37\":\"2. 继承划词ExtensionAbility实现扩展生命周期函数\",\"38\":\"    ```ts\",\"39\":\"    import { selectionManager, PanelInfo, PanelType, SelectionExtensionAbility } from '@kit.BasicServicesKit';\",\"40\":\"\",\"41\":\"    class SelectionAbilityStub extends rpc.RemoteObject {\",\"42\":\"      constructor(des) {\"}",
      "用户拒绝的修改": "继承划词ExtensionAbility实现扩展生命周期函数",
      "注意事项": "修复时应优先结合上下文语境判断句式要求（如步骤描述需统一使用祈使句），避免孤立修正词汇错误而破坏整体一致性；需区分技术术语修正与句式规范调整的边界，仅当原句存在明确语法错误时进行干预。"
    },
    {
      "defect_id": 476773,
      "sentence": "2. 划词ExtensionAbility实现类介绍",
      "reference_sentence": "## 开发步骤开发者按照如下开发流程开发划词应用：",
      "line_num": 132,
      "context": "{\"127\":\"        ]\",\"128\":\"      }\",\"129\":\"    }\",\"130\":\"    ```\",\"131\":\"\",\"132\":\"2. 划词ExtensionAbility实现类介绍\",\"133\":\"\",\"134\":\"    应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法进行生命周期管理。其中，`onConnect` 方法在用户划词并启动划词扩展时触发。\",\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\"}",
      "用户拒绝的修改": "## 划词ExtensionAbility实现类介绍",
      "注意事项": "修复标题级别时应优先检查上下文结构层级，确保修改后的标题与整体文档框架协调（如避免将列表项误判为独立章节）；同时需识别编号格式与标题语法的差异（如\"2. \"开头的列表项不应直接转换为##标题）。"
    },
    {
      "defect_id": 478316,
      "sentence": "  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。",
      "reference_sentence": "  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。",
      "line_num": 50,
      "context": "{\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\",\"55\":\"OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。\"}",
      "用户拒绝的修改": "  + `Enforcing`，强制模式，拦截未授权行为并打印AVC告警。",
      "注意事项": "修复术语大小写时需先确认是否为固定写法或引用内容（如代码/日志关键词），若原文中特定术语（如avc）在上下文或行业规范中明确为小写，则不应强制统一为其他格式。"
    },
    {
      "defect_id": 478349,
      "sentence": "由init通过cfg文件孵化的SA服务进程，例如accountmgr、foundation。",
      "reference_sentence": "由init、chipset_init通过cfg文件孵化的Native进程，例如ueventd、installs。",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"## 新增SA服务进程\",\"36\":\"\",\"37\":\"**适用场景**\",\"38\":\"\",\"39\":\"由init通过cfg文件孵化的SA服务进程，例如accountmgr、foundation。\",\"40\":\"\",\"41\":\"**配置指导**\",\"42\":\"\",\"43\":\"1. 在本进程的cfg文件中，新增secon字段，建立进程与标签的映射关系。如果未配置secon字段，进程在SELinux使能状态会被拦截启动。\",\"44\":\"    ```json\"}",
      "用户拒绝的修改": "由init通过cfg文件孵化的Native进程，例如accountmgr、foundation。",
      "注意事项": "修复时必须严格核对上下文术语定义，优先采用当前章节明确使用的核心概念（如\"SA服务进程\"），避免跨概念替换；当存在多类型进程时，需结合配置文件特征（如secon字段配置要求）确认术语准确性。"
    },
    {
      "defect_id": 478312,
      "sentence": "OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**",
      "reference_sentence": "OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux概述\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"OpenHarmony结合系统架构特点，基于安全增强式Linux（**S**ecurity-**E**nhanced **Linux**\",\"6\":\"，以下简称SELinux）对OpenHarmony操作系统内文件、参数、SA、HDF等系统资源提供强制访问控制保护能力。本文基于SELinux访问控制模型，提供OpenHarmony SELinux功能的开发指导。\",\"7\":\"\",\"8\":\"OpenHarmony SELinux支持以下功能：\",\"9\":\"\",\"10\":\"1. 支持访问参数、SA、HDF管控。\"}",
      "用户拒绝的修改": "OpenHarmony结合系统架构特点，基于安全增强式Linux（Security-Enhanced Linux",
      "注意事项": "修复术语格式时需优先识别文档中已有的固定语法（如加粗/大小写组合），并严格匹配上下文中的呈现形式，避免仅按常规术语规则处理。"
    },
    {
      "defect_id": 478315,
      "sentence": "  - `TE`：类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。",
      "reference_sentence": "  - `TE`：类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"  访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。\",\"42\":\"\",\"43\":\"- **TE**\",\"44\":\"\",\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\"}",
      "用户拒绝的修改": "  - `TE`：类型强制(Type Enforcement)，SELinux策略是由多条类型强制规则构成的。",
      "注意事项": "修复术语一致性时必须优先识别文档固定格式（如加粗标记规范），在保持原有排版结构的前提下进行术语统一，避免因格式破坏导致用户拒绝。"
    },
    {
      "defect_id": 478313,
      "sentence": "  - `sid`：安全标识符(**S**ecurity **ID**)，用于标识进程、文件或其他SELinux对象的唯一标识符。",
      "reference_sentence": "  - `sid`：安全标识符(**S**ecurity **ID**)，用于标识进程、文件或其他SELinux对象的唯一标识符。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"  表示被访问方，客体一般是文件、目录、参数、SA服务、HDF服务等系统资源。\",\"34\":\"\",\"35\":\"- **sid**\",\"36\":\"\",\"37\":\"  安全标识符(**S**ecurity **ID**)，用于标识进程、文件或其他SELinux对象的唯一标识符。\",\"38\":\"\",\"39\":\"- **AVC**\",\"40\":\"\",\"41\":\"  访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。\",\"42\":\"\"}",
      "用户拒绝的修改": "  - `sid`：安全标识符(Security ID)，用于标识进程、文件或其他SELinux对象的唯一标识符。",
      "注意事项": "修复术语格式时应同时检查大小写和加粗标记的一致性，优先匹配上下文已有的格式规范（如**S**ecurity **ID**中的首字母加粗模式），避免仅修改文本内容而破坏文档固定语法结构。"
    },
    {
      "defect_id": 478398,
      "sentence": "1. 虚拟文件系统的标签映射方式和普通文件系统的标签映射方式不一样，在virtfs_contexts中，用genfscon语法来配置。",
      "reference_sentence": "1. 虚拟文件系统的标签映射方式和普通文件系统的标签映射方式不一样，在virtfs_contexts中，用genfscon语法来配置。",
      "line_num": 52,
      "context": "{\"47\":\"\",\"48\":\"对于虚拟文件系统，例如/proc、/sys等目录下的文件标签，可以在 virtfs_contexts文件内对文件或目录进行标签配置。\",\"49\":\"\",\"50\":\"\",\"51\":\"**配置指导**\",\"52\":\"1. 虚拟文件系统的标签映射方式和普通文件系统的标签映射方式不一样，在virtfs_contexts中，用genfscon语法来配置。\",\"53\":\"    ```text\",\"54\":\"    genfscon  proc /iomem  u:object_r:proc_iomem_file:s0\",\"55\":\"    ```\",\"56\":\"2. 在type.te中定义`proc_iomem_file`，使`u:object_r:proc_iomem_file:s0`是合法的。\",\"57\":\"    ```text\"}",
      "用户拒绝的修改": "在virtfs_contexts中，用genfscon语法来配置虚拟文件系统的标签映射方式。",
      "注意事项": "保持句式结构一致性时需优先匹配上下文语境（如步骤说明统一使用陈述句或祈使句），避免仅聚焦局部用词统一而破坏整体语体风格。"
    },
    {
      "defect_id": 478351,
      "sentence": "由appspawn孵化的系统应用进程，期望以独立标签运行，例如`com.ohos.permissionmanager`。",
      "reference_sentence": "由init、chipset_init通过cfg文件孵化的Native进程，例如ueventd、installs。",
      "line_num": 92,
      "context": "{\"87\":\"\",\"88\":\"## 新增应用进程\",\"89\":\"\",\"90\":\"**适用场景**\",\"91\":\"\",\"92\":\"由appspawn孵化的系统应用进程，期望以独立标签运行，例如`com.ohos.permissionmanager`。\",\"93\":\"\",\"94\":\"**配置指导**\",\"95\":\"\",\"96\":\"1. 在sehap_contexts文件中，建立应用APL等级、包名与应用进程标签、数据目录标签的映射关系。这里表示，当安装的应用APL为normal且包名为`com.ohos.permissionmanager`时，安装的应用数据目录标签会被配置为`u:object_r:permissionmanager_hap_data_file:s0`，应用运行时的进程标签会被配置为`u:r:permissionmanager_hap:s0`。\",\"97\":\"    ```text\"}",
      "用户拒绝的修改": "由appspawn孵化的Native进程，期望以独立标签运行，例如`com.ohos.permissionmanager`。",
      "注意事项": "修复时应严格区分上下文中的技术术语定义（如“系统应用进程”与“Native进程”的孵化源差异），避免跨场景概念混淆；需结合参考句子的逻辑（如孵化主体init/appspawn）验证术语适用性，而非仅依赖局部词汇匹配。"
    },
    {
      "defect_id": 478317,
      "sentence": "  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。",
      "reference_sentence": "  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\",\"55\":\"OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。\",\"56\":\"\"}",
      "用户拒绝的修改": "  + `Permissive`，宽容模式，放行未授权行为并打印AVC告警。",
      "注意事项": "修复术语大小写时需优先确认上下文实际使用形式，若术语属于日志内容、代码标识等固定字符串，应保留原始形态而非强制统一。"
    },
    {
      "defect_id": 478350,
      "sentence": "由init、chipset_init通过cfg文件孵化的HDF服务进程，例如wifi_host、camera_host。",
      "reference_sentence": "由init、chipset_init通过cfg文件孵化的Native进程，例如ueventd、installs。",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"## 新增HDF服务进程\",\"62\":\"\",\"63\":\"**适用场景**\",\"64\":\"\",\"65\":\"由init、chipset_init通过cfg文件孵化的HDF服务进程，例如wifi_host、camera_host。\",\"66\":\"\",\"67\":\"**配置指导**\",\"68\":\"\",\"69\":\"1. 在本进程的cfg文件中，新增secon字段，建立进程与标签的映射关系。如果未配置secon字段，进程在SELinux使能状态会被拦截启动。\",\"70\":\"    ```json\"}",
      "用户拒绝的修改": "由init、chipset_init通过cfg文件孵化的Native进程，例如wifi_host、camera_host。",
      "注意事项": "修复时必须严格核对上下文术语定义及章节标题一致性，优先沿用原文已有分类（如\"HDF服务进程\"），避免引入未经验证的同义词替换导致概念混淆。"
    },
    {
      "defect_id": 478314,
      "sentence": "  - `AVC`：访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。",
      "reference_sentence": "  - `AVC`：访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。",
      "line_num": 41,
      "context": "{\"36\":\"\",\"37\":\"  安全标识符(**S**ecurity **ID**)，用于标识进程、文件或其他SELinux对象的唯一标识符。\",\"38\":\"\",\"39\":\"- **AVC**\",\"40\":\"\",\"41\":\"  访问矢量缓存(**A**ccess **V**ector **C**ache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。\",\"42\":\"\",\"43\":\"- **TE**\",\"44\":\"\",\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\"}",
      "用户拒绝的修改": "  - `AVC`：访问矢量缓存(Access Vector Cache)，用于跟踪和缓存有关访问控制决策的信息，以提高系统的性能和安全性。",
      "注意事项": "修复时必须严格保留文档原有的术语格式（包括加粗符号和括号位置），确保缩写展开时每个单词首字母**同时满足大写和加粗**格式，并与上下文中的`安全标识符(**S**ecurity **ID**) `等同类结构完全一致。"
    },
    {
      "defect_id": 478158,
      "sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。",
      "reference_sentence": "表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"当配置的SELinux策略涉及应用SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围详细的对应关系，参考下表：\"}",
      "用户拒绝的修改": "表示允许以normal_hap为标签的应用的进程和huks_service进行binder通信。",
      "注意事项": "修复时应优先识别并保留原文中的固定技术术语（如\"应用进程\"），避免拆分或添加冗余修饰词；当存在术语一致性争议时，建议通过上下文验证或保持原句结构不作修改。"
    },
    {
      "defect_id": 478162,
      "sentence": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：",
      "reference_sentence": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"## 使用neverallow对业务做安全防护\",\"62\":\"\",\"63\":\"neverallow可以阻止不合理的策略配置，因此可以作为安全防护手段，避免本业务的SELinux业务被恶意修改。\",\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\",\"69\":\"表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。\"}",
      "用户拒绝的修改": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本主体进程读写，那么可以通过neverallow进行限制：",
      "注意事项": "严格遵循文档现有术语体系，修复时需核对上下文术语使用一致性（如\"进程\"与\"主体进程\"的取舍应完全匹配参考句式和上下文用词），避免添加未明确存在的修饰词。"
    },
    {
      "defect_id": 478160,
      "sentence": "涉及配置ioctl相关的SELinux策略时，除了配置allow规则以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。",
      "reference_sentence": "涉及配置ioctl相关的SELinux策略时，除了配置allow规则以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。",
      "line_num": 48,
      "context": "{\"43\":\"| 所有system_core等级的应用数据目录 | system_core_hap_data_file_attr |\",\"44\":\"| 所有应用的数据目录 | normal_hap_data_file_attr & system_basic_hap_data_file_attr & system_core_hap_data_file_attr |\",\"45\":\"\",\"46\":\"## 涉及新增ioctl的SELinux策略自检\",\"47\":\"\",\"48\":\"涉及配置ioctl相关的SELinux策略时，除了配置allow规则以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。例如，有下面的avc日志：\",\"49\":\"```text\",\"50\":\"#avc:  denied  { ioctl } for  pid=1 comm=\\\"init\\\" path=\\\"/data/app/el1/bundle/public\\\" dev=\\\"mmcblk0p11\\\" ino=652804 ioctlcmd=0x6613 scontext=u:r:init:s0 tcontext=u:object_r:data_app_el1_file:s0 tclass=dir permissive=0\",\"51\":\"```\",\"52\":\"根据该avc日志配置了允许ioctl的SELinux策略：\",\"53\":\"```text\"}",
      "用户拒绝的修改": "涉及配置ioctl相关的SELinux策略时，除了配置allow策略以外，还需要根据avc日志对ioctl的ioctlcmd进行限制，否则会导致所有的ioctlcmd权限都被开放，不满足权限最小化原则。",
      "注意事项": "确保术语使用严格符合领域规范（如SELinux中\"规则\"特指权限条目，\"策略\"指完整权限配置集），修改时应先确认专业术语的精确含义及上下文搭配关系，避免跨层级概念混淆。"
    },
    {
      "defect_id": 478156,
      "sentence": "另外还有一个attribute表示所有应用进程，为hap_domain。",
      "reference_sentence": "另外还有一个attribute表示所有应用进程，为hap_domain。",
      "line_num": 19,
      "context": "{\"14\":\"| system_basic | system_basic_hap_attr | system_basic_hap_data_file_attr |\",\"15\":\"| system_core | system_core_hap_attr | system_core_hap_data_file_attr |\",\"16\":\"\",\"17\":\"APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。\",\"18\":\"\",\"19\":\"另外还有一个attribute表示所有应用进程，为hap_domain。\",\"20\":\"\",\"21\":\"当配置的SELinux策略涉及应用SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\"}",
      "用户拒绝的修改": "另外还有一个attribute表示所有应用的进程，为hap_domain。",
      "注意事项": "修复时应严格核对上下文和参考句子中术语的原始用法，避免主观添加或删减结构助词（如\"的\"），确保仅针对确实存在不一致的术语进行修正，不改变原有合法表述方式。"
    },
    {
      "defect_id": 478157,
      "sentence": "当配置的SELinux策略涉及应用SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：",
      "reference_sentence": "当配置的SELinux策略涉及应用SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。\",\"18\":\"\",\"19\":\"另外还有一个attribute表示所有应用进程，为hap_domain。\",\"20\":\"\",\"21\":\"当配置的SELinux策略涉及应用SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\"}",
      "用户拒绝的修改": "当配置的SELinux策略涉及应用的SELinux类型时，需要根据实际的开放范围做对应的修改，比如根据avc日志配置的策略是：",
      "注意事项": "修复术语不一致时需严格核对上下文中的技术名词（如\"应用SELinux类型\"与\"hap_domain\"），避免仅依赖字符串匹配，应结合上下文语义确认是否属于同一技术概念后再进行统一。"
    },
    {
      "defect_id": 478182,
      "sentence": "在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。",
      "reference_sentence": "SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。",
      "line_num": 82,
      "context": "{\"77\":\"allow hdcd selinuxfs:file open;\",\"78\":\"```\",\"79\":\"\",\"80\":\"## 策略格式\",\"81\":\"\",\"82\":\"SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。通常allow规则如下:\",\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\"}",
      "用户拒绝的修改": "在设备上使能SELmony时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以授权，neverallow规则主要是禁止危险规则的配置。",
      "注意事项": "修复时应优先保持技术术语的准确性而非机械统一用词，需严格参照上下文已有定义（如\"allow=允许/授权，neverallow=禁止\"）并区分行为描述（\"拦截\"指系统动作，\"禁止\"指规则效力），避免混淆逻辑主体。"
    },
    {
      "defect_id": 478397,
      "sentence": "  3. 使标签生效，file_contexts只是映射了文件路径和标签的对应关系，标签不会自动更新到文件上，需要进程主动触发标签更新操作。",
      "reference_sentence": "3. 使标签生效，file_contexts只是映射了文件路径和标签的对应关系，标签不会自动更新到文件上，需要进程主动触发标签更新操作。",
      "line_num": 35,
      "context": "{\"30\":\"    ```\",\"31\":\"2. 在type.te中定义data_service_el0_file，使u:object_r:data_service_el0_file:s0是合法的。\",\"32\":\"    ```text\",\"33\":\"    type data_service_el0_file, file_attr, data_file_attr;\",\"34\":\"    ```\",\"35\":\"  3. 使标签生效，file_contexts只是映射了文件路径和标签的对应关系，标签不会自动更新到文件上，需要进程主动触发标签更新操作。按文件创建的时机，可以分为以下场景：\",\"36\":\"      | 适用场景 | 更新标签位置 |\",\"37\":\"      | -------- | -------- |\",\"38\":\"      | 通过init从cfg拉起的进程，在cfg内使用mkdir创建目录或文件 | 由于init在解析cfg中的mkdir命令时，已经集成了SELinux更新标签函数Restorecon，所以mkdir会更新标签 |\",\"39\":\"      | 在开机阶段cfg内使用mkdir创建的目录或文件 | 由于init在解析cfg中的mkdir命令时，已经集成了SELinux更新标签函数Restorecon，所以mkdir会更新标签 |\",\"40\":\"      | 在进程运行期间，由进程本身创建的目录或文件 | 需要进程在创建目录或文件后，调用SELinux更新标签函数Restorecon更新标签 |\"}",
      "用户拒绝的修改": "使标签生效。file_contexts只是映射了文件路径和标签的对应关系，标签不会自动更新到文件上，需要进程主动触发标签更新操作。",
      "注意事项": "保持文档原有编号结构与标点习惯，避免擅自拆分步骤编号与说明文本的连贯性；优先参考上下文同类项的表述方式，确保祈使句调整不破坏技术文档的流程化叙述特征。"
    },
    {
      "defect_id": 478159,
      "sentence": "策略开放范围详细的对应关系，参考下表：",
      "reference_sentence": "策略开放范围详细的对应关系，参考下表：",
      "line_num": 30,
      "context": "{\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，那么这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\",\"27\":\"allow hap_domain huks_service:binder { call };\",\"28\":\"```\",\"29\":\"\",\"30\":\"策略开放范围详细的对应关系，参考下表：\",\"31\":\"\",\"32\":\"| 面向应用进程的开放范围 | 替换为attribute |\",\"33\":\"| -------- | -------- |\",\"34\":\"| 所有normal等级的应用 | normal_hap_attr |\",\"35\":\"| 所有system_basic等级的应用 | system_basic_hap_attr |\"}",
      "用户拒绝的修改": "策略开放范围的详细对应关系，参考下表：",
      "注意事项": "修复时应优先确认原文是否存在实际表达错误，避免对符合语境习惯的合理用词（如\"详细的\"与\"详细\"）进行过度统一；若修改仅涉及主观风格差异而非明确规则冲突，应保留原句并标注说明。"
    },
    {
      "defect_id": 478206,
      "sentence": "表示不允许`subject`对`object`进行`class`中的`permissions`操作。",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\",\"95\":\"```\",\"96\":\"表示不允许`subject`对`object`进行`class`中的`permissions`操作。\",\"97\":\"\",\"98\":\"## 策略宏隔离\",\"99\":\"\",\"100\":\"在考虑设备开发者便利的同时，需要兼顾商用设备安全性，因此OpenHarmony SELinux提供了策略隔离宏，决定在不同版本上策略是否生效。OpenHarmony SELinux中支持对仅在root版本生效的策略做宏隔离，宏名称为`debug_only`。在用于设备开发者调试的root版本中，也就是在版本编译命令中指定`--build-variant root`时，宏开启。在用于商用发布的user版本中，也就是在版本编译命令中指定`--build-variant user`时，宏关闭。该宏的使用方法参考如下:\",\"101\":\"```text\"}",
      "用户拒绝的修改": "表示不允许`主体`对`客体`进行`类型`中的`权限`操作。",
      "注意事项": "修复术语不一致时需优先识别并保留技术专有名词的原格式（如代码变量`subject`/`object`），仅在上下文明确使用中文替代时进行翻译，避免破坏技术文档与代码的术语对应关系。"
    },
    {
      "defect_id": 478207,
      "sentence": "| 未隔离的策略 | 生效 | 生效 | 生效 | 生效 |",
      "reference_sentence": "## 策略宏隔离",
      "line_num": 116,
      "context": "{\"111\":\"')\",\"112\":\"```\",\"113\":\"\",\"114\":\"| 隔离宏 | root版本 | root版本开发者模式 | user版本 | user版本开发者模式 |\",\"115\":\"| -------- | -------- | -------- | -------- | -------- |\",\"116\":\"| 未隔离的策略 | 生效 | 生效 | 生效 | 生效 |\",\"117\":\"| debug_only隔离的策略 | 生效 |生效 | 不生效 | 不生效 |\",\"118\":\"| developer_only隔离的策略 | 不生效 | 生效 | 不生效 | 生效 |\"}",
      "用户拒绝的修改": "| 未隔离的策略 | 有效 | 有效 | 有效 | 有效 |",
      "注意事项": "修复时应优先保持上下文术语统一，尤其在技术文档中避免替换已被广泛使用的专业表述（如“生效”），除非存在明确错误；修改前需全面检查同类型文本的用词惯性，确保改动后的表述与整体文档风格一致。"
    },
    {
      "defect_id": 477974,
      "sentence": "3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。",
      "reference_sentence": "3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\",\"38\":\"| contexts类型 | 加载方 | 用途 |\"}",
      "用户拒绝的修改": "3. 对中间文件中使用的SELinux标签校验合法性，生成contexts文件。",
      "注意事项": "修复用词一致性时需严格校验上下文术语使用是否具备实际差异，避免将合理的术语区分误判为不一致；若原文档存在交替使用近义词的情况，应优先维持原作者的表达习惯，除非能明确判定为错误。"
    },
    {
      "defect_id": 478209,
      "sentence": "| developer_only隔离的策略 | 不生效 | 生效 | 不生效 | 生效 |",
      "reference_sentence": "## 策略宏隔离",
      "line_num": 118,
      "context": "{\"113\":\"\",\"114\":\"| 隔离宏 | root版本 | root版本开发者模式 | user版本 | user版本开发者模式 |\",\"115\":\"| -------- | -------- | -------- | -------- | -------- |\",\"116\":\"| 未隔离的策略 | 生效 | 生效 | 生效 | 生效 |\",\"117\":\"| debug_only隔离的策略 | 生效 |生效 | 不生效 | 不生效 |\",\"118\":\"| developer_only隔离的策略 | 不生效 | 生效 | 不生效 | 生效 |\"}",
      "用户拒绝的修改": "| developer_only隔离的策略 | 无效 | 有效 | 无效 | 有效 |",
      "注意事项": "在统一术语时应优先保持上下文用词习惯，对比参考句中的\"生效/不生效\"固定搭配，避免将否定形式机械转换为\"无效\"；修改前需检查表格内其他行是否存在相同表达范式，确保整列术语风格统一。"
    },
    {
      "defect_id": 478200,
      "sentence": "表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：",
      "reference_sentence": "表示允许或禁止某种行为",
      "line_num": 86,
      "context": "{\"81\":\"\",\"82\":\"SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。通常allow规则如下:\",\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\"}",
      "用户拒绝的修改": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "注意事项": "修复术语时应严格保留原文技术词汇（如subject/object），仅在解释性语句中使用括号补充中文译名；技术文档中代码块和专有名词需保持英文原词，避免中英混用造成歧义。"
    },
    {
      "defect_id": 478639,
      "sentence": "1. 划词应用配置文件介绍。",
      "reference_sentence": "## 代码文件介绍",
      "line_num": 111,
      "context": "{\"106\":\"    selectionManager.destroyPanel(this.panel_);\",\"107\":\"    ```\",\"108\":\"\",\"109\":\"## 代码文件介绍\",\"110\":\"\",\"111\":\"1. 划词应用配置文件介绍。\",\"112\":\"\",\"113\":\"在`module.json5`中，于`requestPermissions`子项添加应用所需权限，并在`extensionAbilities`子项指定划词扩展类文件路径。\",\"114\":\"\",\"115\":\"    ```json\",\"116\":\"    {\"}",
      "用户拒绝的修改": "## 划词应用配置文件介绍",
      "注意事项": "修复标题格式时应先确认上下文层级结构，避免将列表项误判为独立标题；确保符号修改与周围格式（如列表序号、代码块位置）保持协调，防止破坏文档逻辑连贯性。"
    },
    {
      "defect_id": 478201,
      "sentence": "- `subject`表示主体，通常为进程的SELinux类型，如`init`。",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 87,
      "context": "{\"82\":\"SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。通常allow规则如下:\",\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\"}",
      "用户拒绝的修改": "- `主体`表示主体，通常为进程的SELinux类型，如`init`。",
      "注意事项": "保留技术文档中的原始英文术语（如subject/object/class）确保专业表述一致性，修改前需确认上下文是否存在已定义的术语对照关系，避免擅自添加冗余限定词（如\"SELinux类型\"中的SELinux）。"
    },
    {
      "defect_id": 477969,
      "sentence": "加载流程在init进程启动后执行",
      "reference_sentence": "加载流程在init进程启动后执行",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux编译与加载\",\"2\":\"\",\"3\":\"## 策略编译与加载\",\"4\":\"\",\"5\":\"OpenHarmony SELinux策略编译流程在编译机中进行，加载流程在init进程启动后执行，总体流程如图：\",\"6\":\"\",\"7\":\"**图1** OpenHarmony SELinux编译和加载流程图\",\"8\":\"\",\"9\":\"![selinux_structure](./figures/SELinux-policy.png)\",\"10\":\"### 策略编译\"}",
      "用户拒绝的修改": "加载过程在init进程启动后执行",
      "注意事项": "在修改术语前必须全面检查上下文中的统一用词规范，优先沿用文档中已确立的高频核心术语（如\"流程\"），避免将同义词替换作为默认处理方式。"
    },
    {
      "defect_id": 478237,
      "sentence": "编译SELinux时会检查文件是否为unix格式，当配置的策略文件格式不正确时，可能出现编译报错。",
      "reference_sentence": "编译SELinux时会检查文件是否为unix格式，当配置的策略文件格式不正确时，可能出现编译报错。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"## unrecognized character报错\",\"30\":\"\",\"31\":\"**现象描述**\",\"32\":\"\",\"33\":\"编译SELinux时会检查文件是否为unix格式，当配置的策略文件格式不正确时，可能出现编译报错。\",\"34\":\"\",\"35\":\"```\",\"36\":\"' on line 3350:rity/selinux_adapter/sepolicy/base/public/domain.te:16:ERROR 'unrecognized character' at token '\",\"37\":\"allow domain init:process sigchld;\",\"38\":\"```\"}",
      "用户拒绝的修改": "编译SELinux时会检查文件是否为unix格式，当配置的策略文件格式不正确时，可能出现编译错误。",
      "注意事项": "保持技术术语一致性时应优先沿用原文表述，避免主观替换已存在的专有名词（如\"编译报错\"）；修改前需核实现有上下文（如日志中的\"ERROR\"标识）是否与目标术语存在强关联性。"
    },
    {
      "defect_id": 478641,
      "sentence": "1. 通过系统参数设置划词配置。",
      "reference_sentence": "## 调测验证",
      "line_num": 142,
      "context": "{\"137\":\"\",\"138\":\"应用划词类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。\",\"139\":\"\",\"140\":\"## 调测验证\",\"141\":\"\",\"142\":\"1. 通过系统参数设置划词配置。\",\"143\":\"\",\"144\":\"- 打开划词开关。\",\"145\":\"- 选择当前应用为划词应用。\",\"146\":\"- 设置划词触发方式。\",\"147\":\"\"}",
      "用户拒绝的修改": "## 通过系统参数设置划词配置",
      "注意事项": "修复时必须严格区分标题层级与内容条目，避免在列表项中误用标题符号（如##），应优先检查上下文结构一致性而非机械匹配格式符号。"
    },
    {
      "defect_id": 478208,
      "sentence": "| debug_only隔离的策略 | 生效 |生效 | 不生效 | 不生效 |",
      "reference_sentence": "## 策略宏隔离",
      "line_num": 117,
      "context": "{\"112\":\"```\",\"113\":\"\",\"114\":\"| 隔离宏 | root版本 | root版本开发者模式 | user版本 | user版本开发者模式 |\",\"115\":\"| -------- | -------- | -------- | -------- | -------- |\",\"116\":\"| 未隔离的策略 | 生效 | 生效 | 生效 | 生效 |\",\"117\":\"| debug_only隔离的策略 | 生效 |生效 | 不生效 | 不生效 |\",\"118\":\"| developer_only隔离的策略 | 不生效 | 生效 | 不生效 | 生效 |\"}",
      "用户拒绝的修改": "| debug_only隔离的策略 | 有效 | 有效 | 无效 | 无效 |",
      "注意事项": "修复前必须核查上下文术语一致性，优先保留技术文档中已形成体系的专业表述（如\"生效/不生效\"），避免机械替换为近义词破坏领域特定表达规范。"
    },
    {
      "defect_id": 478238,
      "sentence": "新增的策略文件格式为dos格式。",
      "reference_sentence": "新增的策略文件格式为dos格式。",
      "line_num": 42,
      "context": "{\"37\":\"allow domain init:process sigchld;\",\"38\":\"```\",\"39\":\"\",\"40\":\"**可能原因**\",\"41\":\"\",\"42\":\"新增的策略文件格式为dos格式。\",\"43\":\"\",\"44\":\"**解决方法**\",\"45\":\"\",\"46\":\"使用dos2unix命令转换编译报错中打印的文件：\",\"47\":\"```text\"}",
      "用户拒绝的修改": "新增的策略文件格式为DOS格式。",
      "注意事项": "修改术语格式前需确认上下文惯例和行业标准，优先保持原文术语一致性；只有当格式错误导致歧义时，才应通过补充说明（而非单纯改写）提升表达准确性。"
    },
    {
      "defect_id": 478204,
      "sentence": "  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 90,
      "context": "{\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\",\"95\":\"```\"}",
      "用户拒绝的修改": "  - `权限`表示要执行的具体操作，如对文件file的open、read、write。",
      "注意事项": "修复术语不一致时需优先保持上下文术语体系，技术文档中若已建立英文术语体系（如subject/object/class），应保留原词`permissions`而非翻译为中文；同时需区分术语定义和使用场景，在术语首次定义后的解释性语句中才使用本地化表达。"
    },
    {
      "defect_id": 478240,
      "sentence": "排查是否有进行定义，需要使用type进行定义，格式如下：",
      "reference_sentence": "排查是否有进行定义，需要使用type进行定义，格式如下：",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"**可能原因1 & 解决方法**\",\"63\":\"\",\"64\":\"SELinux类型未定义。\",\"65\":\"\",\"66\":\"排查是否有进行定义，需要使用type进行定义，格式如下：\",\"67\":\"```text\",\"68\":\"type init, xxx\",\"69\":\"```\",\"70\":\"\",\"71\":\"**可能原因2 & 解决方法**\"}",
      "用户拒绝的修改": "排查是否有进行定义，需要使用type定义，格式如下：",
      "注意事项": "保持原文动词结构完整性，避免过度简化导致语义偏移；严格区分必要与冗余修饰词，技术文档中\"进行\"等助动词若不影响核心含义应保留原有表达。"
    },
    {
      "defect_id": 477970,
      "sentence": "使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错",
      "reference_sentence": "使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错",
      "line_num": 14,
      "context": "{\"9\":\"![selinux_structure](./figures/SELinux-policy.png)\",\"10\":\"### 策略编译\",\"11\":\"OpenHarmony SELinux策略编译主要包括以下流程：\",\"12\":\"1. 按`security_classes, initial_sids, access_vectors, glb_perm_def.spt, glb_never_def.spt, mls, policy_cap, glb_te_def.spt, attributes, .te, glb_roles.spt, users, initial_sid_contexts, fs_use, virtfs_contexts`顺序遍历策略目录`//base/security/selinux_adapter/sepolicy/`，得到父目录为system和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`system.conf`中间文件，这里会决定是否展开隔离宏。同理，遍历得到父目录为vendor和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`vendor.conf`中间文件，这里也会决定是否展开隔离宏。\",\"13\":\"2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件，得到`system.cil`和`vendor.cil`。\",\"14\":\"3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。\",\"15\":\"4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。\",\"16\":\"\",\"17\":\"### 策略加载\",\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\",\"19\":\"1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。\"}",
      "用户拒绝的修改": "使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译成二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错",
      "注意事项": "修复时应优先检查上下文中的术语一致性，若原文档已统一使用\"编译为\"等特定表述，则避免主观替换为同义词；技术文档修改需严格遵循现有用词习惯，非明显错误时不宜改动风格用词。"
    },
    {
      "defect_id": 478202,
      "sentence": "  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 88,
      "context": "{\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\"}",
      "用户拒绝的修改": "  - `客体`表示客体，通常为系统资源的SELinux类型，如`data_file`。",
      "注意事项": "修复时应严格区分技术术语的上下文使用场景，代码/示例中的英文术语需保持原样，解释性文本中的中文译名需与参考句式统一，避免跨语境机械替换破坏技术文档的术语一致性。"
    },
    {
      "defect_id": 477972,
      "sentence": "这些文件不随策略编译而编译，需要单独归档。",
      "reference_sentence": "这些文件不随策略编译而编译，需要单独归档。",
      "line_num": 23,
      "context": "{\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\",\"19\":\"1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。\",\"20\":\"2. 然后根据配置文件`/system/etc/selinux/config`中SELINUX字段的值设置运行模式，`SELINUX=enforcing`时，设置为强制模式，`SELINUX=permissive`时，设置为宽容模式。从OpenHarmony 3.2开始，OpenHarmony SELinux默认以强制模式运行。\",\"21\":\"\",\"22\":\"## contexts编译与加载\",\"23\":\"OpenHarmony SELinux contexts包括`file_contexts`、`hdf_service_contexts`、`service_contexts`、`parameter_contexts`、`sehap_contexts`。这些文件不随策略编译而编译，需要单独归档。总体流程如图：\",\"24\":\"\",\"25\":\"**图2** OpenHarmony SELinux contexts编译和加载流程图\",\"26\":\"\",\"27\":\"![selinux_contexts](./figures/SELinux-contexts.png)\",\"28\":\"\"}",
      "用户拒绝的修改": "这些文件不随策略编译过程而编译，需要单独归档。",
      "注意事项": "修复时应严格遵循上下文已有术语使用习惯，避免主观添加修饰词；优先核对文档中重复出现的核心术语形式，确保修改后的表述与上下文保持完全一致。"
    },
    {
      "defect_id": 478203,
      "sentence": "  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 89,
      "context": "{\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\"}",
      "用户拒绝的修改": "  - `类型`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。",
      "注意事项": "修复术语时应优先保留上下文已定义的专用术语（如`class`），避免将技术概念与通用翻译（如\"类型\"）混用；需严格校验问题句子在原文中的技术语境，确保术语与代码示例、策略说明保持完全一致。"
    },
    {
      "defect_id": 477975,
      "sentence": "4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。",
      "reference_sentence": "4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。",
      "line_num": 34,
      "context": "{\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\",\"38\":\"| contexts类型 | 加载方 | 用途 |\",\"39\":\"| -------- | -------- | -------- |\"}",
      "用户拒绝的修改": "4. 将contexts归档至`system.img`，位于`/system/etc/selinux/targeted/contexts/`。",
      "注意事项": "修改前需确认上下文是否存在明确的用词规范（如全篇统一使用\"到\"或\"至\"），若仅为同义词替换且无实际语义差异时，应优先保持原句表述避免主观介入。"
    },
    {
      "defect_id": 477973,
      "sentence": "2. 对列表分别拼接去重，生成contexts中间文件。",
      "reference_sentence": "2. 对列表分别拼接去重，生成contexts中间文件。",
      "line_num": 32,
      "context": "{\"27\":\"![selinux_contexts](./figures/SELinux-contexts.png)\",\"28\":\"\",\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\"}",
      "用户拒绝的修改": "2. 对列表分别拼接去重，生成中间文件。",
      "注意事项": "修改术语时必须严格匹配上下文中的实际文件名或变量名（如\"_contexts\"），避免过度简化；修复前应交叉验证文档中所有相关术语实例，确保全局一致性而非局部统一。"
    },
    {
      "defect_id": 478239,
      "sentence": "编译SELinux时会检查SELinux类型是否定义，没定义或者定义位置错误时，会出现编译报错。",
      "reference_sentence": "编译SELinux时会检查SELinux类型是否定义，没定义或者定义位置错误时，会出现编译报错。",
      "line_num": 54,
      "context": "{\"49\":\"```\",\"50\":\"\",\"51\":\"## unknown type报错\",\"52\":\"**现象描述**\",\"53\":\"\",\"54\":\"编译SELinux时会检查SELinux类型是否定义，没定义或者定义位置错误时，会出现编译报错。\",\"55\":\"```\",\"56\":\"../../base/security/selinux_adapter/sepolicy/ohos_policy/security/access_token/vendor/access_token.te:2:ERROR 'unknown type accesstoken_data_file' at token ';' on line 10334:\",\"57\":\"allow accesstoken_service accesstoken_data_file:dir { search add_name open read write remove_name };\",\"58\":\"#line 1 \\\"../../base/security/selinux_adapter/sepolicy/ohos_policy/security/access_token/vendor/access_token.te\\\"\",\"59\":\"checkpolicy:  error(s) encountered while parsing configuration\"}",
      "用户拒绝的修改": "编译SELinux时会检查SELinux类型是否定义，没定义或者定义位置错误时，会出现编译错误。",
      "注意事项": "修复时应优先保持原文专业术语的一致性，避免主观替换已明确定义的词汇；调整重复表述时需结合上下文确认是否存在特定术语依赖，确保修改不破坏原有技术概念的准确性。"
    },
    {
      "defect_id": 478640,
      "sentence": "2. 划词ExtensionAbility实现类介绍。",
      "reference_sentence": "## 代码文件介绍",
      "line_num": 136,
      "context": "{\"131\":\"        ]\",\"132\":\"      }\",\"133\":\"    }\",\"134\":\"    ```\",\"135\":\"\",\"136\":\"2. 划词ExtensionAbility实现类介绍。\",\"137\":\"\",\"138\":\"应用划词类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法以管理生命周期。`onConnect` 方法在用户划词并启动扩展时触发。\",\"139\":\"\",\"140\":\"## 调测验证\",\"141\":\"\"}",
      "用户拒绝的修改": "## 划词ExtensionAbility实现类介绍",
      "注意事项": "修复时应同时验证上下文结构一致性，避免仅机械匹配标题符号而忽略层级逻辑（如原句为列表项时不应强行转为二级标题）；优先确认用户文档中编号项的实际用途（标题/列表）再选择对应格式。"
    },
    {
      "defect_id": 478205,
      "sentence": "同理，",
      "reference_sentence": "表示允许`主体`对`客体`进行`类型`中的`权限`操作，其中：",
      "line_num": 92,
      "context": "{\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\",\"95\":\"```\",\"96\":\"表示不允许`subject`对`object`进行`class`中的`permissions`操作。\",\"97\":\"\"}",
      "用户拒绝的修改": "同理，表示不允许`主体`对`客体`进行`类型`中的`权限`操作。",
      "注意事项": "修复时必须严格保留文档中预定义的占位符术语（如`subject`/`object`/`class`/`permissions`），禁止替换为中文翻译；需完全对齐参考句式的标点符号和结构（如保留分号、冒号后接列表的格式）。"
    },
    {
      "defect_id": 479308,
      "sentence": "**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。",
      "reference_sentence": "**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"brightness(value: number): T\",\"50\":\"\",\"51\":\"为组件添加高光效果。\",\"52\":\"\",\"53\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"54\":\"\",\"55\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"56\":\"\",\"57\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"58\":\"\"}",
      "用户拒绝的修改": "**原子化服务API：** 从API version 9开始，该接口支持在原子化服务中使用。",
      "注意事项": "修复时应严格区分上下文中的独立条目，确保术语一致性仅在同一功能模块内应用，并验证版本号与功能描述的对应关系，避免跨条目错误替换。"
    },
    {
      "defect_id": 479132,
      "sentence": "1、进入网址后，点击**立即下载**，如下图所示：",
      "reference_sentence": "1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。",
      "line_num": 119,
      "context": "{\"114\":\"\",\"115\":\"#### **DevEco Studio下载安装**\",\"116\":\"\",\"117\":\"DevEco Studio下载网址：https://developer.huawei.com/consumer/cn/deveco-studio/\",\"118\":\"\",\"119\":\"1、进入网址后，点击**立即下载**，如下图所示：\",\"120\":\"\",\"121\":\"![mig2](figures/mig2.png) \",\"122\":\"\",\"123\":\"2、建议选择`release`版本，版本号不作要求；建议在32GB及以上内存的Windows环境中使用。\",\"124\":\"\"}",
      "用户拒绝的修改": "1、进入网址后，单击**立即下载**，如下图所示：",
      "注意事项": "修复术语不一致时需确保上下文统一，优先采用文档已有术语（如“单击”），并在修改理由中明确标注“术语规范”以提示用户注意细微差异。"
    },
    {
      "defect_id": 479293,
      "sentence": "当options的值为undefined时，恢复为渐变模糊为0的效果。",
      "reference_sentence": "当value的值为undefined时，恢复为渐变模糊为0的效果。",
      "line_num": 39,
      "context": "{\"34\":\"**参数：** \",\"35\":\"\",\"36\":\"| 参数名  | 类型                                                         | 必填 | 说明                                                         |\",\"37\":\"| ------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"38\":\"| value   | Optional\\\\<number>                                            | 是   | 为模糊半径，模糊半径越大越模糊，为0时不模糊。<br/>取值范围：[0, 1000]<br/>当value的值为undefined时，恢复为渐变模糊为0的效果。 |\",\"39\":\"| options | Optional\\\\<[LinearGradientBlurOptions](#lineargradientbluroptions12对象说明)> | 是   | 设置线性渐变模糊效果。<br/>当options的值为undefined时，恢复为渐变模糊为0的效果。<br/>线性梯度模糊包含两个部分fractionStops和direction。 |\",\"40\":\"\",\"41\":\"**返回值：**\",\"42\":\"\",\"43\":\"| 类型   | 说明                     |\",\"44\":\"| ------ | ------------------------ |\"}",
      "用户拒绝的修改": "当options的值为undefined时，恢复渐变模糊为0的效果。",
      "注意事项": "在统一句式时应优先保留技术文档中的固定表达结构（如\"恢复为...效果\"），避免过度调整导致术语不一致；修改前需确认上下文是否存在明确的祈使句规范，若无明确依据应维持原句表述。"
    },
    {
      "defect_id": 478642,
      "sentence": "2. 通过日志观察划词服务拉起划词ExtensionAbility过程。",
      "reference_sentence": "## 调测验证",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"- 打开划词开关。\",\"145\":\"- 选择当前应用为划词应用。\",\"146\":\"- 设置划词触发方式。\",\"147\":\"\",\"148\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程。\",\"149\":\"\",\"150\":\"- 使用DevEco Studio的Hilog窗口查看日志。\",\"151\":\"\",\"152\":\"3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口。\"}",
      "用户拒绝的修改": "## 通过日志观察划词服务拉起划词ExtensionAbility过程",
      "注意事项": "修复时应优先识别上下文结构类型（如列表项/标题层级），确保格式调整与原有内容逻辑层级一致，避免将步骤列表项误判为标题导致结构混乱。"
    },
    {
      "defect_id": 479347,
      "sentence": "查询/激活/删除已删除的账号。",
      "reference_sentence": "查询/激活/删除已删除的帐号。",
      "line_num": 80,
      "context": "{\"75\":\"\",\"76\":\"**可能原因**\",\"77\":\"\",\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\"}",
      "用户拒绝的修改": "查询/激活/删除已删除的帐号。",
      "注意事项": "修改前必须全面检查上下文中的术语使用习惯，优先遵循用户指定的统一用词规范（如\"账号\"），即使存在其他正确写法也应保持文档内部一致性。"
    },
    {
      "defect_id": 479741,
      "sentence": "创建插件组件，用于显示外部应用提供的UI。",
      "reference_sentence": "提供外部应用组件嵌入式显示功能，即外部应用提供的UI可在本应用内显示。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"## 接口\",\"18\":\"\",\"19\":\"PluginComponent(options: PluginComponentOptions)\",\"20\":\"\",\"21\":\"创建插件组件，用于显示外部应用提供的UI。\",\"22\":\"\",\"23\":\"**系统接口：** 此接口为系统接口。\",\"24\":\"\",\"25\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"26\":\"\"}",
      "用户拒绝的修改": "创建插件组件，用于显示外部应用提供的用户界面。",
      "注意事项": "修复时需优先检查上下文及参考示例中的术语使用频率，严格沿用原文已有表述形式；若缩写与全称并存，需结合项目规范判断是否属于允许的弹性表达场景，避免过度纠正。"
    },
    {
      "defect_id": 479346,
      "sentence": "查询/激活/删除未创建的账号。",
      "reference_sentence": "查询/激活/删除未创建的帐号。",
      "line_num": 79,
      "context": "{\"74\":\"The account does not exist.\",\"75\":\"\",\"76\":\"**可能原因**\",\"77\":\"\",\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\"}",
      "用户拒绝的修改": "查询/激活/删除未创建的帐号。",
      "注意事项": "修复时必须全局检查文档中术语的统一性，优先采用上下文已确定的规范用词；修改前需核对问题句所在段落及相邻条目的用词习惯，避免孤立处理导致不一致。"
    },
    {
      "defect_id": 479344,
      "sentence": "为已删除的账号设置约束/用户名/头像。",
      "reference_sentence": "为已删除的帐号设置约束/用户名/头像。",
      "line_num": 81,
      "context": "{\"76\":\"**可能原因**\",\"77\":\"\",\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\"}",
      "用户拒绝的修改": "为已删除的帐号设置约束/用户名/头像。",
      "注意事项": "修复前需全局检查文档中术语的一致性，优先遵循上下文已有用词习惯；建立敏感词库标记\"账号/帐号\"等易混术语，确保全文档统一使用客户指定版本。"
    },
    {
      "defect_id": 479310,
      "sentence": "**卡片能力：** 从API version 11开始，该接口支持在ArkTS卡片中使用。",
      "reference_sentence": "**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "line_num": 95,
      "context": "{\"90\":\"\",\"91\":\"outlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors): T\",\"92\":\"\",\"93\":\"设置元素的外描边颜色。\",\"94\":\"\",\"95\":\"**卡片能力：** 从API version 11开始，该接口支持在ArkTS卡片中使用。\",\"96\":\"\",\"97\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"98\":\"\",\"99\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"100\":\"\"}",
      "用户拒绝的修改": "**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "注意事项": "修复时需严格区分上下文中的独立功能模块，避免跨模块强制统一术语；修改前必须核对参考句子的版本号、术语使用场景及上下文逻辑，确保局部一致性而非全局替换。"
    },
    {
      "defect_id": 479309,
      "sentence": "**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。",
      "reference_sentence": "**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。",
      "line_num": 77,
      "context": "{\"72\":\"\",\"73\":\"brightness(brightness: Optional\\\\<number>): T\",\"74\":\"\",\"75\":\"为组件添加高光效果。与[brightness](#brightness)相比，brightness参数新增了对undefined类型的支持。\",\"76\":\"\",\"77\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"78\":\"\",\"79\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"80\":\"\",\"81\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"82\":\"\"}",
      "用户拒绝的修改": "**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。",
      "注意事项": "修复时需严格检查上下文同类条目（如\"原子化服务API\"和\"系统能力\"）的命名范式，确保术语与文档全局分类体系一致，避免将不同维度的概念（如\"能力\"与\"API\"）强行对齐。"
    },
    {
      "defect_id": 479345,
      "sentence": "更新未创建的账号。",
      "reference_sentence": "更新未创建的帐号。",
      "line_num": 82,
      "context": "{\"77\":\"\",\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\"}",
      "用户拒绝的修改": "更新未创建的帐号。",
      "注意事项": "修复前必须全面检查上下文中的现有术语使用情况，优先遵循用户指定的统一用词规范（如\"账号\"），而非依赖局部参考示例；建立全局术语一致性校验机制，避免单点修改破坏文档整体统一性。"
    },
    {
      "defect_id": 479325,
      "sentence": "outlineColor(color: Optional\\<ResourceColor | EdgeColors | LocalizedEdgeColors>): T",
      "reference_sentence": "outlineColoroutlineColor(value: ResourceColor | EdgeColors | LocalizedEdgeColors): T",
      "line_num": 115,
      "context": "{\"110\":\"| ------ | ------------------------ |\",\"111\":\"| T | 返回当前组件。 |\",\"112\":\"\",\"113\":\"## outlineColor<sup>18+</sup>\",\"114\":\"\",\"115\":\"outlineColor(color: Optional\\\\<ResourceColor | EdgeColors | LocalizedEdgeColors>): T\",\"116\":\"\",\"117\":\"设置元素的外描边颜色。与[outlineColor](#outlinecolor)相比，color参数新增了对undefined类型的支持。\",\"118\":\"\",\"119\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"120\":\"\"}",
      "用户拒绝的修改": "outlineColor(color: Optional<ResourceColor | EdgeColors | LocalizedEdgeColors>): T",
      "注意事项": "严格校验方法名与参考句子的精确匹配，避免忽略重复字符或大小写差异；交叉验证上下文注释与代码实体的命名一致性，特别是存在重载或相似名称时需重点核查参数类型和命名细节。"
    },
    {
      "defect_id": 479327,
      "sentence": "当color的值为undefined时，恢复为描边颜色为Color.Black的效果。",
      "reference_sentence": "默认值：Color.Black",
      "line_num": 129,
      "context": "{\"124\":\"\",\"125\":\"**参数：**\",\"126\":\"\",\"127\":\"| 参数名 | 类型                                                         | 必填 | 说明                                                         |\",\"128\":\"| ------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"129\":\"| color  | Optional\\\\<[ResourceColor](ts-types.md#resourcecolor)&nbsp;\\\\|&nbsp;[EdgeColors](#edgecolors对象说明)&nbsp;\\\\|&nbsp;[LocalizedEdgeColors](#localizededgecolors对象说明12)> | 是   | 设置元素的外描边颜色。<br/>默认值：Color.Black<br/>当color的值为undefined时，恢复为描边颜色为Color.Black的效果。 |\",\"130\":\"\",\"131\":\"**返回值：**\",\"132\":\"\",\"133\":\"| 类型   | 说明                     |\",\"134\":\"| ------ | ------------------------ |\"}",
      "用户拒绝的修改": "当color的值为undefined时，恢复为默认值Color.Black。",
      "注意事项": "修复时应优先保留原句的上下文操作描述（如\"恢复为描边颜色\"），仅在术语表述不一致时进行最小化替换（如将\"描边颜色为Color.Black的效果\"改为\"默认值Color.Black\"），避免删除关键动作描述造成语义缺失。"
    },
    {
      "defect_id": 479134,
      "sentence": "1. 打开DevEco Studio，在欢迎页单击**Create Project**，创建一个新工程。",
      "reference_sentence": "1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"![img](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20240408193010.49872269946363026547229661463558:50001231000000:2800:7CF59FEDE5425F219B1C183B029DB8209191EDA8412FE15D074C6525DFC00D5B.png?needInitFileName=true?needInitFileName=true)\",\"166\":\"\",\"167\":\"#### 创建新项目\",\"168\":\"\",\"169\":\"1. 打开DevEco Studio，在欢迎页单击**Create Project**，创建一个新工程。\",\"170\":\"2. 根据工程创建向导，选择“Empty Ability”模板，然后单击**Next**。\",\"171\":\"\",\"172\":\"![输入图片说明](https://foruda.gitee.com/images/1747893601075538104/02ff3e8e_13944498.png \\\"屏幕截图\\\")\",\"173\":\"\",\"174\":\"输入项目名称，选择项目保存路径，其他可默认，或者根据具体业务要求进行选择\"}",
      "用户拒绝的修改": "1. 运行DevEco Studio，在欢迎页单击**Create Project**，创建一个新工程。",
      "注意事项": "修复时应优先检查上下文中的动词使用习惯（如\"打开\"在操作步骤中保持统一），避免仅根据孤立参考例句修改导致上下文不一致；需区分软件启动场景差异，\"运行\"适用于首次启动配置，而常规操作建议保持\"打开\"表述。"
    },
    {
      "defect_id": 479756,
      "sentence": "### onError",
      "reference_sentence": "### onComplete",
      "line_num": 86,
      "context": "{\"81\":\"\",\"82\":\"| 参数名  | 类型                                                     | 必填 | 说明                                                     |\",\"83\":\"| ------- | ----------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"84\":\"| callback | [VoidCallback](../../apis-basic-services-kit/js-apis-base.md#callback) | 是   | 回调函数，组件加载完成时触发的回调。 |\",\"85\":\"\",\"86\":\"### onError\",\"87\":\"\",\"88\":\"onError(callback:&nbsp;PluginErrorCallback)\",\"89\":\"\",\"90\":\"组件加载错误时触发回调。\",\"91\":\"\"}",
      "用户拒绝的修改": "### onComplete",
      "注意事项": "修复标题级别时必须同步验证内容语义关联性，避免机械统一格式导致上下文功能描述错位；优先保留原始功能关键词(onError)并调整格式符号，而非直接套用不匹配的参考标题(onComplete)。"
    },
    {
      "defect_id": 478938,
      "sentence": "tlsServer.close(); // 停止监听并释放监听端口",
      "reference_sentence": "TLSSocketServer停止监听并释放通过[listen](#listen10-2)方法绑定的端口。使用Promise方法作为异步方法。",
      "line_num": 8940,
      "context": "{\"8935\":\"  ALPNProtocols: [\\\"spdy/1\\\", \\\"http/1.1\\\"]\",\"8936\":\"}\",\"8937\":\"tlsServer.on('connect', (connection: socket.TLSSocketConnection) => {\",\"8938\":\"  console.log(JSON.stringify(connection))\",\"8939\":\"  // 逻辑处理\",\"8940\":\"  tlsServer.close(); // 停止监听并释放监听端口\",\"8941\":\"  connection.close(); // 关闭当前连接\",\"8942\":\"});\",\"8943\":\"tlsServer.listen(tlsConnectOptions).then(() => {\",\"8944\":\"  console.log(\\\"listen callback success\\\");\",\"8945\":\"}).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "tlsServer.close(); // 停止监听并释放通过listen方法绑定的端口",
      "注意事项": "确保注释与API方法官方描述保持严格术语一致，避免引入未在方法定义中明确提及的扩展解释；优先采用上下文已有注释的简洁表达风格，仅在必要时补充关键关联信息（如方法链调用）。"
    },
    {
      "defect_id": 479326,
      "sentence": "设置元素的外描边颜色。与[outlineColor](#outlinecolor)相比，color参数新增了对undefined类型的支持。",
      "reference_sentence": "设置元素的外描边颜色。",
      "line_num": 117,
      "context": "{\"112\":\"\",\"113\":\"## outlineColor<sup>18+</sup>\",\"114\":\"\",\"115\":\"outlineColor(color: Optional\\\\<ResourceColor | EdgeColors | LocalizedEdgeColors>): T\",\"116\":\"\",\"117\":\"设置元素的外描边颜色。与[outlineColor](#outlinecolor)相比，color参数新增了对undefined类型的支持。\",\"118\":\"\",\"119\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"120\":\"\",\"121\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"122\":\"\"}",
      "用户拒绝的修改": "设置元素的外描边颜色。与[outlineColor](#outlineColor)相比，color参数新增了对undefined类型的支持。",
      "注意事项": "修复方法名大小写时需严格匹配上下文实际用法，避免误改正确锚点；同时应全面检查相关术语（如\"卡片能力\"版本号）在文档中的全局一致性，避免局部修正引发新矛盾。"
    },
    {
      "defect_id": 479342,
      "sentence": "为不存在的账号设置自定义数据。",
      "reference_sentence": "为不存在的帐号设置自定义数据。",
      "line_num": 88,
      "context": "{\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\",\"90\":\"\",\"91\":\"**处理步骤**\",\"92\":\"\",\"93\":\"请检查账号是否存在。\"}",
      "用户拒绝的修改": "为不存在的帐号设置自定义数据。",
      "注意事项": "修复时应全面检查上下文中的术语使用频率，优先遵循文档整体一致性而非单个参考例句；当用户明确指定统一用词时，必须严格遵循指定词汇并验证所有相关上下文。"
    },
    {
      "defect_id": 479341,
      "sentence": "为不存在的账号设置/删除凭据。",
      "reference_sentence": "为不存在的帐号设置/删除凭据。",
      "line_num": 87,
      "context": "{\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\",\"90\":\"\",\"91\":\"**处理步骤**\",\"92\":\"\"}",
      "用户拒绝的修改": "为不存在的帐号设置/删除凭据。",
      "注意事项": "修复前必须全面检查上下文中的术语使用历史，确保用词与文档现有表述完全一致；对\"账号/帐号\"等同音异形词建立术语库强制锁定，禁止擅自替换。"
    },
    {
      "defect_id": 479349,
      "sentence": "为不存在的账号设置/取消账号信息访问授权。",
      "reference_sentence": "为不存在的帐号设置/取消帐号信息访问授权。",
      "line_num": 83,
      "context": "{\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\"}",
      "用户拒绝的修改": "为不存在的帐号设置/取消帐号信息访问授权。",
      "注意事项": "修复术语不一致时必须全局检查上下文，优先采用文档中高频出现的标准术语（如\"账号\"），并建立术语表确保全文统一。"
    },
    {
      "defect_id": 479382,
      "sentence": "PIN码输入器已注册，解注册之前无法重复注册。",
      "reference_sentence": "请传入正确的参数。",
      "line_num": 377,
      "context": "{\"372\":\"The credential inputer already exists.\",\"373\":\"\",\"374\":\"**可能原因**\",\"375\":\"\",\"376\":\"该错误码表示凭据输入器已注册，可能原因如下：\",\"377\":\"PIN码输入器已注册，解注册之前无法重复注册。\",\"378\":\"\",\"379\":\"**处理步骤**\",\"380\":\"\",\"381\":\"凭据输入器已存在，请勿重复操作。\",\"382\":\"\"}",
      "用户拒绝的修改": "凭据输入器已注册，解注册之前无法重复注册。",
      "注意事项": "严格保持术语一致性，修改前需核对上下文已有用词；仅在存在明确矛盾时调整表述，避免基于主观判断替换已统一的关键词。"
    },
    {
      "defect_id": 479343,
      "sentence": "为不存在的账号使能分布式同步功能。",
      "reference_sentence": "为不存在的帐号使能分布式同步功能。",
      "line_num": 89,
      "context": "{\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\",\"90\":\"\",\"91\":\"**处理步骤**\",\"92\":\"\",\"93\":\"请检查账号是否存在。\",\"94\":\"\"}",
      "用户拒绝的修改": "为不存在的帐号使能分布式同步功能。",
      "注意事项": "修改前必须全面检查上下文术语使用情况，严格遵循用户指定的统一用词规范（如\"账号\"），避免依赖自身知识库进行同义词替换。"
    },
    {
      "defect_id": 479338,
      "sentence": "为不存在的账号设置/删除/查询密码。",
      "reference_sentence": "为不存在的帐号设置/删除/查询密码。",
      "line_num": 84,
      "context": "{\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\"}",
      "用户拒绝的修改": "为不存在的帐号设置/删除/查询密码。",
      "注意事项": "修复前必须全面检查上下文中的术语使用习惯，优先保持文档现有词汇一致性；若存在多版本表述可能，需主动询问用户偏好或参考已有规范文件进行确认。"
    },
    {
      "defect_id": 479478,
      "sentence": "2. 请确认网络环境无问题后重试。",
      "reference_sentence": "1. 认证录入超时，请重试。",
      "line_num": 506,
      "context": "{\"501\":\"2. 认证服务因网络原因无法及时响应而超时。\",\"502\":\"\",\"503\":\"**处理步骤**\",\"504\":\"\",\"505\":\"1. 认证录入超时，请重试。\",\"506\":\"2. 请确认网络环境无问题后重试。\",\"507\":\"\",\"508\":\"## 12300112 认证服务忙\",\"509\":\"\",\"510\":\"**错误信息**\",\"511\":\"\"}",
      "用户拒绝的修改": "请确认网络环境无问题后重试。",
      "注意事项": "修复时必须先准确判断原句是否符合目标句式结构（如祈使句需以动词开头），同时严格检查上下文同类项的句式一致性，避免将正确句式误判为错误。"
    },
    {
      "defect_id": 479340,
      "sentence": "为不存在的账号设置额外信息。",
      "reference_sentence": "为不存在的帐号设置额外信息。",
      "line_num": 86,
      "context": "{\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\",\"90\":\"\",\"91\":\"**处理步骤**\"}",
      "用户拒绝的修改": "为不存在的帐号设置额外信息。",
      "注意事项": "修复时应优先检查上下文中的统一用词规范，维护术语表避免同义词混用（如\"账号/帐号\"），确保修改后的表述与文档现有用词体系完全一致。"
    },
    {
      "defect_id": 479475,
      "sentence": "重新或结束认证操作。",
      "reference_sentence": "重新或结束认证操作。",
      "line_num": 474,
      "context": "{\"469\":\"录入凭据过程中，用户取消录入操作。\",\"470\":\"录入凭据过程中，用户取消更新操作。\",\"471\":\"\",\"472\":\"**处理步骤**\",\"473\":\"\",\"474\":\"重新或结束认证操作。\",\"475\":\"\",\"476\":\"## 12300110 认证被锁定\",\"477\":\"\",\"478\":\"**错误信息**\",\"479\":\"\"}",
      "用户拒绝的修改": "请重新或结束认证操作。",
      "注意事项": "修复时应严格遵循技术文档的简洁性原则，避免添加\"请\"等主观修饰词；确保祈使句结构统一，直接使用动词短语（如\"重新操作\"）而非礼貌性句式。"
    },
    {
      "defect_id": 479339,
      "sentence": "为不存在的账号设置/删除令牌。",
      "reference_sentence": "为不存在的帐号设置/删除令牌。",
      "line_num": 85,
      "context": "{\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\",\"84\":\"6. 为不存在的账号设置/删除/查询密码。\",\"85\":\"7. 为不存在的账号设置/删除令牌。\",\"86\":\"8. 为不存在的账号设置额外信息。\",\"87\":\"9. 为不存在的账号设置/删除凭据。\",\"88\":\"10. 为不存在的账号设置自定义数据。\",\"89\":\"11. 为不存在的账号使能分布式同步功能。\",\"90\":\"\"}",
      "用户拒绝的修改": "为不存在的帐号设置/删除令牌。",
      "注意事项": "修复前必须完整扫描上下文确认术语统一性，优先遵循用户提供的上下文用词规范而非通用习惯，避免因近义词替换破坏已有术语一致性。"
    },
    {
      "defect_id": 479348,
      "sentence": "创建已存在的账号。",
      "reference_sentence": "创建已存在的帐号。",
      "line_num": 104,
      "context": "{\"99\":\"The account already exists.\",\"100\":\"\",\"101\":\"**可能原因**\",\"102\":\"\",\"103\":\"该错误码表示账号已存在，可能原因如下：\",\"104\":\"创建已存在的账号。\",\"105\":\"\",\"106\":\"**处理步骤**\",\"107\":\"\",\"108\":\"请取消创建，或使用其他账户号名重试。\",\"109\":\"\"}",
      "用户拒绝的修改": "创建已存在的帐号。",
      "注意事项": "在修复术语不一致时，必须优先扫描上下文确认现有用词规范（如\"账号\"），并严格遵循用户指定的统一形式；对\"帐/账\"等易混淆字需建立敏感词库强制校验，避免依赖单一语境判断。"
    },
    {
      "defect_id": 479352,
      "sentence": "创建id为0-100的账号。",
      "reference_sentence": "创建id为0-100的帐号。",
      "line_num": 164,
      "context": "{\"159\":\"**可能原因**\",\"160\":\"\",\"161\":\"该错误码表示操作的是受限账号，可能原因如下：\",\"162\":\"1. 删除系统保留用户。\",\"163\":\"2. 查询系统保留用户的约束源类型。\",\"164\":\"3. 创建id为0-100的账号。\",\"165\":\"\",\"166\":\"**处理步骤**\",\"167\":\"\",\"168\":\"指定id为系统保留用户，无法操作。\",\"169\":\"\"}",
      "用户拒绝的修改": "创建id为0-100的帐号。",
      "注意事项": "修复时必须全面检查上下文中的术语使用记录，优先遵循文档内部已确立的统一用词规范，而非依赖单一参考句子；对易混淆词汇（如账号/帐号）应建立术语对照表强制统一。"
    },
    {
      "defect_id": 479476,
      "sentence": "认证错误次数超过上限，请在freezingTime之后重试。",
      "reference_sentence": "认证错误次数超过上限，请在freezingTime之后重试。",
      "line_num": 489,
      "context": "{\"484\":\"该错误码表示认证被锁定，可能原因如下：\",\"485\":\"认证类型错误次数超过上限。\",\"486\":\"\",\"487\":\"**处理步骤**\",\"488\":\"\",\"489\":\"认证错误次数超过上限，请在freezingTime之后重试。\",\"490\":\"\",\"491\":\"## 12300111 认证超时\",\"492\":\"\",\"493\":\"**错误信息**\",\"494\":\"\"}",
      "用户拒绝的修改": "请在freezingTime之后重试。",
      "注意事项": "修复时应优先保留原句的关键信息（如错误原因+解决步骤），仅在句式调整时保持祈使句结构；需结合上下文判断是否属于独立处理步骤（此处487行已标注\"处理步骤\"，单独保留解决指令即可接受）。"
    },
    {
      "defect_id": 479378,
      "sentence": "创建账号使用的短名称已经存在。",
      "reference_sentence": "创建已存在的账号。",
      "line_num": 274,
      "context": "{\"269\":\"\",\"270\":\"The short name already exists.\",\"271\":\"\",\"272\":\"**可能原因**\",\"273\":\"\",\"274\":\"创建账号使用的短名称已经存在。\",\"275\":\"\",\"276\":\"**处理步骤**\",\"277\":\"\",\"278\":\"更换别的不存在的短名称。\",\"279\":\"\"}",
      "用户拒绝的修改": "创建账号使用的账号名称已经存在。",
      "注意事项": "修复时必须优先保留原文中的关键术语（如“短名称”），严格检查上下文是否存在重复出现的特定词汇，避免将用户设定的专有名词替换为通用同义词。"
    },
    {
      "defect_id": 479474,
      "sentence": "请提供系统支持的认证类型。",
      "reference_sentence": "请使用存在的认证类型查询/删除。",
      "line_num": 426,
      "context": "{\"421\":\"该错误码表示提供了认证类型不支持，可能原因如下：\",\"422\":\"传入系统不支持的认证类型。\",\"423\":\"\",\"424\":\"**处理步骤**\",\"425\":\"\",\"426\":\"请提供系统支持的认证类型。\",\"427\":\"\",\"428\":\"## 12300107 认证类型不存在\",\"429\":\"\",\"430\":\"**错误信息**\",\"431\":\"\"}",
      "用户拒绝的修改": "请使用系统支持的认证类型。",
      "注意事项": "保持上下文关键动词和术语严格一致，避免主观替换近义词（如\"提供\"vs\"使用\"），需结合错误场景的实际操作逻辑（此处错误源于用户\"提供\"了错误类型，正确操作应要求用户重新\"提供\"而非\"使用\"）。"
    },
    {
      "defect_id": 479337,
      "sentence": "请取消创建，或使用其他账户号名重试。",
      "reference_sentence": "请取消创建，或使用其他帐号名重试。",
      "line_num": 108,
      "context": "{\"103\":\"该错误码表示账号已存在，可能原因如下：\",\"104\":\"创建已存在的账号。\",\"105\":\"\",\"106\":\"**处理步骤**\",\"107\":\"\",\"108\":\"请取消创建，或使用其他账户号名重试。\",\"109\":\"\",\"110\":\"## 12300005 不支持多用户\",\"111\":\"\",\"112\":\"**错误信息**\",\"113\":\"\"}",
      "用户拒绝的修改": "请取消创建，或使用其他帐号名重试。",
      "注意事项": "在修复术语一致性时，必须优先核对上下文已有用词（如\"账号\"）并严格遵循用户指定的统一术语，避免将\"账户/帐号/账号\"等近义词混用，即使单字结构相似也不应自行替换。"
    },
    {
      "defect_id": 479381,
      "sentence": "请确认凭据类型是否存在。",
      "reference_sentence": "请传入正确的参数。",
      "line_num": 366,
      "context": "{\"361\":\"2. 查询未录入的凭据类型。\",\"362\":\"3. 删除未录入的凭据类型。\",\"363\":\"\",\"364\":\"**处理步骤**\",\"365\":\"\",\"366\":\"请确认凭据类型是否存在。\",\"367\":\"\",\"368\":\"## 12300103 凭据输入器已注册\",\"369\":\"\",\"370\":\"**错误信息**\",\"371\":\"\"}",
      "用户拒绝的修改": "请确认凭据类型是否已录入。",
      "注意事项": "修复时应严格遵循上下文已明确使用的核心动词（如“录入”），避免引入未出现的新同义词替换（如将\"存在\"改为\"确认\"），确保术语修改在文档操作逻辑链中具有明确关联性。"
    },
    {
      "defect_id": 479472,
      "sentence": "请输入正确的可信等级。",
      "reference_sentence": "请提供系统支持的认证类型。",
      "line_num": 411,
      "context": "{\"406\":\"该错误码表示提供了可信等级不支持，可能原因如下：\",\"407\":\"传入系统不支持的可信等级。\",\"408\":\"\",\"409\":\"**处理步骤**\",\"410\":\"\",\"411\":\"请输入正确的可信等级。\",\"412\":\"\",\"413\":\"## 12300106 认证类型不支持\",\"414\":\"\",\"415\":\"**错误信息**\",\"416\":\"\"}",
      "用户拒绝的修改": "请提供系统支持的可信等级。",
      "注意事项": "修复时应严格遵循上下文术语一致性，避免混用不同概念（如“可信等级”和“认证类型”），优先采用上下文中已明确使用的标准表述（如“系统支持的”替代“正确的”），并确保修改后的句子与关联错误码逻辑匹配。"
    },
    {
      "defect_id": 479380,
      "sentence": "同一域账号不允许绑定多个系统账号，请更换域账号或删除绑定的账号后再进行绑定。",
      "reference_sentence": "删除已创建的账号。",
      "line_num": 330,
      "context": "{\"325\":\"\",\"326\":\"输入的域账号已绑定系统账号。\",\"327\":\"\",\"328\":\"**处理步骤**\",\"329\":\"\",\"330\":\"同一域账号不允许绑定多个系统账号，请更换域账号或删除绑定的账号后再进行绑定。\",\"331\":\"\",\"332\":\"<!--DelEnd-->\",\"333\":\"\",\"334\":\"## 12300101 凭据不正确\",\"335\":\"\"}",
      "用户拒绝的修改": "同一域账号不允许绑定多个系统账号，请更换域账号或解除绑定后再进行绑定。",
      "注意事项": "保持操作动词与文档现有术语严格一致，避免同义词替换；修改前需核对上下文和参考句中的固定表达方式，优先复用已有标准化表述而非创造新说法。"
    },
    {
      "defect_id": 479379,
      "sentence": "将已经登录的账号退出，再登录新的账号。",
      "reference_sentence": "删除已创建的账号。",
      "line_num": 292,
      "context": "{\"287\":\"\",\"288\":\"登录的账号数已经达到上限，不能再登录新账号。\",\"289\":\"\",\"290\":\"**处理步骤**\",\"291\":\"\",\"292\":\"将已经登录的账号退出，再登录新的账号。\",\"293\":\"\",\"294\":\"<!--Del-->\",\"295\":\"\",\"296\":\"## 12300021 系统账号已绑定域账号\",\"297\":\"\"}",
      "用户拒绝的修改": "将已登录的账号退出，再登录新的账号。",
      "注意事项": "修复前需完整分析上下文确认实际用词差异，避免将参考案例的词汇错误投射到当前语境；区分\"删除\"与\"退出\"等动作的实质区别，仅在确实存在术语混用时进行修正。"
    },
    {
      "defect_id": 479479,
      "sentence": "当前认证服务忙，请稍后重试。",
      "reference_sentence": "当前认证服务忙，请稍后重试。",
      "line_num": 522,
      "context": "{\"517\":\"系统账号认证时，认证总数超过5个。\",\"518\":\"应用账号认证时，三方应用的认证器服务忙碌（根据实际情况决定）。\",\"519\":\"\",\"520\":\"**处理步骤**\",\"521\":\"\",\"522\":\"当前认证服务忙，请稍后重试。\",\"523\":\"\",\"524\":\"## 12300113 认证服务不存在\",\"525\":\"\",\"526\":\"**错误信息**\",\"527\":\"\"}",
      "用户拒绝的修改": "请稍后重试。",
      "注意事项": "修复时应优先保留关键信息完整性，避免过度删减必要内容；句式调整需在保持原意的基础上进行，确保错误原因和操作指引同时存在。"
    },
    {
      "defect_id": 479477,
      "sentence": "1. 认证录入超时，请重试。",
      "reference_sentence": "2. 请确认网络环境无问题后重试。",
      "line_num": 505,
      "context": "{\"500\":\"1. 对于系统账号，认证、录入超过三分钟。\",\"501\":\"2. 认证服务因网络原因无法及时响应而超时。\",\"502\":\"\",\"503\":\"**处理步骤**\",\"504\":\"\",\"505\":\"1. 认证录入超时，请重试。\",\"506\":\"2. 请确认网络环境无问题后重试。\",\"507\":\"\",\"508\":\"## 12300112 认证服务忙\",\"509\":\"\",\"510\":\"**错误信息**\"}",
      "用户拒绝的修改": "请重试。",
      "注意事项": "修复时应同时保留关键原因信息（如“超时”）并保持祈使句结构，避免因过度简化丢失必要语境。建议采用\"问题描述+操作指令\"复合句式（例：\"认证超时，请重试\"）。"
    },
    {
      "defect_id": 479482,
      "sentence": "1. 请重试或重启系统。",
      "reference_sentence": "2. 修改密码或删除已有密码。",
      "line_num": 574,
      "context": "{\"569\":\"1. 身份认证服务出现未知错误。\",\"570\":\"2. 用户已有对应类型的密码，不能再添加密码。\",\"571\":\"\",\"572\":\"**处理步骤**\",\"573\":\"\",\"574\":\"1. 请重试或重启系统。\",\"575\":\"2. 修改密码或删除已有密码。\",\"576\":\"\",\"577\":\"## 12300116 凭证复杂度验证失败\",\"578\":\"\",\"579\":\"**错误信息**\"}",
      "用户拒绝的修改": "请重试或重启系统。",
      "注意事项": "修复时必须严格对比上下文例句结构（如统一省略\"请\"字或保持动词短语对称性），优先匹配已有句式的修饰词和语法模式而非机械套用祈使句规则。"
    },
    {
      "defect_id": 479503,
      "sentence": "重新设置PIN码。",
      "reference_sentence": "按照要求录入包含特定字符的凭证。",
      "line_num": 603,
      "context": "{\"598\":\"\",\"599\":\"用户认证的PIN码过期。\",\"600\":\"\",\"601\":\"**处理步骤**\",\"602\":\"\",\"603\":\"重新设置PIN码。\",\"604\":\"\",\"605\":\"## 12400001 应用不存在\",\"606\":\"\",\"607\":\"**错误信息**\",\"608\":\"\"}",
      "用户拒绝的修改": "重新录入PIN码。",
      "注意事项": "严格核查上下文术语一致性，避免主观替换同义词，优先沿用原文已有操作动词（如上下文\"设置\"）或参考句中的标准表达（如\"录入\"）保持场景统一。"
    },
    {
      "defect_id": 480040,
      "sentence": "被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。",
      "reference_sentence": "被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取报错信息并做处理。",
      "line_num": 87,
      "context": "{\"82\":\"\",\"83\":\"### onError\",\"84\":\"\",\"85\":\"onError(callback:ErrorCallback)\",\"86\":\"\",\"87\":\"被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。\",\"88\":\"\",\"89\":\"**系统接口：** 此接口为系统接口。\",\"90\":\"\",\"91\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"92\":\"\"}",
      "用户拒绝的修改": "被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取报错信息并做处理。",
      "注意事项": "修改前需全面检查上下文术语使用情况，优先保持文档内部术语统一；当用户反馈\"没问题\"时，建议主动询问是否需保留原始表述或确认具体术语规范。"
    },
    {
      "defect_id": 479506,
      "sentence": "请取消设置操作，或者删除已存在的自定义数据。",
      "reference_sentence": "请取消操作，或向支持认证服务的应用进行认证。",
      "line_num": 647,
      "context": "{\"642\":\"\",\"643\":\"该错误码表示自定义数据的数量已达上限，可能原因如下：设置自定义数据时，目标账号的自定义数据数量已达512。\",\"644\":\"\",\"645\":\"**处理步骤**\",\"646\":\"\",\"647\":\"请取消设置操作，或者删除已存在的自定义数据。\",\"648\":\"\",\"649\":\"## 12400004 令牌数量已达上限\",\"650\":\"\",\"651\":\"**错误信息**\",\"652\":\"\"}",
      "用户拒绝的修改": "请取消操作，或者删除已存在的自定义数据。",
      "注意事项": "在保持语言简洁性时必须优先保留上下文关键术语，修改前需确认操作名称中的核心动词（如\"设置\"）是否为系统定义的关键字或专用概念。"
    },
    {
      "defect_id": 479480,
      "sentence": "1. 请重试或重启系统。",
      "reference_sentence": "2. 按照规范开发应用认证器。",
      "line_num": 558,
      "context": "{\"553\":\"1. 身份认证服务出现未知错误；\",\"554\":\"2. 应用认证器不符合规范；\",\"555\":\"\",\"556\":\"**处理步骤**\",\"557\":\"\",\"558\":\"1. 请重试或重启系统。\",\"559\":\"2. 按照规范开发应用认证器。\",\"560\":\"\",\"561\":\"## 12300115 用户认证密码个数达到上限\",\"562\":\"\",\"563\":\"**错误信息**\"}",
      "用户拒绝的修改": "请重试或重启系统。",
      "注意事项": "修复前需先确认原句实际存在的句式不一致问题，避免将正确祈使句误判为不一致；同时应结合上下文检查整体步骤的语法统一性，而非孤立判断单一句子。"
    },
    {
      "defect_id": 479508,
      "sentence": "请取消设置操作，或者撤销已存在的访问/开放授权后再设置。",
      "reference_sentence": "请取消操作，或向支持认证服务的应用进行认证。",
      "line_num": 675,
      "context": "{\"670\":\"\",\"671\":\"该错误码表示授权列表已达上限，可能原因如下：设置访问/开放授权时，授权列表的大小超过1024。\",\"672\":\"\",\"673\":\"**处理步骤**\",\"674\":\"\",\"675\":\"请取消设置操作，或者撤销已存在的访问/开放授权后再设置。\"}",
      "用户拒绝的修改": "请取消操作，或者撤销已存在的访问/开放授权后再设置。",
      "注意事项": "必须优先识别并保留技术文档中的关键术语（如\"设置\"），确保操作名称与上下文术语严格一致，避免因过度简化破坏专业表述的准确性。"
    },
    {
      "defect_id": 480753,
      "sentence": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账户信息。 |",
      "reference_sentence": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账号信息。 |",
      "line_num": 337,
      "context": "{\"332\":\"\",\"333\":\"**参数：**\",\"334\":\"\",\"335\":\"  | 参数名 | 类型 | 必填 | 说明 |\",\"336\":\"  | -------- | -------- | -------- | -------- |\",\"337\":\"  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账户信息。 |\",\"338\":\"\",\"339\":\"**返回值：**\",\"340\":\"\",\"341\":\"  | 类型 | 说明 |\",\"342\":\"  | -------- | -------- |\"}",
      "用户拒绝的修改": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账号信息。 |",
      "注意事项": "修复时应严格遵循用户指定的统一术语（如\"账号\"），并全局检查文档中所有相关词汇的表述一致性，避免局部修改导致新的术语混用。"
    },
    {
      "defect_id": 480752,
      "sentence": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账户信息。 |",
      "reference_sentence": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账号信息。 |",
      "line_num": 247,
      "context": "{\"242\":\"\",\"243\":\"**参数：**\",\"244\":\"\",\"245\":\"  | 参数名 | 类型 | 必填 | 说明 |\",\"246\":\"  | -------- | -------- | -------- | -------- |\",\"247\":\"  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账户信息。 |\",\"248\":\"\",\"249\":\"**返回值：**\",\"250\":\"\",\"251\":\"  | 类型 | 说明 |\",\"252\":\"  | -------- | -------- |\"}",
      "用户拒绝的修改": "  | accountInfo | [DistributedInfo](#distributedinfo) | 是 | 分布式账号信息。 |",
      "注意事项": "修复前必须全局扫描文档确认术语统一标准，优先采用用户提供的参考案例中的用词形式（如\"账号\"），并确保所有关联字段同步更新。"
    },
    {
      "defect_id": 480039,
      "sentence": "支持以下事件：",
      "reference_sentence": "支持以下事件：",
      "line_num": 81,
      "context": "{\"76\":\"\",\"77\":\"不支持[通用事件](ts-component-general-events.md)。\",\"78\":\"\",\"79\":\"将事件经过坐标转换后异步传递给受限worker线程处理。\",\"80\":\"\",\"81\":\"支持以下事件：\",\"82\":\"\",\"83\":\"### onError\",\"84\":\"\",\"85\":\"onError(callback:ErrorCallback)\",\"86\":\"\"}",
      "用户拒绝的修改": "支持以下通用事件：",
      "注意事项": "修复时应首先核查上下文术语使用情况，确保修改后的表述与文档已有术语体系完全统一，若原术语在相邻段落已明确指向特定类型（如\"通用事件\"），则需保持类型限定词的使用一致性。"
    },
    {
      "defect_id": 479507,
      "sentence": "请取消添加操作，或者删除已存在的令牌后再添加。",
      "reference_sentence": "请取消操作，或向支持认证服务的应用进行认证。",
      "line_num": 661,
      "context": "{\"656\":\"\",\"657\":\"该错误码表示令牌数量已达上限，可能原因如下：添加令牌时，目标账号的令牌数量已达1024。\",\"658\":\"\",\"659\":\"**处理步骤**\",\"660\":\"\",\"661\":\"请取消添加操作，或者删除已存在的令牌后再添加。\",\"662\":\"\",\"663\":\"## 12400005 授权列表已达上限\",\"664\":\"\",\"665\":\"**错误信息**\",\"666\":\"\"}",
      "用户拒绝的修改": "请取消操作，或者删除已存在的令牌后再添加。",
      "注意事项": "保留原文中的核心操作动词（如\"添加\"），避免因统一表达而删除关键术语；修改前需确认术语在上下文中的必要性，特别是涉及具体功能或错误场景时不得省略限定词。"
    },
    {
      "defect_id": 479505,
      "sentence": "请使用存在的自定义数据的键名查询。",
      "reference_sentence": "请使用已成功打开的会话标识查询会话回调。",
      "line_num": 633,
      "context": "{\"628\":\"\",\"629\":\"该错误码表示自定义数据不存在，可能原因如下：查询账号的自定义数据时，输入的键名不存在。\",\"630\":\"\",\"631\":\"**处理步骤**\",\"632\":\"\",\"633\":\"请使用存在的自定义数据的键名查询。\",\"634\":\"\",\"635\":\"## 12400003 自定义数据的数量已达上限\",\"636\":\"\",\"637\":\"**错误信息**\",\"638\":\"\"}",
      "用户拒绝的修改": "请使用已存在的自定义数据的键名查询。",
      "注意事项": "严格检查上下文术语一致性，避免混淆核心概念（如区分“键名”和“会话标识”）；优先保持原句核心信息不变，仅在必要时进行最小化修正（如“存在”与“已存在”无实质差异时无需修改）。"
    },
    {
      "defect_id": 479986,
      "sentence": "独立Abc运行在受限worker可保证相对安全，独立Abc内容不影响主线程。",
      "reference_sentence": "创建IsolatedComponent组件，用于显示受限worker运行的Abc。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"**安全约束**\",\"34\":\"\",\"35\":\"1、独立Abc通过IsolatedComponent组件嵌入式显示在宿主进程，即可说明其Abc内容完全向宿主开放，宿主有权操作独立Abc的内容，对此安全敏感场景禁用。\",\"36\":\"\",\"37\":\"2、独立Abc运行在受限worker可保证相对安全，独立Abc内容不影响主线程。\",\"38\":\"\",\"39\":\"## 子组件\",\"40\":\"\",\"41\":\"无\",\"42\":\"\"}",
      "用户拒绝的修改": "独立abc文件运行在受限worker可保证相对安全，独立abc文件内容不影响主线程。",
      "注意事项": "在统一术语表述时，需优先核查上下文实际使用场景，若原词\"Abc\"在上下文中作为专有组件名称存在（如参考句的\"IsolatedComponent\"组件关联），应保留首字母大写且不加后缀；仅当明确指代文件时才补充\"文件\"类限定词。"
    },
    {
      "defect_id": 481558,
      "sentence": "createDataProxyHandle().then((dataProxyHandle) => {",
      "reference_sentence": "dataShare.createDataProxyHandle().then((dataProxyHandle) => {",
      "line_num": 48,
      "context": "{\"43\":\"import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\",\"44\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"45\":\"\",\"46\":\"export default class EntryAbility extends UIAbility {\",\"47\":\"  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\",\"48\":\"    dataShare.createDataProxyHandle().then((dataProxyHandle) => {\",\"49\":\"      console.info(\\\"createDataProxyHandle succeed\\\");\",\"50\":\"    }). catch((err: BusinessError) => {\",\"51\":\"      console.error(`createDataProxyHandle error: code: ${err.code}, message: ${err.message} `);\",\"52\":\"    });\",\"53\":\"  };\"}",
      "用户拒绝的修改": "dataShare.createDataProxyHandle().then((dataProxyHandle) => {",
      "注意事项": "在修复方法调用缺失前缀时，必须严格校验问题句子的上下文引用关系，若问题句子所在行已正确包含对象前缀（如48行的dataShare.createDataProxyHandle），则禁止重复添加；同时需确保问题句子的行号提取准确性，避免跨行语句切割错误。"
    },
    {
      "defect_id": 479504,
      "sentence": "请取消设置，或使用已安装的应用包名重试。",
      "reference_sentence": "请取消操作，或向支持认证服务的应用进行认证。",
      "line_num": 619,
      "context": "{\"614\":\"1. 设置访问权限时，目标应用不存在。\",\"615\":\"2. 设置开放授权时，目标应用不存在。\",\"616\":\"\",\"617\":\"**处理步骤**\",\"618\":\"\",\"619\":\"请取消设置，或使用已安装的应用包名重试。\",\"620\":\"\",\"621\":\"## 12400002 自定义数据不存在\",\"622\":\"\",\"623\":\"**错误信息**\",\"624\":\"\"}",
      "用户拒绝的修改": "请取消操作，或使用已安装的应用包名重试。",
      "注意事项": "保持上下文术语一致性，避免替换原文核心动作词汇（如\"设置\"）；修改前需核查相邻条目中重复出现的关键词，确保操作步骤描述与上下文形成完整逻辑链条。"
    },
    {
      "defect_id": 482660,
      "sentence": "系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。",
      "reference_sentence": "账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。",
      "line_num": 5,
      "context": "{\"1\":\"# 账号管理概述\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。按照使用场景，账号模块负责管理以下类别的账号：\",\"10\":\"\"}",
      "用户拒绝的修改": "系统支持在一台设备上创建多个本地系统帐户，以允许多个用户使用同一台设备。多个用户的数据按系统帐户进行隔离，以保证不同用户数据的安全性。",
      "注意事项": "修复时必须严格遵循上下文已确立的术语体系（如\"账号\"），优先检查问题段落所在章节的标题和基本概念定义，禁止基于同义词库进行主观替换。"
    },
    {
      "defect_id": 479792,
      "sentence": "4. 点击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequestListener”相关信息；",
      "reference_sentence": "3. 分别点击使用方的“Register Push Listener”按钮和提供方的“Register Request Listener”按钮注册监听；",
      "line_num": 139,
      "context": "{\"134\":\"\",\"135\":\"本示例展示`PluginComponent`组件的基础使用方式，需要创建一个`bundleName`为\\\"com.example.user\\\"的[使用方应用](#组件使用方)，和一个`bundleName`为\\\"com.example.provider\\\"的[提供方应用](#组件提供方)。应用项目构建完成后，具体测试步骤如下：\",\"136\":\"1. 将两个应用的hap包安装到设备上；\",\"137\":\"2. 打开使用方应用页面，使用方与提供方内容都正确显示；\",\"138\":\"3. 分别点击使用方的“Register Push Listener”按钮和提供方的“Register Request Listener”按钮注册监听；\",\"139\":\"4. 点击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequestListener”相关信息；\",\"140\":\"5. 点击提供方的“Push”按钮向使用方发送事件，日志中打印“onPushListener”相关信息。\",\"141\":\"\",\"142\":\"### 组件使用方\",\"143\":\"\",\"144\":\"使用方应用的`bundleName`为\\\"com.example.user\\\"，包含一个页面。\"}",
      "用户拒绝的修改": "4. 单击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequestListener”相关信息；",
      "注意事项": "修复时应优先检查上下文术语使用习惯（如上下文中统一使用“点击”则无需替换为“单击”），避免脱离文档整体一致性进行孤立修改。"
    },
    {
      "defect_id": 481557,
      "sentence": "import { dataShare } from '@kit.ArkData';",
      "reference_sentence": "import { dataShare } from '@ohos.data.dataShare';",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"\",\"12\":\"## 导入模块\",\"13\":\"\",\"14\":\"```ts\",\"15\":\"import { dataShare } from '@kit.ArkData';\",\"16\":\"```\",\"17\":\"\",\"18\":\"\",\"19\":\"## dataShare.createDataProxyHandle<sup>20+</sup>\",\"20\":\"\"}",
      "用户拒绝的修改": "import { dataShare } from '@ohos.data.dataShare';",
      "注意事项": "修复前需验证模块名的实际可用性和版本兼容性，优先匹配上下文已有导入语句的命名规范，避免仅依赖通用规则而忽略项目特定别名或官方最新命名约定。"
    },
    {
      "defect_id": 482723,
      "sentence": "能力限制：应用卸载场景下，被卸载应用的账号数据会被删除；本地账号删除场景下，被删除本地账号下的所有应用的账号数据会被删除。",
      "reference_sentence": "能力限制：应用卸载场景下，被卸载应用的帐户数据会被删除；本地帐户删除场景下，被删除本地帐户下的所有应用的帐户数据会被删除。",
      "line_num": 5,
      "context": "{\"1\":\"# 管理应用账号\",\"2\":\"\",\"3\":\"应用开发者可以使用[应用账号SDK](../../reference/apis-basic-services-kit/js-apis-appAccount.md)管理本应用的账号数据。\",\"4\":\"\",\"5\":\"能力限制：应用卸载场景下，被卸载应用的账号数据会被删除；本地账号删除场景下，被删除本地账号下的所有应用的账号数据会被删除。\",\"6\":\"\",\"7\":\"## 开发准备\",\"8\":\"\",\"9\":\"1. 导入应用账号模块。\",\"10\":\"\"}",
      "用户拒绝的修改": "能力限制：应用卸载场景下，被卸载应用的帐户数据会被删除；本地帐户删除场景下，被删除本地帐户下的所有应用的帐户数据会被删除。",
      "注意事项": "修复术语一致性时必须优先核查上下文现有用词规范，若用户已明确指定统一术语（如\"账号\"），即使参考句子存在差异也应严格遵循用户要求，避免机械替换引入新矛盾。"
    },
    {
      "defect_id": 482722,
      "sentence": "应用开发者可以使用[应用账号SDK](../../reference/apis-basic-services-kit/js-apis-appAccount.md)管理本应用的账号数据。",
      "reference_sentence": "应用开发者可以使用[应用账号SDK](../../reference/apis-basic-services-kit/js-apis-appAccount.md)管理本应用的帐户数据。",
      "line_num": 3,
      "context": "{\"1\":\"# 管理应用账号\",\"2\":\"\",\"3\":\"应用开发者可以使用[应用账号SDK](../../reference/apis-basic-services-kit/js-apis-appAccount.md)管理本应用的账号数据。\",\"4\":\"\",\"5\":\"能力限制：应用卸载场景下，被卸载应用的账号数据会被删除；本地账号删除场景下，被删除本地账号下的所有应用的账号数据会被删除。\",\"6\":\"\",\"7\":\"## 开发准备\",\"8\":\"\"}",
      "用户拒绝的修改": "应用开发者可以使用[应用账号SDK](../../reference/apis-basic-services-kit/js-apis-appAccount.md)管理本应用的帐户数据。",
      "注意事项": "修复术语不一致时必须先核查上下文中的统一用词规范，优先沿用文档已确定的术语（如“账号”），即使存在其他常见变体（如“帐户”）也需保持内部一致性。"
    },
    {
      "defect_id": 482729,
      "sentence": "3. 调用[getCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcustomdata9)接口，获取账号的自定义数据。",
      "reference_sentence": "3. 调用[getCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcustomdata9)接口，获取帐户的自定义数据。",
      "line_num": 117,
      "context": "{\"112\":\"   }).catch((err: BusinessError) => {\",\"113\":\"       console.error('setCustomData failed: ' + JSON.stringify(err));\",\"114\":\"   });\",\"115\":\"   ```\",\"116\":\"\",\"117\":\"3. 调用[getCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcustomdata9)接口，获取账号的自定义数据。\",\"118\":\"\",\"119\":\"   ```ts\",\"120\":\"   appAccountManager.getCustomData(name, key).then((data: string) => {\",\"121\":\"       console.log('getCustomData successfully, data: ' + data);\",\"122\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "3. 调用[getCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcustomdata9)接口，获取帐户的自定义数据。",
      "注意事项": "修复术语一致性时必须严格遵循用户指定的统一用词（如\"账号\"），优先检查上下文现有用词模式，避免过度依赖参考句子导致反向破坏一致性。"
    },
    {
      "defect_id": 482739,
      "sentence": "指定要删除的账号名称，调用[removeAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#removeaccount9)接口删除账号。",
      "reference_sentence": "用户退出登录后，应用需及时将相应的应用账号从系统中删除。",
      "line_num": 166,
      "context": "{\"161\":\"\",\"162\":\"用户退出登录后，应用需及时将相应的应用账号从系统中删除。\",\"163\":\"\",\"164\":\"具体开发实例如下：\",\"165\":\"\",\"166\":\"指定要删除的账号名称，调用[removeAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#removeaccount9)接口删除账号。\",\"167\":\"\",\"168\":\"   ```ts\",\"169\":\"   let name: string = 'Zhangsan';\",\"170\":\"   appAccountManager.removeAccount(name).then(() => {\",\"171\":\"       console.log('removeAccount successfully');\"}",
      "用户拒绝的修改": "指定要移除的账号名称，调用[removeAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#removeaccount9)接口移除账号。",
      "注意事项": "修复时必须严格核对上下文实际用词，优先采用问题句子所在段落已存在的标准术语（如参考句中的\"删除\"），避免因误判前文表述而错误替换正确词汇。"
    },
    {
      "defect_id": 482661,
      "sentence": "账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。",
      "reference_sentence": "系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。按照使用场景，账号模块负责管理以下类别的账号：\",\"10\":\"\",\"11\":\"- 系统账号：表示用户在端侧设备上的身份标识，该标识在每个端侧设备上唯一。\",\"12\":\"\",\"13\":\"- 域账号：表示用户在特定域内（比如公司、学校等）的身份标识，该标识在特定域内唯一。\",\"14\":\"\"}",
      "用户拒绝的修改": "帐户是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种帐户。",
      "注意事项": "修复时必须优先核对上下文术语使用习惯，对\"账号/帐户\"等同音异形词要严格保持全文统一，禁止在参考句已明确用词规范的情况下进行概念替换。"
    },
    {
      "defect_id": 482685,
      "sentence": "当需要验证域账号身份（比如屏幕解锁、登录会话失效等场景）时，可以使用系统提供的接口对域账号进行身份认证。",
      "reference_sentence": "当需要验证域账号身份（比如屏幕解锁、登录会话失效等场景）时，可以使用系统提供的接口对域账号进行身份认证。",
      "line_num": 3,
      "context": "{\"1\":\"# 认证域账号（仅对系统应用开放）\",\"2\":\"\",\"3\":\"当需要验证域账号身份（比如屏幕解锁、登录会话失效等场景）时，可以使用系统提供的接口对域账号进行身份认证。\",\"4\":\"\",\"5\":\"## 开发准备\",\"6\":\"\",\"7\":\"导入系统账号模块。\",\"8\":\"\"}",
      "用户拒绝的修改": "当需要验证域账号身份（比如屏幕解锁、登录会话失效等场景）时，可以使用系统提供的接口对域账号进行认证。",
      "注意事项": "在修复术语不一致时，需优先核对上下文中的核心术语使用习惯（如标题\"认证域账号\"中的动词\"认证\"与正文名词性表述\"身份认证\"的共存关系），避免机械替换破坏技术场景下的固定搭配。"
    },
    {
      "defect_id": 482724,
      "sentence": "用户在应用中登录后，开发者可以在系统中创建一个关联的应用账号，后续可以基于此账号进行数据管理。",
      "reference_sentence": "用户在应用中登录后，开发者可以在系统中创建一个关联的应用帐户，后续可以基于此帐户进行数据管理。",
      "line_num": 23,
      "context": "{\"18\":\"   const appAccountManager = appAccount.createAppAccountManager();\",\"19\":\"   ```\",\"20\":\"\",\"21\":\"## 创建应用账号\",\"22\":\"\",\"23\":\"用户在应用中登录后，开发者可以在系统中创建一个关联的应用账号，后续可以基于此账号进行数据管理。\",\"24\":\"\",\"25\":\"具体开发实例如下：\",\"26\":\"\",\"27\":\"1. 参数准备，指定账号名和可选配置。\",\"28\":\"\"}",
      "用户拒绝的修改": "用户在应用中登录后，开发者可以在系统中创建一个关联的应用帐户，后续可以基于此帐户进行数据管理。",
      "注意事项": "修复术语一致性时必须全面检查上下文中的既有用词（如示例中\"应用账号\"已在标题和代码注释出现），同时要验证用户提供的参考句子是否符合实际规范要求，避免盲目跟随错误示例。"
    },
    {
      "defect_id": 482727,
      "sentence": "3. 调用[setCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcredential9)接口，设置账号的凭据。",
      "reference_sentence": "3. 调用[setCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcredential9)接口，设置帐户的凭据。",
      "line_num": 85,
      "context": "{\"80\":\"   }).catch((err: BusinessError) => {\",\"81\":\"       console.error('getCredential failed, error: ' + JSON.stringify(err));\",\"82\":\"   });\",\"83\":\"   ```\",\"84\":\"\",\"85\":\"3. 调用[setCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcredential9)接口，设置账号的凭据。\",\"86\":\"\",\"87\":\"   ```ts\",\"88\":\"   appAccountManager.setCredential(name, credentialType, credential).then(() => {\",\"89\":\"       console.log('setCredential successfully');\",\"90\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "3. 调用[setCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcredential9)接口，设置帐户的凭据。",
      "注意事项": "修改术语前必须严格核对上下文已有用词（如“账号”vs“帐户”），优先遵循用户指定的统一规范而非通用词典，确保同一文档内术语表述零冲突。"
    },
    {
      "defect_id": 482695,
      "sentence": "设备所有者可以给指定系统账号设置约束，以限制该账号的行为。例如在家长模式下，家长可能禁止儿童打开WIFI、安装应用等。",
      "reference_sentence": "账号管理模块提供了基于角色的访问控制机制，用户可以为系统账号设置约束，以限制目标账号的行为。",
      "line_num": 27,
      "context": "{\"22\":\"   let accountManager = osAccount.getAccountManager();\",\"23\":\"   ```\",\"24\":\"\",\"25\":\"## 设置指定系统账号的约束列表\",\"26\":\"\",\"27\":\"设备所有者可以给指定系统账号设置约束，以限制该账号的行为。例如在家长模式下，家长可能禁止儿童打开WIFI、安装应用等。\",\"28\":\"\",\"29\":\"具体开发实例如下：\",\"30\":\"\",\"31\":\"1. 指定系统账号标识和待使能的约束集合。\",\"32\":\"\"}",
      "用户拒绝的修改": "设备所有者可以给指定系统账号设置约束，以限制该账号的行为。例如在家长模式下，设备所有者可能禁止儿童打开WIFI、安装应用等。",
      "注意事项": "保持上下文术语分层一致性时需区分\"角色统称\"和\"具体实例\"的合理转换，在示例场景中允许使用符合情境的具体角色称谓（如\"家长\"），避免过度统一导致示例失焦。"
    },
    {
      "defect_id": 482738,
      "sentence": "用户退出登录后，应用需及时将相应的应用账号从系统中删除。",
      "reference_sentence": "## 删除应用账号",
      "line_num": 162,
      "context": "{\"157\":\"   });\",\"158\":\"   ```\",\"159\":\"\",\"160\":\"## 删除应用账号\",\"161\":\"\",\"162\":\"用户退出登录后，应用需及时将相应的应用账号从系统中删除。\",\"163\":\"\",\"164\":\"具体开发实例如下：\",\"165\":\"\",\"166\":\"指定要删除的账号名称，调用[removeAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#removeaccount9)接口删除账号。\",\"167\":\"\"}",
      "用户拒绝的修改": "用户退出登录后，应用需及时将相应的应用账号从系统中移除。",
      "注意事项": "修改前必须全面检查上下文术语一致性，优先沿用原文已有高频词汇；涉及关键操作动词时需核对章节标题、代码注释等关联位置，避免同义词替换破坏统一性。"
    },
    {
      "defect_id": 482728,
      "sentence": "2. 调用[setCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcustomdata9)接口，设置账号的自定义数据。",
      "reference_sentence": "2. 调用[setCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcustomdata9)接口，设置帐户的自定义数据。",
      "line_num": 107,
      "context": "{\"102\":\"   let name: string = 'ZhangSan';\",\"103\":\"   let key: string = 'age';\",\"104\":\"   let value: string = '12';\",\"105\":\"   ```\",\"106\":\"\",\"107\":\"2. 调用[setCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcustomdata9)接口，设置账号的自定义数据。\",\"108\":\"\",\"109\":\"   ```ts\",\"110\":\"   appAccountManager.setCustomData(name, key, value).then(() => {\",\"111\":\"       console.log('setCustomData successfully');\",\"112\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "2. 调用[setCustomData](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setcustomdata9)接口，设置帐户的自定义数据。",
      "注意事项": "修复术语不一致时应严格遵循用户指定的统一词汇，并优先检查上下文及已有规范，确保替换前确认文档中所有相关术语的使用一致性。"
    },
    {
      "defect_id": 482694,
      "sentence": "账号管理模块提供了基于角色的访问控制机制，用户可以为系统账号设置约束，以限制目标账号的行为。",
      "reference_sentence": "使用约束管控系统账号（仅对系统应用开放）",
      "line_num": 3,
      "context": "{\"1\":\"# 使用约束管控系统账号（仅对系统应用开放）\",\"2\":\"\",\"3\":\"账号管理模块提供了基于角色的访问控制机制，用户可以为系统账号设置约束，以限制目标账号的行为。\",\"4\":\"\",\"5\":\"## 约束列表\",\"6\":\"\",\"7\":\"预定义的账号约束条件，可以参考：[系统账号约束列表](../../reference/apis-basic-services-kit/js-apis-osAccount.md#系统账号约束列表)。\",\"8\":\"\"}",
      "用户拒绝的修改": "账号管理模块提供了基于角色的访问控制机制，设备所有者可以为系统账号设置约束，以限制目标账号的行为。",
      "注意事项": "严格遵循上下文中的术语定义和权限范围，确保替换后的主体名词（如“用户”“设备所有者”）与当前章节的限定条件（如“仅对系统应用开放”）及全局文档的权限体系保持一致，避免引入未定义或超范围的主体角色。"
    },
    {
      "defect_id": 482773,
      "sentence": "## 在指定的系统账号上登录绑定分布式账号",
      "reference_sentence": "## 在当前系统账号上登录绑定分布式账号",
      "line_num": 79,
      "context": "{\"74\":\"   }).catch((err: BusinessError) => {\",\"75\":\"       console.error('setOsAccountDistributedInfo exception: '  + JSON.stringify(err));\",\"76\":\"   });\",\"77\":\"   ```\",\"78\":\"\",\"79\":\"## 在指定的系统账号上登录绑定分布式账号\",\"80\":\"\",\"81\":\"具体开发实例如下：\",\"82\":\"\",\"83\":\"1. 确定目标系统账号，并定义待登录的分布式账号信息。其中，登录场景下需将event指定为\\\"Ohos.account.event.LOGIN\\\"。\",\"84\":\"\"}",
      "用户拒绝的修改": "## 在指定系统账号上登录绑定分布式账号",
      "注意事项": "修复时应全面核查上下文术语一致性，优先沿用文档已有表述（如\"当前系统账号\"）而非主观调整措辞，避免仅关注局部语法优化而忽略整体术语体系统一性。"
    },
    {
      "defect_id": 482696,
      "sentence": "业务应用需要判断目标系统账号的指定约束是否使能，以此来决策是否对目标系统账号的行为做管控。开发者可以使用[isOsAccountConstraintEnabled](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#isosaccountconstraintenabled11)接口完成此操作。",
      "reference_sentence": "账号管理模块提供了基于角色的访问控制机制，用户可以为系统账号设置约束，以限制目标账号的行为。",
      "line_num": 51,
      "context": "{\"46\":\"   }\",\"47\":\"   ```\",\"48\":\"\",\"49\":\"## 判断目标系统账号的指定约束是否使能\",\"50\":\"\",\"51\":\"业务应用需要判断目标系统账号的指定约束是否使能，以此来决策是否对目标系统账号的行为做管控。开发者可以使用[isOsAccountConstraintEnabled](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#isosaccountconstraintenabled11)接口完成此操作。\",\"52\":\"\",\"53\":\"具体开发实例如下：\",\"54\":\"\",\"55\":\"1. 指定系统账号标识和约束名称。\",\"56\":\"\"}",
      "用户拒绝的修改": "业务应用需要判断目标系统账号的指定约束是否使能，以此来决策是否对目标系统账号的行为做管控。设备所有者可以使用[isOsAccountConstraintEnabled](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#isosaccountconstraintenabled11)接口完成此操作。",
      "注意事项": "修复时应严格遵循上下文中的术语定义和角色区分，避免跨概念替换（如\"开发者\"与\"用户\"），需通过上下文验证目标主体是否与接口调用者的技术角色一致（如API使用者是否为开发人员）。"
    },
    {
      "defect_id": 482726,
      "sentence": "2. 调用[getCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcredential9)接口，获取账号的凭据。",
      "reference_sentence": "2. 调用[getCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcredential9)接口，获取帐户的凭据。",
      "line_num": 75,
      "context": "{\"70\":\"   let name: string = 'ZhangSan';\",\"71\":\"   let credentialType: string = 'PIN_SIX';\",\"72\":\"   let credential: string = 'xxxxxx';\",\"73\":\"   ```\",\"74\":\"\",\"75\":\"2. 调用[getCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcredential9)接口，获取账号的凭据。\",\"76\":\"\",\"77\":\"   ```ts\",\"78\":\"   appAccountManager.getCredential(name, credentialType).then((data: string) => {\",\"79\":\"       console.log('getCredential successfully, data: ' + data);\",\"80\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "2. 调用[getCredential](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getcredential9)接口，获取帐户的凭据。",
      "注意事项": "修复术语不一致时，需优先检查上下文和用户指定规则（如“统一使用‘账号’”），避免依赖自身语料库默认映射；同时需验证修改后的术语是否与文档其他部分及API命名逻辑（如接口名getCredential隐含\"credential\"而非\"account\"）保持统一。"
    },
    {
      "defect_id": 482775,
      "sentence": "3. 在账号绑定之后，可以调用[getOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#getosaccountdistributedinfobylocalid10)接口查看分布式账号的登录信息。",
      "reference_sentence": "3. 在账号绑定之后，可以调用[getOsAccountDistributedInfo](../../reference/apis-basic-services-kit/js-apis-distributed-account.md#getosaccountdistributedinfo9)接口查看分布式账号的登录信息。",
      "line_num": 104,
      "context": "{\"99\":\"   }).catch((err: BusinessError) => {\",\"100\":\"       console.error('setOsAccountDistributedInfoByLocalId exception: '  + JSON.stringify(err));\",\"101\":\"   });\",\"102\":\"   ```\",\"103\":\"\",\"104\":\"3. 在账号绑定之后，可以调用[getOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#getosaccountdistributedinfobylocalid10)接口查看分布式账号的登录信息。\",\"105\":\"\",\"106\":\"   ```ts\",\"107\":\"   distributedAccountAbility.getOsAccountDistributedInfoByLocalId(localId).then((data: distributedAccount.DistributedInfo) => {\",\"108\":\"       console.log('distributed information: ' + JSON.stringify(data));\",\"109\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "3. 在账号绑定之后，可以调用[getOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#getosaccountdistributedinfobylocalid10)接口查看目标系统账号的分布式账号登录信息。",
      "注意事项": "修复时必须严格保持接口名称与上下文引用的完全一致，避免混淆不同API；同时需核对问题上下文中的实际代码示例，确保术语使用与现有文档体系保持统一。"
    },
    {
      "defect_id": 482686,
      "sentence": "在无法获取用户密码的情况下，需要认证域账号时，可以请求系统弹窗验证域账号用户。",
      "reference_sentence": "在无法获取用户密码的情况下，需要认证域账号时，可以请求系统弹窗验证域账号用户。",
      "line_num": 54,
      "context": "{\"49\":\"   }\",\"50\":\"   ```\",\"51\":\"\",\"52\":\"## 弹窗认证域账号\",\"53\":\"\",\"54\":\"在无法获取用户密码的情况下，需要认证域账号时，可以请求系统弹窗验证域账号用户。开发者可以使用[authWithPopup](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#authwithpopup10)完成此操作。\",\"55\":\"\",\"56\":\"具体开发实例如下：\",\"57\":\"\",\"58\":\"1. 定义认证结果回调对象。\",\"59\":\"\"}",
      "用户拒绝的修改": "在无法获取用户密码的情况下，需要认证域账号时，可以请求系统弹窗认证域账号用户。",
      "注意事项": "修复术语一致性时应优先确认动词/名词的语法功能匹配性，若参考上下文中\"认证\"作为章节标题（名词性用法），则需保留原句\"验证\"的动词属性以维持技术动作的准确性。"
    },
    {
      "defect_id": 482803,
      "sentence": "用户可以删除不再使用的域账号。由于域账号和系统账号是一一绑定关系，开发者可以使用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口删除与目标域账号绑定的系统账号，进而实现删除域账号。",
      "reference_sentence": "用户在设置中添加其他域账号，允许其他域账号用户使用同一设备。开发者可以使用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)完成此操作。",
      "line_num": 82,
      "context": "{\"77\":\"   }\",\"78\":\"   ```\",\"79\":\"\",\"80\":\"## 删除域账号\",\"81\":\"\",\"82\":\"用户可以删除不再使用的域账号。由于域账号和系统账号是一一绑定关系，开发者可以使用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口删除与目标域账号绑定的系统账号，进而实现删除域账号。\",\"83\":\"\",\"84\":\"具体开发实例如下：\",\"85\":\"\",\"86\":\"1. 调用[getOsAccountLocalIdForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount.md#getosaccountlocalidfordomain9)方法，根据域账号信息获取系统账号ID。\",\"87\":\"\"}",
      "用户拒绝的修改": "用户可以移除不再使用的域账号。由于域账号和系统账号是一一绑定关系，开发者可以使用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口移除与目标域账号绑定的系统账号，进而实现移除域账号。",
      "注意事项": "修复时应严格遵循上下文已有术语（如标题\"删除域账号\"中的\"删除\"），避免近义词替换；需检查全段动词一致性，确保操作描述与API接口名称（如removeOsAccount）的语义保持逻辑对应。"
    },
    {
      "defect_id": 482804,
      "sentence": "用户通过身份认证后，可以查询自己或他人的域账号信息。开发者可以使用[getAccountInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getaccountinfo10)接口完成此操作。",
      "reference_sentence": "用户在设置中添加其他域账号，允许其他域账号用户使用同一设备。开发者可以使用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)完成此操作。",
      "line_num": 120,
      "context": "{\"115\":\"   }\",\"116\":\"   ```\",\"117\":\"\",\"118\":\"## 查询域账号信息\",\"119\":\"\",\"120\":\"用户通过身份认证后，可以查询自己或他人的域账号信息。开发者可以使用[getAccountInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getaccountinfo10)接口完成此操作。\",\"121\":\"\",\"122\":\"具体开发实例如下：\",\"123\":\"\",\"124\":\"1. 定义查询选项，可以指定需要查询的域名和账号名。选项的类型为[GetDomainAccountInfoOptions](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getdomainaccountinfooptions10)。\",\"125\":\"\"}",
      "用户拒绝的修改": "用户通过身份认证后，查询自己或他人的域账号信息。开发者可以使用[getAccountInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getaccountinfo10)接口完成此操作。",
      "注意事项": "修复时应优先保持用户操作描述的客观陈述语气，避免机械统一句式导致语义偏差；需结合上下文确认目标段落是用户指南还是开发者指引，区分\"用户可以...\"和\"开发者可以...\"的表述场景。"
    },
    {
      "defect_id": 482725,
      "sentence": "2. 调用[createAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#createaccount9)接口，根据名称和选项创建应用账号。",
      "reference_sentence": "2. 调用[createAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#createaccount9)接口，根据名称和选项创建应用帐户。",
      "line_num": 38,
      "context": "{\"33\":\"       age: '10'\",\"34\":\"     }\",\"35\":\"   };\",\"36\":\"   ```\",\"37\":\"\",\"38\":\"2. 调用[createAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#createaccount9)接口，根据名称和选项创建应用账号。\",\"39\":\"\",\"40\":\"   ```ts\",\"41\":\"   appAccountManager.createAccount(name, options).then(()=>{\",\"42\":\"    console.log('createAccount successfully');\",\"43\":\"  }).catch((err: BusinessError)=>{\"}",
      "用户拒绝的修改": "2. 调用[createAccount](../../reference/apis-basic-services-kit/js-apis-appAccount.md#createaccount9)接口，根据名称和选项创建应用帐户。",
      "注意事项": "修复前必须全局检查文档中术语的统一性（如\"账号\"与\"帐户\"），优先遵循用户明确指定的用词规范，而非依赖局部上下文或参考句子的孤立判断。"
    },
    {
      "defect_id": 482662,
      "sentence": "删除系统账号后，与之关联的域账号、分布式账号和应用账号也随之删除。",
      "reference_sentence": "系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。",
      "line_num": 30,
      "context": "{\"25\":\"- 域账号与系统账号存在一对一关联关系，两者的生命周期一致。\",\"26\":\"- 分布式账号与系统账号存在一对多关联关系，用户可以在每个系统账号下绑定一个分布式账号；不同系统账号下，分布式账号可以重复。分布式账号的生命周期独立于系统账号。\",\"27\":\"- 应用账号与系统账号存在多对多关联关系，用户可以在不同系统账号下管理多个应用账号；不同系统账号下，应用账号可以重复。应用账号的生命周期独立于系统账号。\",\"28\":\"- 域账号、分布式账号和应用账号相互之间无直接关联关系。\",\"29\":\"\",\"30\":\"删除系统账号后，与之关联的域账号、分布式账号和应用账号也随之删除。\",\"31\":\"\",\"32\":\"## 相关实例\",\"33\":\"\",\"34\":\"针对账号管理开发，有以下相关实例可供参考：\",\"35\":\"\"}",
      "用户拒绝的修改": "删除系统帐户后，与之关联的域帐户、分布式帐户和应用帐户也随之删除。",
      "注意事项": "修复时必须优先核对上下文术语使用习惯，在涉及专业术语或特定用词时禁止自主替换同义词，应严格沿用文档既有表述形式（如\"账号\"）保持全文统一。"
    },
    {
      "defect_id": 482774,
      "sentence": "2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定分布式账号与当前系统账号绑定。",
      "reference_sentence": "2. 调用[setOsAccountDistributedInfo](../../reference/apis-basic-services-kit/js-apis-distributed-account.md#setosaccountdistributedinfo9)接口，将当前系统账号与指定分布式账号绑定到一起。",
      "line_num": 94,
      "context": "{\"89\":\"       id: '12345',\",\"90\":\"       event: 'Ohos.account.event.LOGIN',\",\"91\":\"   };\",\"92\":\"   ```\",\"93\":\"\",\"94\":\"2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定分布式账号与当前系统账号绑定。\",\"95\":\"\",\"96\":\"   ```ts\",\"97\":\"   distributedAccountAbility.setOsAccountDistributedInfoByLocalId(localId, distributedInfo).then(() => {\",\"98\":\"       console.log('setOsAccountDistributedInfoByLocalId successfully');\",\"99\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定的分布式账号与目标系统账号绑定。",
      "注意事项": "修复时应优先保持原文核心语义不变，避免引入未在上下文出现的术语（如\"目标系统账号\"）；需严格核对接口参数对应关系，确保\"指定\"与\"当前\"等限定词的使用与接口定义及代码示例完全一致。"
    },
    {
      "defect_id": 482838,
      "sentence": "1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。",
      "reference_sentence": "1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"OEM厂商可以采用插件方式定制化域账号管理能力，系统提供了域账号插件注册和注销能能力。\",\"4\":\"\",\"5\":\"## 开发准备\",\"6\":\"\",\"7\":\"1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。\",\"8\":\"   - ohos.permission.MANAGE_LOCAL_ACCOUNTS\",\"9\":\"   - ohos.permission.GET_DOMAIN_ACCOUNTS\",\"10\":\"\",\"11\":\"2. 导入系统账号模块。\",\"12\":\"\"}",
      "用户拒绝的修改": "1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic级别应用申请权限的方式)。",
      "注意事项": "修改术语前必须优先核对文档上下文和用户提供的参考句子中的现有用法，确保术语一致性；当术语表与上下文用法冲突时，需通过追问确认优先级，避免机械替换导致文档内部矛盾。"
    },
    {
      "defect_id": 482982,
      "sentence": "  - [管理域账号插件](manage-domain-plugin.md)",
      "reference_sentence": "无",
      "line_num": 11,
      "context": "{\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\",\"16\":\"  - [管理应用账号](manage-application-account.md)\"}",
      "用户拒绝的修改": "  - [管理域帐户插件](manage-domain-plugin.md)",
      "注意事项": "在应用术语规则前必须优先检查上下文中的现有统一用法，当规则与文档实际用词冲突时，应以上下文实际使用的高频词为准维持一致性。"
    },
    {
      "defect_id": 482986,
      "sentence": "  - [管理应用账号](manage-application-account.md)",
      "reference_sentence": "无",
      "line_num": 16,
      "context": "{\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\",\"16\":\"  - [管理应用账号](manage-application-account.md)\"}",
      "用户拒绝的修改": "  - [管理应用帐户](manage-application-account.md)",
      "注意事项": "修复时应优先检查上下文中的现有术语使用情况（如\"账号\"在相邻条目中重复出现），确保与项目内部统一用词规范一致，而非机械套用通用语言规则。"
    },
    {
      "defect_id": 482975,
      "sentence": "- 系统账号（仅对系统应用开放）<!--os-account-->",
      "reference_sentence": "无",
      "line_num": 4,
      "context": "{\"1\":\"# 账号管理<!--account-management-->\",\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\"}",
      "用户拒绝的修改": "- 系统帐户（仅对系统应用开放）<!--os-account-->",
      "注意事项": "修改术语前必须优先检查上下文中的现有用词规范，若文档已存在统一术语（如\"账号\"），即使与常规规则冲突也应优先保持内部一致性，禁止机械替换。"
    },
    {
      "defect_id": 482976,
      "sentence": "  - [管理系统账号](manage-os-account.md)",
      "reference_sentence": "无",
      "line_num": 5,
      "context": "{\"1\":\"# 账号管理<!--account-management-->\",\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\"}",
      "用户拒绝的修改": "  - [管理系统帐户](manage-os-account.md)",
      "注意事项": "修复时应首先检查上下文中的现有术语使用情况（如\"账号\"在标题和多个条目中已统一使用），优先遵循项目内部术语一致性而非通用规则；当用户明确指定统一用词时，应以用户要求为准覆盖常规转换规则。"
    },
    {
      "defect_id": 482981,
      "sentence": "  - [认证域账号](auth-domain-account.md)",
      "reference_sentence": "无",
      "line_num": 10,
      "context": "{\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\"}",
      "用户拒绝的修改": "  - [认证域帐户](auth-domain-account.md)",
      "注意事项": "修复前必须优先检查上下文术语一致性，若用户已明确指定统一用词（如‘账号’），应直接遵循用户指定而非机械应用通用替换规则，并主动对比相邻条目确保全文统一。"
    },
    {
      "defect_id": 482973,
      "sentence": "# 账号管理<!--account-management-->",
      "reference_sentence": "无",
      "line_num": 1,
      "context": "{\"1\":\"# 账号管理<!--account-management-->\",\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\"}",
      "用户拒绝的修改": "# 帐户管理<!--account-management-->",
      "注意事项": "修复前必须优先确认用户或项目的特定术语规范（如\"账号\"不可替换为\"帐户\"），并严格检查上下文中的现存用词一致性，避免机械套用通用规则。"
    },
    {
      "defect_id": 482984,
      "sentence": "  - [管理分布式账号](manage-distributed-account.md)",
      "reference_sentence": "无",
      "line_num": 13,
      "context": "{\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\",\"16\":\"  - [管理应用账号](manage-application-account.md)\"}",
      "用户拒绝的修改": "  - [管理分布式帐户](manage-distributed-account.md)",
      "注意事项": "修复前必须全面检查上下文中的现有术语使用情况，当项目存在明确术语规范时应优先遵循内部约定而非通用规则，确保\"账号/帐户\"等近义词在整个文档中保持完全一致。"
    },
    {
      "defect_id": 482980,
      "sentence": "  - [管理域账号](manage-domain-account.md)",
      "reference_sentence": "无",
      "line_num": 9,
      "context": "{\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\"}",
      "用户拒绝的修改": "  - [管理域帐户](manage-domain-account.md)",
      "注意事项": "在修改术语前必须全面检查上下文中的现有用词习惯，优先保持文档内部统一性；当规则与用户实际使用情况冲突时，应以用户显式指定的术语为准而非机械套用通用规则。"
    },
    {
      "defect_id": 482791,
      "sentence": "用户在设置中添加其他域账号，允许其他域账号用户使用同一设备。",
      "reference_sentence": "用户可以在系统中添加域账号，后续可以域账号身份登录、使用系统。",
      "line_num": 50,
      "context": "{\"45\":\"   });\",\"46\":\"   ```\",\"47\":\"\",\"48\":\"## 添加域账号\",\"49\":\"\",\"50\":\"用户在设置中添加其他域账号，允许其他域账号用户使用同一设备。开发者可以使用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)完成此操作。\",\"51\":\"\",\"52\":\"具体开发实例如下：\",\"53\":\"\",\"54\":\"1. 定义域账号信息，指定域名、账号名、账号标识（可选）。\",\"55\":\"\"}",
      "用户拒绝的修改": "用户在设置中添加其他域账号，允许其他域账号使用同一设备。",
      "注意事项": "在统一术语表述时需优先保持逻辑主语完整性，若\"域账号\"单独使用易产生\"非人主体执行动作\"的歧义（如\"域账号使用设备\"），应结合上下文判断是否需保留\"用户\"限定词，或采用\"以域账号身份\"等无歧义结构。"
    },
    {
      "defect_id": 482978,
      "sentence": "  - [管理系统账号凭据](manage-os-account-credential.md)",
      "reference_sentence": "无",
      "line_num": 7,
      "context": "{\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\"}",
      "用户拒绝的修改": "  - [管理系统帐户凭据](manage-os-account-credential.md)",
      "注意事项": "修复前必须优先核对上下文现有术语使用习惯，当用户明确指定统一用词时，应优先遵循用户规范而非通用规则，即使存在拼写差异。"
    },
    {
      "defect_id": 482974,
      "sentence": "- [账号管理概述](account-overview.md)",
      "reference_sentence": "无",
      "line_num": 3,
      "context": "{\"1\":\"# 账号管理<!--account-management-->\",\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\"}",
      "用户拒绝的修改": "- [帐户管理概述](account-overview.md)",
      "注意事项": "修复术语时应优先遵循用户指定的统一用词或文档现有用法，而非机械套用通用规则；在应用规则前必须检查上下文是否存在已确定的术语实例，确保全局一致性。"
    },
    {
      "defect_id": 482954,
      "sentence": "系统提供了用于管理系统账号的接口",
      "reference_sentence": "系统提供了用于管理系统帐号的接口",
      "line_num": 3,
      "context": "{\"1\":\"# 管理系统账号（仅对系统应用开放）\",\"2\":\"\",\"3\":\"系统提供了用于管理系统账号的接口。系统应用开发者在申请对应的权限后，可以创建、激活、修改和删除系统账号，实现对系统账号的生命周期管理；三方应用开发者可以查询系统账号的基本信息，以完成与系统账号相关的业务逻辑开发。\",\"4\":\"\",\"5\":\"## 基本概念\",\"6\":\"\",\"7\":\"### 账号类型\",\"8\":\"\"}",
      "用户拒绝的修改": "系统提供了用于管理系统帐号的接口",
      "注意事项": "修改前必须严格核对上下文中的术语统一性，优先遵循文档已有用词而非通用标准；涉及近义词替换时需结合上下文确认是否存在强制统一的特定词汇要求。"
    },
    {
      "defect_id": 482977,
      "sentence": "  - [使用约束管控系统账号](control-os-account-by-constraints.md)",
      "reference_sentence": "无",
      "line_num": 6,
      "context": "{\"1\":\"# 账号管理<!--account-management-->\",\"2\":\"<!--Del-->\",\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\"}",
      "用户拒绝的修改": "  - [使用约束管控系统帐户](control-os-account-by-constraints.md)",
      "注意事项": "修复术语时应优先检查文档内部统一用法，若上下文存在明确术语偏好（如\"账号\"），即使与常规规则冲突也应遵循现有一致性；当用户明确指定统一用词时，直接采用无需二次修正。"
    },
    {
      "defect_id": 482957,
      "sentence": "调用[queryAllCreatedOsAccounts](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryallcreatedosaccounts)接口查询全量账号",
      "reference_sentence": "调用[queryAllCreatedOsAccounts](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryallcreatedosaccounts)接口查询全量帐号",
      "line_num": 61,
      "context": "{\"56\":\"\",\"57\":\"账号管理界面通常需要获取所有账号信息时，以方便用户操作不同账号。\",\"58\":\"\",\"59\":\"具体开发实例如下：\",\"60\":\"\",\"61\":\"调用[queryAllCreatedOsAccounts](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryallcreatedosaccounts)接口查询全量账号。  \",\"62\":\"\",\"63\":\"```ts\",\"64\":\"accountManager.queryAllCreatedOsAccounts((err: BusinessError, accountArr: osAccount.OsAccountInfo[])=>{\",\"65\":\"  console.log('queryAllCreatedOsAccounts err:' + JSON.stringify(err));\",\"66\":\"  console.log('queryAllCreatedOsAccounts accountArr:' + JSON.stringify(accountArr));\"}",
      "用户拒绝的修改": "调用[queryAllCreatedOsAccounts](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryallcreatedosaccounts)接口查询全量帐号",
      "注意事项": "在修复术语不一致时，需优先核对上下文及文档全局用词规范（如上下文明确使用\"账号\"），避免依赖局部判断；同时建立术语映射表强制统一高频易混词（如\"账号/帐号\"），禁止自动替换未确认的同义词。"
    },
    {
      "defect_id": 482983,
      "sentence": "- 分布式账号（仅对系统应用开放）<!--distributed-account-->",
      "reference_sentence": "无",
      "line_num": 12,
      "context": "{\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\",\"16\":\"  - [管理应用账号](manage-application-account.md)\"}",
      "用户拒绝的修改": "- 分布式帐户（仅对系统应用开放）<!--distributed-account-->",
      "注意事项": "修复前必须优先检查上下文术语一致性，若文档已存在统一用词（如\"账号\"），即使与通用规则冲突也应维持现有约定；同时需结合注释标签（如<!--distributed-account-->）判断术语是否属于专有名词或技术术语，避免误改。"
    },
    {
      "defect_id": 482979,
      "sentence": "- 域账号（仅对系统应用开放）<!--domain-account-->",
      "reference_sentence": "无",
      "line_num": 8,
      "context": "{\"3\":\"- [账号管理概述](account-overview.md)\",\"4\":\"- 系统账号（仅对系统应用开放）<!--os-account-->\",\"5\":\"  - [管理系统账号](manage-os-account.md)\",\"6\":\"  - [使用约束管控系统账号](control-os-account-by-constraints.md)\",\"7\":\"  - [管理系统账号凭据](manage-os-account-credential.md)\",\"8\":\"- 域账号（仅对系统应用开放）<!--domain-account-->\",\"9\":\"  - [管理域账号](manage-domain-account.md)\",\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\"}",
      "用户拒绝的修改": "- 域帐户（仅对系统应用开放）<!--domain-account-->",
      "注意事项": "修复前必须全面检查上下文中的现有术语使用情况，优先遵循文档内部统一用词而非通用规则；当规则与上下文实际用法冲突时，以用户文档的现有一致性为准。"
    },
    {
      "defect_id": 482956,
      "sentence": "账号管理界面通常需要获取所有账号信息时，以方便用户操作不同账号",
      "reference_sentence": "账号管理界面通常需要获取所有帐号信息时，以方便用户操作不同帐号",
      "line_num": 57,
      "context": "{\"52\":\"});\",\"53\":\"```\",\"54\":\"\",\"55\":\"## 查询所有已创建的系统账号\",\"56\":\"\",\"57\":\"账号管理界面通常需要获取所有账号信息时，以方便用户操作不同账号。\",\"58\":\"\",\"59\":\"具体开发实例如下：\",\"60\":\"\",\"61\":\"调用[queryAllCreatedOsAccounts](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryallcreatedosaccounts)接口查询全量账号。  \",\"62\":\"\"}",
      "用户拒绝的修改": "账号管理界面通常需要获取所有帐号信息时，以方便用户操作不同帐号",
      "注意事项": "修改前必须核对上下文现有用词习惯，优先遵循用户指定的统一术语（如\"账号\"），避免机械替换导致二次不一致；同时检查文档全局术语表或规范说明，确保修改符合整体风格约束。"
    },
    {
      "defect_id": 482958,
      "sentence": "除了查询所有账号信息，还可以根据账号标识查询指定系统账号的详细信息",
      "reference_sentence": "除了查询所有帐号信息，还可以根据帐号标识查询指定系统帐号的详细信息",
      "line_num": 72,
      "context": "{\"67\":\"});\",\"68\":\"```\",\"69\":\"\",\"70\":\"## 查询指定系统账号信息\",\"71\":\"\",\"72\":\"除了查询所有账号信息，还可以根据账号标识查询指定系统账号的详细信息。\",\"73\":\"\",\"74\":\"具体开发实例如下：\",\"75\":\"\",\"76\":\"调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定账号的详细信息。\",\"77\":\"\"}",
      "用户拒绝的修改": "除了查询所有帐号信息，还可以根据帐号标识查询指定系统帐号的详细信息",
      "注意事项": "修复前必须全局检查文档中术语的现有使用习惯（如上下文已统一使用\"账号\"），并优先遵循用户明确指定的统一要求，避免机械替换导致二次不一致。"
    },
    {
      "defect_id": 482960,
      "sentence": "可以修改系统账号的头像、昵称，以满足用户的个性化需求",
      "reference_sentence": "可以修改系统帐号的头像、昵称，以满足用户的个性化需求",
      "line_num": 88,
      "context": "{\"83\":\"});\",\"84\":\"```\",\"85\":\"\",\"86\":\"## 修改系统账号头像和昵称\",\"87\":\"\",\"88\":\"可以修改系统账号的头像、昵称，以满足用户的个性化需求。\",\"89\":\"\",\"90\":\"具体开发实例如下：\",\"91\":\"\",\"92\":\"1. 调用[setOsAccountProfilePhoto](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountprofilephoto)接口修改系统账号头像。\",\"93\":\"\"}",
      "用户拒绝的修改": "可以修改系统帐号的头像、昵称，以满足用户的个性化需求",
      "注意事项": "修复前必须严格核对上下文术语使用一致性，优先沿用文档已有用词规范；同时建立易混淆术语对照表（如\"账号/帐号\"）辅助判断，避免主观臆断正确用词。"
    },
    {
      "defect_id": 482959,
      "sentence": "调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定账号的详细信息",
      "reference_sentence": "调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定帐号的详细信息",
      "line_num": 76,
      "context": "{\"71\":\"\",\"72\":\"除了查询所有账号信息，还可以根据账号标识查询指定系统账号的详细信息。\",\"73\":\"\",\"74\":\"具体开发实例如下：\",\"75\":\"\",\"76\":\"调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定账号的详细信息。\",\"77\":\"\",\"78\":\"```ts\",\"79\":\"let localId: number = 100;\",\"80\":\"accountManager.queryOsAccountById(localId, (err: BusinessError, accountInfo: osAccount.OsAccountInfo)=>{\",\"81\":\"  console.log('queryOsAccountById err:' + JSON.stringify(err));\"}",
      "用户拒绝的修改": "调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定帐号的详细信息",
      "注意事项": "修复术语时应优先检查上下文现有用词（如问题上下文中\"账号\"已高频出现），对易混淆词汇（账号/帐号）需建立术语库强制统一，避免脱离上下文进行机械替换。"
    },
    {
      "defect_id": 482962,
      "sentence": "调用[setOsAccountName](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountname)接口修改系统账号名称",
      "reference_sentence": "调用[setOsAccountName](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountname)接口修改系统帐号名称",
      "line_num": 106,
      "context": "{\"101\":\"   accountManager.setOsAccountProfilePhoto(localId, newPhoto, (err: BusinessError)=>{\",\"102\":\"     console.log('setOsAccountProfilePhoto err:' + JSON.stringify(err));\",\"103\":\"   });\",\"104\":\"   ```\",\"105\":\"\",\"106\":\"2. 调用[setOsAccountName](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountname)接口修改系统账号名称。\",\"107\":\"\",\"108\":\"   ```ts\",\"109\":\"   let localId: number = 100;\",\"110\":\"   let newName: string = 'Tom';\",\"111\":\"   accountManager.setOsAccountName(localId, newName, (err: BusinessError) => {\"}",
      "用户拒绝的修改": "调用[setOsAccountName](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountname)接口修改系统帐号名称",
      "注意事项": "修复术语不一致时应优先遵循用户指定的统一规范（如“账号”），而非依赖上下文中的参考案例；修改前需确认用户提供的明确术语要求，避免机械替换导致二次错误。"
    },
    {
      "defect_id": 482955,
      "sentence": "可以创建多个系统账号，以满足用户不同诉求",
      "reference_sentence": "可以创建多个系统帐号，以满足用户不同诉求",
      "line_num": 39,
      "context": "{\"34\":\"   let accountManager = osAccount.getAccountManager();\",\"35\":\"   ```\",\"36\":\"\",\"37\":\"## 创建系统账号\",\"38\":\"\",\"39\":\"系统初始化阶段，会创建默认系统账号。此外，可以创建多个系统账号，以满足用户不同诉求。\",\"40\":\"\",\"41\":\"具体开发实例如下：\",\"42\":\"\",\"43\":\"调用[createOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccount)接口，指定昵称和类型信息来创建系统账号。\",\"44\":\"\"}",
      "用户拒绝的修改": "可以创建多个系统帐号，以满足用户不同诉求",
      "注意事项": "修复时应优先遵循用户指定的统一术语（如“账号”），严格检查上下文现有用词习惯，避免机械套用参考句中的非常规用词。若参考句与用户要求冲突，需以用户明示规则为准。"
    },
    {
      "defect_id": 482961,
      "sentence": "调用[setOsAccountProfilePhoto](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountprofilephoto)接口修改系统账号头像",
      "reference_sentence": "调用[setOsAccountProfilePhoto](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountprofilephoto)接口修改系统帐号头像",
      "line_num": 92,
      "context": "{\"87\":\"\",\"88\":\"可以修改系统账号的头像、昵称，以满足用户的个性化需求。\",\"89\":\"\",\"90\":\"具体开发实例如下：\",\"91\":\"\",\"92\":\"1. 调用[setOsAccountProfilePhoto](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountprofilephoto)接口修改系统账号头像。\",\"93\":\"\",\"94\":\"   ```ts\",\"95\":\"   let localId: number = 100;\",\"96\":\"   let newPhoto: string = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAAAXNSR0IArs4c6QAAAARnQU1BAA'+\",\"97\":\"   'Cxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACwSURBVDhPvZLBDYMwDEV/ugsXRjAT0EHCOuFIBwkbdIRewi6unbiAyoGgSn1SFH85+Y'+\"}",
      "用户拒绝的修改": "调用[setOsAccountProfilePhoto](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#setosaccountprofilephoto)接口修改系统帐号头像",
      "注意事项": "修复术语不一致前必须全面检查上下文现有用词习惯，优先遵循文档已有统一标准；针对\"账号/帐号\"等常见异形词，需建立术语对照表强制统一，避免孤立处理单个词条。"
    },
    {
      "defect_id": 482985,
      "sentence": "- 应用账号<!--application-account-->",
      "reference_sentence": "无",
      "line_num": 15,
      "context": "{\"10\":\"  - [认证域账号](auth-domain-account.md)\",\"11\":\"  - [管理域账号插件](manage-domain-plugin.md)\",\"12\":\"- 分布式账号（仅对系统应用开放）<!--distributed-account-->\",\"13\":\"  - [管理分布式账号](manage-distributed-account.md)\",\"14\":\"<!--DelEnd-->\",\"15\":\"- 应用账号<!--application-account-->\",\"16\":\"  - [管理应用账号](manage-application-account.md)\"}",
      "用户拒绝的修改": "- 应用帐户<!--application-account-->",
      "注意事项": "修改术语前必须优先检查上下文现有用词习惯，当用户明确指定统一术语时应以项目内部规范为准，而非机械套用通用规则。"
    },
    {
      "defect_id": 482963,
      "sentence": "调用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口删除指定的账号。",
      "reference_sentence": "调用[activateOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#activateosaccount)接口激活指定系统账号。",
      "line_num": 145,
      "context": "{\"140\":\"\",\"141\":\"不再使用某个系统账号时，可以将该系统账号删除。\",\"142\":\"\",\"143\":\"具体开发实例如下：\",\"144\":\"\",\"145\":\"调用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口删除指定的账号。\",\"146\":\"\",\"147\":\"```ts\",\"148\":\"let localId: number = 101;\",\"149\":\"accountManager.removeOsAccount(localId, (err: BusinessError)=>{\",\"150\":\"  if (err) {\"}",
      "用户拒绝的修改": "调用[removeOsAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#removeosaccount)接口移除指定的账号。",
      "注意事项": "修复时必须严格遵循上下文已确定的术语（如\"删除\"），禁止使用近义词替换；修改前需检查相邻段落和参考句子的用词习惯，确保全文术语一致性优先于表达多样性。"
    },
    {
      "defect_id": 483001,
      "sentence": "设置指定系统账号的分布式信息。使用callback异步回调。",
      "reference_sentence": "获取指定系统账号的分布式信息。使用callback异步回调。",
      "line_num": 123,
      "context": "{\"118\":\"\",\"119\":\"### setOsAccountDistributedInfoByLocalId<sup>10+</sup>\",\"120\":\"\",\"121\":\"setOsAccountDistributedInfoByLocalId(localId: number, distributedInfo: DistributedInfo, callback: AsyncCallback&lt;void&gt;): void\",\"122\":\"\",\"123\":\"设置指定系统账号的分布式信息。使用callback异步回调。\",\"124\":\"\",\"125\":\"**系统接口：** 此接口为系统接口。\",\"126\":\"\",\"127\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"128\":\"\"}",
      "用户拒绝的修改": "设置指定系统账号的分布式信息。使用回调异步回调。",
      "注意事项": "修复术语一致性时需严格区分技术术语和普通用词，保留接口参数原文（如\"callback\"），仅调整非术语部分（如\"异步回调\"）；同时需交叉验证上下文参数命名和参考句的术语使用规范。"
    },
    {
      "defect_id": 483097,
      "sentence": "checkOsAccountTestable(): Promise&lt;boolean&gt;",
      "reference_sentence": "### checkOsAccountTestable<sup>9+</sup>",
      "line_num": 421,
      "context": "{\"416\":\"  }\",\"417\":\"  ```\",\"418\":\"\",\"419\":\"### checkOsAccountTestable<sup>9+</sup>\",\"420\":\"\",\"421\":\"checkOsAccountTestable(): Promise&lt;boolean&gt;\",\"422\":\"\",\"423\":\"检查当前系统账号是否为测试账号。使用Promise异步回调。\",\"424\":\"\",\"425\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"426\":\"\"}",
      "用户拒绝的修改": "checkOsAccountTestable(callback: AsyncCallback&lt;boolean&gt;): void",
      "注意事项": "修复函数重载时必须严格区分参数类型和数量，保留原有方法签名并补充新重载形式，避免直接覆盖或混淆不同参数结构的同名函数。"
    },
    {
      "defect_id": 483098,
      "sentence": "检查当前系统账号是否为测试账号。使用Promise异步回调。",
      "reference_sentence": "### checkOsAccountTestable<sup>9+</sup>",
      "line_num": 423,
      "context": "{\"418\":\"\",\"419\":\"### checkOsAccountTestable<sup>9+</sup>\",\"420\":\"\",\"421\":\"checkOsAccountTestable(): Promise&lt;boolean&gt;\",\"422\":\"\",\"423\":\"检查当前系统账号是否为测试账号。使用Promise异步回调。\",\"424\":\"\",\"425\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"426\":\"\",\"427\":\"**返回值：**\",\"428\":\"\"}",
      "用户拒绝的修改": "检查当前系统账号是否为测试账号。使用callback异步回调。",
      "注意事项": "修复时必须严格核对API定义中的异步处理方式（如Promise或callback参数），确保术语与函数签名及上下文中的技术实现完全一致，避免混淆不同重载版本。"
    },
    {
      "defect_id": 483079,
      "sentence": "判断指定系统账号是否具有指定约束。使用Promise异步回调。",
      "reference_sentence": "判断指定系统账号是否具有指定约束。使用callback异步回调。",
      "line_num": 329,
      "context": "{\"324\":\"\",\"325\":\"### checkOsAccountConstraintEnabled<sup>(deprecated)</sup>\",\"326\":\"\",\"327\":\"checkOsAccountConstraintEnabled(localId: number, constraint: string): Promise&lt;boolean&gt;\",\"328\":\"\",\"329\":\"判断指定系统账号是否具有指定约束。使用Promise异步回调。\",\"330\":\"\",\"331\":\"> **说明：**\",\"332\":\">\",\"333\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"334\":\"\"}",
      "用户拒绝的修改": "判断指定系统账号是否具有指定约束。使用callback异步回调。",
      "注意事项": "修复时需确保术语与函数签名严格一致，若异步方式（Promise/callback）涉及参数或返回类型差异，必须优先保持接口兼容性，避免修改原函数参数结构。"
    },
    {
      "defect_id": 482876,
      "sentence": "PIN码认证成功后，可以录入人脸/指纹，操作流程与录入PIN码类似。",
      "reference_sentence": "## 录入PIN码",
      "line_num": 143,
      "context": "{\"138\":\"   });\",\"139\":\"   ```\",\"140\":\"\",\"141\":\"## 录入生物识别凭据\",\"142\":\"\",\"143\":\"PIN码认证成功后，可以录入人脸/指纹，操作流程与录入PIN码类似。\",\"144\":\"\",\"145\":\"具体开发实例如下：\",\"146\":\"\",\"147\":\"1. 认证PIN码，获取授权令牌authToken。\",\"148\":\"\"}",
      "用户拒绝的修改": "PIN码认证成功后，可以注册人脸/指纹，操作流程与注册PIN码类似。",
      "注意事项": "修复时应优先检查上下文中的术语使用习惯，确保同类型操作动词保持全文统一，避免在未识别已有规范术语的情况下进行近义词替换。"
    },
    {
      "defect_id": 483051,
      "sentence": "判断当前系统账号是否使能指定约束。使用Promise异步回调。",
      "reference_sentence": "判断指定系统账号是否处于激活状态。使用Promise异步回调。",
      "line_num": 233,
      "context": "{\"228\":\"\",\"229\":\"### isOsAccountConstraintEnabled<sup>11+</sup>\",\"230\":\"\",\"231\":\"isOsAccountConstraintEnabled(constraint: string): Promise&lt;boolean&gt;\",\"232\":\"\",\"233\":\"判断当前系统账号是否使能指定约束。使用Promise异步回调。\",\"234\":\"\",\"235\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"236\":\"\",\"237\":\"**参数：**\",\"238\":\"\"}",
      "用户拒绝的修改": "判断当前系统账号是否激活指定约束。使用Promise异步回调。",
      "注意事项": "修复术语不一致时应优先检查上下文和参考句子的现有术语使用习惯，确保与文档整体术语体系严格一致，避免基于主观理解替换词汇。"
    },
    {
      "defect_id": 483369,
      "sentence": "该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "reference_sentence": "该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "line_num": 18009,
      "context": "{\"18004\":\"\",\"18005\":\"| 名称 | 描述 | \",\"18006\":\"| -------- | -------- |\",\"18007\":\"| env | Node-API的环境指针。| \",\"18008\":\"\",\"18009\":\"**返回：**\",\"18010\":\"\",\"18011\":\"[ARKUI_ERROR_CODE_NO_ERROR](_ark_u_i___native_module.md#arkui_errorcode) 成功。</br >\",\"18012\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](_ark_u_i___native_module.md#arkui_errorcode) 参数无效（如env为null或设置白名单失败）。</br >\",\"18013\":\"[ARKUI_ERROR_CODE_CAPI_INIT_ERROR](_ark_u_i___native_module.md#arkui_errorcode) CAPI初始化错误。</br >\",\"18014\":\"\"}",
      "用户拒绝的修改": "该函数禁止在非UI线程中调用，否则程序将触发abort并终止执行。",
      "注意事项": "保持技术术语一致性，避免重复描述同一操作的不同阶段（如\"触发abort\"和\"终止执行\"属于同一行为的不同表述），优先使用接口文档中已定义的标准化表述方式。"
    },
    {
      "defect_id": 483050,
      "sentence": "返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "reference_sentence": "返回true表示账号已激活；返回false表示账号未激活。",
      "line_num": 293,
      "context": "{\"288\":\"\",\"289\":\"| 参数名     | 类型                         | 必填 | 说明                                                               |\",\"290\":\"| ---------- | ---------------------------- | ---- | ----------------------------------------------------------------- |\",\"291\":\"| localId    | number                       | 是   | 系统账号ID。                                 |\",\"292\":\"| constraint | string                       | 是   | 指定的[约束](#系统账号约束列表)名称。                                |\",\"293\":\"| callback   | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示已使能指定的约束；返回false表示未使能指定的约束。 |\",\"294\":\"\",\"295\":\"**错误码：**\",\"296\":\"\",\"297\":\"| 错误码ID | 错误信息             |\",\"298\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回true表示指定的约束已激活；返回false表示指定的约束未激活。",
      "注意事项": "修复时应严格保持技术术语的一致性，优先沿用原文用词而非替换近义词，并需特别检查参数说明、错误码等上下文是否存在已定义的术语规范。"
    },
    {
      "defect_id": 483078,
      "sentence": "checkOsAccountConstraintEnabled(localId: number, constraint: string): Promise&lt;boolean&gt;",
      "reference_sentence": "checkOsAccountConstraintEnabled(localId: number, constraint: string, callback: AsyncCallback&lt;boolean&gt;): void",
      "line_num": 327,
      "context": "{\"322\":\"  }\",\"323\":\"  ```\",\"324\":\"\",\"325\":\"### checkOsAccountConstraintEnabled<sup>(deprecated)</sup>\",\"326\":\"\",\"327\":\"checkOsAccountConstraintEnabled(localId: number, constraint: string): Promise&lt;boolean&gt;\",\"328\":\"\",\"329\":\"判断指定系统账号是否具有指定约束。使用Promise异步回调。\",\"330\":\"\",\"331\":\"> **说明：**\",\"332\":\">\"}",
      "用户拒绝的修改": "checkOsAccountConstraintEnabled(localId: number, constraint: string, callback: AsyncCallback&lt;boolean&gt;): void",
      "注意事项": "修复函数重载时需保留原有方法签名并新增重载版本，避免直接覆盖参数列表；严格区分Promise和Callback异步模式，确保两种方法签名独立存在。"
    },
    {
      "defect_id": 483002,
      "sentence": "设置指定系统账号的分布式信息。使用Promise异步回调。",
      "reference_sentence": "获取指定系统账号的分布式信息。使用Promise异步回调。",
      "line_num": 176,
      "context": "{\"171\":\"\",\"172\":\"### setOsAccountDistributedInfoByLocalId<sup>10+</sup>\",\"173\":\"\",\"174\":\"setOsAccountDistributedInfoByLocalId(localId: number, distributedInfo: DistributedInfo): Promise&lt;void&gt;\",\"175\":\"\",\"176\":\"设置指定系统账号的分布式信息。使用Promise异步回调。\",\"177\":\"\",\"178\":\"**系统接口：** 此接口为系统接口。\",\"179\":\"\",\"180\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"181\":\"\"}",
      "用户拒绝的修改": "设置指定系统账号的分布式信息。使用Promise回调。",
      "注意事项": "修复时必须优先保留技术文档中的固定术语和API关键字（如\"异步\"），严格对照上下文参考句子的完整表述方式，避免因过度简化导致关键信息丢失。"
    },
    {
      "defect_id": 482875,
      "sentence": "前述操作完成后，可以进行PIN码录入。开发者可以使用[addCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#addcredential8)接口完成此操作。",
      "reference_sentence": "## 注册PIN码输入器输入器用于传递PIN码数据，录入、认证PIN码前需要先注册输入器。",
      "line_num": 89,
      "context": "{\"84\":\"   let challenge: Uint8Array = await userIDM.openSession();\",\"85\":\"   ```\",\"86\":\"\",\"87\":\"## 录入PIN码\",\"88\":\"\",\"89\":\"前述操作完成后，可以进行PIN码录入。开发者可以使用[addCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#addcredential8)接口完成此操作。\",\"90\":\"\",\"91\":\"具体开发实例如下：\",\"92\":\"\",\"93\":\"1. 定义PIN码凭据信息。\",\"94\":\"\"}",
      "用户拒绝的修改": "前述操作完成后，可以进行PIN码注册。开发者可以使用[addCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#addcredential8)接口完成此操作。",
      "注意事项": "修复时应优先检查上下文术语一致性，避免混淆技术场景中的近义词（如“注册”用于系统级操作，“录入”侧重用户输入动作），确保替换词与领域内已有表述严格匹配。"
    },
    {
      "defect_id": 482871,
      "sentence": "1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。",
      "reference_sentence": "权限",
      "line_num": 35,
      "context": "{\"30\":\"| FINGERPRINT_OPTICAL<sup>10+</sup>    | 30001 | 表示光学指纹。   |\",\"31\":\"| FINGERPRINT_ULTRASONIC<sup>10+</sup>    | 30002 | 表示超声波指纹。   |\",\"32\":\"\",\"33\":\"## 开发准备\",\"34\":\"\",\"35\":\"1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。\",\"36\":\"   - ohos.permission.MANAGE_USER_IDM\",\"37\":\"   - ohos.permission.ACCESS_PIN_AUTH\",\"38\":\"\",\"39\":\"2. 导入系统账号模块。\",\"40\":\"\"}",
      "用户拒绝的修改": "1. 申请权限，申请流程请参考：[申请权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。",
      "注意事项": "修复时应优先保持上下文术语一致性，避免过度简化关键技术名词，需结合上下文判断\"应用权限\"是否特指系统定义的权限类型而非冗余表述。"
    },
    {
      "defect_id": 483052,
      "sentence": "返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "reference_sentence": "返回true表示账号已激活；返回false表示账号未激活。",
      "line_num": 247,
      "context": "{\"242\":\"\",\"243\":\"**返回值：**\",\"244\":\"\",\"245\":\"| 类型                   | 说明                                                                  |\",\"246\":\"| --------------------- | --------------------------------------------------------------------- |\",\"247\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。 |\",\"248\":\"\",\"249\":\"**错误码：**\",\"250\":\"\",\"251\":\"| 错误码ID | 错误信息             |\",\"252\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回true表示指定的约束已激活；返回false表示指定的约束未激活。",
      "注意事项": "修复时应优先保持与上下文术语的一致性，避免主观替换专业词汇，若原文使用\"使能\"则需保持全文档统一，仅在术语确实错误时才进行替换并明确标注修改依据。"
    },
    {
      "defect_id": 482869,
      "sentence": "凭据可用于认证用户的身份，本文档将介绍如何录入、认证、更新、查询和删除指定系统账号的凭据。",
      "reference_sentence": "登录",
      "line_num": 3,
      "context": "{\"1\":\"# 管理系统账号凭据（仅对系统应用开放）\",\"2\":\"\",\"3\":\"凭据可用于认证用户的身份，本文档将介绍如何录入、认证、更新、查询和删除指定系统账号的凭据。\",\"4\":\"\",\"5\":\"## 凭据类型\",\"6\":\"\",\"7\":\"系统账号支持管理以下凭据类型：\",\"8\":\"\"}",
      "用户拒绝的修改": "凭据可用于登录用户的身份，本文档将介绍如何录入、认证、更新、查询和删除指定系统账号的凭据。",
      "注意事项": "保持技术术语一致性时需优先沿用原文核心概念（如\"认证\"），避免机械替换近义词；修改前应结合上下文确认目标词汇是否属于同一操作层级（如身份认证 vs 登录行为）。"
    },
    {
      "defect_id": 483370,
      "sentence": "该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "reference_sentence": "该函数禁止在非UI线程中调用，否则程序将触发abort并终止执行。",
      "line_num": 18029,
      "context": "{\"18024\":\"\",\"18025\":\"**起始版本：** 20\",\"18026\":\"\",\"18027\":\"**参数:**\",\"18028\":\"\",\"18029\":\"| 名称 | 描述 | \",\"18030\":\"| -------- | -------- |\",\"18031\":\"| env | Node-API的环境指针。| \",\"18032\":\"\",\"18033\":\"\",\"18034\":\"### OH_ArkUI_RegisterLayoutCallbackOnNodeHandle()\"}",
      "用户拒绝的修改": "该函数禁止在非UI线程中调用，否则程序将触发abort并终止执行。",
      "注意事项": "修复时应严格核对文档中已定义的接口术语和错误处理机制，避免引入未提及的冗余操作描述（如\"终止执行\"）；优先采用上下文已有的标准化表述方式，确保技术动作描述与接口命名一一对应。"
    },
    {
      "defect_id": 483105,
      "sentence": "检查指定系统账号是否已验证。使用callback异步回调。",
      "reference_sentence": "检查当前系统账号是否已认证解锁。使用callback异步回调。",
      "line_num": 577,
      "context": "{\"572\":\"\",\"573\":\"### checkOsAccountVerified<sup>(deprecated)</sup>\",\"574\":\"\",\"575\":\"checkOsAccountVerified(localId: number, callback: AsyncCallback&lt;boolean&gt;): void\",\"576\":\"\",\"577\":\"检查指定系统账号是否已验证。使用callback异步回调。\",\"578\":\"\",\"579\":\"> **说明：**\",\"580\":\">\",\"581\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"582\":\"\"}",
      "用户拒绝的修改": "检查指定系统账号是否已认证解锁。使用callback异步回调。",
      "注意事项": "严格遵循上下文中的现有术语，避免主观替换近义词；优先参考同一文档中的参考句子和已有表述，确保术语一致性。"
    },
    {
      "defect_id": 483080,
      "sentence": "Promise&lt;boolean&gt; | Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "reference_sentence": "void | 无返回值。回调函数返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "line_num": 350,
      "context": "{\"345\":\"\",\"346\":\"**返回值：**\",\"347\":\"\",\"348\":\"| 类型                   | 说明                                                                  |\",\"349\":\"| --------------------- | --------------------------------------------------------------------- |\",\"350\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。 |\",\"351\":\"\",\"352\":\"**错误码：**\",\"353\":\"\",\"354\":\"| 错误码ID | 错误信息             |\",\"355\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "void | 无返回值。回调函数返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "注意事项": "在修复返回值描述前必须确认函数是否存在重载版本，严格区分不同参数列表对应的返回类型，避免将不同函数签名的返回值说明混为一谈。"
    },
    {
      "defect_id": 483259,
      "sentence": "通知指定的上下文环境已销毁。该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "reference_sentence": "初始化指定上下文环境的ArkUI相关接口。该函数禁止在非UI线程中调用，否则程序将主动abort。每个上下文环境都会占用一定的内存，当内存消耗超过虚拟机的上限时，将导致内存溢出。有关ArkTS内存管理的详细信息，请参阅[GC垃圾回收](../../arkts-utils/gc-introduction.md)。",
      "line_num": 47,
      "context": "{\"42\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_GetRouterPageState](_ark_u_i___native_module.md#oh_arkui_getrouterpagestate) ([ArkUI_NodeHandle](_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_RouterPageState](_ark_u_i___native_module.md#arkui_routerpagestate) \\\\*state) | 获取当前节点所在页面的Page组件的状态。  | \",\"43\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_GetRouterPageId](_ark_u_i___native_module.md#oh_arkui_getrouterpageid) ([ArkUI_NodeHandle](_ark_u_i___native_module.md#arkui_nodehandle) node, char \\\\*buffer, int32_t bufferSize, int32_t \\\\*writeLength) | 获取当前节点所在页面的Page组件的ID。  | \",\"44\":\"| int32_t [OH_ArkUI_PostFrameCallback](_ark_u_i___native_module.md#oh_arkui_postframecallback)([ArkUI_ContextHandle](_ark_u_i___native_module.md#arkui_contexthandle-12) uiContext, void\\\\* userData, void (\\\\*callback)(uint64_t nanoTimestamp, uint32_t frameCount, void\\\\* userData))| 注册一个回调函数，以便在下一帧渲染时执行。不允许在非UI线程调用，检查到非UI线程调用程序会主动abort。</br >**起始版本：** 18 |\",\"45\":\"| int32_t [OH_ArkUI_PostIdleCallback](_ark_u_i___native_module.md#oh_arkui_postidlecallback)([ArkUI_ContextHandle](_ark_u_i___native_module.md#arkui_contexthandle-12) uiContext, void\\\\* userData, void (\\\\*callback)(uint64_t nanoTimeLeft, uint32_t frameCount, void\\\\* userData))| 注册一个回调函数，以便在下一帧渲染完成时执行。如果当前没有下一帧，将自动请求下一帧。</br >**起始版本：** 20 |\",\"46\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_InitModuleForArkTSEnv](_ark_u_i___native_module.md#oh_arkui_initmoduleforarktsenv)(napi_env env) | 初始化指定上下文环境的ArkUI相关接口。该函数禁止在非UI线程中调用，否则程序将主动abort。每个上下文环境都会占用一定的内存，当内存消耗超过虚拟机的上限时，将导致内存溢出。有关ArkTS内存管理的详细信息，请参阅[GC垃圾回收](../../arkts-utils/gc-introduction.md)。</br >**起始版本：** 20 |\",\"47\":\"| void [OH_ArkUI_NotifyArkTSEnvDestroy](_ark_u_i___native_module.md#oh_arkui_notifyarktsenvdestroy)(napi_env env) | 通知指定的上下文环境已销毁。该函数禁止在非UI线程中调用，否则程序将主动abort。</br >**起始版本：** 20 |\"}",
      "用户拒绝的修改": "通知上下文环境已销毁。该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "注意事项": "在保持术语一致性的同时需优先保留技术文档中具有明确指代意义的修饰词（如\"指定\"），修改前应交叉验证上下文及参考句中的同类表述，避免因过度简化导致信息缺失。"
    },
    {
      "defect_id": 482870,
      "sentence": "调用[openSession](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#opensession8)接口打开凭据管理新会话。",
      "reference_sentence": "打开",
      "line_num": 81,
      "context": "{\"76\":\"\",\"77\":\"在进行凭据管理前，请先打开一个新的会话。开发者可以使用[openSession](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#opensession8)接口完成此操作。\",\"78\":\"\",\"79\":\"具体开发实例如下：\",\"80\":\"\",\"81\":\"调用[openSession](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#opensession8)接口打开凭据管理新会话。\",\"82\":\"\",\"83\":\"   ```ts\",\"84\":\"   let challenge: Uint8Array = await userIDM.openSession();\",\"85\":\"   ```\",\"86\":\"\"}",
      "用户拒绝的修改": "调用[openSession](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#opensession8)接口开启凭据管理新会话。",
      "注意事项": "修复时应优先检查上下文中的动词使用习惯（如\"打开\"在前后文中已形成固定搭配），避免同义词替换破坏术语一致性；技术文档中需严格保持API描述动词与接口命名及上下文用词的精准对应。"
    },
    {
      "defect_id": 482885,
      "sentence": "凭据管理界面需要向用户展示已录入的凭据信息；锁屏界面需要展示可认证的凭据类型。开发者可以使用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口查询已录入的凭据信息，实现前述业务场景功能。",
      "reference_sentence": "无",
      "line_num": 248,
      "context": "{\"243\":\"   });\",\"244\":\"   ```\",\"245\":\"\",\"246\":\"## 查询凭据信息\",\"247\":\"\",\"248\":\"凭据管理界面需要向用户展示已录入的凭据信息；锁屏界面需要展示可认证的凭据类型。开发者可以使用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口查询已录入的凭据信息，实现前述业务场景功能。\",\"249\":\"\",\"250\":\"具体开发实例如下：\",\"251\":\"\",\"252\":\"1. 查询所有已录入的凭据信息。\",\"253\":\"\"}",
      "用户拒绝的修改": "凭据管理页面需要向用户展示已录入的凭据信息；锁屏页面需要展示可认证的凭据类型。开发者可以使用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口查询已录入的凭据信息，实现前述业务场景功能。",
      "注意事项": "修复时需严格检查上下文中的术语使用一致性，优先沿用原文已有表述（如“界面”），避免擅自替换为同义词（如“页面”）；技术文档中涉及UI组件命名时，应通过上下文验证术语规范。"
    },
    {
      "defect_id": 483099,
      "sentence": "checkOsAccountVerified(callback: AsyncCallback&lt;boolean&gt;): void",
      "reference_sentence": "### checkOsAccountVerified<sup>(deprecated)</sup>",
      "line_num": 493,
      "context": "{\"488\":\"  }\",\"489\":\"  ```\",\"490\":\"\",\"491\":\"### checkOsAccountVerified<sup>(deprecated)</sup>\",\"492\":\"\",\"493\":\"checkOsAccountVerified(callback: AsyncCallback&lt;boolean&gt;): void\",\"494\":\"\",\"495\":\"检查当前系统账号是否已认证解锁。使用callback异步回调。\",\"496\":\"\",\"497\":\"> **说明：**\",\"498\":\">\"}",
      "用户拒绝的修改": "checkOsAccountVerified(): Promise&lt;boolean&gt;",
      "注意事项": "在修复函数重载时，必须同时检查所有重载签名的一致性，优先保留参数差异并确保返回类型与异步模式（Callback/Promise）匹配，避免因遗漏重载导致方法签名冲突。"
    },
    {
      "defect_id": 483107,
      "sentence": "系统账号ID。不填则检查当前系统账号是否已验证。",
      "reference_sentence": "系统账号ID。                              ",
      "line_num": 641,
      "context": "{\"636\":\"\",\"637\":\"**参数：**\",\"638\":\"\",\"639\":\"| 参数名  | 类型   | 必填 | 说明                                                              |\",\"640\":\"| ------- | ------ | ---- | --------------------------------------------------------------- |\",\"641\":\"| localId | number | 是   | 系统账号ID。不填则检查当前系统账号是否已验证。 |\",\"642\":\"\",\"643\":\"**返回值：**\",\"644\":\"\",\"645\":\"| 类型                   | 说明                                                               |\",\"646\":\"| ---------------------- | ----------------------------------------------------------------- |\"}",
      "用户拒绝的修改": "系统账号ID。不填则检查当前系统账号是否已认证解锁。",
      "注意事项": "严格保持原文术语一致性，修改前需核对上下文确认核心概念的表达方式，避免主观替换已有明确定义的专有词汇（如\"验证\"改为\"认证解锁\"）。"
    },
    {
      "defect_id": 483139,
      "sentence": "该函数禁止在非UI线程中调用，否则程序将主动abort。",
      "reference_sentence": "不允许在非UI线程调用，检查到非UI线程调用程序会主动abort。",
      "line_num": 46,
      "context": "{\"41\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_GetRouterPagePath](_ark_u_i___native_module.md#oh_arkui_getrouterpagepath) ([ArkUI_NodeHandle](_ark_u_i___native_module.md#arkui_nodehandle) node, char \\\\*buffer, int32_t bufferSize, int32_t \\\\*writeLength) | 获取当前节点所在页面的Page组件的路径。  | \",\"42\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_GetRouterPageState](_ark_u_i___native_module.md#oh_arkui_getrouterpagestate) ([ArkUI_NodeHandle](_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_RouterPageState](_ark_u_i___native_module.md#arkui_routerpagestate) \\\\*state) | 获取当前节点所在页面的Page组件的状态。  | \",\"43\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_GetRouterPageId](_ark_u_i___native_module.md#oh_arkui_getrouterpageid) ([ArkUI_NodeHandle](_ark_u_i___native_module.md#arkui_nodehandle) node, char \\\\*buffer, int32_t bufferSize, int32_t \\\\*writeLength) | 获取当前节点所在页面的Page组件的ID。  | \",\"44\":\"| int32_t [OH_ArkUI_PostFrameCallback](_ark_u_i___native_module.md#oh_arkui_postframecallback)([ArkUI_ContextHandle](_ark_u_i___native_module.md#arkui_contexthandle-12) uiContext, void\\\\* userData, void (\\\\*callback)(uint64_t nanoTimestamp, uint32_t frameCount, void\\\\* userData))| 注册一个回调函数，以便在下一帧渲染时执行。不允许在非UI线程调用，检查到非UI线程调用程序会主动abort。</br >**起始版本：** 18 |\",\"45\":\"| int32_t [OH_ArkUI_PostIdleCallback](_ark_u_i___native_module.md#oh_arkui_postidlecallback)([ArkUI_ContextHandle](_ark_u_i___native_module.md#arkui_contexthandle-12) uiContext, void\\\\* userData, void (\\\\*callback)(uint64_t nanoTimeLeft, uint32_t frameCount, void\\\\* userData))| 注册一个回调函数，以便在下一帧渲染完成时执行。如果当前没有下一帧，将自动请求下一帧。</br >**起始版本：** 20 |\",\"46\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_InitModuleForArkTSEnv](_ark_u_i___native_module.md#oh_arkui_initmoduleforarktsenv)(napi_env env) | 初始化指定上下文环境的ArkUI相关接口。该函数禁止在非UI线程中调用，否则程序将主动abort。每个上下文环境都会占用一定的内存，当内存消耗超过虚拟机的上限时，将导致内存溢出。有关ArkTS内存管理的详细信息，请参阅[GC垃圾回收](../../arkts-utils/gc-introduction.md)。</br >**起始版本：** 20 |\",\"47\":\"| void [OH_ArkUI_NotifyArkTSEnvDestroy](_ark_u_i___native_module.md#oh_arkui_notifyarktsenvdestroy)(napi_env env) | 通知指定的上下文环境已销毁。该函数禁止在非UI线程中调用，否则程序将主动abort。</br >**起始版本：** 20 |\"}",
      "用户拒绝的修改": "该函数不允许在非UI线程中调用，检查到非UI线程调用程序会主动abort。",
      "注意事项": "修复时应全面检查文档上下文中的统一用词规范，优先沿用问题句子所在段落已采用的固定表述（如\"禁止/否则\"或\"不允许/检查到\"），避免跨段落混用不同术语体系导致二次返工。"
    },
    {
      "defect_id": 483132,
      "sentence": "获取当前进程所属的系统账号ID，使用callback异步回调。",
      "reference_sentence": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "line_num": 761,
      "context": "{\"756\":\"\",\"757\":\"### getOsAccountLocalId<sup>9+</sup>\",\"758\":\"\",\"759\":\"getOsAccountLocalId(callback: AsyncCallback&lt;number&gt;): void\",\"760\":\"\",\"761\":\"获取当前进程所属的系统账号ID，使用callback异步回调。\",\"762\":\"\",\"763\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"764\":\"\",\"765\":\"**参数：**\",\"766\":\"\"}",
      "用户拒绝的修改": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "注意事项": "修复时必须先确认是否存在函数重载场景，若存在需保持各重载版本术语独立一致性（如callback/Promise），同一函数的不同重载示例应严格匹配其参数类型声明，禁止跨重载版本统一术语。"
    },
    {
      "defect_id": 482883,
      "sentence": "录入完生物识别凭据后，用户可以进行生物识别认证。类似PIN码认证，开发者可以使用[auth](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#auth8)接口完成此操作。",
      "reference_sentence": "录入完PIN码，用户可以进行PIN码认证。开发者可以使用[auth](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#auth8)接口完成此操作。",
      "line_num": 193,
      "context": "{\"188\":\"   });\",\"189\":\"   ```\",\"190\":\"\",\"191\":\"## 认证生物识别凭据\",\"192\":\"\",\"193\":\"录入完生物识别凭据后，用户可以进行生物识别认证。类似PIN码认证，开发者可以使用[auth](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#auth8)接口完成此操作。\",\"194\":\"\",\"195\":\"具体开发实例如下：\",\"196\":\"\",\"197\":\"1. 定义认证参数（以人脸认证为例），包括挑战值、认证类型、认证可性等级。\",\"198\":\"\"}",
      "用户拒绝的修改": "录入完生物识别凭据后，用户可以进行生物识别认证。类似于PIN码认证，开发者可以使用[auth](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#auth8)接口完成此操作。",
      "注意事项": "严格保持核心术语在上下文中的一致性，确保\"录入\"和\"认证\"等关键动作的表述与文档既定规则完全统一，修改时需同步检查所有关联术语的表述（如PIN码相关操作需与生物识别保持相同动词搭配）。"
    },
    {
      "defect_id": 483135,
      "sentence": "getOsAccountLocalIdForUid(uid: number, callback: AsyncCallback&lt;number&gt;): void",
      "reference_sentence": "getOsAccountLocalId(): Promise&lt;number&gt;",
      "line_num": 834,
      "context": "{\"829\":\"  }\",\"830\":\"  ```\",\"831\":\"\",\"832\":\"### getOsAccountLocalIdForUid<sup>9+</sup>\",\"833\":\"\",\"834\":\"getOsAccountLocalIdForUid(uid: number, callback: AsyncCallback&lt;number&gt;): void\",\"835\":\"\",\"836\":\"根据uid查询对应的系统账号ID，使用callback异步回调。\",\"837\":\"\",\"838\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"839\":\"\"}",
      "用户拒绝的修改": "getOsAccountLocalIdForUid(uid: number): Promise&lt;number&gt;",
      "注意事项": "修复时应优先检查是否存在函数重载声明，保留合法的多参数回调形式并补充独立的Promise返回方法，确保API设计模式与上下文中的重载结构保持一致，避免直接修改原有参数列表导致接口契约破坏。"
    },
    {
      "defect_id": 483106,
      "sentence": "检查指定系统账号是否已验证。使用Promise异步回调。",
      "reference_sentence": "检查当前系统账号是否已认证解锁。使用Promise异步回调。",
      "line_num": 627,
      "context": "{\"622\":\"\",\"623\":\"### checkOsAccountVerified<sup>(deprecated)</sup>\",\"624\":\"\",\"625\":\"checkOsAccountVerified(localId: number): Promise&lt;boolean&gt;\",\"626\":\"\",\"627\":\"检查指定系统账号是否已验证。使用Promise异步回调。\",\"628\":\"\",\"629\":\"> **说明：**\",\"630\":\">\",\"631\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"632\":\"\"}",
      "用户拒绝的修改": "检查指定系统账号是否已认证解锁。使用Promise异步回调。",
      "注意事项": "修复时应严格对照上下文和参考句子中的术语（如“认证解锁”），避免引入近义词替换导致不一致；优先沿用文档已有表达而非主观调整，确保同一概念在全文中术语统一。"
    },
    {
      "defect_id": 483136,
      "sentence": "根据uid查询对应的系统账号ID，使用callback异步回调。",
      "reference_sentence": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "line_num": 836,
      "context": "{\"831\":\"\",\"832\":\"### getOsAccountLocalIdForUid<sup>9+</sup>\",\"833\":\"\",\"834\":\"getOsAccountLocalIdForUid(uid: number, callback: AsyncCallback&lt;number&gt;): void\",\"835\":\"\",\"836\":\"根据uid查询对应的系统账号ID，使用callback异步回调。\",\"837\":\"\",\"838\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"839\":\"\",\"840\":\"**参数：**\",\"841\":\"\"}",
      "用户拒绝的修改": "根据uid查询对应的系统账号ID，使用Promise异步回调。",
      "注意事项": "在修复语言表达一致性时，需优先确认上下文是否存在函数重载或参数差异，确保术语修改与当前函数定义（如参数类型callback/Promise）严格对应，避免跨重载方法的用词混淆。"
    },
    {
      "defect_id": 483175,
      "sentence": "查询当前进程所属的系统账号的信息。使用callback异步回调。",
      "reference_sentence": "获取指定系统账号的全部约束。使用callback异步回调。",
      "line_num": 1236,
      "context": "{\"1231\":\"\",\"1232\":\"### getCurrentOsAccount<sup>(deprecated)</sup>\",\"1233\":\"\",\"1234\":\"getCurrentOsAccount(callback: AsyncCallback&lt;OsAccountInfo&gt;): void\",\"1235\":\"\",\"1236\":\"查询当前进程所属的系统账号的信息。使用callback异步回调。\",\"1237\":\"\",\"1238\":\"> **说明：**\",\"1239\":\">\",\"1240\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"1241\":\"\"}",
      "用户拒绝的修改": "获取当前进程所属的系统账号的信息。使用callback异步回调。",
      "注意事项": "修复时应优先检查接口名称中的动词（如\"get\"）对应的中文术语规范，确保描述动词与接口命名严格对应；若项目存在术语映射表，需强制遵循术语表而非机械统一用词。"
    },
    {
      "defect_id": 483189,
      "sentence": "获取分布式虚拟设备ID。使用callback异步回调。",
      "reference_sentence": "查询当前进程所属的系统账号的信息。使用Promise异步回调。",
      "line_num": 1400,
      "context": "{\"1395\":\"\",\"1396\":\"### queryDistributedVirtualDeviceId<sup>9+</sup>\",\"1397\":\"\",\"1398\":\"queryDistributedVirtualDeviceId(callback: AsyncCallback&lt;string&gt;): void\",\"1399\":\"\",\"1400\":\"获取分布式虚拟设备ID。使用callback异步回调。\",\"1401\":\"\",\"1402\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或 ohos.permission.DISTRIBUTED_DATASYNC\",\"1403\":\"\",\"1404\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1405\":\"\"}",
      "用户拒绝的修改": "获取分布式虚拟设备ID。使用Promise异步回调。",
      "注意事项": "修复术语一致性时必须优先验证接口定义和上下文中的实际用法，确保术语修改与API参数类型（如AsyncCallback/Promise）及已有参考示例严格匹配，避免脱离技术实现强行统一。"
    },
    {
      "defect_id": 483133,
      "sentence": "getOsAccountLocalId(callback: AsyncCallback&lt;number&gt;): void",
      "reference_sentence": "getOsAccountLocalId(): Promise&lt;number&gt;",
      "line_num": 798,
      "context": "{\"793\":\"  }\",\"794\":\"  ```\",\"795\":\"\",\"796\":\"### getOsAccountLocalId<sup>9+</sup>\",\"797\":\"\",\"798\":\"getOsAccountLocalId(): Promise&lt;number&gt;\",\"799\":\"\",\"800\":\"获取当前进程所属的系统账号ID，使用Promise异步回调。\",\"801\":\"\",\"802\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"803\":\"\"}",
      "用户拒绝的修改": "getOsAccountLocalId(): Promise&lt;number&gt;",
      "注意事项": "修复时必须识别并保留合法的函数重载形式，确保不同调用方式（如callback和Promise）在文档中共存；修改前需完整分析上下文是否存在多个有效方法签名，避免因过度统一而破坏API设计语义。"
    },
    {
      "defect_id": 483131,
      "sentence": "getOsAccountLocalId(callback: AsyncCallback&lt;number&gt;): void",
      "reference_sentence": "getOsAccountLocalId(): Promise&lt;number&gt;",
      "line_num": 759,
      "context": "{\"754\":\"  }\",\"755\":\"  ```\",\"756\":\"\",\"757\":\"### getOsAccountLocalId<sup>9+</sup>\",\"758\":\"\",\"759\":\"getOsAccountLocalId(callback: AsyncCallback&lt;number&gt;): void\",\"760\":\"\",\"761\":\"获取当前进程所属的系统账号ID，使用callback异步回调。\",\"762\":\"\",\"763\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"764\":\"\"}",
      "用户拒绝的修改": "getOsAccountLocalId(): Promise&lt;number&gt;",
      "注意事项": "在修复语言表达一致性时，需优先识别函数重载（参数差异），禁止直接覆盖原方法；若存在异步调用兼容场景（如同时支持callback和Promise），应保留两种独立方法声明而非强行统一。"
    },
    {
      "defect_id": 483158,
      "sentence": "Promise对象，返回域账号关联的系统账号ID。",
      "reference_sentence": "回调函数。如果查询成功，err为null，data为域账号关联的系统账号ID；否则为错误对象。",
      "line_num": 1023,
      "context": "{\"1018\":\"\",\"1019\":\"**返回值：**\",\"1020\":\"\",\"1021\":\"| 类型                  | 说明                                    |\",\"1022\":\"| :-------------------- | :------------------------------------- |\",\"1023\":\"| Promise&lt;number&gt; | Promise对象，返回域账号关联的系统账号ID。 |\",\"1024\":\"\",\"1025\":\"**错误码：**\",\"1026\":\"\",\"1027\":\"| 错误码ID | 错误信息       |\",\"1028\":\"| -------- | ------------- |\"}",
      "用户拒绝的修改": "Promise对象，返回指定域账号关联的系统账号ID。",
      "注意事项": "严格保持上下文术语一致性，避免添加未明确提及的修饰词（如\"指定\"）；需精准识别跨段落表述差异（如\"域账号关联的系统账号ID\"与\"系统账号ID\"），确保参数命名在文档全局统一。"
    },
    {
      "defect_id": 483134,
      "sentence": "获取当前进程所属的系统账号ID，使用callback异步回调。",
      "reference_sentence": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "line_num": 800,
      "context": "{\"795\":\"\",\"796\":\"### getOsAccountLocalId<sup>9+</sup>\",\"797\":\"\",\"798\":\"getOsAccountLocalId(): Promise&lt;number&gt;\",\"799\":\"\",\"800\":\"获取当前进程所属的系统账号ID，使用Promise异步回调。\",\"801\":\"\",\"802\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"803\":\"\",\"804\":\"**返回值：**\",\"805\":\"\"}",
      "用户拒绝的修改": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "注意事项": "修复前必须确认API是否存在函数重载设计，优先保持与官方接口定义一致；修改术语时应同时检查所有重载版本的描述，避免因统一用词破坏技术准确性。"
    },
    {
      "defect_id": 483173,
      "sentence": "查询当前处于激活状态的系统账号的ID列表。使用callback异步回调。",
      "reference_sentence": "获取指定系统账号的全部约束。使用callback异步回调。",
      "line_num": 1158,
      "context": "{\"1153\":\"\",\"1154\":\"### getActivatedOsAccountLocalIds<sup>9+</sup>\",\"1155\":\"\",\"1156\":\"getActivatedOsAccountLocalIds(callback: AsyncCallback&lt;Array&lt;number&gt;&gt;): void\",\"1157\":\"\",\"1158\":\"查询当前处于激活状态的系统账号的ID列表。使用callback异步回调。\",\"1159\":\"\",\"1160\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1161\":\"\",\"1162\":\"**参数：**\",\"1163\":\"\"}",
      "用户拒绝的修改": "获取当前处于激活状态的系统账号的ID列表。使用callback异步回调。",
      "注意事项": "修复时应优先保持与接口方法名（如getXXX）的中文动词对应关系（如\"查询\"对应get），并检查上下文已有术语（如参考句中的\"获取\"）确保全局用词统一。"
    },
    {
      "defect_id": 483195,
      "sentence": "通过SN码查询与其关联的系统账号的账号ID。使用Promise异步回调。",
      "reference_sentence": "通过SN码查询与其关联的系统账号的账号ID。使用异步回调。",
      "line_num": 1524,
      "context": "{\"1519\":\"\",\"1520\":\"### getOsAccountLocalIdForSerialNumber<sup>9+</sup>\",\"1521\":\"\",\"1522\":\"getOsAccountLocalIdForSerialNumber(serialNumber: number): Promise&lt;number&gt;\",\"1523\":\"\",\"1524\":\"通过SN码查询与其关联的系统账号的账号ID。使用Promise异步回调。\",\"1525\":\"\",\"1526\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1527\":\"\",\"1528\":\"**参数：**\",\"1529\":\"\"}",
      "用户拒绝的修改": "通过SN码查询与其关联的系统账号的账号ID。使用异步回调。",
      "注意事项": "在修复语言表达一致性时，必须严格遵循接口文档中明确使用的技术术语（如Promise），避免将具体实现方式泛化为通用表述；修改前需核对上下文中的参数类型、方法定义等关键信息，确保技术描述与接口规范完全一致。"
    },
    {
      "defect_id": 483229,
      "sentence": "判断是否支持多系统账号。使用callback异步回调。",
      "reference_sentence": "判断是否支持多系统账号。使用Promise异步回调。",
      "line_num": 1659,
      "context": "{\"1654\":\"\",\"1655\":\"### isMultiOsAccountEnable<sup>(deprecated)</sup>\",\"1656\":\"\",\"1657\":\"isMultiOsAccountEnable(callback: AsyncCallback&lt;boolean&gt;): void\",\"1658\":\"\",\"1659\":\"判断是否支持多系统账号。使用callback异步回调。\",\"1660\":\"\",\"1661\":\"> **说明：**\",\"1662\":\">\",\"1663\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。\",\"1664\":\"\"}",
      "用户拒绝的修改": "判断是否支持多系统账号。使用Promise异步回调。",
      "注意事项": "修复术语一致性时需优先核对上下文中的接口定义或技术参数，确保技术实现方式（如callback/Promise）与代码规范严格一致，避免脱离技术上下文强行统一术语。"
    },
    {
      "defect_id": 483145,
      "sentence": "查询值为12345678的uid所属的系统账号的账号ID",
      "reference_sentence": "查询值为12345678的uid所属的系统账号ID",
      "line_num": 855,
      "context": "{\"850\":\"| -------- | --------------- |\",\"851\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types.|\",\"852\":\"| 12300001 | The system service works abnormally. |\",\"853\":\"| 12300002 | Invalid uid.    |\",\"854\":\"\",\"855\":\"**示例：** 查询值为12345678的uid所属的系统账号的账号ID\",\"856\":\"\",\"857\":\"  ```ts\",\"858\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"859\":\"  let accountManager: osAccount.AccountManager = osAccount.getAccountManager();\",\"860\":\"  let uid: number = 12345678;\"}",
      "用户拒绝的修改": "查询值为12345678的uid所属的系统账号ID",
      "注意事项": "修复时应严格遵循上下文已有的术语结构（如\"系统账号的账号ID\"），避免擅自合并嵌套关系；当存在明确参考句式（如问题上下文第855行）时，必须保持完全一致的表达模板。"
    },
    {
      "defect_id": 483194,
      "sentence": "通过SN码查询与其关联的系统账号的账号ID。使用callback异步回调。",
      "reference_sentence": "通过SN码查询与其关联的系统账号的账号ID。使用Promise异步回调。",
      "line_num": 1481,
      "context": "{\"1476\":\"\",\"1477\":\"### getOsAccountLocalIdForSerialNumber<sup>9+</sup>\",\"1478\":\"\",\"1479\":\"getOsAccountLocalIdForSerialNumber(serialNumber: number, callback: AsyncCallback&lt;number&gt;): void\",\"1480\":\"\",\"1481\":\"通过SN码查询与其关联的系统账号的账号ID。使用callback异步回调。\",\"1482\":\"\",\"1483\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1484\":\"\",\"1485\":\"**参数：**\",\"1486\":\"\"}",
      "用户拒绝的修改": "通过SN码查询与其关联的系统账号的账号ID。使用异步回调。",
      "注意事项": "修复时必须严格保留接口文档中明确使用的技术术语（如callback/Promise等参数名），不可因追求表达简洁而删除关键参数名称；在统一用词前需核对上下文接口定义，确保技术术语与API参数保持完全一致。"
    },
    {
      "defect_id": 483190,
      "sentence": "获取分布式虚拟设备ID。使用Promise异步回调。",
      "reference_sentence": "查询当前进程所属的系统账号的信息。使用Promise异步回调。",
      "line_num": 1442,
      "context": "{\"1437\":\"\",\"1438\":\"### queryDistributedVirtualDeviceId<sup>9+</sup>\",\"1439\":\"\",\"1440\":\"queryDistributedVirtualDeviceId(): Promise&lt;string&gt;\",\"1441\":\"\",\"1442\":\"获取分布式虚拟设备ID。使用Promise异步回调。\",\"1443\":\"\",\"1444\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或 ohos.permission.DISTRIBUTED_DATASYNC\",\"1445\":\"\",\"1446\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1447\":\"\"}",
      "用户拒绝的修改": "获取分布式虚拟设备ID。使用callback异步回调。",
      "注意事项": "修复前必须检查接口定义（如`queryDistributedVirtualDeviceId(): Promise<string>`）和上下文术语（如参考句中的\"Promise\"），确保异步回调方式与接口返回类型严格一致，并在全文档范围内统一使用单一术语（如优先采用接口声明的`Promise`）。"
    },
    {
      "defect_id": 483174,
      "sentence": "查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。",
      "reference_sentence": "获取指定系统账号的全部约束。使用Promise异步回调。",
      "line_num": 1200,
      "context": "{\"1195\":\"\",\"1196\":\"### getActivatedOsAccountLocalIds<sup>9+</sup>\",\"1197\":\"\",\"1198\":\"getActivatedOsAccountLocalIds(): Promise&lt;Array&lt;number&gt;&gt;\",\"1199\":\"\",\"1200\":\"查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。\",\"1201\":\"\",\"1202\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1203\":\"\",\"1204\":\"**返回值：**\",\"1205\":\"\"}",
      "用户拒绝的修改": "获取当前处于激活状态的系统账号的ID列表。使用Promise异步回调。",
      "注意事项": "修复时需严格匹配接口方法名中的动词（如\"get\"对应\"查询\"），并检查上下文已有术语使用习惯（如参考句使用\"获取\"时应保持全文统一），避免仅依赖近义词替换导致术语断层。"
    },
    {
      "defect_id": 483231,
      "sentence": "返回true表示支持多系统账号；返回false表示不支持。",
      "reference_sentence": "Promise对象。返回true表示支持多系统账号；返回false表示不支持。",
      "line_num": 1671,
      "context": "{\"1666\":\"\",\"1667\":\"**参数：**\",\"1668\":\"\",\"1669\":\"| 参数名   | 类型                         | 必填 | 说明                                                     |\",\"1670\":\"| -------- | ---------------------------- | ---- | ------------------------------------------------------ |\",\"1671\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示支持多系统账号；返回false表示不支持。 |\",\"1672\":\"\",\"1673\":\"**示例：**\",\"1674\":\"\",\"1675\":\"  ```ts\",\"1676\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "Promise对象。返回true表示支持多系统账号；返回false表示不支持。",
      "注意事项": "修复时必须严格检查上下文中的参数类型定义（如AsyncCallback），确保返回值描述与接口类型完全一致，避免引入Promise等未在上下文中明确定义的术语造成概念混淆。"
    },
    {
      "defect_id": 483214,
      "sentence": "Account not found.",
      "reference_sentence": "The account indicated by serialNumber dose not exist.",
      "line_num": 1636,
      "context": "{\"1631\":\"| 错误码ID | 错误信息             |\",\"1632\":\"| -------- | ------------------- |\",\"1633\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. |\",\"1634\":\"| 12300001 | The system service works abnormally. |\",\"1635\":\"| 12300002 | Invalid localId.    |\",\"1636\":\"| 12300003 | Account not found. |\",\"1637\":\"\",\"1638\":\"**示例：** 获取ID为100的系统账号关联的SN码\",\"1639\":\"\",\"1640\":\"  ```ts\",\"1641\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "The account indicated by localId dose not exist.",
      "注意事项": "严格遵循上下文参数命名规范（如\"localId\"与\"serialNumber\"不可混用），修复时必须与参考句式和已有错误码的变量名称保持完全一致，避免擅自添加未明确关联的上下文参数。"
    },
    {
      "defect_id": 483326,
      "sentence": "查询当前进程所属的系统账号的账号类型。使用Promise异步回调。",
      "reference_sentence": "查询当前进程所属的系统账号的账号类型。使用callback异步回调。",
      "line_num": 2557,
      "context": "{\"2552\":\"\",\"2553\":\"### getOsAccountTypeFromProcess<sup>(deprecated)</sup>\",\"2554\":\"\",\"2555\":\"getOsAccountTypeFromProcess(): Promise&lt;OsAccountType&gt;\",\"2556\":\"\",\"2557\":\"查询当前进程所属的系统账号的账号类型。使用Promise异步回调。\",\"2558\":\"\",\"2559\":\"> **说明：**\",\"2560\":\">\",\"2561\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountType](#getosaccounttype9-1)。\",\"2562\":\"\"}",
      "用户拒绝的修改": "查询当前进程所属的系统账号的账号类型。使用callback异步回调。",
      "注意事项": "修复时必须严格检查上下文中的技术术语一致性（如函数返回类型Promise），避免将不同异步模式（Promise/callback）混用，保持与API定义完全匹配的表述方式。"
    },
    {
      "defect_id": 483345,
      "sentence": "账号SN码。",
      "reference_sentence": "账号SN码。",
      "line_num": 2699,
      "context": "{\"2694\":\"\",\"2695\":\"**参数：**\",\"2696\":\"\",\"2697\":\"| 参数名       | 类型   | 必填 | 说明       |\",\"2698\":\"| ------------ | ------ | ---- | ---------- |\",\"2699\":\"| serialNumber | number | 是   | 账号SN码。 |\",\"2700\":\"\",\"2701\":\"**返回值：**\",\"2702\":\"\",\"2703\":\"| 类型                  | 说明                                                         |\",\"2704\":\"| --------------------- | -------------------------------------------- |\"}",
      "用户拒绝的修改": "帐号SN码。",
      "注意事项": "在修改术语前必须严格检查上下文和参考示例，优先遵循文档已有统一用词，避免依赖通用习惯错误替换内部规范术语。"
    },
    {
      "defect_id": 483324,
      "sentence": "查询当前进程所属的系统账号的信息。使用Promise异步回调。",
      "reference_sentence": "查询当前进程所属的系统账号的信息。使用callback异步回调。",
      "line_num": 2493,
      "context": "{\"2488\":\"\",\"2489\":\"### queryCurrentOsAccount<sup>(deprecated)</sup>\",\"2490\":\"\",\"2491\":\"queryCurrentOsAccount(): Promise&lt;OsAccountInfo&gt;\",\"2492\":\"\",\"2493\":\"查询当前进程所属的系统账号的信息。使用Promise异步回调。\",\"2494\":\"\",\"2495\":\"> **说明：**\",\"2496\":\">\",\"2497\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"2498\":\"\"}",
      "用户拒绝的修改": "查询当前进程所属的系统账号的信息。使用callback异步回调。",
      "注意事项": "修复时必须严格核对接口定义和上下文术语（如\"Promise\"与\"callback\"），确保异步机制描述与代码声明（如`Promise<OsAccountInfo>`）完全一致，禁止将技术术语替换为同义词。"
    },
    {
      "defect_id": 483325,
      "sentence": "Promise对象，返回当前进程所属的系统账号信息。",
      "reference_sentence": "回调函数。如果查询成功，err为null，data为当前进程所属的系统账号信息；否则为错误对象。",
      "line_num": 2507,
      "context": "{\"2502\":\"\",\"2503\":\"**返回值：**\",\"2504\":\"\",\"2505\":\"| 类型                                           | 说明                                       |\",\"2506\":\"| ---------------------------------------------- | ------------------------------------------ |\",\"2507\":\"| Promise&lt;[OsAccountInfo](#osaccountinfo)&gt; | Promise对象，返回当前进程所属的系统账号信息。 |\",\"2508\":\"\",\"2509\":\"**示例：**\",\"2510\":\"\",\"2511\":\"  ```ts\",\"2512\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "回调函数。如果查询成功，err为null，data为当前进程所属的系统账号信息；否则为错误对象。",
      "注意事项": "修复时必须严格校验上下文术语一致性（如异步处理方式Promise/callback），确保返回值类型与文档结构定义完全匹配，避免跨模式混用。"
    },
    {
      "defect_id": 483348,
      "sentence": "系统账号ID。",
      "reference_sentence": "系统账号ID。",
      "line_num": 2736,
      "context": "{\"2731\":\"\",\"2732\":\"**参数：**\",\"2733\":\"\",\"2734\":\"| 参数名   | 类型                        | 必填 | 说明                                                                         |\",\"2735\":\"| -------- | --------------------------- | ---- | --------------------------------------------------------------------------- |\",\"2736\":\"| localId  | number                      | 是   | 系统账号ID。                                                                 |\",\"2737\":\"| callback | AsyncCallback&lt;number&gt; | 是   | 回调函数。如果获取成功，err为null，data为与该系统账号关联的SN码；否则为错误对象。 |\",\"2738\":\"\",\"2739\":\"**示例：** 获取ID为100的系统账号关联的SN码\",\"2740\":\"\",\"2741\":\"  ```ts\"}",
      "用户拒绝的修改": "系统帐号ID。",
      "注意事项": "在修复术语一致性时，需优先确认上下文中的原始用词（如\"账号\"）和用户明确指定的统一规则，避免因字形近义词（如\"帐号\"）擅自替换；若用户已提供参考句子，应直接匹配而非依赖模型自身语感判断。"
    },
    {
      "defect_id": 483319,
      "sentence": "查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。",
      "reference_sentence": "获取指定系统账号的全部约束。使用Promise异步回调。",
      "line_num": 2433,
      "context": "{\"2428\":\"\",\"2429\":\"> **说明：**\",\"2430\":\">\",\"2431\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9-1)。\",\"2432\":\"\",\"2433\":\"查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。\",\"2434\":\"\",\"2435\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2436\":\"\",\"2437\":\"**返回值：**\",\"2438\":\"\"}",
      "用户拒绝的修改": "获取当前处于激活状态的系统账号的ID列表。使用Promise异步回调。",
      "注意事项": "在保持动词一致性时应优先匹配接口名称中的核心动词（如\"query\"对应\"查询\"），而非简单统一使用同义词，技术文档需严格遵循接口命名中的动作术语。"
    },
    {
      "defect_id": 483346,
      "sentence": "系统账号ID。",
      "reference_sentence": "系统账号ID。",
      "line_num": 2666,
      "context": "{\"2661\":\"**参数：**\",\"2662\":\"\",\"2663\":\"| 参数名       | 类型                        | 必填 | 说明                                                                               |\",\"2664\":\"| ------------ | --------------------------- | ---- | -------------------------------------------------------------------------------- |\",\"2665\":\"| serialNumber | number                      | 是   | 账号SN码。                                                                        |\",\"2666\":\"| callback     | AsyncCallback&lt;number&gt; | 是   | 回调函数。如果查询成功，err为null，data为与SN码关联的系统账号的账号ID；否则为错误对象。 |\",\"2667\":\"\",\"2668\":\"**示例：** 查询与SN码12345关联的系统账号的ID\",\"2669\":\"\",\"2670\":\"  ```ts\",\"2671\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "系统帐号ID。",
      "注意事项": "在修改术语前必须严格检查上下文中的现有用词（如参考句子的\"账号SN码\"），优先遵循用户指定的统一形式而非常见用法；涉及多位置重复出现的术语时，需全局验证所有相关实例的一致性后再执行替换。"
    },
    {
      "defect_id": 483347,
      "sentence": "系统账号ID。",
      "reference_sentence": "系统账号ID。",
      "line_num": 2705,
      "context": "{\"2700\":\"\",\"2701\":\"**返回值：**\",\"2702\":\"\",\"2703\":\"| 类型                  | 说明                                                         |\",\"2704\":\"| --------------------- | -------------------------------------------- |\",\"2705\":\"| Promise&lt;number&gt; | Promise对象，返回与SN码关联的系统账号的账号ID。 |\",\"2706\":\"\",\"2707\":\"**示例：** 查询与SN码12345关联的系统账号的ID\",\"2708\":\"\",\"2709\":\"  ```ts\",\"2710\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "系统帐号ID。",
      "注意事项": "修复前必须严格检查上下文及参考句子中的术语使用习惯，优先沿用文档已有统一表述（如“账号”），避免混淆形近词（如“帐号”）；修改后需全局验证术语一致性，确保不破坏原始语境逻辑。"
    },
    {
      "defect_id": 483244,
      "sentence": "> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。",
      "line_num": 1838,
      "context": "{\"1833\":\"\",\"1834\":\"判断指定系统账号是否具有指定约束。使用Promise异步回调。\",\"1835\":\"\",\"1836\":\"> **说明：**\",\"1837\":\">\",\"1838\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"1839\":\"\",\"1840\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。\",\"1841\":\"\",\"1842\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1843\":\"\"}",
      "用户拒绝的修改": "> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。替代方法仅向系统应用开放。",
      "注意事项": "保持上下文信息独立分离，避免在同一个句子中混合版本变更说明和权限限制信息；确保新增建议方法时维持原句结构完整性，遵循\"支持-废弃-建议\"的单一逻辑链。"
    },
    {
      "defect_id": 483243,
      "sentence": "> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。",
      "line_num": 1800,
      "context": "{\"1795\":\"\",\"1796\":\"判断指定系统账号是否具有指定约束。使用callback异步回调。\",\"1797\":\"\",\"1798\":\"> **说明：**\",\"1799\":\">\",\"1800\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"1801\":\"\",\"1802\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。\",\"1803\":\"\",\"1804\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1805\":\"\"}",
      "用户拒绝的修改": "> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。替代方法仅向系统应用开放。",
      "注意事项": "修复时应严格检查上下文是否存在重复权限说明，保持句子结构单线化（建议替代方法后不再追加权限限制），避免新增内容与已有系统权限说明产生冗余。"
    },
    {
      "defect_id": 483288,
      "sentence": "获取已创建的系统账号数量，使用Promise异步回调。",
      "reference_sentence": "获取已创建的系统账号数量。使用callback异步回调。",
      "line_num": 2079,
      "context": "{\"2074\":\"\",\"2075\":\"### getCreatedOsAccountsCount<sup>(deprecated)</sup>\",\"2076\":\"\",\"2077\":\"getCreatedOsAccountsCount(): Promise&lt;number&gt;\",\"2078\":\"\",\"2079\":\"获取已创建的系统账号数量，使用Promise异步回调。\",\"2080\":\"\",\"2081\":\"> **说明：**\",\"2082\":\">\",\"2083\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountCount](#getosaccountcount9-1)。\",\"2084\":\"\"}",
      "用户拒绝的修改": "获取已创建的系统账号数量。使用Promise异步回调。",
      "注意事项": "修复时必须严格核对接口定义中的异步方式术语（如Promise/callback），确保与上下文返回类型一致，避免因参考句子干扰而错误替换关键术语。"
    },
    {
      "defect_id": 483344,
      "sentence": "账号SN码。",
      "reference_sentence": "账号SN码。",
      "line_num": 2665,
      "context": "{\"2660\":\"\",\"2661\":\"**参数：**\",\"2662\":\"\",\"2663\":\"| 参数名       | 类型                        | 必填 | 说明                                                                               |\",\"2664\":\"| ------------ | --------------------------- | ---- | -------------------------------------------------------------------------------- |\",\"2665\":\"| serialNumber | number                      | 是   | 账号SN码。                                                                        |\",\"2666\":\"| callback     | AsyncCallback&lt;number&gt; | 是   | 回调函数。如果查询成功，err为null，data为与SN码关联的系统账号的账号ID；否则为错误对象。 |\",\"2667\":\"\",\"2668\":\"**示例：** 查询与SN码12345关联的系统账号的ID\",\"2669\":\"\",\"2670\":\"  ```ts\"}",
      "用户拒绝的修改": "帐号SN码。",
      "注意事项": "修复时应优先检查上下文和用户提供的参考示例，严格遵循现有术语（如“账号”），避免依赖LLM内部知识库擅自替换近义词；若用户已明确指定统一用词，必须无条件采纳，不得引入其他变体。"
    },
    {
      "defect_id": 483262,
      "sentence": "Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "reference_sentence": "Promise对象。返回true表示账号已激活；返回false表示账号未激活。",
      "line_num": 1855,
      "context": "{\"1850\":\"\",\"1851\":\"**返回值：**\",\"1852\":\"\",\"1853\":\"| 类型                   | 说明                                                                   |\",\"1854\":\"| ---------------------- | --------------------------------------------------------------------- |\",\"1855\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。 |\",\"1856\":\"\",\"1857\":\"**示例：** 判断ID为100的系统账号是否有禁止使用Wi-Fi的约束\",\"1858\":\"\",\"1859\":\"  ```ts\",\"1860\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "Promise对象。返回true表示指定约束已激活；返回false表示指定约束未激活。",
      "注意事项": "严格保持技术术语的一致性，修复时必须优先沿用原文已确立的术语体系（如\"使能\"），避免基于主观理解替换为同义但破坏统一性的词汇（如\"激活\"）；若需调整术语，需结合完整上下文验证是否存在系统性映射关系。"
    },
    {
      "defect_id": 483343,
      "sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或ohos.permission.DISTRIBUTED_DATASYNC",
      "reference_sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。",
      "line_num": 2627,
      "context": "{\"2622\":\"\",\"2623\":\"> **说明：**\",\"2624\":\">\",\"2625\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[queryDistributedVirtualDeviceId](#querydistributedvirtualdeviceid9-1)。\",\"2626\":\"\",\"2627\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或ohos.permission.DISTRIBUTED_DATASYNC\",\"2628\":\"\",\"2629\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2630\":\"\",\"2631\":\"**返回值：**\",\"2632\":\"\"}",
      "用户拒绝的修改": "ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.DISTRIBUTED_DATASYNC，该权限仅系统应用可申请。",
      "注意事项": "修复时应保持标点符号体系一致性（避免混合使用括号与中文说明），并列结构需统一说明位置（权限描述与限制条件应采用相同语法结构），并严格匹配上下文格式规范。"
    },
    {
      "defect_id": 483300,
      "sentence": "根据域账号信息，获取与其关联的系统账号的账号ID。使用callback异步回调。",
      "reference_sentence": "根据uid查询对应的系统账号ID，使用Promise异步回调。",
      "line_num": 2244,
      "context": "{\"2239\":\"\",\"2240\":\"### getOsAccountLocalIdFromDomain<sup>(deprecated)</sup>\",\"2241\":\"\",\"2242\":\"getOsAccountLocalIdFromDomain(domainInfo: DomainAccountInfo, callback: AsyncCallback&lt;number&gt;): void\",\"2243\":\"\",\"2244\":\"根据域账号信息，获取与其关联的系统账号的账号ID。使用callback异步回调。\",\"2245\":\"\",\"2246\":\"> **说明：**\",\"2247\":\">\",\"2248\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalIdForDomain](#getosaccountlocalidfordomain9)。\",\"2249\":\"\"}",
      "用户拒绝的修改": "根据域账号信息，获取与其关联的系统账号的账号ID，使用callback异步回调。",
      "注意事项": "修复时应严格检查相邻接口描述和版本说明，确保异步机制术语（callback/Promise）与当前接口定义及上下文版本保持一致，特别注意不同API版本间异步机制的差异。"
    },
    {
      "defect_id": 483342,
      "sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或 ohos.permission.DISTRIBUTED_DATASYNC",
      "reference_sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。",
      "line_num": 2593,
      "context": "{\"2588\":\"\",\"2589\":\"> **说明：**\",\"2590\":\">\",\"2591\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[queryDistributedVirtualDeviceId](#querydistributedvirtualdeviceid9)。\",\"2592\":\"\",\"2593\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS（仅系统应用可申请）或 ohos.permission.DISTRIBUTED_DATASYNC\",\"2594\":\"\",\"2595\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2596\":\"\",\"2597\":\"**参数：**\",\"2598\":\"\"}",
      "用户拒绝的修改": "ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.DISTRIBUTED_DATASYNC，该权限仅系统应用可申请。",
      "注意事项": "确保标点符号（括号/逗号）和连接词（如“或”）的用法在上下文保持统一，避免混合使用不同格式的权限说明方式（如括号内注释与独立中文说明），优先采用与上下文一致的注释结构。"
    },
    {
      "defect_id": 483298,
      "sentence": "根据uid查询对应的系统账号ID。使用callback异步回调。",
      "reference_sentence": "根据uid查询对应的系统账号ID，使用Promise异步回调。",
      "line_num": 2173,
      "context": "{\"2168\":\"\",\"2169\":\"### getOsAccountLocalIdFromUid<sup>(deprecated)</sup>\",\"2170\":\"\",\"2171\":\"getOsAccountLocalIdFromUid(uid: number, callback: AsyncCallback&lt;number&gt;): void\",\"2172\":\"\",\"2173\":\"根据uid查询对应的系统账号ID。使用callback异步回调。\",\"2174\":\"\",\"2175\":\"> **说明：**\",\"2176\":\">\",\"2177\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalIdForUid](#getosaccountlocalidforuid9)。\",\"2178\":\"\"}",
      "用户拒绝的修改": "根据uid查询对应的系统账号ID，使用callback异步回调。",
      "注意事项": "修复时必须严格核对上下文中的参数类型（如callback/Promise）并保持术语一致，优先参考相邻接口定义或代码示例中的异步处理方式，避免脱离上下文孤立修改。"
    },
    {
      "defect_id": 483318,
      "sentence": "查询当前处于激活状态的系统账号的ID列表。使用callback异步回调。",
      "reference_sentence": "获取指定系统账号的全部约束。使用callback异步回调。",
      "line_num": 2394,
      "context": "{\"2389\":\"\",\"2390\":\"### queryActivatedOsAccountIds<sup>(deprecated)</sup>\",\"2391\":\"\",\"2392\":\"queryActivatedOsAccountIds(callback: AsyncCallback&lt;Array&lt;number&gt;&gt;): void\",\"2393\":\"\",\"2394\":\"查询当前处于激活状态的系统账号的ID列表。使用callback异步回调。\",\"2395\":\"\",\"2396\":\"> **说明：**\",\"2397\":\">\",\"2398\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9)。\",\"2399\":\"\"}",
      "用户拒绝的修改": "获取当前处于激活状态的系统账号的ID列表。使用callback异步回调。",
      "注意事项": "修复时必须严格匹配接口名称中的动词（如query对应\"查询\"），优先保持上下文已有术语一致性而非全局统一，同时需检查相邻接口描述用词是否存在关联性约束。"
    },
    {
      "defect_id": 483350,
      "sentence": "getSerialNumberByOsAccountLocalId(localId: number): Promise&lt;number&gt;",
      "reference_sentence": "getSerialNumberByOsAccountLocalId(localId: number, callback: AsyncCallback&lt;number&gt;): void",
      "line_num": 2756,
      "context": "{\"2751\":\"  });\",\"2752\":\"  ```\",\"2753\":\"\",\"2754\":\"### getSerialNumberByOsAccountLocalId<sup>(deprecated)</sup>\",\"2755\":\"\",\"2756\":\"getSerialNumberByOsAccountLocalId(localId: number): Promise&lt;number&gt;\",\"2757\":\"\",\"2758\":\"通过系统账号ID获取与该系统账号关联的SN码。使用Promise异步回调。\",\"2759\":\"\",\"2760\":\"> **说明：**\",\"2761\":\">\"}",
      "用户拒绝的修改": "getSerialNumberByOsAccountLocalId(localId: number, callback: AsyncCallback&lt;number&gt;): void",
      "注意事项": "修复方法签名时必须严格检查上下文规定的异步模式（Promise/Callback）一致性，优先匹配已有示例的调用风格而非孤立参数补全，避免混合不同异步范式导致工具链解析冲突。"
    },
    {
      "defect_id": 483279,
      "sentence": "isOsAccountVerified(localId: number, callback: AsyncCallback&lt;boolean&gt;): void",
      "reference_sentence": "isOsAccountVerified(localId?: number): Promise&lt;boolean&gt;",
      "line_num": 1969,
      "context": "{\"1964\":\"  });\",\"1965\":\"  ```\",\"1966\":\"\",\"1967\":\"### isOsAccountVerified<sup>(deprecated)</sup>\",\"1968\":\"\",\"1969\":\"isOsAccountVerified(localId: number, callback: AsyncCallback&lt;boolean&gt;): void\",\"1970\":\"\",\"1971\":\"检查指定系统账号是否已验证。使用callback异步回调。\",\"1972\":\"\",\"1973\":\"> **说明：**\",\"1974\":\">\"}",
      "用户拒绝的修改": "isOsAccountVerified(localId?: number, callback: AsyncCallback&lt;boolean&gt;): void",
      "注意事项": "修复时必须严格校验参数数量、类型和可选性是否与上下文中的重载方法保持完全一致，特别是当存在多个方法签名时，需确保所有参数结构在必填/可选属性上形成逻辑连贯的体系。"
    },
    {
      "defect_id": 483354,
      "sentence": "系统账号是否已解锁（EL2级别目录是否解密）",
      "reference_sentence": "系统账号是否已解锁（EL2级别目录是否解密）",
      "line_num": 2980,
      "context": "{\"2975\":\"| localId                        | number                                                       | 是   | 系统账号ID。                      |\",\"2976\":\"| localName                      | string                                                       | 是   | 系统账号名称。                    |\",\"2977\":\"| type                           | [OsAccountType](#osaccounttype)                              | 是   | 系统账号类型。                      |\",\"2978\":\"| constraints                    | Array&lt;string&gt;                                          | 是   | 系统账号[约束](#系统账号约束列表)，默认为空。|\",\"2979\":\"| isVerified<sup>(deprecated)</sup> | boolean                                                   | 是   | 账号是否验证。true表示指定账号已验证；false表示指定账号未验证。<br>**说明**：从API version 7开始支持，从API version 11开始废弃。           |\",\"2980\":\"| isUnlocked<sup>11+</sup>      | boolean                                                       | 是   | 账号是否已解锁（EL2级别目录是否解密）。true表示指定账号已解锁；false表示指定账号未解锁。                      |\",\"2981\":\"| photo<sup>8+</sup>             | string                                                       | 是   | 系统账号头像，默认为空。                      |\",\"2982\":\"| createTime<sup>8+</sup>        | number                                                       | 是   | 系统账号创建时间。                  |\",\"2983\":\"| lastLoginTime<sup>8+</sup>     | number                                                       | 是   | 系统账号最后一次登录时间，默认为空。          |\",\"2984\":\"| serialNumber<sup>8+</sup>      | number                                                       | 是   | 系统账号SN码。                      |\",\"2985\":\"| isActived<sup>(deprecated)</sup>         | boolean                                            | 是   | 系统账号激活状态。true表示指定账号处于激活状态；false表示指定账号处于未激活状态。<br>**说明**：从API version 7开始支持，从API version 11开始废弃。                  |\"}",
      "用户拒绝的修改": "系统账号是否已解锁（EL2级别目录是否解锁）",
      "注意事项": "修复时应优先保留专业术语或上下文已定义的词汇，确保技术准确性高于表面用词一致性；若字段存在明确技术指向（如\"解密\"对应EL2目录操作），不得擅自替换为近义词。"
    },
    {
      "defect_id": 483365,
      "sentence": "### addServerConfig<sup>18+</sup>",
      "reference_sentence": "### updateAccountInfo<sup>18+</sup>updateAccountInfo(oldAccountInfo: DomainAccountInfo, newAccountInfo: DomainAccountInfo): Promise&lt;void&gt;",
      "line_num": 3019,
      "context": "{\"3014\":\"\",\"3015\":\"## DomainServerConfigManager<sup>18+</sup>\",\"3016\":\"\",\"3017\":\"域服务器配置管理类。\",\"3018\":\"\",\"3019\":\"### addServerConfig<sup>18+</sup>\",\"3020\":\"\",\"3021\":\"static addServerConfig(parameters: Record&lt;string, Object&gt;): Promise&lt;DomainServerConfig&gt;\",\"3022\":\"\",\"3023\":\"添加域服务器配置。使用Promise异步回调。\",\"3024\":\"\"}",
      "用户拒绝的修改": "### addServerConfig<sup>18+</sup>addServerConfig(parameters: Record&lt;string, Object&gt;): Promise&lt;DomainServerConfig&gt;",
      "注意事项": "保持标题层级简洁性（仅保留方法名+版本标记），将参数和返回值描述移至标题下方独立段落；严格遵循\"### 方法名<sup>版本</sup>\"的统一格式，避免在标题行混入方法签名细节。"
    },
    {
      "defect_id": 483368,
      "sentence": "Promise对象，返回更新后的域服务器配置。",
      "reference_sentence": "Promise对象，返回新添加的域服务器配置。",
      "line_num": 3138,
      "context": "{\"3133\":\"\",\"3134\":\"**返回值：**\",\"3135\":\"\",\"3136\":\"| 类型                      | 说明                     |\",\"3137\":\"| :------------------------ | ----------------------- |\",\"3138\":\"| Promise&lt;[DomainServerConfig](#domainserverconfig18)&gt; | Promise对象，返回更新后的域服务器配置。 |\",\"3139\":\"\",\"3140\":\"**错误码：**\",\"3141\":\"\",\"3142\":\"| 错误码ID | 错误信息                     |\",\"3143\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "Promise对象，返回更新后的配置。",
      "注意事项": "修复时应优先保留领域专用术语的完整性（如\"域服务器配置\"），仅在确实存在上下文矛盾时才进行简化；必须结合返回值类型定义（DomainServerConfig）验证术语准确性，避免过度统一导致技术信息丢失。"
    },
    {
      "defect_id": 483364,
      "sentence": "## DomainServerConfigManager<sup>18+</sup>",
      "reference_sentence": "## DomainAccountManager<sup>18+</sup>域账号管理类。",
      "line_num": 3015,
      "context": "{\"3010\":\"| ----------- | ------ | ---- | ---------- |\",\"3011\":\"| parameters | Record<string, Object> | 是   | 服务器配置参数。 |\",\"3012\":\"| id | string | 是   | 服务器配置标识。|\",\"3013\":\"| domain | string | 是 | 服务器所属的域。 |\",\"3014\":\"\",\"3015\":\"## DomainServerConfigManager<sup>18+</sup>\",\"3016\":\"\",\"3017\":\"域服务器配置管理类。\",\"3018\":\"\",\"3019\":\"### addServerConfig<sup>18+</sup>\",\"3020\":\"\"}",
      "用户拒绝的修改": "## DomainServerConfigManager<sup>18+</sup>表示域服务器配置管理类。",
      "注意事项": "保持标题层级简洁性（仅保留类名和标签），详细类描述应置于标题下方独立段落；严格区分相似术语的概念边界，避免因术语混淆导致信息错位。"
    },
    {
      "defect_id": 483351,
      "sentence": "通过系统账号ID获取与该系统账号关联的SN码。使用Promise异步回调。",
      "reference_sentence": "通过系统账号ID获取与该系统账号关联的SN码。使用callback异步回调。",
      "line_num": 2758,
      "context": "{\"2753\":\"\",\"2754\":\"### getSerialNumberByOsAccountLocalId<sup>(deprecated)</sup>\",\"2755\":\"\",\"2756\":\"getSerialNumberByOsAccountLocalId(localId: number): Promise&lt;number&gt;\",\"2757\":\"\",\"2758\":\"通过系统账号ID获取与该系统账号关联的SN码。使用Promise异步回调。\",\"2759\":\"\",\"2760\":\"> **说明：**\",\"2761\":\">\",\"2762\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getSerialNumberForOsAccountLocalId](#getserialnumberforosaccountlocalid9-1)。\",\"2763\":\"\"}",
      "用户拒绝的修改": "通过系统账号ID获取与该系统账号关联的SN码。使用callback异步回调。",
      "注意事项": "修复时必须严格核对技术上下文中的术语一致性（如代码示例中的Promise类型定义），优先保持与代码实现相匹配的技术术语，避免脱离上下文进行概念替换。"
    },
    {
      "defect_id": 483366,
      "sentence": "### removeServerConfig<sup>18+</sup>",
      "reference_sentence": "### updateAccountInfo<sup>18+</sup>updateAccountInfo(oldAccountInfo: DomainAccountInfo, newAccountInfo: DomainAccountInfo): Promise&lt;void&gt>",
      "line_num": 3068,
      "context": "{\"3063\":\"  }).catch((err: BusinessError) => {\",\"3064\":\"    console.error('add server configuration failed, error: ' + JSON.stringify(err));\",\"3065\":\"  });\",\"3066\":\"  ```\",\"3067\":\"\",\"3068\":\"### removeServerConfig<sup>18+</sup>\",\"3069\":\"\",\"3070\":\"static removeServerConfig(configId: string): Promise&lt;void&gt;\",\"3071\":\"\",\"3072\":\"删除域服务器配置。使用Promise异步回调。\",\"3073\":\"\"}",
      "用户拒绝的修改": "### removeServerConfig<sup>18+</sup>removeServerConfig(configId: string): Promise&lt;void&gt>",
      "注意事项": "保持标题行与内容描述的层级分离，标题行仅保留方法名和标签，详细参数及返回值描述应统一放置在下方内容区；严格遵循参考示例中\"### 方法名<sup>标签</sup>\"+换行后写具体声明的两段式结构。"
    },
    {
      "defect_id": 483367,
      "sentence": "Promise对象，无返回结果的Promise对象。",
      "reference_sentence": "Promise对象，返回新添加的域服务器配置。",
      "line_num": 3088,
      "context": "{\"3083\":\"\",\"3084\":\"**返回值：**\",\"3085\":\"\",\"3086\":\"| 类型                      | 说明                     |\",\"3087\":\"| :------------------------ | ----------------------- |\",\"3088\":\"| Promise&lt;void&gt; | Promise对象，无返回结果的Promise对象。 |\",\"3089\":\"\",\"3090\":\"**错误码：**\",\"3091\":\"\",\"3092\":\"| 错误码ID | 错误信息                     |\",\"3093\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "Promise对象，无返回值。",
      "注意事项": "修复时应优先确保技术准确性而非机械统一用词，需结合上下文确认\"返回值\"是否特指Promise解析值；当技术文档存在固定表述范式时，应保留领域约定俗成的表达方式。"
    },
    {
      "defect_id": 483363,
      "sentence": "## DomainServerConfig<sup>18+</sup>",
      "reference_sentence": "## OsAccountInfo表示系统账号信息。",
      "line_num": 3003,
      "context": "{\"2998\":\"| ----------- | ------ | ---- | ---------- |\",\"2999\":\"| domain      | string | 是   | 域名。     |\",\"3000\":\"| accountName | string | 是   | 域账号名。 |\",\"3001\":\"| serverConfigId<sup>18+</sup> | string | 否   | 域账号配置ID。 |\",\"3002\":\"\",\"3003\":\"## DomainServerConfig<sup>18+</sup>\",\"3004\":\"\",\"3005\":\"域服务器配置。\",\"3006\":\"\",\"3007\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"3008\":\"\"}",
      "用户拒绝的修改": "## DomainServerConfig<sup>18+</sup>表示域服务器配置。",
      "注意事项": "保持标题简洁性，避免在标题行直接添加解释性描述（详细内容应置于标题下方正文）；严格区分并准确对应上下文中的术语概念，确保修复前后语义一致且不引入混淆。"
    },
    {
      "defect_id": 483401,
      "sentence": "禁止删除用户",
      "reference_sentence": "禁止创建新用户",
      "line_num": 3332,
      "context": "{\"3327\":\"| constraint.bluetooth.set              | 禁止配置蓝牙                   |\",\"3328\":\"| constraint.bluetooth | 禁止使用蓝牙 |\",\"3329\":\"| constraint.bluetooth.share | 禁止共享使用蓝牙 |\",\"3330\":\"| constraint.usb.file.transfer | 禁止通过USB传输文件 |\",\"3331\":\"| constraint.credentials.set | 禁止配置用户凭据 |\",\"3332\":\"| constraint.os.account.remove | 禁止删除用户 |\",\"3333\":\"| constraint.managed.profile.remove | 禁止删除此用户的托管配置文件 |\",\"3334\":\"| constraint.debug.features.use | 禁止启用或访问调试功能 |\",\"3335\":\"| constraint.vpn.set | 禁止配置VPN |\",\"3336\":\"| constraint.date.time.set | 禁止配置日期时间和时区 |\",\"3337\":\"| constraint.tethering.config | 禁止配置Tethering |\"}",
      "用户拒绝的修改": "禁止删除帐户",
      "注意事项": "修复时必须严格核查上下文术语使用习惯，禁止将原文核心名词（如\"用户\"）替换为近义词（如\"帐户\"），即使语义相近也应保持与问题句子、参考句子及相邻条目完全一致的术语体系。"
    },
    {
      "defect_id": 485376,
      "sentence": "编辑媒体文件时，需要先对媒体流进行解封装，获取到指定sample进行编辑。",
      "reference_sentence": "编辑媒体文件时，需要先对媒体流进行解封装，获取到指定样本进行编辑。",
      "line_num": 17,
      "context": "{\"12\":\"  \",\"13\":\"  播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。\",\"14\":\"\",\"15\":\"- 音视频编辑\",\"16\":\"  \",\"17\":\"  编辑媒体文件时，需要先对媒体流进行解封装，获取到指定sample进行编辑。\",\"18\":\"\",\"19\":\"- 媒体文件格式转换（转封装）\",\"20\":\"\",\"21\":\"  媒体文件格式转换时，需要先对媒体流进行解封装，然后按需将媒体流封装至新的格式文件内。\",\"22\":\"\"}",
      "用户拒绝的修改": "编辑媒体文件时，需要先对媒体流进行解封装，获取到指定样本进行编辑。",
      "注意事项": "修复术语一致性时需优先确认上下文领域规范，技术文档应保留行业通用英文术语（如sample），仅在全文统一使用中文译名时才进行替换；同时需检查相邻段落是否存在已确立的术语使用惯例。"
    },
    {
      "defect_id": 483375,
      "sentence": "Promise对象，返回获取的域服务器配置。",
      "reference_sentence": "Promise对象，返回更新后的域服务器配置。",
      "line_num": 3193,
      "context": "{\"3188\":\"\",\"3189\":\"**返回值：**\",\"3190\":\"\",\"3191\":\"| 类型                      | 说明                     |\",\"3192\":\"| :------------------------ | ----------------------- |\",\"3193\":\"| Promise&lt;[DomainServerConfig](#domainserverconfig18)&gt; | Promise对象，返回获取的域服务器配置。 |\",\"3194\":\"\",\"3195\":\"**错误码：**\",\"3196\":\"\",\"3197\":\"| 错误码ID | 错误信息                     |\",\"3198\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "Promise对象，返回域服务器配置。",
      "注意事项": "修复时应优先保留原文的关键技术动词（如\"获取\"），确保技术动作描述的完整性；需结合上下文区分\"返回\"作为结果状态与前置动作动词的共存合理性，避免过度简化专业表述。"
    },
    {
      "defect_id": 483356,
      "sentence": "系统账号创建是否完整",
      "reference_sentence": "系统账号创建是否完整",
      "line_num": 2987,
      "context": "{\"2982\":\"| createTime<sup>8+</sup>        | number                                                       | 是   | 系统账号创建时间。                  |\",\"2983\":\"| lastLoginTime<sup>8+</sup>     | number                                                       | 是   | 系统账号最后一次登录时间，默认为空。          |\",\"2984\":\"| serialNumber<sup>8+</sup>      | number                                                       | 是   | 系统账号SN码。                      |\",\"2985\":\"| isActived<sup>(deprecated)</sup>         | boolean                                            | 是   | 系统账号激活状态。true表示指定账号处于激活状态；false表示指定账号处于未激活状态。<br>**说明**：从API version 7开始支持，从API version 11开始废弃。                  |\",\"2986\":\"| isActivated<sup>11+</sup>         | boolean                                                   | 是   | 系统账号激是否激活。true表示指定账号已激活；false表示指定账号未激活。                  |\",\"2987\":\"| isCreateCompleted<sup>8+</sup> | boolean                                                      | 是   | 系统账号创建是否完整。true表示指定账号已创建完整；false表示指定账号未创建完整。              |\",\"2988\":\"| distributedInfo                | [distributedAccount.DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是   | 分布式账号信息，默认为空。                    |\",\"2989\":\"| domainInfo<sup>8+</sup>        | [DomainAccountInfo](#domainaccountinfo8)                      | 是   | 域账号信息，默认为空。                        |\",\"2990\":\"\",\"2991\":\"## DomainAccountInfo<sup>8+</sup>\",\"2992\":\"\"}",
      "用户拒绝的修改": "系统账号是否创建完整",
      "注意事项": "修复时应严格保持原文句式结构，优先调整用词而非语序；需结合上下文确认字段命名规律（如\"isCreateCompleted\"对应\"创建是否完整\"），确保修改后的表述与字段语义完全对应。"
    },
    {
      "defect_id": 483402,
      "sentence": "禁止创建新用户",
      "reference_sentence": "禁止删除用户",
      "line_num": 3340,
      "context": "{\"3335\":\"| constraint.vpn.set | 禁止配置VPN |\",\"3336\":\"| constraint.date.time.set | 禁止配置日期时间和时区 |\",\"3337\":\"| constraint.tethering.config | 禁止配置Tethering |\",\"3338\":\"| constraint.network.reset | 禁止重置网络设置 |\",\"3339\":\"| constraint.factory.reset | 禁止出厂设置 |\",\"3340\":\"| constraint.os.account.create | 禁止创建新用户 |\",\"3341\":\"| constraint.add.managed.profile | 禁止添加托管配置文件 |\",\"3342\":\"| constraint.apps.verify.disable | 强制应用程序验证 |\",\"3343\":\"| constraint.cell.broadcasts.set | 禁止配置小区广播 |\",\"3344\":\"| constraint.mobile.networks.set | 禁止配置移动网络 |\",\"3345\":\"| constraint.control.apps | 禁止在设置或启动模块中修改应用程序 |\"}",
      "用户拒绝的修改": "禁止创建新帐户",
      "注意事项": "修复时必须严格对照上下文术语一致性（例如该场景应统一使用\"用户\"而非\"帐户\"），避免机械替换同义词；优先检查参考句式和相邻条目（如3340条原始表述及3345条\"用户\"用法）确保全局表述统一。"
    },
    {
      "defect_id": 483362,
      "sentence": "## DomainAccountInfo<sup>8+</sup>",
      "reference_sentence": "## OsAccountInfo表示系统账号信息。",
      "line_num": 2991,
      "context": "{\"2986\":\"| isActivated<sup>11+</sup>         | boolean                                                   | 是   | 系统账号激是否激活。true表示指定账号已激活；false表示指定账号未激活。                  |\",\"2987\":\"| isCreateCompleted<sup>8+</sup> | boolean                                                      | 是   | 系统账号创建是否完整。true表示指定账号已创建完整；false表示指定账号未创建完整。              |\",\"2988\":\"| distributedInfo                | [distributedAccount.DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是   | 分布式账号信息，默认为空。                    |\",\"2989\":\"| domainInfo<sup>8+</sup>        | [DomainAccountInfo](#domainaccountinfo8)                      | 是   | 域账号信息，默认为空。                        |\",\"2990\":\"\",\"2991\":\"## DomainAccountInfo<sup>8+</sup>\",\"2992\":\"\",\"2993\":\"表示域账号信息。\",\"2994\":\"\",\"2995\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2996\":\"\"}",
      "用户拒绝的修改": "## DomainAccountInfo<sup>8+</sup>表示域账号信息。",
      "注意事项": "保持标题层级简洁性（仅保留名称和版本标记），详细说明应置于标题下方段落；严格区分不同术语体系（如\"域账号\"和\"系统账号\"），避免跨概念混用解释。"
    },
    {
      "defect_id": 484146,
      "sentence": "获取拖拽相关数据的简介，延迟拖拽调用此接口，简介中只能获取数据类型。",
      "reference_sentence": "获取拖拽相关数据。",
      "line_num": 315,
      "context": "{\"310\":\"\",\"311\":\"### getSummary<sup>10+</sup>\",\"312\":\"\",\"313\":\"getSummary(): Summary\",\"314\":\"\",\"315\":\"获取拖拽相关数据的简介，延迟拖拽调用此接口，简介中只能获取数据类型。\",\"316\":\"\",\"317\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"318\":\"\",\"319\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"320\":\"\"}",
      "用户拒绝的修改": "获取拖拽相关数据的简要信息，延迟拖拽时调用此接口，简要信息中只能获取数据类型。",
      "注意事项": "修复时应严格保持原文核心术语的一致性，避免替换已有明确指代功能的词汇（如\"简介\"），需结合上下文确认术语使用场景，优先采用参考句中的标准化表述（如\"相关数据\"）确保全文档概念统一。"
    },
    {
      "defect_id": 483936,
      "sentence": "获取拖拽相关数据的简介，延迟拖拽调用此接口简介中只能获取数据类型。",
      "reference_sentence": "getData(): UnifiedData获取拖拽相关数据。",
      "line_num": 315,
      "context": "{\"310\":\"\",\"311\":\"### getSummary<sup>10+</sup>\",\"312\":\"\",\"313\":\"getSummary(): Summary\",\"314\":\"\",\"315\":\"获取拖拽相关数据的简介，延迟拖拽调用此接口简介中只能获取数据类型。\",\"316\":\"\",\"317\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"318\":\"\",\"319\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"320\":\"\"}",
      "用户拒绝的修改": "获取拖拽相关数据的简介，延迟拖拽调用此接口只能获取数据类型。",
      "注意事项": "修复时应严格保持术语一致性（如\"简介\"与\"数据\"的区分），同时确保句式结构统一，优先参考上下文已有规范表达（如\"getData(): UnifiedData获取拖拽相关数据\"的动宾结构）。"
    },
    {
      "defect_id": 483403,
      "sentence": "禁止托管配置文件与主用户进行统一锁屏质询",
      "reference_sentence": "禁止删除此用户的托管配置文件",
      "line_num": 3368,
      "context": "{\"3363\":\"| constraint.data.roam | 禁止漫游通话时使用蜂窝数据 |\",\"3364\":\"| constraint.os.account.set.icon | 禁止修改用户头像 |\",\"3365\":\"| constraint.wallpaper.set | 禁止设置壁纸 |\",\"3366\":\"| constraint.oem.unlock | 禁止启用oem解锁 |\",\"3367\":\"| constraint.device.unmute | 禁止取消设备静音 |\",\"3368\":\"| constraint.password.unified | 禁止托管配置文件与主用户进行统一锁屏质询 |\",\"3369\":\"| constraint.autofill | 禁止使用自动填充服务 |\",\"3370\":\"| constraint.content.capture | 禁止捕获用户屏幕 |\",\"3371\":\"| constraint.content.suggestions | 禁止接收内容建议 |\",\"3372\":\"| constraint.os.account.activate | 禁止前台启动用户 |\",\"3373\":\"| constraint.location.set | 禁止配置位置服务 |\"}",
      "用户拒绝的修改": "禁止托管配置文件与主帐户进行统一锁屏质询",
      "注意事项": "修复时必须严格遵循上下文术语一致性（如\"用户\"vs\"帐户\"），避免将技术文档中的专有名词替换为同义词，所有修改需基于相邻条目和参考句子的用词模式进行验证。"
    },
    {
      "defect_id": 485375,
      "sentence": "播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。",
      "reference_sentence": "播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的样本进行解码和播放。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"**适用场景**：\",\"10\":\"\",\"11\":\"- 播放\",\"12\":\"  \",\"13\":\"  播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。\",\"14\":\"\",\"15\":\"- 音视频编辑\",\"16\":\"  \",\"17\":\"  编辑媒体文件时，需要先对媒体流进行解封装，获取到指定sample进行编辑。\",\"18\":\"\"}",
      "用户拒绝的修改": "播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的样本进行解码和播放。",
      "注意事项": "在统一术语前需优先确认上下文是否存在合理的术语混用惯例，技术文档中若存在行业通用英文术语(如\"sample\")应保留原文表述，避免过度汉化破坏专业语境一致性。"
    },
    {
      "defect_id": 483377,
      "sentence": "Promise对象，返回目标账号的域服务器配置。",
      "reference_sentence": "Promise对象，返回域服务器配置。",
      "line_num": 3288,
      "context": "{\"3283\":\"\",\"3284\":\"**返回值：**\",\"3285\":\"\",\"3286\":\"| 类型                      | 说明                     |\",\"3287\":\"| :------------------------ | ----------------------- |\",\"3288\":\"| Promise&lt;[DomainServerConfig](#domainserverconfig18)&gt; | Promise对象，返回目标账号的域服务器配置。 |\",\"3289\":\"\",\"3290\":\"**错误码：**\",\"3291\":\"\",\"3292\":\"| 错误码ID | 错误信息                     |\",\"3293\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "Promise对象，返回目标域账号的域服务器配置。",
      "注意事项": "在确保术语一致性时，需优先验证上下文是否存在明确关联性，避免机械添加重复字段破坏原有语义逻辑；若原文术语独立且无歧义，应尊重原始表述而非强行统一。"
    },
    {
      "defect_id": 485377,
      "sentence": "上述'sample'字样仅为示例，此处由开发者根据实际工程目录自定义。",
      "reference_sentence": "上述'样本'字样仅为示例，此处由开发者根据实际工程目录自定义。",
      "line_num": 44,
      "context": "{\"39\":\"target_link_libraries(sample PUBLIC libnative_media_core.so)\",\"40\":\"```\",\"41\":\"\",\"42\":\"> **说明：**\",\"43\":\">\",\"44\":\"> 上述'sample'字样仅为示例，此处由开发者根据实际工程目录自定义。\",\"45\":\">\",\"46\":\"\",\"47\":\"### 开发步骤\",\"48\":\"\",\"49\":\"1. 添加头文件。\"}",
      "用户拒绝的修改": "上述'样本'字样仅为示例，此处由开发者根据实际工程目录自定义。",
      "注意事项": "修复术语一致性时需严格区分代码标识符与自然语言描述场景，若术语在代码示例中作为固定标识符出现（如'sample'），应保持原词不变；若在普通文本中混用中英文表述（如\"样本\"/\"sample\"），才需统一为单一表达形式。"
    },
    {
      "defect_id": 483376,
      "sentence": "Promise对象，返回获取的所有域服务器配置。",
      "reference_sentence": "Promise对象，返回域服务器配置。",
      "line_num": 3238,
      "context": "{\"3233\":\"\",\"3234\":\"**返回值：**\",\"3235\":\"\",\"3236\":\"| 类型                      | 说明                     |\",\"3237\":\"| :------------------------ | ----------------------- |\",\"3238\":\"| Promise&lt;Array&lt;[DomainServerConfig](#domainserverconfig18)&gt;&gt; | Promise对象，返回获取的所有域服务器配置。 |\",\"3239\":\"\",\"3240\":\"**错误码：**\",\"3241\":\"\",\"3242\":\"| 错误码ID | 错误信息                     |\",\"3243\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "Promise对象，返回所有域服务器配置。",
      "注意事项": "在保持动词一致性的同时必须优先保留技术文档中的核心动作描述术语，若\"获取\"属于明确的操作步骤则不应删除，需通过调整句式结构而非删减关键动词来达成表达一致性。"
    },
    {
      "defect_id": 491230,
      "sentence": "如果两个线程都需要访问该对象，只能采用拷贝方式。反之，建议采用转移方式，以获得更高的传输效率，从而提升性能。",
      "reference_sentence": "如果两个线程都需要访问该对象，只能采用拷贝方式。反之，建议采用转移方式，以获得更高的传输效率，从而提升性能。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"Native内存采用转移方式，传输后原线程将无法使用此ArrayBuffer对象。跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。通信过程如下图所示：\",\"10\":\"\",\"11\":\"![transfer](figures/transfer.png)\",\"12\":\"\",\"13\":\"ArrayBuffer可以用来表示图片等资源，在应用开发中，处理图片（如调整亮度、饱和度、大小等）往往比较耗时，为了避免长时间阻塞UI主线程，可以将图片传递到子线程中进行处理。采用转移方式传递ArrayBuffer传输性能更高，但原线程无法再访问ArrayBuffer对象。如果两个线程都需要访问该对象，只能采用拷贝方式。反之，建议采用转移方式，以获得更高的传输效率，从而提升性能。\",\"14\":\"\",\"15\":\"以下将通过案例分别介绍拷贝和转移两种方式，实现图片跨ArkTS线程传输。\",\"16\":\"\",\"17\":\"## ArrayBuffer拷贝传输方式\",\"18\":\"\"}",
      "用户拒绝的修改": "如果两个线程都需要访问该对象，采用拷贝方式。反之，采用转移方式，以提高传输效率，提升性能。",
      "注意事项": "修复时应优先保留原文的关键限定词（如\"只能\"\"建议\"）和逻辑层次（如\"从而\"），避免过度简化破坏技术准确性；技术文档的清晰性高于句式统一，应通过添加衔接词而非删除信息来实现表达优化。"
    },
    {
      "defect_id": 491026,
      "sentence": "命令行参数传入的路径中不能包含空格，例如，SDK 路径不能为 `\\DevEco Studio\\sdk`。",
      "reference_sentence": "命令行参数传入的路径中不能包含空格，例如，SDK 路径不能为 `\\DevEco Studio\\sdk`。",
      "line_num": 35,
      "context": "{\"30\":\"| --project-folder           | 扫描文件夹路径，如扫描单个文件不需要加此参数，将单个文件路径加在命令行最后即可。 |\",\"31\":\"| --homecheck                |增加对编译期无法检查的运行时错误的排查。|\",\"32\":\"\",\"33\":\"**注意事项：**\",\"34\":\"\",\"35\":\"1.命令行参数传入的路径中不能包含空格，例如，SDK 路径不能为 `\\\\DevEco Studio\\\\sdk`。\",\"36\":\"\",\"37\":\"2.推荐先基于ArkTS1.1编译工程。否则，可能会缺失工程的模块间依赖，导致部分规则漏扫或误扫。\",\"38\":\"\",\"39\":\"设备要求： 建议使用32GB及以上Windows环境扫描。在扫描过程中发生了out of memory的错误，可以为node添加参数\\\"--max-old-space-size=8192\\\"，可以解决部分场景问题.\",\"40\":\"\"}",
      "用户拒绝的修改": "命令行参数传入的路径中不能包含空格，例如，命令路径不能为 `\\DevEco Studio\\sdk`。",
      "注意事项": "修改术语时必须严格检查上下文关联性，确保示例中的术语与主句核心概念完全匹配（如\"SDK路径\"与\"命令行参数\"的逻辑关联），同时维护全文档术语树状结构的一致性，避免孤立替换造成概念断层。"
    },
    {
      "defect_id": 489635,
      "sentence": "连接设备。当前版本不支持在非root权限的设备上使用此调试工具，仅支持在[模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-emulator)中调用。具备root权限的命令提示符为#，非root权限的命令提示符为$。",
      "reference_sentence": "开发者在使用本工具前需开启开发者模式，且需要获取HDC工具，执行HDC shell。",
      "line_num": 10,
      "context": "{\"5\":\"本调试工具基于HDC命令实现对SQLite数据库的操作，提供一种通过命令行接口高效管理SQLite数据库的方式，适用于开发、调试和运维阶段对数据库的快速操作与验证。\",\"6\":\"\",\"7\":\"## 环境要求\",\"8\":\"\",\"9\":\"- 开发者在使用本工具前需开启开发者模式，且需要获取HDC工具，执行HDC shell。\",\"10\":\"- 连接设备。当前版本不支持在非root权限的设备上使用此调试工具，仅支持在[模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-emulator)中调用。具备root权限的命令提示符为#，非root权限的命令提示符为$。\",\"11\":\"\",\"12\":\"## 操作准备\",\"13\":\"\",\"14\":\"在使用SQLite之前需先切换至具备读写权限的目录。\",\"15\":\"\"}",
      "用户拒绝的修改": "启动设备。当前版本不支持在非root权限的设备上使用此调试工具，仅支持在[模拟器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-run-emulator)中调用。root权限的命令提示符为#，非root权限的命令提示符为$。",
      "注意事项": "保持核心操作术语（如\"连接设备\"）和关键要求（如\"模拟器调用\"）的表述一致性，避免在修复过程中弱化或遗漏用户强调的限定条件（如权限说明、环境限制等关键信息）。"
    },
    {
      "defect_id": 485379,
      "sentence": "获取轨道index及信息（可选，若用户已知轨道信息，可跳过此步）。",
      "reference_sentence": "获取轨道索引及信息（可选，若用户已知轨道信息，可跳过此步）。",
      "line_num": 218,
      "context": "{\"213\":\"      return;\",\"214\":\"   }\",\"215\":\"   OH_AVFormat_Destroy(sourceFormat);\",\"216\":\"   ```\",\"217\":\"\",\"218\":\"6. 获取轨道index及信息（可选，若用户已知轨道信息，可跳过此步）。\",\"219\":\"\",\"220\":\"   ```c++\",\"221\":\"   uint32_t audioTrackIndex = 0;\",\"222\":\"   uint32_t videoTrackIndex = 0;\",\"223\":\"   int32_t w = 0;\"}",
      "用户拒绝的修改": "获取轨道索引及信息（可选，若用户已知轨道信息，可跳过此步）。",
      "注意事项": "修复时应优先保持与代码变量命名的一致性（如\"TrackIndex\"对应\"index\"），在技术文档中若英文术语直接用于代码上下文，应保留原词而非强制翻译。"
    },
    {
      "defect_id": 488974,
      "sentence": "NodeContianer接口绑定NodeController，实现动态组件页面显示。",
      "reference_sentence": "NodeContainer接口绑定NodeController，实现动态组件页面显示。",
      "line_num": 1432,
      "context": "{\"1427\":\"    struct Index {\",\"1428\":\"      build() {\",\"1429\":\"        Row() {\",\"1430\":\"          Column() {\",\"1431\":\"            // NodeContainer用于与NodeController节点绑定，rebuild会触发makeNode。\",\"1432\":\"            // Page页通过NodeContainer接口绑定NodeController，实现动态组件页面显示。\",\"1433\":\"            NodeContainer(getNWeb(\\\"https://www.example.com\\\"))\",\"1434\":\"              .height(\\\"90%\\\")\",\"1435\":\"              .width(\\\"100%\\\")\",\"1436\":\"          }\",\"1437\":\"          .width('100%')\"}",
      "用户拒绝的修改": "NodeContainer接口绑定NodeController，实现动态组件页面显示。",
      "注意事项": "修复时必须严格校验术语拼写一致性（如\"NodeContianer\"与\"NodeContainer\"的字母顺序差异），并通过注释/标记明确标注修正点，避免用户误判为无意义拷贝。"
    },
    {
      "defect_id": 488973,
      "sentence": "NodeContianer上的节点的行为，需要与NodeContainer一起使用。",
      "reference_sentence": "用于控制和反馈对应的NodeContianer上的节点的行为，需要与NodeContainer一起使用。",
      "line_num": 1359,
      "context": "{\"1354\":\"          .width(\\\"100%\\\")\",\"1355\":\"          .height(\\\"100%\\\")\",\"1356\":\"      }\",\"1357\":\"    }\",\"1358\":\"    let wrap = wrapBuilder<Data[]>(WebBuilder);\",\"1359\":\"    // 用于控制和反馈对应的NodeContianer上的节点的行为，需要与NodeContainer一起使用。\",\"1360\":\"    export class myNodeController extends NodeController {\",\"1361\":\"      private rootnode: BuilderNode<Data[]> | null = null;\",\"1362\":\"      // 必须要重写的方法，用于构建节点数、返回节点挂载在对应NodeContianer中。\",\"1363\":\"      // 在对应NodeContianer创建的时候调用、或者通过rebuild方法调用刷新。\",\"1364\":\"      makeNode(uiContext: UIContext): FrameNode | null {\"}",
      "用户拒绝的修改": "用于控制和反馈对应的NodeContainer上的节点的行为，需要与NodeController一起使用。",
      "注意事项": "修复时必须严格校验术语拼写一致性（如NodeContianer/NodeContainer的拼写差异），避免在修正概念混用时引入新术语（如NodeController）导致二次概念冲突，建议通过全局匹配确保上下文拼写统一。"
    },
    {
      "defect_id": 488718,
      "sentence": "const urisToUnWatch: string[] =",
      "reference_sentence": "const urisToWatch: string[] =",
      "line_num": 245,
      "context": "{\"240\":\"| 15700000 | Inner error. Possible causes: The service is not ready or is being restarted abnormally.|\",\"241\":\"\",\"242\":\"**示例：**\",\"243\":\"\",\"244\":\"```ts\",\"245\":\"const urisToUnWatch: string[] =\",\"246\":\"  ['datashareproxy://com.example.app1/config1', 'datashareproxy://com.example.app1/config2',];\",\"247\":\"const config: dataShare.DataProxyConfig = {\",\"248\":\"  type: dataShare.DataProxyType.SHARED_CONFIG,\",\"249\":\"};\",\"250\":\"const callback = (err: BusinessError<void>, changes: dataShare.DataProxyChangeInfo[]): void => {\"}",
      "用户拒绝的修改": "const urisToWatch: string[] =",
      "注意事项": "在修复术语一致性前，需结合上下文确认变量是否用于区分对立操作（如Watch/UnWatch），优先保留功能性语义差异，避免因过度统一破坏代码逻辑清晰度。"
    },
    {
      "defect_id": 488716,
      "sentence": "import { dataShare } from '@kit.ArkData';",
      "reference_sentence": "import { dataShare } from '@ohos.data.dataShare';",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"\",\"12\":\"## 导入模块\",\"13\":\"\",\"14\":\"```ts\",\"15\":\"import { dataShare } from '@kit.ArkData';\",\"16\":\"```\",\"17\":\"\",\"18\":\"\",\"19\":\"## dataShare.createDataProxyHandle<sup>20+</sup>\",\"20\":\"\"}",
      "用户拒绝的修改": "import { dataShare } from '@ohos.data.dataShare';",
      "注意事项": "修复时应严格遵循上下文中的现有模块引用规范，优先验证项目或文档内实际使用的官方命名约定，避免仅依赖外部参考直接替换；若存在多种合法形式需明确区分系统接口与SDK别名，确保修改后与上下文的代码风格及依赖声明完全一致。"
    },
    {
      "defect_id": 487281,
      "sentence": "未设置或设置为undefined时，百分比依据窗口大小计算。若设置为AvailableLayoutArea.SAFE_AREA，预览图的可布局区域为窗口大小减去上下左右的安全边距。",
      "reference_sentence": "未设置或设置undefined按照PreviewScaleMode.AUTO处理。当设置成PreviewScaleMode.CONSTANT时，如果预览图过大，剩余的空间不足以放置菜单时，菜单将重叠显示在预览图之下。",
      "line_num": 186,
      "context": "{\"181\":\"| onWillAppear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单显示动效前的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br/>2.aboutToAppear是初始化时触发调用，onWillAppear是在动画执行前触发调用，onWillAppear在aboutToAppear之后执行。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"182\":\"| onDidAppear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单弹出时的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br />2.快速点击弹出，消失菜单时，存在onWillDisappear在onDidAppear前生效。<br />3. 当菜单入场动效未完成时关闭菜单，该回调不会触发。<br/>4.onAppear和onDidAppear触发时机相同，onDidAppear在onAppear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"183\":\"| onWillDisappear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单退出动效前的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br />2.快速点击弹出，消失菜单时，存在onWillDisappear在onDidAppear前生效。<br/>3.aboutToDisappear和onWillDisappear触发时机相同，onWillDisappear在aboutToDisappear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"184\":\"| onDidDisappear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单消失时的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br/>2.onDisappear和onDidDisappear触发时机相同，onDidDisappear在onDisappear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"185\":\"| previewScaleMode<sup>20+</sup> | [PreviewScaleMode](#previewscalemode20类型说明) | 否 | 预览图缩放方式。<br />默认值：PreviewScaleMode.AUTO<br />**说明：**<br />布局空间不足时，控制预览图的缩放方式。未设置或设置undefined按照PreviewScaleMode.AUTO处理。当设置成PreviewScaleMode.CONSTANT时，如果预览图过大，剩余的空间不足以放置菜单时，菜单将重叠显示在预览图之下。<br />预览图的最大宽高不会超过预览图最大可布局区域（窗口大小减去上下左右的安全边距）。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"186\":\"| availableLayoutArea<sup>20+</sup> | [AvailableLayoutArea](#availablelayoutarea20类型说明) | 否 | 设置预览图宽高的可布局区域，预览图的百分比依据此设置计算，最终可能因安全区限制而被压缩或裁剪。<br /> **说明：** <br />未设置或设置为undefined时，百分比依据窗口大小计算。若设置为AvailableLayoutArea.SAFE_AREA，预览图的可布局区域为窗口大小减去上下左右的安全边距。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"187\":\"\",\"188\":\"## MenuPreviewMode<sup>11+</sup>\",\"189\":\"\",\"190\":\"菜单的预览样式。\",\"191\":\"\"}",
      "用户拒绝的修改": "未设置或设置undefined时，百分比依据窗口大小计算。若设置为AvailableLayoutArea.SAFE_AREA，预览图的可布局区域为预览图最大可布局区域（窗口大小减去上下左右的安全边距）。",
      "注意事项": "保持动词与宾语搭配的一致性（如统一使用\"设置undefined\"而非混用\"设置为undefined\"），确保术语与解释的严格对应（若已定义\"预览图最大可布局区域\"则直接引用该术语，避免重复括号解释）。"
    },
    {
      "defect_id": 491227,
      "sentence": "跨线程传递时，JS对象壳需要经过序列化与反序列化拷贝传递，Native内存区域则有两种传递方式：拷贝和转移。",
      "reference_sentence": "跨线程传递时，JS对象壳需要经过序列化与反序列化拷贝传递，Native内存区域则有两种传递方式：拷贝和转移。",
      "line_num": 3,
      "context": "{\"1\":\"# ArrayBuffer对象\",\"2\":\"\",\"3\":\"ArrayBuffer由两部分组成：底层存储数据的Native内存区域，以及封装操作的JS对象壳，该JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传递时，JS对象壳需要经过序列化与反序列化拷贝传递，Native内存区域则有两种传递方式：拷贝和转移。\",\"4\":\"\",\"5\":\"Native内存采用拷贝方式（递归遍历），传输后两个线程可以独立访问ArrayBuffer。这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，传输效率较低。通信过程如下图所示：\",\"6\":\"\",\"7\":\"![copy_transfer](figures/copy_transfer.png)\",\"8\":\"\"}",
      "用户拒绝的修改": "跨线程传递时，对JS对象壳进行序列化与反序列化拷贝传递，Native内存区域则有两种传递方式：拷贝和转移。",
      "注意事项": "修复时需优先保持自然语感，仅在句式差异显著影响理解时进行调整；技术文档允许主被动句式混合使用，避免机械统一破坏专业表述的流畅性。"
    },
    {
      "defect_id": 491229,
      "sentence": "跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。",
      "reference_sentence": "跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"Native内存采用拷贝方式（递归遍历），传输后两个线程可以独立访问ArrayBuffer。这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，传输效率较低。通信过程如下图所示：\",\"6\":\"\",\"7\":\"![copy_transfer](figures/copy_transfer.png)\",\"8\":\"\",\"9\":\"Native内存采用转移方式，传输后原线程将无法使用此ArrayBuffer对象。跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。通信过程如下图所示：\",\"10\":\"\",\"11\":\"![transfer](figures/transfer.png)\",\"12\":\"\",\"13\":\"ArrayBuffer可以用来表示图片等资源，在应用开发中，处理图片（如调整亮度、饱和度、大小等）往往比较耗时，为了避免长时间阻塞UI主线程，可以将图片传递到子线程中进行处理。采用转移方式传递ArrayBuffer传输性能更高，但原线程无法再访问ArrayBuffer对象。如果两个线程都需要访问该对象，只能采用拷贝方式。反之，建议采用转移方式，以获得更高的传输效率，从而提升性能。\",\"14\":\"\"}",
      "用户拒绝的修改": "跨线程时，只需重建JS壳，Native内存无需拷贝，提高传输效率。",
      "注意事项": "修复时应优先保留原文的关键术语（如\"效率更高\"）和上下文对比结构，避免机械统一句式导致技术信息弱化或理解成本增加；在技术文档中，信息准确性和读者认知惯性优先级高于句式一致性要求。"
    },
    {
      "defect_id": 491228,
      "sentence": "这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，传输效率较低。",
      "reference_sentence": "这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，传输效率较低。",
      "line_num": 5,
      "context": "{\"1\":\"# ArrayBuffer对象\",\"2\":\"\",\"3\":\"ArrayBuffer由两部分组成：底层存储数据的Native内存区域，以及封装操作的JS对象壳，该JS对象壳被分配在虚拟机本地堆（LocalHeap）。跨线程传递时，JS对象壳需要经过序列化与反序列化拷贝传递，Native内存区域则有两种传递方式：拷贝和转移。\",\"4\":\"\",\"5\":\"Native内存采用拷贝方式（递归遍历），传输后两个线程可以独立访问ArrayBuffer。这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，传输效率较低。通信过程如下图所示：\",\"6\":\"\",\"7\":\"![copy_transfer](figures/copy_transfer.png)\",\"8\":\"\",\"9\":\"Native内存采用转移方式，传输后原线程将无法使用此ArrayBuffer对象。跨线程时只需重建JS壳，Native内存无需拷贝，效率更高。通信过程如下图所示：\",\"10\":\"\"}",
      "用户拒绝的修改": "这种传输方式不仅需要重建JS壳，还需要拷贝Native内存，降低传输效率。",
      "注意事项": "修复时应优先保持句子自然流畅性，避免机械追求句式统一；需结合上下文语境判断表达习惯（如技术文档常用描述性语句而非祈使句），确保修改后的表述与原文风格一致。"
    },
    {
      "defect_id": 487295,
      "sentence": "取消投播设备连接状态的监听。",
      "reference_sentence": "投播设备连接状态的回调函数。",
      "line_num": 2198,
      "context": "{\"2193\":\"\",\"2194\":\"## avSession.off('deviceStateChanged')<sup>20+</sup>\",\"2195\":\"\",\"2196\":\"off(type: 'deviceStateChanged', callback?: Callback\\\\<DeviceState>): void\",\"2197\":\"\",\"2198\":\"取消投播设备连接状态的监听。\",\"2199\":\"\",\"2200\":\"**系统能力：** SystemCapability.Multimedia.AVSession.AVCast\",\"2201\":\"\",\"2202\":\"**系统接口：** 该接口为系统接口。\",\"2203\":\"\"}",
      "用户拒绝的修改": "取消投播设备连接状态的回调。",
      "注意事项": "修复时应优先检查上下文中的参数命名和已有术语（如\"callback\"），确保修改后的词汇与代码中的实际变量名及参考句子的表述严格一致，避免脱离技术语境强行替换近义词。"
    },
    {
      "defect_id": 488717,
      "sentence": "}). catch((err: BusinessError) => {",
      "reference_sentence": "}).catch((err: BusinessError) => {",
      "line_num": 50,
      "context": "{\"45\":\"\",\"46\":\"export default class EntryAbility extends UIAbility {\",\"47\":\"  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\",\"48\":\"    dataShare.createDataProxyHandle().then((dataProxyHandle) => {\",\"49\":\"      console.info(\\\"createDataProxyHandle succeed\\\");\",\"50\":\"    }). catch((err: BusinessError) => {\",\"51\":\"      console.error(`createDataProxyHandle error: code: ${err.code}, message: ${err.message}`);\",\"52\":\"    });\",\"53\":\"  };\",\"54\":\"};\",\"55\":\"```\"}",
      "用户拒绝的修改": "}).catch((err: BusinessError) => {",
      "注意事项": "修复代码格式时应严格检查空格和符号位置，确保链式调用符（如`.catch`）与前导括号紧密连接；需同步验证同类结构（如Promise链的then/catch）整体风格统一性，避免局部修正引发新格式断层。"
    },
    {
      "defect_id": 491231,
      "sentence": "在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。",
      "reference_sentence": "在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"以下将通过案例分别介绍拷贝和转移两种方式，实现图片跨ArkTS线程传输。\",\"16\":\"\",\"17\":\"## ArrayBuffer拷贝传输方式\",\"18\":\"\",\"19\":\"在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。\",\"20\":\"\",\"21\":\"首先，实现一个处理ArrayBuffer的接口，该接口在Task中执行。\",\"22\":\"\",\"23\":\"然后，通过拷贝方式将ArrayBuffer数据传递到Task中，并处理。\",\"24\":\"\"}",
      "用户拒绝的修改": "在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式。通过调用setTransferList()接口，指定部分数据的传递方式为转移方式，其他部分数据切换为拷贝方式。",
      "注意事项": "修复时应优先保留原句的情态动词（如\"可以\"）确保操作可选性不被弱化，同时保持复合句结构以维护信息连贯性，避免因过度统一句式破坏技术说明的准确性。"
    },
    {
      "defect_id": 491055,
      "sentence": "1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。",
      "reference_sentence": "1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。",
      "line_num": 143,
      "context": "{\"138\":\"\",\"139\":\"#### 配置开发环境\",\"140\":\"\",\"141\":\"接下来介绍第一次启动DevEco Studio的配置向导：\",\"142\":\"\",\"143\":\"1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。\",\"144\":\"\",\"145\":\"2. 进入DevEco Studio操作向导页面，修改**npm registry**，DevEco Studio已预置对应的仓（默认的npm仓，可能出现部分开发者无法访问或访问速度缓慢的情况），直接单击**Start using DevEco Studio**进入下一步。\",\"146\":\"\",\"147\":\"   \",\"148\":\"\"}",
      "用户拒绝的修改": "1. 运行已安装的DevEco Studio，首次使用，请单击**Do not import settings**，单击**OK**。",
      "注意事项": "保持操作动词一致性时需先区分界面元素类型（单选/按钮），确保\"选择\"用于选项、\"单击\"用于按钮，并参考上下文其他步骤的用词规范。"
    },
    {
      "defect_id": 491232,
      "sentence": "原线程将无法再使用已传输给子线程的ArrayBuffer。",
      "reference_sentence": "原线程将无法再使用已传输给子线程的ArrayBuffer。",
      "line_num": 89,
      "context": "{\"84\":\"}\",\"85\":\"```\",\"86\":\"\",\"87\":\"## ArrayBuffer转移传输方式\",\"88\":\"\",\"89\":\"在TaskPool中，传递ArrayBuffer数据时默认使用转移方式，原线程将无法再使用已传输给子线程的ArrayBuffer。在上文示例的基础上去除task.setTransferList接口调用，即在createImageTask的第二个参数传入true，就可以实现转移方式的传输。\"}",
      "用户拒绝的修改": "原线程无法再使用已传输给子线程的ArrayBuffer。",
      "注意事项": "修复时需优先保留原句核心语义和时态准确性，避免过度追求句式统一而牺牲技术文档的清晰性；严格区分陈述句与祈使句的语法特征，仅在上下文明确要求指令性表达时调整句式。"
    },
    {
      "defect_id": 491234,
      "sentence": "在非UI线程中操作不符合要求的节点时，接口调用不生效。",
      "reference_sentence": "基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。  | 支持 | 支持在任意线程调用。",
      "line_num": 10,
      "context": "{\"5\":\"## 组件创建销毁\",\"6\":\"\",\"7\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"8\":\"| -------- | ------- | ------- | ------- |  \",\"9\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [createNode](#createnode) )([ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype) type) | 基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。  | 支持 | 支持在任意线程调用。 |\",\"10\":\"| void(\\\\* [disposeNode](#disposenode) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 销毁节点指针指向的节点对象。  | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用不生效。 |\",\"11\":\"\",\"12\":\"## 组件属性读写\",\"13\":\"\",\"14\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"15\":\"| -------- | ------- | ------- | ------- |  \"}",
      "用户拒绝的修改": "在非UI线程中操作不符合要求的节点时，接口返回错误码。",
      "注意事项": "修复时应严格遵循文档中已明确定义的术语和表达习惯，避免将技术概念（如\"调用不生效\"的行为描述）与实现机制（如\"返回错误码\"的底层逻辑）混用，需通过交叉验证上下文确保语义与相邻接口描述保持平行。"
    },
    {
      "defect_id": 491635,
      "sentence": "ArrayList和[LinkedList](js-apis-linkedlist.md)相比，ArrayList的随机访问效率更高。但由于ArrayList的增删操作可能会影响数组内其他元素的移动，LinkedList的增加和删除操作效率更高。",
      "reference_sentence": "ArrayList和[Vector](js-apis-vector.md)相似，都是基于数组实现。它们都可以动态调整容量，但Vector每次扩容增加1倍。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"ArrayList是一种线性数据结构，底层基于数组实现。ArrayList会根据实际需要动态调整容量，每次扩容增加50%。\",\"4\":\"\",\"5\":\"ArrayList和[Vector](js-apis-vector.md)相似，都是基于数组实现。它们都可以动态调整容量，但Vector每次扩容增加1倍。\",\"6\":\"\",\"7\":\"ArrayList和[LinkedList](js-apis-linkedlist.md)相比，ArrayList的随机访问效率更高。但由于ArrayList的增删操作可能会影响数组内其他元素的移动，LinkedList的增加和删除操作效率更高。\",\"8\":\"\",\"9\":\"**推荐使用场景：** 当需要频繁读取集合中的元素时，推荐使用ArrayList。\",\"10\":\"\",\"11\":\"文档中使用了泛型，涉及以下泛型标记符：\",\"12\":\"- T：Type，类\"}",
      "用户拒绝的修改": "ArrayList和[LinkedList](js-apis-linkedlist.md)相比，ArrayList的随机访问效率更高。但由于ArrayList的增删操作可能会影响数组内其他元素的移动，LinkedList的增删操作效率更高。",
      "注意事项": "修复术语一致性时需优先确认上下文表达习惯，若原句使用完整动词（如\"增加和删除操作\"）增强技术细节明确性，应保留原表述而非强制统一为缩略形式。"
    },
    {
      "defect_id": 485378,
      "sentence": "获取文件轨道数（可选，若用户已知轨道信息，可跳过此步）。",
      "reference_sentence": "获取文件轨道数量（可选，若用户已知轨道信息，可跳过此步）。",
      "line_num": 203,
      "context": "{\"198\":\"      printf(\\\"get custom metadata from custom metadata format failed\\\");\",\"199\":\"      return;\",\"200\":\"   }\",\"201\":\"   OH_AVFormat_Destroy(customMetadataFormat);\",\"202\":\"\",\"203\":\"   // 获取文件轨道数（可选，若用户已知轨道信息，可跳过此步）。\",\"204\":\"   // 从文件 source 信息获取文件轨道数，用户可通过该接口获取文件级别属性，具体支持信息参考附表 1。\",\"205\":\"   OH_AVFormat *sourceFormat = OH_AVSource_GetSourceFormat(source);\",\"206\":\"   if (sourceFormat == nullptr) {\",\"207\":\"      printf(\\\"get source format failed\\\");\",\"208\":\"      return;\"}",
      "用户拒绝的修改": "获取文件轨道数量（可选，若用户已知轨道信息，可跳过此步）。",
      "注意事项": "优先保留原文中已确立的专业术语或固定表达，仅在上下文存在明确不一致时才进行修改；修改前需核查技术文档中相关术语的统一性，避免将合理变体误判为不一致。"
    },
    {
      "defect_id": 491053,
      "sentence": "1、进入网址后，点击**立即下载**，如下图所示：",
      "reference_sentence": "1、进入网址后，单击**立即下载**，如下图所示：",
      "line_num": 119,
      "context": "{\"114\":\"\",\"115\":\"#### **DevEco Studio下载安装**\",\"116\":\"\",\"117\":\"从以下网址下载DevEco Studio：https://developer.huawei.com/consumer/cn/deveco-studio/\",\"118\":\"\",\"119\":\"1、进入网址后，点击**立即下载**，如下图所示：\",\"120\":\"\",\"121\":\"![mig2](figures/mig2.png) \",\"122\":\"\",\"123\":\"2、建议选择`release`版本，版本号不作要求；建议在32GB及以上内存的Windows环境中使用。\",\"124\":\"\"}",
      "用户拒绝的修改": "1、进入网址后，单击**立即下载**，如下图所示：",
      "注意事项": "修复时应全面检查上下文及用户提供的参考句子，确保术语统一（如“点击”或“单击”），避免仅依赖局部修改导致前后矛盾；优先沿用文档已有高频词汇，若参考句子明确用词则严格对齐。"
    },
    {
      "defect_id": 491233,
      "sentence": "销毁节点指针指向的节点对象。",
      "reference_sentence": "基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。",
      "line_num": 10,
      "context": "{\"5\":\"## 组件创建销毁\",\"6\":\"\",\"7\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"8\":\"| -------- | ------- | ------- | ------- |  \",\"9\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [createNode](#createnode) )([ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype) type) | 基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。  | 支持 | 支持在任意线程调用。 |\",\"10\":\"| void(\\\\* [disposeNode](#disposenode) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 销毁节点指针指向的节点对象。  | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用不生效。 |\",\"11\":\"\",\"12\":\"## 组件属性读写\",\"13\":\"\",\"14\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"15\":\"| -------- | ------- | ------- | ------- |  \"}",
      "用户拒绝的修改": "删除节点指针指向的节点对象。",
      "注意事项": "修复时应严格保持技术术语与接口名称的一致性（如\"disposeNode\"对应\"销毁\"），避免将技术文档中的固定动词替换为近义词，需结合上下文验证术语使用的准确性。"
    },
    {
      "defect_id": 491299,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程中操作不符合要求的节点时，接口返回错误码。",
      "line_num": 174,
      "context": "{\"169\":\"\",\"170\":\"该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。\",\"171\":\"\",\"172\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"173\":\"\",\"174\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"175\":\"\",\"176\":\"**参数:**\",\"177\":\"\",\"178\":\"| 名称 | 描述 | \",\"179\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程中操作已挂载到UI树上的节点时，接口返回错误码。",
      "注意事项": "修复术语一致性时需优先检查问题句子的邻近上下文，确认原文档中\"函数\"与\"接口\"的具体使用场景及定义边界，若上下文存在明确术语倾向性（如相邻句子均使用\"函数\"），则不应强制统一为参考句中的\"接口\"。"
    },
    {
      "defect_id": 491339,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回ArkUI_IntSize默认值{0, 0}。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 436,
      "context": "{\"431\":\"```\",\"432\":\"**描述：**\",\"433\":\"\",\"434\":\"获取节点测算完成后的尺寸。\",\"435\":\"\",\"436\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回ArkUI_IntSize默认值{0, 0}。\",\"437\":\"\",\"438\":\"**参数:**\",\"439\":\"\",\"440\":\"| 名称 | 描述 | \",\"441\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "在修复语言表达一致性时，需严格核对上下文中的实际接口行为描述（如返回默认值/错误码），确保修改后的表述与文档其他部分的逻辑和术语完全一致，避免因参考句子脱离上下文导致错误修正。"
    },
    {
      "defect_id": 491250,
      "sentence": "将child节点从parent节点的子节点列表中移除。",
      "reference_sentence": "将child节点挂载到parent节点的子节点列表中。",
      "line_num": 43,
      "context": "{\"38\":\"## 组件树操作\",\"39\":\"\",\"40\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"41\":\"| -------- | ------- | ------- | ------- |  \",\"42\":\"| int32_t(\\\\* [addChild](#addchild) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child) | 将child节点挂载到parent节点的子节点列表中。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"43\":\"| int32_t(\\\\* [removeChild](#removechild) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child) | 将child节点从parent节点的子节点列表中移除。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"44\":\"| int32_t(\\\\* [insertChildAfter](#insertchildafter) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) sibling) | 将child节点挂载到parent节点的子节点列表中，挂载位置在sibling节点之后。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"45\":\"| int32_t(\\\\* [insertChildBefore](#insertchildbefore) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) sibling) | 将child节点挂载到parent节点的子节点列表中，挂载位置在sibling节点之前。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"46\":\"| int32_t(\\\\* [insertChildAt](#insertchildat) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, int32_t position) | 将child节点挂载到parent节点的子节点列表中，挂载位置由position指定。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"47\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getParent](#getparent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的父节点。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"48\":\"| int32_t(\\\\* [removeAllChildren](#removeallchildren) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent) | 移除node节点的所有子节点。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\"}",
      "用户拒绝的修改": "将child节点从parent节点的子节点列表中删除。",
      "注意事项": "保持文档内部术语配对关系（如\"挂载/移除\"的反义对应），避免单纯统一用词而破坏操作描述的逻辑对称性；优先检查上下文是否存在已建立的术语体系，而非孤立判断词汇一致性。"
    },
    {
      "defect_id": 491298,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程中操作不符合要求的节点时，接口返回错误码。",
      "line_num": 132,
      "context": "{\"127\":\"\",\"128\":\"该函数添加的监听回调函数触发时机会先于registerNodeCustomEventReceiver注册的全局回调函数。\",\"129\":\"\",\"130\":\"避免直接保存ArkUI_NodeCustomEvent对象指针，数据会在回调结束后销毁。\",\"131\":\"\",\"132\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"133\":\"\",\"134\":\"**参数：**\",\"135\":\"\",\"136\":\"| 名称 | 描述 | \",\"137\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程中操作已挂载到UI树上的节点时，接口返回错误码。",
      "注意事项": "修改术语前需优先确认上下文中的用词习惯，确保同一段落内术语严格一致；若原句与参考句属于不同上下文，应优先遵循问题句所在段落的现有表述方式，避免跨上下文机械替换。"
    },
    {
      "defect_id": 491242,
      "sentence": "删除node节点上注册的事件回调函数。",
      "reference_sentence": "向node节点注册事件回调函数，用于接收该组件产生的组件事件。",
      "line_num": 30,
      "context": "{\"25\":\"| int32_t(\\\\* [registerNodeEvent](#registernodeevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeeventtype) eventType, int32_t targetId, void \\\\*userData) | 向node节点注册事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"26\":\"| void(\\\\* [unregisterNodeEvent](#unregisternodeevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeeventtype) eventType) | node节点解注册事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用无效。 |\",\"27\":\"| int32_t(\\\\* [registerNodeCustomEvent](#registernodecustomevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeCustomEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomeventtype) eventType, int32_t targetId, void \\\\*userData) | 向node节点注册自定义事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"28\":\"| void(\\\\* [unregisterNodeCustomEvent](#unregisternodecustomevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeCustomEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomeventtype) eventType) | node节点解注册自定义事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用不生效。 |\",\"29\":\"| int32_t(\\\\* [addNodeEventReceiver](#addnodeeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 向node节点注册事件回调函数，用于接收该组件产生的组件事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"30\":\"| int32_t(\\\\* [removeNodeEventReceiver](#removenodeeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 删除node节点上注册的事件回调函数。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"31\":\"| int32_t(\\\\* [addNodeCustomEventReceiver](#addnodecustomeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) | 向node节点注册自定义事件回调函数，用于接收该组件产生的自定义事件（如布局事件，绘制事件）。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"32\":\"| int32_t(\\\\* [removeNodeCustomEventReceiver](#removenodecustomeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) | 删除node节点上注册的自定义事件回调函数。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"33\":\"| void(\\\\* [registerNodeEventReceiver](#registernodeeventreceiver) )(void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 注册节点事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"34\":\"|  void(\\\\* [unregisterNodeEventReceiver](#unregisternodeeventreceiver) )() | 解注册节点事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"35\":\"| void(\\\\* [registerNodeCustomEventReceiver](#registernodecustomeventreceiver) )(void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) |  注册节点自定义事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\"}",
      "用户拒绝的修改": "解注册node节点上注册的事件回调函数。",
      "注意事项": "在统一术语前需优先确认上下文API接口的命名一致性，若同一组操作接口（如add/remove）已存在固定动词搭配，应保持原有术语体系而非跨接口统一，避免破坏已有接口对的语义对称性。"
    },
    {
      "defect_id": 491334,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 267,
      "context": "{\"262\":\"\",\"263\":\"属性获取函数。\",\"264\":\"\",\"265\":\"该函数返回的指针是ArkUI框架内部的缓冲区指针，不需要开发者主动调用delete释放内存，但是需要在该函数下一次被调用前使用，否则可能会被其他值所覆盖。\",\"266\":\"\",\"267\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。\",\"268\":\"\",\"269\":\"**参数:**\",\"270\":\"\",\"271\":\"| 名称 | 描述 | \",\"272\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应优先确保技术准确性而非单纯统一术语，需结合上下文核对API实际行为；当用户明确拒绝修改时，应尊重原始技术描述而非强制统一表达。"
    },
    {
      "defect_id": 491235,
      "sentence": "在非UI线程中操作不符合要求的节点时，接口返回空指针。",
      "reference_sentence": "基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。  | 支持 | 支持在任意线程调用。",
      "line_num": 17,
      "context": "{\"12\":\"## 组件属性读写\",\"13\":\"\",\"14\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"15\":\"| -------- | ------- | ------- | ------- |  \",\"16\":\"| int32_t(\\\\* [setAttribute](#setattribute) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeAttributeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeattributetype) attribute, const [ArkUI_AttributeItem](_ark_u_i___attribute_item.md) \\\\*item) | 设置node节点的属性。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"17\":\"| const [ArkUI_AttributeItem](_ark_u_i___attribute_item.md) \\\\*(\\\\* [getAttribute](#getattribute) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeAttributeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeattributetype) attribute) | 获取node节点的属性。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回空指针。 |\",\"18\":\"| int32_t(\\\\* [resetAttribute](#resetattribute) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeAttributeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeattributetype) attribute) | 重置node节点的属性为默认值。  | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"19\":\"| int32_t(\\\\* [setLengthMetricUnit](#setlengthmetricunit) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_LengthMetricUnit](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_lengthmetricunit) unit) | 指定node节点的单位。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 | \",\"20\":\"\",\"21\":\"## 组件事件注册解注册\",\"22\":\"\"}",
      "用户拒绝的修改": "在非UI线程中操作不符合要求的节点时，接口返回错误码。",
      "注意事项": "修复时必须严格区分接口返回类型差异（错误码/指针），核对上下文技术实现细节，避免因追求术语统一而忽略接口实际行为特征，确保错误描述与API规范完全匹配。"
    },
    {
      "defect_id": 491297,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程中操作不符合要求的节点时，接口返回错误码。",
      "line_num": 88,
      "context": "{\"83\":\"```\",\"84\":\"**描述：**\",\"85\":\"\",\"86\":\"将节点挂载到某个父节点下。\",\"87\":\"\",\"88\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"89\":\"\",\"90\":\"**参数:**\",\"91\":\"\",\"92\":\"| 名称 | 描述 | \",\"93\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程中操作已挂载到UI树上的节点时，接口返回错误码。",
      "注意事项": "修改术语前需优先检查上下文中的原始用词习惯，若原段落已统一使用\"函数\"则无需强制替换为\"接口\"，避免过度依赖外部参考句而破坏当前段落的内部一致性。"
    },
    {
      "defect_id": 491335,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 300,
      "context": "{\"295\":\"```\",\"296\":\"**描述：**\",\"297\":\"\",\"298\":\"获取子节点。\",\"299\":\"\",\"300\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。\",\"301\":\"\",\"302\":\"**参数:**\",\"303\":\"\",\"304\":\"| 名称 | 描述 | \",\"305\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时必须严格核对问题句与参考句的上下文关联性，确保技术描述准确性优先于形式统一，禁止跨函数/场景强行统一术语。"
    },
    {
      "defect_id": 491347,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "line_num": 611,
      "context": "{\"606\":\"```\",\"607\":\"**描述：**\",\"608\":\"\",\"609\":\"获取在节点上保存的自定义数据。\",\"610\":\"\",\"611\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回空指针。\",\"612\":\"\",\"613\":\"**参数:**\",\"614\":\"\",\"615\":\"| 名称 | 描述 | \",\"616\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "注意事项": "修复时应优先确认上下文术语使用习惯，确保技术概念（如\"接口\"/\"函数\"）的准确性高于词汇一致性，避免因过度统一表述而改变原有技术语义。"
    },
    {
      "defect_id": 491333,
      "sentence": "在非UI线程调用函数操作已挂载到UI树的节点时，函数调用不生效。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 238,
      "context": "{\"233\":\"```\",\"234\":\"**描述：**\",\"235\":\"\",\"236\":\"销毁节点指针指向的节点对象。\",\"237\":\"\",\"238\":\"在非UI线程调用函数操作已挂载到UI树的节点时，函数调用不生效。\",\"239\":\"\",\"240\":\"**参数:**\",\"241\":\"\",\"242\":\"| 名称 | 描述 | \",\"243\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应确保术语一致性前先核查上下文是否存在统一表述规范，若原句与上下文已有明确对应关系（如\"不生效\"在问题描述中已多次使用）则无需强制替换为参考句中的\"返回错误码\"。"
    },
    {
      "defect_id": 491345,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的node节点时，函数返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "line_num": 539,
      "context": "{\"534\":\"```\",\"535\":\"**描述：**\",\"536\":\"\",\"537\":\"获取上一个兄弟节点。\",\"538\":\"\",\"539\":\"在非UI线程调用函数操作已挂载到UI树上的node节点时，函数返回空指针。\",\"540\":\"\",\"541\":\"**参数:**\",\"542\":\"\",\"543\":\"| 名称 | 描述 | \",\"544\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "注意事项": "修复术语不一致时应优先检查上下文术语使用习惯，若原文采用\"node节点\"这类中英混合表述作为固定技术术语时，应保留原始命名而非强制统一，避免破坏技术文档特有的命名约定。"
    },
    {
      "defect_id": 491359,
      "sentence": "在非UI线程调用此函数返回错误码。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 769,
      "context": "{\"764\":\"```\",\"765\":\"**描述：**\",\"766\":\"\",\"767\":\"对特定节点进行布局并传递该节点相对父节点的期望位置。\",\"768\":\"\",\"769\":\"在非UI线程调用此函数返回错误码。\",\"770\":\"\",\"771\":\"**参数:**\",\"772\":\"\",\"773\":\"| 名称 | 描述 | \",\"774\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应严格对照上下文句式结构，优先保持语法完整性和表达习惯一致性，避免因补充细节破坏原有简洁性。"
    },
    {
      "defect_id": 491348,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "line_num": 623,
      "context": "{\"618\":\"\",\"619\":\"**返回：**\",\"620\":\"\",\"621\":\"自定义数据。\",\"622\":\"\",\"623\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回空指针。\",\"624\":\"\",\"625\":\"**示例：**\",\"626\":\"```\",\"627\":\"ArkUI_NativeNodeAPI_1 *multiThreadNodeApi = nullptr;\",\"628\":\"OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeApi);\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "注意事项": "在修复术语一致性时需优先确认上下文技术语境（如代码示例中的\"GetModuleInterface\"），严格区分\"接口\"（API模块）和\"函数\"（具体方法）的技术层级，避免脱离领域语义强行统一词汇。"
    },
    {
      "defect_id": 491243,
      "sentence": "删除node节点上注册的自定义事件回调函数。",
      "reference_sentence": "向node节点注册自定义事件回调函数，用于接收该组件产生的自定义事件（如布局事件，绘制事件）。",
      "line_num": 32,
      "context": "{\"27\":\"| int32_t(\\\\* [registerNodeCustomEvent](#registernodecustomevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeCustomEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomeventtype) eventType, int32_t targetId, void \\\\*userData) | 向node节点注册自定义事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"28\":\"| void(\\\\* [unregisterNodeCustomEvent](#unregisternodecustomevent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, [ArkUI_NodeCustomEventType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomeventtype) eventType) | node节点解注册自定义事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用不生效。 |\",\"29\":\"| int32_t(\\\\* [addNodeEventReceiver](#addnodeeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 向node节点注册事件回调函数，用于接收该组件产生的组件事件。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"30\":\"| int32_t(\\\\* [removeNodeEventReceiver](#removenodeeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 删除node节点上注册的事件回调函数。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"31\":\"| int32_t(\\\\* [addNodeCustomEventReceiver](#addnodecustomeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) | 向node节点注册自定义事件回调函数，用于接收该组件产生的自定义事件（如布局事件，绘制事件）。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"32\":\"| int32_t(\\\\* [removeNodeCustomEventReceiver](#removenodecustomeventreceiver) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) | 删除node节点上注册的自定义事件回调函数。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"33\":\"| void(\\\\* [registerNodeEventReceiver](#registernodeeventreceiver) )(void(\\\\*eventReceiver)([ArkUI_NodeEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*event)) | 注册节点事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"34\":\"|  void(\\\\* [unregisterNodeEventReceiver](#unregisternodeeventreceiver) )() | 解注册节点事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"35\":\"| void(\\\\* [registerNodeCustomEventReceiver](#registernodecustomeventreceiver) )(void(\\\\*eventReceiver)([ArkUI_NodeCustomEvent](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodecustomevent) \\\\*event)) |  注册节点自定义事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"36\":\"|  void(\\\\* [unregisterNodeCustomEventReceiver](#unregisternodecustomeventreceiver) )() |  解注册节点自定义事件回调统一入口函数。 | 不支持 | 只支持UI线程调用，否则接口调用不生效。 |\",\"37\":\"\"}",
      "用户拒绝的修改": "解注册node节点上注册的自定义事件回调函数。",
      "注意事项": "修复时应严格比对API命名中的动词（如remove/unregister），确保操作术语与对应函数名称保持一致，优先遵循接口命名规范而非全局统一，同时识别不同接口间的语义差异。"
    },
    {
      "defect_id": 491251,
      "sentence": "移除node节点的所有子节点。",
      "reference_sentence": "将child节点挂载到parent节点的子节点列表中。",
      "line_num": 48,
      "context": "{\"43\":\"| int32_t(\\\\* [removeChild](#removechild) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child) | 将child节点从parent节点的子节点列表中移除。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"44\":\"| int32_t(\\\\* [insertChildAfter](#insertchildafter) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) sibling) | 将child节点挂载到parent节点的子节点列表中，挂载位置在sibling节点之后。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"45\":\"| int32_t(\\\\* [insertChildBefore](#insertchildbefore) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) sibling) | 将child节点挂载到parent节点的子节点列表中，挂载位置在sibling节点之前。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"46\":\"| int32_t(\\\\* [insertChildAt](#insertchildat) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent, [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) child, int32_t position) | 将child节点挂载到parent节点的子节点列表中，挂载位置由position指定。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"47\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getParent](#getparent) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的父节点。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"48\":\"| int32_t(\\\\* [removeAllChildren](#removeallchildren) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) parent) | 移除node节点的所有子节点。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回错误码。 |\",\"49\":\"| uint32_t(\\\\* [getTotalChildCount](#gettotalchildcount) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的子节点个数。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回0。 |\",\"50\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getChildAt](#getchildat) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node, int32_t position) | 获取node节点的子节点指针，位置由position指定。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回空指针。 |\",\"51\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getFirstChild](#getfirstchild) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的第一个子节点指针。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回空指针。 |\",\"52\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getLastChild](#getlastchild) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的最后一个子节点指针。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回空指针。 |\",\"53\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [getPreviousSibling](#getprevioussibling) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 获取node节点的上一个兄弟节点指针。 | 支持 | 在非UI线程中操作不符合要求的节点时，接口返回空指针。 |\"}",
      "用户拒绝的修改": "删除node节点的所有子节点。",
      "注意事项": "维护动词术语一致性时需严格参照上下文已有表述，当\"移除\"与\"挂载\"在相邻API中形成操作对仗时，应保留原术语而非机械替换近义词，避免破坏技术文档的体系化表达结构。"
    },
    {
      "defect_id": 491338,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回ArkUI_IntOffset默认值{0, 0}。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 403,
      "context": "{\"398\":\"```\",\"399\":\"**描述：**\",\"400\":\"\",\"401\":\"获取节点布局完成后的位置。\",\"402\":\"\",\"403\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回ArkUI_IntOffset默认值{0, 0}。\",\"404\":\"\",\"405\":\"**参数:**\",\"406\":\"\",\"407\":\"| 名称 | 描述 | \",\"408\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时必须严格核对上下文术语一致性（如“返回默认值”与“返回错误码”不可混用），优先采用问题上下文或参考句子中的统一表述，避免因局部修正破坏整体文档逻辑连贯性。"
    },
    {
      "defect_id": 491336,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 335,
      "context": "{\"330\":\"```\",\"331\":\"**描述：**\",\"332\":\"\",\"333\":\"获取第一个子节点。\",\"334\":\"\",\"335\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回空指针。\",\"336\":\"\",\"337\":\"**参数:**\",\"338\":\"\",\"339\":\"| 名称 | 描述 | \",\"340\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复前必须确认问题句子的上下文是否存在特定技术约定（如\"返回空指针\"是否为该API的固定设计），避免因过度统一术语而破坏技术准确性；优先保持问题句子与所在段落/接口的技术描述自洽而非全局统一。"
    },
    {
      "defect_id": 491358,
      "sentence": "| sibling | 后一个兄弟节点指针，如果为空则插入位置在最后面。  |",
      "reference_sentence": "| sibling | 前一个兄弟节点指针，如果为空则插入位置在最后面。  |",
      "line_num": 735,
      "context": "{\"730\":\"\",\"731\":\"| 名称 | 描述 | \",\"732\":\"| -------- | -------- |\",\"733\":\"| parent | 父节点指针。  | \",\"734\":\"| child | 子节点指针。  | \",\"735\":\"| sibling | 后一个兄弟节点指针，如果为空则插入位置在最后面。  | \",\"736\":\"\",\"737\":\"**返回：**\",\"738\":\"\",\"739\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"740\":\"\"}",
      "用户拒绝的修改": "| sibling | 前一个兄弟节点指针，如果为空则插入位置在最后面。  |",
      "注意事项": "修复前需确认上下文术语定义是否统一，优先遵循文档现有字段命名逻辑而非字面一致性；当用户明确拒绝修改时，应重新校验参数实际功能与描述是否存在隐藏逻辑关联。"
    },
    {
      "defect_id": 491360,
      "sentence": "在非UI线程调用此函数不生效。",
      "reference_sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 807,
      "context": "{\"802\":\"\",\"803\":\"强制标记当前节点需要重新测算，布局或者绘制。\",\"804\":\"\",\"805\":\"系统属性设置更新场景下ArkUI框架会自动标记脏区并重新执行测算，布局或者绘制，不需要开发者主动调用该函数。\",\"806\":\"\",\"807\":\"在非UI线程调用此函数不生效。\",\"808\":\"\",\"809\":\"**参数:**\",\"810\":\"\",\"811\":\"| 名称 | 描述 | \",\"812\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数不生效。",
      "注意事项": "修复时应优先保持上下文句式结构统一，避免在未明确技术差异的情况下擅自添加条件细节；修改前需核对相邻条目表达模式，确保技术描述颗粒度与文档现有风格严格匹配。"
    },
    {
      "defect_id": 491364,
      "sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程调用此函数不生效。",
      "line_num": 870,
      "context": "{\"865\":\"```\",\"866\":\"**描述：**\",\"867\":\"\",\"868\":\"注册自定义节点事件函数。事件触发时通过registerNodeCustomEventReceiver注册的自定义事件入口函数返回。\",\"869\":\"\",\"870\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"871\":\"\",\"872\":\"**参数:**\",\"873\":\"\",\"874\":\"| 名称 | 描述 | \",\"875\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数不生效。",
      "注意事项": "保持技术术语和逻辑一致性，优先保留原文中的\"返回错误码\"等明确行为描述，避免将具体错误机制改为笼统的\"不生效\"等模糊表述，确保修改后的表述与上下文错误处理机制完全匹配。"
    },
    {
      "defect_id": 491363,
      "sentence": "在非UI线程调用此函数返回错误码。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 834,
      "context": "{\"829\":\"```\",\"830\":\"**描述：**\",\"831\":\"\",\"832\":\"对特定节点进行测算，可以通过getMeasuredSize接口获取测算后的大小。\",\"833\":\"\",\"834\":\"在非UI线程调用此函数返回错误码。\",\"835\":\"\",\"836\":\"**参数:**\",\"837\":\"\",\"838\":\"| 名称 | 描述 | \",\"839\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应优先确认上下文是否存在隐式前提条件，避免过度补充冗余信息；保持一致性需兼顾表达简洁性，仅在必要处补充限定条件确保技术准确性。"
    },
    {
      "defect_id": 491365,
      "sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程调用此函数不生效。",
      "line_num": 945,
      "context": "{\"940\":\"```\",\"941\":\"**描述：**\",\"942\":\"\",\"943\":\"注册节点事件函数。\",\"944\":\"\",\"945\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"946\":\"\",\"947\":\"**参数:**\",\"948\":\"\",\"949\":\"| 名称 | 描述 | \",\"950\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数不生效。",
      "注意事项": "保持技术术语一致性时需优先保留原有错误处理机制描述（如\"返回错误码\"），避免将具体错误行为替换为笼统表述（如\"不生效\"）；修改前需结合完整上下文验证技术逻辑是否发生实质性改变。"
    },
    {
      "defect_id": 491414,
      "sentence": "在非UI线程调用函数返回错误码。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1370,
      "context": "{\"1365\":\"```\",\"1366\":\"**描述：**\",\"1367\":\"\",\"1368\":\"在测算回调函数中设置节点测算完成后的宽和高。\",\"1369\":\"\",\"1370\":\"在非UI线程调用函数返回错误码。\",\"1371\":\"\",\"1372\":\"**参数:**\",\"1373\":\"\",\"1374\":\"| 名称 | 描述 | \",\"1375\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应避免过度补充上下文已明确的信息，优先保持原句简洁性；仅在术语不统一时调整用词，若前后文存在详细/简写两种表述但语义无歧义，则尊重原文表述习惯。"
    },
    {
      "defect_id": 491417,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数不生效。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1470,
      "context": "{\"1465\":\"```\",\"1466\":\"**描述：**\",\"1467\":\"\",\"1468\":\"解注册节点事件函数。\",\"1469\":\"\",\"1470\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数不生效。\",\"1471\":\"\",\"1472\":\"**参数:**\",\"1473\":\"\",\"1474\":\"| 名称 | 描述 | \",\"1475\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应确保术语一致性，优先沿用文档上下文已有的表述方式（如\"不生效\"），避免引入新术语（如\"返回错误码\"）造成上下文矛盾；修改前需全面核查相邻条目是否使用相同语义结构。"
    },
    {
      "defect_id": 491398,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "[ARKUI_ERROR_CODE_ON_INVALID_THREAD](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止在非UI线程调用此函数操作已挂载到UI树上的节点。",
      "line_num": 1257,
      "context": "{\"1252\":\"```\",\"1253\":\"**描述：**\",\"1254\":\"\",\"1255\":\"属性设置函数。\",\"1256\":\"\",\"1257\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"1258\":\"\",\"1259\":\"**参数:**\",\"1260\":\"\",\"1261\":\"| 名称 | 描述 | \",\"1262\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用函数时，函数返回错误码。",
      "注意事项": "修复时应严格区分\"调用函数\"和\"操作节点\"的动词层次关系，保留\"调用函数操作节点\"的完整技术动作描述，避免因过度统一动词而破坏技术文档的精确性；需特别关注复合动词结构中的术语必要性，确保修改不损害原句的语义完整性。"
    },
    {
      "defect_id": 491376,
      "sentence": "删除节点上注册的自定义事件回调函数。",
      "reference_sentence": "解注册节点自定义事件回调统一入口函数。",
      "line_num": 1137,
      "context": "{\"1132\":\"```\",\"1133\":\"int32_t(* ArkUI_NativeNodeAPI_1::removeNodeCustomEventReceiver) (ArkUI_NodeHandle node, void(*eventReceiver)(ArkUI_NodeCustomEvent *event))\",\"1134\":\"```\",\"1135\":\"**描述：**\",\"1136\":\"\",\"1137\":\"删除节点上注册的自定义事件回调函数。\",\"1138\":\"\",\"1139\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"1140\":\"\",\"1141\":\"**参数:**\",\"1142\":\"\"}",
      "用户拒绝的修改": "解注册节点上注册的自定义事件回调函数。",
      "注意事项": "在保持术语一致性时应优先匹配上下文已有用词规范，若接口函数名使用\"remove\"则对应\"删除\"应保留；修改前需核查参考句子的适用场景是否与当前上下文完全匹配，避免跨技术场景的术语混用。"
    },
    {
      "defect_id": 491416,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数不生效。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1442,
      "context": "{\"1437\":\"```\",\"1438\":\"**描述：**\",\"1439\":\"\",\"1440\":\"解注册节点自定义事件函数。\",\"1441\":\"\",\"1442\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数不生效。\",\"1443\":\"\",\"1444\":\"**参数:**\",\"1445\":\"\",\"1446\":\"| 名称 | 描述 | \",\"1447\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应严格检查上下文术语一致性，优先保留用户原有用词；若需调整描述，需确保全文档相关表述同步更新，避免局部修改导致前后矛盾。"
    },
    {
      "defect_id": 491374,
      "sentence": "在非UI线程调用此函数不生效。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1057,
      "context": "{\"1052\":\"```\",\"1053\":\"**描述：**\",\"1054\":\"\",\"1055\":\"解注册节点自定义事件回调统一入口函数。\",\"1056\":\"\",\"1057\":\"在非UI线程调用函数不生效。\",\"1058\":\"\",\"1059\":\"**示例：**\",\"1060\":\"```\",\"1061\":\"ArkUI_NativeNodeAPI_1 *multiThreadNodeApi = nullptr;\",\"1062\":\"OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeApi);\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "保持原句核心语义不变的前提下进行最小化修正，避免引入未在原始上下文中明确提及的技术细节（如错误码机制），同时需确保修正后的描述与文档其他部分的错误处理表述风格一致。"
    },
    {
      "defect_id": 491377,
      "sentence": "删除节点上注册的节点事件回调函数。",
      "reference_sentence": "解注册事件回调统一入口函数。",
      "line_num": 1175,
      "context": "{\"1170\":\"```\",\"1171\":\"int32_t(* ArkUI_NativeNodeAPI_1::removeNodeEventReceiver) (ArkUI_NodeHandle node, void(*eventReceiver)(ArkUI_NodeEvent *event))\",\"1172\":\"```\",\"1173\":\"**描述：**\",\"1174\":\"\",\"1175\":\"删除节点上注册的节点事件回调函数。\",\"1176\":\"\",\"1177\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"1178\":\"\",\"1179\":\"**参数:**\",\"1180\":\"\"}",
      "用户拒绝的修改": "解注册节点上注册的节点事件回调函数。",
      "注意事项": "修复时应优先检查上下文术语一致性（如代码中的\"remove\"对应\"删除\"），避免机械替换同义词；需确认目标文档是否存在明确定义的专用术语体系，若API命名与文档描述已形成固定对应关系则不应强行统一。"
    },
    {
      "defect_id": 491415,
      "sentence": "在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1406,
      "context": "{\"1401\":\"```\",\"1402\":\"**描述：**\",\"1403\":\"\",\"1404\":\"在节点上保存自定义数据。\",\"1405\":\"\",\"1406\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"1407\":\"\",\"1408\":\"**参数:**\",\"1409\":\"\",\"1410\":\"| 名称 | 描述 | \",\"1411\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "确保术语和指代一致性时需结合上下文判断必要性，避免过度添加冗余限定词（如\"此函数\"）；优先保留用户原句的简洁性，仅在指代模糊或歧义风险较高时补充说明。"
    },
    {
      "defect_id": 491375,
      "sentence": "在非UI线程调用函数不生效。",
      "reference_sentence": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "line_num": 1079,
      "context": "{\"1074\":\"```\",\"1075\":\"**描述：**\",\"1076\":\"\",\"1077\":\"解注册事件回调统一入口函数。\",\"1078\":\"\",\"1079\":\"在非UI线程调用函数不生效。\",\"1080\":\"\",\"1081\":\"**示例：**\",\"1082\":\"```\",\"1083\":\"ArkUI_NativeNodeAPI_1 *multiThreadNodeApi = nullptr;\",\"1084\":\"OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeApi);\"}",
      "用户拒绝的修改": "在非UI线程调用此函数操作已挂载到UI树上的节点时，函数返回错误码。",
      "注意事项": "修复时应优先保持原句核心语义不变，避免引入未明确的技术细节（如错误码）；需结合上下文判断用户是否已通过其他方式描述该机制，防止过度修正破坏文档完整性。"
    },
    {
      "defect_id": 492590,
      "sentence": "网络接口名。",
      "reference_sentence": "以太网卡名称。",
      "line_num": 596,
      "context": "{\"591\":\"\",\"592\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"593\":\"\",\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\"}",
      "用户拒绝的修改": "以太网卡名称。",
      "注意事项": "在修复术语不一致时，必须全局检索文档确认是否存在已有统一表述，避免因局部修改导致重复冲突；若参考句子已存在相同表述，应直接沿用而非新增同义替换。"
    },
    {
      "defect_id": 492591,
      "sentence": "设备名称。",
      "reference_sentence": "以太网卡名称。",
      "line_num": 597,
      "context": "{\"592\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"593\":\"\",\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\"}",
      "用户拒绝的修改": "以太网卡名称。",
      "注意事项": "修复前必须确认术语在上下文中的具体指代对象，若原词为通用概念（如\"设备名称\"）而参考词为特定场景术语（如\"以太网卡名称\"），需优先保留原词通用性，仅在上下文明确限定场景时方可替换为特化词汇。"
    },
    {
      "defect_id": 498972,
      "sentence": "取消animator动画。",
      "reference_sentence": "销毁animator动画对象。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"| int32_t [OH_ArkUI_Animator_ResetAnimatorOption](#oh_arkui_animator_resetanimatoroption) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle, [ArkUI_AnimatorOption](#arkui_animatoroption) \\\\*option) | 更新animator动画。  |\",\"10\":\"| int32_t [OH_ArkUI_Animator_Play](#oh_arkui_animator_play) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 启动animator动画。  |\",\"11\":\"| int32_t [OH_ArkUI_Animator_Finish](#oh_arkui_animator_finish) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 结束animator动画。  |\",\"12\":\"| int32_t [OH_ArkUI_Animator_Pause](#oh_arkui_animator_pause) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 暂停animator动画。  |\",\"13\":\"| int32_t [OH_ArkUI_Animator_Cancel](#oh_arkui_animator_cancel) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 取消animator动画。  |\",\"14\":\"| int32_t [OH_ArkUI_Animator_Reverse](#oh_arkui_animator_reverse) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 以相反的顺序播放animator动画。  |\",\"15\":\"\",\"16\":\"int32_t OH_ArkUI_Animator_Cancel (ArkUI_AnimatorHandle animatorHandle)\",\"17\":\"\",\"18\":\"int32_t OH_ArkUI_Animator_Finish (ArkUI_AnimatorHandle animatorHandle)\"}",
      "用户拒绝的修改": "销毁animator动画。",
      "注意事项": "修复时应严格校验上下文术语一致性，优先采用同功能接口已使用的动词（如\"取消\"对应Cancel操作），注意区分对象销毁（需带\"对象\"后缀）与操作终止的表述差异。"
    },
    {
      "defect_id": 500151,
      "sentence": "根据`状态示意图`和`详细的接口文档`进行合理调用。在程序执行完成后，调用`OH_***_Create`方法的同时必须调用对应的`OH_***_Destroy`方法，进行资源释放。",
      "reference_sentence": "根据`状态示意图`和`详细的接口文档`进行合理调用。在程序执行完成后，调用`OH_***_Create`方法的同时必须调用对应的`OH_***_Destroy`方法，进行资源释放。",
      "line_num": 24,
      "context": "{\"19\":\"\",\"20\":\"- 当应用在执行过程中，可能出现系统内部异常。如网络异常、内存不足、媒体服务死亡不可用等，建议通过 [OH_LowPowerAudioSinkCallback_SetErrorListener](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosinkcallback_seterrorlistener)或[OH_LowPowerVideoSinkCallback_SetErrorListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_seterrorlistener)对应接口设置错误监听回调函数，根据不同错误类型和错误信息，做出相应处理，避免出现播放异常。\",\"21\":\"\",\"22\":\"- 在播放过程中，播放器需要的数据要通过 [OH_AVDemuxer_ReadSampleBuffer](../../reference/apis-avcodec-kit/_a_v_demuxer.md#oh_avdemuxer_readsamplebuffer)接口获取指定轨道的buffer，并通过 [OH_AVSamplesBuffer_AppendOneBuffer](../../reference/apis-media-kit/capi-lowpower-avsink-base-h.md#oh_avsamplesbuffer_appendonebuffer)进行多个buffer的封装，然后再通过 [OH_LowPowerAudioSink_ReturnSamples](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosink_returnsamples)或[OH_LowPowerVideoSink_ReturnSamples](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosink_returnsamples)通知播放器进行消费，当播放器需要数据时，会触发通过 [OH_LowPowerAudioSinkCallback_SetDataNeededListener](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosinkcallback_setdataneededlistener)或[OH_LowPowerVideoSinkCallback_SetDataNeededListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_setdataneededlistener)接口注册的回调函数。\",\"23\":\"\",\"24\":\"- 需要注意函数的调用时机。根据`状态示意图`和`详细的接口文档`进行合理调用。在程序执行完成后，调用`OH_***_Create`方法的同时必须调用对应的`OH_***_Destroy`方法，进行资源释放。\",\"25\":\"\",\"26\":\"- 用户在注册回调函数时，可在最后一个参数`void *userData`中来配置自定义数据，以便在回调函数中执行某些设置（如状态改变等）。<br>\",\"27\":\"其他回调函数 : <br>\",\"28\":\"[OH_LowPowerAudioSinkCallback_SetPositionUpdateListener](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosinkcallback_setpositionupdatelistener)：可获取播放进度。<br>[OH_LowPowerAudioSinkCallback_SetEosListener](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosinkcallback_seteoslistener)或[OH_LowPowerVideoSinkCallback_SetEosListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_seteoslistener)：播放结束触发。 <br>\",\"29\":\"[OH_LowPowerVideoSinkCallback_SetRenderStartListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_setrenderstartlistener)：视频开始渲染。 <br>\"}",
      "用户拒绝的修改": "根据状态示意图和详细的接口文档进行合理调用。在程序执行完成后，调用`OH_***_Create`方法的同时必须调用对应的`OH_***_Destroy`方法，进行资源释放。",
      "注意事项": "在判断术语一致性时需先确认上下文是否存在特定格式规范（如反引号用于接口/文档名称），避免将合法格式差异误判为术语不一致；修改前应检查同文档其他位置的引用方式保持统一。"
    },
    {
      "defect_id": 500150,
      "sentence": "使用LPP（low power player）播放器可以实现从媒体源到渲染的音视频通路能力。本指南将以完整地播放一个本地视频作为示例，向开发者讲解使用LowPowerPlayer播放音视频。",
      "reference_sentence": "使用LPP（low power player）播放器可以实现从媒体源到渲染的音视频通路能力。本指南将以完整地播放一个本地视频作为示例，向开发者讲解使用LPP播放音视频。",
      "line_num": 3,
      "context": "{\"1\":\"# 使用LPP播放器播放音视频 (C/C++)\",\"2\":\"\",\"3\":\"使用LPP（low power player）播放器可以实现从媒体源到渲染的音视频通路能力。本指南将以完整地播放一个本地视频作为示例，向开发者讲解使用LowPowerPlayer播放音视频。\",\"4\":\"\",\"5\":\"播放流程包含：创建解封装器、创建播放器、设置回调监听函数、设置播放参数（音量/倍速/焦点模式）、播放控制（播放/暂停/停止/音量/倍速）、重置、销毁播放器实例。\",\"6\":\"\",\"7\":\"**图1** 播放状态变化示意图  \",\"8\":\"![LPP status change](figures/lpp-status-change-ndk.png)\"}",
      "用户拒绝的修改": "使用LPP播放器可以实现从媒体源到渲染的音视频通路能力。本指南将以完整地播放一个本地视频作为示例，向开发者讲解使用LPP播放音视频。",
      "注意事项": "在首次明确定义缩写（如\"LPP（low power player）\"）后，需严格保持术语格式一致性，避免将驼峰式全称（如LowPowerPlayer）与缩写混用，同时确认上下文是否存在特殊术语规范要求。"
    },
    {
      "defect_id": 498973,
      "sentence": "取消animator动画。",
      "reference_sentence": "销毁animator动画对象。",
      "line_num": 16,
      "context": "{\"11\":\"| int32_t [OH_ArkUI_Animator_Finish](#oh_arkui_animator_finish) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 结束animator动画。  |\",\"12\":\"| int32_t [OH_ArkUI_Animator_Pause](#oh_arkui_animator_pause) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 暂停animator动画。  |\",\"13\":\"| int32_t [OH_ArkUI_Animator_Cancel](#oh_arkui_animator_cancel) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 取消animator动画。  |\",\"14\":\"| int32_t [OH_ArkUI_Animator_Reverse](#oh_arkui_animator_reverse) ([ArkUI_AnimatorHandle](#arkui_animatorhandle) animatorHandle) | 以相反的顺序播放animator动画。  |\",\"15\":\"\",\"16\":\"int32_t OH_ArkUI_Animator_Cancel (ArkUI_AnimatorHandle animatorHandle)\",\"17\":\"\",\"18\":\"int32_t OH_ArkUI_Animator_Finish (ArkUI_AnimatorHandle animatorHandle)\",\"19\":\"\",\"20\":\"int32_t OH_ArkUI_Animator_Pause (ArkUI_AnimatorHandle animatorHandle)\",\"21\":\"\"}",
      "用户拒绝的修改": "销毁animator动画。",
      "注意事项": "修复时应严格区分术语的适用场景，优先保持上下文动词一致性（如函数名OH_ArkUI_Animator_Cancel对应\"取消\"），避免跨语义替换（如\"销毁\"特指对象资源释放场景）。"
    },
    {
      "defect_id": 498974,
      "sentence": "取消animator动画。",
      "reference_sentence": "销毁animator动画对象。",
      "line_num": 32,
      "context": "{\"27\":\"\",\"28\":\"| int32_t [OH_ArkUI_Animator_ResetAnimatorOption](_ark_u_i___native_module.md#oh_arkui_animator_resetanimatoroption) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle, [ArkUI_AnimatorOption](_ark_u_i___native_module.md#arkui_animatoroption) \\\\*option) | 更新animator动画。  | \",\"29\":\"| int32_t [OH_ArkUI_Animator_Play](_ark_u_i___native_module.md#oh_arkui_animator_play) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle) | 启动animator动画。  | \",\"30\":\"| int32_t [OH_ArkUI_Animator_Finish](_ark_u_i___native_module.md#oh_arkui_animator_finish) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle) | 结束animator动画。  | \",\"31\":\"| int32_t [OH_ArkUI_Animator_Pause](_ark_u_i___native_module.md#oh_arkui_animator_pause) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle) | 暂停animator动画。  | \",\"32\":\"| int32_t [OH_ArkUI_Animator_Cancel](_ark_u_i___native_module.md#oh_arkui_animator_cancel) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle) | 取消animator动画。  | \",\"33\":\"| int32_t [OH_ArkUI_Animator_Reverse](_ark_u_i___native_module.md#oh_arkui_animator_reverse) ([ArkUI_AnimatorHandle](_ark_u_i___native_module.md#arkui_animatorhandle) animatorHandle) | 以相反的顺序播放animator动画。  | \"}",
      "用户拒绝的修改": "销毁animator动画。",
      "注意事项": "修复前需严格核对上下文术语使用场景，区分\"销毁\"（对象生命周期操作）和\"取消\"（动作中断操作）等技术语义差异，优先保持同功能模块动词一致性。"
    },
    {
      "defect_id": 498843,
      "sentence": "向HashSet添加元素。",
      "reference_sentence": "add(value: T): boolean",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"### add\",\"145\":\"\",\"146\":\"add(value: T): boolean\",\"147\":\"\",\"148\":\"向HashSet添加元素。\",\"149\":\"\",\"150\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"151\":\"\",\"152\":\"**系统能力：** SystemCapability.Utils.Lang\",\"153\":\"\"}",
      "用户拒绝的修改": "添加元素到HashSet。",
      "注意事项": "修复时应优先保持与原文档上下文一致的句式结构（如祈使句\"向...添加\"），避免机械调整语序破坏已有规范；需结合参考方法签名和相邻条目风格判断最合适的表达方式，而非单纯依赖语法规则。"
    },
    {
      "defect_id": 498969,
      "sentence": "将输入的Uint8Array字节数组进行Base64编码，返回一个字符串结果。该方法支持多种编码格式，包括标准Base64编码、MIME格式的Base64编码（带有换行符）、URL安全格式的Base64编码等。",
      "reference_sentence": "util.Type.BASIC表示Base64编码。<br/>util.Type.BASIC_URL_SAFE表示Base64URL编码。",
      "line_num": 3442,
      "context": "{\"3437\":\"\",\"3438\":\"### encodeToStringSync<sup>9+</sup>\",\"3439\":\"\",\"3440\":\"encodeToStringSync(src: Uint8Array, options?: Type): string\",\"3441\":\"\",\"3442\":\"将输入的Uint8Array字节数组进行Base64编码，返回一个字符串结果。该方法支持多种编码格式，包括标准Base64编码、MIME格式的Base64编码（带有换行符）、URL安全格式的Base64编码等。\",\"3443\":\"\",\"3444\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"3445\":\"\",\"3446\":\"**系统能力：** SystemCapability.Utils.Lang\",\"3447\":\"\"}",
      "用户拒绝的修改": "将输入的Uint8Array字节数组进行Base64编码，返回一个字符串结果。该方法支持多种编码格式，包括util.Type.BASIC（标准Base64编码）、util.Type.BASIC_URL_SAFE（URL安全格式的Base64编码）等。",
      "注意事项": "修复时应严格保持技术术语的一致性，避免混用\"Base64编码\"与\"Base64URL编码\"等不同标准名称；优先采用文档上下文明确提供的参考表述（如\"Base64编码\"/\"Base64URL编码\"），而非直接暴露底层枚举值。"
    },
    {
      "defect_id": 498874,
      "sentence": "需要保证“D:\\”路径具有读写权限",
      "reference_sentence": "需要保证当前执行cmd命令时所在目录具有读写权限",
      "line_num": 73,
      "context": "{\"68\":\"| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；<br>不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot | 解析当前目录下的rawheap文件，并在指定路径（如：D:\\\\temp）下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap D:\\\\temp\\\\xxx.heapsnapshot<br>解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap xxx.heapsnapshot |\",\"69\":\"> **注意：**\",\"70\":\">\",\"71\":\"> [heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\",\"72\":\"> 以windows为例:\",\"73\":\"> D:\\\\> ...\\\\rawheap_translator.exe ...\\\\example.rawheap 命令中，需要保证“D:\\\\”路径具有读写权限。\",\"74\":\"\",\"75\":\"## 解析命令示例\",\"76\":\"\",\"77\":\"### OHOS设备中解析示例\",\"78\":\"\"}",
      "用户拒绝的修改": "需要保证当前执行cmd命令时所在目录具有读写权限",
      "注意事项": "修复时应严格保持示例路径与上下文术语的一致性，避免用\"当前路径\"等通用表述覆盖具体示例；需明确区分\"指定路径\"和\"默认路径\"两种场景，分别给出独立说明。"
    },
    {
      "defect_id": 500168,
      "sentence": "在CMake脚本中链接动态库。",
      "reference_sentence": "并需要在 CMake 脚本中链接如下动态库:",
      "line_num": 35,
      "context": "{\"30\":\"[OH_LowPowerVideoSink_SetTargetStartFrame](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosink_settargetstartframe)：到达目标帧。 <br>\",\"31\":\"[OH_LowPowerVideoSinkCallback_SetStreamChangedListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_setstreamchangedlistener)：视频流切换。 <br>\",\"32\":\"[OH_LowPowerVideoSinkCallback_SetFirstFrameDecodedListener](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosinkcallback_setfirstframedecodedlistener)：首帧视频渲染完毕。\",\"33\":\"\",\"34\":\"## 开发步骤及注意事项\",\"35\":\"在CMake脚本中链接动态库。\",\"36\":\"```\",\"37\":\"target_link_libraries(sample PUBLIC liblowpower_avsink.so)\",\"38\":\"```\",\"39\":\"\",\"40\":\"头文件引入\"}",
      "用户拒绝的修改": "在CMake脚本中链接如下动态库。",
      "注意事项": "修改时应优先保持上下文逻辑连贯性，若原句后紧跟具体示例（如代码块），无需强制添加\"如下\"等指示词；需区分抽象操作说明和具体内容列举的不同场景，避免过度统一造成语义冗余。"
    },
    {
      "defect_id": 500170,
      "sentence": "开发者使用系统日志能力时，需引入如下头文件：",
      "reference_sentence": "开发者通过引入[lowpower_audio_sink_base.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-base-h.md)、[lowpower_audio_sink.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md)、[lowpower_video_sink.h](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md)、 [lowpower_video_sink_base.h](../../reference/apis-media-kit/capi-lowpower-video-sink-base-h.md) 头文件，使用音视频播放相关API。",
      "line_num": 47,
      "context": "{\"42\":\"#include \\\"multimedia/player_framework/lowpower_audio_sink_base.h\\\"\",\"43\":\"#include \\\"multimedia/player_framework/lowpower_audio_sink.h\\\"\",\"44\":\"#include \\\"multimedia/player_framework/lowpower_video_sink.h\\\"\",\"45\":\"#include \\\"multimedia/player_framework/lowpower_video_sink_base.h\\\"\",\"46\":\"```\",\"47\":\"开发者使用系统日志能力时，需引入如下头文件：\",\"48\":\"```\",\"49\":\"#include <hilog/log.h>\",\"50\":\"```\",\"51\":\"并需要在 CMake 脚本中链接如下动态库:\",\"52\":\"```\"}",
      "用户拒绝的修改": "开发者需引入如下头文件：",
      "注意事项": "保留原文中\"引入如下头文件\"的关键指示词，确保与后续代码示例的\"如下\"形成逻辑呼应；严格区分\"引入头文件\"的泛指表达和\"引入如下头文件\"的特指场景，避免混淆概念边界。"
    },
    {
      "defect_id": 500169,
      "sentence": "头文件引入",
      "reference_sentence": "开发者通过引入[lowpower_audio_sink_base.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-base-h.md)、[lowpower_audio_sink.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md)、[lowpower_video_sink.h](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md)、 [lowpower_video_sink_base.h](../../reference/apis-media-kit/capi-lowpower-video-sink-base-h.md) 头文件，使用音视频播放相关API。",
      "line_num": 40,
      "context": "{\"35\":\"在CMake脚本中链接动态库。\",\"36\":\"```\",\"37\":\"target_link_libraries(sample PUBLIC liblowpower_avsink.so)\",\"38\":\"```\",\"39\":\"\",\"40\":\"头文件引入\",\"41\":\"```\",\"42\":\"#include \\\"multimedia/player_framework/lowpower_audio_sink_base.h\\\"\",\"43\":\"#include \\\"multimedia/player_framework/lowpower_audio_sink.h\\\"\",\"44\":\"#include \\\"multimedia/player_framework/lowpower_video_sink.h\\\"\",\"45\":\"#include \\\"multimedia/player_framework/lowpower_video_sink_base.h\\\"\"}",
      "用户拒绝的修改": "引入头文件",
      "注意事项": "修复时应严格保持原文的术语结构和语法形式（如名词性短语\"头文件引入\"不宜改为动宾结构\"引入头文件\"），优先检查上下文是否存在已确立的固定表达范式，避免因句式转换破坏文档整体一致性。"
    },
    {
      "defect_id": 500171,
      "sentence": "在使用该模块，需要使用解封装、基础解码、显示渲染等能力时，需要链接的库如下所示：",
      "reference_sentence": "并需要在 CMake 脚本中链接如下动态库:",
      "line_num": 55,
      "context": "{\"50\":\"```\",\"51\":\"并需要在 CMake 脚本中链接如下动态库:\",\"52\":\"```\",\"53\":\"target_link_libraries(sample PUBLIC libhilog_ndk.z.so)\",\"54\":\"```\",\"55\":\"在使用该模块，需要使用解封装、基础解码、显示渲染等能力时，需要链接的库如下所示：\",\"56\":\"```\",\"57\":\"set(BASE_LIBRARY\",\"58\":\"    libnative_media_codecbase.so libnative_media_core.so libnative_media_vdec.so libnative_window.so\",\"59\":\"    libnative_media_venc.so libnative_media_acodec.so libnative_media_avdemuxer.so libnative_media_avsource.so\",\"60\":\"    libohaudio.so\"}",
      "用户拒绝的修改": "在使用该模块，需要使用解封装、基础解码、显示渲染等能力时，需要链接如下动态库：",
      "注意事项": "修复时应优先确认上下文术语的准确指代（如\"库\"是否特指\"动态库\"），避免脱离上下文强行统一表述；当存在多个合法表述时，需通过交叉验证参考句和问题句的语法结构（如\"链接的库如下所示：\"与\"链接如下动态库:\"）保持局部一致性。"
    },
    {
      "defect_id": 503388,
      "sentence": "值为true表示组件可交互，响应点击等操作。<br/>值为false表示组件不可交互，不响应点击等操作。",
      "reference_sentence": "组件可交互状态下响应[点击事件](ts-universal-events-click.md)、[触摸事件](ts-universal-events-touch.md)、[拖拽事件](ts-universal-events-drag-drop.md)、[按键事件](ts-universal-events-key.md)、[焦点事件](ts-universal-focus-event.md)、[鼠标事件](ts-universal-mouse-key.md)、[轴事件](ts-universal-events-axis.md)、[悬浮事件](ts-universal-events-hover.md)、[无障碍悬浮事件](ts-universal-accessibility-hover-event.md)、[手势事件](ts-gesture-settings.md)、[焦点轴事件](ts-universal-events-focus_axis.md)和[表冠事件](ts-universal-events-crown.md)。",
      "line_num": 27,
      "context": "{\"22\":\"\",\"23\":\"**参数：** \",\"24\":\"\",\"25\":\"| 参数名 | 类型    | 必填 | 说明                                                         |\",\"26\":\"| ------ | ------- | ---- | ------------------------------------------------------------ |\",\"27\":\"| value  | boolean | 是   | 值为true表示组件可交互，响应点击等操作。<br/>值为false表示组件不可交互，不响应点击等操作。 |\",\"28\":\"\",\"29\":\"**返回值：**\",\"30\":\"\",\"31\":\"| 类型 | 说明 |\",\"32\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "值为true表示组件可交互，响应点击事件等操作。<br/>值为false表示组件不可交互，不响应点击事件等操作。",
      "注意事项": "修复时应优先确认上下文术语使用场景，若原句\"点击\"在参数说明中作为操作类型而非事件类型使用，需保留原表述风格；同时需区分技术术语与通俗表述的适用场景，避免在非必要场景强制统一术语。"
    },
    {
      "defect_id": 492266,
      "sentence": "在Native节点下树前，必须先卸载嵌套的ArkTs节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "reference_sentence": "在Native节点下树前，必须先卸载嵌套的ArkTS节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "line_num": 329,
      "context": "{\"324\":\"\",\"325\":\"## 错误与异常处理\",\"326\":\"\",\"327\":\"- 在非UI线程调用不支持多线程的接口将返回错误码。\",\"328\":\"- 挂载到UI主树后，在非UI线程中调用多线程接口将返回错误码。\",\"329\":\"- 在Native节点下树前，必须先卸载嵌套的ArkTs节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。\",\"330\":\"\",\"331\":\"框架将打印以下日志提示：\",\"332\":\"\",\"333\":\"```\",\"334\":\"CheckIsThreadSafeNodeTree failed. thread safe node tree contains unsafe node: ${nodeid}\"}",
      "用户拒绝的修改": "在Native节点下树前，必须先卸载嵌套的ArkTS节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "注意事项": "修复术语一致性时需优先核对上下文和参考句中的官方命名形式，若存在多版本混用应通过注释说明规范写法而非直接替换，避免因忽略上下文特殊约定导致无效修改。"
    },
    {
      "defect_id": 503988,
      "sentence": "在Native节点下树前，必须先卸载嵌套的ArkTs节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "reference_sentence": "在Native节点下树前，必须先卸载嵌套的ArkTS节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "line_num": 329,
      "context": "{\"324\":\"\",\"325\":\"## 错误与异常处理\",\"326\":\"\",\"327\":\"- 在非UI线程调用不支持多线程的接口将返回错误码。\",\"328\":\"- 在非UI线程调用多线程接口操作已挂载到UI主树的组件将返回错误码。\",\"329\":\"- 在Native节点下树前，必须先卸载嵌套的ArkTs节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。\",\"330\":\"\",\"331\":\"框架将打印以下日志提示：\",\"332\":\"\",\"333\":\"```\",\"334\":\"CheckIsThreadSafeNodeTree failed. thread safe node tree contains unsafe node: ${nodeid}\"}",
      "用户拒绝的修改": "在Native节点下树前，必须先卸载嵌套的ArkTS节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。",
      "注意事项": "修复术语一致性时需优先验证项目规范或上下文中的既定拼写（如检查文档其他部分是否统一使用`ArkTS`），避免仅依赖局部拼写判断；同时注意大小写敏感性（如`ArkTS`为正确格式）。"
    },
    {
      "defect_id": 504137,
      "sentence": "组件点击状态的样式。只支持传入@style修饰的样式代码块。",
      "reference_sentence": "组件按下状态的样式。只支持传入@style修饰的样式代码块。",
      "line_num": 53,
      "context": "{\"48\":\"| -------- | -------- | -------- | -------- | -------- |\",\"49\":\"| normal | any | 否 | 是 | 组件无状态时的样式。只支持传入@style修饰的样式代码块。 |\",\"50\":\"| pressed | any | 否 | 是 | 组件按下状态的样式。只支持传入@style修饰的样式代码块。 |\",\"51\":\"| disabled | any | 否 | 是 | 组件禁用状态的样式。只支持传入@style修饰的样式代码块。 |\",\"52\":\"| focused | any | 否 | 是 | 组件获焦状态的样式。只支持传入@style修饰的样式代码块。 |\",\"53\":\"| clicked | any | 否 | 是 | 组件点击状态的样式。只支持传入@style修饰的样式代码块。 |\",\"54\":\"| selected<sup>10+</sup> | object | 否 | 是 | 组件选中状态的样式。只支持传入@style修饰的样式代码块。<br/> |\",\"55\":\"\",\"56\":\"**selected选中状态说明**\",\"57\":\"\",\"58\":\"- 当前多态样式的选中状态样式依赖组件选中属性值，可以使用[onClick](ts-universal-events-click.md)修改属性值，或使用属性自带[$$](../../../ui/state-management/arkts-two-way-sync.md)双向绑定功能。\"}",
      "用户拒绝的修改": "组件单击状态的样式。只支持传入@style修饰的样式代码块。",
      "注意事项": "修复时必须严格核查上下文术语体系，优先保持文档内部用词一致性（如区分\"点击clicked\"和\"按下pressed\"），避免基于通用语义擅自替换近义词；当用户确认无问题时，应重点比对参考句式的术语使用模式而非直接修改。"
    },
    {
      "defect_id": 503415,
      "sentence": "设置了matchParent的组件会将其大小设置为其父容器不包含padding、border以及safeAreaPadding后的大小，即与父容器内容区大小相等。",
      "reference_sentence": "LayoutPolicy支持设置三种布局策略：matchParent（自适应父组件布局）、wrapContent（根据内容自适应但不超过父组件尺寸的布局）和fixAtIdealSize（根据内容自适应，可能超过父组件尺寸的布局）。",
      "line_num": 1036,
      "context": "{\"1031\":\"> \",\"1032\":\"> - matchParent会强制将自身大小设置成父组件大小，因此其设置的其他除宽高比外约束大小的属性将会失效。\",\"1033\":\">\",\"1034\":\"> - LayoutPolicy的生效优先级为宽高比 > [constraintSize](ts-universal-attributes-size.md#constraintsize) > LayoutPolicy。\",\"1035\":\">\",\"1036\":\"> - 设置了matchParent的组件会将其大小设置为其父组件不包含padding、border以及safeAreaPadding后的大小，即与父组件内容区大小相等。\",\"1037\":\">\",\"1038\":\">  **使用场景：**\",\"1039\":\"> \",\"1040\":\"> - 使用[自定义组件的自定义布局](ts-custom-component-layout.md)时，对其中的子组件的内容未知，不能确定设置固定的长度和宽度，可以为其的宽度或高度设置LayoutPolicy.fixAtIdealSize，使得子组件不受到父组件的影响，只受到自定义布局限制的影响。\",\"1041\":\"\"}",
      "用户拒绝的修改": "设置了matchParent的组件会将其大小设置为其父组件不包含padding、border以及safeAreaPadding后的大小，即与父组件内容区大小相等。",
      "注意事项": "在修复术语一致性时，需优先确认当前上下文和问题句子的术语使用习惯（如\"父容器\"可能为特定场景的合法表述），若上下文存在明确术语混用且用户未提出异议，应避免强行统一；同时需结合参考句子的全局术语（如\"父组件\"）和用户拒绝理由，区分\"必要修正\"与\"过度修正\"的边界。"
    },
    {
      "defect_id": 504053,
      "sentence": "在当前组件上，增加遮罩文本或者叠加自定义组件以及ComponentContent作为该组件的浮层。浮层的定位同样基于当前组件进行计算。浮层不通过组件树进行渲染，部分接口（例如[getRectangleById](../js-apis-arkui-componentUtils.md#componentutilsgetrectanglebyiddeprecated)）不支持获取浮层中的组件。",
      "reference_sentence": "在当前组件上，增加遮罩文本或者叠加自定义组件以及ComponentContent作为该组件的浮层。浮层的定位同样基于当前组件进行计算。浮层不通过组件树进行渲染，部分接口（例如[getRectangleById](../js-apis-arkui-componentUtils.md#componentutilsgetrectanglebyiddeprecated)）不支持获取浮层中的组件。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## overlay\",\"10\":\"\",\"11\":\"overlay(value: string | CustomBuilder | ComponentContent, options?: OverlayOptions ): T\",\"12\":\"\",\"13\":\"在当前组件上，增加遮罩文本或者叠加自定义组件以及ComponentContent作为该组件的浮层。浮层的定位同样基于当前组件进行计算。浮层不通过组件树进行渲染，部分接口（例如[getRectangleById](../js-apis-arkui-componentUtils.md#componentutilsgetrectanglebyiddeprecated)）不支持获取浮层中的组件。\",\"14\":\"\",\"15\":\">**说明：**\",\"16\":\">\",\"17\":\"> overlay会将浮层组件覆盖在所绑定的组件上方，阻塞用户对浮层下方组件的所有交互操作。若需用户可操作下方组件，应参照[示例2（通过builder设置浮层）](#示例2通过builder设置浮层)中的实现，在浮层builder的最外层组件上配置`.hitTestBehavior(HitTestMode.Transparent)`。此配置在通过浮层实现水印时尤其重要，因为水印显示不应妨碍用户对下层组件的操作。\",\"18\":\"\"}",
      "用户拒绝的修改": "在当前组件上，增加遮罩文本或者增加自定义组件以及ComponentContent作为该组件的浮层。浮层的定位同样基于当前组件进行计算。浮层不通过组件树进行渲染，部分接口（例如[getRectangleById](../js-apis-arkui-componentUtils.md#componentutilsgetrectanglebyiddeprecated)）不支持获取浮层中的组件。",
      "注意事项": "在修复语言表达一致性时，需优先确认技术术语的准确性，避免将不同技术场景下的专用动词（如\"增加\"对应创建新元素，\"叠加\"对应层级覆盖操作）强行统一；若上下文存在术语区分意图，应保留原词并补充说明而非直接替换。"
    },
    {
      "defect_id": 501955,
      "sentence": "设置评分条是否作为一个指示器。<br>true：作为一个指示器，此时用户不可操作。<br>false：不作为一个指示器，此时用户可以操作。",
      "reference_sentence": "无",
      "line_num": 28,
      "context": "{\"23\":\"| 名称 | 类型 | 默认值 | 必填 | 描述 |\",\"24\":\"| -------- | -------- | -------- | -------- | -------- |\",\"25\":\"| numstars | number | 5 | 否 | 设置评分条的星级总数。 |\",\"26\":\"| rating | number | 0 | 否 | 设置评分条当前评星数。 |\",\"27\":\"| stepsize | number | 0.5 | 否 | 设置评分条的评星步长。 |\",\"28\":\"| indicator | boolean | false | 否 | 设置评分条是否作为一个指示器。<br>true：作为一个指示器，此时用户不可操作。<br>false：不作为一个指示器，此时用户可以操作。 |\",\"29\":\"\",\"30\":\"\",\"31\":\"## 样式\",\"32\":\"\",\"33\":\"除支持[通用样式](js-components-common-styles.md)外，还支持如下样式：\"}",
      "用户拒绝的修改": "设置评分条是否作为指示器。<br>true：作为指示器，此时用户不可操作。<br>false：不作为指示器，此时用户可以操作。",
      "注意事项": "修改前必须确认术语是否真正存在混用情况，当原文使用相同核心词汇（如\"指示器\"）时，应保留原句结构中的量词（如\"一个\"）以避免过度修改，同时需核对上下文属性名（如indicator）与描述文本的对应关系。"
    },
    {
      "defect_id": 503414,
      "sentence": "若同一父组件下有多个设置matchParent的子组件，则多个子组件均会被设置为父组件大小，也即在特定组件（[Flex](./ts-container-flex.md)、[Row](./ts-container-row.md)、[Column](./ts-container-column.md)、[RelativeContainer](./ts-container-relativecontainer.md)）上子组件会被绘制出容器外。",
      "reference_sentence": "LayoutPolicy支持设置三种布局策略：matchParent（自适应父组件布局）、wrapContent（根据内容自适应但不超过父组件尺寸的布局）和fixAtIdealSize（根据内容自适应，可能超过父组件尺寸的布局）。",
      "line_num": 1030,
      "context": "{\"1025\":\">\",\"1026\":\"> - LayoutPolicy支持设置三种布局策略：matchParent（自适应父组件布局）、wrapContent（根据内容自适应但不超过父组件尺寸的布局）和fixAtIdealSize（根据内容自适应，可能超过父组件尺寸的布局）。具体示例代码参见[设置布局策略](./ts-universal-attributes-size.md#示例5设置布局策略)。\",\"1027\":\">\",\"1028\":\"> - 当设置了matchParent组件，其父容器设定了长度时，该组件将以父容器的尺寸为基准，自动调整以适应父组件的布局。若父容器未设定长度，该组件则会等待其父组件所有子组件完成布局后，再进行自身调整以适应父组件布局。\",\"1029\":\"> \",\"1030\":\"> - 若同一父组件下有多个设置matchParent的子组件，则多个子组件均会被设置为父组件大小，也即在特定组件（[Flex](./ts-container-flex.md)、[Row](./ts-container-row.md)、[Column](./ts-container-column.md)、[RelativeContainer](./ts-container-relativecontainer.md)）上子组件会被绘制出容器外。\",\"1031\":\"> \",\"1032\":\"> - matchParent会强制将自身大小设置成父组件大小，因此其设置的其他除宽高比外约束大小的属性将会失效。\",\"1033\":\">\",\"1034\":\"> - LayoutPolicy的生效优先级为宽高比 > [constraintSize](ts-universal-attributes-size.md#constraintsize) > LayoutPolicy。\",\"1035\":\">\"}",
      "用户拒绝的修改": "若同一父组件下有多个设置matchParent的子组件，则多个子组件均会被设置为父组件大小，也即在特定组件（[Flex](./ts-container-flex.md)、[Row](./ts-container-row.md)、[Column](./ts-container-column.md)、[RelativeContainer](./ts-container-relativecontainer.md)）上子组件会被绘制出父组件外。",
      "注意事项": "在修改术语前需确认上下文是否明确区分\"父组件\"与\"容器\"的概念，若文档中已混用且不影响理解时应保留原文表述，避免过度纠正导致技术歧义。"
    },
    {
      "defect_id": 503981,
      "sentence": "随着用户界面复杂度的提升，页面中可能同时存在大量动态生成的UI组件。这些UI任务堆积在单一UI线程中执行，会导致界面启动缓慢、动画丢帧和界面卡顿，直接影响用户体验。",
      "reference_sentence": "随着用户界面复杂度的提升，界面中可能同时存在大量动态生成的UI组件。这些UI任务堆积在单一UI线程中执行，会导致界面启动缓慢、动画丢帧和界面卡顿，直接影响用户体验。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"## 概述\",\"6\":\"\",\"7\":\"在当前版本NDK中，组件的创建与初始化必须在UI线程中执行。这要求开发者在使用接口时要切换回UI线程，增加了代码复杂度，限制了组件创建过程的灵活性与性能。\",\"8\":\"\",\"9\":\"随着用户界面复杂度的提升，界面中可能同时存在大量动态生成的UI组件。这些UI任务堆积在单一UI线程中执行，会导致界面启动缓慢、动画丢帧和界面卡顿，直接影响用户体验。\",\"10\":\"\",\"11\":\"针对上述问题，**新版API引入了多线程支持**，为开发者带来了以下实质性提升：\",\"12\":\"\",\"13\":\"- **彻底简化调用流程** 三方框架开发者可以在自己的框架线程中直接调用组件创建接口，无需手动切换线程或使用任务队列，减少上下文切换与潜在的竞态问题，简化框架与应用的交互逻辑。\",\"14\":\"\"}",
      "用户拒绝的修改": "随着用户界面复杂度的提升，界面中可能同时存在大量动态生成的UI组件。这些UI任务堆积在单一UI线程中执行，会导致界面启动缓慢、动画丢帧和界面卡顿，直接影响用户体验。",
      "注意事项": "在确保术语一致性前需优先确认上下文是否存在专业术语定义差异，若\"页面\"与\"界面\"在技术文档中存在明确区分（如页面指具体视图层/界面指交互系统），应保留原文表述而非机械统一。"
    },
    {
      "defect_id": 501355,
      "sentence": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。",
      "reference_sentence": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为null时，表示没有任务执行。",
      "line_num": 2448,
      "context": "{\"2443\":\"| 名称     | 类型                | 只读 | 可选 | 说明                                                           |\",\"2444\":\"| -------- | ------------------ | ---- | ---- | ------------------------------------------------------------- |\",\"2445\":\"| name<sup>12+</sup> | string   | 否   | 否   | 任务的名字。<br/> **原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。                                                    |\",\"2446\":\"| taskId   | number             | 否   | 否   | 任务的ID。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                     |\",\"2447\":\"| state    | [State](#state10)  | 否   | 否   | 任务的状态。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                    |\",\"2448\":\"| duration | number             | 否   | 是   | 任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。  |\",\"2449\":\"\",\"2450\":\"## ThreadInfo<sup>10+</sup>\",\"2451\":\"\",\"2452\":\"工作线程的内部信息。\",\"2453\":\"\"}",
      "用户拒绝的修改": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为null时，表示没有任务执行。",
      "注意事项": "确保技术文档中术语与编程语言规范严格对齐，当涉及特殊值时必须使用代码层面的标准表述（如null/undefined），并检查上下文参数类型是否支持该值定义。"
    },
    {
      "defect_id": 504488,
      "sentence": "在TaskPool子线程加载Sendable类时抛出异常：SendableItem is not initialized。",
      "reference_sentence": "开发者在运行如下代码时捕获到错误信息:SendableItem is not initialized，Sendable类无法在TaskPool子线程加载。",
      "line_num": 45,
      "context": "{\"40\":\"}\",\"41\":\"```\",\"42\":\"\",\"43\":\"**根因分析**\",\"44\":\"\",\"45\":\"Observed装饰器仅支持在UI主线程使用，不能在子线程、Worker、TaskPool中直接或者间接使用，否则会导致应用功能失效甚至crash。由于sendable.ets文件中使用了Observed装饰器，即使Observed装饰器没有被显示调用也可能被解析执行，当解析到Observed这类UI装饰器时会抛出异常:Observed is not defined，导致当前文件中的其他模块的解析被中断。在TaskPool子线程加载Sendable类时抛出异常：SendableItem is not initialized。\",\"46\":\"\",\"47\":\"**解决方案**\",\"48\":\"\",\"49\":\"将Observed装饰器修饰的类NormalItem剥离到单独的ets文件后，TaskPool子线程再去加载Sendable类SendableItem，应用运行符合预期。\",\"50\":\"\"}",
      "用户拒绝的修改": "在TaskPool子线程初始化Sendable类时抛出异常：SendableItem is not initialized。",
      "注意事项": "严格保持技术术语一致性，修复时需优先沿用原文动词（如\"加载\"），避免擅自替换近义词（如\"初始化\"）；需结合上下文确认术语使用场景，特别注意类生命周期相关动词（加载/初始化/实例化）在编程语境中的精确性差异。"
    },
    {
      "defect_id": 504149,
      "sentence": "控制组件的显示或隐藏。当未设置visibility时，组件默认为显示。",
      "reference_sentence": "控制组件是否可见。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## visibility\",\"10\":\"\",\"11\":\"visibility(value: Visibility): T\",\"12\":\"\",\"13\":\"控制组件的显示或隐藏。当未设置visibility时，组件默认为显示。\",\"14\":\"\",\"15\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"16\":\"\",\"17\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"18\":\"\"}",
      "用户拒绝的修改": "控制组件是否可见。当未设置visibility时，组件默认为可见。",
      "注意事项": "修复时应优先确认上下文中的技术术语一致性（如参数名\"visibility\"对应\"显示/隐藏\"），避免过度统一词汇而忽略实际API定义；需结合参数命名规范和用户使用习惯判断术语适用性，保留原有技术准确性高于语言形式统一。"
    },
    {
      "defect_id": 503290,
      "sentence": "设置后可使组件的布局范围扩展至[组件级安全区（safeAreaPadding）](./ts-universal-attributes-size.md#safeareapadding14)和页面级安全区（状态栏、导航栏、挖孔区）。",
      "reference_sentence": "系统默认非安全区域，包括状态栏、导航栏。",
      "line_num": 658,
      "context": "{\"653\":\"\",\"654\":\"扩展布局安全区域的枚举类型。\",\"655\":\"\",\"656\":\"| 名称     | 值   | 说明                                             |\",\"657\":\"| -------- | ---|------------------------------------------ |\",\"658\":\"| SYSTEM   |  0 |设置后可使组件的布局范围扩展至[组件级安全区（safeAreaPadding）](./ts-universal-attributes-size.md#safeareapadding14)和页面级安全区（状态栏、导航栏、挖孔区）。   |\",\"659\":\"\",\"660\":\"## LayoutSafeAreaEdge<sup>12+</sup>\",\"661\":\"\",\"662\":\"扩展安全区域的方向。\",\"663\":\"\"}",
      "用户拒绝的修改": "设置后可使组件的布局范围扩展至[组件级安全区（safeAreaPadding）](./ts-universal-attributes-size.md#safeareapadding14)和页面级非安全区域（状态栏、导航栏、CUTOUT）。",
      "注意事项": "在修复术语一致性时，需优先确认上下文中的已有定义（如参考句中的\"非安全区域\"），避免擅自替换用户已明确使用的术语（如\"挖孔区\"）；同时应区分\"安全区\"与\"非安全区域\"的逻辑关系，确保修改后的表述与文档整体概念体系一致。"
    },
    {
      "defect_id": 507469,
      "sentence": "setTimeout()和 setInterval()使用相同的ID池，因此技术上可以互相调用clearTimeout()和clearInterval()来清除。然而，为了提高代码的可读性和可维护性，建议分别使用各自对应的清除方法，以避免混淆。",
      "reference_sentence": "setTimeout()和 setInterval()使用相同的ID池，因此技术上可以互相调用clearTimeout()和clearInterval()来清除。",
      "line_num": 191,
      "context": "{\"186\":\"定时器内部使用32位带符号整数存储延时。因此，当延时超过2147483647毫秒（约24.8天）时，定时器会溢出并立即执行。\",\"187\":\"\",\"188\":\"### 定时器冻结\",\"189\":\"定时器的触发受底层任务调度。当前应用被切换到后台后，定时器到期不会触发。应用被重新拉起到前台后，到期定时器会按序触发。可以使用trace查看进程是否还存在调度，如果没有调度，定时器会被冻结。\",\"190\":\"### 定时器ID\",\"191\":\"setTimeout()和 setInterval()使用相同的ID池，因此技术上可以互相调用clearTimeout()和clearInterval()来清除。然而，为了提高代码的可读性和可维护性，建议分别使用各自对应的清除方法，以避免混淆。\"}",
      "用户拒绝的修改": "setTimeout()和 setInterval()使用相同的ID池，因此技术上可以互相调用clearTimeout()和clearInterval()来清除。然而，为了提高代码的可读性和可维护性，建议分别使用setTimeout()对应的clearTimeout()和setInterval()对应的clearInterval()来清除，以避免混淆。",
      "注意事项": "保持原文术语的简洁性，避免过度解释导致冗余信息；优先维护原句的专业表达结构，仅在存在实际歧义时进行补充说明。"
    },
    {
      "defect_id": 508685,
      "sentence": "检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。",
      "reference_sentence": "检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。",
      "line_num": 160,
      "context": "{\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\",\"159\":\"| Bms moduleResPaths is empty. | 插件包moduleResPaths属性为空。 |  检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常                   |\",\"160\":\"| Bms get hapPath failed! Cannot find hap according to BundleName and ModuleName! | 获取hapPath失败。  |   检查PluginComponentTemplate参数中bundleName字段是否有误，检查bundleName字段对应的模块是否已正确安装。               |\",\"161\":\"\",\"162\":\"\",\"163\":\"## 示例（加载PluginComponent）\",\"164\":\"\",\"165\":\"本示例展示`PluginComponent`组件的基础使用方式，需要创建一个`bundleName`为\\\"com.example.user\\\"的[使用方应用](#组件使用方)，和一个`bundleName`为\\\"com.example.provider\\\"的[提供方应用](#组件提供方)。应用项目构建完成后，具体测试步骤如下：\"}",
      "用户拒绝的修改": "检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED, ohos.permission.GET_BUNDLE_INFO, ohos.permission.REQUIRE_FORM权限。",
      "注意事项": "修复时应优先保持上下文格式一致性，避免机械添加空格破坏已有规范；合并重复内容前需确认是否属于必要强调或存在上下文差异，避免过度优化破坏原始信息结构。"
    },
    {
      "defect_id": 507655,
      "sentence": "| storage | string | 否 | 返回[LocalStorage](arkts-localstorage.md)实例对象的函数名。 |",
      "reference_sentence": "| storage | [LocalStorage](arkts-localstorage.md) | 否 | 页面级的UI状态存储。 |",
      "line_num": 180,
      "context": "{\"175\":\"\",\"176\":\"\\\\@Entry可以接受以下三个参数：\",\"177\":\"| 名称   | 类型   | 必填 | 说明                                                           |\",\"178\":\"| ------ | ------ | ---- | ------------------------------------------------------------- |\",\"179\":\"| routeName | string | 否 | 表示作为命名路由页面的名字。 |\",\"180\":\"| storage | string | 否 | 返回[LocalStorage](arkts-localstorage.md)实例对象的函数名。 |\",\"181\":\"| useSharedStorage | boolean | 否 | 是否使用LocalStorage.getShared()接口返回的[LocalStorage](arkts-localstorage.md)实例对象，默认值false。 |\",\"182\":\"\",\"183\":\"\",\"184\":\"  ```ts\",\"185\":\"  import { Component, Entry } from \\\"@ohos.arkui.component\\\"\"}",
      "用户拒绝的修改": "| storage | [LocalStorage](arkts-localstorage.md) | 否 | 页面级的UI状态存储。 |",
      "注意事项": "修复时需严格核对参数类型与上下文定义是否匹配，避免跨参数项直接复制描述；当同一术语存在多义性时，应优先保持当前参数项内部类型声明与说明字段的逻辑自洽。"
    },
    {
      "defect_id": 505957,
      "sentence": "无效的cookie值。",
      "reference_sentence": "无效的URL。",
      "line_num": 45,
      "context": "{\"40\":\"| ARKWEB_INIT_ERROR = 17100001               | 初始化失败。                                        |\",\"41\":\"| ARKWEB_ERROR_UNKNOWN = 17100100            | 未知错误。                                          |\",\"42\":\"| ARKWEB_INVALID_PARAM = 17100101            | 参数无效。                                          |\",\"43\":\"| ARKWEB_SCHEME_REGISTER_FAILED = 17100102   | 注册scheme的配置失败，应该在创建ArkWeb之前注册。    |\",\"44\":\"| ARKWEB_INVALID_URL = 17100103 = 17100104   | 无效的URL。                                         |\",\"45\":\"| ARKWEB_INVALID_COOKIE_VALUE = 17100104     | 无效的cookie值。                                    |\",\"46\":\"| ARKWEB_LIBRARY_OPEN_FAILURE = 17100105     | 打开动态链接库失败。<br>**起始版本：** 15           |\",\"47\":\"| ARKWEB_LIBRARY_SYMBOL_NOT_FOUND = 17100106 | 动态链接库中找不到所需的符号。<br>**起始版本：** 15 |\",\"48\":\"| ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED = 17100107 | CookieManager未初始化。<br>**起始版本：** 20 |\"}",
      "用户拒绝的修改": "无效的URL。",
      "注意事项": "修复时必须严格校验错误码与描述的全局唯一对应关系，优先检查相邻条目是否存在编码重复或冲突，确保修改不会破坏已有错误码体系的完整性。"
    },
    {
      "defect_id": 507066,
      "sentence": "Deque在头部插入删除元素的效率高于ArrayList，而ArrayList随机访问元素的效率高于Deque。",
      "reference_sentence": "Deque和[Queue](js-apis-queue.md)相比，Deque允许在两端执行插入和删除操作，Queue只能在头部删除元素，尾部插入元素。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"Deque（double ended queue）基于循环队列的数据结构实现，支持两端元素的插入和删除，同时具备先进先出以及先进后出的特点。Deque会根据实际需要动态调整容量，每次扩容两倍。\",\"4\":\"\",\"5\":\"Deque和[Queue](js-apis-queue.md)相比，Deque允许在两端执行插入和删除操作，Queue只能在头部删除元素，尾部插入元素。\",\"6\":\"\",\"7\":\"与[ArrayList](js-apis-arraylist.md)相比，它们都支持在两端插入和删除元素，但Deque不支持中间插入。Deque在头部插入删除元素的效率高于ArrayList，而ArrayList随机访问元素的效率高于Deque。\",\"8\":\"\",\"9\":\"**推荐使用场景：** 需要在集合两端频繁增删元素时，推荐使用Deque。\",\"10\":\"\",\"11\":\"文档中使用了泛型，涉及以下泛型标记符：\",\"12\":\"- T：Type，类\"}",
      "用户拒绝的修改": "Deque在头部执行插入和删除操作的效率高于ArrayList，而ArrayList随机访问元素的效率高于Deque。",
      "注意事项": "修复时应确保术语表述与上下文现有用法完全统一，避免在相邻段落中交替使用\"插入删除元素\"和\"执行插入和删除操作\"两种不同表达形式，保持全文档动词短语结构一致性。"
    },
    {
      "defect_id": 504489,
      "sentence": "将Observed装饰器修饰的类NormalItem剥离到单独的ets文件后，TaskPool子线程再去加载Sendable类SendableItem，应用运行符合预期。",
      "reference_sentence": "开发者在运行如下代码时捕获到错误信息:SendableItem is not initialized，Sendable类无法在TaskPool子线程加载。",
      "line_num": 49,
      "context": "{\"44\":\"\",\"45\":\"Observed装饰器仅支持在UI主线程使用，不能在子线程、Worker、TaskPool中直接或者间接使用，否则会导致应用功能失效甚至crash。由于sendable.ets文件中使用了Observed装饰器，即使Observed装饰器没有被显示调用也可能被解析执行，当解析到Observed这类UI装饰器时会抛出异常:Observed is not defined，导致当前文件中的其他模块的解析被中断。在TaskPool子线程加载Sendable类时抛出异常：SendableItem is not initialized。\",\"46\":\"\",\"47\":\"**解决方案**\",\"48\":\"\",\"49\":\"将Observed装饰器修饰的类NormalItem剥离到单独的ets文件后，TaskPool子线程再去加载Sendable类SendableItem，应用运行符合预期。\",\"50\":\"\",\"51\":\"```ts\",\"52\":\"// Index.ets\",\"53\":\"import { taskpool } from '@kit.ArkTS'\",\"54\":\"import { BusinessError } from '@kit.BasicServicesKit'\"}",
      "用户拒绝的修改": "将Observed装饰器修饰的类NormalItem剥离到单独的ets文件后，TaskPool子线程再去初始化Sendable类SendableItem，应用运行符合预期。",
      "注意事项": "保持术语与上下文严格一致，优先使用原文中的技术关键词（如\"加载\"），避免替换为近义词（如\"初始化\"）；修复前需验证目标词汇在问题描述、错误日志和解决方案中的语义连贯性。"
    },
    {
      "defect_id": 506973,
      "sentence": "设置为false时ArkWeb将不再检查私有网络请求是否合法",
      "reference_sentence": "禁用私有网络访问检查功能将跳过此安全检查。",
      "line_num": 9509,
      "context": "{\"9504\":\"          }\",\"9505\":\"        })\",\"9506\":\"      Web({ src: 'www.example.com', controller: this.controller })\",\"9507\":\"        .onControllerAttached(() => {\",\"9508\":\"          // 设置为false时ArkWeb将不再检查私有网络请求是否合法\",\"9509\":\"          webview.WebviewController.enablePrivateNetworkAccess(false);\",\"9510\":\"        })\",\"9511\":\"    }\",\"9512\":\"  }\",\"9513\":\"}\",\"9514\":\"```\"}",
      "用户拒绝的修改": "设置为false时ArkWeb将跳过私有网络访问检查。",
      "注意事项": "修复时必须严格区分操作持续性（如\"不再检查\"隐含永久性）与单次行为（如\"跳过检查\"），优先采用上下文已有固定术语（参考\"跳过此安全检查\"），避免近义词替换导致技术语义偏差。"
    },
    {
      "defect_id": 508691,
      "sentence": "plugin.Push();",
      "reference_sentence": "plugin.Request();",
      "line_num": 272,
      "context": "{\"267\":\"          .fontSize(30)\",\"268\":\"          .width(400)\",\"269\":\"          .height(100)\",\"270\":\"          .margin({ top: 20 })\",\"271\":\"          .onClick(() => {\",\"272\":\"            plugin.Push();\",\"273\":\"            this.message = \\\"Button('Push')\\\";\",\"274\":\"            console.info(\\\"Button('Push')\\\");\",\"275\":\"          })\",\"276\":\"        Text(this.message)\",\"277\":\"          .height(150)\"}",
      "用户拒绝的修改": "plugin.Request();",
      "注意事项": "修复时需全面检查关联上下文（如变量名、日志输出等），确保全局命名一致性，避免仅局部匹配参考句式而忽略整体逻辑连贯性。"
    },
    {
      "defect_id": 508684,
      "sentence": "获取激活的用户ID失败。",
      "reference_sentence": "应用包名为空。",
      "line_num": 154,
      "context": "{\"149\":\"错误码1为默认错误码，错误信息和处理建议详见下表：\",\"150\":\"\",\"151\":\"| 错误信息   | 描述                        | 处理建议 |\",\"152\":\"| ------ | -------------------------- | ----------------- |\",\"153\":\"| package path is empty. | 包路径为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"154\":\"| Query Active OsAccountIds failed! | 获取激活的用户ID失败。 | 检查Account服务是否异常，或检查应用是否具备用户ID查询权限。    |\",\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\",\"159\":\"| Bms moduleResPaths is empty. | 插件包moduleResPaths属性为空。 |  检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常                   |\"}",
      "用户拒绝的修改": "获取激活的帐户ID失败。",
      "注意事项": "修复前需确认上下文术语是否属于同一概念体系，避免将不同领域术语（如系统级\"用户ID\"与应用级\"包名\"）误判为表述不一致；修改时应保留原始技术文档中已明确定义的专有名词。"
    },
    {
      "defect_id": 507654,
      "sentence": "存储。",
      "reference_sentence": "页面级的UI状态存储。",
      "line_num": 179,
      "context": "{\"174\":\"#### ArkTS1.2\",\"175\":\"\",\"176\":\"\\\\@Entry可以接受以下三个参数：\",\"177\":\"| 名称   | 类型   | 必填 | 说明                                                           |\",\"178\":\"| ------ | ------ | ---- | ------------------------------------------------------------- |\",\"179\":\"| routeName | string | 否 | 表示作为命名路由页面的名字。 |\",\"180\":\"| storage | string | 否 | 返回[LocalStorage](arkts-localstorage.md)实例对象的函数名。 |\",\"181\":\"| useSharedStorage | boolean | 否 | 是否使用LocalStorage.getShared()接口返回的[LocalStorage](arkts-localstorage.md)实例对象，默认值false。 |\",\"182\":\"\",\"183\":\"\",\"184\":\"  ```ts\"}",
      "用户拒绝的修改": "页面级的UI状态存储。",
      "注意事项": "修复时应先全局检查文档中其他同类参数的描述结构（如“表示作为...”），确保术语（如“命名路由页面”）和句式与上下文严格一致，避免仅依赖局部信息导致整体风格冲突。"
    },
    {
      "defect_id": 508647,
      "sentence": "必须显式设置组件宽高为非0有效值。",
      "reference_sentence": "创建插件组件，用于显示外部应用提供的UI。",
      "line_num": 63,
      "context": "{\"58\":\"| 参数       | 类型   | 描述                        |\",\"59\":\"| ---------- | ------ | --------------------------- |\",\"60\":\"| source     | string | 组件模板名。                |\",\"61\":\"| bundleName | string | 提供方Ability的bundleName。 |\",\"62\":\"## 属性\",\"63\":\"必须显式设置组件宽高为非0有效值。\",\"64\":\"\",\"65\":\"**说明：**\",\"66\":\"\",\"67\":\"  模板支持两种提供方式：\",\"68\":\"* 1.使用绝对路径进行资源提供：source字段填写模板绝对路径，bundleName不需要填写。仅适用于不需要加载资源的单独模板页面，不建议使用。\"}",
      "用户拒绝的修改": "请显式设置组件宽高为非0有效值。",
      "注意事项": "在修复语言表达一致性时，需优先确认上下文句式是否已统一（如原句\"必须...\"本身隐含祈使语气），避免过度添加\"请\"等冗余修饰词破坏技术文档的简洁性；同时应结合相邻句子的表达风格（如参考句\"创建插件组件...\"采用无主语句式）进行全局适配。"
    },
    {
      "defect_id": 507137,
      "sentence": "HashSet和[TreeSet](js-apis-treeset.md)相比，HashSet中的数据按Hash值排序，即存放元素的顺序和取出的顺序不一致，而TreeSet是有序存放。",
      "reference_sentence": "在HashSet中，仅处理value对象。",
      "line_num": 5,
      "context": "{\"1\":\"# @ohos.util.HashSet (非线性容器HashSet)\",\"2\":\"\",\"3\":\"HashSet基于[HashMap](js-apis-hashmap.md)实现。在HashSet中，仅处理value对象。\",\"4\":\"\",\"5\":\"HashSet和[TreeSet](js-apis-treeset.md)相比，HashSet中的数据按Hash值排序，即存放元素的顺序和取出的顺序不一致，而TreeSet是有序存放。它们集合中的元素都不允许重复，HashSet允许插入null值，TreeSet不建议插入null值，可能会影响排序。\",\"6\":\"\",\"7\":\"**推荐使用场景：** 可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。\",\"8\":\"\",\"9\":\"文档中使用了泛型，涉及以下泛型标记符：\",\"10\":\"- T：Type，类\"}",
      "用户拒绝的修改": "HashSet和[TreeSet](js-apis-treeset.md)相比，HashSet中的数据存放顺序和取出顺序不一致，而TreeSet是有序存放。它们集合中的元素都不允许重复，HashSet允许插入null值，TreeSet不建议插入null值，可能会影响排序。",
      "注意事项": "修复时应严格保留原文的技术性表述（如\"按Hash值排序\"），避免因过度简化删除关键术语导致信息失真；修改前必须完整分析上下文技术背景（如前文HashSet实现原理），确保新增/删除内容与已有技术描述逻辑自洽。"
    },
    {
      "defect_id": 507065,
      "sentence": "与[ArrayList](js-apis-arraylist.md)相比，它们都支持在两端插入和删除元素，但Deque不支持中间插入。",
      "reference_sentence": "Deque和[Queue](js-apis-queue.md)相比，Deque允许在两端执行插入和删除操作，Queue只能在头部删除元素，尾部插入元素。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"Deque（double ended queue）基于循环队列的数据结构实现，支持两端元素的插入和删除，同时具备先进先出以及先进后出的特点。Deque会根据实际需要动态调整容量，每次扩容两倍。\",\"4\":\"\",\"5\":\"Deque和[Queue](js-apis-queue.md)相比，Deque允许在两端执行插入和删除操作，Queue只能在头部删除元素，尾部插入元素。\",\"6\":\"\",\"7\":\"与[ArrayList](js-apis-arraylist.md)相比，它们都支持在两端插入和删除元素，但Deque不支持中间插入。Deque在头部插入删除元素的效率高于ArrayList，而ArrayList随机访问元素的效率高于Deque。\",\"8\":\"\",\"9\":\"**推荐使用场景：** 需要在集合两端频繁增删元素时，推荐使用Deque。\",\"10\":\"\",\"11\":\"文档中使用了泛型，涉及以下泛型标记符：\",\"12\":\"- T：Type，类\"}",
      "用户拒绝的修改": "与[ArrayList](js-apis-arraylist.md)相比，它们都支持在两端执行插入和删除操作，但Deque不支持中间插入。",
      "注意事项": "保持动词结构一致性（统一使用\"执行插入和删除操作\"或\"插入和删除元素\"），避免在相邻段落重复使用完全相同的句式结构，同时需检查上下文是否存在\"两端/头部/尾部\"等术语混用风险。"
    },
    {
      "defect_id": 508450,
      "sentence": "收到来自对端Ability的处理结果code。",
      "reference_sentence": "收到被拉起的Ability发送的数据时触发的回调。",
      "line_num": 106,
      "context": "{\"101\":\"\",\"102\":\"**参数：**\",\"103\":\"\",\"104\":\"| 参数名                       | 类型   | 说明                                                         |\",\"105\":\"| ---------------------------- | ------ | ------------------------------------------------------------ |\",\"106\":\"| code                        | number | 收到来自对端Ability的处理结果code。                          |\",\"107\":\"| want                        | Want | 收到来自对端Ability的处理结果[Want](../../apis-ability-kit/js-apis-app-ability-want.md)。 |\",\"108\":\"\",\"109\":\"### onRelease<sup>(deprecated)</sup>\",\"110\":\"\",\"111\":\"onRelease(callback: [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<number>)\"}",
      "用户拒绝的修改": "收到来自被拉起的Ability的处理结果code。",
      "注意事项": "修复时应严格遵循上下文术语一致性（如\"对端Ability\"在参数说明中已形成固定表述），避免孤立参考单个句子导致概念混淆，需结合完整文档结构验证术语使用场景的统一性。"
    },
    {
      "defect_id": 507162,
      "sentence": "TreeMap的构造函数，支持通过比较函数让元素按照自定义规则排序。",
      "reference_sentence": "TreeMap和[HashMap](js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"### constructor\",\"42\":\"\",\"43\":\"constructor(comparator?:(firstValue: K, secondValue: K) => boolean)\",\"44\":\"\",\"45\":\"TreeMap的构造函数，支持通过比较函数让元素按照自定义规则排序。\",\"46\":\"\",\"47\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"48\":\"\",\"49\":\"**系统能力：** SystemCapability.Utils.Lang\",\"50\":\"\"}",
      "用户拒绝的修改": "TreeMap的构造函数，支持通过比较函数让元素有序存取。",
      "注意事项": "修复时必须严格遵循上下文已有的固定术语表述（如\"有序存取\"），避免将正确的技术性描述（如\"自定义规则排序\"）强行替换为同义词，技术文档应优先保证术语准确性而非语言多样性。"
    },
    {
      "defect_id": 508646,
      "sentence": "## 属性",
      "reference_sentence": "## 子组件",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"| 参数       | 类型   | 描述                        |\",\"59\":\"| ---------- | ------ | --------------------------- |\",\"60\":\"| source     | string | 组件模板名。                |\",\"61\":\"| bundleName | string | 提供方Ability的bundleName。 |\",\"62\":\"## 属性\",\"63\":\"必须显式设置组件宽高为非0有效值。\",\"64\":\"\",\"65\":\"**说明：**\",\"66\":\"\",\"67\":\"  模板支持两种提供方式：\"}",
      "用户拒绝的修改": "## 子组件",
      "注意事项": "修复前需优先验证上下文内容与标题的语义匹配性，避免仅依赖格式一致性忽略实际语境；确认用户文档中是否存在分章节差异化标题规则，确保修改符合局部上下文而非全局机械统一。"
    },
    {
      "defect_id": 508449,
      "sentence": "收到来自对端Ability的数据。",
      "reference_sentence": "收到被拉起的Ability发送的数据时触发的回调。",
      "line_num": 89,
      "context": "{\"84\":\"\",\"85\":\"**参数：**\",\"86\":\"\",\"87\":\"| 参数名                       | 类型   | 必填 | 说明                                                         |\",\"88\":\"| ---------------------------- | ------ | ------ | ------------------------------------------------------- |\",\"89\":\"| data                        | [ReceiveCallback](#receivecallback18) | 否 | 收到来自对端Ability的数据。                 |\",\"90\":\"\",\"91\":\"### onResult<sup>(deprecated)</sup>\",\"92\":\"\",\"93\":\"onResult(callback: [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<{code: number; want?: Want}>)\",\"94\":\"\"}",
      "用户拒绝的修改": "收到被拉起的Ability发送的数据。",
      "注意事项": "修复时应优先检查文档现有术语使用习惯，确保术语替换与上下文保持严格统一；当存在多个合法表述方式时，需通过全局搜索确认文档内部已确立的标准表达。"
    },
    {
      "defect_id": 507412,
      "sentence": "必须与`utf8name`二者选其一。",
      "reference_sentence": "必须与`name`二者选其一。",
      "line_num": 23,
      "context": "{\"18\":\"### 成员变量\",\"19\":\"\",\"20\":\"| 名称 | 描述 | \",\"21\":\"| -------- | -------- |\",\"22\":\"| const char \\\\* [utf8name](#utf8name) | 描述属性键值的可选字符串，UTF8编码。 必须与`name`二者选其一。  | \",\"23\":\"| [JSVM_Value](_j_s_v_m.md#jsvm_value) [name](#name) | 可选的JSVM_Value，指向用作属性键的JavaScript字符串或符号。 必须与`utf8name`二者选其一。  | \",\"24\":\"| [JSVM_Callback](_j_s_v_m.md#jsvm_callback) [method](#method) | 设置此项使属性描述符对象的value属性成为method表示的JavaScript函数。  | \",\"25\":\"| [JSVM_Callback](_j_s_v_m.md#jsvm_callback) [getter](#getter) | 执行对属性的获取访问时调用的函数。  | \",\"26\":\"| [JSVM_Callback](_j_s_v_m.md#jsvm_callback) [setter](#setter) | 执行属性的设置访问时调用的函数。  | \",\"27\":\"| [JSVM_Value](_j_s_v_m.md#jsvm_value) [value](#value) | 如果属性是数据属性，则通过属性的get访问检索到的值。  | \",\"28\":\"| [JSVM_PropertyAttributes](_j_s_v_m.md#jsvm_propertyattributes) [attributes](#attributes) | 与特定属性关联的属性。  | \"}",
      "用户拒绝的修改": "必须与`name`二者选其一。",
      "注意事项": "修复时应同时检查当前变量名与对应变量名的交叉引用关系，确保在\"二者选其一\"逻辑中始终指向正确的互斥变量（如`utf8name`对应`name`），而非单纯依赖前文出现顺序。需通过上下文验证变量配对逻辑的准确性。"
    },
    {
      "defect_id": 508690,
      "sentence": "Button('Push')",
      "reference_sentence": "Button('Register Push Listener')",
      "line_num": 266,
      "context": "{\"261\":\"          .margin({ top: 20 })\",\"262\":\"          .onClick(() => {\",\"263\":\"            plugin.onListener();\",\"264\":\"            console.info(\\\"Button('Register Request Listener')\\\");\",\"265\":\"          })\",\"266\":\"        Button('Push')\",\"267\":\"          .fontSize(30)\",\"268\":\"          .width(400)\",\"269\":\"          .height(100)\",\"270\":\"          .margin({ top: 20 })\",\"271\":\"          .onClick(() => {\"}",
      "用户拒绝的修改": "单击('Push')",
      "注意事项": "修复时应优先核对上下文同类元素的命名习惯（如按钮统一使用名词标签），避免将UI元素标签与事件描述动词（如onClick）混为一谈，确保术语一致性而非机械替换。"
    },
    {
      "defect_id": 508683,
      "sentence": "点击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequestListener”相关信息；",
      "reference_sentence": "点击提供方的“Push”按钮向使用方发送事件，日志中打印“onPushListener”相关信息。",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"本示例展示`PluginComponent`组件的基础使用方式，需要创建一个`bundleName`为\\\"com.example.user\\\"的[使用方应用](#组件使用方)，和一个`bundleName`为\\\"com.example.provider\\\"的[提供方应用](#组件提供方)。应用项目构建完成后，具体测试步骤如下：\",\"166\":\"1. 将两个应用的hap包安装到设备上；\",\"167\":\"2. 打开使用方应用页面，使用方与提供方内容都正确显示；\",\"168\":\"3. 分别点击使用方的“Register Push Listener”按钮和提供方的“Register Request Listener”按钮注册监听；\",\"169\":\"4. 点击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequestListener”相关信息；\",\"170\":\"5. 点击提供方的“Push”按钮向使用方发送事件，日志中打印“onPushListener”相关信息。\",\"171\":\"\",\"172\":\"### 组件使用方\",\"173\":\"\",\"174\":\"使用方应用的`bundleName`为\\\"com.example.user\\\"，包含一个页面。\"}",
      "用户拒绝的修改": "点击使用方的“Request”按钮向提供方发送事件，日志中打印“onRequest”相关信息；",
      "注意事项": "修复时应严格遵循上下文中的命名规范（如\"onXxxListener\"结构），特别注意组件角色（使用方/提供方）与事件方向（发送/接收）的逻辑对应关系，避免仅凭表面文字重复进行修改。"
    },
    {
      "defect_id": 506972,
      "sentence": "设置为false时ArkWeb将不再检查私有网络请求是否合法",
      "reference_sentence": "禁用私有网络访问检查功能将跳过此安全检查。",
      "line_num": 9461,
      "context": "{\"9456\":\"\",\"9457\":\"  build() {\",\"9458\":\"    Column() {\",\"9459\":\"      Web({ src: 'www.example.com', controller: this.controller })\",\"9460\":\"        .onControllerAttached(() => {\",\"9461\":\"          // 设置为false时ArkWeb将不再检查私有网络请求是否合法\",\"9462\":\"          webview.WebviewController.enablePrivateNetworkAccess(false);\",\"9463\":\"        })\",\"9464\":\"    }\",\"9465\":\"  }\",\"9466\":\"}\"}",
      "用户拒绝的修改": "设置为false时ArkWeb将跳过私有网络访问检查。",
      "注意事项": "严格区分技术术语的精确含义，避免将\"功能性描述\"与\"结果性描述\"混用；修复时应优先匹配上下文已有表达范式(如参考句中的\"跳过检查\")，而非简单替换近义词。"
    },
    {
      "defect_id": 507656,
      "sentence": "@Entry({routeName : 'myPage', storage: 'myStorage'})",
      "reference_sentence": "@Entry({ routeName : 'myPage' })",
      "line_num": 190,
      "context": "{\"185\":\"  import { Component, Entry } from \\\"@ohos.arkui.component\\\"\",\"186\":\"  import { LocalStorage } from \\\"@ohos.arkui.stateManagement\\\"\",\"187\":\"\",\"188\":\"  const myStorage: ()=>LocalStorage = ()=>new LocalStorage();\",\"189\":\"\",\"190\":\"  @Entry({routeName : 'myPage', storage: 'myStorage'})\",\"191\":\"  @Component\",\"192\":\"  struct MyComponent {\",\"193\":\"  }\",\"194\":\"  ```\",\"195\":\"\"}",
      "用户拒绝的修改": "@Entry({routeName : 'myPage', storage: myStorage})",
      "注意事项": "修复时必须严格校验上下文变量类型和API参数要求，确保符号引用（如myStorage）与字符串字面量（如'myStorage'）的使用场景符合代码逻辑，避免混淆函数/对象实例与其名称的字符串表达形式。"
    },
    {
      "defect_id": 508810,
      "sentence": "任务的状态。state标识任务的当前状态，不推荐修改此值。",
      "reference_sentence": "任务的状态。状态标识任务的当前状态，不推荐修改此值。",
      "line_num": 2447,
      "context": "{\"2442\":\"\",\"2443\":\"| 名称     | 类型                | 只读 | 可选 | 说明                                                           |\",\"2444\":\"| -------- | ------------------ | ---- | ---- | ------------------------------------------------------------- |\",\"2445\":\"| name<sup>12+</sup> | string   | 否   | 否   | 任务的名字。<br/> **原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。                                                    |\",\"2446\":\"| taskId   | number             | 否   | 否   | 任务的ID。任务的标识符，系统默认提供全局唯一值，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                     |\",\"2447\":\"| state    | [State](#state10)  | 否   | 否   | 任务的状态。state标识任务的当前状态，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                    |\",\"2448\":\"| duration | number             | 否   | 是   | 任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。  |\",\"2449\":\"\",\"2450\":\"## ThreadInfo<sup>10+</sup>\",\"2451\":\"\",\"2452\":\"工作线程的内部信息。\"}",
      "用户拒绝的修改": "任务的状态。状态标识任务的当前状态，不推荐修改此值。",
      "注意事项": "修复时必须严格区分参数名称（如\"state\"）和普通文本描述，参数名称作为代码标识符应保持原文不变，仅对非代码术语进行中文化统一，避免混淆技术要素和自然语言表达。"
    },
    {
      "defect_id": 508466,
      "sentence": "被拉起的Ability扩展意外Crash或被kill时，触发本回调，此时releaseCode为1。",
      "reference_sentence": "被拉起的UIExtensionAbility通过调用`terminateSelfWithResult`或者`terminateSelf`正常退出时，触发本回调函数。",
      "line_num": 133,
      "context": "{\"128\":\"### onError\",\"129\":\"\",\"130\":\"onError(callback:[ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback))\",\"131\":\"\",\"132\":\"被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理，业务错误码详细介绍请参见[UIExtension错误码](../errorcode-uiextension.md)。\",\"133\":\"\",\"134\":\"**系统接口：** 此接口为系统接口。\",\"135\":\"\",\"136\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"137\":\"\",\"138\":\"**参数：**\"}",
      "用户拒绝的修改": "被拉起的UIExtensionAbility意外Crash或被kill时，触发本回调，此时releaseCode为1。",
      "注意事项": "修复时必须严格遵循上下文中的术语定义和接口名称，确保技术概念与代码实现一致，避免跨上下文替换术语；优先核对文档中已有示例和参数命名，确保修改后的表述与当前章节的用词规范完全统一。"
    },
    {
      "defect_id": 508464,
      "sentence": "### onRelease<sup>(deprecated)</sup>onRelease(callback: [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)<number>)",
      "reference_sentence": "### onTerminated<sup>12+</sup>onTerminated(callback: Callback<TerminationInfo>)",
      "line_num": 128,
      "context": "{\"123\":\"\",\"124\":\"| 参数名                       | 类型   | 说明                                                         |\",\"125\":\"| ---------------------------- | ------ | ------------------------------------------------------------ |\",\"126\":\"| releaseCode                        | number | 对端Ability销毁时的code，0为正常销毁，1为异常销毁。                          |\",\"127\":\"\",\"128\":\"### onError\",\"129\":\"\",\"130\":\"onError(callback:[ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback))\",\"131\":\"\",\"132\":\"被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理，业务错误码详细介绍请参见[UIExtension错误码](../errorcode-uiextension.md)。\",\"133\":\"\"}",
      "用户拒绝的修改": "### onTerminated<sup>12+</sup>onTerminated(callback: Callback<TerminationInfo>)",
      "注意事项": "在修复时需严格验证API名称与上下文参数的语义一致性，确保废弃标记与替代方法在版本号和参数类型上完全匹配，避免跨概念替换。"
    },
    {
      "defect_id": 508809,
      "sentence": "任务的ID。任务的标识符，系统默认提供全局唯一值，不推荐修改此值。",
      "reference_sentence": "任务的ID。任务的ID，系统默认提供全局唯一值，不推荐修改此值。",
      "line_num": 2446,
      "context": "{\"2441\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2442\":\"\",\"2443\":\"| 名称     | 类型                | 只读 | 可选 | 说明                                                           |\",\"2444\":\"| -------- | ------------------ | ---- | ---- | ------------------------------------------------------------- |\",\"2445\":\"| name<sup>12+</sup> | string   | 否   | 否   | 任务的名字。<br/> **原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。                                                    |\",\"2446\":\"| taskId   | number             | 否   | 否   | 任务的ID。任务的标识符，系统默认提供全局唯一值，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                     |\",\"2447\":\"| state    | [State](#state10)  | 否   | 否   | 任务的状态。state标识任务的当前状态，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                    |\",\"2448\":\"| duration | number             | 否   | 是   | 任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。  |\",\"2449\":\"\",\"2450\":\"## ThreadInfo<sup>10+</sup>\",\"2451\":\"\"}",
      "用户拒绝的修改": "任务的ID。任务的ID，系统默认提供全局唯一值，不推荐修改此值。",
      "注意事项": "在确保术语一致性的同时，需优先保持语句自然通顺，避免机械重复（如\"任务的ID。任务的ID\"），可通过调整句式结构（如替换为\"该ID\"或补充连接词）平衡规范性与可读性。"
    },
    {
      "defect_id": 508465,
      "sentence": "被拉起的Ability扩展调用terminateSelfWithResult或者terminateSelf时会触发本回调，此时releaseCode为0，即正常销毁。",
      "reference_sentence": "被拉起的UIExtensionAbility通过调用`terminateSelfWithResult`或者`terminateSelf`正常退出时，触发本回调函数。",
      "line_num": 132,
      "context": "{\"127\":\"\",\"128\":\"### onError\",\"129\":\"\",\"130\":\"onError(callback:[ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback))\",\"131\":\"\",\"132\":\"被拉起的Ability扩展在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理，业务错误码详细介绍请参见[UIExtension错误码](../errorcode-uiextension.md)。\",\"133\":\"\",\"134\":\"**系统接口：** 此接口为系统接口。\",\"135\":\"\",\"136\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"137\":\"\"}",
      "用户拒绝的修改": "被拉起的UIExtensionAbility通过调用`terminateSelfWithResult`或者`terminateSelf`正常退出时，触发本回调函数，此时releaseCode为0，即正常销毁。",
      "注意事项": "修复时应严格校验上下文术语使用一致性，优先匹配问题句子所在段落及相邻接口描述中的命名规范，并核对系统能力(SystemCapability)对应的官方接口定义，避免跨概念替换。"
    },
    {
      "defect_id": 508797,
      "sentence": "由于har/Index模块中存在顶层代码进行ServiceManager的初始化，如果在main模块中进行import路径展开，将不会执行har/Index模块，也就不会进行ServiceManager的初始化，可能导致业务异常。",
      "reference_sentence": "在import语句中，跳过中间的依赖路径，直接依赖变量对应的模块，即为import路径展开。",
      "line_num": 491,
      "context": "{\"486\":\"ServiceManager is not inited.\",\"487\":\"```\",\"488\":\"\",\"489\":\"**产生的副作用**\",\"490\":\"\",\"491\":\"由于har/Index模块中存在顶层代码进行ServiceManager的初始化，如果在main模块中进行import路径展开，将不会执行har/Index模块，也就不会进行ServiceManager的初始化，可能导致业务异常。\",\"492\":\"\",\"493\":\"**优化方式**\",\"494\":\"\",\"495\":\"需要开发者根据业务需要排查跳过执行顶层代码带来的影响，并进行对应修改。\",\"496\":\"\"}",
      "用户拒绝的修改": "由于har/Index模块中存在顶层代码进行ServiceManager的初始化，如果在main模块中进行import路径展开，将不会执行har/Index模块，也就不会进行ServiceManager的初始化，导致业务异常。",
      "注意事项": "修复时应优先保留原句的语义准确性，避免过度追求词汇统一而删除关键限定词（如\"可能\"），需结合上下文判断是否存在实际逻辑差异。"
    },
    {
      "defect_id": 508773,
      "sentence": "导入可能会修改内置的全局对象或原型链的第三方库时，确认该第三方库的行为是符合预期的",
      "reference_sentence": "导入可能会修改内置的全局对象或原型链的第三方库时，确认该第三方库的行为是符合预期的",
      "line_num": 279,
      "context": "{\"274\":\"\",\"275\":\"修改内置的全局对象或原型链，影响其他代码运行。\",\"276\":\"\",\"277\":\"**优化方式**\",\"278\":\"\",\"279\":\"导入可能会修改内置的全局对象或原型链的第三方库时，确认该第三方库的行为是符合预期的。\",\"280\":\"\",\"281\":\"### 循环依赖\",\"282\":\"\",\"283\":\"**副作用产生场景**\",\"284\":\"\"}",
      "用户拒绝的修改": "导入可能会操作内置的全局对象或原型链的第三方库时，确认该第三方库的行为是符合预期的",
      "注意事项": "在替换术语前必须严格检查上下文中的既有用词规范，优先沿用文档已确立的核心动词（如\"修改\"），避免使用同义词替换导致表达断裂。"
    },
    {
      "defect_id": 508516,
      "sentence": "为空代表取消订阅所有扩展Ability同步注册后触发回调<br> 非空代表取消订阅同步对应回调。",
      "reference_sentence": "为空代表取消订阅所有扩展Ability异步注册后触发回调。<br> 非空代表取消订阅异步对应回调。",
      "line_num": 393,
      "context": "{\"388\":\"**参数：**\",\"389\":\"\",\"390\":\"| 参数名  | 类型 | 必填 | 说明 |\",\"391\":\"| ------ | -------- | ----- | ------- |\",\"392\":\"| type   | string | 是 | 取消订阅扩展Ability发生同步注册回调。 |\",\"393\":\"| callback | Callback\\\\<UIExtensionProxy\\\\> | 否 | 为空代表取消订阅所有扩展Ability同步注册后触发回调<br> 非空代表取消订阅同步对应回调。 |\",\"394\":\"\",\"395\":\"## 示例\",\"396\":\"\",\"397\":\"### 示例1 (加载UIExtension)\",\"398\":\"\"}",
      "用户拒绝的修改": "为空代表取消订阅所有扩展Ability异步注册后触发回调。<br> 非空代表取消订阅异步对应回调。",
      "注意事项": "修复时必须严格核对上下文参数描述（如参数type的\"同步注册回调\"说明），确保术语一致性优先于表面文字对称，避免脱离上下文孤立修改术语类型。"
    },
    {
      "defect_id": 508770,
      "sentence": "修改应用级ArkUI组件的状态变量信息",
      "reference_sentence": "修改应用级ArkUI组件的状态变量信息",
      "line_num": 168,
      "context": "{\"163\":\"\",\"164\":\"### 修改应用级ArkUI组件的状态变量信息\",\"165\":\"\",\"166\":\"**副作用产生场景**\",\"167\":\"\",\"168\":\"顶层代码或导入的模块可能会直接**修改应用级ArkUI组件的状态变量信息**，改变全局状态，引发副作用。\",\"169\":\"\",\"170\":\"```typescript\",\"171\":\"// module.ets\",\"172\":\"export let data = \\\"data from module\\\"\",\"173\":\"AppStorage.setOrCreate(\\\"SomeAppStorageVar\\\", 200); // 修改应用全局的UI状态\"}",
      "用户拒绝的修改": "操作应用级ArkUI组件的状态变量信息",
      "注意事项": "在保持术语一致性的修复过程中，必须严格检查上下文已有用词模式（如\"修改\"在标题/正文/代码注释中的重复使用），避免同义词替换破坏技术文档的术语统一性；优先采用原文高频词汇而非近义词，确保技术概念表述的严谨性和可搜索性。"
    },
    {
      "defect_id": 508769,
      "sentence": "操作全局变量",
      "reference_sentence": "操作全局变量",
      "line_num": 118,
      "context": "{\"113\":\"200\",\"114\":\"```\",\"115\":\"\",\"116\":\"**产生的副作用**\",\"117\":\"\",\"118\":\"模块加载时直接修改全局变量 `globalThis.someGlobalVar` 的值，**会影响其他依赖该变量的模块或代码**。\",\"119\":\"\",\"120\":\"**优化方式**\",\"121\":\"\",\"122\":\"将可能引发副作用的代码放在函数或方法内部，只有在需要时再执行，而不是在模块加载时立即执行。\",\"123\":\"\"}",
      "用户拒绝的修改": "修改全局变量",
      "注意事项": "修改前必须核对上下文中的现有术语，优先保持原文用词一致性而非替换同义词，避免因未识别原句在文档中的实际存在位置导致误改。"
    },
    {
      "defect_id": 508796,
      "sentence": "2. 在模块解析阶段会通过深度优先遍历的方式建立变量的绑定关系，main.ets中使用的har.One变量是由har/src/main/ets/NumberString.ets导出的，而由于使用了export *的写法，建立变量的绑定关系时需要递归去进行变量名的匹配，**导致模块解析耗时增加**。",
      "reference_sentence": "在import语句中，跳过中间的依赖路径，直接依赖变量对应的模块，即为import路径展开。",
      "line_num": 400,
      "context": "{\"395\":\"console.info(\\\"har NumberString.ets execute.\\\");\",\"396\":\"```\",\"397\":\"\",\"398\":\"1. 如果main.ets只需要依赖har中的NumberString模块，import xxx from \\\"har\\\"的写法会导致har整条链路上的模块被解析、执行，**导致模块解析及执行耗时增加**。上述例子中的har/Index、OtherModule1、OtherModule2、Utils、OtherModule3、OtherModule4、NumberString模块均会被解析、执行。\",\"399\":\"\",\"400\":\"2. 在模块解析阶段会通过深度优先遍历的方式建立变量的绑定关系，main.ets中使用的har.One变量是由har/src/main/ets/NumberString.ets导出的，而由于使用了export *的写法，建立变量的绑定关系时需要递归去进行变量名的匹配，**导致模块解析耗时增加**。\",\"401\":\"在上述例子中，会先查找 `har/Index.ets` 文件。该文件中有多个 `export *` 语句，因此会依次检查 `OtherModule1` 和 `OtherModule2` 是否导出 `One` 变量。接着，找到 `Utils` 模块，该模块也有 `export *` 语句，因此会继续检查 `OtherModule3` 和 `OtherModule4`，最终确定 `One` 变量是从 `NumberString` 模块导出的。\",\"402\":\"\",\"403\":\"优化方式：改为如下的代码写法，跳过中间的依赖路径，直接依赖变量对应的模块。\",\"404\":\"\",\"405\":\"```typescript\"}",
      "用户拒绝的修改": "2. 在模块解析阶段会通过深度优先遍历的方式建立变量的绑定关系，main.ets中使用的har.One变量是由har/src/main/ets/NumberString.ets导出的，而由于使用了export *的写法，建立变量的绑定关系时需要递归去进行变量名的匹配，导致模块解析耗时增加。",
      "注意事项": "修复语言表达一致性时应严格保留原始格式标记（如加粗符号** **），避免在修改文本内容时误删文档特有的格式规范元素。"
    },
    {
      "defect_id": 508774,
      "sentence": "由于使用到延迟加载（lazy import）特性，会导致模块变量在使用到时再执行对应的模块，模块中的一些全局变量修改行为也会延迟，可能会导致运行结果不符合预期",
      "reference_sentence": "由于使用到延迟加载（lazy import）特性，会导致模块变量在使用到时再执行对应的模块，模块中的一些全局变量修改行为也会延迟，可能会导致运行结果不符合预期",
      "line_num": 341,
      "context": "{\"336\":\"data from module\",\"337\":\"```\",\"338\":\"\",\"339\":\"**产生的副作用**\",\"340\":\"\",\"341\":\"由于使用到延迟加载（lazy import）特性，会导致模块变量在使用到时再执行对应的模块，模块中的一些全局变量修改行为也会延迟，可能会导致运行结果不符合预期。\",\"342\":\"\",\"343\":\"**优化方式**\",\"344\":\"\",\"345\":\"将可能引发副作用的代码放在函数或方法内部，只有在需要时再执行，而不是在模块加载时立即执行。\",\"346\":\"\"}",
      "用户拒绝的修改": "由于使用到延迟加载（lazy import）特性，会导致模块变量在使用到时再执行对应的模块，模块中的一些全局变量操作行为也会延迟，可能会导致运行结果不符合预期",
      "注意事项": "修复时应严格遵循文档已有术语一致性，优先沿用上下文及参考句子中的原有用词（如\"修改\"），避免使用近义词替换导致表述割裂；修改前需交叉核对问题句所在段落及关联段落的关键词使用情况。"
    },
    {
      "defect_id": 508811,
      "sentence": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。不推荐修改此值。",
      "reference_sentence": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。不推荐修改此值。",
      "line_num": 2448,
      "context": "{\"2443\":\"| 名称     | 类型                | 只读 | 可选 | 说明                                                           |\",\"2444\":\"| -------- | ------------------ | ---- | ---- | ------------------------------------------------------------- |\",\"2445\":\"| name<sup>12+</sup> | string   | 否   | 否   | 任务的名字。<br/> **原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。                                                    |\",\"2446\":\"| taskId   | number             | 否   | 否   | 任务的ID。任务的标识符，系统默认提供全局唯一值，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                     |\",\"2447\":\"| state    | [State](#state10)  | 否   | 否   | 任务的状态。state标识任务的当前状态，不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。                                                    |\",\"2448\":\"| duration | number             | 否   | 是   | 任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。不推荐修改此值。<br/> **原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。  |\",\"2449\":\"\",\"2450\":\"## ThreadInfo<sup>10+</sup>\",\"2451\":\"\",\"2452\":\"工作线程的内部信息。\",\"2453\":\"\"}",
      "用户拒绝的修改": "任务执行至当前所用的时间，默认为0，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务。不推荐修改此值。",
      "注意事项": "保持技术文档的术语一致性，修改时需严格区分\"没有任务\"（任务不存在）与\"没有任务执行\"（存在任务但未运行）的技术差异，确保修改后的表述既符合上下文逻辑又能准确传递技术语义。"
    },
    {
      "defect_id": 508511,
      "sentence": "用于在双方建立连接成功后，组件使用方取消订阅被拉起的Ability发生异步注册的场景。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。",
      "line_num": 357,
      "context": "{\"352\":\"\",\"353\":\"### off('asyncReceiverRegister')<sup>11+</sup>\",\"354\":\"\",\"355\":\"off(type: 'asyncReceiverRegister', callback?: Callback\\\\<UIExtensionProxy\\\\>): void\",\"356\":\"\",\"357\":\"用于在双方建立连接成功后，组件使用方取消订阅被拉起的Ability发生异步注册的场景。\",\"358\":\"\",\"359\":\"> **说明：**\",\"360\":\">\",\"361\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"362\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方向取消订阅被拉起的Ability发生异步注册的场景。",
      "注意事项": "在修复术语一致性时，需优先确认上下文中的固定术语（如\"使用方\"为组件调用方的固定命名），避免将普通词汇（如\"方向\"）误判为术语；修改前应交叉验证参考句子的实际应用场景，确保语义逻辑与术语用法双重匹配。"
    },
    {
      "defect_id": 508772,
      "sentence": "修改内置的全局对象或原型链",
      "reference_sentence": "修改内置的全局对象或原型链",
      "line_num": 275,
      "context": "{\"270\":\"}\",\"271\":\"```\",\"272\":\"\",\"273\":\"**产生的副作用**\",\"274\":\"\",\"275\":\"修改内置的全局对象或原型链，影响其他代码运行。\",\"276\":\"\",\"277\":\"**优化方式**\",\"278\":\"\",\"279\":\"导入可能会修改内置的全局对象或原型链的第三方库时，确认该第三方库的行为是符合预期的。\",\"280\":\"\"}",
      "用户拒绝的修改": "操作内置的全局对象或原型链",
      "注意事项": "修改时必须严格检查上下文术语一致性，优先沿用原文高频词汇避免同义词替换；技术文档应保持\"修改/操作\"等动词的精准区分，避免在相同语义场景混用不同表述。"
    },
    {
      "defect_id": 508498,
      "sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。",
      "line_num": 263,
      "context": "{\"258\":\"\",\"259\":\"send(data: Record\\\\<string, Object\\\\>): void\",\"260\":\"\",\"261\":\"用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。\",\"262\":\"\",\"263\":\"> **说明：**\",\"264\":\">\",\"265\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"266\":\"\",\"267\":\"**系统接口：** 此接口为系统接口。\",\"268\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方被拉起的Ability发送数据的场景，提供异步发送数据。",
      "注意事项": "在修复术语一致性时，需优先确认上下文是否存在领域专用术语或固定搭配，避免将技术名词误判为表述不一致；同时应结合问题上下文和参考句子交叉验证，确保修改后的词汇在语义和逻辑层面均符合原始技术场景。"
    },
    {
      "defect_id": 509230,
      "sentence": "半模态全屏样式的系统转场方式",
      "reference_sentence": "半模态可以在独立子窗口中展示",
      "line_num": 88,
      "context": "{\"83\":\"| placement<sup>18+</sup> | [Placement](ts-appendix-enums.md#placement8) | 否 | 设置半模态popup样式弹窗相对于目标的显示位置。<br />默认值：Placement.Bottom<br />**说明：** <br /> 1. popup样式弹窗在确保指定位置能容纳弹窗尺寸的前提下，优先依据设定的placement展示弹窗。若不可行，则遵循先垂直翻转，后尝试90°水平旋转的规则调整显示位置，以预设方向为下方为例，调整顺序依次为：下、上、右、左。<br />2. 如果设置的对齐方式导致组件布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至组件完全显示在窗口内。<br />3. 如果在四个方向上均无法容纳当前的popup样式弹窗，处理方式遵循开发者设置的placementOnTarget属性：<br />1）若属性值为true，将依据设定的placement，向其镜像方向平移，直至弹窗能够完全显示。<br />2）若属性值为false，则在四个方向中，选择能够完全展示弹窗宽度且剩余高度最大的方向，通过调整半模态高度以适应当前方向，确保弹窗能够放下，同时保持预设placement对应的对齐方式不变。 <br />**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"84\":\"| placementOnTarget<sup>18+</sup> | boolean | 否 | 半模态popup样式弹窗在当前窗口下，四个方向均无法容纳该弹窗大小时，设置是否允许其覆盖在目标节点上。<br /> 默认值：true <br />**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。|\",\"85\":\"| effectEdge<sup>18+</sup> | number | 否 | 设置半模态面板内容区边缘回弹效果，支持单边生效。<br/>**默认值**：默认双边生效，即[EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).START \\\\| [EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).END（即数值3）。<br />**说明：**<br />1. 仅上边缘生效：[EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).START。<br/>2. 仅下边缘生效：[EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).END。<br/>3. 双边生效：[EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).START \\\\| [EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).END（即数值3）。<br/>4. 双边不生效：[EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).START & [EffectEdge](ts-container-scrollable-common.md#effectedge18枚举说明).END（即数值0）。<br />**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"86\":\"| showInSubWindow<sup>19+</sup> | boolean                                  | 否    | 半模态是否在独立子窗中显示。<br>默认值：false<br>**说明：** <br>1. 若属性值为true，半模态可以在独立子窗口中展示，并且可以超过应用窗口范围。<br>2. 若属性值为false，半模态只能在应用窗口范围内展示。<br>3. 不建议在showInSubWindow为true的弹窗嵌套显示另一个showInSubWindow为true的弹窗，半模态可能会影响其他组件行为。<br>4. 不建议在showInSubWindow为true的弹窗中使用CalendarPicker、CalendarPickerDialog、DatePickerDialog、TextPickerDialog、TimePickerDialog等picker组件，半模态会影响上述组件行为。<br>5. 半模态显示期间该属性不支持动态切换。<br/>**原子化服务API：** 从API version 19开始，该接口支持在原子化服务中使用。 |\",\"87\":\"| enableFloatingDragBar<sup>20+</sup>              | boolean | 否   | 控制条是否悬浮显示，true为悬浮显示，false为不悬浮显示。<br />默认值：false <br /> **说明：** <br>悬浮效果只在控制条显示的场景生效，且控制条不占位。<br /> title传入[CustomBuilder](ts-types.md#custombuilder8)时enableFloatingDragBar始终为false。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"88\":\"| modalTransition | [ModalTransition](ts-types.md#modaltransition10) | 否 | 半模态全屏样式的系统转场方式。<br/>默认值：ModalTransition.DEFAULT<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"89\":\"\",\"90\":\"## SheetSize枚举说明\",\"91\":\"\",\"92\":\"指定半模态的高度。\",\"93\":\"\"}",
      "用户拒绝的修改": "模态全屏样式的系统转场方式",
      "注意事项": "修复时必须严格保持术语一致性，保留\"半模态\"等关键前缀，避免混淆概念；修改前需交叉验证上下文所有相关术语用法，确保技术名词与文档整体表述完全统一。"
    },
    {
      "defect_id": 508771,
      "sentence": "修改应用级ArkUI组件的状态变量信息",
      "reference_sentence": "修改应用级ArkUI组件的状态变量信息",
      "line_num": 207,
      "context": "{\"202\":\"test200\",\"203\":\"```\",\"204\":\"\",\"205\":\"**产生的副作用**\",\"206\":\"\",\"207\":\"模块加载时直接修改AppStorage中SomeAppStorageVar的值，**会影响其他依赖该变量的模块或代码**。\",\"208\":\"\",\"209\":\"ArkUI组件的状态变量信息可以通过一些应用级接口修改，详见[ArkUI状态管理接口文档](../ui/state-management/arkts-state-management-overview.md)。\",\"210\":\"\",\"211\":\"**优化方式**\",\"212\":\"\"}",
      "用户拒绝的修改": "操作AppStorage中SomeAppStorageVar的值",
      "注意事项": "保持技术文档动词术语一致性，修改时需严格匹配上下文已有动词(如\"修改\")，避免同义词替换破坏专业表述连贯性；调整前必须检查3层上下文内是否存在重复用词模式。"
    },
    {
      "defect_id": 512498,
      "sentence": "未知错误，内部状态错误等。",
      "reference_sentence": "未知错误。",
      "line_num": 64,
      "context": "{\"59\":\"**起始版本：** 12\",\"60\":\"\",\"61\":\"| 枚举项                                     | 描述                                                |\",\"62\":\"| ------------------------------------------ | --------------------------------------------------- |\",\"63\":\"| ARKWEB_BLANKLESS_SUCCESS = 0               | 成功。                                               |\",\"64\":\"| ARKWEB_BLANKLESS_ERR_UNKNOWN = -1          | 未知错误，内部状态错误等。                             |\",\"65\":\"| ARKWEB_BLANKLESS_ERR_INVALID_ARGS = -2     | 参数不合法。                                          |\",\"66\":\"| ARKWEB_BLANKLESS_ERR_CONTROLLER_NOT_INITED = -3 | web controller未绑定组件。                       |\",\"67\":\"| ARKWEB_BLANKLESS_ERR_KEY_NOT_MATCH = -4    | 未匹配到key值，对于OH_NativeArkWeb_SetBlanklessLoadingWithKey需与OH_NativeArkWeb_GetBlanklessInfoWithKey配套使用并且key值一致，否则返回该错误码。 |\",\"68\":\"| ARKWEB_BLANKLESS_ERR_SIGNIFICANT_CHANGE = -5 | 当相似度比较低（<0.33）时系统会判定为跳变太大，OH_NativeArkWeb_SetBlanklessLoadingWithKey接口启用插帧不成功。 |\"}",
      "用户拒绝的修改": "未知错误。",
      "注意事项": "修复时应严格区分\"用词不一致\"与\"补充说明\"的区别，当原文使用逗号分隔的并列结构时，需保留完整语义信息（如错误类型枚举），仅修改真正重复冗余的表述，避免过度简化导致技术信息丢失。"
    },
    {
      "defect_id": 511609,
      "sentence": "this.textState = '继续';",
      "reference_sentence": "this.textState = '下载';",
      "line_num": 88,
      "context": "{\"83\":\"            progressButtonWidth: this.buttonWidth,\",\"84\":\"            content: this.textState,\",\"85\":\"            enable: this.enableState,\",\"86\":\"            clickCallback: () => {\",\"87\":\"              if (this.textState && !this.isRunning && this.progressIndex < 100) {\",\"88\":\"                this.textState = '继续';\",\"89\":\"              }\",\"90\":\"              this.isRunning = !this.isRunning;\",\"91\":\"              let timer = setInterval(() => {\",\"92\":\"                if (this.isRunning) {\",\"93\":\"                  if (this.progressIndex === 100) {\"}",
      "用户拒绝的修改": "this.textState = '下载';",
      "注意事项": "修复前必须结合上下文确认变量值的语义场景，区分状态切换导致的合理文本变化与真正的用词不一致，避免将动态状态变量误判为概念不统一。"
    },
    {
      "defect_id": 507470,
      "sentence": "Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。",
      "reference_sentence": "Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置和获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。",
      "line_num": 284,
      "context": "{\"279\":\"  ```\",\"280\":\"\",\"281\":\"\",\"282\":\"## 其他说明\",\"283\":\"\",\"284\":\"Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。如果开发者想自定义视频播放，请参考[视频播放](../media/media/video-playback.md)。\",\"285\":\"\",\"286\":\"## 相关实例\",\"287\":\"\",\"288\":\"针对Video组件开发，有以下相关实例可供参考：\",\"289\":\"\"}",
      "用户拒绝的修改": "Video组件已经封装好了视频播放的基础能力，开发者无需进行视频实例的创建，视频信息的设置和获取，只需要设置数据源以及基础信息即可播放视频，相对扩展能力较弱。",
      "注意事项": "在修改并列动词结构时，需优先确认技术文档中是否已存在固定术语搭配（如\"设置获取\"可能是特定领域术语），若上下文未明确显示逻辑歧义，应保留原有表述避免过度修正。"
    },
    {
      "defect_id": 511611,
      "sentence": "this.textState = '继续';",
      "reference_sentence": "this.textState = '下载';",
      "line_num": 202,
      "context": "{\"197\":\"            progressButtonWidth: this.buttonWidth,\",\"198\":\"            content: this.textState,\",\"199\":\"            enable: this.enableState,\",\"200\":\"            clickCallback: () => {\",\"201\":\"              if (this.textState && !this.isRunning && this.progressIndex < 100) {\",\"202\":\"                this.textState = '继续';\",\"203\":\"              }\",\"204\":\"              this.isRunning = !this.isRunning;\",\"205\":\"              let timer = setInterval(() => {\",\"206\":\"                if (this.isRunning) {\",\"207\":\"                  if (this.progressIndex === 100) {\"}",
      "用户拒绝的修改": "this.textState = '下载';",
      "注意事项": "修复前必须结合上下文确认变量值的动态变化是否属于业务逻辑需求（如状态切换），避免将合理的动态文本差异误判为不一致问题；优先检查相邻代码段是否存在条件判断触发值变更，确保不破坏功能逻辑。"
    },
    {
      "defect_id": 511610,
      "sentence": "this.textState = '继续';",
      "reference_sentence": "this.textState = '下载';",
      "line_num": 149,
      "context": "{\"144\":\"            progressButtonWidth: this.buttonWidth,\",\"145\":\"            content: this.textState,\",\"146\":\"            enable: this.enableState,\",\"147\":\"            clickCallback: () => {\",\"148\":\"              if (this.textState && !this.isRunning && this.progressIndex < 100) {\",\"149\":\"                this.textState = '继续';\",\"150\":\"              }\",\"151\":\"              this.isRunning = !this.isRunning;\",\"152\":\"              let timer = setInterval(() => {\",\"153\":\"                if (this.isRunning) {\",\"154\":\"                  if (this.progressIndex === 100) {\"}",
      "用户拒绝的修改": "this.textState = '下载';",
      "注意事项": "修复前必须结合上下文确认变量状态变化逻辑，区分\"下载\"和\"继续\"代表不同操作阶段的情况；避免机械统一词汇，应优先保持语义准确性而非形式一致性。"
    },
    {
      "defect_id": 507439,
      "sentence": "Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考[VideoController使用说明](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#videocontroller)。",
      "reference_sentence": "Video组件[属性](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#属性)主要用于设置视频的播放形式。",
      "line_num": 187,
      "context": "{\"182\":\"```\",\"183\":\"\",\"184\":\"\",\"185\":\"## Video控制器使用\",\"186\":\"\",\"187\":\"Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考[VideoController使用说明](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#videocontroller)。\",\"188\":\"\",\"189\":\"- 默认控制器\",\"190\":\"\",\"191\":\"  默认的控制器支持视频的开始、暂停、进度调整、全屏显示四项基本功能。\",\"192\":\"\"}",
      "用户拒绝的修改": "使用Video控制器控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考[VideoController使用说明](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#videocontroller)。",
      "注意事项": "修复时应优先保持原句功能描述型句式（\"主要用于...\"），仅在操作步骤场景强制使用祈使句，需结合上下文判断章节属性（功能说明类内容保留陈述句，操作指引类内容使用祈使句）。"
    },
    {
      "defect_id": 511629,
      "sentence": "下拉菜单选中某一项的回调类型。表示选中项的值。",
      "reference_sentence": "下拉菜单选中某一项的回调。",
      "line_num": 191,
      "context": "{\"186\":\"**参数：**\",\"187\":\"\",\"188\":\"| 参数名            | 类型     | 必填 | 说明                       |\",\"189\":\"|:--------------|:-------|:---|:-------------------------|\",\"190\":\"| selectedIndex   | number | 是  | 下拉菜单选中某一项的回调类型。表示选中项的索引。 |\",\"191\":\"| selectedContent | string | 否  | 下拉菜单选中某一项的回调类型。表示选中项的值。  |\",\"192\":\"\",\"193\":\"## SubHeaderV2OperationType\",\"194\":\"\",\"195\":\"操作区元素样式。\",\"196\":\"\"}",
      "用户拒绝的修改": "下拉菜单选中某一项的回调。表示选中项的值。",
      "注意事项": "修复时必须结合参数表\"类型\"列的字段信息，当参数类型已在独立字段声明时，说明部分应统一使用\"回调\"而非\"回调类型\"，避免因机械匹配参考句式而破坏表格结构的语义完整性。"
    },
    {
      "defect_id": 508795,
      "sentence": "下文将通过示例来说明import路径展开优化性能的原理：",
      "reference_sentence": "在import语句中，跳过中间的依赖路径，直接依赖变量对应的模块，即为import路径展开。",
      "line_num": 374,
      "context": "{\"369\":\"\",\"370\":\"### 原理\",\"371\":\"\",\"372\":\"在import语句中，跳过中间的依赖路径，直接依赖变量对应的模块，即为import路径展开。\",\"373\":\"\",\"374\":\"下文将通过示例来说明import路径展开优化性能的原理：\",\"375\":\"\",\"376\":\"```typescript\",\"377\":\"// main.ets\",\"378\":\"import * as har from \\\"har\\\"\",\"379\":\"console.info(har.One); // 这里的One变量是har/src/main/ets/NumberString.ets导出的\"}",
      "用户拒绝的修改": "本文将通过示例来说明import路径展开优化性能的原理：",
      "注意事项": "修复时应确保指代一致性，优先沿用上下文已确立的术语（如\"下文\"对应后置示例），避免引入新概念（如\"本文\"）；同时需结合段落结构分析指代对象的具体位置，保持技术文档的逻辑连贯性。"
    },
    {
      "defect_id": 511467,
      "sentence": "是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true",
      "reference_sentence": "是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true",
      "line_num": 235,
      "context": "{\"230\":\"| background   | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的背景。<br />默认值跟随buttonStyle。                                               |\",\"231\":\"| fontColor    | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的字体颜色。<br />默认值跟随buttonStyle。                                             |\",\"232\":\"| buttonStyle  | [ButtonStyleMode](ts-basic-components-button.md#buttonstylemode11枚举说明) | 否  | @Trace | 按钮的样式。<br />默认值：2in1设备为ButtonStyleMode.NORMAL，其他设备为ButtonStyleMode.TEXTUAL。 |\",\"233\":\"| role         | [ButtonRole](ts-basic-components-button.md#buttonrole12枚举说明)           | 否  | @Trace | 按钮的角色。<br />默认值：ButtonRole.NORMAL。                                          |\",\"234\":\"| defaultFocus | boolean                                                                | 否  | @Trace | 是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false                         |\",\"235\":\"| enabled       | boolean                                                                | 否  | @Trace | 是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true                                                         |\",\"236\":\"\",\"237\":\"> **说明：**\",\"238\":\">\",\"239\":\"> buttonStyle和role优先级高于fontColor和background。如果buttonStyle和role设置的是默认值，那么fontColor和background可生效。\",\"240\":\">\"}",
      "用户拒绝的修改": "是否可用。<br/>true：按钮为可用。<br/>false：按钮为不可用。<br />默认值：true",
      "注意事项": "修复时应优先保持与上下文描述方式一致（如统一使用\"是\"而非\"为\"），并参考同一文档中其他同类参数的定义格式（如defaultFocus参数使用\"是\"的描述结构）。"
    },
    {
      "defect_id": 511620,
      "sentence": "该示例实现了一个简单的带加载进度的文本下载按钮。",
      "reference_sentence": "## 示例",
      "line_num": 109,
      "context": "{\"104\":\"## 事件\",\"105\":\"不支持[通用事件](ts-component-general-events.md)。\",\"106\":\"\",\"107\":\"## 示例\",\"108\":\"\",\"109\":\"该示例实现了一个简单的带加载进度的文本下载按钮。\",\"110\":\"```ts\",\"111\":\"import { LengthMetrics, ProgressButtonV2 } from '@kit.ArkUI';\",\"112\":\"\",\"113\":\"@Entry\",\"114\":\"@ComponentV2\"}",
      "用户拒绝的修改": "## 示例：带加载进度的文本下载按钮",
      "注意事项": "修复时应严格匹配标题与内容中的术语形式（如\"示例\"与\"该示例\"需保持词性一致），避免在标题层级添加冗余描述；需结合上下文检查现有标题格式（如## 示例后无冒号），确保修改后的结构与文档整体风格统一。"
    },
    {
      "defect_id": 507438,
      "sentence": "## Video控制器使用",
      "reference_sentence": "## 创建视频组件Video通过调用接口来创建，接口调用形式如下：",
      "line_num": 185,
      "context": "{\"180\":\"  }\",\"181\":\"}\",\"182\":\"```\",\"183\":\"\",\"184\":\"\",\"185\":\"## Video控制器使用\",\"186\":\"\",\"187\":\"Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考[VideoController使用说明](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#videocontroller)。\",\"188\":\"\",\"189\":\"- 默认控制器\",\"190\":\"\"}",
      "用户拒绝的修改": "## 视频控制器使用",
      "注意事项": "在统一标题格式时需优先识别并保留上下文中的专有名词（如\"Video\"），避免将技术术语中必要的英文部分误转为中文；同时应结合参考句子的混合格式（如\"## 创建视频组件Video...\"）判断文档允许中英文并存规则。"
    },
    {
      "defect_id": 511511,
      "sentence": "按钮的点击事件。<br />默认无事件。",
      "reference_sentence": "按钮的点击事件。<br/>默认无事件。",
      "line_num": 268,
      "context": "{\"263\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"264\":\"\",\"265\":\"| 名称           | 类型                                                                     | 必填 | 说明                                                                          |\",\"266\":\"|:-------------|:-----------------------------------------------------------------------|:---|:----------------------------------------------------------------------------|\",\"267\":\"| content      | [ResourceStr](ts-types.md#resourcestr)                                 | 是  | 按钮的内容。                                                                      |\",\"268\":\"| action       | [AdvancedDialogV2ButtonAction](#advanceddialogv2buttonaction)          | 否  | 按钮的点击事件。<br />默认无事件。                                                        |\",\"269\":\"| background   | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                              | 否  | 按钮的背景。<br /> 默认值跟随buttonStyle。                                              |\",\"270\":\"| fontColor    | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                              | 否  | 按钮的字体颜色。<br />默认值跟随buttonStyle。                                             |\",\"271\":\"| buttonStyle  | [ButtonStyleMode](ts-basic-components-button.md#buttonstylemode11枚举说明) | 否  | 按钮的样式。<br />默认值：2in1设备为ButtonStyleMode.NORMAL，其他设备为ButtonStyleMode.TEXTUAL。 |\",\"272\":\"| role         | [ButtonRole](ts-basic-components-button.md#buttonrole12枚举说明)           | 否  | 按钮的角色。<br />默认值：ButtonRole.NORMAL。                                          |\",\"273\":\"| defaultFocus | boolean                                                                | 否  | 是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false                         |\"}",
      "用户拒绝的修改": "按钮的点击事件。<br/>默认无事件。",
      "注意事项": "修复前需确认上下文中的分行符使用规范是否统一，避免将合法但格式略有差异的<br />和<br/>误判为不一致；优先保留用户原有符号格式，仅在明确违反文档规范时调整。"
    },
    {
      "defect_id": 509358,
      "sentence": "发布共享配置项。发布后，发布者和允许列表中指定的应用可以访问该共享配置项。如果要发布的URI已经存在，则更新对应的共享配置项。如果发布的配置项中存在任一URI的长度超出上限或者格式校验失败，则当前发布操作失败。只有发布者才允许更新共享配置项，每个应用支持最多32个共享配置。",
      "reference_sentence": "发布共享配置项。发布后，发布者和允许列表中指定的应用可以访问该共享配置项。如果要发布的URI已经存在，则更新对应的共享配置项。如果发布的配置项中存在任一URI的长度超出上限或者格式校验失败，则当前发布操作失败。只有发布者才允许更新共享配置项，每个应用支持最多32个共享配置。",
      "line_num": 271,
      "context": "{\"266\":\"\",\"267\":\"### publish<sup>20+</sup>\",\"268\":\"\",\"269\":\"publish(data: ProxyData[], config: DataProxyConfig): Promise&lt;DataProxyResult[]&gt;\",\"270\":\"\",\"271\":\"发布共享配置项。发布后，发布者和允许列表中指定的应用可以访问该共享配置项。如果要发布的URI已经存在，则更新对应的共享配置项。如果发布的配置项中存在任一URI的长度超出上限或者格式校验失败，则当前发布操作失败。只有发布者才允许更新共享配置项，每个应用支持最多32个共享配置。\",\"272\":\"\",\"273\":\"**系统能力：**  SystemCapability.DistributedDataManager.DataShare.Consumer\",\"274\":\"\",\"275\":\"**参数：**\",\"276\":\"\"}",
      "用户拒绝的修改": "发布者发布共享配置项。发布后，发布者和允许列表中指定的应用可以访问该共享配置项。如果要发布的URI已经存在，则更新对应的共享配置项。如果发布的配置项中存在任一URI的长度超出上限或者格式校验失败，则当前发布操作失败。只有发布者才允许更新共享配置项，每个应用支持最多32个共享配置。",
      "注意事项": "在统一术语时应优先保持句子的语法结构完整性，避免将动词短语强行添加主语；需结合上下文判断术语实际指代对象，技术文档中接口描述通常以动宾结构开头，无需强制补全主语。"
    },
    {
      "defect_id": 508509,
      "sentence": "用于在双方建立连接成功后，组件使用方订阅被拉起的Ability发生异步注册的场景。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。",
      "line_num": 315,
      "context": "{\"310\":\"\",\"311\":\"### on('asyncReceiverRegister')<sup>11+</sup>\",\"312\":\"\",\"313\":\"on(type: 'asyncReceiverRegister', callback: Callback\\\\<UIExtensionProxy\\\\>): void\",\"314\":\"\",\"315\":\"用于在双方建立连接成功后，组件使用方订阅被拉起的Ability发生异步注册的场景。\",\"316\":\"\",\"317\":\"> **说明：**\",\"318\":\">\",\"319\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"320\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方向订阅被拉起的Ability发生异步注册的场景。",
      "注意事项": "在确保术语一致性时，需优先识别并保留原文中已定义的固定搭配（如\"使用方\"），避免混淆名词性短语（如\"组件使用方\"）与介词结构（如\"向...方向\"）的语法差异，同时结合上下文参考句验证修改合理性。"
    },
    {
      "defect_id": 511424,
      "sentence": "TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, ischecked?: boolean, checkAction?: (isChecked: boolean) => void, onCheckedChange?: Callback<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})",
      "reference_sentence": "TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, ischecked?: boolean, checkAction?: (isChecked: boolean) => void, onCheckedChange?: Callback<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})",
      "line_num": 30,
      "context": "{\"25\":\"不支持[通用属性](ts-component-general-attributes.md)。\",\"26\":\"\",\"27\":\"## TipsDialog\",\"28\":\"\",\"29\":\"\",\"30\":\"TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, ischecked?: boolean, checkAction?: (isChecked: boolean) => void, onCheckedChange?: Callback\\\\<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})\",\"31\":\"\",\"32\":\"\",\"33\":\"提示弹出框，即为带图形确认框，必要时可通过图形化方式展现确认框。\",\"34\":\"\",\"35\":\"\"}",
      "用户拒绝的修改": "TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, checked?: boolean, checkAction?: (checked: boolean) => void, onCheckedChange?: Callback<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})",
      "注意事项": "修复参数命名不一致时需全面检查所有相关参数和回调函数，确保命名同步修改；优先遵循组件现有命名习惯而非机械统一，若参数存在关联回调（如checkAction/isChecked），需保持参数名与回调参数命名完全一致。"
    },
    {
      "defect_id": 511512,
      "sentence": "是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false",
      "reference_sentence": "是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true",
      "line_num": 273,
      "context": "{\"268\":\"| action       | [AdvancedDialogV2ButtonAction](#advanceddialogv2buttonaction)          | 否  | 按钮的点击事件。<br />默认无事件。                                                        |\",\"269\":\"| background   | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                              | 否  | 按钮的背景。<br /> 默认值跟随buttonStyle。                                              |\",\"270\":\"| fontColor    | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                              | 否  | 按钮的字体颜色。<br />默认值跟随buttonStyle。                                             |\",\"271\":\"| buttonStyle  | [ButtonStyleMode](ts-basic-components-button.md#buttonstylemode11枚举说明) | 否  | 按钮的样式。<br />默认值：2in1设备为ButtonStyleMode.NORMAL，其他设备为ButtonStyleMode.TEXTUAL。 |\",\"272\":\"| role         | [ButtonRole](ts-basic-components-button.md#buttonrole12枚举说明)           | 否  | 按钮的角色。<br />默认值：ButtonRole.NORMAL。                                          |\",\"273\":\"| defaultFocus | boolean                                                                | 否  | 是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false                         |\",\"274\":\"| enabled       | boolean                                                                | 否  | 是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true                                                         |\",\"275\":\"\",\"276\":\"## 示例\",\"277\":\"\",\"278\":\"### 示例1（上图下文弹出框）\"}",
      "用户拒绝的修改": "是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br/>默认值：false",
      "注意事项": "修复时应优先确保内容逻辑一致性，避免过度关注次要格式差异（如HTML标签空格）；需结合上下文检查其他参数的分行符使用惯例，保持同一文档内的格式统一性。"
    },
    {
      "defect_id": 511465,
      "sentence": "按钮的点击事件。<br />默认无事件。",
      "reference_sentence": "默认无事件。",
      "line_num": 229,
      "context": "{\"224\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"225\":\"\",\"226\":\"| 名称           | 类型                                                                     | 必填 | 装饰器类型  | 说明                                                                          |\",\"227\":\"|:-------------|:-----------------------------------------------------------------------|:---|:-------|:----------------------------------------------------------------------------|\",\"228\":\"| content      | [ResourceStr](ts-types.md#resourcestr)                                 | 是  | @Trace | 按钮的内容。                                                                      |\",\"229\":\"| action       | [AdvancedDialogV2ButtonAction](#advanceddialogv2buttonaction)          | 否  | @Trace | 按钮的点击事件。<br />默认无事件。                                                        |\",\"230\":\"| background   | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的背景。<br />默认值跟随buttonStyle。                                               |\",\"231\":\"| fontColor    | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的字体颜色。<br />默认值跟随buttonStyle。                                             |\",\"232\":\"| buttonStyle  | [ButtonStyleMode](ts-basic-components-button.md#buttonstylemode11枚举说明) | 否  | @Trace | 按钮的样式。<br />默认值：2in1设备为ButtonStyleMode.NORMAL，其他设备为ButtonStyleMode.TEXTUAL。 |\",\"233\":\"| role         | [ButtonRole](ts-basic-components-button.md#buttonrole12枚举说明)           | 否  | @Trace | 按钮的角色。<br />默认值：ButtonRole.NORMAL。                                          |\",\"234\":\"| defaultFocus | boolean                                                                | 否  | @Trace | 是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false                         |\"}",
      "用户拒绝的修改": "按钮的单击事件。<br />默认无事件。",
      "注意事项": "修复术语一致性时应首先检查上下文及相邻条目是否使用相同表述，若文档已存在统一术语（如\"点击\"）且无歧义，则无需强制替换为近义词（如\"单击\"），避免过度修正破坏文档内部一致性。"
    },
    {
      "defect_id": 508510,
      "sentence": "用于在双方建立连接成功后，组件使用方订阅被拉起的Ability发生同步注册的场景。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供同步发送数据。",
      "line_num": 336,
      "context": "{\"331\":\"\",\"332\":\"### on('syncReceiverRegister')<sup>11+</sup>\",\"333\":\"\",\"334\":\"on(type: 'syncReceiverRegister', callback: Callback\\\\<UIExtensionProxy\\\\>): void;\",\"335\":\"\",\"336\":\"用于在双方建立连接成功后，组件使用方订阅被拉起的Ability发生同步注册的场景。\",\"337\":\"\",\"338\":\"> **说明：**\",\"339\":\">\",\"340\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"341\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方向订阅被拉起的Ability发生同步注册的场景。",
      "注意事项": "在修复术语一致性时，必须严格区分上下文中的核心术语（如\"使用方\"与\"使用方向\"），优先匹配问题句子所在段落已存在的术语形式，避免跨上下文参考导致误改。"
    },
    {
      "defect_id": 508499,
      "sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供同步发送数据。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供同步发送数据。",
      "line_num": 281,
      "context": "{\"276\":\"\",\"277\":\"### sendSync<sup>11+</sup>\",\"278\":\"\",\"279\":\"sendSync(data: Record\\\\<string, Object\\\\>): Record\\\\<string, Object\\\\>\",\"280\":\"\",\"281\":\"用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供同步发送数据。\",\"282\":\"\",\"283\":\"> **说明：**\",\"284\":\">\",\"285\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"286\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方被拉起的Ability发送数据的场景，提供同步发送数据。",
      "注意事项": "在修复术语一致性时，需优先确认上下文是否存在特定技术术语定义（如\"组件使用方向\"可能是专有名词），避免将合法术语误判为表述不一致；若参考句子与问题句子表述完全相同，应保留原词而非强制统一。"
    },
    {
      "defect_id": 507440,
      "sentence": "  默认的控制器支持视频的开始、暂停、进度调整、全屏显示四项基本功能。",
      "reference_sentence": "当视频完整出现时会自动播放，用户点击视频区域则会暂停播放，同时显示播放进度条，通过拖动播放进度条指定视频播放到具体位置。",
      "line_num": 191,
      "context": "{\"186\":\"\",\"187\":\"Video控制器主要用于控制视频的状态，包括播放、暂停、停止以及设置进度等，详细使用请参考[VideoController使用说明](../reference/apis-arkui/arkui-ts/ts-media-components-video.md#videocontroller)。\",\"188\":\"\",\"189\":\"- 默认控制器\",\"190\":\"\",\"191\":\"  默认的控制器支持视频的开始、暂停、进度调整、全屏显示四项基本功能。\",\"192\":\"\",\"193\":\"  ```ts\",\"194\":\"  // xxx.ets\",\"195\":\"  @Entry\",\"196\":\"  @Component\"}",
      "用户拒绝的修改": "  默认的控制器支持视频的播放、暂停、进度调整、全屏显示四项基本功能。",
      "注意事项": "修复前需仔细核对上下文术语一致性，优先采用问题上下文中的规范表述；当参考句子与当前语境存在功能表述差异时，应以问题段落所在章节的用词体系为准进行判断。"
    },
    {
      "defect_id": 508512,
      "sentence": "用于在双方建立连接成功后，组件使用方取消订阅被拉起的Ability发生同步注册的场景。",
      "reference_sentence": "用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供同步发送数据。",
      "line_num": 378,
      "context": "{\"373\":\"\",\"374\":\"### off('syncReceiverRegister')<sup>11+</sup>\",\"375\":\"\",\"376\":\"off(type: 'syncReceiverRegister', callback?: Callback\\\\<UIExtensionProxy\\\\>): void\",\"377\":\"\",\"378\":\"用于在双方建立连接成功后，组件使用方取消订阅被拉起的Ability发生同步注册的场景。\",\"379\":\"\",\"380\":\"> **说明：**\",\"381\":\">\",\"382\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"383\":\"\"}",
      "用户拒绝的修改": "用于在双方建立连接成功后，组件使用方向取消订阅被拉起的Ability发生同步注册的场景。",
      "注意事项": "在修改术语一致性时，需先确认上下文是否存在明确的术语规范（如参考句中的\"使用方向\"特指数据流向场景），避免将不同语义场景的词汇强制统一；若上下文无明确冲突，应优先保留原句核心术语不作修改。"
    },
    {
      "defect_id": 509807,
      "sentence": "检查接口传入的proxyData数组中是否有proxyData的value的长度超过4096字节。",
      "reference_sentence": "proxyData中value长度超过4096字节。",
      "line_num": 139,
      "context": "{\"134\":\"\",\"135\":\"**处理步骤**\",\"136\":\"\",\"137\":\"1. 检查接口传入的URI数组或者proxyData数组中是否有URI的长度超过256字节。\",\"138\":\"\",\"139\":\"2. 检查接口传入的proxyData数组中是否有proxyData的value的长度超过4096字节。\",\"140\":\"\",\"141\":\"3. 检查接口传入的URI数组的长度是否超过32。\",\"142\":\"\",\"143\":\"4. 检查接口传入的proxyData数组的长度是否超过32。\",\"144\":\"\"}",
      "用户拒绝的修改": "检查接口传入的proxyData数组中是否有proxyData中value的长度超过4096字节。",
      "注意事项": "修复时应确保上下文所有相关表述统一使用相同结构（如统一使用\"proxyData中value\"而非混用\"的/中\"），并同步检查相邻条款的语法一致性。"
    },
    {
      "defect_id": 512499,
      "sentence": "参数不合法。",
      "reference_sentence": "参数无效。",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"| 枚举项                                     | 描述                                                |\",\"62\":\"| ------------------------------------------ | --------------------------------------------------- |\",\"63\":\"| ARKWEB_BLANKLESS_SUCCESS = 0               | 成功。                                               |\",\"64\":\"| ARKWEB_BLANKLESS_ERR_UNKNOWN = -1          | 未知错误，内部状态错误等。                             |\",\"65\":\"| ARKWEB_BLANKLESS_ERR_INVALID_ARGS = -2     | 参数不合法。                                          |\",\"66\":\"| ARKWEB_BLANKLESS_ERR_CONTROLLER_NOT_INITED = -3 | web controller未绑定组件。                       |\",\"67\":\"| ARKWEB_BLANKLESS_ERR_KEY_NOT_MATCH = -4    | 未匹配到key值，对于OH_NativeArkWeb_SetBlanklessLoadingWithKey需与OH_NativeArkWeb_GetBlanklessInfoWithKey配套使用并且key值一致，否则返回该错误码。 |\",\"68\":\"| ARKWEB_BLANKLESS_ERR_SIGNIFICANT_CHANGE = -5 | 当相似度比较低（<0.33）时系统会判定为跳变太大，OH_NativeArkWeb_SetBlanklessLoadingWithKey接口启用插帧不成功。 |\"}",
      "用户拒绝的修改": "参数无效。",
      "注意事项": "在修复用词不一致问题前，需全面核对文档中所有相同语义的术语使用情况（如检查所有错误码描述中的\"参数不合法/无效\"），优先保持上下文内部统一性而非局部替换。"
    },
    {
      "defect_id": 511466,
      "sentence": "是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false",
      "reference_sentence": "是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false",
      "line_num": 234,
      "context": "{\"229\":\"| action       | [AdvancedDialogV2ButtonAction](#advanceddialogv2buttonaction)          | 否  | @Trace | 按钮的点击事件。<br />默认无事件。                                                        |\",\"230\":\"| background   | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的背景。<br />默认值跟随buttonStyle。                                               |\",\"231\":\"| fontColor    | [ColorMetrics](../js-apis-arkui-graphics.md#colormetrics12)                                | 否  | @Trace | 按钮的字体颜色。<br />默认值跟随buttonStyle。                                             |\",\"232\":\"| buttonStyle  | [ButtonStyleMode](ts-basic-components-button.md#buttonstylemode11枚举说明) | 否  | @Trace | 按钮的样式。<br />默认值：2in1设备为ButtonStyleMode.NORMAL，其他设备为ButtonStyleMode.TEXTUAL。 |\",\"233\":\"| role         | [ButtonRole](ts-basic-components-button.md#buttonrole12枚举说明)           | 否  | @Trace | 按钮的角色。<br />默认值：ButtonRole.NORMAL。                                          |\",\"234\":\"| defaultFocus | boolean                                                                | 否  | @Trace | 是否为默认焦点。<br/>true：按钮是默认焦点。<br/>false：按钮不是默认焦点。<br />默认值：false                         |\",\"235\":\"| enabled       | boolean                                                                | 否  | @Trace | 是否可用。<br/>true：按钮可用。<br/>false：按钮不可用。<br />默认值：true                                                         |\",\"236\":\"\",\"237\":\"> **说明：**\",\"238\":\">\",\"239\":\"> buttonStyle和role优先级高于fontColor和background。如果buttonStyle和role设置的是默认值，那么fontColor和background可生效。\"}",
      "用户拒绝的修改": "是否为默认焦点。<br/>true：按钮为默认焦点。<br/>false：按钮不为默认焦点。<br />默认值：false",
      "注意事项": "在统一术语时应优先保持上下文已有表达习惯，若参考句子和相邻参数描述都使用\"是/不是\"结构，则不宜强制改为\"为/不为\"，避免破坏文档整体一致性。"
    },
    {
      "defect_id": 512511,
      "sentence": "假设应用的Web页面在2025/06/10会进行大幅改动，比如商品促销活动等，该提案清除白屏插帧优化缓存",
      "reference_sentence": "清除指定key值页面无白屏优化缓存，本接口只清除缓存。",
      "line_num": 9600,
      "context": "{\"9595\":\"import { webview } from '@kit.ArkWeb';\",\"9596\":\"\",\"9597\":\"export default class EntryAbility extends UIAbility {\",\"9598\":\"  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {\",\"9599\":\"    console.log(\\\"EntryAbility onCreate\\\");\",\"9600\":\"    // 假设应用的Web页面在2025/06/10会进行大幅改动，比如商品促销活动等，该提案清除白屏插帧优化缓存\",\"9601\":\"    webview.WebviewController.initializeWebEngine();\",\"9602\":\"    let pageUpdateTime: number = Date.UTC(2025, 5, 10, 0, 0, 0, 0);\",\"9603\":\"    let pageUpdateTime1: number = Date.UTC(2025, 5, 11, 0, 0, 0, 0);\",\"9604\":\"    let pageUpdateTimeNow: number = Date.now();\",\"9605\":\"    if (pageUpdateTimeNow > pageUpdateTime && pageUpdateTime < pageUpdateTime1) {\"}",
      "用户拒绝的修改": "假设应用的Web页面在2025/06/10会进行大幅改动，比如商品促销活动等，该提案清除无白屏优化缓存。",
      "注意事项": "修改术语时必须严格核对代码接口命名规范，确保\"无白屏优化缓存\"与API方法webview.WebviewController.initializeWebEngine()实际功能匹配，避免将技术实现层概念（插帧优化）与功能描述层术语（无白屏）混用。"
    },
    {
      "defect_id": 511628,
      "sentence": "下拉菜单选中某一项的回调类型。表示选中项的索引。",
      "reference_sentence": "下拉菜单选中某一项的回调。",
      "line_num": 190,
      "context": "{\"185\":\"\",\"186\":\"**参数：**\",\"187\":\"\",\"188\":\"| 参数名            | 类型     | 必填 | 说明                       |\",\"189\":\"|:--------------|:-------|:---|:-------------------------|\",\"190\":\"| selectedIndex   | number | 是  | 下拉菜单选中某一项的回调类型。表示选中项的索引。 |\",\"191\":\"| selectedContent | string | 否  | 下拉菜单选中某一项的回调类型。表示选中项的值。  |\",\"192\":\"\",\"193\":\"## SubHeaderV2OperationType\",\"194\":\"\",\"195\":\"操作区元素样式。\"}",
      "用户拒绝的修改": "下拉菜单选中某一项的回调。表示选中项的索引。",
      "注意事项": "修复时应结合上下文验证技术术语的准确性，避免机械替换（如\"回调类型\"可能指参数类型声明，需核对参数表数据类型是否与\"类型\"字段匹配）；优先保持技术文档参数定义与代码实现的严格对应，而非单纯追求字面一致性。"
    },
    {
      "defect_id": 512500,
      "sentence": "web controller未绑定组件。",
      "reference_sentence": "初始化失败。",
      "line_num": 66,
      "context": "{\"61\":\"| 枚举项                                     | 描述                                                |\",\"62\":\"| ------------------------------------------ | --------------------------------------------------- |\",\"63\":\"| ARKWEB_BLANKLESS_SUCCESS = 0               | 成功。                                               |\",\"64\":\"| ARKWEB_BLANKLESS_ERR_UNKNOWN = -1          | 未知错误，内部状态错误等。                             |\",\"65\":\"| ARKWEB_BLANKLESS_ERR_INVALID_ARGS = -2     | 参数不合法。                                          |\",\"66\":\"| ARKWEB_BLANKLESS_ERR_CONTROLLER_NOT_INITED = -3 | web controller未绑定组件。                       |\",\"67\":\"| ARKWEB_BLANKLESS_ERR_KEY_NOT_MATCH = -4    | 未匹配到key值，对于OH_NativeArkWeb_SetBlanklessLoadingWithKey需与OH_NativeArkWeb_GetBlanklessInfoWithKey配套使用并且key值一致，否则返回该错误码。 |\",\"68\":\"| ARKWEB_BLANKLESS_ERR_SIGNIFICANT_CHANGE = -5 | 当相似度比较低（<0.33）时系统会判定为跳变太大，OH_NativeArkWeb_SetBlanklessLoadingWithKey接口启用插帧不成功。 |\"}",
      "用户拒绝的修改": "web controller未初始化。",
      "注意事项": "修复时必须严格匹配上下文已有术语（如错误码描述中的\"未绑定组件\"），避免将专业表述替换为近义词（如\"未初始化\"），需优先保持与同类型错误描述的词汇一致性。"
    },
    {
      "defect_id": 512898,
      "sentence": "本次页面无白屏加载的预测信息，供应用确定是否启用无白屏加载。",
      "reference_sentence": "清除指定key值页面无白屏优化缓存，本接口只清除缓存。",
      "line_num": 94,
      "context": "{\"89\":\"\",\"90\":\"### ArkWeb_BlanklessInfo()\",\"91\":\"\",\"92\":\"## 概述\",\"93\":\"\",\"94\":\"本次页面无白屏加载的预测信息，供应用确定是否启用无白屏加载。\",\"95\":\"\",\"96\":\"**起始版本：** 20\",\"97\":\"\",\"98\":\"### 成员变量\",\"99\":\"\"}",
      "用户拒绝的修改": "本次界面无白屏加载的预测信息，供应用确定是否启用无白屏加载。",
      "注意事项": "修复时应严格遵循上下文术语一致性（如“页面”在参考句和上下文中均为固定技术概念），避免对专业术语进行无依据的同义词替换，需结合技术场景判断“页面”与“界面”的精确使用边界。"
    },
    {
      "defect_id": 517370,
      "sentence": "加载时显示的占位图，支持本地图片（png、jpg、bmp、svg、gif和heif类型），支持[PixelMap](../../apis-image-kit/arkts-apis-image-PixelMap.md)类型图片，不支持网络图片。",
      "reference_sentence": "ArkTS卡片上不支持http://等网络相关路径前缀和file://路径前缀的字符串。",
      "line_num": 124,
      "context": "{\"119\":\"\",\"120\":\"**参数：**\",\"121\":\"\",\"122\":\"| 参数名 | 类型                                                     | 必填 | 说明                                                         |\",\"123\":\"| ------ | -------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"124\":\"| value  | string&nbsp;\\\\|&nbsp;[Resource](ts-types.md#resource)&nbsp;\\\\|&nbsp;[PixelMap](../../apis-image-kit/arkts-apis-image-PixelMap.md)<sup>12+</sup> | 是   | 加载时显示的占位图，支持本地图片（png、jpg、bmp、svg、gif和heif类型），支持[PixelMap](../../apis-image-kit/arkts-apis-image-PixelMap.md)类型图片，不支持网络图片。<br/>默认值：null<br/>由有效值（可正常解析并加载的图片资源）切换为无效值（无法解析或加载的图片路径）时，组件应保持显示此前成功加载的图片内容，不进行清除或重置操作。 |\",\"125\":\"\",\"126\":\"### objectFit\",\"127\":\"\",\"128\":\"objectFit(value: ImageFit)\",\"129\":\"\"}",
      "用户拒绝的修改": "加载时显示的占位图，支持本地图片（png、jpg、bmp、svg、gif和heif类型），支持[PixelMap](../../apis-image-kit/arkts-apis-image-PixelMap.md)类型图片，不支持http://等网络相关路径前缀和file://路径前缀的字符串。",
      "注意事项": "修复时应确保补充说明与原句的抽象层级一致，避免将概括性描述（如\"网络图片\"）替换为具体实现细节（如路径前缀），同时需严格验证参考句子的上下文适用性，防止跨场景误用。"
    },
    {
      "defect_id": 512854,
      "sentence": "必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。",
      "reference_sentence": "必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套使用，且必须在触发加载页面的接口前或者onLoadIntercept中使用。",
      "line_num": 378,
      "context": "{\"373\":\"\",\"374\":\"设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。\",\"375\":\"\",\"376\":\"> **说明：**\",\"377\":\">\",\"378\":\"> - 必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。\",\"379\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"380\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"381\":\"\",\"382\":\"**起始版本：** 20\",\"383\":\"\"}",
      "用户拒绝的修改": "必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发加载页面的接口前或者onLoadIntercept中调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。",
      "注意事项": "修复时应全面核查上下文逻辑一致性，避免局部修改引发前后矛盾；优先采用用户提供的参考句式确保术语、时序描述精准匹配，尤其注意接口调用顺序（如前/后）与配套关系的统一性。"
    },
    {
      "defect_id": 513231,
      "sentence": "Not system application to call the interface.",
      "reference_sentence": "Not system application to call the interface.",
      "line_num": 4825,
      "context": "{\"4820\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[通知错误码](./errorcode-notification.md)。\",\"4821\":\"\",\"4822\":\"| 错误码ID | 错误信息                                                     |\",\"4823\":\"| -------- | ------------------------------------------------------------ |\",\"4824\":\"| 201      | Permission denied.     |  \",\"4825\":\"| 202      | Not system application to call the interface.                                      |  \",\"4826\":\"| 1600001  | Internal error.                     |\",\"4827\":\"| 1600002  | Marshalling or unmarshalling error. |\",\"4828\":\"| 1600003  | Failed to connect to the service.          |\",\"4829\":\"| 1600012  | No memory space.                          |\",\"4830\":\"| 17700001 | The specified bundle name was not found. |\"}",
      "用户拒绝的修改": "非系统应用调用接口。",
      "注意事项": "修复时必须优先核对API文档中对应的原始术语和命名规范，保持技术术语与官方API定义完全一致，避免擅自添加翻译或修改专业表述。"
    },
    {
      "defect_id": 518184,
      "sentence": "对话框中title字段的字体最大放大倍数为2。",
      "reference_sentence": "操作菜单中title字段的字体最大放大倍数为2。",
      "line_num": 73,
      "context": "{\"68\":\"\",\"69\":\"## 对话框 (showDialog)\",\"70\":\"\",\"71\":\"对话框通过UIContext中的getPromptAction方法获取到PromptAction对象，再通过该对象调用[showDialog](../reference/apis-arkui/js-apis-arkui-UIContext.md#showdialog)接口实现，支持在回调或开发者自定义类中使用。\",\"72\":\"\",\"73\":\"对话框中title字段的字体最大放大倍数为2。\",\"74\":\"\",\"75\":\"创建并显示对话框，对话框响应后异步返回选中按钮在buttons数组中的索引。\",\"76\":\"\",\"77\":\"```ts\",\"78\":\"// xxx.ets\"}",
      "用户拒绝的修改": "操作菜单中title字段的字体最大放大倍数为2。",
      "注意事项": "修复时必须严格核对问题上下文中的原始术语和组件名称（如\"对话框\"），确保概念一致性；涉及UI组件描述时需结合代码片段和章节标题验证修改准确性，避免混淆不同控件类型。"
    },
    {
      "defect_id": 518631,
      "sentence": "返回单个水波形状的灰度Mask。",
      "reference_sentence": "返回椭圆形状的径向分布效果的灰度Mask。",
      "line_num": 1010,
      "context": "{\"1005\":\"\",\"1006\":\"**返回值：**\",\"1007\":\"\",\"1008\":\"| 类型                          | 说明                                               |\",\"1009\":\"| ----------------------------- | ------------------------------------------------- |\",\"1010\":\"| [Mask](#mask20) | 返回单个水波形状的灰度Mask。 |\",\"1011\":\"\",\"1012\":\"**错误码：**\",\"1013\":\"\",\"1014\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"1015\":\"\"}",
      "用户拒绝的修改": "返回单个水波形状的灰度[Mask](#mask20)。",
      "注意事项": "修复链接格式时应全局检查同一术语的所有实例，确保全文统一使用带Markdown链接的\"[Mask](#mask20)\"或纯文本\"Mask\"，避免混合格式；同时需核对参考句子的表达惯例，优先保持与相邻上下文格式一致。"
    },
    {
      "defect_id": 518196,
      "sentence": "选择器弹窗中selected字段的字体最大放大倍数为2。",
      "reference_sentence": "对话框中title字段的字体最大放大倍数为2。",
      "line_num": 114,
      "context": "{\"109\":\"\",\"110\":\"## 选择器弹窗 (PickerDialog)\",\"111\":\"\",\"112\":\"选择器弹窗通常用于在用户进行某些操作（如点击按钮）时显示特定的信息或选项。\",\"113\":\"\",\"114\":\"选择器弹窗中selected字段的字体最大放大倍数为2。\",\"115\":\"\",\"116\":\"### 日历选择器弹窗 (CalendarPickerDialog)\",\"117\":\"\",\"118\":\"日历选择器弹窗提供日历视图，包含年、月和星期信息，通过[CalendarPickerDialog](../reference/apis-arkui/arkui-ts/ts-methods-calendarpicker-dialog.md)接口实现。开发者可调用show函数，定义并弹出日历选择器弹窗。\",\"119\":\"\"}",
      "用户拒绝的修改": "选择器弹窗中selected字段的字体放大倍数最大为2。",
      "注意事项": "修复时应优先检查上下文是否存在已固定的表述结构，确保术语顺序（如“最大放大倍数”）与参考句子严格一致，避免因调整语序破坏文档统一性；若原句无歧义且符合上下文风格，即使语法微调也需谨慎保留原结构。"
    },
    {
      "defect_id": 518224,
      "sentence": "其中系统提供的气泡PopupOptions类型的气泡，字体的最大放大倍数为2。",
      "reference_sentence": "气泡分为两种类型，一种是系统提供的气泡[PopupOptions](../reference/apis-arkui/arkui-ts/ts-universal-attributes-popup.md#popupoptions类型说明)，一种是开发者可以自定义的气泡[CustomPopupOptions](../reference/apis-arkui/arkui-ts/ts-universal-attributes-popup.md#custompopupoptions8类型说明)。",
      "line_num": 4,
      "context": "{\"1\":\"# 气泡提示（Popup）\",\"2\":\"Popup属性可绑定在组件上显示气泡弹窗提示，设置弹窗内容、交互逻辑和显示状态。主要用于屏幕录制、信息弹出提醒等显示状态。\",\"3\":\"\",\"4\":\"气泡分为两种类型，一种是系统提供的气泡[PopupOptions](../reference/apis-arkui/arkui-ts/ts-universal-attributes-popup.md#popupoptions类型说明)，一种是开发者可以自定义的气泡[CustomPopupOptions](../reference/apis-arkui/arkui-ts/ts-universal-attributes-popup.md#custompopupoptions8类型说明)。其中，PopupOptions通过配置primaryButton和secondaryButton来设置带按钮的气泡；CustomPopupOptions通过配置[builder](../../application-dev/ui/state-management/arkts-builder.md)来设置自定义的气泡。其中系统提供的气泡PopupOptions类型的气泡，字体的最大放大倍数为2。\",\"5\":\"\",\"6\":\"气泡可以通过配置[mask](../reference/apis-arkui/arkui-ts/ts-universal-attributes-popup.md#popupoptions类型说明)来实现模态和非模态窗口，mask为true或者颜色值的时候，气泡为模态窗口，mask为false时，气泡为非模态窗口。\",\"7\":\"\",\"8\":\"多个气泡同时弹出时，子窗内显示的气泡比主窗内显示的气泡层级高，所处窗口相同时，后面弹出的气泡层级比先弹出的气泡层级高。\",\"9\":\"\"}",
      "用户拒绝的修改": "其中系统提供的气泡PopupOptions，字体的最大放大倍数为2。",
      "注意事项": "在统一术语表述时应优先保持上下文语义连贯性，若删除\"类型\"等限定词会导致指代模糊（如与CustomPopupOptions形成不对称表述），需保留原修饰词；技术文档修改需同时考虑术语规范性和语句自然度，避免过度简化影响理解准确性。"
    },
    {
      "defect_id": 517431,
      "sentence": "  Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。不支持跨包、跨模块调用该Image组件。",
      "reference_sentence": "如果图片加载过程中出现白色块，请参考[Image白块问题解决方案](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-image-white-lump-solution)。",
      "line_num": 32,
      "context": "{\"27\":\"\",\"28\":\"- 本地资源\",\"29\":\"\",\"30\":\"  创建文件夹，将本地图片放入ets文件夹下的任意位置。\",\"31\":\"\",\"32\":\"  Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。不支持跨包、跨模块调用该Image组件。\",\"33\":\"\",\"34\":\"  ```ts\",\"35\":\"  Image('images/view.jpg')\",\"36\":\"  .width(200)\",\"37\":\"  ```\"}",
      "用户拒绝的修改": "  Image组件引入本地图片路径，即可显示图片（根目录为ets文件夹）。不支持跨包、跨模块调用该组件。",
      "注意事项": "在调整术语一致性时需优先确认上下文是否存在局部命名规范，若原句在特定段落内已形成组件全称(\"Image组件\")的指代惯例，则不宜强行简化为\"Image\"或\"该组件\"，应保持段落内指称统一性高于全局术语简化原则。"
    },
    {
      "defect_id": 518881,
      "sentence": "此类型的具体定义并不直接暴露。可调用[OH_NativeXComponent_GetMouseEventModifierKeyStates](#oh_nativexcomponent_getmouseeventmodifierkeystates)接口从中获取Ctrl键、Shift键和Alt键的按压状态。",
      "reference_sentence": "此类型的具体定义并不直接暴露。可调用[OH_ArkUI_XComponent_GetNativeWindow](#oh_arkui_xcomponent_getnativewindow)接口以获取此类型实例",
      "line_num": 333,
      "context": "{\"328\":\"\",\"329\":\"提供封装的扩展的鼠标事件信息实例。\",\"330\":\"\",\"331\":\"> **说明：**\",\"332\":\">\",\"333\":\"> 此类型的具体定义并不直接暴露。可调用[OH_NativeXComponent_GetMouseEventModifierKeyStates](#oh_nativexcomponent_getmouseeventmodifierkeystates)接口从中获取Ctrl键、Shift键和Alt键的按压状态。\",\"334\":\"\",\"335\":\"**起始版本：**\",\"336\":\"\",\"337\":\"20\",\"338\":\"\"}",
      "用户拒绝的修改": "此类型的具体定义并不直接暴露。可调用[OH_NativeXComponent_GetMouseEventModifierKeyStates](#oh_nativexcomponent_getmouseeventmodifierkeystates)接口以获取Ctrl键、Shift键和Alt键的按压状态。",
      "注意事项": "修复时应优先保留原句的关键技术逻辑（如\"从中\"强调数据来源），避免机械统一句式导致信息丢失；需结合上下文判断用户侧重表达的是结构关联性还是句式一致性，必要时通过追问确认技术细节。"
    },
    {
      "defect_id": 518149,
      "sentence": "即时反馈弹框中字体的最大放大倍数为2。",
      "reference_sentence": "即时反馈作为应用内的轻量通知，应当避免内容布局占用界面内的其他元素信息，如遮盖弹出框的展示内容，从而迷惑用户弹出的内容是否属于弹出框。",
      "line_num": 32,
      "context": "{\"27\":\"\",\"28\":\"   即时反馈在系统中默认从界面底部弹出，距离底部有一定的安全间距，作为系统性的应用内提示反馈，请遵守系统默认效果，避免与其他弹出类组件内容重叠。特殊场景下可对内容布局进行规避。\",\"29\":\"\",\"30\":\" - 弹框字体最大放大倍数限制。\",\"31\":\"\",\"32\":\"   即时反馈弹框中字体的最大放大倍数为2。\",\"33\":\"\",\"34\":\"## 即时反馈模式对比\",\"35\":\"\",\"36\":\"即时反馈提供了两种显示模式，分别为DEFAULT（显示在应用内）、TOP\\\\_MOST（显示在应用之上）。\",\"37\":\"\"}",
      "用户拒绝的修改": "即时反馈中字体的最大放大倍数为2。",
      "注意事项": "在保持术语一致性时应优先核对上下文中的核心概念定义，避免过度简化导致关键限定词丢失；修改时需保留原文必要的结构助词（如\"中\"后加逗号）来维持句式完整性。"
    },
    {
      "defect_id": 518868,
      "sentence": "页面是否刷新。<br>当页面因刷新即将离开时，isReload参数被设置为true；当页面因关闭即将离开时，isReload参数被设置为false。<br>默认值：false。",
      "reference_sentence": "定义刷新或关闭场景下，在即将离开当前页面时触发此回调。",
      "line_num": 163,
      "context": "{\"158\":\"| 名称             | 类型      | 必填   | 说明                                       |\",\"159\":\"| -------------- | ---- | ---- | ---------------------------------------- |\",\"160\":\"| url | string | 是 | 当前显示弹窗所在网页的URL。                       |\",\"161\":\"| message | string | 是 | 弹窗中显示的信息。                       |\",\"162\":\"| result | [JsResult](./arkts-basic-components-web-JsResult.md) | 是 | 通知Web组件用户操作行为。                       |\",\"163\":\"| isReload<sup>20+</sup> | boolean | 否 | 页面是否刷新。<br>当页面因刷新即将离开时，isReload参数被设置为true；当页面因关闭即将离开时，isReload参数被设置为false。<br>默认值：false。|\",\"164\":\"\",\"165\":\"## OnPromptEvent<sup>12+</sup>\",\"166\":\"\",\"167\":\"定义网页调用prompt()告警时触发此回调。\",\"168\":\"\"}",
      "用户拒绝的修改": "页面是否重写。<br>当页面因重写即将离开时，isReload参数被设置为true；当页面因关闭即将离开时，isReload参数被设置为false。<br>默认值：false。",
      "注意事项": "严格保持技术术语一致性，优先使用上下文已有定义的关键词（如\"刷新\"而非\"重写\"），避免将操作行为近义词（如\"关闭/离开\"）混用，参数说明需与参考句子的核心动词保持完全统一。"
    },
    {
      "defect_id": 518963,
      "sentence": "从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 1607,
      "context": "{\"1602\":\"\",\"1603\":\"### (event: Event)<sup>9+</sup>\",\"1604\":\"\",\"1605\":\"(event: Event): void | Promise&lt;void&gt;\",\"1606\":\"\",\"1607\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"1608\":\"\",\"1609\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1610\":\"\",\"1611\":\"**参数：**\",\"1612\":\"\"}",
      "用户拒绝的修改": "从API version 11开始，该接口支持在原子化服务中使用。",
      "注意事项": "修复时必须严格核对上下文中的具体数值和技术细节（如API版本号），优先采用问题句子所在段落直接提供的数据，而非依赖其他参考句子的版本信息。"
    },
    {
      "defect_id": 518964,
      "sentence": "Worker instance is not running.",
      "reference_sentence": "The Worker instance is not running.",
      "line_num": 1630,
      "context": "{\"1625\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\",\"1631\":\"| 10200005 | The invoked API is not supported in workers. |\",\"1632\":\"\",\"1633\":\"**示例：**\",\"1634\":\"\",\"1635\":\"```ts\"}",
      "用户拒绝的修改": "The Worker instance is not running.",
      "注意事项": "修复时应优先保持与上下文术语及SDK原始描述严格一致，避免因过度追求语法规范破坏技术文档与代码实现的术语映射关系，需通过交叉验证上下文同类表述确保修改必要性。"
    },
    {
      "defect_id": 518965,
      "sentence": "The invoked API is not supported in workers.",
      "reference_sentence": "The called API is not supported in the worker thread.",
      "line_num": 1631,
      "context": "{\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\",\"1631\":\"| 10200005 | The invoked API is not supported in workers. |\",\"1632\":\"\",\"1633\":\"**示例：**\",\"1634\":\"\",\"1635\":\"```ts\",\"1636\":\"import { worker, Event } from \\\"@kit.ArkTS\\\"\"}",
      "用户拒绝的修改": "The called API is not supported in the worker thread.",
      "注意事项": "修复时应优先核对上下文和SDK术语，若原文与官方错误码/接口命名完全一致，即使存在词汇重复也需保留技术准确性，避免过度追求语言规范破坏与代码的映射关系。"
    },
    {
      "defect_id": 520455,
      "sentence": "设置组件背景。从API version 20开始，content参数新增了对[ResourceColor](ts-types.md#resourcecolor)类型的支持，并新增了背景向父组件的安全区扩展的能力。",
      "reference_sentence": "设置组件的背景样式。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## background<sup>10+</sup>\",\"10\":\"\",\"11\":\"background(content: CustomBuilder | ResourceColor, options?: BackgroundOptions): T\",\"12\":\"\",\"13\":\"设置组件背景。从API version 20开始，content参数新增了对[ResourceColor](ts-types.md#resourcecolor)类型的支持，并新增了背景向父组件的安全区扩展的能力。\",\"14\":\"\",\"15\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"16\":\"\",\"17\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"18\":\"\"}",
      "用户拒绝的修改": "设置组件的背景样式。从API version 20开始，content参数新增了对[ResourceColor](ts-types.md#resourcecolor)类型的支持，并新增了背景向父组件的安全区扩展的能力。",
      "注意事项": "修复时应严格保持原文术语和表述结构的稳定性，避免添加冗余修饰词（如\"样式\"）导致语义偏移，同时需交叉验证上下文同类接口的命名模式确保全局一致性。"
    },
    {
      "defect_id": 521132,
      "sentence": "从API version 20开始，支持跨BuilderNode配对\\@Provide/\\@Consume。在BuildNode上树时，\\@Consume通过key匹配找到最近的\\@Provide，两者类型需要一致，如果不一致，则会抛出运行时报错。",
      "reference_sentence": "从API version 20开始，支持跨BuilderNode配对\\@Provide/\\@Consume。在BuildNode上树时，\\@Consume通过key匹配找到最近的\\@Provide，两者类型需要一致，如果不一致，则会抛出运行时错误。",
      "line_num": 375,
      "context": "{\"370\":\"      ToDoDemo()\",\"371\":\"    }\",\"372\":\"  }\",\"373\":\"}\",\"374\":\"```\",\"375\":\"6. 从API version 20开始，支持跨BuilderNode配对\\\\@Provide/\\\\@Consume。在BuildNode上树时，\\\\@Consume通过key匹配找到最近的\\\\@Provide，两者类型需要一致，如果不一致，则会抛出运行时报错。\",\"376\":\"需要注意类型不相等判断包括类实例的判断，比如：\",\"377\":\"```ts\",\"378\":\"class A {}\",\"379\":\"class B {}\",\"380\":\"// 两个message都为object类型，但其构造函数不同，属于不同类型\"}",
      "用户拒绝的修改": "从API version 20开始，支持跨BuilderNode配对\\@Provide/\\@Consume。在BuildNode上树时，\\@Consume通过key匹配找到最近的\\@Provide，两者类型需要一致，如果不一致，则会抛出运行时错误。",
      "注意事项": "修复时应优先检查上下文是否存在已统一的术语用法，避免将正确术语替换为近义词；确保同一技术概念在文档中始终保持完全一致的表述，禁止使用同义词替换。"
    },
    {
      "defect_id": 521478,
      "sentence": "| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |",
      "line_num": 889,
      "context": "{\"884\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"885\":\"\",\"886\":\"**参数：**\",\"887\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"888\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"889\":\"| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |\",\"890\":\"| index     | number                               | 是   | typedArray中的索引。    |\",\"891\":\"| value     | number              | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。 |\",\"892\":\"\",\"893\":\"**返回值：** \",\"894\":\"| 类型        | 说明                         |\"}",
      "用户拒绝的修改": "| typedArray | typedArray                        | 是   | 要操作的数组。     |",
      "注意事项": "修复参数类型不一致时需先确认上下文是否存在关联参数类型定义（如smalltypeArray/bigtypeArray），确保统一使用文档内部约定的具体类型名称而非变量名本身。"
    },
    {
      "defect_id": 521110,
      "sentence": "1. 点击`add Child`:",
      "reference_sentence": "无",
      "line_num": 781,
      "context": "{\"776\":\"3. 建立双向同步的关系后，如果\\\\@Provide装饰变量的值和\\\\@Consume的默认值不同，则会回调\\\\@Consume的\\\\@Watch方法，以及与\\\\@Consume有同步关系的变量的\\\\@Watch方法，例如\\\\@Consume通知与其双向同步的\\\\@Link触发\\\\@Watch方法。\",\"777\":\"4. BuilderNode下树后，\\\\@Consume会再次试图查找对应的\\\\@Provide，如果发现下树后无法再找到之前配对的\\\\@Provide，则断开和\\\\@Provide的双向同步关系，\\\\@Consume装饰的变量恢复成默认值。\",\"778\":\"5. \\\\@Consume断开和\\\\@Provide的连接，恢复成默认值时，会判断是否有变化，如果有变化，则会回调\\\\@Consume以及与其有同步关系变量的\\\\@Watch方法。\",\"779\":\"\",\"780\":\"在下面的例子中：\",\"781\":\"1. 点击`add Child`:\",\"782\":\"    - 构建BuilderNode下的子节点`Child`，`Child`中\\\\@Consume未找到\\\\@Provide，使用本地默认值'default value'初始化。\",\"783\":\"    - BuilderNode上树时，`Child`中\\\\@Consume向上找到最近的`Index`中的\\\\@Provide，将\\\\@Consume从默认值更新为\\\\@Provide的值，并回调\\\\@Consume的\\\\@Watch方法。\",\"784\":\"2. \\\\@Provide和\\\\@Consume配对后，建立双向同步关系。点击```Text(`@Provide: ${this.message}`)```和```Text(`@Consume ${this.message}`)```，\\\\@Provide和\\\\@Consume绑定的Text组件刷新，并回调\\\\@Provide和\\\\@Consume的\\\\@Watch方法。\",\"785\":\"3. 点击`remove Child`:\",\"786\":\"    - BuilderNode子节点下树，`Child`中的\\\\@Consume和`Index`中的\\\\@Provide断开连接，`Child`中的\\\\@Consume恢复成默认值，并回调\\\\@Consume的\\\\@Watch方法。\"}",
      "用户拒绝的修改": "1. 单击`add Child`:",
      "注意事项": "在统一操作术语时应优先遵循上下文已有用词习惯和用户认知习惯，若存在多个合理选项（如\"点击\"/\"单击\"），需保留原文表述或通过注释说明修改必要性，避免过度统一导致语义流畅性下降。"
    },
    {
      "defect_id": 520065,
      "sentence": "检查传入的音频采集器信息中音源类型的录制是否可以启动成功。",
      "reference_sentence": "该函数仅检测是否可以获取音频采集器信息中音源类型的焦点。通常在音频录制启动前调用，因为已存在的录制流可能会拒绝其启动。",
      "line_num": 811,
      "context": "{\"806\":\"\",\"807\":\"## isRecordingAvailable<sup>20+</sup>\",\"808\":\"\",\"809\":\"isRecordingAvailable(capturerInfo: AudioCapturerInfo): boolean\",\"810\":\"\",\"811\":\"检查传入的音频采集器信息中音源类型的录制是否可以启动成功。\",\"812\":\"该函数仅检测是否可以获取音频采集器信息中音源类型的焦点。通常在音频录制启动前调用，因为已存在的录制流可能会拒绝其启动。\",\"813\":\"\",\"814\":\"**系统能力：** SystemCapability.Multimedia.Audio.Capturer\",\"815\":\"\",\"816\":\"**参数：**\"}",
      "用户拒绝的修改": "检查传入的音频采集器信息中音源类型的录制是否可以获取焦点。",
      "注意事项": "修复时应严格保持技术术语与上下文功能描述的一致性，优先使用函数实际作用中明确提及的核心动词（如\"启动\"），避免替换为可能引发歧义的内部机制术语（如\"获取焦点\"），同时需验证修改后的动词是否与接口行为、参数说明及用户反馈中的关键操作形成逻辑闭环。"
    },
    {
      "defect_id": 521063,
      "sentence": "点击`add Child`:",
      "reference_sentence": "点击`add Child`",
      "line_num": 781,
      "context": "{\"776\":\"3. 建立双向同步的关系后，如果\\\\@Provide装饰变量的值和\\\\@Consume的默认值不同，则会回调\\\\@Consume的\\\\@Watch方法，以及与\\\\@Consume有同步关系的变量的\\\\@Watch方法，例如\\\\@Consume通知与其双向同步的\\\\@Link触发\\\\@Watch方法。\",\"777\":\"4. BuilderNode下树后，\\\\@Consume会再次试图查找对应的\\\\@Provide，如果发现下树后无法再找到之前配对的\\\\@Provide，则断开和\\\\@Provide的双向同步关系，\\\\@Consume装饰的变量恢复成默认值。\",\"778\":\"5. \\\\@Consume断开和\\\\@Provide的连接，恢复成默认值时，会判断是否有变化，如果有变化，则会回调\\\\@Consume以及与其有同步关系变量的\\\\@Watch方法。\",\"779\":\"\",\"780\":\"在下面的例子中：\",\"781\":\"1. 点击`add Child`:\",\"782\":\"    - 构建BuilderNode下的子节点`Child`，`Child`中\\\\@Consume未找到\\\\@Provide，使用本地默认值'default value'初始化。\",\"783\":\"    - BuilderNode上树时，`Child`中\\\\@Consume向上找到最近的`Index`中的\\\\@Provide，将\\\\@Consume从默认值更新为\\\\@Provide的值，并回调\\\\@Consume的\\\\@Watch方法。\",\"784\":\"2. \\\\@Provide和\\\\@Consume配对后，建立双向同步关系。点击```Text(`@Provide: ${this.message}`)```和```Text(`@Consume ${this.message}`)```，\\\\@Provide和\\\\@Consume绑定的Text组件刷新，并回调\\\\@Provide和\\\\@Consume的\\\\@Watch方法。\",\"785\":\"3. 点击`remove Child`:\",\"786\":\"    - BuilderNode子节点下树，`Child`中的\\\\@Consume和`Index`中的\\\\@Provide断开连接，`Child`中的\\\\@Consume恢复成默认值，并回调\\\\@Consume的\\\\@Watch方法。\"}",
      "用户拒绝的修改": "单击`add Child`:",
      "注意事项": "修复时需优先匹配代码中的实际术语（如button事件使用\"点击\"而非\"单击\"），同时严格遵循上下文已有表达（如参考句中的\"点击\"），保持代码描述与界面操作术语的双重一致性。"
    },
    {
      "defect_id": 520526,
      "sentence": "替代的ArkTS1.2接口声明：[setXComponentSurfaceRect(rect: SurfaceRect): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setxcomponentsurfacerect12)",
      "reference_sentence": "ArkTS1.1接口声明：[setXComponentSurfaceSize(value: {surfaceWidth: number, surfaceHeight: number}): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setXComponentSurfaceSizedeprecated)",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"## setXComponentSurfaceSize\",\"6\":\"\",\"7\":\"ArkTS1.1接口声明：[setXComponentSurfaceSize(value: {surfaceWidth: number, surfaceHeight: number}): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setXComponentSurfaceSizedeprecated)\",\"8\":\"\",\"9\":\"替代的ArkTS1.2接口声明：[setXComponentSurfaceRect(rect: SurfaceRect): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setxcomponentsurfacerect12)\",\"10\":\"\",\"11\":\"适配方法：\",\"12\":\"\",\"13\":\"ArkTS1.1\",\"14\":\"\"}",
      "用户拒绝的修改": "替代的ArkTS1.2接口声明：[setXComponentSurfaceSize(rect: SurfaceRect): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setxcomponentsurfacerect12)",
      "注意事项": "严格校验接口名称与上下文版本对应关系，确保术语变更（如\"Size\"→\"Rect\"）与参数类型（SurfaceRect）保持逻辑一致，避免跨版本混用命名规范。"
    },
    {
      "defect_id": 521477,
      "sentence": "static xor(typedArray: smalltypeArray, index: number, value: number): number",
      "reference_sentence": "static xor(typedArray: bigtypeArray, index: number, value: bigint): bigint",
      "line_num": 880,
      "context": "{\"875\":\"}\",\"876\":\"```\",\"877\":\"\",\"878\":\"## xor\",\"879\":\"\",\"880\":\"static xor(typedArray: smalltypeArray, index: number, value: number): number  \",\"881\":\"\",\"882\":\"将typedArray[index]与value进行按位异或运算，结果写回typedArray[index]。  \",\"883\":\"此方法返回typedArray[index]被修改之前的值。  \",\"884\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"885\":\"\"}",
      "用户拒绝的修改": "static xor(typedArray: bigtypeArray, index: number, value: number): number",
      "注意事项": "修复类型不一致时应同步检查所有相关参数和返回类型的上下文一致性，确保参数类型修改后与返回值类型（如bigint/number）及相邻方法的类型定义保持统一。"
    },
    {
      "defect_id": 520525,
      "sentence": "ArkTS1.1接口声明：[setXComponentSurfaceSize(value: {surfaceWidth: number, surfaceHeight: number}): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setXComponentSurfaceSizedeprecated)",
      "reference_sentence": "替代的ArkTS1.2接口声明：[setXComponentSurfaceRect(rect: SurfaceRect): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setxcomponentsurfacerect12)",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"以下接口在ArkTS1.1已经标记废弃，在ArkTS1.2不再支持。\",\"4\":\"\",\"5\":\"## setXComponentSurfaceSize\",\"6\":\"\",\"7\":\"ArkTS1.1接口声明：[setXComponentSurfaceSize(value: {surfaceWidth: number, surfaceHeight: number}): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setXComponentSurfaceSizedeprecated)\",\"8\":\"\",\"9\":\"替代的ArkTS1.2接口声明：[setXComponentSurfaceRect(rect: SurfaceRect): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setxcomponentsurfacerect12)\",\"10\":\"\",\"11\":\"适配方法：\",\"12\":\"\"}",
      "用户拒绝的修改": "ArkTS1.1接口声明：[setXComponentSurfaceRect(value: {surfaceWidth: number, surfaceHeight: number}): void](../reference/apis-arkui/arkui-ts/ts-basic-components-xcomponent.md#setXComponentSurfaceSizedeprecated)",
      "注意事项": "修复接口声明时需严格核对接口名称和参数类型是否与最新版本文档完全一致，避免仅修改部分术语而忽略参数结构或类型变更；同时应交叉验证上下文中的替代接口示例，确保整体声明格式和内容匹配。"
    },
    {
      "defect_id": 521950,
      "sentence": "4. 字节码编译：使用方舟编译器生成方舟字节码文件（\\*.abc）。",
      "reference_sentence": "4. 字节码编译：使用方舟编译器生成方舟字节码文件（.abc）。",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"2. UI转换：将UI声明式范式语法转换为标准TS语法。\",\"12\":\"\",\"13\":\"3. 源码混淆：使用ArkGuard源码混淆工具对源码进行混淆，开发者可根据业务需要选择开启。\",\"14\":\"\",\"15\":\"4. 字节码编译：使用方舟编译器生成方舟字节码文件（\\\\*.abc）。\",\"16\":\"\",\"17\":\"5. 自定义修改方舟字节码：提供开发者修改字节码能力的入口，在字节码编译落盘前调用。\",\"18\":\"\",\"19\":\"6. 反汇编：使用Disassembler反汇编工具将字节数据反汇编成可阅读的汇编指令。\",\"20\":\"\"}",
      "用户拒绝的修改": "4. 字节码编译：使用方舟编译器生成方舟字节码文件（*.abc）。",
      "注意事项": "修复文件后缀格式时应确保符合文档规范，优先采用标准\".abc\"格式而非通配符\"*.abc\"；处理转义字符需完整清除冗余符号（如残留的\\或*），保持与上下文参考样例（.abc）的严格一致。"
    },
    {
      "defect_id": 521002,
      "sentence": "滚动组件划动离手时触发，使用鼠标滚轮划动时不会触发。",
      "reference_sentence": "滚动组件滑动时触发。",
      "line_num": 494,
      "context": "{\"489\":\"\",\"490\":\"### onWillStopDragging<sup>20+</sup>\",\"491\":\"\",\"492\":\"onWillStopDragging(handler: OnWillStopDraggingCallback): T\",\"493\":\"\",\"494\":\"滚动组件划动离手时触发，使用鼠标滚轮划动时不会触发。\",\"495\":\"\",\"496\":\"**卡片能力：** 从API version 20开始，该接口支持在ArkTS卡片中使用。\",\"497\":\"\",\"498\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"499\":\"\"}",
      "用户拒绝的修改": "滚动组件滑动离手时触发，使用鼠标滚轮滑动时不会触发。",
      "注意事项": "修复前需优先确认术语在上下文中的固定用法，若问题仅涉及局部补充说明（如卡片能力），应严格限定修改范围避免改动无关表述，同时交叉验证文档中现有用词的一致性模式。"
    },
    {
      "defect_id": 520651,
      "sentence": "为OH_ArkWebHttpBodyStream_AsyncRead设置回调函数。OH_ArkWebHttpBodyStream_AsyncRead的结果将通过readCallback通知给调用者。",
      "reference_sentence": "为OH_ArkWebHttpBodyStream_Read设置回调函数。OH_ArkWebHttpBodyStream_Read的结果将通过readCallback通知给调用者。",
      "line_num": 60,
      "context": "{\"55\":\"| [int32_t OH_ArkWebResourceRequest_GetResourceType(const ArkWeb_ResourceRequest* resourceRequest)](#oh_arkwebresourcerequest_getresourcetype) | - | 获取请求的资源类型。 |\",\"56\":\"| [void OH_ArkWebResourceRequest_GetFrameUrl(const ArkWeb_ResourceRequest* resourceRequest, char** frameUrl)](#oh_arkwebresourcerequest_getframeurl) | - | 获取触发此请求的Frame的URL。 |\",\"57\":\"| [int32_t OH_ArkWebHttpBodyStream_SetUserData(ArkWeb_HttpBodyStream* httpBodyStream, void* userData)](#oh_arkwebhttpbodystream_setuserdata) | - | 将一个用户数据设置到ArkWeb_HttpBodyStream对象中。 |\",\"58\":\"| [void* OH_ArkWebHttpBodyStream_GetUserData(const ArkWeb_HttpBodyStream* httpBodyStream)](#oh_arkwebhttpbodystream_getuserdata) | - | 从ArkWeb_HttpBodyStream获取用户数据。 |\",\"59\":\"| [int32_t OH_ArkWebHttpBodyStream_SetReadCallback(ArkWeb_HttpBodyStream* httpBodyStream,ArkWeb_HttpBodyStreamReadCallback readCallback)](#oh_arkwebhttpbodystream_setreadcallback) | - | 为OH_ArkWebHttpBodyStream_Read设置回调函数。OH_ArkWebHttpBodyStream_Read的结果将通过readCallback通知给调用者。<br>该回调函数将在与OH_ArkWebHttpBodyStream_Read相同的线程中运行。 |\",\"60\":\"| [int32_t OH_ArkWebHttpBodyStream_SetAsyncReadCallback(ArkWeb_HttpBodyStream* httpBodyStream,ArkWeb_HttpBodyStreamReadCallback readCallback)](#oh_arkwebhttpbodystream_setasyncreadcallback) | - | 为OH_ArkWebHttpBodyStream_AsyncRead设置回调函数。OH_ArkWebHttpBodyStream_AsyncRead的结果将通过readCallback通知给调用者。<br>该回调函数将在与OH_ArkWebHttpBodyStream_AsyncRead相同的线程中运行。 |\",\"61\":\"| [int32_t OH_ArkWebHttpBodyStream_Init(ArkWeb_HttpBodyStream* httpBodyStream,ArkWeb_HttpBodyStreamInitCallback initCallback)](#oh_arkwebhttpbodystream_init) | - | 初始化ArkWeb_HttpBodyStream。在调用任何其他函数之前，必须调用此函数。该接口需要在IO线程调用。 |\",\"62\":\"| [void OH_ArkWebHttpBodyStream_Read(const ArkWeb_HttpBodyStream* httpBodyStream, uint8_t* buffer, int bufLen)](#oh_arkwebhttpbodystream_read) | - | 将请求的上传数据读取到buffer。buffer的大小必须大于bufLen。我们将从工作线程读取数据到buffer，因此在回调函数返回之前，不应在其他线程中使用buffer，以避免并发问题。 |\",\"63\":\"| [void OH_ArkWebHttpBodyStream_AsyncRead(const ArkWeb_HttpBodyStream* httpBodyStream, uint8_t* buffer, int bufLen)](#oh_arkwebhttpbodystream_asyncread) | - | 将请求的上传数据读取到buffer。buffer的大小必须大于bufLen。我们将从工作线程读取数据到buffer，因此在回调函数返回之前，不应在其他线程中使用buffer，以避免并发问题。 |\",\"64\":\"| [uint64_t OH_ArkWebHttpBodyStream_GetSize(const ArkWeb_HttpBodyStream* httpBodyStream)](#oh_arkwebhttpbodystream_getsize) | - | 获取httpBodyStream的大小。当数据以分块的形式传输或httpBodyStream无效时，始终返回0。 |\",\"65\":\"| [uint64_t OH_ArkWebHttpBodyStream_GetPosition(const ArkWeb_HttpBodyStream* httpBodyStream)](#oh_arkwebhttpbodystream_getposition) | - | 获取httpBodyStream当前的读取位置。 |\"}",
      "用户拒绝的修改": "为OH_ArkWebHttpBodyStream_SetAsyncRead设置回调函数。OH_ArkWebHttpBodyStream_SetAsyncRead的结果将通过readCallback通知给调用者。",
      "注意事项": "修复时必须严格区分设置回调函数（SetXxxCallback）与执行操作函数（Xxx）的命名差异，避免错误添加\"Set\"前缀；需结合上下文交叉验证术语一致性，确保\"Read\"和\"AsyncRead\"等动作型函数不被混淆为设置型函数。"
    },
    {
      "defect_id": 521949,
      "sentence": "在生成字节码文件后，开发者可以使用[Disassembler反汇编工具](tool-disassembler.md)查看字节码文件的内容。关于字节码的具体内容，可参考[方舟字节码文件格式](arkts-bytecode-file-format.md)章节。",
      "reference_sentence": "在生成字节码文件后，开发者可以使用[Disassembler反汇编工具](tool-disassembler.md)查看字节码文件的内容。关于方舟字节码文件的具体内容，可参考[方舟字节码文件格式](arkts-bytecode-file-format.md)章节。",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS编译工具链概述\",\"2\":\"\",\"3\":\"为了支持ArkTS应用编译，ArkTS应用SDK提供一套完整的编译工具链，通过将其部署在[Hvigor](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor)编译任务的编排工具上，实现将应用的ArkTS/TS/JS源码编译生成方舟字节码文件（\\\\*.abc）。\",\"4\":\"\",\"5\":\"编译工具链在编译过程中首先执行语法转换，包含语法检查和UI转换。为确保源码安全，编译工具链会使用[ArkGuard源码混淆工具](source-obfuscation.md)对源码进行混淆操作。在字节码落盘之前，编译工具链会判断是否需要进行[字节码自定义修改](customize-bytecode-during-compilation.md)，如果需要，则加载并执行自定义修改代码。在生成字节码文件后，开发者可以使用[Disassembler反汇编工具](tool-disassembler.md)查看字节码文件的内容。关于字节码的具体内容，可参考[方舟字节码文件格式](arkts-bytecode-file-format.md)章节。\",\"6\":\"\",\"7\":\"ArkTS编译工具链当前主要包括如下功能：\",\"8\":\"\",\"9\":\"1. 语法检查：检查ArkTS/TS语法正确性。\",\"10\":\"\"}",
      "用户拒绝的修改": "在生成方舟字节码文件后，开发者可以使用[Disassembler反汇编工具](tool-disassembler.md)查看方舟字节码文件的内容。关于方舟字节码的具体内容，可参考[方舟字节码文件格式](arkts-bytecode-file-format.md)章节。",
      "注意事项": "修复时应优先保持上下文术语层级的一致性，在已明确使用全称定义（如\"方舟字节码\"）的语境下，允许后续使用简称（如\"字节码\"），但需确保链接锚文本与对应章节标题的命名完全一致。"
    },
    {
      "defect_id": 520930,
      "sentence": "注入不会触发窗口焦点、层级变化或拖拽，事件直接发送给ArkUI。",
      "reference_sentence": "此操作不会触发窗口焦点、层级变化或拖拽，事件会直接发送给ArkUI。",
      "line_num": 132,
      "context": "{\"127\":\"| ------------------------------------------------------------ | -------------------------- |\",\"128\":\"| OH_WindowManager_InjectTouchEvent(int32_t windowId, Input_TouchEvent* touchEvent, int32_t windowX, int32_t windowY) | 为指定的窗口注入触摸事件。 |\",\"129\":\"\",\"130\":\"- 构造事件参数，向目标窗口ID注入事件。\",\"131\":\"\",\"132\":\"- 仅支持注入同进程窗口。注入不会触发窗口焦点、层级变化或拖拽，事件直接发送给ArkUI。\",\"133\":\"\",\"134\":\"- 接口需要在指定窗口加载UI后调用。\",\"135\":\"\",\"136\":\"- 完成窗口和多模触摸事件校验，确保事件参数正确，再将事件发送给ArkUI。具体参数说明如下：\",\"137\":\"\"}",
      "用户拒绝的修改": "此操作不会触发窗口焦点、层级变化或拖拽，事件直接发送给ArkUI。",
      "注意事项": "在调整语句结构时需优先检查上下文术语一致性（如保留\"注入\"承接上文动作描述），避免机械套用句式规则破坏技术文档的连贯性；修复后应确保新句子的主语/动作与相邻条目保持平行结构（如统一使用动名词短语而非添加\"此操作\"）。"
    },
    {
      "defect_id": 520931,
      "sentence": "其中，touchEvent多模触摸事件具体参数说明如下：",
      "reference_sentence": "以下示例代码介绍了如何将多模触摸事件注入目标窗口，以单次事件注入为例。",
      "line_num": 145,
      "context": "{\"140\":\"  | windowId   | 目标窗口ID，仅支持同进程的窗口，否则返回错误码1300002。窗口需完成UI加载，否则返回错误码1300003。 |\",\"141\":\"  | touchEvent | 多模触摸事件，具体可见[Input_TouchEvent](../reference/apis-input-kit/capi-input-input-touchevent.md)，事件定义在oh_input_manager.h中。调用[OH_Input_CreateTouchEvent](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_createtouchevent)接口创建touchEvent对象，使用完后调用[OH_Input_DestroyTouchEvent](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_destroytouchevent)接口销毁该对象。具体参数说明见下表。 |\",\"142\":\"  | windowX    | 注入事件相对于注入窗口的落点横坐标。参数应为大于等于0的整数，否则返回错误码1300003。 |\",\"143\":\"  | windowY    | 注入事件相对于注入窗口的落点纵坐标。参数应为大于等于0的整数，否则返回错误码1300003。 |\",\"144\":\"\",\"145\":\"  其中，touchEvent多模触摸事件具体参数说明如下：\",\"146\":\"\",\"147\":\"  | 参数名     | 方法                                                         | 描述                                                         |\",\"148\":\"  | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"149\":\"  | action     | [OH_Input_SetTouchEventAction](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventaction) | 表示事件行为，默认值为0。<br>当前只支持0-3的行为，分别表示为：<br>- 0：cancel，表示取消事件。<br>- 1：down，表示按下事件。<br/>- 2：move，表示移动事件。<br/>- 3：up，表示抬起事件。<br/>- 其他行为会返回错误码1300003。 |\",\"150\":\"  | id         | [OH_Input_SetTouchEventFingerId](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventfingerid) | 表示手指ID，默认值为0。<br>应为大于等于0的整数，否则返回错误码1300003。 |\"}",
      "用户拒绝的修改": "以下为touchEvent多模触摸事件的具体参数说明：",
      "注意事项": "修复时应优先确认上下文是否存在统一的句式习惯，避免机械套用语法规则破坏原有表达连贯性；当用户明确表示当前表述已符合一致性要求时，应尊重上下文语境而非强行统一句式结构。"
    },
    {
      "defect_id": 521479,
      "sentence": "typedArray不在类型范围内",
      "reference_sentence": "\"Index out of bounds\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：确保传入的index在typedArray的范围内。如果无法保证，建议捕获 RangeError 异常。",
      "line_num": 937,
      "context": "{\"932\":\"| bigint       | 返回typedArray[index]被修改之前的值。   |\",\"933\":\"\",\"934\":\"**错误信息**\",\"935\":\"| 错误信息        | 说明                         |\",\"936\":\"| ----------- | --------------------------- |\",\"937\":\"| \\\"Unhandled array type!\\\" | typedArray不在类型范围内 |\",\"938\":\"\",\"939\":\"**示例：**\",\"940\":\"```ts\",\"941\":\"let ab = new ArrayBuffer(1024)\",\"942\":\"let ta = new BigInt64Array(ab)\"}",
      "用户拒绝的修改": "typedArray类型不在有效范围内",
      "注意事项": "修复时应严格保持错误类型描述的一致性，确保术语使用与上下文完全匹配（如\"范围\"指索引边界时不擅自添加\"类型\"修饰），并核对同类错误表述的用词模式是否统一。"
    },
    {
      "defect_id": 520066,
      "sentence": "录制是否可以启动成功。true表示成功，false表示失败。",
      "reference_sentence": "该函数仅检测是否可以获取音频采集器信息中音源类型的焦点。通常在音频录制启动前调用，因为已存在的录制流可能会拒绝其启动。",
      "line_num": 826,
      "context": "{\"821\":\"\",\"822\":\"**返回值：**\",\"823\":\"\",\"824\":\"| 类型          | 说明                                    |\",\"825\":\"| ------------ | --------------------------------------- |\",\"826\":\"|  boolean     | 录制是否可以启动成功。true表示成功，false表示失败。 |\",\"827\":\"\",\"828\":\"**错误码：**\",\"829\":\"\",\"830\":\"以下错误码的详细介绍请参见[Audio错误码](errorcode-audio.md)。\",\"831\":\"\"}",
      "用户拒绝的修改": "录制是否可以获取焦点。true表示成功，false表示失败。",
      "注意事项": "保持技术概念准确性优先于表面术语统一，修改前需结合上下文确认核心功能描述是否被改变；确保关键动词（如\"启动\"和\"获取焦点\"）的修改不会造成功能阶段的错位（启动流程与焦点检测属于不同环节）。"
    },
    {
      "defect_id": 521027,
      "sentence": "> API version 19及以前，@Provide和\\@Consume双向同步仅支持在声明式节点上树的场景。从从API version 20开始，通过配置[BuilderNode](../../reference/apis-arkui/js-apis-arkui-builderNode.md)的[BuildOptions](../../reference/apis-arkui/js-apis-arkui-builderNode.md#buildoptions12)参数`enableProvideConsumeCrossing`为true，@Provide和\\@Consume支持跨[BuilderNode](../../reference/apis-arkui/js-apis-arkui-builderNode.md)双向同步。但需要注意，BuilderNode会在上树前构造节点，所以BuilderNode内部\\@Consume需要设置默认值。并通过BuilderNode上树后，接收\\Provide数据，并建立双向同步关系。具体可见[例子](#consume在跨buildernode场景下和provide建立双向同步)。",
      "reference_sentence": "> **说明：**> 从API version 9开始，这两个装饰器支持在ArkTS卡片中使用。> 从API version 11开始，这两个装饰器支持在原子化服务中使用。> 从API version 20开始，@Consume装饰的变量支持设置默认值。当查找不到@Provide的匹配结果时，@Consume装饰的变量会使用默认值进行初始化；当查找到@Provide的匹配结果时，@Consume装饰的变量会优先使用@Provide匹配结果的值，默认值不生效。",
      "line_num": 17,
      "context": "{\"12\":\">\",\"13\":\"> 从API version 11开始，这两个装饰器支持在原子化服务中使用。\",\"14\":\">\",\"15\":\"> 从API version 20开始，@Consume装饰的变量支持设置默认值。当查找不到@Provide的匹配结果时，@Consume装饰的变量会使用默认值进行初始化；当查找到@Provide的匹配结果时，@Consume装饰的变量会优先使用@Provide匹配结果的值，默认值不生效。\",\"16\":\">\",\"17\":\"> API version 19及以前，@Provide和\\\\@Consume双向同步仅支持在声明式节点上树的场景。从从API version 20开始，通过配置[BuilderNode](../../reference/apis-arkui/js-apis-arkui-builderNode.md)的[BuildOptions](../../reference/apis-arkui/js-apis-arkui-builderNode.md#buildoptions12)参数`enableProvideConsumeCrossing`为true，@Provide和\\\\@Consume支持跨[BuilderNode](../../reference/apis-arkui/js-apis-arkui-builderNode.md)双向同步。但需要注意，BuilderNode会在上树前构造节点，所以BuilderNode内部\\\\@Consume需要设置默认值。并通过BuilderNode上树后，接收\\\\Provide数据，并建立双向同步关系。具体可见[例子](#consume在跨buildernode场景下和provide建立双向同步)。\",\"18\":\"\",\"19\":\"## 概述\",\"20\":\"\",\"21\":\"\\\\@Provide/\\\\@Consume装饰的状态变量有以下特性：\",\"22\":\"\"}",
      "用户拒绝的修改": "> API version 19及以前，@Provide和@Consume双向同步仅支持在声明式节点上树的场景。从API version 20开始，通过配置[BuilderNode](../../reference/apis-arkui/js-apis-arkui-builderNode.md)的[BuildOptions](../../reference/apis-arkui/js-apis-arkui-builderNode.md#buildoptions12)参数`enableProvideConsumeCrossing`为true，@Provide和@Consume支持跨BuilderNode双向同步。但需要注意，BuilderNode会在上树前构造节点，所以BuilderNode内部@Consume需要设置默认值。并通过BuilderNode上树后，接收@Provide数据，并建立双向同步关系。具体可见[例子](#consume在跨buildernode场景下和provide建立双向同步)。",
      "注意事项": "严格保持术语一致性（确保\"@Provide\"/\"@Consume\"符号格式统一、BuilderNode链接引用完整），动作描述需统一（如\"上树前/后\"与\"上树场景\"统一为\"上树前/后\"），并消除重复用词（如\"从从\"）。"
    },
    {
      "defect_id": 521457,
      "sentence": "等待结果可通过返回值获得。  \r",
      "reference_sentence": "等待结果可通过返回值获得。  \r",
      "line_num": 817,
      "context": "{\"812\":\"## waitAsync\",\"813\":\"\",\"814\":\"async static waitAsync(typedArray: Int32Array | BigInt64Array, index: number, value: bigint, timeout?: number): Promise\\\\<string>\",\"815\":\"\",\"816\":\"等待共享内存的特定位置，与wait不同不会阻塞调用者。  \",\"817\":\"等待结果可通过返回值获得。  \",\"818\":\"\",\"819\":\"**参数：**\",\"820\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"821\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"822\":\"| typedArray | Int32Array \\\\| BigInt64Array            | 是   | 要操作的数组。     |\"}",
      "用户拒绝的修改": "返回的等待结果可通过返回值获得。",
      "注意事项": "修复时必须严格校验上下文术语一致性，避免擅自添加未出现的修饰词（如“返回的”）；优先维持原句核心名词结构，仅在必要时通过补充逻辑主语或调整句式明确指代关系。"
    },
    {
      "defect_id": 522901,
      "sentence": "原函数名代表函数在源代码中的名字，匿名函数则为空字符串",
      "reference_sentence": "作用域名称是源代码中定义作用域时所使用的名称。匿名则为空字符串",
      "line_num": 58,
      "context": "{\"53\":\"namespace A {\",\"54\":\"    function foo() { }                      // foo的函数名为\\\"#&A^1*#foo\\\"，其中\\\"^1\\\" 为重名序号\",\"55\":\"}\",\"56\":\"```\",\"57\":\"### 原函数名\",\"58\":\"原函数名代表函数在源代码中的名字，匿名函数则为空字符串。同样的，如果源码中相同作用域下出现了同名的函数，重名的名称后面会加上重名序号（包括匿名函数）。\",\"59\":\"\",\"60\":\"```ts\",\"61\":\"function foo() {}                           // 原函数名为\\\"foo\\\"\",\"62\":\"() => { }                                   // 原函数名为\\\"\\\"\",\"63\":\"() => { }                                   // 原函数名为\\\"^1\\\"\"}",
      "用户拒绝的修改": "原函数名代表函数在源代码中的名字，匿名函数则为空。",
      "注意事项": "保持技术术语一致性，严格匹配上下文中的\"空字符串\"表述；避免将技术概念（空字符串）简化为日常用语（空），需通过交叉验证参考句子的用词模式确保表述精准。"
    },
    {
      "defect_id": 523031,
      "sentence": "Disassembler是ArkTS反汇编工具。",
      "reference_sentence": "Disassembler是ArkCompiler反汇编工具。",
      "line_num": 5,
      "context": "{\"1\":\"# Disassembler反汇编工具\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"Disassembler是ArkTS反汇编工具。如果需要分析方舟字节码文件（\\\\*.abc）相关问题，开发者可以使用Disassembler将字节数据反编译为可读的汇编指令。\",\"6\":\"\",\"7\":\"工具随DevEco Studio SDK发布。以Windows平台为例，Disassembler工具位于DevEco Studio/sdk/default/openharmony/toolchains/ark_disasm.exe。\",\"8\":\"\",\"9\":\"## 命令行说明\",\"10\":\"\"}",
      "用户拒绝的修改": "Disassembler是ArkCompiler反汇编工具。",
      "注意事项": "修复术语一致性时必须先核对上下文术语定义和文档规范，确认是否属于同一实体不同名称或实际指代不同工具，避免将正确术语误判为错误；当用户明确\"原文正确\"时，应优先保留原术语并检查是否存在多术语共存场景。"
    },
    {
      "defect_id": 520633,
      "sentence": "| [typedef void (\\*ArkWeb_HttpBodyStreamAsyncReadCallback)(const ArkWeb_HttpBodyStream* httpBodyStream,uint8_t* buffer,int bytesRead)](#arkweb_httpbodystreamasyncreadcallback) | ArkWeb_HttpBodyStreamAsyncReadCallback | 当OH_ArkWebHttpBodyStream_AsyncRead读取操作完成时的回调函数。 |",
      "reference_sentence": "| [typedef void (*ArkWeb_HttpBodyStreamReadCallback)(const ArkWeb_HttpBodyStream* httpBodyStream,uint8_t* buffer,int bytesRead)](#arkweb_httpbodystreamreadcallback) | ArkWeb_HttpBodyStreamReadCallback | 当OH_ArkWebHttpBodyStream_Read读取操作完成时的回调函数。 |",
      "line_num": 44,
      "context": "{\"39\":\"| 名称 | typedef关键字 | 描述 |\",\"40\":\"| -- | -- | -- |\",\"41\":\"| [typedef void (\\\\*ArkWeb_OnRequestStart)(const ArkWeb_SchemeHandler* schemeHandler,ArkWeb_ResourceRequest* resourceRequest,const ArkWeb_ResourceHandler* resourceHandler,bool* intercept)](#arkweb_onrequeststart) | ArkWeb_OnRequestStart | 请求开始的回调，这将在IO线程上被调用。 |\",\"42\":\"| [typedef void (\\\\*ArkWeb_OnRequestStop)(const ArkWeb_SchemeHandler* schemeHandler,const ArkWeb_ResourceRequest* resourceRequest)](#arkweb_onrequeststop) | ArkWeb_OnRequestStop | 请求完成时的回调函数。这将在IO线程上被调用。<br>应该使用ArkWeb_ResourceRequest_Destroy销毁resourceRequest，<br>并使用ArkWeb_ResourceHandler_Destroy销毁在ArkWeb_OnRequestStart中接收到的ArkWeb_ResourceHandler。 |\",\"43\":\"| [typedef void (\\\\*ArkWeb_HttpBodyStreamReadCallback)(const ArkWeb_HttpBodyStream* httpBodyStream,uint8_t* buffer,int bytesRead)](#arkweb_httpbodystreamreadcallback) | ArkWeb_HttpBodyStreamReadCallback | 当OH_ArkWebHttpBodyStream_Read读取操作完成时的回调函数。 |\",\"44\":\"| [typedef void (\\\\*ArkWeb_HttpBodyStreamAsyncReadCallback)(const ArkWeb_HttpBodyStream* httpBodyStream,uint8_t* buffer,int bytesRead)](#arkweb_httpbodystreamasyncreadcallback) | ArkWeb_HttpBodyStreamAsyncReadCallback | 当OH_ArkWebHttpBodyStream_AsyncRead读取操作完成时的回调函数。 |\",\"45\":\"| [typedef void (\\\\*ArkWeb_HttpBodyStreamInitCallback)(const ArkWeb_HttpBodyStream* httpBodyStream, ArkWeb_NetError result)](#arkweb_httpbodystreaminitcallback) | ArkWeb_HttpBodyStreamInitCallback | ArkWeb_HttpBodyStream初始化操作完成时回调函数。 |\",\"46\":\"| [void OH_ArkWebRequestHeaderList_Destroy(ArkWeb_RequestHeaderList* requestHeaderList)](#oh_arkwebrequestheaderlist_destroy) | - | 销毁ArkWeb_RequestHeaderList对象。 |\",\"47\":\"| [int32_t OH_ArkWebRequestHeaderList_GetSize(const ArkWeb_RequestHeaderList* requestHeaderList)](#oh_arkwebrequestheaderlist_getsize) | - | 获取请求头列表的大小。 |\",\"48\":\"| [void OH_ArkWebRequestHeaderList_GetHeader(const ArkWeb_RequestHeaderList* requestHeaderList,int32_t index,char** key,char** value)](#oh_arkwebrequestheaderlist_getheader) | - | 获取指定的请求头。 |\",\"49\":\"| [int32_t OH_ArkWebResourceRequest_SetUserData(ArkWeb_ResourceRequest* resourceRequest, void* userData)](#oh_arkwebresourcerequest_setuserdata) | - | 将一个用户数据设置到ArkWeb_ResourceRequest对象中。 |\"}",
      "用户拒绝的修改": "| [typedef void (\\*ArkWeb_HttpBodyStreamAsyncReadCallback)(const ArkWeb_HttpBodyStream* httpBodyStream,uint8_t* buffer,int bytesRead)](#arkweb_httpbodystreamasyncreadcallback) | ArkWeb_HttpBodyStreamAsyncReadCallback | 当OH_ArkWebHttpBodyStream_AsyncRead异步读取操作完成时的回调函数。 |",
      "注意事项": "严格区分同步和异步函数名称，确保回调描述中的操作类型（如“异步”）与对应函数名（如OH_ArkWebHttpBodyStream_AsyncRead）完全匹配，并避免冗余表述（如重复“读取操作完成”需精简为单次精准描述）。"
    },
    {
      "defect_id": 522287,
      "sentence": "通常情况下，字节码文件的各个结构使用32位偏移量来引用，当一个结构引用另一个结构时，需要在当前结构中记录被引用结构的32位偏移量。为了减小文件体积，字节码文件被分割成多个索引区域（Index region），每个索引区域内的结构使用16位索引。",
      "reference_sentence": "### IndexSection",
      "line_num": 442,
      "context": "{\"437\":\"> \",\"438\":\"> 特殊操作码计算方式：`(line_increment - LINE_BASE) + (address_increment * LINE_RANGE) + OPCODE_BASE`。\",\"439\":\"\",\"440\":\"\",\"441\":\"### IndexSection\",\"442\":\"通常情况下，字节码文件的各个结构使用32位偏移量来引用，当一个结构引用另一个结构时，需要在当前结构中记录被引用结构的32位偏移量。为了减小文件体积，字节码文件被分割成多个索引区域（Index region），每个索引区域内的结构使用16位索引。IndexSection结构描述了索引区域的集合。\",\"443\":\"\",\"444\":\"- 对齐方式：4个字节。\",\"445\":\"- 格式：\",\"446\":\"\",\"447\":\"| **名称** | **格式** | **说明**       |\"}",
      "用户拒绝的修改": "通常情况下，字节码文件的各个结构使用32位偏移量来引用，当一个结构引用另一个结构时，需要在当前结构中记录被引用结构的32位偏移量。为了减小文件体积，字节码文件被分割成多个索引区域，每个索引区域内的结构使用16位索引。",
      "注意事项": "保留术语首次出现时的中英文对照形式（如\"索引区域（Index region）\"），确保上下文术语使用一致性；避免在未明确上下文关联的情况下删除括号内的补充说明内容。"
    },
    {
      "defect_id": 523033,
      "sentence": "待反汇编的方舟字节码文件路径。",
      "reference_sentence": "待反汇编的abc文件路径。",
      "line_num": 22,
      "context": "{\"17\":\"参数说明：\",\"18\":\"\",\"19\":\"| 参数 | 是否可缺省 | 描述 |\",\"20\":\"| -------- | -------- | -------- |\",\"21\":\"| [options] | 可缺省 | 命令选项，详见下文options选项说明。 |\",\"22\":\"| input_file | 不可缺省 | 待反汇编的方舟字节码文件路径。 |\",\"23\":\"| output_file | 不可缺省 | 反汇编内容的输出文件路径。 |\",\"24\":\"\",\"25\":\"options选项说明：\",\"26\":\"\",\"27\":\"| 选项 | 必填 | 存在入参 | 描述 |\"}",
      "用户拒绝的修改": "待反汇编的abc文件路径。",
      "注意事项": "修改前必须优先确认文档中已确立的标准术语，若原文术语在上下文或参考材料中已形成规范用法（如\"方舟字节码文件\"在参数表中明确使用），即使存在其他同义表述也应保留原始术语，避免破坏文档内部一致性。"
    },
    {
      "defect_id": 523084,
      "sentence": "方舟字节码中，除寄存器和累加器之外，还存在**全局变量**、**模块（[module](https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules)）命名空间和模块变量**、**词法环境和词法变量**、**补丁变量**4种值存储方式。",
      "reference_sentence": "方舟字节码中，除寄存器和累加器之外，还存在**全局变量**、**模块命名空间和模块变量**、**词法环境和词法变量**、**补丁变量**4种值存储方式。",
      "line_num": 8,
      "context": "{\"3\":\"## 总体设计\",\"4\":\"### 概述\",\"5\":\"方舟字节码（Ark Bytecode），是由方舟编译器编译ArkTS/TS/JS生成的，提供给方舟运行时解释执行的二进制文件。字节码中的主要内容是方舟字节码指令。<br>\",\"6\":\"本文旨在介绍方舟字节码指令相关的设计，将在后续章节中对构成指令的重要概念和具体的指令格式及含义进行说明，帮助开发者了解方舟字节码指令，指导开发者进行指令相关的特性开发工作。<br>\",\"7\":\"一条方舟字节码指令，由操作码（指令的名称）和指令入参列表组成。操作码包含无前缀的操作码和有前缀的操作码两种情况。寄存器、立即数以及string id/method id/literal id，均可以作为指令的入参，除此之外，部分指令中使用累加器作为默认参数。<br>\",\"8\":\"方舟字节码中，除寄存器和累加器之外，还存在**全局变量**、**模块（[module](https://262.ecma-international.org/12.0/#sec-ecmascript-language-scripts-and-modules)）命名空间和模块变量**、**词法环境和词法变量**、**补丁变量**4种值存储方式。指令可以使用这4种储值位置中的值作为入参。\",\"9\":\"\",\"10\":\"### 术语和约束\",\"11\":\"#### 术语\",\"12\":\"本文涉及的术语清单：\",\"13\":\"\"}",
      "用户拒绝的修改": "方舟字节码中，除寄存器和累加器之外，还存在**全局变量**、**模块命名空间和模块变量**、**词法环境和词法变量**、**补丁变量**4种值存储方式。",
      "注意事项": "修复术语不一致时需优先保留原文中的有效超链接和参考资料，确保在统一术语格式的同时不丢失关键引用信息；修改前应检查上下文是否存在特殊标注（如括号链接），避免过度简化破坏文档完整性。"
    },
    {
      "defect_id": 522269,
      "sentence": "`ADVANCE_LINE` | `0x02` |  | `sleb128 line_diff` | `line_diff`：`line`寄存器的值待增加的数值。 | `line`寄存器中的值加上`line_diff`，指向下一个行位置，而不生成位置条目。",
      "reference_sentence": "#### Line number program",
      "line_num": 417,
      "context": "{\"412\":\"\",\"413\":\"| **操作码**  | **值** | **指令参数**   | **常量池参数**    | **参数说明** | **说明**  |\",\"414\":\"| ----- | ----- | ------- | ---- | ------- | ------ |\",\"415\":\"| `END_SEQUENCE`         | `0x00`  |       |          |        | 标记行号程序的结束。    |\",\"416\":\"| `ADVANCE_PC`           | `0x01`  |    | `uleb128 addr_diff`   | `addr_diff`：`address`寄存器的值待增加的数值。    | `address`寄存器中的值加上`addr_diff`，指向下一个地址，而不生成位置条目。 |\",\"417\":\"| `ADVANCE_LINE`         | `0x02` |     | `sleb128 line_diff`  | `line_diff`：`line`寄存器的值待增加的数值。    | `line`寄存器中的值加上`line_diff`，指向下一个行位置，而不生成位置条目。 |\",\"418\":\"| `START_LOCAL`          | `0x03` | `sleb128 register_num` | `uleb128 name_idx`<br>`uleb128 type_idx`   | `register_num`：将包含局部变量的寄存器。<br>`name_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的名称。<br>`type_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的类型。 | 在当前地址中引入一个带有名称和类型的局部变量。将要包含这个变量的寄存器的编号被编码在指令中。如果寄存器的编号是-1，则意味着这个是累加器寄存器。`name_idx`和`type_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"419\":\"| `START_LOCAL_EXTENDED` | `0x04` | `sleb128 register_num` | `uleb128 name_idx`<br>`uleb128 type_idx`<br>`uleb128 sig_idx` | `register_num`：将包含局部变量的寄存器。<br>`name_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的名称。<br>`type_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的类型。<br>`sig_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的签名。 | 在当前地址中引入一个带有名称、类型和签名的局部变量。将要包含这个变量的寄存器的编号被编码在指令中。如果寄存器的编号是-1，则意味着这个是累加器寄存器。`name_idx`、`type_idx`和`sig_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"420\":\"| `END_LOCAL`            | `0x05` | `sleb128 register_num` |    | `register_num`：包含局部变量的寄存器。  | 在当前地址将指定寄存器中的局部变量标记为超出范围。寄存器的编号为-1，则意味着是累加器寄存器。 |\",\"421\":\"| `SET_FILE`             | `0x09`  |    | `uleb128 name_idx`  | `name_idx`：一个偏移量，指向[字符串](#字符串)，表示文件的名称。 | 设置file寄存器的值。`name_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"422\":\"| `SET_SOURCE_CODE`      | `0x0a`  |    | `uleb128 source_idx` | `source_idx`：一个偏移量，指向[字符串](#字符串)，表示文件的源码。 | 设置`source_code`寄存器的值。`source_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\"}",
      "用户拒绝的修改": "`ADVANCE_LINE` | `0x02` |  | `sleb128 line_diff` | `line_diff`：`line`寄存器的值待增加的数值。 | `line`寄存器的值加上`line_diff`，指向下一个行位置，而不生成位置条目。",
      "注意事项": "修复时应严格保持技术术语的一致性，优先沿用原文的固定表述（如\"寄存器中的值\"），避免同义词替换；修改前需全局检索文档确认是否存在统一用词规范。"
    },
    {
      "defect_id": 522302,
      "sentence": "八字节编码      | `uint64_t`   | 八字节的值，8个字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。",
      "reference_sentence": "描述字节码文件中的字面量，根据字面量值的字节数的不同，有四种编码格式，分别是单字节编码、双字节编码、四字节编码、八字节编码。根据不同数值长度对应相适应的编译格式，优化字节码文件大小。",
      "line_num": 538,
      "context": "{\"533\":\"| **名称** | **格式** | **说明** |\",\"534\":\"| -------------- | ------------ | -------------- |\",\"535\":\"| 单字节编码      | `uint8_t`    | 单字节的值，单字节对齐，存储用于简单类型的字面量，例如`BOOL`字面量。   |\",\"536\":\"| 双字节编码      | `uint16_t`   | 双字节的值，2个字节对齐，存储16位整型字面量。   |\",\"537\":\"| 四字节编码      | `uint32_t`   | 四字节的值，4个字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。   |\",\"538\":\"| 八字节编码      | `uint64_t`   | 八字节的值，8个字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。   |\"}",
      "用户拒绝的修改": "八字节编码      | `uint64_t`   | 八字节的值，8字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。",
      "注意事项": "修复时应严格保持上下文已有的格式模板和术语体系（如\"X个字节对齐\"的固定表述），避免为追求局部简洁性破坏文档整体一致性；优先核对相邻条目表达方式，确保数值单位、量词结构、专业术语等细节完全统一。"
    },
    {
      "defect_id": 522301,
      "sentence": "四字节编码      | `uint32_t`   | 四字节的值，4个字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。",
      "reference_sentence": "描述字节码文件中的字面量，根据字面量值的字节数的不同，有四种编码格式，分别是单字节编码、双字节编码、四字节编码、八字节编码。根据不同数值长度对应相适应的编译格式，优化字节码文件大小。",
      "line_num": 537,
      "context": "{\"532\":\"\",\"533\":\"| **名称** | **格式** | **说明** |\",\"534\":\"| -------------- | ------------ | -------------- |\",\"535\":\"| 单字节编码      | `uint8_t`    | 单字节的值，单字节对齐，存储用于简单类型的字面量，例如`BOOL`字面量。   |\",\"536\":\"| 双字节编码      | `uint16_t`   | 双字节的值，2个字节对齐，存储16位整型字面量。   |\",\"537\":\"| 四字节编码      | `uint32_t`   | 四字节的值，4个字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。   |\",\"538\":\"| 八字节编码      | `uint64_t`   | 八字节的值，8个字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。   |\"}",
      "用户拒绝的修改": "四字节编码      | `uint32_t`   | 四字节的值，4字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。",
      "注意事项": "保持量词使用与上下文严格一致（如\"4个字节\"vs\"4字节\"），优先沿用原文表述；核查全文档术语统一性（如\"字面量/字面值\"），避免局部修正引发新矛盾。"
    },
    {
      "defect_id": 523034,
      "sentence": "显示配套方舟字节码文件版本号以及最低支持的方舟字节码文件版本。",
      "reference_sentence": "显示配套abc文件版本号以及最低支持的abc文件版本。",
      "line_num": 35,
      "context": "{\"30\":\"| --debug-file | 否 | 是 | 如果使能了--debug，指定调试信息的输出文件。 |\",\"31\":\"| --help | 否 | 否 | 打印帮助提示。 |\",\"32\":\"| --skip-string-literals | 否 | 否 | 跳过对字符串字面量的反汇编。 |\",\"33\":\"| --quiet | 否 | 否 | 使能所有'--skip-'开头的选项。 |\",\"34\":\"| --verbose | 否 | 否 | 使能输出额外信息（字节位置、方舟字节码格式、操作码）。 |\",\"35\":\"| --version | 否 | 否 | 显示配套方舟字节码文件版本号以及最低支持的方舟字节码文件版本。 |\",\"36\":\"\",\"37\":\"## 使用示例\",\"38\":\"\",\"39\":\"假设已存在方舟字节码文件：test.abc，其源代码如下：\",\"40\":\"\"}",
      "用户拒绝的修改": "显示配套的abc文件版本号以及最低支持的abc文件版本。",
      "注意事项": "保持术语一致性时需优先沿用上下文已有命名（如\"方舟字节码文件\"），若需替换缩略语（如\"abc文件\"）必须全局统一修改并验证上下文关联性，避免局部修改导致术语混用。"
    },
    {
      "defect_id": 522300,
      "sentence": "双字节编码      | `uint16_t`   | 双字节的值，2个字节对齐，存储16位整型字面量。",
      "reference_sentence": "描述字节码文件中的字面量，根据字面量值的字节数的不同，有四种编码格式，分别是单字节编码、双字节编码、四字节编码、八字节编码。根据不同数值长度对应相适应的编译格式，优化字节码文件大小。",
      "line_num": 536,
      "context": "{\"531\":\"- 格式：\",\"532\":\"\",\"533\":\"| **名称** | **格式** | **说明** |\",\"534\":\"| -------------- | ------------ | -------------- |\",\"535\":\"| 单字节编码      | `uint8_t`    | 单字节的值，单字节对齐，存储用于简单类型的字面量，例如`BOOL`字面量。   |\",\"536\":\"| 双字节编码      | `uint16_t`   | 双字节的值，2个字节对齐，存储16位整型字面量。   |\",\"537\":\"| 四字节编码      | `uint32_t`   | 四字节的值，4个字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。   |\",\"538\":\"| 八字节编码      | `uint64_t`   | 八字节的值，8个字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。   |\"}",
      "用户拒绝的修改": "双字节编码      | `uint16_t`   | 2字节的值，存储16位整型字面量。",
      "注意事项": "修改时应保留原文关键技术细节（如\"2个字节对齐\"的存储特性），保持与上下文其他条目（单/四/八字节编码）的\"值描述+对齐方式+存储内容\"结构一致性，避免因简化导致技术信息丢失。"
    },
    {
      "defect_id": 523085,
      "sentence": "* 本文仅适用于版本号为12.0.6.0的方舟字节码（版本号为方舟编译器内部保留字段，开发者无需关注）。",
      "reference_sentence": "* 本文仅适用于版本号为12.0.6.0的方舟字节码（版本号为方舟编译器内部保留字段，开发者无需关注）。",
      "line_num": 28,
      "context": "{\"23\":\"|  lexical environment\\t|  词法环境，用来存放闭包变量的语义环境。   |\",\"24\":\"|  lexical variable\\t|  词法变量，词法环境中所存的闭包变量。   |\",\"25\":\"\",\"26\":\"#### 约束\",\"27\":\"* 本文中所有采用代码形式描述的内容均遵循[ArkTS语言规范](../quick-start/introduction-to-arkts.md)。\",\"28\":\"* 本文仅适用于版本号为12.0.6.0的方舟字节码（版本号为方舟编译器内部保留字段，开发者无需关注）。\",\"29\":\"\",\"30\":\"### 字节码构成\",\"31\":\"#### 操作码与前缀\",\"32\":\"方舟字节码中的操作码通常被编码为一个8位的值，因此至多只能有256个操作码。随着方舟编译器运行时功能的演进，字节码的数量也在逐步增加，已经超过了256个。因此，方舟字节码引入了前缀（prefix），将操作码最大宽度从8位扩展到16位。8位操作码（无前缀的）用于表示频繁出现的指令，16位操作码（有前缀的）用于表示出现频率不高的指令。<br>\",\"33\":\"带前缀的操作码为小端法存储的16位值，由8位操作码和8位前缀组成，编码规则为：操作码左移8位，再与前缀相或。\"}",
      "用户拒绝的修改": "* 本文仅适用于版本号为12.0.6.0的方舟字节码（ArkCompiler Bytecode）（版本号为方舟编译器内部保留字段，开发者无需关注）。",
      "注意事项": "在补充术语翻译或扩展时，需优先检查上下文是否存在统一的术语使用习惯，若原文未使用双语标注或用户强调简洁性，应保留原表述，避免过度补充导致冗余或风格不一致。"
    },
    {
      "defect_id": 522902,
      "sentence": "如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性",
      "reference_sentence": "如果匿名函数定义时被赋值给了一个变量",
      "line_num": 71,
      "context": "{\"66\":\"#### 特殊情况\",\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。比如下面的例子：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么它的原函数名则是这个属性名。\",\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\"}",
      "用户拒绝的修改": "如果匿名函数在对象字面量中定义并且被赋值给了一个属性",
      "注意事项": "保持技术术语的精确性，修复时不得删除关键限定词（如\"字面量\"），确保对比场景中变量赋值与字面量属性赋值的表述严格区分。"
    },
    {
      "defect_id": 522299,
      "sentence": "单字节编码      | `uint8_t`    | 单字节的值，单字节对齐，存储用于简单类型的字面量，例如`BOOL`字面量。",
      "reference_sentence": "描述字节码文件中的字面量，根据字面量值的字节数的不同，有四种编码格式，分别是单字节编码、双字节编码、四字节编码、八字节编码。根据不同数值长度对应相适应的编译格式，优化字节码文件大小。",
      "line_num": 535,
      "context": "{\"530\":\"- 对齐方式：每种格式都有对应的对齐规则。\",\"531\":\"- 格式：\",\"532\":\"\",\"533\":\"| **名称** | **格式** | **说明** |\",\"534\":\"| -------------- | ------------ | -------------- |\",\"535\":\"| 单字节编码      | `uint8_t`    | 单字节的值，单字节对齐，存储用于简单类型的字面量，例如`BOOL`字面量。   |\",\"536\":\"| 双字节编码      | `uint16_t`   | 双字节的值，2个字节对齐，存储16位整型字面量。   |\",\"537\":\"| 四字节编码      | `uint32_t`   | 四字节的值，4个字节对齐，存储32位数值字面量，例如`INTEGER`整数型字面量，或`FLOAT`浮点型字面量。   |\",\"538\":\"| 八字节编码      | `uint64_t`   | 八字节的值，8个字节对齐，存储64位数值字面量，例如`DOUBLE`双精度浮点型字面量。   |\"}",
      "用户拒绝的修改": "单字节编码      | `uint8_t`    | 单字节的值，对齐方式为单字节，用于存储简单类型的字面量，例如`BOOL`字面量。",
      "注意事项": "保持专业术语一致性（如统一使用\"字面量\"而非\"字面值\"），修改时需保留原始格式的简洁性（如\"单字节对齐\"比\"对齐方式为单字节\"更符合表格语境），避免过度解释破坏原有信息结构。"
    },
    {
      "defect_id": 522034,
      "sentence": "### ClassIndexClassIndex结构的作用是通过名称快速地定位到Class的定义。",
      "reference_sentence": "### ForeignClass描述字节码文件中的外部类。外部类在其他文件中声明，并在当前字节码文件中被引用。",
      "line_num": 119,
      "context": "{\"114\":\"> \",\"115\":\"> 通过ForeignMethod的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"116\":\"\",\"117\":\"\",\"118\":\"### ClassIndex\",\"119\":\"ClassIndex结构的作用是通过名称快速地定位到Class的定义。\",\"120\":\"\",\"121\":\"- 对齐方式：4个字节。\",\"122\":\"- 格式：\",\"123\":\"\",\"124\":\"| **名称** | **格式** | **说明**                                               |\"}",
      "用户拒绝的修改": "### ClassIndexClassIndex结构的作用是通过名称快速地定位到类的定义。",
      "注意事项": "严格区分术语标签和普通描述中的用词，优先保持术语标签的原文形式（如`ClassIndex`中的\"Class\"），仅在普通描述语句中统一术语译法（如\"类\"），避免修改作为专有名称组成部分的关键词。"
    },
    {
      "defect_id": 522250,
      "sentence": "程序计数器（指向方法的某个指令），只能单调递增。",
      "reference_sentence": "### DebugInfo",
      "line_num": 402,
      "context": "{\"397\":\"#### State machine\",\"398\":\"状态机（State machine）的作用是产生[DebugInfo](#debuginfo)信息。状态机中有以下的寄存器：\",\"399\":\"\",\"400\":\"| **名称**    | **初始值**                                             | **说明**                                               |\",\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\"}",
      "用户拒绝的修改": "地址寄存器（指向方法的某个指令），只能单调递增。",
      "注意事项": "在统一术语时需优先确认技术准确性，若原术语（如“程序计数器”）在上下文中已被明确关联且无歧义（如表格内`address`字段的说明），应保留原术语而非强制与字段名一致。"
    },
    {
      "defect_id": 523474,
      "sentence": "资源管理导入sendableResourceManager模块，通过调用[resourceToSendableResource](#sendableresourcemanagerresourcetosendableresource)和[sendableResourceToResource](#sendableresourcemanagersendableresourcetoresource)方法可以将[Resource](#resource)对象和[SendableResource](#sendableresource)对象进行互转。",
      "reference_sentence": "Resource对象通过转换为SendableResource对象后，可以被[Sendable类](../../arkts-utils/arkts-sendable.md)持有。Sendable类在跨线程传输后，取出持有的SendableResource对象转为Resource对象，作为参数获取资源。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.sendableResourceManager (资源管理)\",\"2\":\"\",\"3\":\"资源管理导入sendableResourceManager模块，通过调用[resourceToSendableResource](#sendableresourcemanagerresourcetosendableresource)和[sendableResourceToResource](#sendableresourcemanagersendableresourcetoresource)方法可以将[Resource](#resource)对象和[SendableResource](#sendableresource)对象进行互转。\",\"4\":\"\",\"5\":\"Resource对象通过转换为SendableResource对象后，可以被[Sendable类](../../arkts-utils/arkts-sendable.md)持有。Sendable类在跨线程传输后，取出持有的SendableResource对象转为Resource对象，作为参数获取资源。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\"}",
      "用户拒绝的修改": "Resource模块通过调用[resourceToSendableResource](#sendableresourcemanagerresourcetosendableresource)和[sendableResourceToResource](#sendableresourcemanagersendableresourcetoresource)方法可以将[Resource](#resource)对象和[SendableResource](#sendableresource)对象进行互转。",
      "注意事项": "在统一术语表述时应优先保留技术模块的官方命名（如\"资源管理\"），避免将功能描述性词汇强制替换为类名（如\"Resource\"），同时需确认上下文是否存在需要保持差异化的专业术语用法。"
    },
    {
      "defect_id": 522190,
      "sentence": "一个指向定义该字段的类型的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型。",
      "reference_sentence": "一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。",
      "line_num": 180,
      "context": "{\"175\":\"- 格式：\",\"176\":\"\",\"177\":\"| **名称** | **格式** | **说明**                                               |\",\"178\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"179\":\"| `class_idx`      | `uint16_t`       | 一个指向该字段从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。 |\",\"180\":\"| `type_idx`       | `uint16_t`       | 一个指向定义该字段的类型的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型。 |\",\"181\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示字段的名称。 |\",\"182\":\"| `reserved`       | `uleb128`        | 方舟字节码文件内部使用的保留字段。                           |\",\"183\":\"| `field_data`     | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[FieldTag](#fieldtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"184\":\"\",\"185\":\"> **注意：**\"}",
      "用户拒绝的修改": "一个指向定义该字段的类型的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。",
      "注意事项": "修复时应确保术语指向对象与字段定义严格对应（如\"类型\"vs\"类\"），避免机械复制相似句式导致语义偏移；需同时检查上下文关联字段的描述差异，保持逻辑一致性而非单纯句式统一。"
    },
    {
      "defect_id": 522229,
      "sentence": "通过Annotation的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。",
      "reference_sentence": "一个指向当前Annotation所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。",
      "line_num": 318,
      "context": "{\"313\":\"| `elements`       | AnnotationElement[] | 一个数组，数组的每个元素都是[AnnotationElement](#annotationelement)类型。 |\",\"314\":\"| `element_types`  | `uint8_t[]`  | 一个数组，数组的每个元素都是[AnnotationElementTag](#annotationelementtag)类型，用于描述一个AnnotationElement。每个元素在`element_types`数组中的位置和其对应的AnnotationElement在`elements`数组中的位置一致。 |\",\"315\":\"\",\"316\":\"> **注意：**\",\"317\":\"> \",\"318\":\"> 通过Annotation的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"319\":\"\",\"320\":\"\",\"321\":\"### AnnotationElementTag\",\"322\":\"\",\"323\":\"| **名称** | **标记** |\"}",
      "用户拒绝的修改": "通过Annotation的索引，可以找到索引所在的IndexHeader以解析`class_idx`。",
      "注意事项": "保持技术术语一致性时需严格验证上下文定义，避免将具有特定技术含义的术语（如\"偏移量\"和\"索引\"）视为同义词替换，优先沿用原文术语并参考关联段落中的概念定义。"
    },
    {
      "defect_id": 522268,
      "sentence": "`END_SEQUENCE` | `0x00` |  |  | 标记行号程序的结束。",
      "reference_sentence": "#### Line number program",
      "line_num": 415,
      "context": "{\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\",\"412\":\"\",\"413\":\"| **操作码**  | **值** | **指令参数**   | **常量池参数**    | **参数说明** | **说明**  |\",\"414\":\"| ----- | ----- | ------- | ---- | ------- | ------ |\",\"415\":\"| `END_SEQUENCE`         | `0x00`  |       |          |        | 标记行号程序的结束。    |\",\"416\":\"| `ADVANCE_PC`           | `0x01`  |    | `uleb128 addr_diff`   | `addr_diff`：`address`寄存器的值待增加的数值。    | `address`寄存器中的值加上`addr_diff`，指向下一个地址，而不生成位置条目。 |\",\"417\":\"| `ADVANCE_LINE`         | `0x02` |     | `sleb128 line_diff`  | `line_diff`：`line`寄存器的值待增加的数值。    | `line`寄存器中的值加上`line_diff`，指向下一个行位置，而不生成位置条目。 |\",\"418\":\"| `START_LOCAL`          | `0x03` | `sleb128 register_num` | `uleb128 name_idx`<br>`uleb128 type_idx`   | `register_num`：将包含局部变量的寄存器。<br>`name_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的名称。<br>`type_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的类型。 | 在当前地址中引入一个带有名称和类型的局部变量。将要包含这个变量的寄存器的编号被编码在指令中。如果寄存器的编号是-1，则意味着这个是累加器寄存器。`name_idx`和`type_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"419\":\"| `START_LOCAL_EXTENDED` | `0x04` | `sleb128 register_num` | `uleb128 name_idx`<br>`uleb128 type_idx`<br>`uleb128 sig_idx` | `register_num`：将包含局部变量的寄存器。<br>`name_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的名称。<br>`type_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的类型。<br>`sig_idx`：一个偏移量，指向[字符串](#字符串)，表示变量的签名。 | 在当前地址中引入一个带有名称、类型和签名的局部变量。将要包含这个变量的寄存器的编号被编码在指令中。如果寄存器的编号是-1，则意味着这个是累加器寄存器。`name_idx`、`type_idx`和`sig_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"420\":\"| `END_LOCAL`            | `0x05` | `sleb128 register_num` |    | `register_num`：包含局部变量的寄存器。  | 在当前地址将指定寄存器中的局部变量标记为超出范围。寄存器的编号为-1，则意味着是累加器寄存器。 |\"}",
      "用户拒绝的修改": "`END_SEQUENCE` | `0x00` |  |  | 结束行号程序。",
      "注意事项": "保持术语一致性，优先沿用原文已定义的专业表述；修改时需核对上下文确保技术概念描述方式统一，避免同义词替换导致语义偏差。"
    },
    {
      "defect_id": 524729,
      "sentence": "| FREE<sup>20+</sup>   | 4 | 自由滚动。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|",
      "reference_sentence": "| Free<sup>(deprecated) </sup> | 2 | 支持竖直或水平方向滚动。<br/> 从API version 9开始废弃，无替代接口。|",
      "line_num": 236,
      "context": "{\"231\":\"| ---------- | -- | ------------------------ |\",\"232\":\"| Vertical   | 0  | 仅支持竖直方向滚动。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"233\":\"| Horizontal | 1  | 仅支持水平方向滚动。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"234\":\"| Free<sup>(deprecated) </sup> | 2 | 支持竖直或水平方向滚动。<br/> 从API version 9开始废弃，无替代接口。|\",\"235\":\"| None       | 3 | 不可滚动。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"236\":\"| FREE<sup>20+</sup>   | 4 | 自由滚动。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"237\":\"\",\"238\":\"## ScrollSnapOptions<sup>10+</sup>对象说明\",\"239\":\"\",\"240\":\"限位滚动模式对象。\",\"241\":\"\"}",
      "用户拒绝的修改": "| Free<sup>20+</sup>   | 4 | 自由滚动。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|",
      "注意事项": "修复术语大小写时必须严格核对上下文中的历史版本和已废弃条目，确保同一术语在不同版本中的大小写形式与文档既有规范保持一致，避免因统一格式而破坏版本区分或语义差异。"
    },
    {
      "defect_id": 522247,
      "sentence": "调试信息（DebugInfo）包含方法的程序计数器与源代码中的行列号之间的映射以及有关局部变量的信息。",
      "reference_sentence": "### DebugInfo",
      "line_num": 378,
      "context": "{\"373\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"374\":\"| `offsets`        | `uint32_t[]`     | 一个数组，数组中每个元素的值是一个偏移量，指向一个行号程序。数组长度由[Header](#header)中的`num_lnps`指定。 |\",\"375\":\"\",\"376\":\"\",\"377\":\"### DebugInfo\",\"378\":\"调试信息（DebugInfo）包含方法的程序计数器与源代码中的行列号之间的映射以及有关局部变量的信息。调试信息的格式由[DWARF调试信息格式第3版](https://dwarfstd.org/dwarf3std.html)（见第6.2项）的内容演变形成。基于状态机（State machine）的执行模型对行号程序（Line number program)进行解释，可得到映射和局部变量信息编码。为对不同方法的相同行号程序进行去重，程序中引用的所有常量都被移动到了常量池（Constant pool）中。\",\"379\":\"\",\"380\":\"- 对齐方式：单字节对齐。\",\"381\":\"- 格式：\",\"382\":\"\",\"383\":\"| **名称**          | **格式** | **说明**                                               |\"}",
      "用户拒绝的修改": "DebugInfo 包含方法的程序计数器与源代码中的行列号之间的映射以及有关局部变量的信息。",
      "注意事项": "在统一术语时需区分首次提及（应保留全称+括号注释）与后续引用（可直接使用缩写），避免机械统一导致首次定义不完整或信息丢失。"
    },
    {
      "defect_id": 522160,
      "sentence": "| `methods`        | `Method[]`       | Class的方法的数组，数组中每一个元素都是[Method](#method)类型。数组长度由`num_methods`指定。 |",
      "reference_sentence": "| `methods`        | `Method[]`       | Class的方法的数组，数组中每一个元素都是[Method](#method)类型。数组长度由`num_methods`指定。 |",
      "line_num": 144,
      "context": "{\"139\":\"| `access_flags`   | `uleb128`        | Class的访问标志，是[ClassAccessFlag](#classaccessflag)的组合。 |\",\"140\":\"| `num_fields`     | `uleb128`        | Class的字段的数量。                                          |\",\"141\":\"| `num_methods`    | `uleb128`        | Class的方法的数量。                                          |\",\"142\":\"| `class_data`     | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[ClassTag](#classtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"143\":\"| `fields`         | `Field[]`        | Class的字段的数组，数组中每一个元素都是[Field](#field)类型。数组长度由`num_fields`指定。 |\",\"144\":\"| `methods`        | `Method[]`       | Class的方法的数组，数组中每一个元素都是[Method](#method)类型。数组长度由`num_methods`指定。 |\",\"145\":\"\",\"146\":\"\",\"147\":\"### ClassAccessFlag\",\"148\":\"\",\"149\":\"| **名称** | **值** | **说明**                                               |\"}",
      "用户拒绝的修改": "| `methods`        | `Method[]`       | 类的方法的数组，数组中每一个元素都是[Method](#method)类型。数组长度由`num_methods`指定。 |",
      "注意事项": "修复时应严格检查上下文术语一致性，优先沿用已有命名格式（如\"Class\"），避免中英文术语混用，特别需核对相邻条目的表述方式。"
    },
    {
      "defect_id": 522266,
      "sentence": "根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。",
      "reference_sentence": "#### Line number program",
      "line_num": 411,
      "context": "{\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\",\"412\":\"\",\"413\":\"| **操作码**  | **值** | **指令参数**   | **常量池参数**    | **参数说明** | **说明**  |\",\"414\":\"| ----- | ----- | ------- | ---- | ------- | ------ |\",\"415\":\"| `END_SEQUENCE`         | `0x00`  |       |          |        | 标记行号程序的结束。    |\",\"416\":\"| `ADVANCE_PC`           | `0x01`  |    | `uleb128 addr_diff`   | `addr_diff`：`address`寄存器的值待增加的数值。    | `address`寄存器中的值加上`addr_diff`，指向下一个地址，而不生成位置条目。 |\"}",
      "用户拒绝的修改": "根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者从常量池中获取（也称为常量池参数）。",
      "注意事项": "保持技术文档中关键术语的严格一致性，避免在定义性描述中替换具有功能指向性的动词（如\"需要\"改为\"从\"可能弱化必要性）；修改时应优先核查上下文是否存在已建立的术语体系，确保修饰语调整不改变技术行为的强制属性。"
    },
    {
      "defect_id": 525096,
      "sentence": "| value  | [ScrollDirection](#scrolldirection枚举说明) | 是   | 滚动方向。<br/>默认值：ScrollDirection.Vertical<br/>**说明：** <br/>当滚动方向设置为ScrollDirection.FREE时，Scroll组件仅支持[scrollBar](#scrollbar)、[scrollBarColor](#scrollbarcolor)、[scrollBarWidth](#scrollbarwidth)、[scrollBarMargin](./ts-container-scrollable-common.md#scrollbarmargin20)、[edgeEffect](#edgeeffect)(仅支持[Spring](ts-appendix-enums.md#edgeeffect)和[None](ts-appendix-enums.md#edgeeffect)边缘滑动效果)、[enableScrollInteraction](#enablescrollinteraction10)、[friction](#friction10)、[clipContent](./ts-container-scrollable-common.md#clipcontent14)、[initialOffset](#initialoffset12)、[scrollable](#scrollable)属性，[onWillScroll](#onwillscroll12)、[onDidScroll](#ondidscroll12)、[onScrollEdge](#onscrolledge)、[onScrollStart](#onscrollstart9)、[onScrollStop](#onscrollstop9)事件和[scrollTo](#scrollto)、[scrollEdge](#scrolledge)、[scrollPage](#scrollpage9)、[currentOffset](#currentoffset)、[scrollBy](#scrollby9)、[getItemRect](#getitemrect11)Scroller控制器方法。 |",
      "reference_sentence": "无",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"**参数：** \",\"50\":\"\",\"51\":\"| 参数名 | 类型                                        | 必填 | 说明                                            |\",\"52\":\"| ------ | ------------------------------------------- | ---- | ----------------------------------------------- |\",\"53\":\"| value  | [ScrollDirection](#scrolldirection枚举说明) | 是   | 滚动方向。<br/>默认值：ScrollDirection.Vertical<br/>**说明：** <br/>当滚动方向设置为ScrollDirection.FREE时，Scroll组件仅支持[scrollBar](#scrollbar)、[scrollBarColor](#scrollbarcolor)、[scrollBarWidth](#scrollbarwidth)、[scrollBarMargin](./ts-container-scrollable-common.md#scrollbarmargin20)、[edgeEffect](#edgeeffect)(仅支持[Spring](ts-appendix-enums.md#edgeeffect)和[None](ts-appendix-enums.md#edgeeffect)边缘滑动效果)、[enableScrollInteraction](#enablescrollinteraction10)、[friction](#friction10)、[clipContent](./ts-container-scrollable-common.md#clipcontent14)、[initialOffset](#initialoffset12)、[scrollable](#scrollable)属性，[onWillScroll](#onwillscroll12)、[onDidScroll](#ondidscroll12)、[onScrollEdge](#onscrolledge)、[onScrollStart](#onscrollstart9)、[onScrollStop](#onscrollstop9)事件和[scrollTo](#scrollto)、[scrollEdge](#scrolledge)、[scrollPage](#scrollpage9)、[currentOffset](#currentoffset)、[scrollBy](#scrollby9)、[getItemRect](#getitemrect11)Scroller控制器方法。 |\",\"54\":\"\",\"55\":\"### scrollBar\",\"56\":\"\",\"57\":\"scrollBar(barState: BarState)\",\"58\":\"\"}",
      "用户拒绝的修改": "| value  | [ScrollDirection](#scrolldirection枚举说明) | 是   | 滚动方向。<br/>默认值：ScrollDirection.Vertical<br/>**说明：** <br/>当滚动方向设置为ScrollDirection.FREE时，Scroll组件仅支持[scrollBar](#scrollbar)、[scrollBarColor](#scrollbarcolor)、[scrollBarWidth](#scrollbarwidth)、[scrollBarMargin](./ts-container-scrollable-common.md#scrollbarmargin)、[edgeEffect](#edgeeffect)(仅支持[Spring](ts-appendix-enums.md#edgeeffect)和[None](ts-appendix-enums.md#edgeeffect)边缘回弹动画)、[enableScrollInteraction](#enablescrollinteraction10)、[friction](#friction10)、[clipContent](./ts-container-scrollable-common.md#clipcontent14)、[initialOffset](#initialoffset12)、[scrollable](#scrollable)属性，[onWillScroll](#onwillscroll12)、[onDidScroll](#ondidscroll12)、[onScrollEdge](#onscrolledge)、[onScrollStart](#onscrollstart9)、[onScrollStop](#onscrollstop9)事件和[scrollTo](#scrollto)、[scrollEdge](#scrolledge)、[scrollPage](#scrollpage9)、[currentOffset](#currentoffset)、[scrollBy](#scrollby9)、[getItemRect](#getitemrect11)Scroller控制器方法。 |",
      "注意事项": "修复时应严格检查术语统一性（如\"边缘滑动效果\"与\"边缘回弹动画\"）和链接版本标识（如scrollbarmargin20与scrollbarmargin），确保与上下文及文档其他部分完全一致，避免因局部修改产生新的不一致。"
    },
    {
      "defect_id": 523942,
      "sentence": "使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param和duration必填。",
      "reference_sentence": "使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param选填，且不生效。",
      "line_num": 147,
      "context": "{\"142\":\"\",\"143\":\"| 名称                | 值   | 说明                                                         |\",\"144\":\"| ------------------- | ---- | ------------------------------------------------------------ |\",\"145\":\"| LINEAR              | 0    | 表示动画从头到尾的速度都是相同的。<br/>使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中duration必填。<br/>使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param选填，且不生效。 |\",\"146\":\"| INTERPOLATION_SPRING | 1    | 表示插值器弹簧曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。动画时间由曲线参数决定，不受[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的duration参数控制。<br/>使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中duration选填，且不生效。<br/>使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param必填。 |\",\"147\":\"| CUBIC_BEZIER | 2    | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。<br/>使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param和duration必填。 |\",\"148\":\"\",\"149\":\"## WindowTransitionType<sup>20+</sup>\",\"150\":\"\",\"151\":\"窗口转场动画类型枚举。\",\"152\":\"\"}",
      "用户拒绝的修改": "使用该曲线类型时[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中param和duration均必填。",
      "注意事项": "修复时必须严格核对上下文参数要求，区分不同曲线类型的独立规则，避免将其他类型的参数限制错误套用至当前条目，确保同一参数在不同类型下的必填/选填状态表述无矛盾。"
    },
    {
      "defect_id": 522191,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示字段的名称。",
      "reference_sentence": "一个偏移量，指向[字符串](#字符串)，表示方法名称。",
      "line_num": 181,
      "context": "{\"176\":\"\",\"177\":\"| **名称** | **格式** | **说明**                                               |\",\"178\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"179\":\"| `class_idx`      | `uint16_t`       | 一个指向该字段从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。 |\",\"180\":\"| `type_idx`       | `uint16_t`       | 一个指向定义该字段的类型的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型。 |\",\"181\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示字段的名称。 |\",\"182\":\"| `reserved`       | `uleb128`        | 方舟字节码文件内部使用的保留字段。                           |\",\"183\":\"| `field_data`     | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[FieldTag](#fieldtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"184\":\"\",\"185\":\"> **注意：**\",\"186\":\"> \"}",
      "用户拒绝的修改": "一个偏移量，指向表示字段名称的[字符串](#字符串)。",
      "注意事项": "修复时应严格保持上下文中的并列结构一致性，优先检查相邻条目（如字段和方法的`name_off`说明）是否采用相同句式，避免因局部优化破坏整体格式统一。"
    },
    {
      "defect_id": 522265,
      "sentence": "一个行号程序（Line number program）由指令组成。",
      "reference_sentence": "#### Line number program",
      "line_num": 411,
      "context": "{\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\",\"412\":\"\",\"413\":\"| **操作码**  | **值** | **指令参数**   | **常量池参数**    | **参数说明** | **说明**  |\",\"414\":\"| ----- | ----- | ------- | ---- | ------- | ------ |\",\"415\":\"| `END_SEQUENCE`         | `0x00`  |       |          |        | 标记行号程序的结束。    |\",\"416\":\"| `ADVANCE_PC`           | `0x01`  |    | `uleb128 addr_diff`   | `addr_diff`：`address`寄存器的值待增加的数值。    | `address`寄存器中的值加上`addr_diff`，指向下一个地址，而不生成位置条目。 |\"}",
      "用户拒绝的修改": "一个行号程序由指令组成。",
      "注意事项": "保留首次出现的术语中英文对照（如\"行号程序（Line number program）\"），确保技术文档中核心概念的双语一致性；若上下文已明确术语英文对应（如标题#### Line number program），则正文无需重复括号注释，避免冗余。"
    },
    {
      "defect_id": 522222,
      "sentence": "通过Method的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。",
      "reference_sentence": "通过Field的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`和`type_idx`。",
      "line_num": 222,
      "context": "{\"217\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"218\":\"| `method_data`    | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[MethodTag](#methodtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"219\":\"\",\"220\":\"> **注意：**\",\"221\":\"> \",\"222\":\"> 通过Method的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"223\":\"\",\"224\":\"\",\"225\":\"### MethodIndexData\",\"226\":\"MethodIndexData是一个无符号32位整数，划分为3个部分。\",\"227\":\"\"}",
      "用户拒绝的修改": "通过Method的偏移量，可以找到对应的IndexHeader以解析`class_idx`。",
      "注意事项": "修复时必须保留原句的关键位置限定词（如\"所在的\"），避免过度简化导致定位信息丢失；严格区分上下文中的专业术语边界（如Method/Field），禁止跨概念替换影响准确性。"
    },
    {
      "defect_id": 522033,
      "sentence": "`name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。",
      "reference_sentence": "`class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是一个指向[Class](#class)或[ForeignClass](#foreignclass)的偏移量。",
      "line_num": 110,
      "context": "{\"105\":\"\",\"106\":\"| **名称** | **格式** | **说明**                                               |\",\"107\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"108\":\"| `class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是一个指向[Class](#class)或[ForeignClass](#foreignclass)的偏移量。 |\",\"109\":\"| `reserved`       | `uint16_t`       | 方舟字节码文件内部使用的保留字段。               |\",\"110\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。 |\",\"111\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"112\":\"\",\"113\":\"> **注意：**\",\"114\":\"> \",\"115\":\"> 通过ForeignMethod的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\"}",
      "用户拒绝的修改": "`name_off`       | `uint32_t`       | 一个指向[字符串](#字符串)的索引，表示方法名称。",
      "注意事项": "在修复术语不一致时，必须优先检查文档中所有相关字段的用词惯例，确保全局统一性；若文档中存在类似\"索引指向偏移量\"的嵌套结构，需严格区分不同层级的概念表述，避免混淆\"索引\"和\"偏移量\"等具有技术差异的术语。"
    },
    {
      "defect_id": 523889,
      "sentence": "确定贝塞尔曲线第二点纵坐标。类型为number，必填，取值范围：(-∞, +∞)。",
      "reference_sentence": "确定贝塞尔曲线第一点横坐标。类型为number，必填，取值范围：[0, 1]，设置的值小于0时，按0处理；设置的值大于1时，按1处理。",
      "line_num": 59,
      "context": "{\"54\":\"\",\"55\":\"- y1: 确定贝塞尔曲线第二点横坐标。类型为number，必填，取值范围：[0, 1]，设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"56\":\"\",\"57\":\"- x2: 确定贝塞尔曲线第一点纵坐标。类型为number，必填，取值范围：(-∞, +∞)。\",\"58\":\"\",\"59\":\"- y2: 确定贝塞尔曲线第二点纵坐标。类型为number，必填，取值范围：(-∞, +∞)。\"}",
      "用户拒绝的修改": "确定贝塞尔曲线第二点的纵坐标。类型为number，必填，取值范围：(-∞, +∞)。",
      "注意事项": "修复时应严格遵循上下文已有的术语结构和标点习惯（如\"第二点横坐标\"不含\"的\"字），避免引入格式偏差，优先保持整体文档表述统一性而非单纯优化单一句子。"
    },
    {
      "defect_id": 525385,
      "sentence": "设置图片帧信息集合。每一帧的帧信息(ImageFrameInfo)包含图片路径、图片大小、图片位置和图片播放时长信息，详见[ImageFrameInfo](#imageframeinfo对象说明)对象说明。",
      "reference_sentence": "设置图片帧信息集合。不支持动态更新。",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"**参数：** \",\"43\":\"\",\"44\":\"| 参数名 | 类型                                                   | 必填 | 说明                                                         |\",\"45\":\"| ------ | ------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"46\":\"| value  | Array&lt;[ImageFrameInfo](#imageframeinfo对象说明)&gt; | 是   | 设置图片帧信息集合。每一帧的帧信息(ImageFrameInfo)包含图片路径、图片大小、图片位置和图片播放时长信息，详见[ImageFrameInfo](#imageframeinfo对象说明)对象说明。<br/>默认值：[] <br/> **说明：** 传入数组的内容过大时，内存占用会随之升高。此内存由开发者自行控制。因此，开发者在传入数据前，请充分评估内存消耗情况，以避免内存不足等问题。 |\",\"47\":\"\",\"48\":\"### state\",\"49\":\"\",\"50\":\"state(value: AnimationStatus)\",\"51\":\"\"}",
      "用户拒绝的修改": "设置图片帧信息集合。每一帧的帧信息(ImageFrameInfo)包含图片路径、图片大小、图片位置和图片播放时长信息，详见[ImageFrameInfo](#imageframeinfo对象说明)对象说明。请注意，此集合不支持动态更新。",
      "注意事项": "修复时应严格校验上下文是否存在重复说明，避免添加冗余信息导致表述冲突；保持修复内容与已有参数说明的简洁性统一，确保关键限制条件只在权威位置单点说明。"
    },
    {
      "defect_id": 526408,
      "sentence": "当JSON字符串中存在小于-(2^53-1)或大于(2^53-1)的整数时，解析后数据会出现精度丢失或不正确的情况。该解析场景需要指定BigIntMode，将大整数解析为BigInt。",
      "reference_sentence": "当JSON字符串中存在小于-(2^53-1)或大于(2^53-1)的整数时，解析后数据会出现精度丢失或不正确的情况。该解析场景需要指定BigInt模式，将大整数解析为BigInt。",
      "line_num": 159,
      "context": "{\"154\":\"console.info(obj3.name); // zhangsan\",\"155\":\"```\",\"156\":\"\",\"157\":\"### 解析包含大整数的JSON字符串场景\",\"158\":\"\",\"159\":\"当JSON字符串中存在小于-(2^53-1)或大于(2^53-1)的整数时，解析后数据会出现精度丢失或不正确的情况。该解析场景需要指定BigIntMode，将大整数解析为BigInt。\",\"160\":\"\",\"161\":\"```ts\",\"162\":\"import { JSON } from '@kit.ArkTS';\",\"163\":\"\",\"164\":\"let numberText = '{\\\"number\\\": 10, \\\"largeNumber\\\": 112233445566778899}';\"}",
      "用户拒绝的修改": "当JSON字符串中存在小于-(2^53-1)或大于(2^53-1)的整数时，解析后数据会出现精度丢失或不正确的情况。该解析场景需要指定BigInt模式，将大整数解析为BigInt。",
      "注意事项": "修复时必须严格检查问题上下文中的原始术语使用形式（如\"BigIntMode\"），保持与上下文完全一致的命名规范，避免擅自进行中英文术语转换导致新的不一致。"
    },
    {
      "defect_id": 526354,
      "sentence": "以下提供两种方式解决该场景问题：",
      "reference_sentence": "JSON字符串中的嵌套引号会破坏其结构，将导致解析失败。",
      "line_num": 96,
      "context": "{\"91\":\"```ts\",\"92\":\"// 比如以下JSON字符串，由于嵌套引号导致结构破坏，执行JSON.parse将会抛异常。\",\"93\":\"// let jsonStr = `{\\\"info\\\": \\\"{\\\"name\\\": \\\"zhangsan\\\", \\\"age\\\": 18}\\\"}`;\",\"94\":\"```\",\"95\":\"\",\"96\":\"以下提供两种方式解决该场景问题：\",\"97\":\"\",\"98\":\"方式1：避免出现嵌套引号的操作。\",\"99\":\"\",\"100\":\"```ts\",\"101\":\"import { JSON } from '@kit.ArkTS';\"}",
      "用户拒绝的修改": "以下提供两种方法解决该场景问题：",
      "注意事项": "修复时应严格检查上下文术语一致性（如\"方式\"在后续多次出现），避免同义词替换；当原文表述无歧义且上下文已形成固定用词时，优先保留原术语而非强行统一。"
    },
    {
      "defect_id": 526353,
      "sentence": "从对象中删除指定的属性。",
      "reference_sentence": "检查对象是否包含指定的属性，确保传入的值是一个对象，并且属性键是有效的字符串。",
      "line_num": 68,
      "context": "{\"63\":\"\",\"64\":\"### remove\",\"65\":\"\",\"66\":\"remove(obj: object, property: string): void\",\"67\":\"\",\"68\":\"从对象中删除指定的属性。\",\"69\":\"\",\"70\":\"| 特性 | 原生方式（delete obj.key） | 本库remove |\",\"71\":\"| -------- | -------- | -------- | \",\"72\":\"| 参数校验 | 无校验（可能误删） | 强制检查obj是普通对象，property是非空字符串 |\",\"73\":\"| 错误处理 | 可能静默失败 | 抛出BusinessError |\"}",
      "用户拒绝的修改": "移除对象中指定的属性。",
      "注意事项": "修复时必须严格保持上下文术语一致性，优先沿用原文已确立的动词（如函数名\"remove\"对应\"移除\"），避免同功能场景混用近义词（如\"删除/移除\"）。需同步检查参考句子、表格标题等关联内容是否存在术语联动关系。"
    },
    {
      "defect_id": 529034,
      "sentence": "当id为tab2的TabContent显示的时候，将id为tab1的节点的冻结状态设置为true。",
      "reference_sentence": "当id为tab2的TabContent显示的时候，通过uniqueId设置id为tab1的节点的冻结状态为true。",
      "line_num": 209,
      "context": "{\"204\":\"        .onWillHide(() => {\",\"205\":\"          //id为tab2的TabContent隐藏的时候设置该节点的冻结状态为true。\",\"206\":\"          this.getUIContext().freezeUINode('tab2', true);\",\"207\":\"        })\",\"208\":\"        .onWillShow(() => {\",\"209\":\"          //当id为tab2的TabContent显示的时候，将id为tab1的节点的冻结状态设置为true。\",\"210\":\"          //通过状态变量改变id为tab1的节点中Column的宽度。因该节点的冻结状态为true，标脏至TabContent时终止标记，不触发布局。\",\"211\":\"          this.getUIContext().freezeUINode('tab1', true);\",\"212\":\"          this.columnWidth1 = '50%';\",\"213\":\"          //配置延时任务。\",\"214\":\"          setTimeout(() => {\"}",
      "用户拒绝的修改": "当uniqueId为tab2的TabContent显示的时候，将uniqueId为tab1的节点的冻结状态设置为true。",
      "注意事项": "修复时应严格对照上下文术语使用习惯，若变量名、参数名或注释中已明确使用特定术语（如\"id\"），需保持全文统一，避免将正确术语误判为不一致而强行替换。"
    },
    {
      "defect_id": 528608,
      "sentence": "全屏启动原子化服务组件，当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方跳出式拉起原子化服务。",
      "reference_sentence": "全屏启动原子化服务组件，当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方跳出式拉起原子化服务。",
      "line_num": 4,
      "context": "{\"1\":\"# FullScreenLaunchComponent\",\"2\":\"\",\"3\":\"\",\"4\":\"全屏启动原子化服务组件，当被拉起方授权使用方可以嵌入式运行原子化服务时，使用方全屏嵌入式运行原子化服务；未授权时，使用方跳出式拉起原子化服务。\",\"5\":\"\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 该组件从API Version 12开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\"}",
      "用户拒绝的修改": "全屏启动原子化服务组件，当被拉起方授权使用方可以嵌入式拉起原子化服务时，使用方全屏嵌入式拉起原子化服务；未授权时，使用方跳出式拉起原子化服务。",
      "注意事项": "在统一动词时应优先确保技术术语的准确性，避免将功能性动词（如\"运行\"）错误替换为流程性动词（如\"拉起\"）；修改前需结合上下文确认术语是否存在语义差异，技术文档中特定动词的替换需验证是否改变原始技术逻辑。"
    },
    {
      "defect_id": 528609,
      "sentence": "被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。",
      "reference_sentence": "被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。",
      "line_num": 46,
      "context": "{\"41\":\"| 名称 | 类型 | 必填 | 装饰器类型 | 说明 |\",\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\",\"50\":\"> **说明：**\",\"51\":\">\"}",
      "用户拒绝的修改": "被拉起的原子化服务在运行过程中发生异常时触发本回调。",
      "注意事项": "在确保术语一致性的同时，需优先保留技术文档中的专业修饰词（如\"嵌入式运行\"），避免因过度简化导致技术含义缺失；修复前应结合上下文确认术语是否属于特定功能定义，而非冗余表达。"
    },
    {
      "defect_id": 529033,
      "sentence": "当id为tab1的TabContent显示的时候设置该节点的冻结状态为false。",
      "reference_sentence": "当id为tab1的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。",
      "line_num": 192,
      "context": "{\"187\":\"        .onWillHide(() => {\",\"188\":\"          //id为tab1的TabContent隐藏的时候设置该节点的冻结状态为true。\",\"189\":\"          this.getUIContext().freezeUINode('tab1', true);\",\"190\":\"        })\",\"191\":\"        .onWillShow(() => {\",\"192\":\"          //id为tab1的TabContent显示的时候设置该节点的冻结状态为false。\",\"193\":\"          this.getUIContext().freezeUINode('tab1', false);\",\"194\":\"        })\",\"195\":\"\",\"196\":\"        TabContent() {\",\"197\":\"          Column()\"}",
      "用户拒绝的修改": "当uniqueId为tab1的TabContent显示的时候设置该节点的冻结状态为false。",
      "注意事项": "修复前必须结合上下文确认术语的实际使用场景，区分代码参数命名（如freezeUINode方法的uniqueId）和自然语言描述（如注释中的id）的差异，避免将不同层级的标识符误判为表述不一致。"
    },
    {
      "defect_id": 529032,
      "sentence": "通过id设置组件冻结状态，防止组件被标记为脏从而触发布局更新。",
      "reference_sentence": "通过uniqueId设置组件的冻结状态，防止组件被标记为脏从而触发布局更新。",
      "line_num": 143,
      "context": "{\"138\":\"\",\"139\":\"### freezeUINode<sup>18+</sup>\",\"140\":\"\",\"141\":\"freezeUINode(id: string, isFrozen: boolean): void\",\"142\":\"\",\"143\":\"通过id设置组件冻结状态，防止组件被标记为脏从而触发布局更新。\",\"144\":\"\",\"145\":\"**原子化服务API:** 从API version 18 开始，该接口支持在原子化服务中使用。\",\"146\":\"\",\"147\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"148\":\"\"}",
      "用户拒绝的修改": "通过uniqueId设置组件冻结状态，防止组件被标记为脏从而触发布局更新。",
      "注意事项": "修复术语一致性时必须严格核对上下文参数命名（如API接口定义的\"id\"），避免将官方参数名误判为表述不一致；优先保持与代码级定义术语的完全对齐，仅在确认存在实际混用时进行修正。"
    },
    {
      "defect_id": 528611,
      "sentence": "被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。",
      "reference_sentence": "被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。",
      "line_num": 48,
      "context": "{\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\",\"50\":\"> **说明：**\",\"51\":\">\",\"52\":\"> - 若原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)退出，其携带的信息会传给回调函数的入参；\",\"53\":\"> - 若原子化服务通过调用[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)退出，上述回调函数的入参中，\\\"code\\\"取默认值\\\"0\\\"，\\\"want\\\"为\\\"undefined\\\"。\"}",
      "用户拒绝的修改": "被拉起的原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。",
      "注意事项": "在统一术语时应优先保留上下文中的技术限定词（如\"嵌入式运行\"），避免过度简化导致信息缺失；需结合相邻条目的表述模式判断是否属于必要修饰而非冗余重复。"
    },
    {
      "defect_id": 526299,
      "sentence": "通过id设置组件冻结状态，防止自身脏区标记并进行布局更新。",
      "reference_sentence": "通过uniqueId设置组件的冻结状态，防止自身脏区标记并进行布局更新。",
      "line_num": 143,
      "context": "{\"138\":\"\",\"139\":\"### freezeUINode<sup>18+</sup>\",\"140\":\"\",\"141\":\"freezeUINode(id: string, isFrozen: boolean): void\",\"142\":\"\",\"143\":\"通过id设置组件冻结状态，防止自身脏区标记并进行布局更新。\",\"144\":\"\",\"145\":\"**原子化服务API:** 从API version 18 开始，该接口支持在原子化服务中使用。\",\"146\":\"\",\"147\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"148\":\"\"}",
      "用户拒绝的修改": "通过uniqueId设置组件冻结状态，防止自身脏区标记并进行布局更新。",
      "注意事项": "修复术语一致性时必须优先核对上下文中的实际参数命名，确保修改后的表述与接口定义、代码示例等上下文中的术语完全一致，避免脱离具体语境进行全局替换。"
    },
    {
      "defect_id": 528755,
      "sentence": "选中项背景的颜色和边框圆角半径，多列模式时会同时设置所有列的选中项背景的颜色和圆角半径。",
      "reference_sentence": "表冠响应灵敏度。<br/>默认值：CrownSensitivity.MEDIUM，响应速度适中。",
      "line_num": 444,
      "context": "{\"439\":\"\",\"440\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"441\":\"\",\"442\":\"| 参数名   | 类型                                     | 必填   | 说明                      |\",\"443\":\"| ----- | ---------------------------------------- | ---- | ------------------------- |\",\"444\":\"| style | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<[PickerBackgroundStyle](#pickerbackgroundstyle20)> | 是    | 选中项背景的颜色和边框圆角半径，多列模式时会同时设置所有列的选中项背景的颜色和圆角半径。<br/>默认值：<br/>{ <br/>color: $r('sys.color.comp_background_tertiary'),<br/>borderRadius: $r('sys.float.corner_radius_level12')<br/>}|\",\"445\":\"\",\"446\":\"## 事件\",\"447\":\"\",\"448\":\"除支持[通用事件](ts-component-general-events.md)外，还支持以下事件：\",\"449\":\"\"}",
      "用户拒绝的修改": "选中项背景的颜色和边框圆角半径，多列模式时会同时设置所有列的选中项背景颜色和圆角半径。",
      "注意事项": "修复时应严格区分术语结构完整性和句式重复冗余，避免将合理省略\"的\"字的结构简化误判为不一致；技术文档参数说明允许适当省略非必要助词，需结合上下文判断是否影响专业表达准确性。"
    },
    {
      "defect_id": 528610,
      "sentence": "被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。",
      "reference_sentence": "被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。",
      "line_num": 47,
      "context": "{\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\",\"50\":\"> **说明：**\",\"51\":\">\",\"52\":\"> - 若原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)退出，其携带的信息会传给回调函数的入参；\"}",
      "用户拒绝的修改": "被拉起的原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。",
      "注意事项": "修复前必须全面核查上下文术语使用场景，若修饰词在上下文中属于必要技术特征（如\"嵌入式运行\"）且存在多实例统一用法，应优先保留术语完整性而非强制简化，确保技术描述的准确性高于句式统一需求。"
    },
    {
      "defect_id": 529242,
      "sentence": "具有提亮效果的混合器（支持HDR）。",
      "reference_sentence": "HdrBrightnessBlender",
      "line_num": 839,
      "context": "{\"834\":\"**系统接口：** 此接口为系统接口。\",\"835\":\"\",\"836\":\"| 类型                          | 说明                                               |\",\"837\":\"| ----------------------------- | ------------------------------------------------- |\",\"838\":\"| [BrightnessBlender](#brightnessblender) | 具有提亮效果的混合器。 |\",\"839\":\"| [HdrBrightnessBlender](#hdrbrightnessblender20) | 具有提亮效果的混合器（支持HDR）。 |\",\"840\":\"\",\"841\":\"## BrightnessBlender\",\"842\":\"提亮混合器，用于将提亮效果添加到指定的组件上。在调用BrightnessBlender前，需要先通过[createBrightnessBlender](#uieffectcreatebrightnessblender)创建一个BrightnessBlender实例。\",\"843\":\"\",\"844\":\"**系统能力：** SystemCapability.Graphics.Drawing\"}",
      "用户拒绝的修改": "具有提亮效果的Blender（支持HDR）。",
      "注意事项": "修复术语不一致时应先验证上下文术语使用规范，区分代码标识符和文档术语，优先保留文档中已明确定义的统一命名（如\"混合器\"），避免将代码类名（如Blender）直接替换文档术语。"
    },
    {
      "defect_id": 529241,
      "sentence": "具有提亮效果的混合器。",
      "reference_sentence": "BrightnessBlender",
      "line_num": 838,
      "context": "{\"833\":\"\",\"834\":\"**系统接口：** 此接口为系统接口。\",\"835\":\"\",\"836\":\"| 类型                          | 说明                                               |\",\"837\":\"| ----------------------------- | ------------------------------------------------- |\",\"838\":\"| [BrightnessBlender](#brightnessblender) | 具有提亮效果的混合器。 |\",\"839\":\"| [HdrBrightnessBlender](#hdrbrightnessblender20) | 具有提亮效果的混合器（支持HDR）。 |\",\"840\":\"\",\"841\":\"## BrightnessBlender\",\"842\":\"提亮混合器，用于将提亮效果添加到指定的组件上。在调用BrightnessBlender前，需要先通过[createBrightnessBlender](#uieffectcreatebrightnessblender)创建一个BrightnessBlender实例。\",\"843\":\"\"}",
      "用户拒绝的修改": "具有提亮效果的Blender。",
      "注意事项": "在修复术语不一致时需优先确认上下文中的术语使用规范，区分接口名称（如BrightnessBlender）和功能描述（如混合器）的应用场景，避免将专有名词强制替换到非技术性描述语句中。"
    },
    {
      "defect_id": 529343,
      "sentence": "传入的节点未挂载到组件树上。",
      "reference_sentence": "传入的节点未挂载到组件树上。",
      "line_num": 67,
      "context": "{\"62\":\"\",\"63\":\"**错误信息**\",\"64\":\"\",\"65\":\"**错误描述**\",\"66\":\"\",\"67\":\"传入的节点未挂载到组件树上。\",\"68\":\"\",\"69\":\"**可能原因**\",\"70\":\"\",\"71\":\"当前传入的节点未挂载到组件树上。\",\"72\":\"\"}",
      "用户拒绝的修改": "传入的节点未正确挂载到组件树上。",
      "注意事项": "修复时应优先保持原句核心信息不变，避免添加冗余修饰词（如\"正确\"）；需结合上下文检查重复描述问题，仅在确实存在歧义或信息缺失时补充必要说明。"
    },
    {
      "defect_id": 529240,
      "sentence": "混合器类型，用于描述混合效果。",
      "reference_sentence": "type Blender = BrightnessBlender | HdrBrightnessBlender",
      "line_num": 830,
      "context": "{\"825\":\"\",\"826\":\"## Blender<sup>13+</sup>\",\"827\":\"\",\"828\":\"type Blender = BrightnessBlender | HdrBrightnessBlender\",\"829\":\"\",\"830\":\"混合器类型，用于描述混合效果。\",\"831\":\"\",\"832\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"833\":\"\",\"834\":\"**系统接口：** 此接口为系统接口。\",\"835\":\"\"}",
      "用户拒绝的修改": "Blender类型，用于描述混合效果。",
      "注意事项": "在修改术语前必须结合上下文确认术语使用场景，严格区分代码标识符(如type Blender)与文档解释性文本(如\"混合器类型\")，保留技术文档中已确立的中英文术语对应关系。"
    },
    {
      "defect_id": 529231,
      "sentence": "返回设置了提亮效果参数的HdrBrightnessBlender。",
      "reference_sentence": "返回设置了提亮效果参数的BrightnessBlender。",
      "line_num": 64,
      "context": "{\"59\":\"\",\"60\":\"**返回值：**\",\"61\":\"\",\"62\":\"| 类型                                     | 说明                     |\",\"63\":\"| ---------------------------------------- | ----------------------- |\",\"64\":\"| [HdrBrightnessBlender](#hdrbrightnessblender20) | 返回设置了提亮效果参数的HdrBrightnessBlender。 |\",\"65\":\"\",\"66\":\"**示例：**\",\"67\":\"\",\"68\":\"```ts\",\"69\":\"import { uiEffect } from \\\"@kit.ArkGraphics2D\\\"\"}",
      "用户拒绝的修改": "返回设置了提亮效果参数的HdrBrightnessBlender对象。",
      "注意事项": "修正前必须严格核对上下文类型名称的精确匹配，避免将不同类名误判为混淆；在不存在歧义的情况下保持术语简洁性，无需添加\"对象\"等冗余说明词。"
    },
    {
      "defect_id": 529342,
      "sentence": "当前操作不支持ArkTS创建的节点。",
      "reference_sentence": "The corresponding operation does not support nodes created by ArkTS.",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"The corresponding operation does not support nodes created by ArkTS.\",\"48\":\"\",\"49\":\"**错误描述**\",\"50\":\"\",\"51\":\"对应的操作不支持ArkTS创建的节点。\",\"52\":\"\",\"53\":\"**可能原因**\",\"54\":\"\",\"55\":\"当前操作不支持ArkTS创建的节点。\",\"56\":\"\"}",
      "用户拒绝的修改": "当前操作不支持由ArkTS创建的节点。",
      "注意事项": "修复时应优先遵循目标语言的语法习惯，避免机械对应英文结构导致表达冗余；在中文语境中允许合理省略介词（如“由”），确保技术文档表述简洁且符合母语者阅读习惯。"
    },
    {
      "defect_id": 529344,
      "sentence": "当前传入的节点未挂载到组件树上。",
      "reference_sentence": "传入的节点未挂载到组件树上。",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"传入的节点未挂载到组件树上。\",\"68\":\"\",\"69\":\"**可能原因**\",\"70\":\"\",\"71\":\"当前传入的节点未挂载到组件树上。\",\"72\":\"\",\"73\":\"**处理步骤**\",\"74\":\"\",\"75\":\"调整函数调用时机，确保传入的节点已挂载到组件树上。\"}",
      "用户拒绝的修改": "请检查当前传入的节点是否已挂载到组件树上。",
      "注意事项": "保持上下文术语一致性，避免冗余修饰词（如\"当前\"）；修复时需提供具体解决方案而非单纯重复问题描述，确保修改内容与已有参考句式保持统一。"
    },
    {
      "defect_id": 535053,
      "sentence": "系统区域对象。",
      "reference_sentence": "表示区域ID的字符串。",
      "line_num": 320,
      "context": "{\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\",\"317\":\"**返回值：**\",\"318\":\"| 类型     | 说明      |\",\"319\":\"| ------ | ------- |\",\"320\":\"| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域对象。 |\",\"321\":\"\",\"322\":\"**示例：**\",\"323\":\"  ```ts\",\"324\":\"  let systemLocale: Intl.Locale = i18n.System.getSystemLocaleInstance();\",\"325\":\"  ```\"}",
      "用户拒绝的修改": "系统区域ID。",
      "注意事项": "在修复术语不一致时，必须结合上下文确认技术准确性（如返回值类型为对象而非字符串），避免仅依赖词汇匹配导致技术定义冲突；优先根据代码示例和类型注释判断术语适用性，而非机械对齐表面词汇。"
    },
    {
      "defect_id": 533846,
      "sentence": "单字绘制是图形渲染中针对文本渲染的一种精细化控制技术。",
      "reference_sentence": "单字绘制是图形渲染中针对文本渲染的一种精细化控制技术。",
      "line_num": 139,
      "context": "{\"134\":\">\",\"135\":\"> 需要在应用入口文件（默认工程中为EntryAbility.ets）中复写onConfigurationUpdate函数，以响应切换主题字体的操作，确保切换后页面能够及时刷新并生效。具体实现可参考[使用主题字体（ArkTS）](theme-font-arkts.md)。\",\"136\":\"\",\"137\":\"## 单字绘制\",\"138\":\"\",\"139\":\"单字绘制是图形渲染中针对文本渲染的一种精细化控制技术。相比字块绘制，其核心优势在于能够利用字体退化机制，在当前字体无法显示某字符时，自动退化到使用系统字体绘制字符，从而提升对特殊字符的兼容性，避免字符缺失。同时，单字绘制支持逐字符配置字体特征（如连字、替代字形），满足复杂排版需求，增强用户体验。详细API说明请见[drawing.Canvas](../reference/apis-arkgraphics2d/arkts-apis-graphics-drawing-Canvas.md#drawsinglecharacter12)。\",\"140\":\"\",\"141\":\"基础场景：无字体特征的单字绘制​\",\"142\":\"对于无需字体特征的常规文本渲染场景，可以使用drawSingleCharacter绘制单个字符，measureSingleCharacter测量单个字符的宽度，示例代码和效果图如下：\",\"143\":\"\",\"144\":\"```ts\"}",
      "用户拒绝的修改": "使用单字绘制技术进行图形渲染中的文本渲染精细化控制。",
      "注意事项": "修复时应优先确保语义不变，避免机械套用句式规则导致功能误导（如将定义性陈述句改为操作指令句）；需结合上下文判断句子类型（如技术定义、操作步骤）再调整句式，保持原句核心信息与文档定位一致。"
    },
    {
      "defect_id": 533449,
      "sentence": "通常用于响应用户的点击操作。",
      "reference_sentence": "通常用于响应用户的单击操作。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"开发者可以根据实际应用场景选择合适的表单与选择组件进行页面开发。\",\"6\":\"\",\"7\":\"| 表单与选择组件名称 | 应用场景 |\",\"8\":\"| -------- | -------- |\",\"9\":\"| [按钮(Button)](arkts-common-components-button.md) | 通常用于响应用户的点击操作。 |\",\"10\":\"| [弧形按钮(ArcButton)](arkts-advanced-components-arcbutton.md) | 用于圆形屏幕。为手表用户提供强调、普通、警告等样式按钮。 |\",\"11\":\"| [单选框(Radio)](arkts-common-components-radio-button.md) | 单选框组件，通常用于提供相应的用户交互选择项。 |\",\"12\":\"| [切换按钮(Toggle)](arkts-common-components-switch.md) | 一般用于两种状态之间的切换， 如勾选框和开关。 |\"}",
      "用户拒绝的修改": "通常用于响应用户的单击操作。",
      "注意事项": "修复前必须核查上下文术语使用一致性，优先沿用原文已有统一表述；准确区分近义词的适用场景，避免将正确表述误判为概念混用。"
    },
    {
      "defect_id": 529035,
      "sentence": "当id为tab3的TabContent显示的时候设置该节点的冻结状态为false。",
      "reference_sentence": "当id为tab3的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。",
      "line_num": 235,
      "context": "{\"230\":\"        .onWillHide(() => {\",\"231\":\"          //当id为tab3的TabContent隐藏的时候设置该节点的冻结状态为true。\",\"232\":\"          this.getUIContext().freezeUINode('tab3', true);\",\"233\":\"        })\",\"234\":\"        .onWillShow(() => {\",\"235\":\"          //id为tab3的TabContent显示的时候设置该节点的冻结状态为false。\",\"236\":\"          this.getUIContext().freezeUINode('tab3', false);\",\"237\":\"        })\",\"238\":\"\",\"239\":\"      }\",\"240\":\"      .vertical(false)\"}",
      "用户拒绝的修改": "当uniqueId为tab3的TabContent显示的时候设置该节点的冻结状态为false。",
      "注意事项": "修改术语前需交叉验证上下文参数命名一致性，优先保持与代码实现字段（如freezeUINode参数'tab3'）和相邻注释（如231行\"id为tab3\"）的术语统一，避免将不同层级的标识符（id与uniqueId）混用。"
    },
    {
      "defect_id": 533847,
      "sentence": "同时，单字绘制支持逐字符配置字体特征（如连字、替代字形），满足复杂排版需求，增强用户体验。",
      "reference_sentence": "同时，单字绘制支持逐字符配置字体特征（如连字、替代字形），满足复杂排版需求，增强用户体验。",
      "line_num": 139,
      "context": "{\"134\":\">\",\"135\":\"> 需要在应用入口文件（默认工程中为EntryAbility.ets）中复写onConfigurationUpdate函数，以响应切换主题字体的操作，确保切换后页面能够及时刷新并生效。具体实现可参考[使用主题字体（ArkTS）](theme-font-arkts.md)。\",\"136\":\"\",\"137\":\"## 单字绘制\",\"138\":\"\",\"139\":\"单字绘制是图形渲染中针对文本渲染的一种精细化控制技术。相比字块绘制，其核心优势在于能够利用字体退化机制，在当前字体无法显示某字符时，自动退化到使用系统字体绘制字符，从而提升对特殊字符的兼容性，避免字符缺失。同时，单字绘制支持逐字符配置字体特征（如连字、替代字形），满足复杂排版需求，增强用户体验。详细API说明请见[drawing.Canvas](../reference/apis-arkgraphics2d/arkts-apis-graphics-drawing-Canvas.md#drawsinglecharacter12)。\",\"140\":\"\",\"141\":\"基础场景：无字体特征的单字绘制​\",\"142\":\"对于无需字体特征的常规文本渲染场景，可以使用drawSingleCharacter绘制单个字符，measureSingleCharacter测量单个字符的宽度，示例代码和效果图如下：\",\"143\":\"\",\"144\":\"```ts\"}",
      "用户拒绝的修改": "同时，支持逐字符配置字体特征（如连字、替代字形），以满足复杂排版需求，增强用户体验。",
      "注意事项": "修复句式一致性时需优先保留上下文关键主语（如\"单字绘制\"），避免因过度简化导致逻辑断层；句式调整应结合段落整体表达结构，确保修改后的句子与前后文形成自然衔接。"
    },
    {
      "defect_id": 536516,
      "sentence": "| style | [Optional](ts-universal-attributes-custom-property.md#optional12)\\<[PickerBackgroundStyle](#pickerbackgroundstyle20)> | 是    | 选中项背景的颜色和边框圆角半径，多列模式时会同时设置所有列的选中项背景的颜色和圆角半径。<br/>默认值：<br/>{ <br/>color: $r('sys.color.comp_background_tertiary'),<br/>borderRadius: $r('sys.float.corner_radius_level12')<br/>}",
      "reference_sentence": "| sensitivity | [Optional](ts-universal-attributes-custom-property.md#optional12)\\<[CrownSensitivity](ts-appendix-enums.md#crownsensitivity18)> | 是    | 表冠响应灵敏度。<br/>默认值：CrownSensitivity.MEDIUM，响应速度适中。                     |",
      "line_num": 444,
      "context": "{\"439\":\"\",\"440\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"441\":\"\",\"442\":\"| 参数名   | 类型                                     | 必填   | 说明                      |\",\"443\":\"| ----- | ---------------------------------------- | ---- | ------------------------- |\",\"444\":\"| style | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<[PickerBackgroundStyle](#pickerbackgroundstyle20)> | 是    | 选中项背景的颜色和边框圆角半径，多列模式时会同时设置所有列的选中项背景的颜色和圆角半径。<br/>默认值：<br/>{ <br/>color: $r('sys.color.comp_background_tertiary'),<br/>borderRadius: $r('sys.float.corner_radius_level12')<br/>}|\",\"445\":\"\",\"446\":\"## 事件\",\"447\":\"\",\"448\":\"除支持[通用事件](ts-component-general-events.md)外，还支持以下事件：\",\"449\":\"\"}",
      "用户拒绝的修改": "| style | [Optional](ts-universal-attributes-custom-property.md#optional12)\\<[PickerBackgroundStyle](#pickerbackgroundstyle20)> | 是    | 选中项背景的颜色和圆角半径，多列模式时会同时设置所有列的选中项背景的颜色和圆角半径。<br/>默认值：<br/>{ <br/>color: $r('sys.color.comp_background_tertiary'),<br/>borderRadius: $r('sys.float.corner_radius_level12')<br/>}",
      "注意事项": "保持参数描述中专业术语的一致性（如统一使用\"圆角半径\"而非\"边框圆角半径\"），并严格遵循项目文档对默认值的统一表达格式（如保持代码块结构或自然语言说明的连贯性）。"
    },
    {
      "defect_id": 535061,
      "sentence": "获取系统当前设置的区域对象。",
      "reference_sentence": "获取系统当前设置的区域。",
      "line_num": 311,
      "context": "{\"306\":\"\",\"307\":\"### getSystemLocaleInstance<sup>20+</sup>\",\"308\":\"\",\"309\":\"static getSystemLocaleInstance(): Intl.Locale;\",\"310\":\"\",\"311\":\"获取系统当前设置的区域对象。\",\"312\":\"\",\"313\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"314\":\"\",\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\"}",
      "用户拒绝的修改": "获取系统当前设置的区域。",
      "注意事项": "严格保持技术术语一致性，修改前必须核对API定义和上下文中的对象类型表述，确保\"区域对象\"等专业术语不被错误简化或替换。"
    },
    {
      "defect_id": 535062,
      "sentence": "| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域对象。 |",
      "reference_sentence": "| string | 表示区域ID的字符串。 |",
      "line_num": 320,
      "context": "{\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\",\"317\":\"**返回值：**\",\"318\":\"| 类型     | 说明      |\",\"319\":\"| ------ | ------- |\",\"320\":\"| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域对象。 |\",\"321\":\"\",\"322\":\"**示例：**\",\"323\":\"  ```ts\",\"324\":\"  let systemLocale: Intl.Locale = i18n.System.getSystemLocaleInstance();\",\"325\":\"  ```\"}",
      "用户拒绝的修改": "| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域ID。 |",
      "注意事项": "修复时应严格核对上下文数据类型（如Intl.Locale对象与string类型差异），优先保持术语与返回值类型的一致性，避免单纯依赖邻近字段的词汇匹配导致概念混淆。"
    },
    {
      "defect_id": 535748,
      "sentence": "### 示例2（使用DrawingRenderingContext中的方法）",
      "reference_sentence": "### 示例1（使用CanvasRenderingContext2D中的方法）",
      "line_num": 121,
      "context": "{\"116\":\"  }\",\"117\":\"}\",\"118\":\"```\",\"119\":\"  ![zh-cn_image_0000001194032666](figures/zh-cn_image_0000001194032666.png)\",\"120\":\"\",\"121\":\"### 示例2（使用DrawingRenderingContext中的方法）\",\"122\":\"\",\"123\":\"该示例实现了如何在Canvas组件使用DrawingRenderingContext中的方法进行绘制。\",\"124\":\"\",\"125\":\"```ts\",\"126\":\"// xxx.ets\"}",
      "用户拒绝的修改": "### 示例2（使用CanvasRenderingContext2D中的方法）",
      "注意事项": "在修复术语一致性时，需优先验证上下文中的技术概念是否匹配（如区分`CanvasRenderingContext2D`和`DrawingRenderingContext`的适用场景），避免仅依赖字面相似性强制统一术语，导致技术逻辑错误。"
    },
    {
      "defect_id": 536498,
      "sentence": "获取LoadingProgress节点类型的属性。",
      "reference_sentence": "创建LoadingProgress类型的FrameNode节点。",
      "line_num": 3186,
      "context": "{\"3181\":\"**参数：**\",\"3182\":\"\",\"3183\":\"| 参数名 | 类型 | 必填 | 说明  |\",\"3184\":\"| ------------------ | ------------------ | ------------------- | ------------------- |\",\"3185\":\"| node | [FrameNode](./js-apis-arkui-frameNode.md) | 是   | 获取属性时所需的目标节点。 |\",\"3186\":\"| nodeType | 'LoadingProgress' | 是 | 获取LoadingProgress节点类型的属性。 |\",\"3187\":\"\",\"3188\":\"**返回值：**\",\"3189\":\"\",\"3190\":\"| 类型                  | 说明      |\",\"3191\":\"| ------------------ | ------------------ |\"}",
      "用户拒绝的修改": "获取LoadingProgress节点类型的属性值。",
      "注意事项": "修复时应严格核对上下文术语一致性（如“属性”与“属性值”的精确对应），避免跨概念混淆（如“创建”与“获取”需在相同操作维度保持统一），优先保留原句核心动词除非上下文明确要求变更。"
    },
    {
      "defect_id": 536478,
      "sentence": "获取Progress节点的属性。若该节点非ArkTS语言创建，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持声明式方式创建的节点。",
      "reference_sentence": "创建Progress类型的FrameNode节点。",
      "line_num": 2855,
      "context": "{\"2850\":\"typeNode.createNode(uiContext, 'Progress');\",\"2851\":\"```\",\"2852\":\"### getAttribute('Progress')<sup>20+</sup>\",\"2853\":\"getAttribute(node: FrameNode, nodeType: 'Progress'): ProgressAttribute | undefined\",\"2854\":\"\",\"2855\":\"获取Progress节点的属性。若该节点非ArkTS语言创建，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持声明式方式创建的节点。\",\"2856\":\"\",\"2857\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"2858\":\"\",\"2859\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"2860\":\"\"}",
      "用户拒绝的修改": "获取Progress节点的属性。若该节点不是使用ArkTS语言创建的，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持声明式方式创建的节点。",
      "注意事项": "严格区分上下文中的\"创建\"与\"获取\"等核心操作术语，确保同一概念在整段描述中保持表述一致性；在涉及跨操作流程的条件判断时，需显式关联操作主体（如\"节点创建方式\"对应\"属性获取条件\"），避免隐含逻辑断层。"
    },
    {
      "defect_id": 536497,
      "sentence": "获取LoadingProgress节点的属性。若该节点非ArkTS语言创建，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持声明式方式创建的节点。",
      "reference_sentence": "创建LoadingProgress类型的FrameNode节点。",
      "line_num": 3175,
      "context": "{\"3170\":\"typeNode.createNode(uiContext, 'LoadingProgress');\",\"3171\":\"```\",\"3172\":\"### getAttribute('LoadingProgress')<sup>20+</sup>\",\"3173\":\"getAttribute(node: FrameNode, nodeType: 'LoadingProgress'): LoadingProgressAttribute | undefined\",\"3174\":\"\",\"3175\":\"获取LoadingProgress节点的属性。若该节点非ArkTS语言创建，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持声明式方式创建的节点。\",\"3176\":\"\",\"3177\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"3178\":\"\",\"3179\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"3180\":\"\"}",
      "用户拒绝的修改": "获取LoadingProgress节点的属性。如果该节点不是使用ArkTS语言创建的，则需要设置是否支持跨语言访问，如果不支持跨语言访问，则返回undefined。该接口不支持使用声明式创建的节点。",
      "注意事项": "严格保持术语一致性（如\"跨语言访问\"与\"声明式方式\"需固定词序和修饰词），明确区分操作动作（如\"创建\"与\"获取\"需与上下文逻辑严格对应）。"
    },
    {
      "defect_id": 536573,
      "sentence": "当曲线类型为CUBIC_BEZIER时，动画曲线参数需设置为长度为4的数组：[x1, y1, x2, y2]。",
      "reference_sentence": "当曲线类型为INTERPOLATION_SPRING时，动画曲线参数需设置为长度为4的数组：[velocity,mass,stiffness,damping]。",
      "line_num": 484,
      "context": "{\"479\":\"\",\"480\":\"- damping：表示刚度，类型为number。必填，取值范围为(0, +∞)，当取值小于等于0时，按1处理。\",\"481\":\"\",\"482\":\"  用于描述系统在受到扰动后震荡及衰减的情形。阻尼越大，弹性运动的震荡次数越少、震荡幅度越小。\",\"483\":\"\",\"484\":\"当曲线类型为CUBIC_BEZIER时，动画曲线参数需设置为长度为4的数组：[x1, y1, x2, y2]。\",\"485\":\"\",\"486\":\"- x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。\",\"487\":\"\",\"488\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"489\":\"\"}",
      "用户拒绝的修改": "设置动画曲线参数为长度为4的数组：[x1, y1, x2, y2]，当曲线类型为CUBIC_BEZIER时。",
      "注意事项": "保持条件从句前置的句式结构，统一使用\"当...时，需...\"的祈使句格式；修复时需严格匹配上下文已有句子的主谓顺序和语气特征，避免改变原句逻辑结构。"
    },
    {
      "defect_id": 537809,
      "sentence": "onOverrideErrorPage的回调函数，网页加载失败时触发。",
      "reference_sentence": "拦截网页可编辑元素拉起软键盘的回调，一般在点击网页input标签时触发。",
      "line_num": 236,
      "context": "{\"231\":\"\",\"232\":\"## OnOverrideErrorPageCallback<sup>20+</sup>\",\"233\":\"\",\"234\":\"type OnOverrideErrorPageCallback= (webResourceRequest: WebResourceRequest, error: WebResourceError) => string\",\"235\":\"\",\"236\":\"onOverrideErrorPage的回调函数，网页加载失败时触发。\",\"237\":\"\",\"238\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"239\":\"\",\"240\":\"**参数：**\",\"241\":\"\"}",
      "用户拒绝的修改": "onOverrideErrorPage的回调，网页加载失败时触发。",
      "注意事项": "在确保术语准确性的前提下进行一致性调整，优先保留技术文档中明确使用的专业术语（如\"回调函数\"），避免因过度统一而误改关键概念。需结合上下文参数类型（如\"OnOverrideErrorPageCallback\"）判断是否需保留\"函数\"后缀。"
    },
    {
      "defect_id": 536547,
      "sentence": "确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。",
      "reference_sentence": "确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。",
      "line_num": 486,
      "context": "{\"481\":\"\",\"482\":\"  用于描述系统在受到扰动后震荡及衰减的情形。阻尼越大，弹性运动的震荡次数越少、震荡幅度越小。\",\"483\":\"\",\"484\":\"当曲线类型为CUBIC_BEZIER时，动画曲线参数需设置为长度为4的数组：[x1, y1, x2, y2]。\",\"485\":\"\",\"486\":\"- x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。\",\"487\":\"\",\"488\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"489\":\"\",\"490\":\"- x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。\",\"491\":\"\"}",
      "用户拒绝的修改": "确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。",
      "注意事项": "修复时应确保上下文参数描述的句式结构完全统一，特别注意检查相邻参数说明中是否已存在更简洁的规范表达（如\"值小于0\"→\"小于0\"），避免局部修改破坏全局一致性。"
    },
    {
      "defect_id": 536543,
      "sentence": "| CUBIC_BEZIER | 2 | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线插值计算。<br/>使用此曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |",
      "reference_sentence": "| INTERPOLATION_SPRING | 1    | 表示插值器弹簧曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。动画时间由曲线参数决定，不受[WindowAnimationConfig](#windowanimationconfig20)中的duration参数控制。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration选填，且不生效。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param必填。 |",
      "line_num": 438,
      "context": "{\"433\":\"\",\"434\":\"| 名称                | 值   | 说明                                                         |\",\"435\":\"| ------------------- | ---- | ------------------------------------------------------------ |\",\"436\":\"| LINEAR              | 0    | 表示动画从头到尾的速度都是相同的。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration必填。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param选填，且不生效。 |\",\"437\":\"| INTERPOLATION_SPRING | 1    | 表示插值器弹簧曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。动画时间由曲线参数决定，不受[WindowAnimationConfig](#windowanimationconfig20)中的duration参数控制。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration选填，且不生效。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param必填。 |\",\"438\":\"| CUBIC_BEZIER | 2 | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线插值计算。<br/>使用此曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |\",\"439\":\"\",\"440\":\"## WindowAnimationConfig<sup>20+</sup>\",\"441\":\"\",\"442\":\"窗口动画参数配置。\",\"443\":\"\"}",
      "用户拒绝的修改": "| CUBIC_BEZIER | 2 | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线插值计算。<br/>使用该曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |",
      "注意事项": "修复时应严格保持术语使用（如\"进行插值计算\"）、指代词（\"该\"与\"此\"）及格式规范（链接写法）的全文一致性，需逐项对照上下文条目特征（如参考句中的完整动词结构、锚点格式）进行全要素对齐。"
    },
    {
      "defect_id": 538071,
      "sentence": "### 支持类型和观察变化",
      "reference_sentence": "### 支持类型和观测变化",
      "line_num": 143,
      "context": "{\"138\":\"      }\",\"139\":\"    }\",\"140\":\"  }\",\"141\":\"  ```\",\"142\":\"\",\"143\":\"## 支持类型和观察变化\",\"144\":\"\",\"145\":\"### 支持类型\",\"146\":\"\",\"147\":\"**ArkTS1.1独有：**\",\"148\":\"\"}",
      "用户拒绝的修改": "### 支持类型和观测变化",
      "注意事项": "在修复术语不一致时，必须严格核查上下文中的原始用词规范（如用户原句使用\"观察\"而参考句使用\"观测\"），优先保持同级标题间的术语统一性，避免跨层级强行对齐术语。建议通过交叉验证相邻章节标题和参考句的用词模式来决策修改边界。"
    },
    {
      "defect_id": 538100,
      "sentence": "JSON.parse返回Object，无法使用@Trace装饰其属性，可以使用makeObserved使其变为可观察数据。\r",
      "reference_sentence": "JSON.parse返回的Object",
      "line_num": 485,
      "context": "{\"480\":\"\",\"481\":\"### makeObserved的入参为JSON.parse的返回值\",\"482\":\"\",\"483\":\"**该场景仅适用于ArkTS1.1。**\",\"484\":\"\",\"485\":\"JSON.parse返回Object，无法使用@Trace装饰其属性，可以使用makeObserved使其变为可观察数据。\",\"486\":\"\",\"487\":\"```ts\",\"488\":\"import { JSON } from '@kit.ArkTS';\",\"489\":\"import { UIUtils } from '@kit.ArkUI';\",\"490\":\"\"}",
      "用户拒绝的修改": "JSON.parse返回对象，无法使用@Trace装饰其属性，可以使用makeObserved使其变为可观察数据。",
      "注意事项": "保持技术术语一致性，严格区分中英文专业术语使用场景（如\"Object\"作为编程概念时应保留英文形式，避免翻译为\"对象\"导致概念混淆），修复时需核对上下文术语使用规范。"
    },
    {
      "defect_id": 536585,
      "sentence": "| CUBIC_BEZIER | 2 | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线插值计算。<br/>使用此曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |",
      "reference_sentence": "| INTERPOLATION_SPRING | 1    | 表示插值器弹簧曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。动画时间由曲线参数决定，不受[WindowAnimationConfig](#windowanimationconfig20)中的duration参数控制。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration选填，且不生效。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param必填。 |",
      "line_num": 438,
      "context": "{\"433\":\"\",\"434\":\"| 名称                | 值   | 说明                                                         |\",\"435\":\"| ------------------- | ---- | ------------------------------------------------------------ |\",\"436\":\"| LINEAR              | 0    | 表示动画从头到尾的速度都是相同的。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration必填。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param选填，且不生效。 |\",\"437\":\"| INTERPOLATION_SPRING | 1    | 表示插值器弹簧曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。动画时间由曲线参数决定，不受[WindowAnimationConfig](#windowanimationconfig20)中的duration参数控制。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中duration选填，且不生效。<br/>使用该曲线类型时[WindowAnimationConfig](#windowanimationconfig20)中param必填。 |\",\"438\":\"| CUBIC_BEZIER | 2 | 表示插值器贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线插值计算。<br/>使用此曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |\",\"439\":\"\",\"440\":\"## WindowAnimationConfig<sup>20+</sup>\",\"441\":\"\",\"442\":\"窗口动画参数配置。\",\"443\":\"\"}",
      "用户拒绝的修改": "| CUBIC_BEZIER | 2 | 表示贝塞尔曲线，一条从0到1的动画曲线，实际动画值根据曲线进行插值计算。<br/>使用该曲线类型时，[WindowAnimationConfig](arkts-apis-window-i.md#windowanimationconfig20)中的param和duration为必填项。 |",
      "注意事项": "保持术语统一性（如\"插值器\"前缀应与同类条目一致），严格统一指代用词（如\"此/该\"选择需与上下文保持完全一致），并需全局检查相关条目表述模式。"
    },
    {
      "defect_id": 538072,
      "sentence": "### 观察变化",
      "reference_sentence": "### 观测变化",
      "line_num": 158,
      "context": "{\"153\":\"\",\"154\":\"**ArkTS1.1与ArkTS1.2共有：**\",\"155\":\"\",\"156\":\"- 支持Array、Map、Set和Date。\",\"157\":\"\",\"158\":\"### 观察变化\",\"159\":\"\",\"160\":\"- makeObserved传入内置类型或collections类型的实例时，可以观测其API带来的变化（collections类型仅ArkTS1.1支持）：\",\"161\":\"\",\"162\":\"  | 类型  | 可观测变化的API                                              |\",\"163\":\"  | ----- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "### 观测变化",
      "注意事项": "修复术语一致性时需严格检查上下文全局使用情况，避免仅依赖局部参考；优先确认技术文档中术语的官方定义和固定搭配，禁止混淆近义词（如“观察”侧重主观查看，“观测”强调技术性监测）。"
    },
    {
      "defect_id": 536548,
      "sentence": "确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。",
      "reference_sentence": "确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。",
      "line_num": 490,
      "context": "{\"485\":\"\",\"486\":\"- x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。\",\"487\":\"\",\"488\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"489\":\"\",\"490\":\"- x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。\",\"491\":\"\",\"492\":\"- y2: 确定贝塞尔曲线第二点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"493\":\"\",\"494\":\"## WindowInfo<sup>18+</sup>\",\"495\":\"\"}",
      "用户拒绝的修改": "确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。",
      "注意事项": "修复时应严格检查上下文相邻条目的表述惯例，避免局部优化破坏整体一致性；当参数说明存在重复模式时，优先保持原始文本的简洁性而非强制添加重复限定词。"
    },
    {
      "defect_id": 538097,
      "sentence": "其他API不会改变原始数组，所以不会触发UI刷新。\r",
      "reference_sentence": "其他API不会改变原始数组，所以不会触发UI刷新。\r",
      "line_num": 254,
      "context": "{\"249\":\"#### collections.Array\",\"250\":\"collections.Array可以触发UI刷新的API有：\",\"251\":\"- 改变数组长度：push、pop、shift、unshift、splice、shrinkTo、extendTo\",\"252\":\"- 改变数组项本身：sort、fill\",\"253\":\"\",\"254\":\"其他API不会改变原始数组，所以不会触发UI刷新。\",\"255\":\"\",\"256\":\"```ts\",\"257\":\"import { collections } from '@kit.ArkTS';\",\"258\":\"import { UIUtils } from '@kit.ArkUI';\",\"259\":\"\"}",
      "用户拒绝的修改": "其他API不要改变原始数组，因此不会触发UI刷新。",
      "注意事项": "修复时必须保持原句的句式类型（陈述句/祈使句）与上下文一致，避免因替换连接词或调整语态导致语气变化；修改后需整体检查句子在段落中的语法连贯性，确保与相邻语句保持相同表达风格。"
    },
    {
      "defect_id": 539004,
      "sentence": "2.在设置->系统->中转站中关闭“拖拽时启动”。",
      "reference_sentence": "2.在设置->系统->中转站中关闭“拖拽时启动”。",
      "line_num": 365,
      "context": "{\"360\":\"\",\"361\":\"**解决措施**\",\"362\":\"\",\"363\":\"1.设置Image组件的draggable属性为false。\",\"364\":\"\",\"365\":\"2.在设置->系统->中转站中关闭“拖拽时启动”。\",\"366\":\"\",\"367\":\"**参考链接**\",\"368\":\"\",\"369\":\"1.[draggable](../reference/apis-arkui/arkui-ts/ts-basic-components-image.md#draggable9)\"}",
      "用户拒绝的修改": "2.在设置->系统->中转站中关闭“拖拽启动”。",
      "注意事项": "修改前必须核对上下文术语一致性，优先保留用户确认正确的原始表述；仅在存在明确表达冲突时建议调整，避免过度修改已确认无误的规范术语。"
    },
    {
      "defect_id": 538308,
      "sentence": "Promise used to return the source ID.",
      "reference_sentence": "Promise used to return the source ID.",
      "line_num": 140,
      "context": "{\"135\":\"\",\"136\":\"**Return value**\",\"137\":\"\",\"138\":\"| Type               | Description                           |\",\"139\":\"| ------------------- | ------------------------------- |\",\"140\":\"| Promise&lt;number&gt; | Promise used to return the source ID.|\",\"141\":\"\",\"142\":\"**Example**\",\"143\":\"\",\"144\":\"```ts\",\"145\":\"import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "用于返回源ID的Promise。",
      "注意事项": "修复时应优先保留技术术语或专有名词的英文原文，仅在通用表述中统一用词；需结合上下文判断中英文混合使用是否属于文档既定规范，避免破坏技术文档的专业性表达。"
    },
    {
      "defect_id": 538931,
      "sentence": "自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。",
      "reference_sentence": "自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。",
      "line_num": 748,
      "context": "{\"743\":\"| ----------- | ---------------------------------------- |\",\"744\":\"| Default     | 默认触摸测试效果：自身及子节点响应触摸测试，但阻塞兄弟节点的触摸测试，不影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"745\":\"| Block       | 自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"746\":\"| Transparent | 自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"747\":\"| None        | 自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。      |\",\"748\":\"| BLOCK_HIERARCHY<sup>20+</sup>   | 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"749\":\"| BLOCK_DESCENDANTS<sup>20+</sup> | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"750\":\"\",\"751\":\"## DialogButtonStyle<sup>10+</sup>\",\"752\":\"\",\"753\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\"}",
      "用户拒绝的修改": "自身和子节点响应触摸测试，阻塞所有优先级较低的兄弟节点和父节点参与触摸测试。",
      "注意事项": "在修复术语一致性时，需严格核对上下文统一用词（如“阻止”与“阻塞”），优先保留文档原有术语体系；若涉及技术概念替换，必须结合上下文判断是否存在版本差异或场景区分，避免机械替换破坏专业表述一致性。"
    },
    {
      "defect_id": 538928,
      "sentence": "自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。",
      "reference_sentence": "自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。",
      "line_num": 745,
      "context": "{\"740\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"741\":\"\",\"742\":\"| 名称          | 说明                                       |\",\"743\":\"| ----------- | ---------------------------------------- |\",\"744\":\"| Default     | 默认触摸测试效果：自身及子节点响应触摸测试，但阻塞兄弟节点的触摸测试，不影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"745\":\"| Block       | 自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"746\":\"| Transparent | 自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"747\":\"| None        | 自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。      |\",\"748\":\"| BLOCK_HIERARCHY<sup>20+</sup>   | 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"749\":\"| BLOCK_DESCENDANTS<sup>20+</sup> | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"750\":\"\"}",
      "用户拒绝的修改": "自身响应触摸测试，阻塞子节点、兄弟节点及祖先节点的触摸测试。",
      "注意事项": "修复时应确保术语一致性，避免将同一操作的不同表述误判为用词重复；优先保留原文术语，仅在上下文明确存在同义词混用时进行替换，并严格校验修改后的逻辑连贯性。"
    },
    {
      "defect_id": 538929,
      "sentence": "自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。",
      "reference_sentence": "自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。",
      "line_num": 746,
      "context": "{\"741\":\"\",\"742\":\"| 名称          | 说明                                       |\",\"743\":\"| ----------- | ---------------------------------------- |\",\"744\":\"| Default     | 默认触摸测试效果：自身及子节点响应触摸测试，但阻塞兄弟节点的触摸测试，不影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"745\":\"| Block       | 自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"746\":\"| Transparent | 自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"747\":\"| None        | 自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。      |\",\"748\":\"| BLOCK_HIERARCHY<sup>20+</sup>   | 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"749\":\"| BLOCK_DESCENDANTS<sup>20+</sup> | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"750\":\"\",\"751\":\"## DialogButtonStyle<sup>10+</sup>\"}",
      "用户拒绝的修改": "自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，也不会阻塞祖先节点的触摸测试。",
      "注意事项": "修复时应严格校验上下文术语使用惯例，避免将不同语义的词汇（如\"阻塞\"和\"影响\"）误判为不一致，需结合技术文档中已明确定义的术语体系保持表述准确性。"
    },
    {
      "defect_id": 538932,
      "sentence": "自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。",
      "reference_sentence": "自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。",
      "line_num": 749,
      "context": "{\"744\":\"| Default     | 默认触摸测试效果：自身及子节点响应触摸测试，但阻塞兄弟节点的触摸测试，不影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"745\":\"| Block       | 自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"746\":\"| Transparent | 自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"747\":\"| None        | 自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。      |\",\"748\":\"| BLOCK_HIERARCHY<sup>20+</sup>   | 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"749\":\"| BLOCK_DESCENDANTS<sup>20+</sup> | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"750\":\"\",\"751\":\"## DialogButtonStyle<sup>10+</sup>\",\"752\":\"\",\"753\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"754\":\"\"}",
      "用户拒绝的修改": "自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会阻塞祖先节点的触摸测试。",
      "注意事项": "在修复术语一致性时需严格核查上下文术语体系，确保替换词汇在文档上下文中具有完全相同的语义指向和技术含义，避免跨场景混用专业术语。"
    },
    {
      "defect_id": 538930,
      "sentence": "自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。",
      "reference_sentence": "自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。",
      "line_num": 747,
      "context": "{\"742\":\"| 名称          | 说明                                       |\",\"743\":\"| ----------- | ---------------------------------------- |\",\"744\":\"| Default     | 默认触摸测试效果：自身及子节点响应触摸测试，但阻塞兄弟节点的触摸测试，不影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"745\":\"| Block       | 自身响应触摸测试，阻塞子节点和兄弟节点的触摸测试，同时阻塞祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"746\":\"| Transparent | 自身和子节点都响应触摸测试，不会阻塞兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"747\":\"| None        | 自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。      |\",\"748\":\"| BLOCK_HIERARCHY<sup>20+</sup>   | 自身和子节点响应触摸测试，阻止所有优先级较低的兄弟节点和父节点参与触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"749\":\"| BLOCK_DESCENDANTS<sup>20+</sup> | 自身不响应触摸测试，并且所有的后代（孩子，孙子等）也不响应触摸测试，不会影响祖先节点的触摸测试。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"750\":\"\",\"751\":\"## DialogButtonStyle<sup>10+</sup>\",\"752\":\"\"}",
      "用户拒绝的修改": "自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试，也不会阻塞祖先节点的触摸测试。",
      "注意事项": "修复时应严格校验上下文术语一致性，优先沿用原文用词，避免在未确认语义等价性的情况下替换近义词；特别关注技术文档中具有特定领域含义的动词(如\"阻塞\"/\"影响\")，需结合参考句群验证是否存在差异化使用场景。"
    },
    {
      "defect_id": 539700,
      "sentence": "为显示弹出框的独立性，弹出框弹出时会与周边进行避让，包括状态栏、导航条以及键盘等留有间距。故当软键盘弹出时，默认情况下，弹出框会自动避开软键盘，并与之保持16vp的距离。",
      "reference_sentence": "为显示弹出框的独立性，弹出框弹出时会与周边进行避让，包括状态栏、导航条以及键盘等留有间距。故当软键盘弹出时，默认情况下，弹出框会自动避开软键盘，并与之保持16vp的距离。",
      "line_num": 168,
      "context": "{\"163\":\"\",\"164\":\" ![UIContextPromptAction](figures/UIContextPromptActionDialogMask.gif)\",\"165\":\"\",\"166\":\"## 设置弹出框避让软键盘的距离\",\"167\":\"\",\"168\":\"为显示弹出框的独立性，弹出框弹出时会与周边进行避让，包括状态栏、导航条以及键盘等留有间距。故当软键盘弹出时，默认情况下，弹出框会自动避开软键盘，并与之保持16vp的距离。从API version15开始，开发者可以利用[BaseDialogOptions](../reference/apis-arkui/js-apis-promptAction.md#basedialogoptions11)中的keyboardAvoidMode和keyboardAvoidDistance这两个配置项，来设置弹出框在软键盘弹出时的行为，包括是否需要避开软键盘以及与软键盘之间的距离。\",\"169\":\"\",\"170\":\"设置软键盘间距时，需要将keyboardAvoidMode值设为KeyboardAvoidMode.DEFAULT。\",\"171\":\"\",\"172\":\"```ts\",\"173\":\"import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "为显示弹出框的独立性，弹出框弹出时会与周边进行避让，包括状态栏、导航条以及键盘等，留有间距。故当软键盘弹出时，默认情况下，弹出框会自动避开软键盘，并与之保持16vp的距离。",
      "注意事项": "在修复术语一致性前必须严格核对上下文所有实例，避免将正确统一用词误判为不一致；修改请求需附带具体位置证据，确保术语变体真实存在于文档中而非误识别。"
    },
    {
      "defect_id": 539427,
      "sentence": "指定字体系列，支持如下几种类型：'sans-serif',&nbsp;'serif',&nbsp;'monospace'。API version 20及以后支持注册过的自定义字体（DevEco Studio的预览器不支持显示自定义字体），具体使用方法参考自定义字体[font](#font)示例。",
      "reference_sentence": "指定字体系列，支持如下几种类型：'sans-serif',&nbsp;'serif',&nbsp;'monospace'。",
      "line_num": 108,
      "context": "{\"103\":\"| [lineWidth](#linewidth) | number | 否 | 否 | 设置绘制线条的宽度。<br/>默认值：1(px)<br/>默认单位：vp <br/> linewidth取值不支持0和负数，0和负数按异常值处理，异常值按默认值处理。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"104\":\"| [strokeStyle](#strokestyle)              | string&nbsp;\\\\|number<sup>10+</sup>&nbsp;\\\\|[CanvasGradient](ts-components-canvas-canvasgradient.md)&nbsp;\\\\|&nbsp;[CanvasPattern](ts-components-canvas-canvaspattern.md)  | 否 | 否 | 设置线条的颜色。<br/>-&nbsp;类型为string时，表示设置线条使用的颜色，颜色格式参考[ResourceColor](ts-types.md#resourcecolor)中string类型说明。<br/>默认值：'#000000'<br/>- 类型为number时，表示设置线条使用的颜色，不支持设置全透明色，颜色格式参考[ResourceColor](ts-types.md#resourcecolor)中number类型说明。<br/>默认值：0x000000<br/>-&nbsp;类型为CanvasGradient时，表示渐变对象，使用[createLinearGradient](#createlineargradient)方法创建。<br/>-&nbsp;类型为CanvasPattern时，使用[createPattern](#createpattern)方法创建。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"105\":\"| [lineCap](#linecap)                      | [CanvasLineCap](#canvaslinecap类型说明) | 否 | 否 | 指定线端点的样式，可选值为：<br/>-&nbsp;'butt'：线端点以方形结束。<br/>-&nbsp;'round'：线端点以圆形结束。<br/>-&nbsp;'square'：线端点以方形结束，该样式下会增加一个长度和线段厚度相同，宽度是线段厚度一半的矩形。<br/>默认值：'butt'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"106\":\"| [lineJoin](#linejoin)                    | [CanvasLineJoin](#canvaslinejoin类型说明) | 否 | 否 | 指定线段间相交的交点样式，可选值为：<br/>-&nbsp;'round'：在线段相连处绘制一个扇形，扇形的圆角半径是线段的宽度。<br/>-&nbsp;'bevel'：在线段相连处使用三角形为底填充，&nbsp;每个部分矩形拐角独立。<br/>-&nbsp;'miter'：在相连部分的外边缘处进行延伸，使其相交于一点，形成一个菱形区域，该属性可以通过设置miterLimit属性展现效果。<br/>默认值：'miter'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"107\":\"| [miterLimit](#miterlimit)                | number | 否 | 否 | 设置斜接面限制值，该值指定了线条相交处内角和外角的距离。  <br/>默认值：10px<br/>单位：px<br/>miterLimit取值不支持0和负数，0和负数按异常值处理，异常值按默认值处理。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"108\":\"| [font](#font)                            | string | 否 | 否 | 设置文本绘制中的字体样式。<br/>语法：ctx.font='font-style&nbsp;font-weight&nbsp;font-size&nbsp;font-family'<br/>-&nbsp;font-style(可选)，用于指定字体样式，支持如下几种样式：'normal','italic'。<br/>-&nbsp;font-weight(可选)，用于指定字体的粗细，支持如下几种类型：'normal',&nbsp;'bold',&nbsp;'bolder',&nbsp;'lighter',&nbsp;100,&nbsp;200,&nbsp;300,&nbsp;400,&nbsp;500,&nbsp;600,&nbsp;700,&nbsp;800,&nbsp;900。<br/>-&nbsp;font-size(可选)，指定字号和行高，单位支持px、vp。使用时需要添加单位。<br/>-&nbsp;font-family(可选)，指定字体系列，支持如下几种类型：'sans-serif',&nbsp;'serif',&nbsp;'monospace'。API version 20及以后支持注册过的自定义字体（DevEco Studio的预览器不支持显示自定义字体），具体使用方法参考自定义字体[font](#font)示例。<br/>默认值：'normal normal 14px sans-serif'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"109\":\"| [textAlign](#textalign)                  | [CanvasTextAlign](#canvastextalign类型说明) | 否 | 否 | 设置文本绘制中的文本对齐方式，可选值为：<br/>-&nbsp;'left'：文本左对齐。<br/>-&nbsp;'right'：文本右对齐。<br/>-&nbsp;'center'：文本居中对齐。<br/>-&nbsp;'start'：文本对齐界线开始的地方。<br/>-&nbsp;'end'：文本对齐界线结束的地方。<br/>ltr布局模式下'start'和'left'一致，rtl布局模式下'start'和'right'一致。<br/>默认值：'left'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"110\":\"| [textBaseline](#textbaseline)            | [CanvasTextBaseline](#canvastextbaseline类型说明) | 否 | 否 | 设置文本绘制中的水平对齐方式，可选值为：<br/>-&nbsp;'alphabetic'：文本基线是标准的字母基线。<br/>-&nbsp;'top'：文本基线在文本块的顶部。<br/>-&nbsp;'hanging'：文本基线是悬挂基线。<br/>-&nbsp;'middle'：文本基线在文本块的中间。<br/>-&nbsp;'ideographic'：文字基线是表意字基线；如果字符本身超出了alphabetic基线，那么ideograhpic基线位置在字符本身的底部。<br/>-&nbsp;'bottom'：文本基线在文本块的底部。&nbsp;与ideographic基线的区别在于ideographic基线不需要考虑下行字母。<br/>默认值：'alphabetic'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"111\":\"| [globalAlpha](#globalalpha)              | number | 否 | 否 | 设置透明度，范围为[0.0, 1.0]，0.0为完全透明，1.0为完全不透明。若给定值小于0.0，则取值0.0；若给定值大于1.0，则取值1.0.<br/>默认值：1.0<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"112\":\"| [lineDashOffset](#linedashoffset)        | number | 否 | 否 | 设置画布的虚线偏移量，精度为float。    <br/>默认值：0.0<br/>默认单位：vp<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"113\":\"| [globalCompositeOperation](#globalcompositeoperation) | string | 否 | 否 | 设置合成操作的方式。类型字段可选值有'source-over'，'source-atop'，'source-in'，'source-out'，'destination-over'，'destination-atop'，'destination-in'，'destination-out'，'lighter'，'copy'，'xor'。<br/>默认值：'source-over'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "指定字体系列，支持如下几种类型：'sans-serif', 'serif', 'monospace'。API version 20及以后支持注册过的自定义字体系列（DevEco Studio的预览器不支持显示自定义字体系列），具体使用方法参考自定义字体系列[font](#font)示例。",
      "注意事项": "修复时必须严格遵循文档中已确立的术语体系，优先核对上下文和参考句子的用词规范，确保所有相关术语（如\"字体系列\"）在整段及相邻条目中完全统一，避免局部替换导致新的不一致。"
    },
    {
      "defect_id": 537633,
      "sentence": "默认值：NORMAL_MODE。",
      "reference_sentence": "设置web组件的销毁模式。",
      "line_num": 9776,
      "context": "{\"9771\":\"\",\"9772\":\"**参数：**\",\"9773\":\"\",\"9774\":\"| 参数名   | 类型    | 必填 | 说明                      |\",\"9775\":\"| -------- | ------- | ---- | -------------------------------------- |\",\"9776\":\"| mode | [WebDestroyMode](./arkts-apis-webview-e.md#webdestroymode20) | 是 | 设置web组件的销毁模式。<br>默认值：NORMAL_MODE。 |\",\"9777\":\"\",\"9778\":\"**错误码：**\",\"9779\":\"\",\"9780\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"9781\":\"\"}",
      "用户拒绝的修改": "默认值：普通模式。",
      "注意事项": "修复时必须严格区分代码引用与普通文本，保留枚举值、常量等原文命名；涉及技术术语或预定义参数时应优先保持中英文一致性，禁止擅自翻译代码级专有名词。"
    },
    {
      "defect_id": 538333,
      "sentence": "已打开的有效文件描述符对象，描述振动文件。配套的offset和length需符合实际文件长度。",
      "reference_sentence": "已打开的有效文件描述符对象，描述振动文件。配套的offset和length需符合实际文件长度。",
      "line_num": 134,
      "context": "{\"129\":\"**参数：**\",\"130\":\"\",\"131\":\"| 参数名  | 类型                                     | 必填| 说明                    |\",\"132\":\"| -------- | ---------------------------------------- | ---- | ------------------------ |\",\"133\":\"| audioFd | [AudioHapticFileDescriptor](#audioHapticFileDescriptor) | 是 | 已打开的有效文件描述符对象，描述音频文件。配套的offset和length需符合实际文件长度。 |\",\"134\":\"| hapticFd | [AudioHapticFileDescriptor](#audioHapticFileDescriptor) | 是 | 已打开的有效文件描述符对象，描述振动文件。配套的offset和length需符合实际文件长度。 |\",\"135\":\"\",\"136\":\"**返回值：**\",\"137\":\"\",\"138\":\"| 类型               | 说明                           |\",\"139\":\"| ------------------- | ------------------------------- |\"}",
      "用户拒绝的修改": "已打开的有效文件描述符对象，描述振动文件。配套的文件描述符偏移量和长度需符合实际文件长度。",
      "注意事项": "修复时应严格校验上下文术语使用场景，避免将参数名称中的缩写（如Fd）误判为术语混用，在参数说明已正确使用全称\"文件描述符\"的情况下，无需对关联字段（offset/length）添加冗余修饰词。"
    },
    {
      "defect_id": 539833,
      "sentence": "共享配置文件shared_config.json的文件名\"shared_config\"可自定义，根节点名称为crossAppSharedConfig，为对象数组，标识当前共享配置项的数量。（一个应用最多可以发布32个配置项，这个数量是静态配置项与动态配置项的总和。静态配置项数量超过32时，只解析前32个有效配置，其余配置不生效。）",
      "reference_sentence": "配置发布方需要配置module.json5文件中的crossAppSharedConfig字段，通过crossAppSharedConfig字段引用shared_config.json文件，shared_config.json为共享配置文件，定义了应用希望与其他应用共享的配置项。",
      "line_num": 59,
      "context": "{\"54\":\"    \\\"crossAppSharedConfig\\\": \\\"$profile:shared_config\\\"\",\"55\":\"  }\",\"56\":\"```\",\"57\":\"\",\"58\":\"\",\"59\":\"共享配置文件shared_config.json的文件名\\\"shared_config\\\"可自定义，根节点名称为crossAppSharedConfig，为对象数组，标识当前共享配置项的数量。（一个应用最多可以发布32个配置项，这个数量是静态配置项与动态配置项的总和。静态配置项数量超过32时，只解析前32个有效配置，其余配置不生效。）<br/>\",\"60\":\"crossAppSharedConfig字段配置说明：\",\"61\":\"\",\"62\":\"| 属性名称 | 含义 | 数据类型 | 必填 |\",\"63\":\"| ------- | ------- | ------- | ------- |\",\"64\":\"| uri | 共享配置项的全局唯一标识。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复。uri最大长度为256字节。 | 字符串 | 是 |\"}",
      "用户拒绝的修改": "共享配置文件的文件名可自定义为\\",
      "注意事项": "修改前必须核查上下文术语使用场景，确保同一概念在文档中保持完全一致的命名方式（如\"shared_config.json\"和\"共享配置文件\"应明确关联或统一），涉及专业术语（如静态/动态配置项）时禁止拆分或替换核心词组。"
    },
    {
      "defect_id": 541037,
      "sentence": "OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。",
      "reference_sentence": "本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。",
      "line_num": 5,
      "context": "{\"1\":\"# Node-API简介\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。它提供了一组稳定的、跨平台的API，可以在不同的操作系统上使用。\",\"6\":\"\",\"7\":\"本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\"}",
      "用户拒绝的修改": "OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API。",
      "注意事项": "修复时应先检查术语定义是否已在上下文中明确说明，避免在已有后续澄清的位置重复添加冗余解释，确保术语指代的一致性声明仅出现在首次引入或专门的定义段落。"
    },
    {
      "defect_id": 538332,
      "sentence": "通过文件描述符（fd）注册音频和振动资源，确保二者在播放时同步。",
      "reference_sentence": "通过文件描述符（fd）注册音频和振动资源，确保二者在播放时同步。",
      "line_num": 124,
      "context": "{\"119\":\"\",\"120\":\"### registerSourceFromFd\",\"121\":\"\",\"122\":\"registerSourceFromFd(audioFd: AudioHapticFileDescriptor, hapticFd: AudioHapticFileDescriptor): Promise&lt;number&gt;\",\"123\":\"\",\"124\":\"通过文件描述符（fd）注册音频和振动资源，确保二者在播放时同步。\",\"125\":\"注册资源后，将返回资源ID。此方法通过Promise异步返回。\",\"126\":\"\",\"127\":\"**系统能力：**: SystemCapability.Multimedia.AudioHaptic.Core\",\"128\":\"\",\"129\":\"**参数：**\"}",
      "用户拒绝的修改": "通过文件描述符（fd）注册音频和振动资源，确保它们在播放时同步。",
      "注意事项": "修复术语一致性时需优先检查上下文参数命名规范，若参数名已使用缩写形式（如audioFd/hapticFd），应保留首次定义的\"文件描述符（fd）\"结构，避免强行统一代词导致语义断裂。"
    },
    {
      "defect_id": 541232,
      "sentence": "- 用于napi_escape_handle接口，将ArkTS/JS对象逃逸到父scope，以便在外部作用域使用。",
      "reference_sentence": "- 用于napi_escape_handle接口，将ArkTS/JS对象逃逸到父scope，以便在外部作用域使用。",
      "line_num": 123,
      "context": "{\"118\":\"\",\"119\":\"- 由napi_open_escapable_handle_scope接口创建，由napi_close_escapable_handle_scope接口关闭。\",\"120\":\"\",\"121\":\"- 表示一种特殊类型的句柄范围，用于将在escapable_handle_scope范围内创建的值返回给父scope。\",\"122\":\"\",\"123\":\"- 用于napi_escape_handle接口，将ArkTS/JS对象逃逸到父scope，以便在外部作用域使用。\",\"124\":\"\",\"125\":\"#### napi_ref \",\"126\":\"\",\"127\":\"指向napi_value，允许用户管理ArkTS/JS值的生命周期。\",\"128\":\"\"}",
      "用户拒绝的修改": "- 用于napi_escape_handle接口，将JS对象逃逸到父scope，以便在外部作用域使用。",
      "注意事项": "在修改术语时必须严格检查上下文术语使用一致性，特别是复合术语（如ArkTS/JS）不可拆分简化，需保持与文档既有表述及用户指定格式完全统一，优先通过全局上下文验证而非局部优化。"
    },
    {
      "defect_id": 538334,
      "sentence": "console.info(`Promise returned to indicate that the source id of the registerd source ${value}.`);",
      "reference_sentence": "console.info(`Promise returned with registered source id ${value}.`);",
      "line_num": 166,
      "context": "{\"161\":\"  length: hapticFile.length,\",\"162\":\"};\",\"163\":\"let id = 0;\",\"164\":\"\",\"165\":\"audioHapticManagerInstance.registerSourceFromFd(audioFd, hapticFd).then((value: number) => {\",\"166\":\"  console.info(`Promise returned with registered source id ${value}.`);\",\"167\":\"  id = value;\",\"168\":\"}).catch ((err: BusinessError) => {\",\"169\":\"  console.error(`Failed to register source ${err}`);\",\"170\":\"});\",\"171\":\"```\"}",
      "用户拒绝的修改": "console.info(`Promise returned to indicate that the source id of the registered source ${value}.`);",
      "注意事项": "修复术语拼写前需确认用户是否严格遵循术语规范，在日志等非正式文本中允许适当灵活性；优先参考上下文已有正确用法（如\"registered source id\"）保持统一表达。"
    },
    {
      "defect_id": 538977,
      "sentence": "系统支持的度量衡。支持的范围可以通过[getSystemMeasurements](#getsystemmeasurements20)获取。",
      "reference_sentence": "系统支持的度量衡及名称。其中Map的key表示度量衡的标识，value表示度量衡对应的名称。支持的度量衡包括公制、英制和美制。",
      "line_num": 824,
      "context": "{\"819\":\"\",\"820\":\"**参数：**\",\"821\":\"\",\"822\":\"| 参数名  | 类型      | 必填   | 说明                              |\",\"823\":\"| ---- | ------- | ---- | ------------------------------- |\",\"824\":\"| identifier | string | 是 | 系统支持的度量衡。支持的范围可以通过[getSystemMeasurements](#getsystemmeasurements20)获取。 |\",\"825\":\"\",\"826\":\"**错误码：**\",\"827\":\"\",\"828\":\"以下错误码的详细介绍请参见[ohos.i18n错误码](errorcode-i18n.md)和[通用错误码](../errorcode-universal.md)。\",\"829\":\"\"}",
      "用户拒绝的修改": "系统支持的度量衡及名称。支持的范围可以通过[getSystemMeasurements](#getsystemmeasurements20)获取。",
      "注意事项": "修复时需严格校验术语在上下文中的具体定义和逻辑关联，避免仅机械匹配词汇一致性而忽略参数实际含义（如“identifier”仅对应度量衡标识而非名称），确保修改后的描述同时满足表达统一性和语义准确性。"
    },
    {
      "defect_id": 541038,
      "sentence": "一般情况下OpenHarmony应用开发使用ArkTS/JS语言，但部分场景由于性能、效率等要求，比如游戏、物理模拟等，需要依赖使用现有的C/C++库。Node-API规范封装了I/O、CPU密集型、OS底层等能力并对外暴露C接口，使用C/C++模块的注册机制，向ArkTS/JS对象上挂载属性和方法的方式来实现ArkTS/JS和C/C++的交互。",
      "reference_sentence": "本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> OpenHarmony Node-API与Node.js 12.x LTS的Node-API规范的接口异同点，详见[Node-API参考](../reference/native-lib/napi.md)\",\"12\":\"\",\"13\":\"一般情况下OpenHarmony应用开发使用ArkTS/JS语言，但部分场景由于性能、效率等要求，比如游戏、物理模拟等，需要依赖使用现有的C/C++库。Node-API规范封装了I/O、CPU密集型、OS底层等能力并对外暴露C接口，使用C/C++模块的注册机制，向ArkTS/JS对象上挂载属性和方法的方式来实现ArkTS/JS和C/C++的交互。主要场景如下：\",\"14\":\"\",\"15\":\"- 系统可以将框架层丰富的模块功能通过Node-API的模块注册机制对外暴露ArkTS/JS的接口，将C/C++的能力开放给应用的ArkTS/JS层。\",\"16\":\"\",\"17\":\"- 应用开发者也可以选择将一些对性能、底层系统调用有要求的核心功能用C/C++封装实现，再通过ArkTS/JS接口使用，提高应用本身的执行效率。\",\"18\":\"\"}",
      "用户拒绝的修改": "一般情况下OpenHarmony应用开发使用ArkTS/JS语言，但部分场景由于性能、效率等要求，比如游戏、物理模拟等，需要依赖使用现有的C/C++库。OpenHarmony Node-API规范封装了I/O、CPU密集型、OS底层等能力并对外暴露C接口，使用C/C++模块的注册机制，向ArkTS/JS对象上挂载属性和方法的方式来实现ArkTS/JS和C/C++的交互。",
      "注意事项": "修复术语一致性时需优先核查文档中预先定义的简称规则，确保全局遵循已声明的命名约定（如\"Node-API\"特指\"OpenHarmony Node-API\"），避免在已明确缩写的场景中重复添加限定词。"
    },
    {
      "defect_id": 541348,
      "sentence": "napi提供了运行底层事件循环的两种模式, 其定义如下：",
      "reference_sentence": "napi提供了线程安全任务的优先级, 底层任务队列中的任务会根据其优先级被依次执行, 优先级的定义如下：",
      "line_num": 220,
      "context": "{\"215\":\"| napi_qos_default | 默认。 |\",\"216\":\"| napi_qos_user_initiated | 高等级，用户触发并且可见进展，例如打开文档。 |\",\"217\":\"\",\"218\":\"### 事件循环模式\",\"219\":\"\",\"220\":\"napi提供了运行底层事件循环的两种模式, 其定义如下：\",\"221\":\"\",\"222\":\"```c\",\"223\":\"typedef enum {\",\"224\":\"    napi_event_mode_default = 0,\",\"225\":\"    napi_event_mode_nowait = 1,\"}",
      "用户拒绝的修改": "napi提供了运行底层事件循环的两种定义，其定义如下：",
      "注意事项": "修改前必须优先验证上下文中的核心术语（如章节标题\"事件循环模式\"），确保概念表述与文档已有定义严格统一，避免因局部句式调整破坏整体术语一致性。"
    },
    {
      "defect_id": 541350,
      "sentence": "napi_get_value_string_latin1 | 获取给定ArkTSvaule对应的ISO-8859-1编码的字符串。 |",
      "reference_sentence": "napi_get_value_string_latin1 | 获取给定ArkTS value对应的ISO-8859-1编码的字符串。 |",
      "line_num": 289,
      "context": "{\"284\":\"| -------- | -------- |\",\"285\":\"| napi_create_string_utf16 | 通过UTF16编码的C字符串数据创建ArkTS String。 |\",\"286\":\"| napi_get_value_string_utf16 | 获取给定ArkTS vaule对应的UTF16编码的字符串。 |\",\"287\":\"| napi_create_string_latin1 | 通过ISO-8859-1编码的C字符串数据创建ArkTS String。 |\",\"288\":\"| napi_create_string_utf8 | 通过UTF8编码的C字符串数据创建ArkTS String。 |\",\"289\":\"| napi_get_value_string_latin1 | 获取给定ArkTSvaule对应的ISO-8859-1编码的字符串。 |\",\"290\":\"| napi_get_value_string_utf8 | 获取给定ArkTS vaule对应的UTF8编码的字符串。 |\",\"291\":\"\",\"292\":\"### date相关\",\"293\":\"\",\"294\":\"| 接口 | 功能说明 |\"}",
      "用户拒绝的修改": "napi_get_value_string_latin1 | 获取给定ArkTS value对应的ISO-8859-1编码的字符串。 |",
      "注意事项": "修复拼写错误时必须全局检查文档中所有相同术语的一致性，确保所有相关条目同步修正（例如\"vaule\"应统一改为\"value\"），同时需验证术语与上下文格式的匹配性（如\"ArkTSvalue\"应保持空格分隔为\"ArkTS value\"）。"
    },
    {
      "defect_id": 541230,
      "sentence": "napi_value是一个C的结构体指针，表示一个ArkTS/JS对象的引用。napi_value持有了ArkTS/JS对象，同时，napi_value受[napi_handle_scope](#napi_handle_scope)管理，scope中napi_value持有的JS对象不会被释放；出scope后，napi_value将失效，不再持有对应的ArkTS/JS对象。",
      "reference_sentence": "napi_value是一个C的结构体指针，表示一个ArkTS/JS对象的引用。napi_value持有了ArkTS/JS对象，同时，napi_value受[napi_handle_scope](#napi_handle_scope)管理，scope中napi_value持有的JS对象不会被释放；出scope后，napi_value将失效，不再持有对应的ArkTS/JS对象。",
      "line_num": 55,
      "context": "{\"50\":\"} napi_extended_error_info;\",\"51\":\"```\",\"52\":\"\",\"53\":\"### napi_value\",\"54\":\"\",\"55\":\"napi_value是一个C的结构体指针，表示一个ArkTS/JS对象的引用。napi_value持有了ArkTS/JS对象，同时，napi_value受[napi_handle_scope](#napi_handle_scope)管理，scope中napi_value持有的JS对象不会被释放；出scope后，napi_value将失效，不再持有对应的ArkTS/JS对象。\",\"56\":\"\",\"57\":\"### napi_env\",\"58\":\"\",\"59\":\"- 用于表示Node-API执行时的上下文，Native侧函数入参，并传递给函数中的Node-API接口。\",\"60\":\"\"}",
      "用户拒绝的修改": "napi_value是一个C的结构体指针，表示一个JS对象的引用。napi_value持有了JS对象，同时，napi_value受[napi_handle_scope](#napi_handle_scope)管理，scope中napi_value持有的JS对象不会被释放；出scope后，napi_value将失效，不再持有对应的JS对象。",
      "注意事项": "修复时应严格匹配上下文中的复合术语形式（如\"ArkTS/JS对象\"），避免拆分或简化组合词；修改前需全局检查文档中该术语的所有变体，确保统一性优先于简洁性。"
    },
    {
      "defect_id": 541409,
      "sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](_ark_u_i___native_module.md#oh_arkui_dragevent_setdata)使用。",
      "reference_sentence": "向ArkUI_DragEvent中设置拖拽数据。",
      "line_num": 56,
      "context": "{\"51\":\"| [ArkUI_PreDragStatus](_ark_u_i___native_module.md#arkui_predragstatus) [OH_ArkUI_NodeEvent_GetPreDragStatus](_ark_u_i___native_module.md#oh_arkui_nodeevent_getpredragstatus) ([ArkUI_NodeEvent](_ark_u_i___native_module.md#arkui_nodeevent-12) \\\\*nodeEvent) | 获取预览拖拽事件状态。  | \",\"52\":\"| int32_t [OH_ArkUI_DragEvent_DisableDefaultDropAnimation](_ark_u_i___native_module.md#oh_arkui_dragevent_disabledefaultdropanimation) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, bool disable) | 设置是否禁用松手时的系统默认动效，默认不禁用，通常在应用需要自定义落位动效时配置。  | \",\"53\":\"| int32_t [OH_ArkUI_DragEvent_SetSuggestedDropOperation](_ark_u_i___native_module.md#oh_arkui_dragevent_setsuggesteddropoperation) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [ArkUI_DropOperation](_ark_u_i___native_module.md#arkui_dropoperation) dropOperation) | 设置数据处理方式。  | \",\"54\":\"| int32_t [OH_ArkUI_DragEvent_SetDragResult](_ark_u_i___native_module.md#oh_arkui_dragevent_setdragresult) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [ArkUI_DragResult](_ark_u_i___native_module.md#arkui_dragresult) result) | 设置拖拽事件的结果。  | \",\"55\":\"| int32_t [OH_ArkUI_DragEvent_SetData](_ark_u_i___native_module.md#oh_arkui_dragevent_setdata) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [OH_UdmfData](_ark_u_i___native_module.md#oh_udmfdata) \\\\*data) | 向ArkUI_DragEvent中设置拖拽数据。  | \",\"56\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_DragEvent_SetDataLoadParams](_ark_u_i___native_module.md#oh_arkui_dragevent_setdataloadparams) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*dragEvent, [OH_UdmfDataLoadParams](../apis-arkdata/capi-udmf-oh-udmfdataloadparams.md) \\\\*dataLoadParams) | 调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](_ark_u_i___native_module.md#oh_arkui_dragevent_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](_ark_u_i___native_module.md#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。 <br/>**起始版本：** 20 |\",\"57\":\"| int32_t [OH_ArkUI_DragEvent_GetUdmfData](_ark_u_i___native_module.md#oh_arkui_dragevent_getudmfdata) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [OH_UdmfData](_ark_u_i___native_module.md#oh_udmfdata) \\\\*data) | 从ArkUI_DragEvent中获取拖拽默认相关数据。  | \",\"58\":\"| int32_t [OH_ArkUI_DragEvent_GetDataTypeCount](_ark_u_i___native_module.md#oh_arkui_dragevent_getdatatypecount) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, int32_t \\\\*count) | 从ArkUI_DragEvent中获取所拖拽的数据类型种类个数。  | \",\"59\":\"| int32_t [OH_ArkUI_DragEvent_GetDataTypes](_ark_u_i___native_module.md#oh_arkui_dragevent_getdatatypes) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, char \\\\*eventTypeArray[], int32_t length， int32_t maxStrLen) | 从ArkUI_DragEvent中获取拖拽数据的类型列表。  | \",\"60\":\"| int32_t [OH_ArkUI_DragEvent_GetDragResult](_ark_u_i___native_module.md#oh_arkui_dragevent_getdragresult) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [ArkUI_DragResult](_ark_u_i___native_module.md#arkui_dragresult) \\\\*result) | 从ArkUI_DragEvent中获取拖拽结果。  | \",\"61\":\"| int32_t [OH_ArkUI_DragEvent_GetDropOperation](_ark_u_i___native_module.md#oh_arkui_dragevent_getdropoperation) ([ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\*event, [ArkUI_DropOperation](_ark_u_i___native_module.md#arkui_dropoperation) \\\\*operation) | 从ArkUI_DragEvent中获取数据处理方式。  | \"}",
      "用户拒绝的修改": "调用此方法向系统提供数据加载参数，而非直接传入拖拽数据。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](_ark_u_i___native_module.md#oh_arkui_dragevent_setdata) 调用。",
      "注意事项": "修复时应严格区分技术术语与通用词汇，避免在未明确同义时替换核心概念（如\"数据对象\"≠\"拖拽数据\"）；保持动词与API操作场景的一致性（如\"调用\"对应方法执行，\"设置/使用\"对应功能描述），禁止非必要近义词替换。"
    },
    {
      "defect_id": 541519,
      "sentence": "该方法与[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "reference_sentence": "该方法与[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "line_num": 103,
      "context": "{\"98\":\"| int32_t [OH_ArkUI_DragAction_SetPointerId](_ark_u_i___native_module.md#oh_arkui_dragaction_setpointerid) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, int32_t pointer) | 设置手指ID，当屏幕上仅有一只手指在操作时，pointer ID 为 0；一般情况下，配置 0 即可。  | \",\"99\":\"| int32_t [OH_ArkUI_DragAction_SetPixelMaps](_ark_u_i___native_module.md#oh_arkui_dragaction_setpixelmaps) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_PixelmapNative](_ark_u_i___native_module.md#oh_pixelmapnative) \\\\*pixelmapArray[], int32_t size) | 设置拖拽跟手图，只能使用 pixelmap 格式对象。  | \",\"100\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointX](_ark_u_i___native_module.md#oh_arkui_dragaction_settouchpointx) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, float x) | 设置跟手点，相对于设置的第一个pixelmap的左上角。  | \",\"101\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointY](_ark_u_i___native_module.md#oh_arkui_dragaction_settouchpointy) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, float y) | 设置跟手点,相对于设置的第一个pixelmap的左上角。  | \",\"102\":\"| int32_t [OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_UdmfData](_ark_u_i___native_module.md#oh_udmfdata) \\\\*data) | 设置拖拽数据。  | \",\"103\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_DragAction_SetDataLoadParams](_ark_u_i___native_module.md#oh_arkui_dragaction_setdataloadparams) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_UdmfDataLoadParams](../apis-arkdata/capi-udmf-oh-udmfdataloadparams.md) \\\\*dataLoadParams) | 调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。 <br/>**起始版本：** 20 |\",\"104\":\"| int32_t [OH_ArkUI_DragAction_SetDragPreviewOption](_ark_u_i___native_module.md#oh_arkui_dragaction_setdragpreviewoption) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [ArkUI_DragPreviewOption](_ark_u_i___native_module.md#arkui_dragpreviewoption) \\\\*option) | 将构造的ArkUI_DragPreviewOption设置给ArkUI_DragAction。  | \",\"105\":\"| int32_t [OH_ArkUI_DragAction_RegisterStatusListener](_ark_u_i___native_module.md#oh_arkui_dragaction_registerstatuslistener) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, void \\\\*userData, void(\\\\*listener)([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo, void \\\\*userData)) | 注册拖拽状态监听回调,该回调可感知到拖拽已经发起或用户松手结束的状态, 可通过该监听获取到落入方对数据的接收处理是否成功。  | \",\"106\":\"| void [OH_ArkUI_DragAction_UnregisterStatusListener](_ark_u_i___native_module.md#oh_arkui_dragaction_unregisterstatuslistener) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction) | 解注册拖拽状态监听回调。  | \",\"107\":\"| [ArkUI_DragStatus](_ark_u_i___native_module.md#arkui_dragstatus) [OH_ArkUI_DragAndDropInfo_GetDragStatus](_ark_u_i___native_module.md#oh_arkui_draganddropinfo_getdragstatus) ([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 获取dragaction发起拖拽的状态，获取异常时返回 ArkUI_DRAG_STATUS_UNKNOWN。  | \",\"108\":\"| [ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\* [OH_ArkUI_DragAndDropInfo_GetDragEvent](_ark_u_i___native_module.md#oh_arkui_draganddropinfo_getdragevent) ([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 通过dragAndDropInfo获取到DragEvent，可通过DragEvent获取释放结果等。  | \"}",
      "用户拒绝的修改": "此方法与[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "注意事项": "修复时应严格遵循上下文已有术语（如\"该方法\"在参考句中的固定用法），避免过度统一导致偏离实际使用场景；修改前需确认变更范围是否属于当前任务边界，防止引入无关内容干扰用户核心诉求。"
    },
    {
      "defect_id": 541231,
      "sentence": "napi_handle_scope数据类型是用来管理ArkTS/JS对象的生命周期的。它允许ArkTS/JS对象在一定范围内保持活动状态，以便在ArkTS/JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的ArkTS/JS对象都会保持活动状态，直到scope被关闭。这样可以做到ArkTS/JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。",
      "reference_sentence": "napi_handle_scope数据类型是用来管理ArkTS/JS对象的生命周期的。它允许ArkTS/JS对象在一定范围内保持活动状态，以便在ArkTS/JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的ArkTS/JS对象都会保持活动状态，直到scope被关闭。这样可以做到ArkTS/JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。",
      "line_num": 115,
      "context": "{\"110\":\"\",\"111\":\"Node-API包含以下内存管理类型：\",\"112\":\"\",\"113\":\"#### napi_handle_scope\",\"114\":\"\",\"115\":\"napi_handle_scope数据类型是用来管理ArkTS/JS对象的生命周期的。它允许ArkTS/JS对象在一定范围内保持活动状态，以便在ArkTS/JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的ArkTS/JS对象都会保持活动状态，直到scope被关闭。这样可以做到ArkTS/JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。\",\"116\":\"\",\"117\":\"#### napi_escapable_handle_scope\",\"118\":\"\",\"119\":\"- 由napi_open_escapable_handle_scope接口创建，由napi_close_escapable_handle_scope接口关闭。\",\"120\":\"\"}",
      "用户拒绝的修改": "napi_handle_scope数据类型是用来管理JS对象的生命周期的。它允许JS对象在一定范围内保持活动状态，以便在JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的JS对象都会保持活动状态，直到scope被关闭。这样可以做到JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。",
      "注意事项": "在涉及复合术语（如\"ArkTS/JS\"）时，必须严格保持术语格式的完整性和全文一致性，禁止拆分或部分替换；修改前需全局检查文档中所有相关术语的引用方式（包括正文、链接文本和上下文），确保术语颗粒度与原始文档完全对齐。"
    },
    {
      "defect_id": 541439,
      "sentence": "尝试删除给定Object的指定索引处的元素。",
      "reference_sentence": "判断给定ArkTS value是否为TypeArray。",
      "line_num": 352,
      "context": "{\"347\":\"| napi_get_array_length | 获取array的length。 |\",\"348\":\"| napi_is_array | 判断给定ArkTS value是否为array。 |\",\"349\":\"| napi_set_element | 在给定Object的指定索引处，设置属性值。 |\",\"350\":\"| napi_get_element | 获取给定Object指定索引处的元素。 |\",\"351\":\"| napi_has_element | 若给定Object的指定索引处拥有属性。 |\",\"352\":\"| napi_delete_element | 尝试删除给定Object的指定索引处的元素。 |\",\"353\":\"| napi_create_typedarray | 通过现有的ArrayBuffer创建一个ArkTS TypeArray。 |\",\"354\":\"| napi_is_typedarray | 判断给定ArkTS value是否为TypeArray。|\",\"355\":\"| napi_get_typedarray_info | 获取给定TypedArray的各种属性（例如：类型，长度，字节偏移量，ArrayBuffer等）。 |\",\"356\":\"| napi_create_dataview | 通过现有的ArrayBuffer创建一个ArkTS DataView。 |\",\"357\":\"| napi_is_dataview | 判断给定ArkTS value是否为DataView。|\"}",
      "用户拒绝的修改": "尝试删除给定ArkTS value的指定索引处的元素。",
      "注意事项": "修复术语不一致时需严格核对上下文API条目中的用词规范，优先保持同一API内部术语统一（如napi_delete_element相关描述应延续使用\"Object\"而非\"ArkTS value\"），避免跨API术语混用导致概念混淆。"
    },
    {
      "defect_id": 541518,
      "sentence": "此方法应始终优先于[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)使用。",
      "reference_sentence": "此方法应始终优先于[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)使用。",
      "line_num": 103,
      "context": "{\"98\":\"| int32_t [OH_ArkUI_DragAction_SetPointerId](_ark_u_i___native_module.md#oh_arkui_dragaction_setpointerid) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, int32_t pointer) | 设置手指ID，当屏幕上仅有一只手指在操作时，pointer ID 为 0；一般情况下，配置 0 即可。  | \",\"99\":\"| int32_t [OH_ArkUI_DragAction_SetPixelMaps](_ark_u_i___native_module.md#oh_arkui_dragaction_setpixelmaps) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_PixelmapNative](_ark_u_i___native_module.md#oh_pixelmapnative) \\\\*pixelmapArray[], int32_t size) | 设置拖拽跟手图，只能使用 pixelmap 格式对象。  | \",\"100\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointX](_ark_u_i___native_module.md#oh_arkui_dragaction_settouchpointx) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, float x) | 设置跟手点，相对于设置的第一个pixelmap的左上角。  | \",\"101\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointY](_ark_u_i___native_module.md#oh_arkui_dragaction_settouchpointy) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, float y) | 设置跟手点,相对于设置的第一个pixelmap的左上角。  | \",\"102\":\"| int32_t [OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_UdmfData](_ark_u_i___native_module.md#oh_udmfdata) \\\\*data) | 设置拖拽数据。  | \",\"103\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_DragAction_SetDataLoadParams](_ark_u_i___native_module.md#oh_arkui_dragaction_setdataloadparams) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [OH_UdmfDataLoadParams](../apis-arkdata/capi-udmf-oh-udmfdataloadparams.md) \\\\*dataLoadParams) | 调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。 <br/>**起始版本：** 20 |\",\"104\":\"| int32_t [OH_ArkUI_DragAction_SetDragPreviewOption](_ark_u_i___native_module.md#oh_arkui_dragaction_setdragpreviewoption) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, [ArkUI_DragPreviewOption](_ark_u_i___native_module.md#arkui_dragpreviewoption) \\\\*option) | 将构造的ArkUI_DragPreviewOption设置给ArkUI_DragAction。  | \",\"105\":\"| int32_t [OH_ArkUI_DragAction_RegisterStatusListener](_ark_u_i___native_module.md#oh_arkui_dragaction_registerstatuslistener) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction, void \\\\*userData, void(\\\\*listener)([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo, void \\\\*userData)) | 注册拖拽状态监听回调,该回调可感知到拖拽已经发起或用户松手结束的状态, 可通过该监听获取到落入方对数据的接收处理是否成功。  | \",\"106\":\"| void [OH_ArkUI_DragAction_UnregisterStatusListener](_ark_u_i___native_module.md#oh_arkui_dragaction_unregisterstatuslistener) ([ArkUI_DragAction](_ark_u_i___native_module.md#arkui_dragaction) \\\\*dragAction) | 解注册拖拽状态监听回调。  | \",\"107\":\"| [ArkUI_DragStatus](_ark_u_i___native_module.md#arkui_dragstatus) [OH_ArkUI_DragAndDropInfo_GetDragStatus](_ark_u_i___native_module.md#oh_arkui_draganddropinfo_getdragstatus) ([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 获取dragaction发起拖拽的状态，获取异常时返回 ArkUI_DRAG_STATUS_UNKNOWN。  | \",\"108\":\"| [ArkUI_DragEvent](_ark_u_i___native_module.md#arkui_dragevent) \\\\* [OH_ArkUI_DragAndDropInfo_GetDragEvent](_ark_u_i___native_module.md#oh_arkui_draganddropinfo_getdragevent) ([ArkUI_DragAndDropInfo](_ark_u_i___native_module.md#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 通过dragAndDropInfo获取到DragEvent，可通过DragEvent获取释放结果等。  | \"}",
      "用户拒绝的修改": "此方法应始终优先使用[OH_ArkUI_DragAction_SetData](_ark_u_i___native_module.md#oh_arkui_dragaction_setdata)。",
      "注意事项": "修复时应先核对上下文术语使用习惯，避免机械统一忽略已有规范；严格限定修改范围，禁止修改用户未明确指示的内容区域。"
    },
    {
      "defect_id": 541661,
      "sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "reference_sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "line_num": 307,
      "context": "{\"302\":\"| [ArkUI_PreDragStatus](#arkui_predragstatus) [OH_ArkUI_NodeEvent_GetPreDragStatus](#oh_arkui_nodeevent_getpredragstatus) ([ArkUI_NodeEvent](#arkui_nodeevent-12) \\\\*nodeEvent) | 获取预览拖拽事件状态。  |\",\"303\":\"| int32_t [OH_ArkUI_DragEvent_DisableDefaultDropAnimation](#oh_arkui_dragevent_disabledefaultdropanimation) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, bool disable) | 设置是否禁用松手时的系统默认动效，默认不禁用，通常在应用需要自定义落位动效时配置。  |\",\"304\":\"| int32_t [OH_ArkUI_DragEvent_SetSuggestedDropOperation](#oh_arkui_dragevent_setsuggesteddropoperation) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [ArkUI_DropOperation](#arkui_dropoperation) dropOperation) | 设置数据处理方式  |\",\"305\":\"| int32_t [OH_ArkUI_DragEvent_SetDragResult](#oh_arkui_dragevent_setdragresult) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [ArkUI_DragResult](#arkui_dragresult) result) | 设置拖拽事件的结果。  |\",\"306\":\"| int32_t [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [OH_UdmfData](#oh_udmfdata) \\\\*data) | 向ArkUI_DragEvent中设置拖拽数据。  |\",\"307\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_DragEvent_SetDataLoadParams](#oh_arkui_dragevent_setdataloadparams) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*dragEvent, [OH_UdmfDataLoadParams](../apis-arkdata/capi-udmf-oh-udmfdataloadparams.md) \\\\*dataLoadParams) | 调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。 <br/>**起始版本：** 20 |\",\"308\":\"| int32_t [OH_ArkUI_DragEvent_GetUdmfData](#oh_arkui_dragevent_getudmfdata) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [OH_UdmfData](#oh_udmfdata) \\\\*data) | 从ArkUI_DragEvent中获取拖拽默认相关数据。  |\",\"309\":\"| int32_t [OH_ArkUI_DragEvent_GetDataTypeCount](#oh_arkui_dragevent_getdatatypecount) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, int32_t \\\\*count) | 从ArkUI_DragEvent中获取所拖拽的数据类型种类个数。  |\",\"310\":\"| int32_t [OH_ArkUI_DragEvent_GetDataTypes](#oh_arkui_dragevent_getdatatypes) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, char \\\\*\\\\*result[], int32_t length) | 从ArkUI_DragEvent中获取拖拽数据的类型列表。  |\",\"311\":\"| int32_t [OH_ArkUI_DragEvent_GetDragResult](#oh_arkui_dragevent_getdragresult) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [ArkUI_DragResult](#arkui_dragresult) \\\\*result) | 从ArkUI_DragEvent中获取拖拽结果。  |\",\"312\":\"| int32_t [OH_ArkUI_DragEvent_GetDropOperation](#oh_arkui_dragevent_getdropoperation) ([ArkUI_DragEvent](#arkui_dragevent) \\\\*event, [ArkUI_DropOperation](#arkui_dropoperation) \\\\*operation) | 从ArkUI_DragEvent中获取数据处理方式。  |\"}",
      "用户拒绝的修改": "调用此方法向系统提供数据加载参数（dataLoadParams），而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备dataLoadParams。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "注意事项": "严格限定修改范围，仅处理用户明确指出的术语不一致问题（如\"数据加载参数\"/\"dataLoadParams\"混用），避免引入未提及的格式调整（如括号补充英文术语），需通过上下文验证现有文档的术语使用习惯后再进行局部修正。"
    },
    {
      "defect_id": 541923,
      "sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "reference_sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "line_num": 354,
      "context": "{\"349\":\"| int32_t [OH_ArkUI_DragAction_SetPointerId](#oh_arkui_dragaction_setpointerid) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, int32_t pointer) | 设置手指ID，当屏幕上仅有一只手指在操作时，pointer ID 为 0；一般情况下，配置 0 即可。  |\",\"350\":\"| int32_t [OH_ArkUI_DragAction_SetPixelMaps](#oh_arkui_dragaction_setpixelmaps) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, [OH_PixelmapNative](#oh_pixelmapnative) \\\\*pixelmapArray[], int32_t size) | 设置拖拽跟手图，只能使用 pixelmap 格式对象。  |\",\"351\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointX](#oh_arkui_dragaction_settouchpointx) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, float x) | 设置跟手点，相对于设置的第一个pixelmap的左上角。  |\",\"352\":\"| int32_t [OH_ArkUI_DragAction_SetTouchPointY](#oh_arkui_dragaction_settouchpointy) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, float y) | 设置跟手点，相对于设置的第一个pixelmap的左上角。  |\",\"353\":\"| int32_t [OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, [OH_UdmfData](#oh_udmfdata) \\\\*data) | 设置拖拽数据。  |\",\"354\":\"| [ArkUI_ErrorCode](_ark_u_i___native_module.md#arkui_errorcode) [OH_ArkUI_DragAction_SetDataLoadParams](#oh_arkui_dragaction_setdataloadparams) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, [OH_UdmfDataLoadParams](../apis-arkdata/capi-udmf-oh-udmfdataloadparams.md) \\\\*dataLoadParams) | 调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。 <br/>**起始版本：** 20 |\",\"355\":\"| int32_t [OH_ArkUI_DragAction_SetDragPreviewOption](#oh_arkui_dragaction_setdragpreviewoption) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, [ArkUI_DragPreviewOption](#arkui_dragpreviewoption) \\\\*option) | 将构造的ArkUI_DragPreviewOption设置给ArkUI_DragAction。  |\",\"356\":\"| int32_t [OH_ArkUI_DragAction_RegisterStatusListener](#oh_arkui_dragaction_registerstatuslistener) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction, void \\\\*userData, void(\\\\*listener)([ArkUI_DragAndDropInfo](#arkui_draganddropinfo) \\\\*dragAndDropInfo, void \\\\*userData)) | 注册拖拽状态监听回调，该回调可感知到拖拽已经发起或用户松手结束的状态，可通过该监听获取到落入方对数据的接收处理是否成功。  |\",\"357\":\"| void [OH_ArkUI_DragAction_UnregisterStatusListener](#oh_arkui_dragaction_unregisterstatuslistener) ([ArkUI_DragAction](#arkui_dragaction) \\\\*dragAction) | 解注册拖拽状态监听回调。  |\",\"358\":\"| [ArkUI_DragStatus](#arkui_dragstatus) [OH_ArkUI_DragAndDropInfo_GetDragStatus](#oh_arkui_draganddropinfo_getdragstatus) ([ArkUI_DragAndDropInfo](#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 获取dragaction发起拖拽的状态，获取异常时返回 ArkUI_DRAG_STATUS_UNKNOWN。  |\",\"359\":\"| [ArkUI_DragEvent](#arkui_dragevent) \\\\* [OH_ArkUI_DragAndDropInfo_GetDragEvent](#oh_arkui_draganddropinfo_getdragevent) ([ArkUI_DragAndDropInfo](#arkui_draganddropinfo) \\\\*dragAndDropInfo) | 通过dragAndDropInfo获取到DragEvent，可通过DragEvent获取释放结果等。  |\"}",
      "用户拒绝的修改": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用处理释放数据的效率。此方法应始终优先于[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与[OH_ArkUI_DragAction_SetData](#oh_arkui_dragaction_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "注意事项": "确保术语统一时严格验证上下文一致性，避免修改未被明确指出的同义词；优先保持原始技术术语的完整性，仅在存在明确混用且影响理解时进行替换。"
    },
    {
      "defect_id": 541786,
      "sentence": "在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源必须在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。",
      "reference_sentence": "在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源必须在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：\",\"10\":\"\",\"11\":\"- **资源管理**：在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源必须在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。\",\"12\":\"- **钩子函数（Hook）**：钩子函数是一种在特定事件或时间点自动执行的回调函数。在Node-API模块的上下文中，清理钩子函数通常用于在环境或进程退出时执行资源清理任务。这是因为环境或进程退出时，操作系统可能不会立即回收所有资源，因此需要通过清理钩子函数来确保所有资源都被正确释放。\",\"13\":\"\",\"14\":\"以上这些基本概念是理解和使用Node-API接口注册环境清理钩子的基础，下面将介绍具体的接口和使用示例。\",\"15\":\"\",\"16\":\"## 场景和功能介绍\"}",
      "用户拒绝的修改": "在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源需要在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。",
      "注意事项": "在修复技术文档时，应优先保留\"必须\"等强制性术语以符合规范要求，避免弱化操作必要性；调整用词需结合上下文语境（如定义性段落）判断，技术规范类文本中强制性表述不宜替换为建议性表达。"
    },
    {
      "defect_id": 542508,
      "sentence": "在DevEco Studio中**New &gt; Create Project**，选择**Native C++**模板，点击**Next**，选择API版本，设置好工程名称，点击**Finish**，创建得到新工程。",
      "reference_sentence": "使用Node-API实现跨语言交互，首先需要按照Node-API的机制实现模块的注册和加载等相关动作。",
      "line_num": 17,
      "context": "{\"12\":\"此处以在ArkTS/JS侧实现add()接口、在Native侧实现Add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。\",\"13\":\"\",\"14\":\"\",\"15\":\"## 创建Native C++工程\",\"16\":\"\",\"17\":\"- 在DevEco Studio中**New &gt; Create Project**，选择**Native C++**模板，点击**Next**，选择API版本，设置好工程名称，点击**Finish**，创建得到新工程。\",\"18\":\"\",\"19\":\"- 创建工程后工程结构可以分两部分，cpp部分和ets部分，工程结构具体介绍可见<!--RP1-->[C++工程目录结构](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-project-structure-V5)<!--RP1End-->。\",\"20\":\"\",\"21\":\"\",\"22\":\"## Native侧方法的实现\"}",
      "用户拒绝的修改": "在DevEco Studio中**New &gt; Create Project**，选择**Native C++**模板，点击**Next**，选择API版本，设置好工程名称，再次点击**Next**，完成新工程的创建。",
      "注意事项": "修复时需严格核对操作界面实际按钮标签及流程顺序，确保步骤描述与实际操作完全一致，避免擅自添加或变更未明确提示的交互动作。"
    },
    {
      "defect_id": 542775,
      "sentence": "cpp部分代码",
      "reference_sentence": "cpp部分代码",
      "line_num": 174,
      "context": "{\"169\":\"\",\"170\":\"#### napi_create_object_with_named_properties\",\"171\":\"\",\"172\":\"用于使用给定的napi_value和键名创建一个ArkTS对象，并且给定的键名必须为string，且不可转为number。\",\"173\":\"\",\"174\":\"cpp部分代码\",\"175\":\"\",\"176\":\"```cpp\",\"177\":\"#include \\\"napi/native_api.h\\\"\",\"178\":\"\",\"179\":\"static napi_value CreateObjectWithNameProperties(napi_env env, napi_callback_info info)\"}",
      "用户拒绝的修改": "C++ 示例代码",
      "注意事项": "修复时应优先检查文档现有术语和格式的一致性，避免擅自替换用户明确指定的统一表述（如\"cpp部分代码\"），即使存在重复也需尊重原始风格；仅在用户允许或存在歧义时提供多样化建议。"
    },
    {
      "defect_id": 542777,
      "sentence": "接口声明",
      "reference_sentence": "接口声明",
      "line_num": 151,
      "context": "{\"146\":\"    }\",\"147\":\"}\",\"148\":\"```\",\"149\":\"<!-- @[node_api_module_create_object_properties](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/cpp/napi_init.cpp) -->\",\"150\":\"\",\"151\":\"接口声明\",\"152\":\"\",\"153\":\"```ts\",\"154\":\"// index.d.ts\",\"155\":\"export const createObjectWithProperties: (data: string) => Object;\",\"156\":\"```\"}",
      "用户拒绝的修改": "接口声明：创建带有属性的对象",
      "注意事项": "在优化重复标题时，需优先确认上下文是否已通过代码示例或注释明确区分内容，避免过度添加冗余描述破坏原句简洁性；若用户明确保留原句，应尊重其文档结构一致性需求而非强制修改。"
    },
    {
      "defect_id": 542495,
      "sentence": "napi_ref是一个Node-API类型，用于管理napi_value的生命周期。napi_ref允许您在napi_value的生命周期内保持对其的引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享napi_value，并确保在不再需要时正确释放其内存。",
      "reference_sentence": "napi_ref是一个Node-API类型，用于管理napi_value的生命周期。napi_ref允许您在napi_value的生命周期内保持对其的引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享napi_value，并确保在不再需要时正确释放其内存。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"napi_value的生命周期与其在ArkTS中的对应值的生命周期紧密相关。当ArkTS值被垃圾回收时，与之关联的napi_value也将不再有效。重要的是不要在ArkTS值不再存在时尝试使用napi_value。\",\"8\":\"\",\"9\":\"框架层的scope通常用于管理napi_value的生命周期。在Node-API中，可以使用napi_open_handle_scope和napi_close_handle_scope函数来创建和销毁scope。通过在scope内创建napi_value，可以确保在scope结束时自动释放napi_value，避免内存泄漏。\",\"10\":\"\",\"11\":\"napi_ref是一个Node-API类型，用于管理napi_value的生命周期。napi_ref允许您在napi_value的生命周期内保持对其的引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享napi_value，并确保在不再需要时正确释放其内存。\",\"12\":\"\",\"13\":\"## 基本概念\",\"14\":\"\",\"15\":\"Node-API提供了一组功能，使开发人员能够在Node-API模块中创建和操作ArkTS对象，管理引用和生命周期，并注册垃圾回收回调函数等。下面是一些基本概念：\",\"16\":\"\"}",
      "用户拒绝的修改": "napi_ref是一个Node-API类型，用于管理napi_value的生命周期。napi_ref允许您在napi_value的生命周期内管理其引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享napi_value，并确保在不再需要时正确释放其内存。",
      "注意事项": "在统一术语前需优先验证技术准确性，确保修改不破坏原有技术含义；保留上下文关键动词（如\"保持引用\"）时需核对领域规范用法，避免过度统一导致语义偏移。"
    },
    {
      "defect_id": 542776,
      "sentence": "cpp部分代码",
      "reference_sentence": "cpp部分代码",
      "line_num": 237,
      "context": "{\"232\":\"\",\"233\":\"#### napi_run_script_path\",\"234\":\"\",\"235\":\"在Node-API模块中运行abc文件。\",\"236\":\"\",\"237\":\"cpp部分代码\",\"238\":\"\",\"239\":\"```cpp\",\"240\":\"#include \\\"napi/native_api.h\\\"\",\"241\":\"\",\"242\":\"static napi_value RunScriptPath(napi_env env, napi_callback_info info)\"}",
      "用户拒绝的修改": "C++ 代码示例",
      "注意事项": "修复时应优先检查上下文现有标题格式，严格遵循用户指定的统一术语（如\"cpp部分代码\"），避免自行替换为同义但格式不同的表述（如\"C++ 代码示例\"），即使存在重复也需以文档一致性为最高优先级。"
    },
    {
      "defect_id": 542774,
      "sentence": "cpp部分代码",
      "reference_sentence": "cpp部分代码",
      "line_num": 125,
      "context": "{\"120\":\"\",\"121\":\"#### napi_create_object_with_properties\",\"122\":\"\",\"123\":\"用给定的napi_property_descriptor作为属性去创建一个ArkTS对象，并且descriptor的键名必须为string，且不可转为number。\",\"124\":\"\",\"125\":\"cpp部分代码\",\"126\":\"\",\"127\":\"```cpp\",\"128\":\"#include \\\"napi/native_api.h\\\"\",\"129\":\"\",\"130\":\"static napi_value CreateObjectWithProperties(napi_env env, napi_callback_info info)\"}",
      "用户拒绝的修改": "C++ 示例代码",
      "注意事项": "修复时应严格遵循用户指定的统一术语（如“cpp部分代码”），避免自行替换为同义变体（如“C++ 示例代码”）；在优化重复标题时需优先确认上下文是否存在强制格式规范，不可仅因重复性而破坏文档术语一致性。"
    },
    {
      "defect_id": 542003,
      "sentence": "调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。",
      "reference_sentence": "无",
      "line_num": 10072,
      "context": "{\"10067\":\"```\",\"10068\":\"ArkUI_ErrorCode OH_ArkUI_DragEvent_SetDataLoadParams(ArkUI_DragEvent* event, OH_UdmfDataLoadParams* dataLoadParams)\",\"10069\":\"```\",\"10070\":\"**描述：**\",\"10071\":\"\",\"10072\":\"调用此方法向系统提供数据加载参数，而非直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用dataLoadParams请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)使用。请参阅[OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create)了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)存在冲突，系统始终以最后调用的方法为准。\",\"10073\":\"\",\"10074\":\"**起始版本：** 20\",\"10075\":\"\",\"10076\":\"**参数**\",\"10077\":\"\"}",
      "用户拒绝的修改": "调用此方法向系统提供数据加载参数，而不是直接传入完整的数据对象。当用户将数据拖拽至目标应用程序并释放时，系统将使用 DataLoadParams 请求数据。这可以显著提高拖拽大量数据及目标应用程序处理释放数据的效率。此方法应始终优先于 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata)。请参阅 [OH_UdmfDataLoadParams_Create](../apis-arkdata/capi-udmf-h.md#oh_udmfdataloadparams_create) 了解如何创建和准备数据加载参数。该方法与 [OH_ArkUI_DragEvent_SetData](#oh_arkui_dragevent_setdata) 存在冲突，系统始终以最后调用的方法为准。",
      "注意事项": "修复时应严格限定修改范围，仅修正用户明确指出的句式/术语不一致问题（如\"而非\"改为\"而不是\"、\"dataLoadParams\"改为\"DataLoadParams\"），避免调整标点间距、超链接格式等无关细节；术语大小写修改需确保上下文统一，若原文存在混合使用情况应优先保持原格式。"
    },
    {
      "defect_id": 542778,
      "sentence": "接口声明",
      "reference_sentence": "接口声明",
      "line_num": 204,
      "context": "{\"199\":\"    return obj;\",\"200\":\"}\",\"201\":\"```\",\"202\":\"<!-- @[node_api_module_create_object_name_properties](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/cpp/napi_init.cpp) -->\",\"203\":\"\",\"204\":\"接口声明\",\"205\":\"\",\"206\":\"```ts\",\"207\":\"// index.d.ts\",\"208\":\"export const createObjectWithNameProperties: (data: string) => string | { name: string };\",\"209\":\"```\"}",
      "用户拒绝的修改": "接口声明：createObjectWithNameProperties",
      "注意事项": "避免机械追加重复标题，应重新设计标题结构确保唯一性（如将通用标题改为具体接口名称作为核心描述）；检查上下文是否存在同类标题重复，优先采用差异化表述而非简单扩展。"
    },
    {
      "defect_id": 542683,
      "sentence": "用给定的napi_property_descriptor作为属性去创建一个ArkTS对象，并且descriptor的键名必须为string，且不可转为number。",
      "reference_sentence": "用于在Node-API模块中使用给定的napi_property_descriptor创建ArkTS Object。descriptor的键名必须为string，且不可转为number。",
      "line_num": 123,
      "context": "{\"118\":\"\",\"119\":\"### 使用示例\",\"120\":\"\",\"121\":\"#### napi_create_object_with_properties\",\"122\":\"\",\"123\":\"用给定的napi_property_descriptor作为属性去创建一个ArkTS对象，并且descriptor的键名必须为string，且不可转为number。\",\"124\":\"\",\"125\":\"cpp部分代码\",\"126\":\"\",\"127\":\"```cpp\",\"128\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "用给定的napi_property_descriptor作为属性去创建一个ArkTS Object，并且descriptor的键名必须为string，且不可转为number。",
      "注意事项": "修复术语一致性时需先确认文档的中英文术语规范，优先保持与上下文已有用法统一（如示例中的\"ArkTS对象\"），若存在项目特定命名规则（如专有名词保留英文形式），需严格遵循既定格式不作中英混用。"
    },
    {
      "defect_id": 542509,
      "sentence": "注：仅需复制以下两行代码，Init在完成创建Native C++工程以后在napi_init.cpp中已配置好。",
      "reference_sentence": "使用Node-API实现跨语言交互，首先需要按照Node-API的机制实现模块的注册和加载等相关动作。",
      "line_num": 62,
      "context": "{\"57\":\"  EXTERN_C_START\",\"58\":\"  // 模块初始化\",\"59\":\"  static napi_value Init(napi_env env, napi_value exports) {\",\"60\":\"      // ArkTS接口与C++接口的绑定和映射\",\"61\":\"      napi_property_descriptor desc[] = {\",\"62\":\"          // 注：仅需复制以下两行代码，Init在完成创建Native C++工程以后在napi_init.cpp中已配置好。\",\"63\":\"          {\\\"callNative\\\", nullptr, CallNative, nullptr, nullptr, nullptr, napi_default, nullptr},\",\"64\":\"          {\\\"nativeCallArkTS\\\", nullptr, NativeCallArkTS, nullptr, nullptr, nullptr, napi_default, nullptr}\",\"65\":\"      };\",\"66\":\"      // 在exports对象上挂载CallNative/NativeCallArkTS两个Native方法\",\"67\":\"      napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\"}",
      "用户拒绝的修改": "注：仅需复制以下两行代码，Init在完成创建Native C++工程以后已在napi_init.cpp中复制好。",
      "注意事项": "修复时需严格核查技术动作的准确性（如\"配置\"涉及参数设置，\"复制\"仅指代码拷贝），优先保持与上下文技术术语的一致性，同时结合代码注释场景判断动词的适用性。"
    },
    {
      "defect_id": 544325,
      "sentence": "参数值应在允许的范围内使用。",
      "reference_sentence": "参数的值超出允许的范围。",
      "line_num": 301,
      "context": "{\"296\":\"\",\"297\":\"3.参数的格式不正确。\",\"298\":\"\",\"299\":\"**处理步骤**\",\"300\":\"\",\"301\":\"1.参数值应在允许的范围内使用。\",\"302\":\"\",\"303\":\"2.参数允许的长度。\",\"304\":\"\",\"305\":\"3.参数使用正确的格式。\",\"306\":\"\"}",
      "用户拒绝的修改": "参数的值应在允许的范围内使用。",
      "注意事项": "优先保留原表达方式的简洁性，仅在存在实际歧义风险或上下文明显不统一时调整用词，避免过度追求语法结构统一而牺牲自然表达。"
    },
    {
      "defect_id": 544327,
      "sentence": "1.启动闪控球时参数有误。",
      "reference_sentence": "1.传入参数有误。",
      "line_num": 319,
      "context": "{\"314\":\"\",\"315\":\"创建闪控球窗口失败。\",\"316\":\"\",\"317\":\"**可能原因**\",\"318\":\"\",\"319\":\"1.启动闪控球时参数有误。\",\"320\":\"\",\"321\":\"2.在不支持的设备上启动闪控球。\",\"322\":\"\",\"323\":\"3.应用在后台时启动闪控球。\",\"324\":\"\"}",
      "用户拒绝的修改": "1.传入参数有误。",
      "注意事项": "保持文档已有术语一致性，优先沿用上下文中的核心动词（如\"启动闪控球\"）；在无歧义且不影响技术准确性的情况下，避免对同一概念进行不必要的同义替换。"
    },
    {
      "defect_id": 543053,
      "sentence": "在ArkTS编程中，异常和错误是常见的概念。异常表示发生了某种意外情况，而错误则指示程序无法正确执行某些操作。Node-API提供了一系列方法来帮助开发者在Node-API模块中处理ArkTS中的异常和错误。",
      "reference_sentence": "在ArkTS编程中，异常和错误是常见的概念。异常表示发生了某种意外情况，而错误则指示程序无法正确执行某些操作。Node-API提供了一系列方法来帮助开发者在Node-API模块中处理ArkTS中的异常和错误。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用Node-API接口进行错误处理，使得在Node-API模块中能够更好地管理和响应错误情况。通过合理使用这些函数，可以提高模块的稳定性和可靠性。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在ArkTS编程中，异常和错误是常见的概念。异常表示发生了某种意外情况，而错误则指示程序无法正确执行某些操作。Node-API提供了一系列方法来帮助开发者在Node-API模块中处理ArkTS中的异常和错误。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **异常（Exception）**：在程序执行过程中可能会出现的意外情况，可以是语法错误、运行时错误或逻辑错误，例如除以零或对未定义变量的操作。\",\"12\":\"- **错误（Error）**：表示程序无法顺利执行某些操作，可以是由底层系统、API函数或开发者自定义的。\",\"13\":\"- **类型错误（Type Error）**：表示操作或值的类型不符合预期，通常是由错误的数据类型导致的。\",\"14\":\"- **范围错误（Range Error）**：表示一个值不在预期的范围内，例如对数组长度之外的索引进行访问。\"}",
      "用户拒绝的修改": "在ArkTS编程中，错误是常见的概念。错误表示发生了某种意外情况，而错误则指示程序无法正确执行某些操作。Node-API提供了一系列方法来帮助开发者在Node-API模块中处理ArkTS中的错误。",
      "注意事项": "在统一术语前必须核查上下文中的技术定义，若原文已明确区分\"异常\"和\"错误\"为独立概念，应保留术语差异并确保定义描述与术语使用严格对应，避免因过度统一导致技术概念混淆。"
    },
    {
      "defect_id": 545602,
      "sentence": "| 1300021 | Failed to start multiple floating Ball windows. |",
      "reference_sentence": "| 1300023 | Floating ball internal error. |",
      "line_num": 138,
      "context": "{\"133\":\"| 错误码ID | 错误信息 |\",\"134\":\"|------------|------------|\",\"135\":\"| 201 | Permission verification failed, usually returned by VerifyAccessToken. |\",\"136\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"137\":\"| 1300020 | Failed to create the floating Ball window. |\",\"138\":\"| 1300021 | Failed to start multiple floating Ball windows. |\",\"139\":\"| 1300022 | Repeated floating Ball operation. |\",\"140\":\"| 1300023 | Floating ball internal error. |\",\"141\":\"| 1300024 | The floating ball window state is abnormal. |\",\"142\":\"| 1300025 | The floating ball state does not support this operation. |\",\"143\":\"\"}",
      "用户拒绝的修改": "| 1300021 | Failed to start multiple floating ball windows. |",
      "注意事项": "在修复术语一致性时，需优先确认术语是否属于已评审的专有名词（如API参数/组件名），若上下文存在同一术语混合大写（如Ball/ball）但未被用户标记为错误，应保留原格式而非强制统一。"
    },
    {
      "defect_id": 544331,
      "sentence": "3.仅拉起本应用窗口。",
      "reference_sentence": "3.拉起非本应用的窗口。",
      "line_num": 471,
      "context": "{\"466\":\"\",\"467\":\"1.检查应用窗口的拉起参数。\",\"468\":\"\",\"469\":\"2.点击后5秒内启动应用窗口。\",\"470\":\"\",\"471\":\"3.仅拉起本应用窗口。\",\"472\":\"\",\"473\":\"## 1300027 更新闪控球时不能改变模板类型\",\"474\":\"\",\"475\":\"**错误信息**\",\"476\":\"\"}",
      "用户拒绝的修改": "3.只拉起本应用窗口。",
      "注意事项": "仅在用词不一致可能导致歧义时调整表述，优先保持用户文档已有术语习惯；避免机械替换同义词，需结合上下文判断是否存在实际表达冲突。"
    },
    {
      "defect_id": 544326,
      "sentence": "参数允许的长度。",
      "reference_sentence": "参数的长度超出允许的长度。",
      "line_num": 303,
      "context": "{\"298\":\"\",\"299\":\"**处理步骤**\",\"300\":\"\",\"301\":\"1.参数值应在允许的范围内使用。\",\"302\":\"\",\"303\":\"2.参数允许的长度。\",\"304\":\"\",\"305\":\"3.参数使用正确的格式。\",\"306\":\"\",\"307\":\"## 1300020 创建闪控球窗口失败\",\"308\":\"\"}",
      "用户拒绝的修改": "参数的允许长度。",
      "注意事项": "优先保持原文结构一致性，仅在存在实际歧义或语法错误时调整语序；修改前需核对上下文同类表述方式，避免过度纠正无实质影响的一致性差异。"
    },
    {
      "defect_id": 545601,
      "sentence": "| 1300020 | Failed to create the floating Ball window. |",
      "reference_sentence": "| 1300023 | Floating ball internal error. |",
      "line_num": 137,
      "context": "{\"132\":\"\",\"133\":\"| 错误码ID | 错误信息 |\",\"134\":\"|------------|------------|\",\"135\":\"| 201 | Permission verification failed, usually returned by VerifyAccessToken. |\",\"136\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"137\":\"| 1300020 | Failed to create the floating Ball window. |\",\"138\":\"| 1300021 | Failed to start multiple floating Ball windows. |\",\"139\":\"| 1300022 | Repeated floating Ball operation. |\",\"140\":\"| 1300023 | Floating ball internal error. |\",\"141\":\"| 1300024 | The floating ball window state is abnormal. |\",\"142\":\"| 1300025 | The floating ball state does not support this operation. |\"}",
      "用户拒绝的修改": "| 1300020 | Failed to create the floating ball window. |",
      "注意事项": "修复前需确认术语是否存在特殊大小写约定（如专有名词或技术术语），若用户已明确评审通过英文内容，应优先保留原格式不作修改。"
    },
    {
      "defect_id": 546113,
      "sentence": "缩放停止时触发。",
      "reference_sentence": "每帧缩放完成时触发。",
      "line_num": 552,
      "context": "{\"547\":\"\",\"548\":\"### onZoomStop<sup>20+</sup>\",\"549\":\"\",\"550\":\"onZoomStop(event: VoidCallback)\",\"551\":\"\",\"552\":\"缩放停止时触发。\",\"553\":\"\",\"554\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"555\":\"\",\"556\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"557\":\"\"}",
      "用户拒绝的修改": "缩放完成时触发。",
      "注意事项": "严格遵循接口设计中的术语一致性，优先使用接口名称（如\"onZoomStop\"）中的核心动词\"stop\"对应表述，避免引入未经验证的同义词替换（如\"完成\"）；修复时需同时检查参数命名、方法名称等上下文技术要素的语义关联性。"
    },
    {
      "defect_id": 545603,
      "sentence": "| 1300022 | Repeated floating Ball operation. |",
      "reference_sentence": "| 1300023 | Floating ball internal error. |",
      "line_num": 139,
      "context": "{\"134\":\"|------------|------------|\",\"135\":\"| 201 | Permission verification failed, usually returned by VerifyAccessToken. |\",\"136\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"137\":\"| 1300020 | Failed to create the floating Ball window. |\",\"138\":\"| 1300021 | Failed to start multiple floating Ball windows. |\",\"139\":\"| 1300022 | Repeated floating Ball operation. |\",\"140\":\"| 1300023 | Floating ball internal error. |\",\"141\":\"| 1300024 | The floating ball window state is abnormal. |\",\"142\":\"| 1300025 | The floating ball state does not support this operation. |\",\"143\":\"\",\"144\":\"**示例：**\"}",
      "用户拒绝的修改": "| 1300022 | Repeated floating ball operation. |",
      "注意事项": "修复前需优先确认文档现有术语格式惯例，若上下文存在已评审的混合使用案例（如\"Ball\"和\"ball\"共存），应保持原文档风格统一而非强制标准化，避免对已通过审核的内容进行不必要修改。"
    },
    {
      "defect_id": 544328,
      "sentence": "3.闪控球未启动时，拉起应用窗口。",
      "reference_sentence": "1.进行更新操作前，检查闪控球是否已启动。",
      "line_num": 433,
      "context": "{\"428\":\"\",\"429\":\"1.在闪控球未启动时进行更新操作。\",\"430\":\"\",\"431\":\"2.闪控球未启动时查询窗口信息。\",\"432\":\"\",\"433\":\"3.闪控球未启动时，拉起应用窗口。\",\"434\":\"\",\"435\":\"4.调用闪控球停止接口，若流程未完成，则启动闪控球。\",\"436\":\"\",\"437\":\"**处理步骤**\",\"438\":\"\"}",
      "用户拒绝的修改": "3.在闪控球未启动时，拉起应用窗口。",
      "注意事项": "修复前需确认上下文是否存在实际混用模式，优先保持同一文档内的句式统一性而非强制添加介词，避免将不同功能模块的表述差异误判为不一致。"
    },
    {
      "defect_id": 548158,
      "sentence": "无挡位能力。",
      "reference_sentence": "无挡位能力。",
      "line_num": 191,
      "context": "{\"186\":\"| onDetentsDidChange | 无挡位能力。|\",\"187\":\"| showClose       | 不支持显示关闭按钮。 |\",\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\",\"192\":\"| keyboardAvoidMode | 无避让软键盘能力，需自定义避让。 |\",\"193\":\"| enableHoverMode  | 无悬停态避让能力。|\",\"194\":\"| hoverModeArea    | 无悬停态避让能力。|\",\"195\":\"| detentSelection | 无挡位能力。 |\",\"196\":\"| showInSubWindow | 不支持指定显示层级。 |\"}",
      "用户拒绝的修改": "不支持挡位能力。",
      "注意事项": "在统一语言表达时需优先确认用户对特定术语或固定表述的偏好，避免机械替换导致原意偏差；保留必要语境差异，仅在明确冗余或歧义时调整句式结构。"
    },
    {
      "defect_id": 548161,
      "sentence": "无悬停态避让能力。",
      "reference_sentence": "无悬停态避让能力。",
      "line_num": 194,
      "context": "{\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\",\"192\":\"| keyboardAvoidMode | 无避让软键盘能力，需自定义避让。 |\",\"193\":\"| enableHoverMode  | 无悬停态避让能力。|\",\"194\":\"| hoverModeArea    | 无悬停态避让能力。|\",\"195\":\"| detentSelection | 无挡位能力。 |\",\"196\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"197\":\"| radius         | 不支持圆角。  |\",\"198\":\"| borderWidth         | 不支持边框宽度。  |\",\"199\":\"| borderColor         | 不支持边框颜色。  |\"}",
      "用户拒绝的修改": "不支持悬停态避让能力。",
      "注意事项": "修复时应优先保持原文表述结构的一致性，若上下文同类描述均采用\"无...能力\"的否定句式，则不应擅自改为\"不支持...\"句式；修改时需严格对照相邻条目的语法模式，避免因局部优化破坏整体文档的格式统一性。"
    },
    {
      "defect_id": 542804,
      "sentence": "2. 执行命令如es2abc.exe test.js  --output test.abc后便可生成test.abc文件",
      "reference_sentence": "无",
      "line_num": 287,
      "context": "{\"282\":\"<!-- @[ark_node_api_module_run_script_path](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"283\":\"\",\"284\":\"test.js代码，将js代码编成.abc文件，步骤如下：\",\"285\":\"\",\"286\":\"1. 在SDK的ets/build-tools/ets-loader/bin/ark/build-win/bin目录下放置test.js文件\",\"287\":\"2. 执行命令如es2abc.exe test.js  --output test.abc后便可生成test.abc文件\",\"288\":\"\",\"289\":\"放入指定路径中：/entry/resources/rawfile\",\"290\":\"\",\"291\":\"```js\",\"292\":\"function add(a, b) {\"}",
      "用户拒绝的修改": "2. 执行命令如ES2ABC.exe test.js  --output test.abc后便可生成test.abc文件",
      "注意事项": "修复术语一致性时需优先确认实际使用场景中的正确格式（如检查原文件名或上下文引用），避免在无明确参考时擅自修改大小写；技术文档中工具名称应严格遵循官方命名规范而非主观统一格式。"
    },
    {
      "defect_id": 548450,
      "sentence": "给状态管理V2的状态变量删除注册监听方法。具体使用场景见。",
      "reference_sentence": "给状态管理V2的状态变量动态注册监听方法。具体使用场景见。",
      "line_num": 791,
      "context": "{\"786\":\"| MonitorCallback | 参数是[IMonitor](./arkui-ts/ts-state-management-watch-monitor.md#imonitor12)的监听回调函数。 |\",\"787\":\"\",\"788\":\"### clearMonitor<sup>20+</sup>\",\"789\":\"static clearMonitor(target: object, path: string | string[], monitorCallback?: MonitorCallback): void;\",\"790\":\"\",\"791\":\"给状态管理V2的状态变量删除注册监听方法。具体使用场景见。\",\"792\":\"\",\"793\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"794\":\"\",\"795\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"796\":\"\"}",
      "用户拒绝的修改": "删除状态管理V2的状态变量的注册监听方法。具体使用场景见。",
      "注意事项": "修复时应确保动词逻辑一致性，避免同时保留矛盾动作描述（如\"删除注册\"），优先参考上下文已有正确表述（如\"动态注册\"）进行动词选择与搭配。"
    },
    {
      "defect_id": 542781,
      "sentence": "ArkTS侧示例代码",
      "reference_sentence": "ArkTS侧示例代码",
      "line_num": 212,
      "context": "{\"207\":\"// index.d.ts\",\"208\":\"export const createObjectWithNameProperties: (data: string) => string | { name: string };\",\"209\":\"```\",\"210\":\"<!-- @[node_api_module_create_object_name_properties_api](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/cpp/types/libentry/Index.d.ts) -->\",\"211\":\"\",\"212\":\"ArkTS侧示例代码\",\"213\":\"\",\"214\":\"```ts\",\"215\":\"import hilog from '@ohos.hilog';\",\"216\":\"import testNapi from 'libentry.so';\",\"217\":\"\"}",
      "用户拒绝的修改": "ArkTS侧示例代码：创建具有名称属性的对象",
      "注意事项": "在补充描述前需检查上下文是否存在重复标题，确保新增内容提供明确的信息增量（如功能、参数或场景），避免冗余修饰。"
    },
    {
      "defect_id": 548157,
      "sentence": "无挡位能力。",
      "reference_sentence": "无挡位能力。",
      "line_num": 186,
      "context": "{\"181\":\"| --------------- |  --------------- |\",\"182\":\"| height          | 高度只支持全屏高度。 |\",\"183\":\"| width           | 宽度只支持全屏宽度。 |\",\"184\":\"| detents | 无挡位能力。|\",\"185\":\"| dragBar         | 不支持拖动条。  |\",\"186\":\"| onDetentsDidChange | 无挡位能力。|\",\"187\":\"| showClose       | 不支持显示关闭按钮。 |\",\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\"}",
      "用户拒绝的修改": "不支持挡位能力。",
      "注意事项": "修复时应优先保留用户指定的原文表达方式，仅在表意不清或逻辑矛盾时调整术语，并明确标注修改必要性以避免过度纠正。"
    },
    {
      "defect_id": 542779,
      "sentence": "接口声明",
      "reference_sentence": "接口声明",
      "line_num": 261,
      "context": "{\"256\":\"    return returnValue;\",\"257\":\"}\",\"258\":\"```\",\"259\":\"<!-- @[node_api_module_run_script_path](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/cpp/napi_init.cpp) -->\",\"260\":\"\",\"261\":\"接口声明\",\"262\":\"\",\"263\":\"```ts\",\"264\":\"// index.d.ts\",\"265\":\"export const runScriptPath: () => boolean;\",\"266\":\"```\"}",
      "用户拒绝的修改": "接口声明：runScriptPath",
      "注意事项": "修复时应避免重复使用相同标题，优先采用子标题或具体上下文区分（如“接口声明：runScriptPath”改为“runScriptPath接口声明”），并检查相邻段落的结构连贯性。"
    },
    {
      "defect_id": 548451,
      "sentence": "删除对应的状态变量注册监听函数，即path路径对应的状态变量改变时，会回调对应的函数。",
      "reference_sentence": "给对应的状态变量注册监听函数，即path路径对应的状态变量改变时，会回调对应的函数。",
      "line_num": 803,
      "context": "{\"798\":\"\",\"799\":\"| 参数名 | 类型 | 必填 | 说明     |\",\"800\":\"| ------ | ---- | ---- | ------------ |\",\"801\":\"| target | object | 是   | 目标对象，仅支持[\\\\@ComponentV2](../../ui/state-management/arkts-new-componentV2.md)和[\\\\@ObservedV2](../../ui/state-management/arkts-new-observedV2-and-trace.md)实例。</br>对于不支持的类型，会抛出运行时错误，对应[错误码](#错误码)见表格。 |\",\"802\":\"| path | string或string[]   | 是   | 删除监听的变量名路径。可指定一个路径或者传入string数组用于一次性指定删除多个状态变量的监听函数。</br>仅支持string和string数组,对于不支持的类型，会抛出运行时错误，对应[错误码](#错误码)见表格。 |\",\"803\":\"| monitorCallback | [MonitorCallback](#monitorcallback20)   | 否   | 删除对应的状态变量注册监听函数，即path路径对应的状态变量改变时，会回调对应的函数。</br>当开发者不传当前参数时，删除对应path变量注册的所有监听函数。</br>对于不支持的类型，会抛出运行时错误，对应[错误码](#错误码)见表格。 |\",\"804\":\"\",\"805\":\"**错误码：**\",\"806\":\"| 错误码ID | 错误信息 |\",\"807\":\"| ------- | -------------------------------- |\",\"808\":\"|130000|target不是\\\\@ObservedV2装饰的class且该class至少有一个\\\\@Trace装饰的变量，或者不是\\\\@ComponentV2装饰的自定义组件的实例。|\"}",
      "用户拒绝的修改": "删除对应的状态变量监听函数，即path路径对应的状态变量改变时，会回调对应的函数。",
      "注意事项": "确保动词与操作行为的严格对应（如\"删除\"对应\"监听函数\"而非\"注册监听函数\"），并在修改时同步检查上下文所有关联术语的一致性（如参数说明中的\"删除监听的变量名路径\"需与功能描述保持统一）。"
    },
    {
      "defect_id": 542805,
      "sentence": "将异步工作对象加到队列，由底层根据传入的qos优先级去调度执行。",
      "reference_sentence": "用于将异步工作对象加入队列，让开发者能够根据QoS优先级来管理和调度异步工作的执行，从而更好地满足程序的性能和响应需求。",
      "line_num": 310,
      "context": "{\"305\":\"\",\"306\":\"### 使用示例\",\"307\":\"\",\"308\":\"#### napi_queue_async_work_with_qos\",\"309\":\"\",\"310\":\"将异步工作对象加到队列，由底层根据传入的qos优先级去调度执行。\",\"311\":\"\",\"312\":\"<!--Del-->\",\"313\":\"[指定异步任务调度优先级](../performance/develop-Native-modules-using-NAPI-safely-and-efficiently.md#指定异步任务调度优先级)\",\"314\":\"<!--DelEnd-->\",\"315\":\"\"}",
      "用户拒绝的修改": "将异步工作对象加入队列，由底层根据传入的QoS优先级去调度执行。",
      "注意事项": "修复术语不一致时应先检查上下文是否存在已规范化的统一表述，避免因局部修正导致重复；同时需核对用户提供的参考句式和文档结构，确保修改后的内容既保持术语统一性又符合整体文档的信息密度要求。"
    },
    {
      "defect_id": 542880,
      "sentence": "使用给定的napi_property_descriptor创建一个sendable对象。",
      "reference_sentence": "创建一个sendable对象。",
      "line_num": 925,
      "context": "{\"920\":\"```\",\"921\":\"<!-- @[ark_napi_define_sendable_class](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"922\":\"\",\"923\":\"#### napi_create_sendable_object_with_properties\",\"924\":\"\",\"925\":\"使用给定的napi_property_descriptor创建一个sendable对象。\",\"926\":\"\",\"927\":\"cpp部分代码\",\"928\":\"\",\"929\":\"```cpp\",\"930\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "使用给定的napi_property_descriptor创建一个可发送对象。",
      "注意事项": "修复术语不一致时必须优先检查上下文中的已有表述，若参考句子或邻近段落已明确使用特定术语（如\"sendable对象\"），应严格保持全文字面统一，避免引入同义词或翻译变体导致隐性重复。"
    },
    {
      "defect_id": 548162,
      "sentence": "无避让软键盘能力，需自定义避让。",
      "reference_sentence": "默认不避让软键盘，需自定义避让软键盘。",
      "line_num": 193,
      "context": "{\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\",\"192\":\"| keyboardAvoidMode | 无避让软键盘能力，需自定义避让。 |\",\"193\":\"| enableHoverMode  | 无悬停态避让能力。|\",\"194\":\"| hoverModeArea    | 无悬停态避让能力。|\",\"195\":\"| detentSelection | 无挡位能力。 |\",\"196\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"197\":\"| radius         | 不支持圆角。  |\",\"198\":\"| borderWidth         | 不支持边框宽度。  |\"}",
      "用户拒绝的修改": "不支持避让软键盘，需自定义避让。",
      "注意事项": "修复时应优先保留原文句式结构和术语习惯，仅在用户明确要求或存在歧义时进行表达统一，避免过度纠正与上下文风格一致的描述方式。"
    },
    {
      "defect_id": 542836,
      "sentence": "第四个参数clone_list是存放需要克隆传递的Sendable对象的array，如不涉及可传undefined；",
      "reference_sentence": "第四个参数clone_list是存放需要克隆传递的Sendable对象的array，如不涉及可传undefined；",
      "line_num": 673,
      "context": "{\"668\":\"\",\"669\":\"### 接口描述\",\"670\":\"\",\"671\":\"| 接口 | 描述 |\",\"672\":\"| -------- | -------- |\",\"673\":\"| napi_serialize | 将ArkTS对象转换为native数据。第一个参数env是接口执行的ArkTS环境；第二个参数object是待序列化的ArkTS对象；第三个参数transfer_list是存放需要以transfer传递的arrayBuffer的array，如不涉及可传undefined；第四个参数clone_list是存放需要克隆传递的Sendable对象的array，如不涉及可传undefined；第五个参数result是序列化结果。 |\",\"674\":\"| napi_deserialize | 将native数据转为ArkTS对象。第一个参数env是接口执行的ArkTS环境；第二个参数buffer是序列化数据；第三个参数object是反序列化得到的结果。 |\",\"675\":\"| napi_delete_serialization_data | 删除序列化数据。 |\",\"676\":\"\",\"677\":\"### 使用示例\",\"678\":\"\"}",
      "用户拒绝的修改": "第四个参数clone_list是存放需要传递克隆的Sendable对象的array，如不涉及可传undefined；",
      "注意事项": "修复时应优先检查上下文已有术语的使用模式（如\"transfer传递\"对应\"克隆传递\"），保持技术动作描述的结构一致性，避免机械调整词序破坏原有专业表达习惯。"
    },
    {
      "defect_id": 548155,
      "sentence": "无挡位能力。",
      "reference_sentence": "无挡位能力。",
      "line_num": 184,
      "context": "{\"179\":\"**bindSheet全屏模态样式不支持的接口**\",\"180\":\"| 名称             | 说明              |\",\"181\":\"| --------------- |  --------------- |\",\"182\":\"| height          | 高度只支持全屏高度。 |\",\"183\":\"| width           | 宽度只支持全屏宽度。 |\",\"184\":\"| detents | 无挡位能力。|\",\"185\":\"| dragBar         | 不支持拖动条。  |\",\"186\":\"| onDetentsDidChange | 无挡位能力。|\",\"187\":\"| showClose       | 不支持显示关闭按钮。 |\",\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\"}",
      "用户拒绝的修改": "不支持挡位能力。",
      "注意事项": "在确保语言一致性时需优先保留原句核心表达，仅修改格式问题；若需调整术语或结构，必须明确确认上下文是否存在统一标准或用户特殊要求。"
    },
    {
      "defect_id": 548163,
      "sentence": "不支持设置是否允许交互。",
      "reference_sentence": "不支持设置是否允许交互。",
      "line_num": 203,
      "context": "{\"198\":\"| borderWidth         | 不支持边框宽度。  |\",\"199\":\"| borderColor         | 不支持边框颜色。  |\",\"200\":\"| borderStyle         | 不支持边框样式。  |\",\"201\":\"| shadow         | 不支持阴影。  |\",\"202\":\"| maskColor      | 不支持蒙层颜色。  |\",\"203\":\"| enableOutsideInteractive | 不支持设置是否允许交互。  |\",\"204\":\"| effectEdge     | 不支持边缘回弹效果。  |\",\"205\":\"| enableFloatingDragBar | 不支持浮动拖动条。  |\",\"206\":\"| onWillSpringBackWhenDismiss | 无回弹效果。  |\",\"207\":\"\",\"208\":\"## SheetDismiss<sup>11+</sup>\"}",
      "用户拒绝的修改": "不支持设置外部交互。",
      "注意事项": "修复时应严格区分格式调整与内容修改，在用户明确要求保留原意时仅处理指定格式问题；涉及术语统一需先验证上下文一致性，避免擅自替换核心表述导致语义偏差。"
    },
    {
      "defect_id": 548160,
      "sentence": "无悬停态避让能力。",
      "reference_sentence": "无悬停态避让能力。",
      "line_num": 193,
      "context": "{\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\",\"192\":\"| keyboardAvoidMode | 无避让软键盘能力，需自定义避让。 |\",\"193\":\"| enableHoverMode  | 无悬停态避让能力。|\",\"194\":\"| hoverModeArea    | 无悬停态避让能力。|\",\"195\":\"| detentSelection | 无挡位能力。 |\",\"196\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"197\":\"| radius         | 不支持圆角。  |\",\"198\":\"| borderWidth         | 不支持边框宽度。  |\"}",
      "用户拒绝的修改": "不支持悬停态避让能力。",
      "注意事项": "修复时应优先保留原文核心表述结构，仅在必要时调整冗余信息；需严格检查相邻条目表述模式，确保局部一致性高于全局统一性（如上下文存在\"无...能力\"高频表述时不得强行替换为\"不支持...\"结构）。\n\n具体依据：用户拒绝的根本原因是LLM破坏了上下文局部一致性（问题条目193/194均使用\"无悬停态避让能力\"），而相邻属性如191/192/195均采用\"无...能力\"结构，LLM错误地采用其他条目中的\"不支持...\"结构进行全局统一，忽视了上下文特定区块的表述惯例。正确的做法应是识别当前属性区块（191-195行）特有的\"无X能力\"表述范式，保持该区块内部表述统一。"
    },
    {
      "defect_id": 548164,
      "sentence": "无回弹效果。",
      "reference_sentence": "无回弹效果。",
      "line_num": 206,
      "context": "{\"201\":\"| shadow         | 不支持阴影。  |\",\"202\":\"| maskColor      | 不支持蒙层颜色。  |\",\"203\":\"| enableOutsideInteractive | 不支持设置是否允许交互。  |\",\"204\":\"| effectEdge     | 不支持边缘回弹效果。  |\",\"205\":\"| enableFloatingDragBar | 不支持浮动拖动条。  |\",\"206\":\"| onWillSpringBackWhenDismiss | 无回弹效果。  |\",\"207\":\"\",\"208\":\"## SheetDismiss<sup>11+</sup>\",\"209\":\"\",\"210\":\"控制半模态的关闭。\",\"211\":\"\"}",
      "用户拒绝的修改": "不支持回弹效果。",
      "注意事项": "修复时应严格区分格式调整与内容修改需求，若用户仅要求删除超链接则不得擅自变更原文表述；统一语言风格前需全面分析上下文逻辑，确认\"不支持\"与\"无\"在具体语境中的功能差异及用户隐性偏好。"
    },
    {
      "defect_id": 542868,
      "sentence": "创建一个sendable类。",
      "reference_sentence": "napi_define_sendable_class | 创建一个sendable类。",
      "line_num": 823,
      "context": "{\"818\":\"```\",\"819\":\"<!-- @[ark_napi_is_sendable](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"820\":\"\",\"821\":\"#### napi_define_sendable_class\",\"822\":\"\",\"823\":\"创建一个sendable类。\",\"824\":\"\",\"825\":\"cpp部分代码\",\"826\":\"\",\"827\":\"```cpp\",\"828\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "创建一个可发送的类。",
      "注意事项": "修复时应严格遵循上下文中的术语一致性，优先保留原文中的专用名词或接口名称，避免过度本地化翻译导致与现有技术文档或代码示例不统一；修改前需核对关联的接口描述表、函数名及代码上下文，确保技术术语表述方式完全匹配。"
    },
    {
      "defect_id": 548159,
      "sentence": "无挡位能力。",
      "reference_sentence": "无挡位能力。",
      "line_num": 195,
      "context": "{\"190\":\"| mode | 不支持指定显示层级。 |\",\"191\":\"| scrollSizeMode | 无挡位能力。  |\",\"192\":\"| keyboardAvoidMode | 无避让软键盘能力，需自定义避让。 |\",\"193\":\"| enableHoverMode  | 无悬停态避让能力。|\",\"194\":\"| hoverModeArea    | 无悬停态避让能力。|\",\"195\":\"| detentSelection | 无挡位能力。 |\",\"196\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"197\":\"| radius         | 不支持圆角。  |\",\"198\":\"| borderWidth         | 不支持边框宽度。  |\",\"199\":\"| borderColor         | 不支持边框颜色。  |\",\"200\":\"| borderStyle         | 不支持边框样式。  |\"}",
      "用户拒绝的修改": "不支持挡位能力。",
      "注意事项": "修复时应优先识别并沿用上下文相邻条目的固定表达结构（如\"无...能力\"），仅在确认全局统一需求时再调整句式，避免破坏原有局部一致性风格。"
    },
    {
      "defect_id": 542780,
      "sentence": "ArkTS侧示例代码",
      "reference_sentence": "ArkTS侧示例代码",
      "line_num": 159,
      "context": "{\"154\":\"// index.d.ts\",\"155\":\"export const createObjectWithProperties: (data: string) => Object;\",\"156\":\"```\",\"157\":\"<!-- @[node_api_module_create_object_properties_api](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/cpp/types/libentry/Index.d.ts) -->\",\"158\":\"\",\"159\":\"ArkTS侧示例代码\",\"160\":\"\",\"161\":\"```ts\",\"162\":\"import hilog from '@ohos.hilog';\",\"163\":\"import testNapi from 'libentry.so';\",\"164\":\"\"}",
      "用户拒绝的修改": "ArkTS 侧示例代码：创建具有属性的对象",
      "注意事项": "修复时应优先保留原句核心信息，仅在重复标题确实导致混淆时补充必要上下文，避免过度添加冗余描述破坏原有简洁性。"
    },
    {
      "defect_id": 547690,
      "sentence": "1. 打开命令行窗口1，关闭SELinux。",
      "reference_sentence": "6. 在命令行窗口1，输入一个int类型的数。",
      "line_num": 344,
      "context": "{\"339\":\"编译：\",\"340\":\"```bash\",\"341\":\"<clang distribution>/bin/clang++ --target=aarch64-linux-ohos --sysroot=<sysroot distribution> -g hello.cpp -o a.out\",\"342\":\"```\",\"343\":\"\",\"344\":\"1. 打开命令行窗口1，关闭SELinux。\",\"345\":\"   ```shell\",\"346\":\"   hdc shell setenforce 0\",\"347\":\"   ```\",\"348\":\"\",\"349\":\"2. 打开命令行窗口1，将lldb-server和可执行文件a.out推送到设备。（a.out是使用clang编译器编译hello.cpp生成的。）\"}",
      "用户拒绝的修改": "1. 在命令行窗口1中，关闭SELinux。",
      "注意事项": "修复时应严格遵循文档现有术语和结构模式，优先保持上下文动词/介词使用一致性（如\"打开窗口，执行操作\"的固定搭配），避免仅根据语法正确性修改已统一的操作指引格式。"
    },
    {
      "defect_id": 548156,
      "sentence": "不支持拖动条。",
      "reference_sentence": "不支持DragBar。",
      "line_num": 185,
      "context": "{\"180\":\"| 名称             | 说明              |\",\"181\":\"| --------------- |  --------------- |\",\"182\":\"| height          | 高度只支持全屏高度。 |\",\"183\":\"| width           | 宽度只支持全屏宽度。 |\",\"184\":\"| detents | 无挡位能力。|\",\"185\":\"| dragBar         | 不支持拖动条。  |\",\"186\":\"| onDetentsDidChange | 无挡位能力。|\",\"187\":\"| showClose       | 不支持显示关闭按钮。 |\",\"188\":\"| title          | 不支持显示标题栏。 |\",\"189\":\"| uiContext | 不支持指定显示层级。|\",\"190\":\"| mode | 不支持指定显示层级。 |\"}",
      "用户拒绝的修改": "不支持拖动条（dragBar）。",
      "注意事项": "修复术语一致性时必须先核对上下文已有术语的使用习惯，优先沿用原文表达方式；若用户明确要求“仅修改指定部分”，禁止添加额外注释或调整超出范围的表述。"
    },
    {
      "defect_id": 542806,
      "sentence": "用于给ArkTS Object绑定回调和回调所需的参数，给ArkTS Object携带Native信息。",
      "reference_sentence": "用于给ArkTS对象绑定回调和回调所需的参数，其作用是为了给ArkTS对象携带Native信息。",
      "line_num": 328,
      "context": "{\"323\":\"\",\"324\":\"### 使用示例\",\"325\":\"\",\"326\":\"#### napi_coerce_to_native_binding_object\",\"327\":\"\",\"328\":\"用于给ArkTS Object绑定回调和回调所需的参数，给ArkTS Object携带Native信息。\",\"329\":\"\",\"330\":\"cpp部分代码\",\"331\":\"\",\"332\":\"```cpp\",\"333\":\"#include <bits/alltypes.h>\"}",
      "用户拒绝的修改": "用于给ArkTS 对象绑定回调和回调所需的参数，给ArkTS 对象携带Native信息。",
      "注意事项": "在修复术语一致性时，需同步检查上下文技术细节（如\"Native\"是否需补充\"层\"）和句子逻辑完整性（如添加\"能够\"明确功能目的），避免仅机械替换词汇而忽略语义连贯性。"
    },
    {
      "defect_id": 549519,
      "sentence": "超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。",
      "reference_sentence": "超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。",
      "line_num": 9215,
      "context": "{\"9210\":\"获取页面首屏加载预测信息（详细说明见[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)），并开始本次加载过渡帧生成，应用根据此信息确定是否需要启用无白屏加载。必须与[setBlanklessLoadingWithKey](#setblanklessloadingwithkey20)接口配套使用，并且必须在触发加载页面的接口之前或在 `onLoadIntercept` 中调用。需在 `WebViewController` 与Web组件绑定后才能使用。\",\"9211\":\"\",\"9212\":\"> **说明：**\",\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\"}",
      "用户拒绝的修改": "超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的机制）更新缓存。",
      "注意事项": "修复时应严格区分技术术语的适用场景，\"策略\"侧重算法逻辑选择，而\"机制\"强调系统运行原理，需结合上下文判断术语是否构成重复描述；若原文存在并列术语（如\"策略机制\"），禁止擅自拆分统一，应保留原文结构完整性。"
    },
    {
      "defect_id": 542933,
      "sentence": "包裹一个native实例到ArkTS对象中并指定大小。",
      "reference_sentence": "包裹一个native实例到ArkTS对象中。",
      "line_num": 1166,
      "context": "{\"1161\":\"```\",\"1162\":\"<!-- @[ark_napi_wrap_sendable](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"1163\":\"\",\"1164\":\"#### napi_wrap_sendable_with_size\",\"1165\":\"\",\"1166\":\"包裹一个native实例到ArkTS对象中并指定大小。\",\"1167\":\"\",\"1168\":\"cpp部分代码\",\"1169\":\"\",\"1170\":\"```cpp\",\"1171\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "将一个native实例包装到ArkTS对象中并指定大小。",
      "注意事项": "修复时应优先保持原文中已确立的术语一致性（如\"包裹\"），避免替换为近义词（如\"包装\"），需结合上下文参考句和用户技术场景判断术语的固定用法。"
    },
    {
      "defect_id": 542932,
      "sentence": "#### napi_wrap_sendable_with_size",
      "reference_sentence": "#### napi_wrap_sendable包裹一个native实例到ArkTS对象中。",
      "line_num": 1164,
      "context": "{\"1159\":\"\",\"1160\":\"testNapi.wrapSendable();\",\"1161\":\"```\",\"1162\":\"<!-- @[ark_napi_wrap_sendable](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"1163\":\"\",\"1164\":\"#### napi_wrap_sendable_with_size\",\"1165\":\"\",\"1166\":\"包裹一个native实例到ArkTS对象中并指定大小。\",\"1167\":\"\",\"1168\":\"cpp部分代码\",\"1169\":\"\"}",
      "用户拒绝的修改": "#### napi_wrap_sendable_with_size (包裹一个native实例到ArkTS对象中并指定大小)",
      "注意事项": "修复时需严格保持标题结构一致性，避免在函数名称后添加括号解释（应保持与上下文其他标题相同的纯函数名格式），所有功能描述统一移至标题下方段落进行说明。"
    },
    {
      "defect_id": 542881,
      "sentence": "创建一个指定长度的sendable数组。",
      "reference_sentence": "创建一个sendable数组。",
      "line_num": 1002,
      "context": "{\"997\":\"```\",\"998\":\"<!-- @[ark_napi_create_sendable_array](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"999\":\"\",\"1000\":\"#### napi_create_sendable_array_with_length\",\"1001\":\"\",\"1002\":\"创建一个指定长度的sendable数组。\",\"1003\":\"\",\"1004\":\"cpp部分代码\",\"1005\":\"\",\"1006\":\"```cpp\",\"1007\":\"static napi_value GetSendableArrayWithLength(napi_env env, napi_callback_info info) {\"}",
      "用户拒绝的修改": "创建一个指定长度的可发送数组。",
      "注意事项": "修复时应优先保留原文术语（如\"sendable\"），避免擅自翻译导致上下文用词割裂；修改前需全面检查问题句子所在段落及关联上下文，确保与已有命名（如接口名称napi_create_sendable_array_with_length）保持严格一致。"
    },
    {
      "defect_id": 549522,
      "sentence": "启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。",
      "reference_sentence": "启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。",
      "line_num": 9218,
      "context": "{\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9221\":\"\",\"9222\":\"**参数：**\",\"9223\":\"\"}",
      "用户拒绝的修改": "使用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。",
      "注意事项": "保持原文动词的准确性，特别是在技术文档中涉及功能开关的语境下，\"启用\"和\"使用\"具有明确的动作指向差异；需结合上下文判断术语一致性，避免将技术场景中的特定动词替换为通用动词。"
    },
    {
      "defect_id": 542899,
      "sentence": "#### napi_create_sendable_arraybuffer",
      "reference_sentence": "#### napi_create_sendable_object_with_properties",
      "line_num": 1034,
      "context": "{\"1029\":\"let value = testNapi.getSendableArrayWithLength();\",\"1030\":\"hilog.info(0x0000, 'testTag', 'Node-API napi_create_sendable_array_with_length: %{public}s', JSON.stringify(value.length));\",\"1031\":\"```\",\"1032\":\"<!-- @[ark_napi_create_sendable_array_with_length](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"1033\":\"\",\"1034\":\"#### napi_create_sendable_arraybuffer\",\"1035\":\"\",\"1036\":\"创建一个sendable ArrayBuffer。\",\"1037\":\"\",\"1038\":\"cpp部分代码\",\"1039\":\"\"}",
      "用户拒绝的修改": "#### napi_create_sendable_ArrayBuffer",
      "注意事项": "修复术语不一致前需确认是否为项目专用术语或固定标签，优先保留用户明确标注\"TAG不修改\"的原始格式，避免对API名称/代码标识符进行语法规范化修改。"
    },
    {
      "defect_id": 542900,
      "sentence": "创建一个sendable TypedArray。",
      "reference_sentence": "创建一个sendable对象。",
      "line_num": 1077,
      "context": "{\"1072\":\"```\",\"1073\":\"<!-- @[ark_napi_create_sendable_arraybuffer](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"1074\":\"\",\"1075\":\"#### napi_create_sendable_typedarray\",\"1076\":\"\",\"1077\":\"创建一个sendable TypedArray。\",\"1078\":\"\",\"1079\":\"cpp部分代码\",\"1080\":\"\",\"1081\":\"```cpp\",\"1082\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "创建一个可发送的 TypedArray。",
      "注意事项": "修复术语不一致时必须同时检查上下文中的大小写规范和技术文档惯例，确保术语翻译和格式在全文范围内保持统一，特别注意参考句例中的处理方式。"
    },
    {
      "defect_id": 549443,
      "sentence": "normal: 正常停止。",
      "reference_sentence": "该接口异步处理请求，即该接口只是发起创建会话，并不会等到会话资源分配完成、模型加载完成才返回。",
      "line_num": 142,
      "context": "{\"137\":\"    * \\\"message\\\": 回复消息，包含以下字段：\",\"138\":\"        * \\\"role\\\": string. 消息的角色类型，应为\\\"assistant\\\"。\",\"139\":\"        * \\\"content\\\": string. 消息内容。\",\"140\":\"    * \\\"finish_reason\\\": string or null. 停止原因，可能的值如下：\",\"141\":\"        * null: 表示没有停止。流式推理中会有多次回复，只有最后一次回复有非空的\\\"finish_reason\\\"。而非流式推理只有一次回复，且\\\"finish_reason\\\"非空。\",\"142\":\"        * \\\"stop\\\": 正常停止。\",\"143\":\"        * \\\"abort\\\": 用户主动提前中止。\",\"144\":\"        * \\\"length\\\": token数超过限制。\",\"145\":\"\",\"146\":\"##### 返回值\",\"147\":\"\"}",
      "用户拒绝的修改": "normal: 正常完成。",
      "注意事项": "修复时必须严格检查上下文术语一致性，优先沿用已有表述（如\"停止\"），禁止擅自替换近义词；技术文档应保持术语单一性，避免同义词混用导致歧义。"
    },
    {
      "defect_id": 549442,
      "sentence": "* `const char* response`参数是回复的json字符串，包含以下字段：",
      "reference_sentence": "* `const char* request`参数为请求的json字符串，支持以下字段：",
      "line_num": 136,
      "context": "{\"131\":\"* `void* context`参数为用户提供的上下文指针，用于传递给回调函数。一般用法中，用户代码可通过该参数找到与收到的回复对应的请求，从而进行相应的处理。\",\"132\":\"\",\"133\":\"另外，`OH_QoS_GewuOnResponse`回调函数的各参数如下：\",\"134\":\"\",\"135\":\"* `void* context`参数是调用`OH_QoS_GewuSubmitRequest`时传进来的`context`指针。\",\"136\":\"* `const char* response`参数是回复的json字符串，包含以下字段：\",\"137\":\"    * \\\"message\\\": 回复消息，包含以下字段：\",\"138\":\"        * \\\"role\\\": string. 消息的角色类型，应为\\\"assistant\\\"。\",\"139\":\"        * \\\"content\\\": string. 消息内容。\",\"140\":\"    * \\\"finish_reason\\\": string or null. 停止原因，可能的值如下：\",\"141\":\"        * null: 表示没有停止。流式推理中会有多次回复，只有最后一次回复有非空的\\\"finish_reason\\\"。而非流式推理只有一次回复，且\\\"finish_reason\\\"非空。\"}",
      "用户拒绝的修改": "* `const char* response`参数是回复的JSON字符串，包含以下字段：",
      "注意事项": "修复时应优先检查上下文术语使用习惯，若文档中存在统一的小写\"json\"用法，应保持全文档风格一致，而非机械套用通用格式规范。"
    },
    {
      "defect_id": 549694,
      "sentence": "共享配置文件shared_config.json的文件名\"shared_config\"可自定义，根节点名称为crossAppSharedConfig，为对象数组，标识当前共享配置项的数量。（一个应用最多可以发布32个配置项，这个数量是静态配置项与动态配置项的总和。静态配置项数量超过32时，只解析前32个有效配置，其余配置不生效。）<br/>",
      "reference_sentence": "配置发布方需要配置module.json5文件中的crossAppSharedConfig字段，通过crossAppSharedConfig字段引用shared_config.json文件，shared_config.json为共享配置文件，定义了应用希望与其他应用共享的配置项。共享配置文件需放置在工程resources/base/profile目录下，并通过`$`资源访问方式引用。",
      "line_num": 59,
      "context": "{\"54\":\"    \\\"crossAppSharedConfig\\\": \\\"$profile:shared_config\\\"\",\"55\":\"  }\",\"56\":\"```\",\"57\":\"\",\"58\":\"\",\"59\":\"共享配置文件shared_config.json的文件名\\\"shared_config\\\"可自定义，根节点名称为crossAppSharedConfig，为对象数组，标识当前共享配置项的数量。（一个应用最多可以发布32个配置项，这个数量是静态配置项与动态配置项的总和。静态配置项数量超过32时，只解析前32个有效配置，其余配置不生效。）<br/>\",\"60\":\"\",\"61\":\"crossAppSharedConfig字段配置说明：\",\"62\":\"\",\"63\":\"| 属性名称 | 含义 | 数据类型 | 必填 |\",\"64\":\"| ------- | ------- | ------- | ------- |\"}",
      "用户拒绝的修改": "共享配置文件shared_config.json的文件名\\",
      "注意事项": "严格保持术语一致性，确保\"共享配置文件\"、\"静态配置项\"等专业术语在上下文中的统一使用，避免同义替换；修复时需结合完整技术语境验证术语引用关系，确保文件、字段、配置类型的描述与原始定义完全对应。"
    },
    {
      "defect_id": 549521,
      "sentence": "调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。",
      "reference_sentence": "调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。",
      "line_num": 9217,
      "context": "{\"9212\":\"> **说明：**\",\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9221\":\"\",\"9222\":\"**参数：**\"}",
      "用户拒绝的修改": "调用本接口后，将启用页面加载快照检测及生成过渡帧计算，这会产生一定的资源开销。",
      "注意事项": "修复时应严格区分动词的施动主体和逻辑关系，避免将不同操作阶段的动词误判为重复表述；优先保持原句的因果承接结构，仅在确实存在指代不清时添加连接词。"
    },
    {
      "defect_id": 549426,
      "sentence": "建议用户应当等待至所有请求都已完成或中止，然后再调用该接口来销毁会话。如果调用该接口时还有正在进行的请求，那些请求将会被中止，且用户不会再收到回复。注意，在调用完该接口后，会话对象无法再被使用。",
      "reference_sentence": "建议用户应当等待至所有请求都已完成或中止，然后再调用`OH_QoS_GewuDestroySession`接口来销毁会话。如果调用`OH_QoS_GewuDestroySession`接口时还有正在进行的请求，那些请求将会被中止，且用户不会再收到回复。注意，在调用完`OH_QoS_GewuDestroySession`接口后，会话对象无法再被使用。",
      "line_num": 83,
      "context": "{\"78\":\"\",\"79\":\"##### 描述\",\"80\":\"\",\"81\":\"`OH_QoS_GewuDestroySession`接口用于销毁会话。\",\"82\":\"\",\"83\":\"建议用户应当等待至所有请求都已完成或中止，然后再调用该接口来销毁会话。如果调用该接口时还有正在进行的请求，那些请求将会被中止，且用户不会再收到回复。注意，在调用完该接口后，会话对象无法再被使用。\",\"84\":\"\",\"85\":\"##### 声明\",\"86\":\"\",\"87\":\"```C\",\"88\":\"OH_QoS_GewuErrorCode OH_QoS_GewuDestroySession(OH_QoS_GewuSession session);\"}",
      "用户拒绝的修改": "建议用户应当等待至所有请求都已完成或中止，然后再调用`OH_QoS_GewuDestroySession`接口来销毁会话。如果调用`OH_QoS_GewuDestroySession`接口时还有正在进行的请求，那些请求将会被中止，且用户不会再收到回复。注意，在调用完`OH_QoS_GewuDestroySession`接口后，会话对象无法再被使用。",
      "注意事项": "在维护术语一致性时需平衡可读性，若上下文已明确\"该接口\"指代特定术语（如`OH_QoS_GewuDestroySession`），应优先保留自然语言指代；仅在首次出现或存在歧义时强制使用全称术语。"
    },
    {
      "defect_id": 549444,
      "sentence": "只有当用户希望提前中止推理请求的时候，才需要调用`OH_QoS_GewuAbortRequest`接口。",
      "reference_sentence": "建议用户应当等待至所有请求都已完成或中止，然后再调用该接口来销毁会话。",
      "line_num": 158,
      "context": "{\"153\":\"##### 描述\",\"154\":\"\",\"155\":\"`OH_QoS_GewuAbortRequest`接口用于提前中止请求。\",\"156\":\"\",\"157\":\"正常情况下，用户调用`OH_QoS_GewuSubmitRequest`接口提交请求后，等待至推理完成（即收到`\\\"finish_reason\\\"`不为空的回复），不需要调用`OH_QoS_GewuAbortRequest`接口。\",\"158\":\"只有当用户希望提前中止推理请求的时候，才需要调用`OH_QoS_GewuAbortRequest`接口。\",\"159\":\"\",\"160\":\"成功调用该函数后，用户不会再收到该请求的回复，且该请求句柄无法再被使用。\",\"161\":\"\",\"162\":\"##### 声明\",\"163\":\"\"}",
      "用户拒绝的修改": "只有当用户希望中止推理请求的时候，才需要调用`OH_QoS_GewuAbortRequest`接口。",
      "注意事项": "必须保留原文中具有功能区分意义的时间/条件限定词（如\"提前\"），避免因过度简化丢失关键语义差异；需严格核查技术文档中术语的上下文使用场景，确保同一功能描述在不同位置保持用词一致性。"
    },
    {
      "defect_id": 549441,
      "sentence": "* `void* context`参数是调用`OH_QoS_GewuSubmitRequest`时传进来的`context`指针。",
      "reference_sentence": "* `void* context`参数为用户提供的上下文指针，用于传递给回调函数。一般用法中，用户代码可通过该参数找到与收到的回复对应的请求，从而进行相应的处理。",
      "line_num": 135,
      "context": "{\"130\":\"* `OH_QoS_GewuOnResponse callback`参数为请求的回调函数。\",\"131\":\"* `void* context`参数为用户提供的上下文指针，用于传递给回调函数。一般用法中，用户代码可通过该参数找到与收到的回复对应的请求，从而进行相应的处理。\",\"132\":\"\",\"133\":\"另外，`OH_QoS_GewuOnResponse`回调函数的各参数如下：\",\"134\":\"\",\"135\":\"* `void* context`参数是调用`OH_QoS_GewuSubmitRequest`时传进来的`context`指针。\",\"136\":\"* `const char* response`参数是回复的json字符串，包含以下字段：\",\"137\":\"    * \\\"message\\\": 回复消息，包含以下字段：\",\"138\":\"        * \\\"role\\\": string. 消息的角色类型，应为\\\"assistant\\\"。\",\"139\":\"        * \\\"content\\\": string. 消息内容。\",\"140\":\"    * \\\"finish_reason\\\": string or null. 停止原因，可能的值如下：\"}",
      "用户拒绝的修改": "* `void* context`参数是调用`OH_QoS_GewuSubmitRequest`时提供的上下文指针。",
      "注意事项": "在统一术语时需优先保留用户熟悉的直观表达，避免因过度追求术语一致性而牺牲可读性；同时应结合上下文判断术语使用场景，若同一文档存在不同语境下的差异化表述（如参数传递方与接收方），允许保留合理差异。"
    },
    {
      "defect_id": 549535,
      "sentence": "| similarity | number | 否   | 否   | 首屏相似度，根据历史加载首屏内容计算相似度，范围为0~1.0，1.0表示完全一致，数值越接近1，相似度越高。该值存在滞后性，本地加载的相似性将在下次加载时才可反映。建议当相似度较低时，应用不启用无白屏加载插帧方案。 |",
      "reference_sentence": "| similarity | number | 否   | 否   | 首屏相似度，根据历史加载首屏内容计算相似度，范围为0~1.0，1.0表示完全一致，数值越接近1，相似度越高。该值存在滞后性，本地加载的相似性将在下次加载时才可反映。建议当相似度较低时，应用不启用无白屏加载插帧方案。 |",
      "line_num": 172,
      "context": "{\"167\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"168\":\"\",\"169\":\"| 名称        | 类型   | 只读 | 可选 |说明                 |\",\"170\":\"| ----------- | ------ | -----|------|------------------- |\",\"171\":\"| errCode | WebBlanklessErrorCode | 否   | 否   | 无白屏加载的异常错误码，见[WebBlanklessErrorCode](./arkts-apis-webview-e.md#webblanklesserrorcode20)定义。 |\",\"172\":\"| similarity | number | 否   | 否   | 首屏相似度，根据历史加载首屏内容计算相似度，范围为0~1.0，1.0表示完全一致，数值越接近1，相似度越高。该值存在滞后性，本地加载的相似性将在下次加载时才可反映。建议当相似度较低时，应用不启用无白屏加载插帧方案。 |\",\"173\":\"| loadingTime | int | 否   | 否   | 根据历史加载首屏耗时预测本次加载耗时，单位ms，取值范围需大于0。 |\",\"174\":\"\",\"175\":\"## HistoryItem\",\"176\":\"\",\"177\":\"页面历史记录项。\"}",
      "用户拒绝的修改": "| similarity | number | 否   | 否   | 首屏相似度，根据历史加载首屏内容计算相似度，范围为0~1.0，1.0表示完全一致，数值越接近1，相似度越高。该值存在滞后性，本地加载的相似性将在下次加载时才可反映。建议当相似度较低时，应用不启用无白屏加载方案。 |",
      "注意事项": "在修复术语一致性时，需全面检查文档上下文及关联参数定义（如系统能力、错误码等），确认术语是否存在技术性差异或官方定义，避免因局部修改破坏技术概念的完整性；若术语在文档中明确存在变体形式（如\"无白屏加载\"与\"无白屏加载插帧\"），需通过交叉验证参数说明或系统能力字段确认标准表述。"
    },
    {
      "defect_id": 549534,
      "sentence": "| errCode | WebBlanklessErrorCode | 否   | 否   | 无白屏加载的异常错误码，见[WebBlanklessErrorCode](./arkts-apis-webview-e.md#webblanklesserrorcode20)定义。 |",
      "reference_sentence": "| errCode | WebBlanklessErrorCode | 否   | 否   | 无白屏加载的异常错误码，见[WebBlanklessErrorCode](./arkts-apis-webview-e.md#webblanklesserrorcode20)定义。 |",
      "line_num": 171,
      "context": "{\"166\":\"\",\"167\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"168\":\"\",\"169\":\"| 名称        | 类型   | 只读 | 可选 |说明                 |\",\"170\":\"| ----------- | ------ | -----|------|------------------- |\",\"171\":\"| errCode | WebBlanklessErrorCode | 否   | 否   | 无白屏加载的异常错误码，见[WebBlanklessErrorCode](./arkts-apis-webview-e.md#webblanklesserrorcode20)定义。 |\",\"172\":\"| similarity | number | 否   | 否   | 首屏相似度，根据历史加载首屏内容计算相似度，范围为0~1.0，1.0表示完全一致，数值越接近1，相似度越高。该值存在滞后性，本地加载的相似性将在下次加载时才可反映。建议当相似度较低时，应用不启用无白屏加载插帧方案。 |\",\"173\":\"| loadingTime | int | 否   | 否   | 根据历史加载首屏耗时预测本次加载耗时，单位ms，取值范围需大于0。 |\",\"174\":\"\",\"175\":\"## HistoryItem\",\"176\":\"\"}",
      "用户拒绝的修改": "| errCode | WebBlanklessErrorCode | 否   | 否   | 无白屏加载插帧的异常错误码，见[WebBlanklessErrorCode](./arkts-apis-webview-e.md#webblanklesserrorcode20)定义。 |",
      "注意事项": "修复术语时必须严格匹配上下文中的完整定义形式，避免将关联技术方案名称（如\"无白屏加载插帧\"）与基础技术概念（如\"无白屏加载\"）混用；修改前需交叉验证文档中所有相关术语的使用场景和明确定义。"
    },
    {
      "defect_id": 549520,
      "sentence": "如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。",
      "reference_sentence": "如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。",
      "line_num": 9216,
      "context": "{\"9211\":\"\",\"9212\":\"> **说明：**\",\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9221\":\"\"}",
      "用户拒绝的修改": "如果发现快照的similarity（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。",
      "注意事项": "保留括号内术语的补充说明作用，避免在正文中替换已明确对应的中英文术语（如\"相似度(similarity)\"结构），优先保持原文术语与代码字段的显式关联性。"
    },
    {
      "defect_id": 552563,
      "sentence": "Sessions not exist. Return by promise.",
      "reference_sentence": "会话ID不存在时，返回错误。",
      "line_num": 161,
      "context": "{\"156\":\"<!--Del-->\",\"157\":\"## 5400109 会话ID不存在\",\"158\":\"\",\"159\":\"**错误信息**\",\"160\":\"\",\"161\":\"Sessions not exist. Return by promise.\",\"162\":\"\",\"163\":\"**错误描述**\",\"164\":\"\",\"165\":\"会话ID不存在时，返回错误。\",\"166\":\"\"}",
      "用户拒绝的修改": "If the session ID does not exist, return an error by promise.",
      "注意事项": "修复前需确认上下文是否存在固定表达模式（如中英文混用规范），优先保留用户明确要求的平台特定格式，仅在违反核心语言规则时提供建议性修改。"
    },
    {
      "defect_id": 552587,
      "sentence": "Called from Non-System applications. Return by promise.",
      "reference_sentence": "No memory. Return by promise.",
      "line_num": 189,
      "context": "{\"184\":\"**错误码：**\",\"185\":\"\",\"186\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)和[媒体错误码](errorcode-media.md)\",\"187\":\"| 错误码ID | 错误信息                                    |\",\"188\":\"| -------- | ------------------------------------------- |\",\"189\":\"| 202      | Called from Non-System applications. Return by promise.               |\",\"190\":\"| 5400109  | Sessions not exist. Return by promise.               |\",\"191\":\"\",\"192\":\"**示例：**\",\"193\":\"\",\"194\":\"```ts\"}",
      "用户拒绝的修改": "Called from Non-System applications. 异步返回函数执行结果。",
      "注意事项": "修复时应首先检查上下文中的语言使用惯例，确保术语翻译与文档现有语言风格保持一致；当技术术语存在固定英文表述时，应优先保留原文而非强制本地化翻译。"
    },
    {
      "defect_id": 552564,
      "sentence": "传入的会话ID不存在。",
      "reference_sentence": "传入的会话ID不存在。",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"会话ID不存在时，返回错误。\",\"166\":\"\",\"167\":\"**可能原因**\",\"168\":\"\",\"169\":\"传入的会话ID不存在。\",\"170\":\"\",\"171\":\"**处理步骤**\",\"172\":\"\",\"173\":\"检查传入的会话ID，确保其取值正确。\",\"174\":\"<!--DelEnd-->\"}",
      "用户拒绝的修改": "请检查传入的会话ID是否正确。",
      "注意事项": "修复时应先识别上下文结构差异，在\"可能原因\"部分保持陈述句形式，在\"处理步骤\"部分使用祈使句，避免跨结构强行统一句式。"
    },
    {
      "defect_id": 552588,
      "sentence": "Sessions not exist. Return by promise.",
      "reference_sentence": "No memory. Return by promise.",
      "line_num": 190,
      "context": "{\"185\":\"\",\"186\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)和[媒体错误码](errorcode-media.md)\",\"187\":\"| 错误码ID | 错误信息                                    |\",\"188\":\"| -------- | ------------------------------------------- |\",\"189\":\"| 202      | Called from Non-System applications. Return by promise.               |\",\"190\":\"| 5400109  | Sessions not exist. Return by promise.               |\",\"191\":\"\",\"192\":\"**示例：**\",\"193\":\"\",\"194\":\"```ts\",\"195\":\"import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "Sessions do not exist. 异步返回函数执行结果。",
      "注意事项": "修复时应确保语言环境统一，避免中英文混杂，优先采用上下文已确立的表达方式（如全英文描述）。若原文存在混合语言现象，需先确认上下文是否存在统一规范再调整。"
    },
    {
      "defect_id": 553483,
      "sentence": "### 命令式开发范式",
      "reference_sentence": "### 命令式开发范式（类Web开发范式）",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"声明式开发范式（推荐）采用ArkTS语言，通过声明UI结构和状态，自动驱动界面渲染。开发者只需描述“界面应该是什么样”，无需手动管理UI更新。适用于复杂度较高、团队协作的应用开发，具有高开发效率、良好性能和易维护等优势。\",\"53\":\"\",\"54\":\"**适用场景**：复杂应用、需要高效开发和维护的项目、推荐新项目优先选用。\",\"55\":\"\",\"56\":\"### 命令式开发范式\",\"57\":\"\",\"58\":\"命令式开发范式（类Web开发范式）采用HML、CSS、JavaScript三段式，开发者需手动管理UI的每一步变化。适合界面简单、中小型应用或Web开发者迁移。\",\"59\":\"\",\"60\":\"**适用场景**：界面简单的中小型应用、Web前端开发者迁移项目。\",\"61\":\"\"}",
      "用户拒绝的修改": "### 命令式开发范式（类Web开发范式）",
      "注意事项": "修复时应优先确认用户提及的“SE检视”具体规范要求，避免仅依赖局部上下文添加内容；同时需区分标题层级与正文描述的差异，标题简洁性可能比括号补充信息更重要。"
    },
    {
      "defect_id": 551087,
      "sentence": "CookieManager初始化失败。",
      "reference_sentence": "CookieManager未初始化。",
      "line_num": 49,
      "context": "{\"44\":\"| ARKWEB_INVALID_URL = 17100103 = 17100104   | 无效的URL。                                         |\",\"45\":\"| ARKWEB_INVALID_COOKIE_VALUE = 17100104     | 无效的cookie值。                                    |\",\"46\":\"| ARKWEB_LIBRARY_OPEN_FAILURE = 17100105     | 打开动态链接库失败。<br>**起始版本：** 15           |\",\"47\":\"| ARKWEB_LIBRARY_SYMBOL_NOT_FOUND = 17100106 | 动态链接库中找不到所需的符号。<br>**起始版本：** 15 |\",\"48\":\"| ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED = 17100107 | CookieManager未初始化。<br>**起始版本：** 20 |\",\"49\":\"| ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED = 17100108 | CookieManager初始化失败。<br>**起始版本：** 20 |\",\"50\":\"| ARKWEB_COOKIE_SAVE_FAILED = 17100109 | 保存cookie失败。<br>**起始版本：** 20 |\",\"51\":\"\",\"52\":\"### ArkWeb_BlanklessErrorCode\",\"53\":\"\",\"54\":\"```\"}",
      "用户拒绝的修改": "CookieManager未初始化。",
      "注意事项": "严格区分\"未初始化\"（未执行初始化操作）与\"初始化失败\"（已执行但未成功）的技术语义差异，修复时必须与上下文中的错误码定义（ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED vs ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED）保持严格对应关系。"
    },
    {
      "defect_id": 553482,
      "sentence": "命令式开发范式（类Web开发范式）采用HML、CSS、JavaScript三段式，开发者需手动管理UI的每一步变化。适合界面简单、中小型应用或Web开发者迁移。",
      "reference_sentence": "类Web开发范式：采用经典的HML、CSS、JavaScript三段式开发方式，即使用HML标签文件搭建布局、使用CSS文件描述样式、使用JavaScript文件处理逻辑。该范式更符合于Web前端开发者的使用习惯，便于快速将已有的Web应用改造成方舟UI框架应用。",
      "line_num": 58,
      "context": "{\"53\":\"\",\"54\":\"**适用场景**：复杂应用、需要高效开发和维护的项目、推荐新项目优先选用。\",\"55\":\"\",\"56\":\"### 命令式开发范式\",\"57\":\"\",\"58\":\"命令式开发范式（类Web开发范式）采用HML、CSS、JavaScript三段式，开发者需手动管理UI的每一步变化。适合界面简单、中小型应用或Web开发者迁移。\",\"59\":\"\",\"60\":\"**适用场景**：界面简单的中小型应用、Web前端开发者迁移项目。\",\"61\":\"\",\"62\":\"### 自定义能力\",\"63\":\"\"}",
      "用户拒绝的修改": "命令式开发范式（类Web开发范式）采用HML、CSS、JavaScript三段式，开发者需手动管理UI的每一步变化。适合界面简单的中小型应用或Web开发者迁移。",
      "注意事项": "保持并列结构的逻辑层级一致性，避免将不同维度的描述混为单一修饰语；处理复合条件时应明确区分主体属性（如\"界面简单\"）与应用类型（如\"中小型应用\"），使用顿号分隔时需确保并列项处于同一语义层级。\n\n在调整句式结构时需同步验证修饰关系是否产生歧义，特别注意形容词短语（如\"界面简单\"）的修饰范围是否覆盖后续所有并列项，必要时通过重复主语或拆分句式保持表意精准。"
    },
    {
      "defect_id": 551088,
      "sentence": "保存cookie失败。",
      "reference_sentence": "无效的cookie值。",
      "line_num": 50,
      "context": "{\"45\":\"| ARKWEB_INVALID_COOKIE_VALUE = 17100104     | 无效的cookie值。                                    |\",\"46\":\"| ARKWEB_LIBRARY_OPEN_FAILURE = 17100105     | 打开动态链接库失败。<br>**起始版本：** 15           |\",\"47\":\"| ARKWEB_LIBRARY_SYMBOL_NOT_FOUND = 17100106 | 动态链接库中找不到所需的符号。<br>**起始版本：** 15 |\",\"48\":\"| ARKWEB_COOKIE_MANAGER_NOT_INITIALIZED = 17100107 | CookieManager未初始化。<br>**起始版本：** 20 |\",\"49\":\"| ARKWEB_COOKIE_MANAGER_INITIALIZE_FAILED = 17100108 | CookieManager初始化失败。<br>**起始版本：** 20 |\",\"50\":\"| ARKWEB_COOKIE_SAVE_FAILED = 17100109 | 保存cookie失败。<br>**起始版本：** 20 |\",\"51\":\"\",\"52\":\"### ArkWeb_BlanklessErrorCode\",\"53\":\"\",\"54\":\"```\",\"55\":\"enum ArkWeb_BlanklessErrorCode\"}",
      "用户拒绝的修改": "保存Cookie失败。",
      "注意事项": "修复前必须核查上下文及参考句子的术语使用形式，优先保持与相邻条目和已有错误代码描述的一致性，避免孤立判断大小写规则。"
    },
    {
      "defect_id": 552553,
      "sentence": "## 适用场景",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"通过双向预测，B帧同时利用前后帧信息，显著降低时域冗余信号，具有极高的压缩效率。在码率充足且运动平缓、光照稳定的场景中，B帧的精确预测能减少残差数据，从而提升视频压缩效率，降低因量化导致的块效应（Blocking Artifacts），提升运动连续性；但若码率过低，双向预测可能放大Artifacts。\",\"10\":\"\",\"11\":\"## 适用场景\",\"12\":\"\",\"13\":\"除对时延要求很高的场景，其他场景均可使用，不过要考虑时延增加、内存开销和功耗上升给业务场景带来的影响。\",\"14\":\"\",\"15\":\"## 约束和限制\",\"16\":\"\",\"17\":\"- **支持的平台**：该能力与平台能力有关，可以通过OH_AVCapability_IsFeatureSupported接口查询系统支持情况。\",\"18\":\"- **支持的系统**：OpenHarmony6.0及以后。\"}",
      "用户拒绝的修改": "## 使用场景",
      "注意事项": "在保持标题与正文词汇一致性的同时，需优先确保术语的准确性和语义完整性，尤其要区分\"适用场景\"（强调适用条件）与\"使用场景\"（侧重应用环境）等近义词的细微差异，避免因机械替换导致专业表达失真。"
    },
    {
      "defect_id": 551592,
      "sentence": "获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "line_num": 4018,
      "context": "{\"4013\":\"int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)\",\"4014\":\"```\",\"4015\":\"\",\"4016\":\"**描述**\",\"4017\":\"\",\"4018\":\"获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。\",\"4019\":\"\",\"4020\":\"**起始版本：** 20\",\"4021\":\"\",\"4022\":\"**参数：**\",\"4023\":\"\"}",
      "用户拒绝的修改": "获取触摸事件的触摸位置相对于主屏幕左上角的Y坐标。",
      "注意事项": "在确保技术术语准确性的前提下调整表述一致性，避免将正确的专业表述误判为不一致；修改前需完整理解上下文语境，确认\"距离\"和\"相对于\"在具体技术场景中是否具有实质性差异。"
    },
    {
      "defect_id": 552429,
      "sentence": "entry模块必须配置入口Ability。",
      "reference_sentence": "entry模块必须配置入口Ability。",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"- windowStageCreated：[WindowStage](../reference/apis-arkui/arkts-apis-window-WindowStage.md)创建完成阶段，会拉起entry模块的入口UIAbility，并触发其[onCreate](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#oncreate)回调和[onWindowStageCreate](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#onwindowstagecreate)回调。开发者可以在UIAbility的[onCreate](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#oncreate)回调中通过[LaunchParam.launchReason](../reference/apis-ability-kit/js-apis-app-ability-abilityConstant.md#launchreason)判断当前UIAbility是否由预加载机制启动。\",\"26\":\"\",\"27\":\"## 约束限制\",\"28\":\"\",\"29\":\"- entry模块必须配置入口Ability。\",\"30\":\"\",\"31\":\"- 入口Ability的类型必须为UIAbility。\",\"32\":\"\",\"33\":\"## 开发流程\",\"34\":\"\"}",
      "用户拒绝的修改": "必须在entry模块中配置入口Ability。",
      "注意事项": "修复时需保持原句技术约束的精确范围，避免通过句式调整引入排他性歧义；统一表达时应采用\"模块+必须+动作\"的主动结构（如\"entry模块必须配置\"）而非状语前置结构，以准确传递必要条件而非唯一条件。"
    },
    {
      "defect_id": 552554,
      "sentence": "不支持与长期参考帧共同使能。",
      "reference_sentence": "不支持与时域可分层视频编码共同使能。",
      "line_num": 22,
      "context": "{\"17\":\"- **支持的平台**：该能力与平台能力有关，可以通过OH_AVCapability_IsFeatureSupported接口查询系统支持情况。\",\"18\":\"- **支持的系统**：OpenHarmony6.0及以后。\",\"19\":\"- **支持的编码器**：该能力与编码器能力有关，可以通过OH_AVCodec_GetCapabilityByCategory接口查询支持情况。\",\"20\":\"- **支持的码控模式**：VBR、CBR、SQR、CQ。\",\"21\":\"- 不支持与时域可分层视频编码共同使能。\",\"22\":\"- 不支持与长期参考帧共同使能。\",\"23\":\"\",\"24\":\"## 接口介绍\",\"25\":\"\",\"26\":\"支持B帧编码特性，初始配置，全局生效，不支持动态修改。开发配置参数如下：\",\"27\":\"\"}",
      "用户拒绝的修改": "不支持与长期参考帧共同使用。",
      "注意事项": "修复时应严格保留原文的关键技术术语（如“使能”），并优先遵循上下文已有的固定句式模板（如\"不支持与X共同使能\"），避免因替换术语或调整句式结构导致语义偏差。"
    },
    {
      "defect_id": 551108,
      "sentence": "[typedef void (*OH_ArkWeb_OnCookieSaveCallback)(ArkWeb_ErrorCode errorCode)](#oh_arkweb_oncookiesavecallback) | OH_ArkWeb_OnCookieSaveCallback | 定义保存cookie的回调函数的类型。<br>**起始版本：** 20",
      "reference_sentence": "声明API接口供开发者使用注入对象和执行JavaScript代码等功能。",
      "line_num": 25,
      "context": "{\"20\":\"| -- | -- | -- |\",\"21\":\"| [typedef void (\\\\*NativeArkWeb_OnJavaScriptCallback)(const char*)](#nativearkweb_onjavascriptcallback) | NativeArkWeb_OnJavaScriptCallback | 定义执行JavaScript代码后返回结果的回调函数的类型。 |\",\"22\":\"| [typedef char* (\\\\*NativeArkWeb_OnJavaScriptProxyCallback)(const char** argv, int32_t argc)](#nativearkweb_onjavascriptproxycallback) | NativeArkWeb_OnJavaScriptProxyCallback | 定义注入对象的回调函数的类型。 |\",\"23\":\"| [typedef void (\\\\*NativeArkWeb_OnValidCallback)(const char*)](#nativearkweb_onvalidcallback) | NativeArkWeb_OnValidCallback | 定义Web组件可用时的回调函数的类型。 |\",\"24\":\"| [typedef void (\\\\*NativeArkWeb_OnDestroyCallback)(const char*)](#nativearkweb_ondestroycallback) | NativeArkWeb_OnDestroyCallback | 定义Web组件销毁时的回调函数的类型。 |\",\"25\":\"| [typedef void (\\\\*OH_ArkWeb_OnCookieSaveCallback)(ArkWeb_ErrorCode errorCode)](#oh_arkweb_oncookiesavecallback) | OH_ArkWeb_OnCookieSaveCallback | 定义保存cookie的回调函数的类型。<br>**起始版本：** 20 |\",\"26\":\"| [typedef ArkWeb_BlanklessInfo](#arkweb_blanklessinfo) | ArkWeb_BlanklessInfo | 无白屏加载的预测信息，主要包括预测错误码，预测的快照相似度，预测加载的时长，应用需根据此信息来决策是否启用无白屏加载插帧。 |\",\"27\":\"| [void OH_NativeArkWeb_RunJavaScript(const char* webTag, const char* jsCode, NativeArkWeb_OnJavaScriptCallback callback)](#oh_nativearkweb_runjavascript) | - | 在当前显示页面的环境下，加载并异步执行一段JavaScript代码。 |\",\"28\":\"| [void OH_NativeArkWeb_RegisterJavaScriptProxy(const char* webTag, const char* objName, const char** methodList,NativeArkWeb_OnJavaScriptProxyCallback* callback, int32_t size, bool needRefresh)](#oh_nativearkweb_registerjavascriptproxy) | - | 注册对象及函数名称列表。 |\",\"29\":\"| [void OH_NativeArkWeb_UnregisterJavaScriptProxy(const char* webTag, const char* objName)](#oh_nativearkweb_unregisterjavascriptproxy) | - | 删除已注册的对象及其下的回调函数。 |\",\"30\":\"| [void OH_NativeArkWeb_SetJavaScriptProxyValidCallback(const char* webTag, NativeArkWeb_OnValidCallback callback)](#oh_nativearkweb_setjavascriptproxyvalidcallback) | - | 设置对象可注册时的回调函数。 |\"}",
      "用户拒绝的修改": "[typedef void (*OH_ArkWeb_OnCookieSaveCallback)(ArkWeb_ErrorCode errorCode)](#oh_arkweb_oncookiesavecallback) | OH_ArkWeb_OnCookieSaveCallback | 定义保存Cookie的回调函数的类型。<br>**起始版本：** 20",
      "注意事项": "修复术语大小写时需严格遵循项目内部命名规范，优先检查代码中实际变量名和上下文统一用法，避免脱离技术上下文套用通用拼写规则。"
    },
    {
      "defect_id": 552556,
      "sentence": "基础编码功能请参考[视频编码](video-encoding.md)开发指南，下面仅针对B帧编码做具体说明。",
      "reference_sentence": "",
      "line_num": 38,
      "context": "{\"33\":\"- **视频编码使能B帧参数** 在配置阶段配置，仅特性支持才会真正使能成功。\",\"34\":\"- **视频编码支持最大B帧数量** 该接口仅供查询。\",\"35\":\"\",\"36\":\"## 开发指导\",\"37\":\"\",\"38\":\"基础编码功能请参考[视频编码](video-encoding.md)开发指南，下面仅针对B帧编码做具体说明。\",\"39\":\"\",\"40\":\"1. 在初始阶段创建编码实例时，校验当前视频编码器是否支持B帧编码特性。\",\"41\":\"\",\"42\":\"    ```c++\",\"43\":\"    bool isSupported = false;\"}",
      "用户拒绝的修改": "请参考[视频编码](video-encoding.md)开发指南，下面仅针对B帧编码做具体说明。",
      "注意事项": "修复句式一致性时需保留关键限定词（如\"基础编码功能\"），避免因过度简化导致上下文信息丢失；修改前应核对原句语义完整性，确保核心指代对象不发生偏移。"
    },
    {
      "defect_id": 552555,
      "sentence": "在配置阶段配置，仅特性支持才会真正使能成功。",
      "reference_sentence": "该接口仅供查询。",
      "line_num": 33,
      "context": "{\"28\":\"|配置参数 |语义 |格式 |\",\"29\":\"|------- |------- |------- |\",\"30\":\"|OH_MD_KEY_VIDEO_ENCODER_ENABLE_B_FRAME |视频编码使能B帧参数 |Int |\",\"31\":\"|OH_MD_KEY_VIDEO_ENCODER_MAX_B_FRAMES |视频编码支持最大B帧数量 |Int |\",\"32\":\"\",\"33\":\"- **视频编码使能B帧参数** 在配置阶段配置，仅特性支持才会真正使能成功。\",\"34\":\"- **视频编码支持最大B帧数量** 该接口仅供查询。\",\"35\":\"\",\"36\":\"## 开发指导\",\"37\":\"\",\"38\":\"基础编码功能请参考[视频编码](video-encoding.md)开发指南，下面仅针对B帧编码做具体说明。\"}",
      "用户拒绝的修改": "在配置阶段配置，该接口仅在特性支持时才会真正使能成功。",
      "注意事项": "修复时应优先确保语义完整性和上下文术语统一，避免机械套用句式导致关键信息缺失；同时需严格参照相邻条目的表达结构（如\"该接口仅供查询\"），保持主语、谓语和条件状语的位置一致性。"
    },
    {
      "defect_id": 556246,
      "sentence": "| mpeg-ts  | AVC(H.264)<!--RP4--><!--RP4End-->、MPEG2、MPEG4 | AAC、MPEG(MP3)<!--RP5--><!--RP5End-->|",
      "reference_sentence": "| mpeg-ts  | AVC(H.264)、MPEG2、MPEG4 | AAC、MPEG(MP3) |",
      "line_num": 322,
      "context": "{\"317\":\"\",\"318\":\"| 封装格式  | 视频编码类型   | 音频编码类型   |\",\"319\":\"| -------- | :----------------------------| :----------------------------|\",\"320\":\"| mp4      | AVC(H.264)<!--RP2--><!--RP2End-->、MPEG4| AAC、MPEG(MP3) |\",\"321\":\"| mkv      | AVC(H.264)<!--RP3--><!--RP3End--> | AAC、MPEG(MP3)、OPUS |\",\"322\":\"| mpeg-ts  | AVC(H.264)<!--RP4--><!--RP4End-->、MPEG2、MPEG4 | AAC、MPEG(MP3)<!--RP5--><!--RP5End-->|\",\"323\":\"| flv      | AVC(H.264)<!--RP6--><!--RP6End--> |  AAC  |\",\"324\":\"| mpeg-ps  | AVC(H.264)、MPEG2 |    MPEG(MP2、MP3)|\",\"325\":\"| avi      | H.263、AVC(H.264)、MPEG2、MPEG4  | AAC、MPEG(MP2、MP3)、PCM|\",\"326\":\"\",\"327\":\"当前转码支持的源视频格式详细情况请参考[AVCodec支持的格式](../avcodec/avcodec-support-formats.md#媒体数据解析)。\"}",
      "用户拒绝的修改": "| mpeg-ts  | AVC(H.264)、MPEG2、MPEG4 | AAC、MPEG(MP3) |",
      "注意事项": "修复前需准确识别注释标签与内容分隔符的区别，优先保留文档标记语法中的注释结构；处理标点一致性时应结合上下文验证元素类型，避免将注释符号误判为格式错误。"
    },
    {
      "defect_id": 556445,
      "sentence": "| useGlobalCoordinate<sup>20+</sup> | boolean | 否    |  是 | 是否使用全局坐标来计算注入的触摸屏事件。   |",
      "reference_sentence": "| useGlobalCoordinate<sup>20+</sup> | boolean | 否    |  是 | 是否使用全局坐标来计算注入的鼠标事件。   |",
      "line_num": 469,
      "context": "{\"464\":\"**系统能力：** SystemCapability.MultimodalInput.Input.InputSimulator\",\"465\":\"\",\"466\":\"| 名称        | 类型   | 只读   | 可选   | 说明      |\",\"467\":\"| --------- | ------ | ---- | ---- | ------- |\",\"468\":\"| touchEvent | [TouchEvent](js-apis-touchevent.md#touchevent) | 否    |  否 | 触摸屏注入描述信息。   |\",\"469\":\"| useGlobalCoordinate<sup>20+</sup> | boolean | 否    |  是 | 是否使用全局坐标来计算注入的触摸屏事件。   |\"}",
      "用户拒绝的修改": "| useGlobalCoordinate<sup>20+</sup> | boolean | 否    |  是 | 是否使用全局坐标来计算注入的触摸事件。   |",
      "注意事项": "修复术语时应严格遵循上下文已有字段命名（如touchEvent对应\"触摸屏事件\"），优先保持参数说明与关联字段的术语一致性，避免过度泛化专业术语。"
    },
    {
      "defect_id": 556245,
      "sentence": "| mp4      | AVC(H.264)<!--RP2--><!--RP2End-->、MPEG4| AAC、MPEG(MP3) |",
      "reference_sentence": "| mp4      | AVC(H.264)、MPEG4| AAC、MPEG(MP3) |",
      "line_num": 320,
      "context": "{\"315\":\"<!--RP1--><!--RP1End-->\",\"316\":\"- 支持的源视频格式：\",\"317\":\"\",\"318\":\"| 封装格式  | 视频编码类型   | 音频编码类型   |\",\"319\":\"| -------- | :----------------------------| :----------------------------|\",\"320\":\"| mp4      | AVC(H.264)<!--RP2--><!--RP2End-->、MPEG4| AAC、MPEG(MP3) |\",\"321\":\"| mkv      | AVC(H.264)<!--RP3--><!--RP3End--> | AAC、MPEG(MP3)、OPUS |\",\"322\":\"| mpeg-ts  | AVC(H.264)<!--RP4--><!--RP4End-->、MPEG2、MPEG4 | AAC、MPEG(MP3)<!--RP5--><!--RP5End-->|\",\"323\":\"| flv      | AVC(H.264)<!--RP6--><!--RP6End--> |  AAC  |\",\"324\":\"| mpeg-ps  | AVC(H.264)、MPEG2 |    MPEG(MP2、MP3)|\",\"325\":\"| avi      | H.263、AVC(H.264)、MPEG2、MPEG4  | AAC、MPEG(MP2、MP3)、PCM|\"}",
      "用户拒绝的修改": "| mp4      | AVC(H.264)、MPEG4 | AAC、MPEG(MP3) |",
      "注意事项": "修复前需优先识别并保留文档中的注释标签等非内容元素，严格区分格式分隔符与标记符号，避免混淆内容排版标记和功能性注释标签。"
    },
    {
      "defect_id": 549874,
      "sentence": "收到事件后，组件需要对点击做出响应。",
      "reference_sentence": "为ArkUI_AccessibilityElementInfo设置clickable。",
      "line_num": 125,
      "context": "{\"120\":\"**起始版本：** 13\",\"121\":\"\",\"122\":\"| 枚举项 | 描述                                                                                                                                |\",\"123\":\"| -- |-----------------------------------------------------------------------------------------------------------------------------------|\",\"124\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_INVALID = 0 | 无效值。                                                                                                                               |\",\"125\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_CLICK = 0x00000010 | 收到事件后，组件需要对点击做出响应。                                                                                                                |\",\"126\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_LONG_CLICK = 0x00000020 | 收到事件后，组件需要对长点击做出响应。                                                                                                               |\",\"127\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_GAIN_ACCESSIBILITY_FOCUS = 0x00000040 | 表示获取辅助功能焦点的操作，特定组件已聚焦。                                                                                                            |\",\"128\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_CLEAR_ACCESSIBILITY_FOCUS = 0x00000080 | 表示清除辅助功能焦点的操作。                                                                                                                    |\",\"129\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_SCROLL_FORWARD = 0x00000100 | 滚动组件响应向前滚动动作。                                                                                                                     |\",\"130\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_SCROLL_BACKWARD = 0x00000200 | 滚动组件响应反向滚动操作。                                                                                                                     |\"}",
      "用户拒绝的修改": "收到事件后，组件需要对点击操作做出响应。",
      "注意事项": "修复时应优先确认术语使用场景是否属于同一语境，避免跨上下文强制统一；若同一文档中存在合理混用情况（如动词与名词化表述），需保留原有表达差异。"
    },
    {
      "defect_id": 556248,
      "sentence": "| mp4      | AVC(H.264)<!--RP7--><!--RP7End--> | AAC |",
      "reference_sentence": "| mp4      | AVC(H.264) | AAC |",
      "line_num": 333,
      "context": "{\"328\":\"\",\"329\":\"- 支持的目标视频格式：\",\"330\":\"\",\"331\":\"| 封装格式  | 视频编码类型   | 音频编码类型   |\",\"332\":\"| -------- | :------------------| :---------------- |\",\"333\":\"| mp4      | AVC(H.264)<!--RP7--><!--RP7End--> | AAC |\",\"334\":\"\",\"335\":\"- 支持的轨道数：\",\"336\":\"  - 不支持字幕轨。若原视频存在字幕轨，转码后字幕轨将被丢弃。\",\"337\":\"  - 仅支持输出一条视频轨。若原视频存在多条视频轨，默认选择第一条视频轨进行转码。\",\"338\":\"  - 仅支持输出一条音频轨。若原视频存在多条音频轨，默认选择第一条音频轨进行转码。\"}",
      "用户拒绝的修改": "| mp4      | AVC (H.264) | AAC |",
      "注意事项": "修复前需准确识别文档中的注释标签与内容分隔符，优先保留有效注释标记，仅针对实际内容元素进行格式一致性调整。"
    },
    {
      "defect_id": 549878,
      "sentence": "滚动组件响应向前滚动动作。",
      "reference_sentence": "为ArkUI_AccessibilityElementInfo设置scrollable。",
      "line_num": 129,
      "context": "{\"124\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_INVALID = 0 | 无效值。                                                                                                                               |\",\"125\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_CLICK = 0x00000010 | 收到事件后，组件需要对点击做出响应。                                                                                                                |\",\"126\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_LONG_CLICK = 0x00000020 | 收到事件后，组件需要对长点击做出响应。                                                                                                               |\",\"127\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_GAIN_ACCESSIBILITY_FOCUS = 0x00000040 | 表示获取辅助功能焦点的操作，特定组件已聚焦。                                                                                                            |\",\"128\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_CLEAR_ACCESSIBILITY_FOCUS = 0x00000080 | 表示清除辅助功能焦点的操作。                                                                                                                    |\",\"129\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_SCROLL_FORWARD = 0x00000100 | 滚动组件响应向前滚动动作。                                                                                                                     |\",\"130\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_SCROLL_BACKWARD = 0x00000200 | 滚动组件响应反向滚动操作。                                                                                                                     |\",\"131\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_COPY = 0x00000400 | 复制文本组件的选定内容。                                                                                                                      |\",\"132\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_PASTE = 0x00000800 | 粘贴文本组件的选定内容。                                                                                                                      |\",\"133\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_CUT = 0x00001000 | 剪切文本组件的选定内容。                                                                                                                      |\",\"134\":\"| ARKUI_ACCESSIBILITY_NATIVE_ACTION_TYPE_SELECT_TEXT = 0x00002000 | 针对文本组件进行选择操作。结合ArkUI_AccessibilityActionArguments使用，配置selectTextStart，selectTextEnd，selectTextInForWard。进入编辑区选择一段文本内容。                                                                    |\"}",
      "用户拒绝的修改": "滚动组件响应向前滚动操作。",
      "注意事项": "在统一术语前需确认上下文是否存在合理混用场景，优先保持同一功能模块内术语一致性而非全局强制统一，特别注意相邻条目间已存在的术语使用惯例（如示例中\"动作\"和\"操作\"在相邻条目中并存使用）。"
    },
    {
      "defect_id": 556247,
      "sentence": "| flv      | AVC(H.264)<!--RP6--><!--RP6End--> |  AAC  |",
      "reference_sentence": "| flv      | AVC(H.264) |  AAC  |",
      "line_num": 323,
      "context": "{\"318\":\"| 封装格式  | 视频编码类型   | 音频编码类型   |\",\"319\":\"| -------- | :----------------------------| :----------------------------|\",\"320\":\"| mp4      | AVC(H.264)<!--RP2--><!--RP2End-->、MPEG4| AAC、MPEG(MP3) |\",\"321\":\"| mkv      | AVC(H.264)<!--RP3--><!--RP3End--> | AAC、MPEG(MP3)、OPUS |\",\"322\":\"| mpeg-ts  | AVC(H.264)<!--RP4--><!--RP4End-->、MPEG2、MPEG4 | AAC、MPEG(MP3)<!--RP5--><!--RP5End-->|\",\"323\":\"| flv      | AVC(H.264)<!--RP6--><!--RP6End--> |  AAC  |\",\"324\":\"| mpeg-ps  | AVC(H.264)、MPEG2 |    MPEG(MP2、MP3)|\",\"325\":\"| avi      | H.263、AVC(H.264)、MPEG2、MPEG4  | AAC、MPEG(MP2、MP3)、PCM|\",\"326\":\"\",\"327\":\"当前转码支持的源视频格式详细情况请参考[AVCodec支持的格式](../avcodec/avcodec-support-formats.md#媒体数据解析)。\",\"328\":\"\"}",
      "用户拒绝的修改": "| flv      | AVC(H.264)<!--RP6--><!--RP6End--> | AAC、MPEG(MP3) |",
      "注意事项": "修复前需严格区分注释标签与内容元素，优先验证上下文实际分隔符使用模式，避免将XML/HTML注释等非内容标记误判为格式不一致问题。"
    },
    {
      "defect_id": 556447,
      "sentence": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "line_num": 189,
      "context": "{\"184\":\"| [int32_t OH_Input_InjectMouseEvent(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseevent) | - | 注入鼠标事件。 |\",\"185\":\"| [int32_t OH_Input_GetMouseEventDisplayId(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventdisplayid) | - | 获取鼠标事件的屏幕Id。 |\",\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\"}",
      "用户拒绝的修改": "获取鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "保持原文术语的完整性和限定词一致性，优先检查上下文是否存在相同场景的固定搭配（如\"鼠标光标位置\"在设置函数中的使用），避免过度简化导致信息缺失。"
    },
    {
      "defect_id": 556448,
      "sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "line_num": 190,
      "context": "{\"185\":\"| [int32_t OH_Input_GetMouseEventDisplayId(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventdisplayid) | - | 获取鼠标事件的屏幕Id。 |\",\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\"}",
      "用户拒绝的修改": "设置鼠标事件的光标位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应严格遵循上下文术语一致性，优先保留原文档中已确立的复合名词（如\"鼠标光标位置\"），避免过度简化导致专业表述缺失；需对比相邻条目（如触屏事件的\"触摸位置\"）确认领域专用词汇的差异化表达。"
    },
    {
      "defect_id": 556446,
      "sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "line_num": 188,
      "context": "{\"183\":\"| [int32_t OH_Input_InjectTouchEvent(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttouchevent) | - | 注入触屏事件。 |\",\"184\":\"| [int32_t OH_Input_InjectMouseEvent(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseevent) | - | 注入鼠标事件。 |\",\"185\":\"| [int32_t OH_Input_GetMouseEventDisplayId(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventdisplayid) | - | 获取鼠标事件的屏幕Id。 |\",\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\"}",
      "用户拒绝的修改": "设置鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "保持术语的完整性和上下文一致性，优先沿用原文中已明确定义的复合名词（如\"鼠标光标位置\"），避免在未确认上下文统一性的情况下简化术语（如\"光标位置\"），尤其需对比同类型接口的命名模式（如触屏事件\"触摸位置\"与鼠标事件\"鼠标光标位置\"的对称性）。"
    },
    {
      "defect_id": 556449,
      "sentence": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "line_num": 191,
      "context": "{\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\"}",
      "用户拒绝的修改": "获取鼠标事件的光标位置距离主屏幕左上角的Y坐标。",
      "注意事项": "保持上下文术语一致性时需优先采用原句完整修饰词（如\"鼠标光标位置\"），避免过度简化导致专业表述缺失；修改前应交叉验证相邻条目的命名模式确保全局统一。"
    },
    {
      "defect_id": 556457,
      "sentence": "获取轴事件的位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "设置轴事件的位置距离主屏幕左上角的Y坐标。",
      "line_num": 200,
      "context": "{\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\",\"204\":\"\",\"205\":\"### Input_KeyStateAction\"}",
      "用户拒绝的修改": "获取轴事件的轴位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应优先保持与上下文术语的一致性，避免添加冗余修饰词；修改前需全面检查相邻接口描述中使用的核心名词是否统一。"
    },
    {
      "defect_id": 556452,
      "sentence": "设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "line_num": 195,
      "context": "{\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\"}",
      "用户拒绝的修改": "设置触屏事件的触屏位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应优先检查上下文已有术语使用习惯（如\"触摸位置\"在相邻接口中已形成固定搭配），避免擅自替换近义词破坏一致性；修改前需确认原始表述是否属于项目专属术语或规范用法。"
    },
    {
      "defect_id": 556456,
      "sentence": "设置轴事件的位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "获取轴事件的位置距离主屏幕左上角的Y坐标。",
      "line_num": 199,
      "context": "{\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\",\"204\":\"\"}",
      "用户拒绝的修改": "设置轴事件的轴位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应严格遵循上下文已有术语使用习惯，避免在未发现明显错误的情况下擅自替换参数名称（如\"位置\"改为\"轴位置\"），需重点核对相邻接口描述和参考句子的用词一致性。"
    },
    {
      "defect_id": 556504,
      "sentence": "设置选中项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。",
      "reference_sentence": "设置选中项的文本颜色、字号、字体粗细。",
      "line_num": 264,
      "context": "{\"259\":\"\",\"260\":\"### selectedTextStyle<sup>20+</sup>\",\"261\":\"\",\"262\":\"selectedTextStyle(style: Optional\\\\<PickerTextStyle\\\\|TextPickerTextStyle>)\",\"263\":\"\",\"264\":\"设置选中项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。\",\"265\":\"\",\"266\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"267\":\"\",\"268\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"269\":\"\"}",
      "用户拒绝的修改": "设置选中项的文本颜色、字号、字体粗细。",
      "注意事项": "修复时必须严格对照问题句子的完整上下文验证参数是否存在遗漏，避免仅依据局部参考句子进行删减；同时需识别参数列表中的并列关系是否属于同一功能模块，确保不误删有效配置项。"
    },
    {
      "defect_id": 556451,
      "sentence": "获取触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "设置触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "line_num": 194,
      "context": "{\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\"}",
      "用户拒绝的修改": "获取触屏事件的触屏位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时必须严格核对上下文术语使用习惯（如\"触摸位置\"在参考句子中已固定），优先保持同一事件类型术语的绝对一致性，避免将同义词误判为错误。"
    },
    {
      "defect_id": 556505,
      "sentence": "过渡项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。",
      "reference_sentence": "选中项的文本颜色、字号、字体粗细。",
      "line_num": 274,
      "context": "{\"269\":\"\",\"270\":\"**参数：**\",\"271\":\"\",\"272\":\"| 参数名 | 类型                                                         | 必填 | 说明                                                         |\",\"273\":\"| ------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"274\":\"| style  | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<[PickerTextStyle](ts-basic-components-datepicker.md#pickertextstyle10类型说明)\\\\|[TextPickerTextStyle](#textpickertextstyle15类型说明)> | 是   | 过渡项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。<br/>当style的值为undefined时，默认值：<br/>{<br/>color: '#ff182431',<br/>font: {<br/>size: '14fp', <br/>weight: FontWeight.Regular<br/>},<br/>minFontSize: 0,<br/>maxFontSize: 0,<br/>overflow: TextOverflow.CLIP<br/>} |\",\"275\":\"\",\"276\":\"### selectedIndex<sup>10+</sup>\",\"277\":\"\",\"278\":\"selectedIndex(value: number | number[])\",\"279\":\"\"}",
      "用户拒绝的修改": "选中项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。",
      "注意事项": "修复时必须严格核对上下文术语使用场景，避免跨段落术语混淆；保持原句属性完整性，不得因参考案例缺失属性而擅自删减原始参数描述。"
    },
    {
      "defect_id": 556503,
      "sentence": "selectedTextStyle(style: Optional\\<PickerTextStyle\\|TextPickerTextStyle>)",
      "reference_sentence": "selectedTextStyle(style: Optional\\<PickerTextStyle>)",
      "line_num": 262,
      "context": "{\"257\":\"| ------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"258\":\"| style  | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<[PickerTextStyle](ts-basic-components-datepicker.md#pickertextstyle10类型说明)> | 是   | 选中项的文本颜色、字号、字体粗细。<br/>当style的值为undefined时，默认值：<br/>{<br/>color: '#ff007dff',<br/>font: {<br/>size: '20fp', <br/>weight: FontWeight.Medium<br/>}<br/>} |\",\"259\":\"\",\"260\":\"### selectedTextStyle<sup>20+</sup>\",\"261\":\"\",\"262\":\"selectedTextStyle(style: Optional\\\\<PickerTextStyle\\\\|TextPickerTextStyle>)\",\"263\":\"\",\"264\":\"设置选中项的文本颜色、字号、字体粗细、最大字号、最小字号、超长文本截断方式。\",\"265\":\"\",\"266\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"267\":\"\"}",
      "用户拒绝的修改": "selectedTextStyle(style: Optional\\<PickerTextStyle>)",
      "注意事项": "修复参数类型时必须严格区分不同API版本或组件的独立类型定义，避免将上下文中的相似类型强制统一；需特别注意联合类型（|）存在的合理性，仅在确认文档自相矛盾时才进行删除操作。"
    },
    {
      "defect_id": 556752,
      "sentence": "设置鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "获取鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "line_num": 189,
      "context": "{\"184\":\"| [int32_t OH_Input_InjectMouseEvent(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseevent) | - | 注入鼠标事件。 |\",\"185\":\"| [int32_t OH_Input_GetMouseEventDisplayId(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventdisplayid) | - | 获取鼠标事件的屏幕Id。 |\",\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\"}",
      "用户拒绝的修改": "设置鼠标事件的光标X坐标。",
      "注意事项": "保持术语一致性时需严格区分输入类型（如\"光标位置\"专用于鼠标事件，\"触摸位置\"专用于触屏事件），并完整保留关键定位信息（如\"距离主屏幕左上角\"），避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 556874,
      "sentence": "读取图片携带的EXIF元数据作为显示方向，支持旋转和镜像。",
      "reference_sentence": "图片顶部拉伸时，图片的像素值保持不变。",
      "line_num": 669,
      "context": "{\"664\":\"\",\"665\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"666\":\"\",\"667\":\"| 名称     | 值    | 说明                    |\",\"668\":\"| ------ | -------------------------- | -------------------------- |\",\"669\":\"| AUTO | 0 | 读取图片携带的EXIF元数据作为显示方向，支持旋转和镜像。<br/>PixelMap、DrawableDescriptor和Base64类型的图片不携带头信息，使用Auto解析后为UP。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_0](figures/imageRotateOrientation_0.png) |\",\"670\":\"| UP | 1 | 默认按照当前图片的像素数据进行显示，不做任何处理。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\",\"671\":\"| RIGHT | 2 | 将当前图片顺时针旋转90度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_2](figures/imageRotateOrientation_2.png) |\",\"672\":\"| DOWN | 3 | 将当前图片顺时针旋转180度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_3](figures/imageRotateOrientation_3.png) |\",\"673\":\"| LEFT | 4 | 将当前图片顺时针旋转270度后显示。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_4](figures/imageRotateOrientation_4.png) |\",\"674\":\"| UP_MIRRORED<sup>20+</sup> | 5 | 将当前图片水平翻转后显示。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。<br/>![imageRotateOrientation_5](figures/imageRotateOrientation_5.png) |\"}",
      "用户拒绝的修改": "读取图像携带的EXIF元数据作为显示方向，支持旋转和镜像。",
      "注意事项": "在统一术语前需全面检查上下文和参考句子的用词习惯，优先遵循用户原文高频词和已有术语体系，避免仅根据局部片段强行统一导致新冲突。"
    },
    {
      "defect_id": 556455,
      "sentence": "获取轴事件的位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "设置轴事件的位置距离主屏幕左上角的X坐标。",
      "line_num": 198,
      "context": "{\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\"}",
      "用户拒绝的修改": "获取轴事件的轴位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应严格遵循上下文已有术语（如统一使用\"位置\"而非\"轴位置\"），避免在同类接口描述中引入冗余限定词，需交叉验证相邻接口的表述一致性。"
    },
    {
      "defect_id": 556753,
      "sentence": "设置轴事件的位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "获取轴事件的位置距离主屏幕左上角的X坐标。",
      "line_num": 197,
      "context": "{\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\"}",
      "用户拒绝的修改": "设置轴事件的触摸位置距离主屏幕左上角的X坐标。",
      "注意事项": "严格区分事件类型专用术语差异（如\"触摸位置\"专用于TouchEvent，\"位置\"适用于AxisEvent），修复时需检查上下文确保同类型事件表述一致，避免跨类型术语混用。"
    },
    {
      "defect_id": 556453,
      "sentence": "获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "line_num": 196,
      "context": "{\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\"}",
      "用户拒绝的修改": "获取触屏事件的触屏位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应严格保持上下文已有术语一致性，优先沿用原文档高频词汇（如\"触摸位置\"），避免因近义词替换破坏已有命名规范；修改前需交叉验证相邻条目（如193/195行）确保参数命名统一性。"
    },
    {
      "defect_id": 556871,
      "sentence": "Image组件是否支持AI分析。<br/>设置为true时，Image组件支持AI分析。设置为false时，Image组件不支持AI分析。<br/>默认值：false",
      "reference_sentence": "Image组件是否支持AI分析。<br/>设置为true时，Image组件支持AI分析。设置为false时，Image组件不支持AI分析。<br/>默认值：false",
      "line_num": 475,
      "context": "{\"470\":\"\",\"471\":\"**参数：**\",\"472\":\"\",\"473\":\"| 参数名 | 类型    | 必填 | 说明                                                         |\",\"474\":\"| ------ | ------- | ---- | ------------------------------------------------------------ |\",\"475\":\"| enable  | boolean | 是   | Image组件是否支持AI分析。<br/>设置为true时，Image组件支持AI分析。设置为false时，Image组件不支持AI分析。<br/>默认值：false |\",\"476\":\"\",\"477\":\"### resizable<sup>11+</sup>\",\"478\":\"\",\"479\":\"resizable(value: ResizableOptions)\",\"480\":\"\"}",
      "用户拒绝的修改": "是否支持AI分析。<br/>设置为true时，支持AI分析。设置为false时，不支持AI分析。<br/>默认值：false",
      "注意事项": "在参数说明类技术文档中，应保留组件名称作为主语确保指代明确性，仅在上下文已明确限定范围时允许简化重复主语；删除关键限定词前需验证参数表格结构，确保跨行阅读时组件归属不产生歧义。"
    },
    {
      "defect_id": 556754,
      "sentence": "设置轴事件的位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "获取轴事件的位置距离主屏幕左上角的Y坐标。",
      "line_num": 199,
      "context": "{\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\",\"204\":\"\"}",
      "用户拒绝的修改": "设置轴事件的触摸位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应严格遵循上下文已有术语体系，核对同类事件命名一致性（如\"轴事件\"统一使用\"位置\"、\"触屏事件\"使用\"触摸位置\"），避免跨类型术语混用。"
    },
    {
      "defect_id": 556450,
      "sentence": "设置触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "获取触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "line_num": 193,
      "context": "{\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\"}",
      "用户拒绝的修改": "设置触屏事件的触屏位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应严格遵循文档现有术语体系，优先核对上下文同类接口的命名习惯（如\"触摸位置\"在获取接口已确立），避免将不同事件类型的位置描述（如\"触屏位置\"与\"鼠标光标位置\"）进行不当统一。"
    },
    {
      "defect_id": 556454,
      "sentence": "设置轴事件的位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "获取轴事件的位置距离主屏幕左上角的X坐标。",
      "line_num": 197,
      "context": "{\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触屏事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 获取触屏事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 获取轴事件的位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 获取轴事件的位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\"}",
      "用户拒绝的修改": "设置轴事件的X坐标距离主屏幕左上角的位置。",
      "注意事项": "修复时应严格遵循上下文已有术语（如统一使用\"位置\"而非\"轴位置\"），保持相邻条目表述一致性；优先保留用户原始术语结构（\"X坐标\"作核心宾语），避免改变主谓宾顺序导致语义偏移。"
    },
    {
      "defect_id": 556483,
      "sentence": "解析标签，属性及属性值，默认值undefined，表示不解析。",
      "reference_sentence": "解析属性和属性值，默认值undefined，表示不解析。",
      "line_num": 1109,
      "context": "{\"1104\":\"| supportDoctype                 | boolean                                                      | 否   | 是否解析文档类型，false表示不解析文档类型，true表示解析文档类型，默认值false。 |\",\"1105\":\"| ignoreNameSpace                | boolean                                                      | 否   | 是否忽略命名空间，忽略命名空间后，将不会对其进行解析。true表示忽略命名空间，false表示不忽略命名空间，默认值false。 |\",\"1106\":\"| tagValueCallbackFunction       | (name: string, value: string) =&gt; boolean | 否   | 解析开始标签、标签值和结束标签，默认值undefined，表示不解析。 |\",\"1107\":\"| attributeValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否   | 解析属性和属性值，默认值undefined，表示不解析。 |\",\"1108\":\"| tokenValueCallbackFunction     | (eventType: [EventType](#eventtype), value: [ParseInfo](#parseinfo)) =&gt; boolean | 否   | 解析元素事件类型([EventType](#eventtype))和[ParseInfo](#parseinfo)属性，默认值undefined，表示不解析。 |\",\"1109\":\"| attributeWithTagCallbackFunction<sup>20+</sup> | [AttributeWithTagCb](#attributewithtagcb20) | 否 |解析标签，属性及属性值，默认值undefined，表示不解析。|\",\"1110\":\"\",\"1111\":\"## ParseInfo\",\"1112\":\"\",\"1113\":\"当前XML解析信息。\",\"1114\":\"\"}",
      "用户拒绝的修改": "解析标签、属性及属性值，默认值undefined，表示不解析。",
      "注意事项": "修复时应优先保持原文的并列结构层次，若存在多级并列关系需保留\"及\"等连词区分层级；同时需结合上下文确认同类项表述方式，避免将不同语义层级的并列结构机械统一为相同标点。"
    },
    {
      "defect_id": 556947,
      "sentence": "### AsyncLockState",
      "reference_sentence": "### AsyncLockOptionsclass AsyncLockOptions<T>",
      "line_num": 471,
      "context": "{\"466\":\"| ----------- | ------------------------------------- | ---- | ---- | ------------------------------------------------------------------------------------------------------------------------- |\",\"467\":\"| isAvailable | boolean                               | 否   | 否   | 当前锁是否可用。取值为true，则只有在尚未持有锁定请求时才会授予该锁定请求；为false则表示将等待当前锁被释放。默认为 false。 |\",\"468\":\"| signal      | [AbortSignal\\\\<T>](#abortsignal)\\\\|null | 否   | 否   | 用于中止异步操作的对象。当signal.aborted为true时，锁请求将被丢弃；当signal.aborted为false时，请求会继续等待获取锁；当signal为null时，请求正常排队运行。默认为 null。               |\",\"469\":\"| timeout     | number                                | 否   | 否   | 锁操作的超时时间，单位为毫秒。若该值大于零，且操作运行时间超过该时间，[lockAsync](#lockasync)将返回被拒绝的Promise。默认为 0。      |\",\"470\":\"\",\"471\":\"### AsyncLockState\",\"472\":\"\",\"473\":\"用于存储特定异步锁实例上当前执行的所有锁操作的信息的类。\",\"474\":\"\",\"475\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"476\":\"\"}",
      "用户拒绝的修改": "#### AsyncLockState",
      "注意事项": "修复标题格式时需严格判断上下文层级结构，若原格式在文档中属于同级标题且符合统一规范（如###用于类定义），应维持现有层级而非机械匹配其他标题样式；同时需验证用户是否已通过隐性约定（如类名专用标题层级）建立特殊格式规则。"
    },
    {
      "defect_id": 556951,
      "sentence": "### AbortSignal",
      "reference_sentence": "### AsyncLockOptionsclass AsyncLockOptions<T>",
      "line_num": 502,
      "context": "{\"497\":\"| --------- | ------------------------------- | ---- | ---- | --------------------------------------------------------- |\",\"498\":\"| name      | string                          | 否   | 否   | 锁的名称。                                                |\",\"499\":\"| mode      | [AsyncLockMode](#asynclockmode) | 否   | 否   | 锁的模式。                                                |\",\"500\":\"| contextId | number                          | 否   | 否   | [AsyncLockMode](#asynclockmode)调用者的执行上下文标识符。 |\",\"501\":\"\",\"502\":\"### AbortSignal\",\"503\":\"\",\"504\":\"用于中止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。\",\"505\":\"\",\"506\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"507\":\"\"}",
      "用户拒绝的修改": "## AbortSignal",
      "注意事项": "修复标题格式时必须优先检查上下文中的现有层级结构，确保调整后的标题级别与同类条目严格一致（例如其他类定义均使用三级标题时不应降级为二级）。"
    },
    {
      "defect_id": 556983,
      "sentence": "返回 SendableMap 对象。",
      "reference_sentence": "返回 ISendableObject 对象。",
      "line_num": 730,
      "context": "{\"725\":\"**系统能力：** SystemCapability.Utils.Lang\",\"726\":\"\",\"727\":\"| 名称 | 值| 说明            |\",\"728\":\"| ------ | ------ | --------------- |\",\"729\":\"| OBJECT   | 0 |返回 SendableObject 对象。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"730\":\"| MAP<sup>13+</sup>   | 1 |返回 SendableMap 对象。<br>**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"731\":\"\",\"732\":\"### ParseOptions\",\"733\":\"\",\"734\":\"解析选项时，可定义BigInt的处理模式及解析结果的返回类型。\",\"735\":\"\"}",
      "用户拒绝的修改": "返回 ISendableObject 对象。",
      "注意事项": "进行术语替换时必须严格验证上下文中的类型对应关系，确保替换术语与上下文枚举值保持严格匹配；保持语言一致性时需优先维护原始语义完整性，避免跨类型混淆（如MAP对应SendableMap与OBJECT对应SendableObject的差异）。"
    },
    {
      "defect_id": 557429,
      "sentence": "constructor(name: string, func: Function, ...args: Object[])",
      "reference_sentence": "Task的构造函数，用于创建任务并可指定任务名称。",
      "line_num": 1013,
      "context": "{\"1008\":\"let task: taskpool.Task = new taskpool.Task(printArgs, \\\"this is my first Task\\\");\",\"1009\":\"```\",\"1010\":\"\",\"1011\":\"### constructor<sup>11+</sup>\",\"1012\":\"\",\"1013\":\"constructor(name: string, func: Function, ...args: Object[])\",\"1014\":\"\",\"1015\":\"Task的构造函数，用于创建任务并可指定任务名称。\",\"1016\":\"\",\"1017\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1018\":\"\"}",
      "用户拒绝的修改": "constructor(name: string, func: Function, ...args: Object[]) 构造函数的参数。",
      "注意事项": "保持术语一致性，避免混用中英文专业词汇（如统一使用\"构造函数\"或保持原词\"constructor\"）；修复时需结合上下文判断冗余性，参数列表本身已隐含\"构造函数参数\"属性时无需额外补充说明。"
    },
    {
      "defect_id": 557428,
      "sentence": "constructor(func: Function, ...args: Object[])",
      "reference_sentence": "Task的构造函数。",
      "line_num": 975,
      "context": "{\"970\":\"| ioDuration<sup>11+</sup>     | number    | 是   | 否   | 执行任务异步IO耗时。单位为ms。<br>**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。|\",\"971\":\"| cpuDuration<sup>11+</sup>    | number    | 是   | 否   | 执行任务CPU耗时。单位为ms。<br>**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。|\",\"972\":\"\",\"973\":\"### constructor\",\"974\":\"\",\"975\":\"constructor(func: Function, ...args: Object[])\",\"976\":\"\",\"977\":\"Task的构造函数。\",\"978\":\"\",\"979\":\"**系统能力：** SystemCapability.Utils.Lang\",\"980\":\"\"}",
      "用户拒绝的修改": "constructor(func: Function, ...args: Object[])  // Task的构造函数",
      "注意事项": "修复时必须严格保持术语一致性，优先沿用文档中已存在的表述方式；添加注释前需仔细核对上下文，避免重复解释已明确说明的概念。"
    },
    {
      "defect_id": 557297,
      "sentence": "> 自定义弹窗内在拉另一个自定义弹窗时，不推荐将拉起方直接消失。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\">\",\"18\":\"> 自定义弹窗的所有参数，不支持动态刷新。\",\"19\":\">\",\"20\":\"> 在CustomDialogController作为全局变量以实现全局自定义弹窗的场景下，若对controller重新赋值，则无法通过其关闭之前的弹窗。建议在重新赋值前先关闭弹窗。\",\"21\":\">\",\"22\":\"> 自定义弹窗内在拉另一个自定义弹窗时，不推荐将拉起方直接消失。\",\"23\":\"\",\"24\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"25\":\"\",\"26\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"27\":\"\"}",
      "用户拒绝的修改": "> 自定义弹窗内在拉另一个自定义弹窗时，不推荐直接关闭拉起方。",
      "注意事项": "保持技术术语一致性时应优先使用上下文明确定义的动词（如\"关闭\"需关联controller操作），避免脱离技术场景的同义词替换；修改时需核实在文档体系内是否存在特定动作的规范性表述。"
    },
    {
      "defect_id": 557862,
      "sentence": "用户点击图标启动应用场景动效开始点，由离手事件LAST_UP触发。",
      "reference_sentence": "用户点击图标启动应用场景动效结束点。",
      "line_num": 66,
      "context": "{\"61\":\"| startInputType | [ActionType](#actiontype)| 是 | 用户场景触发模式。 |\",\"62\":\"| note | string| 否 | 用户场景备注信息。字符串长度无限制，建议控制在255个字符以内，可以空缺不填，填写后性能指标上报会携带备注信息，不填无影响。 |\",\"63\":\"\",\"64\":\"**示例：** \",\"65\":\"\",\"66\":\"用户点击图标启动应用场景动效开始点，由离手事件LAST_UP触发。\",\"67\":\"  ```ts\",\"68\":\"performanceMonitor.begin(\\\"LAUNCHER_APP_LAUNCH_FROM_ICON\\\", performanceMonitor.ActionType.LAST_UP, \\\"APP_START_BEGIN\\\");\",\"69\":\"  ```\",\"70\":\"\",\"71\":\"\"}",
      "用户拒绝的修改": "用户点击图标启动应用场景动效，由离手事件LAST_UP触发。",
      "注意事项": "修复时必须严格检查上下文中的成对术语使用场景（如\"开始点/结束点\"），保留技术文档中具有明确对应关系的核心定位词，避免因过度简化破坏关键参数的一致性表述。"
    }
  ],
  "反面示例": [
    {
      "defect_id": 21773,
      "sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "reference_sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "line_num": 32,
      "context": "",
      "修改建议": "重复了相同的句子",
      "更改后示例": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径。获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "触发条件": "当相邻语句存在重复的短语结构（如\"获取方式及其接口用法请参考\"连续重复）或信息冗余时触发，通过检测相邻文本段落的句式重复率超过阈值（如连续重复率>70%）进行识别。"
    },
    {
      "defect_id": 37120,
      "sentence": "获取当前应用中指定的module的overlayModuleInfo信息。使用callback异步回调，成功返回null，失败返回对应错误信息。",
      "reference_sentence": "设置当前应用中overlay module的禁用使能状态。使用callback异步回调。成功返回null，失败返回对应错误信息。",
      "line_num": 174,
      "context": "",
      "修改建议": "混用了`overlay module`和`module`描述不一致",
      "更改后示例": "获取当前应用中指定的overlay module的overlayModuleInfo信息。使用callback异步回调，成功返回null，失败返回对应错误信息。",
      "触发条件": "当同一术语在相邻描述中存在全称/简称混用（如\"overlay module\" vs \"module\"），且存在已定义的完整术语形式（参考句中的\"overlay module\"）时，应触发一致性检查。"
    },
    {
      "defect_id": 13000,
      "sentence": "HSP不支持在设备上单独安装/运行，需要与依赖该HSP的HAP一起安装/运行。HAP的版本号须大于等于HSP版本号。",
      "reference_sentence": "原文",
      "line_num": 19,
      "context": "",
      "修改建议": "混用了“安装/运行”和“安装/运行”格式不一致，建议统一。",
      "更改后示例": "HSP不支持在设备上单独安装或运行，需要与依赖该HSP的HAP一起安装或运行。HAP的版本号须大于等于HSP版本号。",
      "触发条件": "同一术语/短语在相邻或相近位置重复出现时，存在连接符号（如\"/\"）与连接词（如\"或\"）混用的情况，或相同语义内容呈现两种以上表达形式。\n\n识别模式：检测重复出现的核心术语（如\"安装/运行\"）是否存在以下特征：\n1. 同一语义单元使用不同分隔符（如\"/\"与\"或\"交替出现）\n2. 相同功能描述存在结构差异（如\"安装/运行\"与\"安装或运行\"并存）\n3. 相邻语句中重复术语的表达形式不统一"
    },
    {
      "defect_id": 13001,
      "sentence": "对外暴露的接口，需要在入口文件`index.ets`中声明：",
      "reference_sentence": "原文",
      "line_num": 72,
      "context": "",
      "修改建议": "“对外暴露的接口”重复出现，建议统一。",
      "更改后示例": "对外暴露的接口，需要在入口文件`index.ets`中声明。",
      "触发条件": "相邻句子或同一语境中重复使用相同名词短语，且未通过代词/省略保持上下文连贯性。  \n\n识别模式：  \n1. 检测相邻句子间存在完全重复的关键性名词短语（如\"对外暴露的接口\"）  \n2. 确认重复内容处于同一逻辑层级（如并列说明/连续操作步骤），且未产生强调意图的特殊修辞需求"
    },
    {
      "defect_id": 22022,
      "sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：",
      "reference_sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "line_num": 17,
      "context": "",
      "修改建议": "重复了相同的句子，导致冗余。",
      "更改后示例": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "触发条件": "当文档中重复出现相同功能说明语句，且存在包含规范引用链接的标准版本时；或当同一操作指引存在冗余表述但缺少必要参考信息时。  \n\n识别模式：通过文本相似度检测匹配重复句式结构，结合引用链接缺失分析（如\"[...]\"占位符或未标注的参考路径），识别需要替换为标准化表述的冗余内容。"
    },
    {
      "defect_id": 19953,
      "sentence": "在onConnect回调里接收到代理对象，调用proxy对象的[sendMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#sendmessagerequest9-2)方法发起请求给服务端",
      "reference_sentence": "在onConnect回调里接收到代理对象，调用proxy对象的[sendMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#sendmessagerequest9-2)方法发起请求给服务端",
      "line_num": 155,
      "context": "",
      "修改建议": "混用了'代理对象'与'proxy对象'概念",
      "更改后示例": "在onConnect回调里接收到代理对象，调用代理对象的[sendMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#sendmessagerequest9-2)方法发起请求给服务端",
      "触发条件": "同一文档中针对同一技术概念出现中英文术语混用（如\"代理对象\"与\"proxy对象\"），且存在已确立的标准术语时触发；或同一段落内对同一实体使用两种及以上不同表达形式时触发。"
    },
    {
      "defect_id": 12283,
      "sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径，获取方式及其接口用法请参考：",
      "reference_sentence": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径。表示沙箱路径的字符串称为path，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "line_num": 17,
      "context": "",
      "修改建议": "前后两句重复，且第二句提供了更详细的说明，建议删除第一句。",
      "更改后示例": "使用该功能模块对文件/目录进行操作前，需要先获取其应用沙箱路径。表示沙箱路径的字符串称为path，获取方式及其接口用法请参考：[应用上下文Context-获取应用文件路径](../../application-models/application-context-stage.md#获取应用文件路径)。",
      "触发条件": "当相邻句子/段落出现重复性说明，且后续内容包含更详细的技术术语或补充说明时，需删除冗余的前置描述。识别模式为：1) 前句为概括性描述 2) 后句复用前句核心概念（如\"应用沙箱路径\"）并追加技术细节（如变量命名、接口链接）。"
    },
    {
      "defect_id": 37119,
      "sentence": "获取当前应用中指定的module的overlayModuleInfo信息。使用promise异步回调，成功返回null，失败返回对应错误信息。",
      "reference_sentence": "设置当前应用中overlay特征module的禁用使能状态。使用Promise异步回调。成功返回null，失败返回对应错误信息。",
      "line_num": 123,
      "context": "",
      "修改建议": "混用了`promise`和`Promise`大小写不一致",
      "更改后示例": "获取当前应用中指定的module的overlayModuleInfo信息。使用Promise异步回调，成功返回null，失败返回对应错误信息。",
      "触发条件": "同一技术术语（如Promise）在文档中出现大小写不一致（如promise/Promise）或存在与参考规范/上下文不符的拼写变体时触发。\n\n识别模式：\n1. 检测技术专有名词（如API类型Promise）是否遵循驼峰命名规范\n2. 对比上下文同类语句（如参考句中的\"使用Promise\"）进行术语一致性校验\n3. 匹配预定义的技术术语字典（如JavaScript规范术语库）验证拼写准确性"
    },
    {
      "defect_id": 13152,
      "sentence": "调整可读流偏置指针位置。",
      "reference_sentence": "调整可读流偏置指针位置。",
      "line_num": 6113,
      "context": "",
      "修改建议": "同一段落中，'偏置指针'和'偏移指针'混用，可能引起混淆",
      "更改后示例": "调整可读流偏移指针位置。",
      "触发条件": "同一段落或相邻上下文中出现相同技术术语的不同表达形式（如\"偏置指针\"与\"偏移指针\"），且存在术语混淆风险时。\n\n识别模式：通过文本匹配检测关键参数/操作对象（如\"指针\"）前的修饰词（如\"偏置/偏移\"）在相邻语句中的一致性，结合技术领域词典识别同义/近义术语混用情况。当同一核心名词的修饰词在局部语境中存在≥2种不同表达时触发规则。"
    },
    {
      "defect_id": 10180,
      "sentence": "清空页面栈中的所有历史页面，仅保留当前页面作为栈顶页面。",
      "reference_sentence": "跳转到应用内的指定页面。",
      "line_num": 217,
      "context": "",
      "修改建议": "使用了不同的动词描述页面的导航操作，'清空'与'跳转'用词不一致。",
      "更改后示例": "跳转并清空页面栈中的所有历史页面，仅保留当前页面作为栈顶页面。",
      "触发条件": "同一操作步骤或相邻步骤中描述导航或页面管理动作时，存在多个不同动词（如“清空”与“跳转”），且上下文未明确区分其差异性。\n\n识别模式：\n1. **动词冲突检测**：检查同一功能描述中是否混用不同动作动词（如“清空”“跳转”“关闭”等），尤其关注是否与参考规范（如“跳转到...”）冲突；\n2. **上下文连贯性验证**：若操作涉及连续动作（如“跳转+清空”），需验证动词组合是否符合统一逻辑，避免单一动作被拆分描述。"
    },
    {
      "defect_id": 19951,
      "sentence": "获取服务代理proxy",
      "reference_sentence": "获取服务代理proxy",
      "line_num": 77,
      "context": "",
      "修改建议": "混用了'代理'与'代理对象'概念",
      "更改后示例": "获取服务代理对象proxy",
      "触发条件": "同一上下文或相邻语句中，同一概念出现术语混用（如\"代理\"与\"代理对象\"交替出现），且未在文档中明确定义为同义词时触发。"
    },
    {
      "defect_id": 37121,
      "sentence": "指定当前应用中的overlay module的名称。",
      "reference_sentence": "overlay特征module的名称。",
      "line_num": 131,
      "context": "",
      "修改建议": "混用了`overlay module`和`overlay特征module`描述不一致",
      "更改后示例": "指定当前应用中的overlay特征module的名称。",
      "触发条件": "同一术语在相邻或相关句子中存在不一致表达（如缺失修饰词、缩写差异），且已有参考句子明确定义了标准表达形式。\n\n识别模式：检测上下文中同一概念是否出现不同变体（如\"overlay module\" vs \"overlay特征module\"），并对比参考句子或规范术语进行一致性验证。当术语结构差异涉及核心语义元素（如\"特征\"修饰词缺失）时触发修复。"
    },
    {
      "defect_id": 37057,
      "sentence": "根据系统已定义的应用类型或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型判断当前应用是否是该类型的默认应用，使用Promise异步回调。",
      "reference_sentence": "## defaultAppManager.isDefaultApplication(type: string): Promise<boolean>",
      "line_num": 37,
      "context": "",
      "修改建议": "句式不一致，前文使用祈使句，此处使用陈述句",
      "更改后示例": "根据系统已定义的应用类型或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型，判断当前应用是否是该类型的默认应用，使用Promise异步回调。",
      "触发条件": "同一段落内存在混合句式（祈使句与陈述句交替使用），且动词位置/标点符号不匹配文档既定规范。当描述操作步骤的句子出现主语显性化（如\"使用Promise\"前出现隐性主语）或句尾标点（句号）破坏操作指引连贯性时触发。"
    },
    {
      "defect_id": 22024,
      "sentence": "Promise对象。返回文件的哈希值。表示为十六进制数字串，所有字母均大写。",
      "reference_sentence": "异步计算文件哈希操作之后的回调函数（其中给定文件哈希值表示为十六进制数字串，所有字母均大写）。",
      "line_num": 54,
      "context": "",
      "修改建议": "描述相同信息时，用词不一致，'返回文件的哈希值'与'给定文件哈希值'。",
      "更改后示例": "Promise对象。返回文件的哈希值，表示为十六进制数字串，所有字母均大写。",
      "触发条件": "同一文档或相邻段落中，对同一操作或概念的描述存在术语、动词或句式不一致（如“返回”与“给定”混用，分句结构差异）。"
    },
    {
      "defect_id": 19952,
      "sentence": "通过proxy可以发送信息给服务端",
      "reference_sentence": "通过proxy可以发送信息给服务端",
      "line_num": 155,
      "context": "",
      "修改建议": "混用了'代理'与'代理对象'概念",
      "更改后示例": "通过代理对象proxy可以发送信息给服务端",
      "触发条件": "同一技术术语在相邻上下文中出现中文全称/简称与英文缩写混用，或同一概念存在多个中文译名交替使用的情况。识别模式为：1) 在3个句子范围内检测到同一术语存在两种及以上表达形式（如\"代理\"和\"代理对象\"）；2) 英文缩写首次出现时未标注中文对应词。"
    },
    {
      "defect_id": 19954,
      "sentence": "服务端被绑定的Ability在onConnect方法里返回继承自[rpc.RemoteObject](../reference/apis-ipc-kit/js-apis-rpc.md#remoteobject)的对象",
      "reference_sentence": "服务端被绑定的Ability在onConnect方法里返回继承自[rpc.RemoteObject](../reference/apis-ipc-kit/js-apis-rpc.md#remoteobject)的对象",
      "line_num": 191,
      "context": "",
      "修改建议": "混用了'服务端'与'服务端'概念，但存在用词不一致",
      "更改后示例": "服务端在onConnect方法里返回继承自[rpc.RemoteObject](../reference/apis-ipc-kit/js-apis-rpc.md#remoteobject)的对象",
      "触发条件": "同一句子中主语存在冗余修饰成分（如\"被绑定的\"）导致表达累赘，且该修饰成分在上下文未提供有效区分信息时；或同一技术主体在相邻表述中出现结构不一致（如\"服务端被绑定的Ability\"与\"服务端\"交替使用）时。"
    },
    {
      "defect_id": 37129,
      "sentence": "获取指定的目标module的OverlayModuleInfo。",
      "reference_sentence": "获取当前应用中指定的module的overlayModuleInfo信息。",
      "line_num": 223,
      "context": "",
      "修改建议": "术语不一致，应保持与上文的一致性",
      "更改后示例": "获取当前应用中指定的目标module的overlayModuleInfo信息。",
      "触发条件": "当文档中出现相同技术术语存在大小写不一致（如驼峰式与全小写混用）或修饰词冗余/缺失（如\"目标module\"与\"module\"）时，应触发该规则。具体表现为同一实体在相邻描述中出现不同命名形态（如OverlayModuleInfo与overlayModuleInfo），或上下文限定词不匹配（如缺少\"当前应用中\"的时空范围描述）。\n\n识别模式：\n1. 通过驼峰格式检测和全小写术语对比识别大小写不一致\n2. 基于依存句法分析提取核心名词短语，比对修饰词（如\"目标\"）的存在性差异\n3. 结合前文建立的上下文框架（如\"当前应用中\"），验证后续语句的限定词完整性"
    },
    {
      "defect_id": 12285,
      "sentence": "获取文件详细属性信息，使用Promise异步返回。",
      "reference_sentence": "获取文件详细属性信息，使用callback异步回调。",
      "line_num": 38,
      "context": "",
      "修改建议": "前后两段描述了相同的功能，但用词不一致，建议统一。",
      "更改后示例": "获取文件详细属性信息，使用Promise异步方式返回。",
      "触发条件": "同一功能点出现术语结构不一致（如\"异步返回\"与\"异步方式返回\"）或相邻语句存在相同功能的差异化表达（如\"Promise异步返回\"与\"callback异步回调\"并列时结构不匹配）。"
    },
    {
      "defect_id": 22500,
      "sentence": "以同步方法设置应用的处置状态。成功返回null，失败抛出对应异常。",
      "reference_sentence": "设置应用的处置状态。使用Promise异步回调。成功返回null，失败返回对应错误信息。",
      "line_num": 139,
      "context": "",
      "修改建议": "句式不一致，前文使用了'使用Promise异步回调'，而这里使用了'以同步方法'，且'失败返回对应错误信息'与'失败抛出对应异常'描述不一致。",
      "更改后示例": "以同步方法设置应用的处置状态。成功返回null，失败返回对应错误信息。",
      "触发条件": "同一功能描述中动词结构不一致（如\"返回\"与\"抛出\"）或技术术语矛盾（如\"同步\"与\"异步\"）时触发。\n\n识别模式：\n1. 检查相邻句子/段落中操作结果描述动词的匹配性（如成功/失败应统一使用\"返回\"或\"抛出\"）\n2. 验证技术实现方式描述的一致性（如异步回调与同步方法不应共存于同一功能模块描述）\n3. 对比错误处理方式的对称性（异常抛出与信息返回需保持统一表达范式）"
    },
    {
      "defect_id": 22629,
      "sentence": "删除应用的处置状态。使用promise异步回调，成功返回null，失败返回对应错误信息。",
      "reference_sentence": "获取指定应用的处置状态。使用callback异步回调，成功返回应用的处置状态，失败返回对应错误信息。",
      "line_num": 355,
      "context": "",
      "修改建议": "使用了不同的词汇描述异步回调，`promise` 与 `callback` 混用",
      "更改后示例": "删除应用的处置状态。使用Promise异步回调，成功返回null，失败返回对应错误信息。",
      "触发条件": "同一技术概念出现大小写不一致（如promise/Promise）或术语混用（如Promise/callback），且上下文存在已确立的标准术语参照"
    },
    {
      "defect_id": 23664,
      "sentence": "用于获取包含skills的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE、GET_BUNDLE_INFO_WITH_ABILITY、GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY一起使用。",
      "reference_sentence": "GET_BUNDLE_INFO_WITH_SKILL<sup>12+</sup>",
      "line_num": 48,
      "context": "",
      "修改建议": "使用了'skills'，而其他地方使用了'skill'，应保持一致。",
      "更改后示例": "用于获取包含skill的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE、GET_BUNDLE_INFO_WITH_ABILITY、GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY一起使用。",
      "触发条件": "同一术语在文档中单复数形式不一致，或与预定义常量命名（如全大写格式）存在单复数、词形不匹配时触发。"
    },
    {
      "defect_id": 37105,
      "sentence": "设置当前应用中overlay module的禁用使能状态。",
      "reference_sentence": "设置当前应用中overlay特征module的禁用使能状态。",
      "line_num": 73,
      "context": "",
      "修改建议": "同一概念在文中使用了不同的表述，'module' 和 '特征module'。",
      "更改后示例": "设置当前应用中overlay特征module的禁用使能状态。",
      "触发条件": "当同一术语在文档不同位置出现修饰词不一致（如\"module\"与\"特征module\"），或与参考句中的标准表述存在结构性差异时触发。\n\n识别模式：\n1. 核心术语匹配：通过词干提取识别相同核心词（如\"module\"）\n2. 修饰成分对比：检测前置定语（如\"特征\"）的存在/缺失\n3. 上下文关联验证：确认术语指代相同技术概念\n4. 参考句对齐：对比文档既定表述规范（如参考句中的完整形态）"
    },
    {
      "defect_id": 12785,
      "sentence": "目的文件的应用沙箱路径。",
      "reference_sentence": "目标文件夹的应用沙箱路径。",
      "line_num": 3361,
      "context": "",
      "修改建议": "用词不一致，前面用的是“目标文件夹”，这里改为了“目的文件”。",
      "更改后示例": "目标文件的应用沙箱路径。",
      "触发条件": "同一文档中出现相同概念使用不同术语（如\"目标\"与\"目的\"混用），或同一术语存在不一致变体（如\"文件夹\"与\"文件\"未保持单复数/类型统一）。\n\n识别模式：通过比对文档术语库和相邻上下文，检测到以下情况时触发规则：\n1. 核心概念词在有效作用域内（同一章节/功能描述域）出现同义词替换\n2. 复合术语的构成要素（如\"目标+文件夹\"与\"目的+文件\"）发生非必要组合变异\n3. 存在术语词根一致但衍生词型不匹配（如\"目标文件夹\"与\"目的文件\"中的\"目标-目的\"词根冲突）"
    },
    {
      "defect_id": 22730,
      "sentence": "appIdentifier  | string | 是    | 要设置卸载处置规则的应用的appIdentifier。<br> 如果应用没有appIdentifier可使用appId代替。appId是应用的唯一标识，由应用Bundle名称和签名信息决定，获取方法参见[获取应用的appId](#获取应用的appid)。",
      "reference_sentence": "appId  | string | 是    | 要获取拦截规则的应用的appId。<br> appId是应用的唯一标识，由应用Bundle名称和签名信息决定，获取方法参见[获取应用的appId](#获取应用的appid)。",
      "line_num": 679,
      "context": "",
      "修改建议": "混用了`appIdentifier`和`appId`概念，导致术语不一致。",
      "更改后示例": "appIdentifier  | string | 是    | 要设置卸载处置规则的应用的appId。<br> 如果应用没有appId可使用appIdentifier代替。appId是应用的唯一标识，由应用Bundle名称和签名信息决定，获取方法参见[获取应用的appId](#获取应用的appid)。",
      "触发条件": "同一概念在文档中使用了两种及以上不同术语表述，且未在上下文中明确说明其等价性或差异性时触发。\n\n识别模式：通过对比参数名称、字段说明和参考文档，检测是否存在术语混用（如案例中appIdentifier与appId交替使用）、参数说明与定义段落术语不匹配（如参数名称为appId但说明中引用appIdentifier）等情况。"
    },
    {
      "defect_id": 22748,
      "sentence": "The specified bundleName of want is not the same with caller.",
      "reference_sentence": "无",
      "line_num": 695,
      "context": "",
      "修改建议": "该错误信息中使用了'bundleName'，而上文中使用的是'appId'，导致用词不一致。",
      "更改后示例": "The specified appId of want is not the same with caller.",
      "触发条件": "同一文档中，存在多个术语指代同一概念且上下文未统一用词；或关键术语与已定义/前文使用不一致。"
    },
    {
      "defect_id": 24098,
      "sentence": "表示用于指定将返回的ExtensionInfo对象中包含的信息的标志。",
      "reference_sentence": "表示用于指定将返回的ExtensionAbilityInfo对象中包含的信息的标志。",
      "line_num": 1256,
      "context": "",
      "修改建议": "混用了`ExtensionInfo`和`ExtensionAbilityInfo`概念",
      "更改后示例": "表示用于指定将返回的ExtensionAbilityInfo对象中包含的信息的标志。",
      "触发条件": "当同一技术文档中交替使用多个相似术语（如ExtensionInfo/ExtensionAbilityInfo）指代同一技术概念，且存在权威参考依据（如API规范或官方文档）时触发。识别模式：通过术语词根匹配（如\"Extension*Info\"）检测相似术语变体，并与上下文/参考文档进行概念映射验证。"
    },
    {
      "defect_id": 22746,
      "sentence": "Permission denied. A non-system application is not allowed to call a system API.",
      "reference_sentence": "Permission denied.",
      "line_num": 690,
      "context": "",
      "修改建议": "混用了'Permission denied.'和'Permission denied. A non-system application is not allowed to call a system API.'，导致用词不一致。",
      "更改后示例": "Permission denied.",
      "触发条件": "同一文档或上下文中存在多个表达相同核心信息的变体（如完整版与缩写版），或相邻语句出现重复信息但表述形式不一致。  \n\n识别模式：  \n1. 核心信息重复检测：通过语义分析识别同一段落/章节中重复表达相同概念（如错误类型、操作提示）但用词/句式不同的句子  \n2. 结构对比识别：当短句式表达与长句式解释同时出现且包含相同关键词（如案例中的\"Permission denied\"）时触发"
    },
    {
      "defect_id": 23662,
      "sentence": "用于获取包含fileContextMenuConfig的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE一起使用。",
      "reference_sentence": "GET_BUNDLE_INFO_WITH_MENU<sup>11+</sup>",
      "line_num": 46,
      "context": "",
      "修改建议": "使用了'fileContextMenuConfig'，而其他地方使用了'file context menu config'，应保持一致。",
      "更改后示例": "用于获取包含file context menu config的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE一起使用。",
      "触发条件": "当同一技术术语在文档中存在驼峰命名与空格分隔的混合写法（例如\"fileContextMenuConfig\"和\"file context menu config\"），且参考句子/已有规范明确使用其中一种格式时触发。识别模式需检测代码符号与自然语言描述中同一概念的不同格式变体。"
    },
    {
      "defect_id": 22793,
      "sentence": "如果应用没有appIdentifier可使用appId代替。appId是应用的唯一标识，由应用Bundle名称和签名信息决定，删除方法参见[获取应用的appId](#获取应用的appid)。",
      "reference_sentence": "如果应用没有appIdentifier可使用appId代替。appId是应用的唯一标识，由应用Bundle名称和签名信息决定，设置方法参见[获取应用的appId](#获取应用的appid)。",
      "line_num": 795,
      "context": "",
      "修改建议": "混用了'设置方法'和'删除方法'，应保持一致性。",
      "更改后示例": "如果应用没有appIdentifier可使用appId代替。appId是应用的唯一标识，由应用Bundle名称和签名信息决定，设置方法参见[获取应用的appId](#获取应用的appid)。",
      "触发条件": "当同一上下文或相邻段落中出现指向相同参考链接但使用不一致的动作术语（如\"设置方法\"和\"删除方法\"）时触发。\n\n识别模式：\n1. 检测相邻语句中描述同类操作的动作动词（设置/删除/获取等）\n2. 验证关联的参考链接是否指向同一目标\n3. 对比当前动词与上下文/参考句中的标准术语一致性\n4. 当动词与既定术语产生语义冲突（如用\"删除\"指向创建型操作）时标记异常"
    },
    {
      "defect_id": 23680,
      "sentence": "用于获取默认extensionAbilityInfo。获取的extensionAbilityInfo不包含permission、metadata 和禁用的abilityInfo。",
      "reference_sentence": "用于获取默认abilityInfo，获取的abilityInfo不包含permission、metadata和禁用的abilityInfo。",
      "line_num": 97,
      "context": "",
      "修改建议": "混用了'extensionAbilityInfo'和'abilityInfo'概念",
      "更改后示例": "用于获取默认extensionAbilityInfo。获取的extensionAbilityInfo不包含permission、metadata和禁用的abilityInfo。",
      "触发条件": "当同一术语在相邻句子或同一段落中出现不同表述（如\"extensionAbilityInfo\"与\"abilityInfo\"混用），且未在上下文中明确定义为不同概念时触发；或当技术名词存在冗余变体形式（如全称与未定义的简称交替出现）时触发。"
    },
    {
      "defect_id": 23663,
      "sentence": "用于获取包含routerMap的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE一起使用。",
      "reference_sentence": "GET_BUNDLE_INFO_WITH_ROUTER_MAP<sup>12+</sup>",
      "line_num": 47,
      "context": "",
      "修改建议": "使用了'routerMap'，而其他地方使用了'router map'，应保持一致。",
      "更改后示例": "用于获取包含router map的bundleInfo。它不能单独使用，需要与GET_BUNDLE_INFO_WITH_HAP_MODULE一起使用。",
      "触发条件": "当同一术语在文档中存在驼峰式（routerMap）和空格分隔（router map）两种不同表达形式时，或与预定义术语表/已有API命名（如GET_BUNDLE_INFO_WITH_ROUTER_MAP）存在格式冲突时触发。\n\n识别模式：通过对比文档中同一术语的命名形式（如大小写、连字符、空格使用），检测是否存在不一致的变体；同时校验术语是否与系统预定义格式（如接口命名规范、术语表）保持统一。"
    },
    {
      "defect_id": 24058,
      "sentence": "| extensionAbilityFlags | [number](#extensionabilityflag)                              | 是   | 表示用于指定将返回的ExtensionInfo对象中包含的信息的标志。    |",
      "reference_sentence": "| abilityFlags | [number](#abilityflag) | 是   | 表示指定返回的AbilityInfo所包含的信息。 |",
      "line_num": 1256,
      "context": "",
      "修改建议": "参数类型和说明不一致",
      "更改后示例": "| extensionAbilityFlags | [number](#abilityflag) | 是   | 表示指定返回的ExtensionAbilityInfo所包含的信息。 |",
      "触发条件": "当参数类型标识符（如#abilityflag）与对应说明中的对象名称（如ExtensionAbilityInfo）存在关键字不匹配，或参数名与说明中的对象名未遵循相同命名模式（如*Flags对应*Info）时触发。\n\n识别模式：\n1. 检查参数类型锚点(#xxx)是否包含与说明对象名强关联的核心词（如abilityFlag对应AbilityInfo）\n2. 验证参数名后缀(Flags)是否与说明中的对象名后缀(Info)形成固定搭配模式\n3. 对比相邻同类参数描述，识别命名范式差异（参考句子abilityFlags→AbilityInfo的对应关系）"
    },
    {
      "defect_id": 24143,
      "sentence": "根据给定的bundleName和appIndex清理BundleCache，使用Promise异步回调。",
      "reference_sentence": "根据给定的bundleName清理BundleCache，使用Promise异步回调。",
      "line_num": 2066,
      "context": "",
      "修改建议": "混用了'bundleName'和'bundleName和appIndex'，导致描述不一致。",
      "更改后示例": "根据给定的bundleName和appIndex清理应用缓存数据，使用Promise异步回调。",
      "触发条件": "当同一句子中参数列表与操作描述的关键术语存在数量/范围不一致(如\"bundleName和appIndex\"对应\"BundleCache\")，或同一概念使用不同术语表达(如\"BundleCache\"与\"应用缓存数据\")时触发。"
    },
    {
      "defect_id": 24156,
      "sentence": "设置指定应用或分身应用的禁用或使能状态，使用Promise异步回调。",
      "reference_sentence": "设置指定应用的禁用或使能状态，使用callback异步回调。",
      "line_num": 2236,
      "context": "",
      "修改建议": "描述不一致，前文使用了callback异步回调，此处使用Promise异步回调",
      "更改后示例": "设置指定应用或分身应用的禁用或使能状态，使用callback异步回调。",
      "触发条件": "当同一文档中出现相同功能描述但使用不同异步回调术语（如\"callback\"与\"Promise\"混用），且存在上下文已确立的固定表达方式时触发。识别模式：通过对比当前术语与参考句/前文术语的一致性，检测到相同操作场景下异步机制表述冲突时需修复。"
    },
    {
      "defect_id": 24155,
      "sentence": "设置指定应用的禁用或使能状态，使用Promise异步回调。",
      "reference_sentence": "设置指定应用的禁用或使能状态，使用callback异步回调。",
      "line_num": 2180,
      "context": "",
      "修改建议": "描述不一致，前文使用了callback异步回调，此处使用Promise异步回调",
      "更改后示例": "设置指定应用的禁用或使能状态，使用callback异步回调。",
      "触发条件": "当同一技术术语（如\"callback\"与\"Promise\"）在文档中混合使用指代同一概念，且存在前文已确立的固定表达形式时触发。需通过术语库比对和上下文一致性检查识别矛盾表达。"
    },
    {
      "defect_id": 23669,
      "sentence": "用于获取包含禁用应用程序的applicationInfo。",
      "reference_sentence": "用于获取application被禁用的BundleInfo和被禁用的Ability信息。",
      "line_num": 66,
      "context": "",
      "修改建议": "混用了'应用程序'和'application'，且'禁用'与'被禁用'用词不一致",
      "更改后示例": "用于获取包含禁用的applicationInfo的applicationInfo。",
      "触发条件": "同一术语存在中英文混用（如“应用程序”与“application”），或同一状态描述存在主动/被动语态不一致（如“禁用”与“被禁用”）。需通过词性标注和术语映射表检测相邻成分中的用词冲突。"
    },
    {
      "defect_id": 23661,
      "sentence": "允许查询应用的基本信息和其他敏感信息。",
      "reference_sentence": "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
      "line_num": 22,
      "context": "",
      "修改建议": "使用了'基本信息'，而其他地方使用了'应用信息'，应保持一致。",
      "更改后示例": "允许查询应用信息和其他敏感信息。",
      "触发条件": "同一术语或短语在文档中存在多种变体（如“应用信息”与“基本信息”），或与预定义参考术语（如权限名称中的核心词汇）不一致时触发。\n\n识别模式：\n1. **术语变体检测**：识别同一上下文中描述同一概念的多个近义词（如“应用信息”/“基本信息”）。\n2. **参考术语匹配**：对比文档中的术语与外部参考词汇（如权限名称、API接口名），发现不一致时标记（如参考词为“GET_BUNDLE_INFO”时，需统一使用“应用信息”而非“基本信息”）。"
    },
    {
      "defect_id": 23985,
      "sentence": "根据给定的want、abilityFlags和userId获取一个或多个AbilityInfo，使用Promise异步回调。",
      "reference_sentence": "根据给定的want、abilityFlags和userId获取多个AbilityInfo，使用callback异步回调。",
      "line_num": 996,
      "context": "",
      "修改建议": "异步回调方式不一致，前文使用了callback，后文使用了Promise",
      "更改后示例": "根据给定的want、abilityFlags和userId获取一个或多个AbilityInfo，使用callback异步回调。",
      "触发条件": "当同一技术概念在相邻语句中使用了两种及以上不同术语表述（如\"callback\"和\"Promise\"），且上下文未明确说明技术差异时触发。\n\n识别模式：\n1. 技术术语对比：检测关键操作描述中是否出现同功能不同术语（如异步机制：callback/Promise/async/await）\n2. 参数一致性验证：检查参数描述与接口实际使用方式是否匹配（如\"使用callback异步回调\"但参数类型是Promise）\n3. 上下文参照：通过参考句子/前文已建立的术语标准（如参考句已使用\"callback\"）识别后续不一致表述"
    },
    {
      "defect_id": 22747,
      "sentence": "The specified appIdentifier is invalid.",
      "reference_sentence": "The specified app ID is an empty string.",
      "line_num": 694,
      "context": "",
      "修改建议": "混用了'app ID'和'appIdentifier'，导致用词不一致。",
      "更改后示例": "The specified appIdentifier is an empty string.",
      "触发条件": "同一文档或上下文中出现同一概念的多个术语变体（如全称/缩写、不同命名格式），且未遵循统一用词规范。\n\n识别模式：\n1. **术语变体检测**：通过正则表达式或术语库匹配同一概念的不同表达形式（例如 `appIdentifier` vs `app ID`，驼峰式与空格分隔式）。\n2. **上下文对比**：检查文档中其他位置是否已存在高频使用的标准术语（如参考句中的 `app ID`），判定当前非常用变体为不一致。"
    },
    {
      "defect_id": 24175,
      "sentence": "设置指定应用或分身应用组件的禁用或使能状态，使用Promise异步回调。",
      "reference_sentence": "设置指定组件的禁用或使能状态，使用Promise异步回调。",
      "line_num": 2478,
      "context": "",
      "修改建议": "描述中混用了“指定应用或分身应用组件”和“指定组件”，建议统一为“指定组件”",
      "更改后示例": "设置指定组件的禁用或使能状态，使用Promise异步回调。",
      "触发条件": "同一描述中针对同一技术概念出现多个不一致的术语表达(如\"指定应用或分身应用组件\"与\"指定组件\")，或存在冗余的限定词修饰时触发。\n\n识别模式：\n1. 检测相邻语句/段落中是否存在重复概念的不同命名形式\n2. 识别包含逻辑包含关系的冗余修饰词(如\"应用或分身应用\"可被上级概念\"指定组件\"覆盖)\n3. 验证核心术语是否与API接口定义/技术规范中的官方命名保持一致"
    },
    {
      "defect_id": 23659,
      "sentence": "本模块首批接口从API version 9 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "本模块首批接口从API version 9 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "line_num": 7,
      "context": "",
      "修改建议": "混用了'API version'和'API version 9'的表述，应保持一致。",
      "更改后示例": "本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "触发条件": "同一术语在文档中存在多种格式变体（如\"API version\"与\"API version X\"混用）或数字连接方式不一致（如空格使用差异）时触发。\n\n识别模式：\n1. 检测同一术语链中是否出现\"术语+空格+数字\"与\"术语+数字\"两种格式共存\n2. 验证数字与前置术语的间距是否符合既定规范（通过上下文对比发现\"API version 9\"与\"API version9\"的格式冲突）\n3. 检查相同语义表达中是否保持统一的连接符/空格规则（如版本号标记方式）"
    },
    {
      "defect_id": 23670,
      "sentence": "用于获取包含禁用的abilityInfo的abilityInfo。",
      "reference_sentence": "用于获取application被禁用的BundleInfo和被禁用的Ability信息。",
      "line_num": 82,
      "context": "",
      "修改建议": "混用了'禁用'和'被禁用'，且'abilityInfo'重复",
      "更改后示例": "用于获取包含禁用的abilityInfo。",
      "触发条件": "同一术语或短语在短句内重复冗余出现，或同一概念存在主动/被动语态混用（如\"禁用\"和\"被禁用\"）时触发。\n\n具体识别模式：\n1. 名词重复检测：当中心词（如abilityInfo）与其修饰语中的相同名词重复出现时（例：禁用的X的X）\n2. 语态一致性检测：当描述同一状态时，检测是否混用主动语态（禁用）和被动语态（被禁用）的表达形式"
    },
    {
      "defect_id": 24128,
      "sentence": "以同步方法根据给定的hapFilePath和bundleFlags获取BundleInfo对象。",
      "reference_sentence": "根据给定的hapFilePath和bundleFlags获取BundleInfo，使用Promise异步回调。",
      "line_num": 1807,
      "context": "",
      "修改建议": "前后文中的描述不一致，前文使用了'根据给定的hapFilePath和bundleFlags获取BundleInfo'，而此处使用了'以同步方法根据给定的hapFilePath和bundleFlags获取BundleInfo对象'。",
      "更改后示例": "根据给定的hapFilePath和bundleFlags同步获取BundleInfo对象。",
      "触发条件": "当同一功能描述中存在状语位置不一致（如\"同步获取\"与\"使用Promise异步回调\"结构差异），或动词与修饰语顺序与上下文模式不匹配时触发。识别模式需检测相同操作描述中是否保持\"副词+动词\"（如同步获取）或\"动词+后置状语\"（如使用异步回调）的统一结构。"
    },
    {
      "defect_id": 24145,
      "sentence": "设置指定应用的禁用或使能状态，使用callback异步回调。",
      "reference_sentence": "根据给定的bundleName清理BundleCache，使用Promise异步回调。",
      "line_num": 2127,
      "context": "",
      "修改建议": "句式不一致，前文使用'根据给定的...清理...'，后文使用'设置...状态'。",
      "更改后示例": "设置指定应用的禁用或使能状态，使用回调异步回调。",
      "触发条件": "同一文档中出现同一概念的中英文术语混用（如\"callback\"与\"回调\"并存），或相同功能描述的动宾结构句式不一致（如\"根据给定的...清理...\"与\"设置...状态\"句式差异）。\n\n识别模式：\n1. 术语一致性检测：识别同一技术概念是否交替使用中英文表达（如API/callback/回调）\n2. 句式结构比对：检查相邻功能描述是否保持相同动宾结构（\"动词+宾语+补语\"的完整性匹配）\n3. 功能场景关联：当涉及相同操作类型（如异步回调）时，强制要求术语和句式双重统一"
    },
    {
      "defect_id": 24195,
      "sentence": "以同步方法获取指定应用的禁用或使能状态。",
      "reference_sentence": "获取指定应用的禁用或使能状态，使用Promise异步回调。",
      "line_num": 2771,
      "context": "",
      "修改建议": "用词不一致，`以同步方法`与`使用Promise异步回调`混用",
      "更改后示例": "以同步方式获取指定应用的禁用或使能状态。",
      "触发条件": "同一功能描述中混用\"方法/方式\"等近义术语，或同步/异步描述存在术语结构不一致（如\"以同步方法\"与\"使用Promise异步回调\"不对称）。\n\n识别模式：检测同一操作描述中是否同时存在\"方法/方式/回调\"等近义术语变体，或同步/异步描述存在\"以...方法\"与\"使用...回调\"等不同语法结构。"
    },
    {
      "defect_id": 24296,
      "sentence": "以同步的方法根据给定的profileType、bundleName和moduleName查询相应配置文件的JSON字符串。",
      "reference_sentence": "以同步接口查询指定bundleName的额外信息。",
      "line_num": 4533,
      "context": "",
      "修改建议": "混用了“方法”和“接口”描述同一事物。",
      "更改后示例": "以同步接口根据给定的profileType、bundleName和moduleName查询相应配置文件的JSON字符串。",
      "触发条件": "当同一技术概念在相邻描述中混用不同术语（如\"方法\"和\"接口\"），且存在已验证的统一表达范例（如参考句中的\"接口\"）时触发。\n\n识别模式：通过对比动词短语结构（如\"以...查询\"）中的核心术语一致性，检测同一功能描述中是否存在术语摇摆，并参照已有规范表达进行术语对齐验证。"
    },
    {
      "defect_id": 24265,
      "sentence": "此接口为系统接口",
      "reference_sentence": "此接口为系统接口。",
      "line_num": 59,
      "context": "",
      "修改建议": "句式不一致，缺少句号。",
      "更改后示例": "此接口为系统接口。",
      "触发条件": "句子结构完整（如陈述句）但缺少结尾标点符号，或与同一文档/上下文中其他同类句子的标点使用模式（如均以句号结尾）存在不一致。"
    },
    {
      "defect_id": 24320,
      "sentence": "要查询扩展资源的应用名称。",
      "reference_sentence": "根据给定的应用bundleName获取当前用户下的所有的开发者ID列表。",
      "line_num": 5024,
      "context": "",
      "修改建议": "混用了'应用名称'和'bundleName'概念，应保持术语一致。",
      "更改后示例": "要查询扩展资源的bundleName。",
      "触发条件": "同一技术概念在文档中使用了多个不一致的术语表述，且存在明确定义的参考术语（如bundleName）时触发。通过检测相邻上下文/技术属性字段是否出现术语混用（如应用名称↔bundleName），并与API/参考句中的标准术语进行模式匹配来识别。"
    },
    {
      "defect_id": 24321,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[ohos.bundle错误码](errorcode-bundle.md)。",
      "reference_sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[ohos.bundle错误码](errorcode-bundle.md)。",
      "line_num": 170,
      "context": "",
      "修改建议": "重复出现，建议只保留一次。",
      "更改后示例": "（无需修改，但建议在文档中只保留一次该说明）",
      "触发条件": "同一文档中存在多个相同或高度相似的说明性语句（如重复的参考指引），且重复内容用于指引读者参考其他章节/外部文档时触发。"
    },
    {
      "defect_id": 40802,
      "sentence": "TaskPool不支持指定任务所运行的线程，任务会被分配到空闲的线程中执行。如果需要指定任务运行的线程，建议使用[Worker](./worker-introduction.md)来实现。",
      "reference_sentence": "TaskPool不支持指定任务所运行的线程，任务会被分配到空闲的线程中执行。如果需要指定任务运行的线程，建议使用[Worker](./worker-introduction.md)来实现。",
      "line_num": 37,
      "context": "",
      "修改建议": "使用了“指定任务所运行的线程”和“指定任务运行的线程”的表述，建议统一使用“指定任务所运行的线程”以保持一致性。",
      "更改后示例": "TaskPool不支持指定任务所运行的线程，任务会被分配到空闲的线程中执行。如果需要指定任务所运行的线程，建议使用[Worker](./worker-introduction.md)来实现。",
      "触发条件": "同一段落或相邻句子中对同一概念使用不同表达形式（如\"指定任务所运行的线程\"与\"指定任务运行的线程\"），且存在关键术语结构差异（如\"所运行的\"与\"运行的\"）。"
    },
    {
      "defect_id": 40800,
      "sentence": "TaskPool支持开发者在宿主线程封装任务抛给任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给宿主线程。",
      "reference_sentence": "TaskPool支持开发者在宿主线程封装任务抛给任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给宿主线程。",
      "line_num": 11,
      "context": "",
      "修改建议": "使用了“封装任务抛给任务队列”的表述，建议使用“提交任务到任务队列”以保持一致性。",
      "更改后示例": "TaskPool支持开发者在宿主线程提交任务到任务队列，系统选择合适的工作线程，进行任务的分发及执行，再将结果返回给宿主线程。",
      "触发条件": "当同一文档中针对相同操作出现多个动词表述（如\"抛给\"与\"提交\"），或检测到与预设标准术语（如参考句中的\"提交\"）存在同义但表述不一致的情况时触发。"
    },
    {
      "defect_id": 40801,
      "sentence": "由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。",
      "reference_sentence": "由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。",
      "line_num": 25,
      "context": "",
      "修改建议": "使用了“线程安全的库”和“非线程安全库”的表述，建议统一使用“线程安全的库”以保持一致性。",
      "更改后示例": "由于不同线程中上下文对象是不同的，因此TaskPool工作线程只能使用线程安全的库，例如UI相关的库不能使用。",
      "触发条件": "同一段落或相邻句子中对同一概念同时使用正反表述（如\"线程安全的库\"和\"非线程安全库\"），且存在冗余性矛盾时触发。  \n\n识别模式：  \n1. 检测相邻语句中是否出现同一核心术语的正反形态（如通过否定词/前缀形成对立表述）  \n2. 验证正反表述指向同一技术属性（如线程安全），且未存在必要的语义区分需求"
    },
    {
      "defect_id": 24266,
      "sentence": "回调函数，当获取成功时，err为null，data为获所有的共享包信息。",
      "reference_sentence": "回调函数，当获取成功时，err为null，data为获取的指定共享包信息。",
      "line_num": 4018,
      "context": "",
      "修改建议": "句式不一致，'获'应为'获取'。",
      "更改后示例": "回调函数，当获取成功时，err为null，data为获取的所有共享包信息。",
      "触发条件": "当句子中出现动词短语成分缺失（如\"获\"缺少\"取\"字）导致与上下文语法结构不一致，且存在同源正确用例（如\"获取的指定\"）时触发。识别模式需检测动词作定语时是否完整（如\"获取的\"vs\"获的\"）及是否存在可参照的规范表达。"
    },
    {
      "defect_id": 41319,
      "sentence": "获取由elementName和locale指定的远程设备上的应用的AbilityInfo数组信息。使用Promise异步回调。",
      "reference_sentence": "获取由elementName和locale指定的远程设备上的应用的AbilityInfo数组信息。使用callback异步回调。",
      "line_num": 486,
      "context": "",
      "修改建议": "异步回调方式不一致，混用了Promise和callback",
      "更改后示例": "获取由elementName和locale指定的远程设备上的应用的AbilityInfo数组信息。使用callback异步回调。",
      "触发条件": "当同一功能描述中混用不同异步回调术语（如Promise与callback），或相邻语句使用不一致的异步机制表述时触发。\n\n识别模式：通过NLP检测技术术语搭配模式（如\"使用X异步回调\"结构），当同一上下文出现\"Promise\"+\"callback\"混合表述，或与项目术语库中定义的异步方案（如统一要求使用callback）冲突时，自动标记术语不一致问题。"
    },
    {
      "defect_id": 24238,
      "sentence": "string | 指定组件的Lablel值。",
      "reference_sentence": "Promise<string> | Promise对象，返回指定组件的Lablel值。",
      "line_num": 3629,
      "context": "",
      "修改建议": "混用了“Lablel”和“Label”术语。",
      "更改后示例": "string | 指定组件的Label值。",
      "触发条件": "同一文档中同一术语存在拼写/大小写不一致（如“Lablel”与“Label”混用），且存在已定义的规范形式（如正确拼写\"Label\"）时触发。\n\n识别模式：\n1. 检测相邻文本段中同一语义单元的不同拼写形态（如字母顺序错误、多余/缺失字符）\n2. 对比技术术语表或上下文高频词形态（如参考句中\"Lablel\"与修复建议\"Label\"形成冲突）\n3. 验证错误形态是否符合常见拼写错误模式（如\"Lablel\"是\"Label\"的典型倒序错误）"
    },
    {
      "defect_id": 41282,
      "sentence": "Promise对象，调用成功返回RemoteAbilityInfo对象；调用失败返回错误对象。",
      "reference_sentence": "Promise对象，调用成功返回RemoteAbilityInfo对象；调用失败返回错误对象。",
      "line_num": 111,
      "context": "",
      "修改建议": "前文已经使用了'Promise对象，调用成功返回RemoteAbilityInfo对象；调用失败返回错误对象'，而此处使用了相同的表述，但前文的描述是单个RemoteAbilityInfo对象，而此处是数组，存在表意不一致的问题。",
      "更改后示例": "Promise对象，调用成功返回RemoteAbilityInfo数组对象；调用失败返回错误对象。",
      "触发条件": "当文档中重复出现相同功能描述但存在数据类型/结构差异（如单个对象与数组）时，或同一术语在不同位置表意矛盾时触发。\n\n识别模式：通过对比相邻段落或相似功能模块的句式结构，检测重复表述中关键名词的修饰词（如\"对象\"/\"数组对象\"）或量词（如\"单个\"/\"多个\"）是否一致，同时验证技术术语与实际返回数据结构的对应关系。"
    },
    {
      "defect_id": 24301,
      "sentence": "The specified user ID is not found.",
      "reference_sentence": "The specified userId is invalid.",
      "line_num": 177,
      "context": "",
      "修改建议": "混用了‘user ID’和‘userId’，且‘找不到’与‘无效’近义词混用",
      "更改后示例": "The specified userId is invalid.",
      "触发条件": "同一术语存在多种拼写形式（如user ID/userId）或同一概念使用不同近义词（如not found/invalid）时触发。识别模式需检测术语格式差异（大小写/分隔符）及同义表达替换（如\"找不到\"与\"无效\"在相同上下文中交替出现）。"
    },
    {
      "defect_id": 24279,
      "sentence": "17700004 | The specified user ID is not found.",
      "reference_sentence": "201 | Permission denied.",
      "line_num": 177,
      "context": "",
      "修改建议": "在描述错误码时，混用了'user ID'和'用户ID'，应全文统一。",
      "更改后示例": "17700004 | The specified 用户ID is not found.",
      "触发条件": "同一术语在文档中存在中英文混用（如\"user ID\"与\"用户ID\"交替出现），且未保持全文统一表达形式时触发。\n\n识别模式：\n1. 检测相邻/同类型错误码描述中同一术语的语言形式（如对比错误码17700004与201的描述）\n2. 通过术语库匹配识别中英文对应关系（如\"用户ID\"对应\"user ID\"）\n3. 定位到包含混合语言表达的术语时，检查文档全局是否存在不一致用法"
    },
    {
      "defect_id": 37609,
      "sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "reference_sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "line_num": 23,
      "context": "",
      "修改建议": "句子格式和风格一致，但未使用祈使句。",
      "更改后示例": "请参考权限等级说明。",
      "触发条件": "当句子属于操作指引或步骤说明但未使用祈使句结构，或指导性内容中动词未以\"请\"开头时触发。\n\n识别模式：\n1. 检测句子是否包含指导性动作（如\"参考\"\"查看\"\"点击\"等）\n2. 验证动词结构是否符合\"请+动词\"的祈使句式\n3. 排除纯描述性/陈述性语句（如功能说明、原理阐述）\n4. 匹配文档中同类操作指引的句式规范（通过上下文对比）"
    },
    {
      "defect_id": 41371,
      "sentence": "根据给定的ElementName获取有关远程设备AbilityInfo信息，使用Promise异步回调。",
      "reference_sentence": "getRemoteAbilityInfo(elementName: ElementName): Promise<RemoteAbilityInfo>",
      "line_num": 64,
      "context": "",
      "修改建议": "混用了`AbilityInfo`和`RemoteAbilityInfo`概念",
      "更改后示例": "根据给定的ElementName获取有关远程设备RemoteAbilityInfo信息，使用Promise异步回调。",
      "触发条件": "文档中同一概念出现多个不一致的命名实体，或与API接口定义的关键术语存在命名冲突。\n\n识别模式：\n1. 通过命名后缀/前缀匹配识别相似术语（如*-AbilityInfo与*-RemoteAbilityInfo）\n2. 交叉验证API接口声明（如getRemoteAbilityInfo方法强制关联RemoteAbilityInfo类型）\n3. 检测相邻段落是否存在同概念不同命名的上下文矛盾（如混用本地/远程组件术语）"
    },
    {
      "defect_id": 24271,
      "sentence": "获取所有的共享包信息，使用Promise异步回调。",
      "reference_sentence": "获取所有的共享包信息，使用callback异步回调。",
      "line_num": 4054,
      "context": "",
      "修改建议": "同一方法在不同示例中描述不一致，前文使用了callback，后文使用了Promise",
      "更改后示例": "获取所有的共享包信息，使用callback异步回调。",
      "触发条件": "同一方法或技术在不同示例或上下文中使用不一致的术语（如callback/Promise），且存在明确的文档内前置定义时触发。识别需检查术语与文档既定表述的冲突，及是否指向同一功能实现。"
    },
    {
      "defect_id": 41379,
      "sentence": "是否通过静默安装。",
      "reference_sentence": "是否通过静默安装。",
      "line_num": 35,
      "context": "",
      "修改建议": "应使用'是否静默安装'以保持术语一致。",
      "更改后示例": "是否静默安装。",
      "触发条件": "当句子中的动词短语包含与既定术语结构不一致的冗余介词（如\"通过\"）或辅助词时触发，或当同一术语在文档中存在多种表达形式（例如\"静默安装\"与\"通过静默安装\"）时触发。\n\n识别模式：\n1. 检测\"是否/能否/是否支持\"等疑问结构后接的动词短语\n2. 对比文档中已定义的标准化术语（如参考句中的\"静默安装\"）\n3. 识别冗余介词（如\"通过\"）导致的术语结构变异\n4. 匹配同一功能描述存在\"动词+术语\"与\"纯术语\"两种表达形式的情况"
    },
    {
      "defect_id": 41349,
      "sentence": "name                              | string                                                       | 是   | 否   | 模块名称。             |",
      "reference_sentence": "moduleName                        | string                                                       | 是   | 否   | 模块名。               |",
      "line_num": 16,
      "context": "",
      "修改建议": "术语不一致，`模块名称`与`模块名`混用。",
      "更改后示例": "name                              | string                                                       | 是   | 否   | 模块名。             |",
      "触发条件": "当同一术语在文档中存在多个不同表达形式（如\"模块名称\"与\"模块名\"），且指向同一概念实体时触发。识别模式需检测相邻字段描述中是否出现同义词/缩略词混用，并通过上下文语义验证是否指代同一对象。"
    },
    {
      "defect_id": 24295,
      "sentence": "根据给定的want、extensionAbilityType、extensionAbilityFlags和userId获取ExtensionAbilityInfo，使用同步方式返回结果。",
      "reference_sentence": "以同步的方法查询指定bundleName的[分发类型](../../security/app-provision-structure.md)，该返回值是在调用install接口时传入的[InstallParam](./js-apis-installer-sys.md#installparam)中的specifiedDistributionType字段。",
      "line_num": 4443,
      "context": "",
      "修改建议": "句式不一致，应统一使用‘以同步的方法查询’",
      "更改后示例": "以同步的方法根据给定的want、extensionAbilityType、extensionAbilityFlags和userId获取ExtensionAbilityInfo。",
      "触发条件": "当技术文档中描述方法调用方式时，若出现\"使用...方式\"与\"以...的方法\"句式混用，或动词短语结构（如\"获取\"/\"查询\"）与上下文规范不匹配时触发。具体识别模式为检测到方法调用描述未采用\"以[同步/异步]的方法[动作]\"的标准句式结构。"
    },
    {
      "defect_id": 24215,
      "sentence": "Permission denied, non-system app called system api.",
      "reference_sentence": "Permission denied, non-system app called system api.",
      "line_num": 394,
      "context": "",
      "修改建议": "虽然两个句子内容一致，但出现在不同方法的错误码描述中，建议统一错误信息",
      "更改后示例": "Permission denied, non-system app called system API.",
      "触发条件": "同一术语在相同/相关上下文中存在不一致的大小写或拼写形式（如\"api\"与\"API\"），且该术语属于需统一标准的专有名词或技术关键词。"
    },
    {
      "defect_id": 37611,
      "sentence": "在组件、页面、应用的生命周期结束时，使用[bundleMonitor.off](#bundlemonitoroff)注销对应用的安装、卸载、更新等事件的监听。",
      "reference_sentence": "在组件、页面、应用的生命周期结束时，使用[bundleMonitor.off](#bundlemonitoroff)注销对应用的安装、卸载、更新等事件的监听。",
      "line_num": 57,
      "context": "",
      "修改建议": "句子格式和风格一致，但未使用祈使句。",
      "更改后示例": "在组件、页面、应用的生命周期结束时，请使用[bundleMonitor.off](#bundlemonitoroff)注销对应用的安装、卸载和更新等事件的监听。",
      "触发条件": "当操作指导类语句未使用祈使句结构（缺少\"请\"字），或与上下文同类语句存在语气/连词格式（\"和\"/\"等\"）不一致时触发。  \n\n识别模式：  \n1. 检测句子是否包含\"使用...注销/执行...\"等操作指令  \n2. 检查是否缺失祈使句标志词\"请\"，同时对比文档中同类操作说明的句式  \n3. 验证并列连词是否符合当前规范（如\"安装、卸载和更新\"vs\"安装、卸载、更新等\"）"
    },
    {
      "defect_id": 24323,
      "sentence": "根据uid查询分身应用的bundleName和appIndex。",
      "reference_sentence": "根据给定的bundleName使能动态图标。",
      "line_num": 5241,
      "context": "",
      "修改建议": "混用了'查询'和'使能'，应保持动词一致。",
      "更改后示例": "根据uid使能分身应用的bundleName和appIndex。",
      "触发条件": "同一操作描述中混用多个不同动词（如“查询”“使能”），且上下文未明确要求差异化动作时。"
    },
    {
      "defect_id": 24224,
      "sentence": "表示权限参数名。",
      "reference_sentence": "表示权限名称。",
      "line_num": 3391,
      "context": "",
      "修改建议": "混用了“参数名”和“名称”两个术语，表意模糊。",
      "更改后示例": "表示权限名称。",
      "触发条件": "同一概念在上下文或术语库中存在多个不一致的命名表述（如“参数名”与“名称”混用），且未遵循预定义的术语规范。\n\n识别模式：\n1. 术语冲突检测：通过对比上下文/术语库，识别同一语义概念使用了不同词汇（如“名”类词尾的变体：参数名、名称、命名）；\n2. 词根一致性验证：检查核心词根（如案例中的\"权限\"）的修饰词是否统一（应固定使用\"名称\"而非\"参数名\"）；\n3. 跨文档对齐：当参考句子已明确使用标准术语（如\"权限名称\"），其他位置出现同义异形词时触发修复。"
    },
    {
      "defect_id": 41350,
      "sentence": "moduleName                        | string                                                       | 是   | 否   | 模块名。               |",
      "reference_sentence": "name                              | string                                                       | 是   | 否   | 模块名称。             |",
      "line_num": 28,
      "context": "",
      "修改建议": "术语不一致，`模块名`与`模块名称`混用。",
      "更改后示例": "moduleName                        | string                                                       | 是   | 否   | 模块名称。               |",
      "触发条件": "当同一术语在文档中存在不同词形变体（如\"名\"与\"名称\"）时，或当参数描述与参考位置术语表达不一致时，应触发语言一致性规则。\n\n识别模式：\n1. 检测术语核心词素重复出现（如\"模块名\"与\"模块名称\"均含\"模块\"+\"名\"词根）\n2. 匹配参数描述字段与参考模板句式结构（如\"| string | 是 | 否 | 模块XX |\"）\n3. 对比同类型参数命名模式（如\"name\"对应\"模块名称\"，则其他参数也应保持\"XX名称\"格式）"
    },
    {
      "defect_id": 24260,
      "sentence": "回调函数，当获取成功时，err为null，data为获取的指定共享包信息。",
      "reference_sentence": "返回BundleInfo对象。",
      "line_num": 3907,
      "context": "",
      "修改建议": "句式不一致，且'获取'与'返回'混用",
      "更改后示例": "回调函数，当获取成功时，err为null，data为指定的共享包信息。",
      "触发条件": "同一上下文或相邻语句中描述相同操作时出现动词混用（如\"获取\"与\"返回\"），或存在冗余的动作描述导致句式结构不平行。通过检测相邻参数描述中重复/冲突的动词（如\"获取的指定\"）及对比API全局术语（如参考句的\"返回\"）进行识别。"
    },
    {
      "defect_id": 41376,
      "sentence": "应用包里应用程序的uid。",
      "reference_sentence": "应用包里应用程序的uid。",
      "line_num": 19,
      "context": "",
      "修改建议": "应使用'应用UID'以保持术语一致。",
      "更改后示例": "应用包里应用程序的UID。",
      "触发条件": "检测到同一术语存在不一致的大小写形式（如\"uid\"与\"UID\"），或与文档中已定义的术语标准形式（如参考句中的\"应用UID\"）产生冲突时触发。\n\n识别模式：\n1. 通过NLP技术匹配核心术语的变体（如全大写/全小写/驼峰式）\n2. 对比上下文已出现的术语表达形式（如参考句中的\"应用UID\"）\n3. 验证术语是否符合技术文档预定义的命名规范（如操作系统领域UID通常全大写）"
    },
    {
      "defect_id": 42811,
      "sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "reference_sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "line_num": 23,
      "context": "",
      "修改建议": "原文中使用了'权限APL等级说明'，应与'权限等级'一致。",
      "更改后示例": "权限等级参考[权限等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "触发条件": "当超链接文本包含与上下文核心术语不一致的冗余缩写/修饰词（如案例中的\"APL\"），且存在明确的前文指代对象（如\"权限等级\"）时触发。\n\n识别模式：\n1. 检测方括号链接文本与锚点前核心术语的包含关系（如\"权限等级说明\"应包含\"权限等级\"）\n2. 识别链接文本中非常规缩写/专业术语（如APL）是否在前文未定义且破坏术语一致性"
    },
    {
      "defect_id": 43248,
      "sentence": "基于bundleName和BundlePackFlag来获取bundlePackInfo。使用Promise异步回调。",
      "reference_sentence": "查询指定模块是否可以被移除。使用Promise异步回调。",
      "line_num": 324,
      "context": "",
      "修改建议": "混用了`应用程序Bundle名称`和`应用Bundle名称`",
      "更改后示例": "基于应用Bundle名称和BundlePackFlag来获取bundlePackInfo。使用Promise异步回调。",
      "触发条件": "当同一技术术语存在全称/缩写混用（如\"Bundle名称\"和\"bundleName\"）或同义表达不一致（如\"应用Bundle名称\"和\"应用程序Bundle名称\"）时触发，且需满足相邻句子/段落中存在相同概念的不同表达形式。"
    },
    {
      "defect_id": 44526,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter hapFiles is needed for code signature; 4. The size of specifiedDistributionType is greater than 128; 5. The size of additionalInfo is greater than 3000.",
      "reference_sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types.",
      "line_num": 194,
      "context": "",
      "修改建议": "错误信息描述不一致，且新增了额外的错误原因，应与原文保持一致。",
      "更改后示例": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types.",
      "触发条件": "当错误信息中的可能原因列表与参考内容存在数量差异或新增未提及的错误类型时触发；当错误描述结构或内容与既定规范不一致时触发。"
    },
    {
      "defect_id": 43724,
      "sentence": "使用的签名证书发生变化，该字段会发生变化。",
      "reference_sentence": "应用的唯一标识，是AppGallery Connect创建应用时分配的APP ID，为云端统一分配的随机字符串。该ID在应用全生命周期中不会发生变化，包括版本升级、证书变更、开发者公私钥变更、应用转移等。",
      "line_num": 75,
      "context": "",
      "修改建议": "混用了'签名证书'与'证书'，导致表意不一致",
      "更改后示例": "使用的证书发生变化，该字段会发生变化。",
      "触发条件": "同一概念在相邻或相关句段中混用不同术语（如全称与简称、同义词、不同限定词），且上下文未明确区分其差异性。\n\n识别模式：\n1. 核心名词在短距离内出现两种及以上变体（如\"证书\"与\"签名证书\"）\n2. 通过依存句法分析确认变体名词的修饰关系（如\"签名+证书\"与单独\"证书\"）\n3. 结合领域词典验证是否为同一实体（如证书类术语表）\n4. 参考上下文标准表述（如示例中的\"证书变更\"统一表述）进行交叉验证"
    },
    {
      "defect_id": 42886,
      "sentence": "从API version 18 开始，支持配置Worker线程优先级。",
      "reference_sentence": "支持配置任务优先级。",
      "line_num": 24,
      "context": "",
      "修改建议": "描述设置优先级时，'配置Worker线程优先级'与'配置任务优先级'用词不一致，建议统一为一种描述方式。",
      "更改后示例": "从API version 18 开始，支持配置任务优先级。",
      "触发条件": "当同一技术概念在描述中存在多个术语变体（如“Worker线程优先级”与“任务优先级”），且上下文指向同一功能属性时触发。\n\n识别模式：\n1. **术语冲突检测**：识别句子中关键功能术语（如“配置X优先级”）是否与既定术语库（如参考句中的“任务优先级”）冲突。\n2. **上下文一致性验证**：通过语义分析确认冲突术语是否指向同一对象（如“Worker线程”与“任务”在上下文中均指代可配置优先级的执行单元）。"
    },
    {
      "defect_id": 44140,
      "sentence": "FA模型配置在[config.json文件中进行配置](../../quick-start/module-structure.md#shortcuts对象的内部结构)，Stage模型配置参考[shortcuts对象内部结构](../../quick-start/module-configuration-file.md#shortcuts标签)。",
      "reference_sentence": "FA模型配置在[config.json文件中进行配置](../../quick-start/module-structure.md#shortcuts对象的内部结构)，Stage模型配置参考[shortcuts对象内部结构](../../quick-start/module-configuration-file.md#shortcuts标签)。",
      "line_num": 9,
      "context": "",
      "修改建议": "混用了'配置'和'内部结构'来描述同一概念",
      "更改后示例": "FA模型配置在[config.json文件中进行配置](../../quick-start/module-structure.md#shortcuts对象的内部结构)，Stage模型配置参考[shortcuts对象的配置](../../quick-start/module-configuration-file.md#shortcuts标签)。",
      "触发条件": "同一文档中相邻或相关描述对相同操作/概念使用不同动词（如\"配置\"和\"内部结构\"），且存在可替换的标准化表述时。\n\n识别模式：\n1. 对比相邻句子结构（如\"在X进行配置\" vs \"参考Y内部结构\"）\n2. 检测相同语法位置（动词短语）出现不同术语表达\n3. 验证是否存在文档内已定义的标准化表述（如统一使用\"配置\"描述设置操作）"
    },
    {
      "defect_id": 42847,
      "sentence": "以同步方法根据系统已定义的应用类型或者符合媒体类型格式（type/subtype）的文件类型或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型设置默认应用。",
      "reference_sentence": "根据系统已定义的应用类型或者符合媒体类型格式（type/subtype）的文件类型或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型设置默认应用，使用callback异步回调。",
      "line_num": 544,
      "context": "",
      "修改建议": "描述不一致，应统一描述方式，避免前后描述不一致。",
      "更改后示例": "根据系统已定义的应用类型或者符合媒体类型格式（type/subtype）的文件类型或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型设置默认应用。",
      "触发条件": "当句子中存在与上下文或既定结构不协调的状语/修饰语（如冗余的行为方式描述），或出现混合句式导致语义焦点不一致时触发。\n\n识别模式：\n1. **状语冗余性检测**：若句首出现\"以...方法\"等行为方式描述，但后文未对应说明具体实现机制（如异步回调），且参考句式无此结构时，视为冗余修饰。\n2. **句式混合检测**：当同一句子中同时包含行为方式状语（前置）和功能目的状语（后置）两种不同语法结构时，判定为描述焦点不统一。例如原句混合了\"以同步方法\"(行为方式)与\"根据...类型\"(判断条件)两种表达维度。"
    },
    {
      "defect_id": 42887,
      "sentence": "超长任务（大于3分钟且非长时任务）会被系统自动回收；而Worker偏向线程的维度，支持长时间占据线程执行，需要主动管理线程生命周期。",
      "reference_sentence": "由于TaskPool的工作线程会绑定系统的调度优先级，并且支持负载均衡（自动扩缩容），而Worker需要开发者自行创建，存在创建耗时，故在性能方面使用TaskPool会优于Worker，因此大多数场景推荐使用TaskPool。",
      "line_num": 37,
      "context": "",
      "修改建议": "描述任务执行时，'自动回收'与'需要主动管理'用词不一致，建议统一为一种描述方式。",
      "更改后示例": "超长任务（大于3分钟且非长时任务）会被系统自动回收；而Worker偏向线程的维度，支持长时间占据线程执行，需要开发者主动管理线程生命周期。",
      "触发条件": "同一语境下存在系统自动行为与开发者主动行为的对比描述，但责任主体表述不一致或缺失时触发。\n\n识别模式：\n1. 检测对比结构中是否同时存在\"自动/系统回收\"和\"需要(主动)管理\"类表述\n2. 验证对应行为主体是否明确对应（系统自动执行 vs 开发者主动执行）\n3. 检查责任主体修饰语（\"系统\"、\"开发者\"）在并列分句中的对称性"
    },
    {
      "defect_id": 42944,
      "sentence": "点击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。",
      "reference_sentence": "无",
      "line_num": 187,
      "context": "",
      "修改建议": "使用了“点击”而不是“单击”，不符合句式一致的规则。",
      "更改后示例": "单击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。",
      "触发条件": "文档中存在针对同一操作步骤的多个同义动词（如\"点击/单击\"），且上下文或规范明确要求使用特定术语时触发。\n\n识别模式：通过动词匹配（如\"点击\"vs\"单击\"）检测操作描述中的术语波动，结合技术文档操作类动词标准化列表（如强制使用\"单击\"），当非标准动词出现在步骤说明中时标记不一致。"
    },
    {
      "defect_id": 42945,
      "sentence": "当前线程为宿主线程，并注册回调函数。",
      "reference_sentence": "无",
      "line_num": 198,
      "context": "",
      "修改建议": "使用了“并”连接两个动作，不符合句式一致的规则，应使用两个独立的句子。",
      "更改后示例": "当前线程为宿主线程。注册回调函数。",
      "触发条件": "句子中存在使用并列连词（如“并”）连接但句式结构不一致的分句（如状态描述与动作描述混合）。"
    },
    {
      "defect_id": 44141,
      "sentence": "快捷方式的本地Ability名称。",
      "reference_sentence": "快捷方式的目标abilityName。",
      "line_num": 37,
      "context": "",
      "修改建议": "混用了'本地Ability名称'和'目标abilityName'来描述同一概念",
      "更改后示例": "快捷方式的目标Ability名称。",
      "触发条件": "同一文档中针对同一功能或参数存在多个不一致的术语表述（如\"本地Ability名称\"与\"目标abilityName\"），且术语核心结构（Ability名称/abilityName）与修饰词（本地/目标）出现矛盾性变化时。\n\n识别模式：\n1. 检测相邻段落/功能描述中相同语义位置的名词短语\n2. 匹配术语核心词（如\"Ability名称\"）与参考标准（如\"目标abilityName\"）的：\n   - 修饰词冲突（本地 vs 目标）\n   - 格式差异（全称/缩写、大小写、连字符）\n3. 验证术语是否指向同一技术概念（如快捷方式指向的Ability实体）"
    },
    {
      "defect_id": 44525,
      "sentence": "Calling interface without permission 'ohos.permission.INSTALL_SELF_BUNDLE'.",
      "reference_sentence": "Permission denied.",
      "line_num": 1107,
      "context": "",
      "修改建议": "错误信息描述不一致，应与原文保持一致。",
      "更改后示例": "Permission denied.",
      "触发条件": "当错误信息或提示语句与同一文档中其他部分的既定表述（如参考句子）存在术语、句式或风格不一致时。  \n\n识别方式：通过对比上下文或参考句子的固定表达模式（如\"Permission denied.\"），检测当前句子是否偏离统一术语或标准格式。"
    },
    {
      "defect_id": 42935,
      "sentence": "onerror接口仅捕获onmessage回调中同步方法产生的异常，无法捕获多线程回调产生的异常和模块化相关异常。",
      "reference_sentence": "onerror接口仅能捕获onmessage回调中的同步异常，且捕获异常后Worker线程会进入销毁流程，无法继续使用。",
      "line_num": 168,
      "context": "",
      "修改建议": "前后句子表述不一致，前文使用了'仅能捕获'，后文应该保持一致。",
      "更改后示例": "onerror接口仅能捕获onmessage回调中的同步异常，无法捕获多线程回调产生的异常和模块化相关异常。",
      "触发条件": "同一句子或相邻上下文中，对同一限制性条件的表述存在副词/助动词不一致（如“仅”与“仅能”混用），且导致前后句式结构失衡时。"
    },
    {
      "defect_id": 42926,
      "sentence": "Worker线程只能使用线程安全的库，例如UI相关的非线程安全库不能使用。",
      "reference_sentence": "由于不同线程中上下文对象是不同的，因此Worker线程只能使用线程安全的库。",
      "line_num": 20,
      "context": "",
      "修改建议": "混用了“线程安全的库”和“非线程安全库”描述同一概念",
      "更改后示例": "Worker线程只能使用线程安全的库，例如UI相关的库不能使用。",
      "触发条件": "同一段落或相邻句子中交替使用肯定与否定形式（如“线程安全的库”和“非线程安全库”）描述同一概念，且未明确声明其对立关系。\n\n识别模式：\n1. 检测核心术语的正反表述共存（如\"A\"与\"非A\"同时出现）\n2. 验证正反表述指向同一维度属性（如线程安全性）\n3. 检查上下文是否缺少对正反关系的明确定义说明\n4. 定位在规则描述与示例说明场景中出现术语切换的情况"
    },
    {
      "defect_id": 42962,
      "sentence": "不建议在明确父Worker发起销毁操作的同步调用前后仍在父Worker线程创建子Worker。",
      "reference_sentence": "建议用户确保子Worker的生命周期始终在父Worker生命周期范围内，并在销毁父Worker前先销毁所有子Worker。",
      "line_num": 502,
      "context": "",
      "修改建议": "混用了建议和不建议的表述，且用词不一致",
      "更改后示例": "不建议在明确父Worker发起销毁操作的同步调用前后，在父Worker线程创建子Worker。",
      "触发条件": "同一语境中混合使用正反建议表述（如\"建议\"与\"不建议\"共存），或对同一操作使用不一致的动词/副词描述（如\"仍在创建\"与\"在创建\"）。"
    },
    {
      "defect_id": 39108,
      "sentence": "进程间IPC通道建立，详情参考[Native子进程开发指导（C/C++)](../application-models/capi_nativechildprocess_development_guideline.md)，本文重点阐述IPC CAPI部分使用说明。",
      "reference_sentence": "IPC CAPI接口不直接提供跨进程通信能力，两个进程之间的IPC通道建立，依赖于[Ability Kit](../application-models/abilitykit-overview.md)。",
      "line_num": 11,
      "context": "",
      "修改建议": "混用了“进程间IPC通道建立”和“IPC通道建立”两种表述方式",
      "更改后示例": "进程间IPC通道的建立，详情参考[Native子进程开发指导（C/C++)](../application-models/capi_nativechildprocess_development_guideline.md)，本文重点阐述IPC CAPI部分使用说明。",
      "触发条件": "同一术语或短语在相邻上下文中存在结构不一致（如名词短语中\"的\"的缺失/冗余、修饰词位置差异），且参考句已确立规范表达形式时触发。\n\n识别模式：通过对比同一段落内重复出现的核心术语（如\"IPC通道建立\"），检测其是否保持相同的语法结构（动宾结构vs偏正结构）。当名词性短语中关键助词\"的\"出现缺失，导致与参考句确立的\"XX的建立\"规范形式冲突时，需触发修正。"
    },
    {
      "defect_id": 42884,
      "sentence": "在Worker线程中进行消息解析并调用对应方法。",
      "reference_sentence": "直接将方法传入调用。",
      "line_num": 19,
      "context": "",
      "修改建议": "描述方法调用时，'解析并调用'与'传入调用'用词不一致，建议统一为一种描述方式。",
      "更改后示例": "在Worker线程中解析消息并调用对应方法。",
      "触发条件": "句子中存在由连词（如\"并\"）连接的多个动词短语时，若其结构不一致（如\"进行解析\"与\"调用\"存在冗余修饰词差异）或与上下文同类动作描述用词冲突（如\"解析并调用\"与\"传入调用\"动词组合模式不匹配）。"
    },
    {
      "defect_id": 42946,
      "sentence": "当Worker正常退出时code为0，异常退出时code为1",
      "reference_sentence": "无",
      "line_num": 239,
      "context": "",
      "修改建议": "使用了“当”开头，不符合句式一致的规则，应使用祈使句。",
      "更改后示例": "如果Worker正常退出，code为0；如果异常退出，code为1。",
      "触发条件": "当文档中并列条件句出现混合使用不同连接词（如\"当\"与\"如果\"）或句式结构不平行（陈述句与祈使句混用）时触发。识别模式为检测同一复句内多个条件分句的句首连接词/句式是否保持统一。"
    },
    {
      "defect_id": 43247,
      "sentence": "基于bundleName和bundlePackFlag来获取bundlePackInfo。使用callback异步回调。",
      "reference_sentence": "查询指定模块是否可以被移除。使用callback异步回调。",
      "line_num": 274,
      "context": "",
      "修改建议": "混用了`应用程序Bundle名称`和`应用Bundle名称`",
      "更改后示例": "基于应用Bundle名称和BundlePackFlag来获取bundlePackInfo。使用callback异步回调。",
      "触发条件": "当同一术语在文档中存在多个不同中文译名（如\"应用Bundle名称\"和\"应用程序Bundle名称\"交替出现），或中英文混合表述（如\"bundleName\"未统一翻译）时触发。\n\n识别模式：\n1. 检测同一英文术语对应的不同中文翻译（如bundleName→应用Bundle名称/应用程序Bundle名称）\n2. 识别相邻术语表述形式差异（如\"应用Bundle名称\"与\"BundlePackFlag\"中英文格式不匹配）\n3. 对比上下文出现过的同源术语表达（如参考句保持\"callback\"全英文，问题句却出现部分翻译）"
    },
    {
      "defect_id": 42963,
      "sentence": "不建议在不确定父Worker是否发起销毁操作的情况下，仍在父Worker线程创建子Worker，即创建子Worker线程成功之前需保证父Worker线程始终处于存活状态。",
      "reference_sentence": "建议用户确保子Worker的生命周期始终在父Worker生命周期范围内，并在销毁父Worker前先销毁所有子Worker。",
      "line_num": 502,
      "context": "",
      "修改建议": "混用了建议和不建议的表述，且用词不一致",
      "更改后示例": "不建议在不确定父Worker是否发起销毁操作的情况下，在父Worker线程创建子Worker，即创建子Worker线程成功之前需保证父Worker线程始终处于存活状态。",
      "触发条件": "同一建议性表述中混用正反语气（如\"不建议\"与\"需保证\"共存），或关键术语（如\"存活状态\"/\"生命周期\"）在上下文出现不一致表述时触发。\n\n识别模式：\n1. 检测建议性语句中是否同时存在否定式（不建议）与肯定式（建议/需）指令\n2. 对比技术核心术语（如Worker生命周期状态描述）与参考规范的一致性\n3. 验证同一概念是否使用不同表述（如\"存活状态\"与\"生命周期范围内\"）"
    },
    {
      "defect_id": 42961,
      "sentence": "不建议父Worker主动销毁后，子Worker仍向父Worker发送消息。",
      "reference_sentence": "建议用户确保子Worker的生命周期始终在父Worker生命周期范围内，并在销毁父Worker前先销毁所有子Worker。",
      "line_num": 431,
      "context": "",
      "修改建议": "混用了建议和不建议的表述，且用词不一致",
      "更改后示例": "不建议在父Worker销毁后，子Worker仍向父Worker发送消息。",
      "触发条件": "同一建议性表述中混用正反动词（如\"建议\"与\"不建议\"），或同一操作对象使用不一致的修饰词（如\"主动销毁\"与\"销毁\"）。\n\n识别模式：\n1. 检测建议性语句中是否交替出现\"建议/不建议\"等对立表述\n2. 比对操作对象描述是否保持术语统一（如动词短语结构一致性、修饰词稳定性）\n3. 验证否定性建议是否采用固定句式结构（如\"不建议在...后\"的标准化表达）"
    },
    {
      "defect_id": 103185,
      "sentence": "判断此HashMap中是否含有该指定key。",
      "reference_sentence": "hasKey(key: K): boolean",
      "line_num": 100,
      "context": "",
      "修改建议": "术语'判断'与'hasKey'不一致",
      "更改后示例": "判断此HashMap中是否包含指定key。",
      "触发条件": "当文档中的动词表述（如\"含有\"）与对应API方法名中的核心动词（如\"hasKey\"中的\"has/包含\"）存在术语不一致时触发。识别模式需检测句子动词是否与接口定义的关键术语（如方法名、参数名）存在中文翻译偏差。"
    },
    {
      "defect_id": 51093,
      "sentence": "该接口用于解析xml。",
      "reference_sentence": "setDocType(text: string): void写入文档类型。",
      "line_num": 534,
      "context": "",
      "修改建议": "混用了'xml'和'XML'，大小写不一致。",
      "更改后示例": "该接口用于解析XML。",
      "触发条件": "同一技术术语在文档中出现不同大小写形式（如XML/xml/Xml），或与行业标准/上下文既定格式不一致时触发。\n\n识别模式：通过术语库匹配检测专有名词（如XML、JSON）和代码元素（如setDocType），当同一术语在相邻段落或技术上下文中存在大小写混用（如\"xml\"与\"XML\"交替出现），或与预定义的标准化格式（如RFC规范要求XML必须全大写）冲突时判定为不一致。"
    },
    {
      "defect_id": 52657,
      "sentence": "在当前URI的基础上添加查询参数，并创建一个新的URI，同时保持原有URI对象不变。",
      "reference_sentence": "对给定的字段进行编码并将其追加到当前URI的path字段中，并创建一个新的URI返回，同时保持原有URI对象不变。",
      "line_num": 419,
      "context": "",
      "修改建议": "前后文描述中，对创建新的URI对象的表述不一致，前者使用了‘创建一个新的URI’，后者使用了‘创建一个新的URI返回’。",
      "更改后示例": "在当前URI的基础上添加查询参数，并创建一个新的URI对象返回，同时保持原有URI对象不变。",
      "触发条件": "同一操作在相邻描述中存在动词短语结构不一致（如\"创建新的URI\" vs \"创建新的URI对象返回\"），或关键宾语成分缺失（如缺少\"对象\"或\"返回\"等限定词）。  \n\n识别模式：  \n1. 检查相同操作步骤中是否交替使用不同动词结构（有无附加动作如\"返回\"）  \n2. 对比宾语成分完整性（是否统一使用\"URI对象\"等完整术语）  \n3. 验证相邻语句中相同语义操作是否保持完全一致的动宾结构（如\"创建+宾语\" vs \"创建+宾语+返回\"）"
    },
    {
      "defect_id": 103186,
      "sentence": "判断此HashMap中是否含有该指定value。",
      "reference_sentence": "hasValue(value: V): boolean",
      "line_num": 139,
      "context": "",
      "修改建议": "术语'判断'与'hasValue'不一致",
      "更改后示例": "判断此HashMap中是否包含指定value。",
      "触发条件": "当文档动词与对应API方法名中的术语存在不一致，且存在符合代码术语的更准确动词替代时触发。\n\n识别模式：1.检查句子动词是否与API方法名中的英文术语存在翻译偏差 2.验证是否存在与API术语直接对应的规范动词（如\"hasValue\"对应\"包含\"而非\"含有\"）"
    },
    {
      "defect_id": 101406,
      "sentence": "返回arraylist的容量大小。",
      "reference_sentence": "获取当前实例的容量大小。",
      "line_num": 660,
      "context": "",
      "修改建议": "混用了'返回'和'获取'，导致表意不一致",
      "更改后示例": "获取当前实例的容量大小。",
      "触发条件": "同一功能描述中混用不同动词（如\"返回\"与\"获取\"），或与上下文/术语规范中的既定动词（如参考句的\"获取\"）产生语义冲突时触发。识别模式需检测描述同一操作的关键动词在相邻语句或规范文档中的一致性差异。"
    },
    {
      "defect_id": 102349,
      "sentence": "返回结果是否为纳秒数。",
      "reference_sentence": "返回结果是否为纳秒数。<br>- true：表示返回结果为纳秒数(ns)。 <br>- false：表示返回结果为毫秒数(ms)。<br>默认值为false。",
      "line_num": 458,
      "context": "",
      "修改建议": "用词不一致，缺少默认值描述",
      "更改后示例": "返回结果是否为纳秒数。<br>- true：表示返回结果为纳秒数(ns)。 <br>- false：表示返回结果为毫秒数(ms)。<br>默认值为false。",
      "触发条件": "当文档中存在术语/单位表述不一致（如全称与缩写混用）或参数描述缺少布尔选项对应说明及默认值时触发。\n\n识别模式：1）检查同一参数项中是否出现相同术语的不同表达形式（如\"纳秒数\"与\"ns\"未对应说明）2）验证所有布尔型参数是否明确标注true/false对应的具体含义，并包含默认值声明。"
    },
    {
      "defect_id": 51094,
      "sentence": "用户控制以及获取解析信息的选项。",
      "reference_sentence": "XML解析选项。",
      "line_num": 548,
      "context": "",
      "修改建议": "混用了'用户控制以及获取解析信息的选项'和'XML解析选项'，表意不一致。",
      "更改后示例": "XML解析选项。",
      "触发条件": "同一上下文或文档中对同一概念或功能使用不一致的术语或表达方式（如混用长描述短语与精炼术语），且存在已定义的标准化表述形式。"
    },
    {
      "defect_id": 51048,
      "sentence": "写入标签值。",
      "reference_sentence": "写入元素结束标记。",
      "line_num": 368,
      "context": "",
      "修改建议": "两个句子虽然描述不同的操作，但均使用了'写入'，建议统一使用'添加'以保持一致性。",
      "更改后示例": "添加标签值。",
      "触发条件": "同一文档中出现多个描述相似操作的动词（如“写入”和“添加”），且上下文存在已定义的统一术语要求（如参考句中的“写入”与当前操作需对齐）。 \n\n识别模式：  \n1. **动词冲突检测**：通过NLP识别操作类动词（如写入/添加/插入），比对同一文档中相似操作场景的用词差异；  \n2. **上下文关联性判断**：当动词出现在相同功能模块（如标签操作）或相邻段落时，强制要求术语统一。"
    },
    {
      "defect_id": 52642,
      "sentence": "标准uri定义主要由以下三个部分组成：",
      "reference_sentence": "标准uri定义主要由以下三个部分组成：",
      "line_num": 46,
      "context": "",
      "修改建议": "混用了'uri'和'URI'概念，应保持全文一致",
      "更改后示例": "标准URI定义主要由以下三个部分组成：",
      "触发条件": "同一术语在文档中存在全大写（如URI）和全小写（如uri）两种形式混用，且未通过驼峰命名、下划线等格式差异明确区分不同含义时触发。\n\n识别模式：通过NLP技术检测全篇术语变体（如uri/URI），结合上下文验证其是否指向同一技术概念。若同一章节/段落内出现非代码环境下的术语格式冲突（如纯文本描述中混用），则判定为表达不一致问题。"
    },
    {
      "defect_id": 50846,
      "sentence": "转换xml文本为JavaScript对象。",
      "reference_sentence": "本模块提供转换xml文本为JavaScript对象的功能。",
      "line_num": 22,
      "context": "",
      "修改建议": "重复使用了相同的表述，应保持一致。",
      "更改后示例": "转换XML文本为JavaScript对象。",
      "触发条件": "同一术语在相邻句段中存在大小写不一致（如XML/xml）或重复表述出现拼写/格式差异时触发。识别模式需检测文档中相同概念术语是否保持全大写、驼峰等统一形式，并检查重复表达是否存在非必要的用词变动。"
    },
    {
      "defect_id": 47056,
      "sentence": "当查询下载任务的MimeType成功，err为undefined，data为获取到的任务MimeType对象；否则为错误对象。",
      "reference_sentence": "当查询下载任务成功，err为undefined，data为获取到的DownloadInfo对象；否则为错误对象。",
      "line_num": 2120,
      "context": "",
      "修改建议": "混用了'任务'和'任务的MimeType'，应保持用词一致，建议统一使用'任务'。",
      "更改后示例": "当查询下载任务的MimeType成功，err为undefined，data为获取到的MimeType对象；否则为错误对象。",
      "触发条件": "同一句子或相邻分句中，对同一实体使用不一致的限定词（如\"任务\"和\"任务的MimeType\"），或重复出现冗余修饰词（如\"任务MimeType对象\"中的双重限定），导致概念层级混乱时触发。"
    },
    {
      "defect_id": 51047,
      "sentence": "写入注释内容。",
      "reference_sentence": "写入元素结束标记。",
      "line_num": 290,
      "context": "",
      "修改建议": "两个句子虽然描述不同的操作，但均使用了'写入'，建议统一使用'添加'以保持一致性。",
      "更改后示例": "添加注释内容。",
      "触发条件": "同一文档中出现多个动词描述相同或类似操作时，或存在重复动词但需统一为更一致术语时。\n\n识别模式：\n1. 通过NLP动词提取技术识别相邻段落/功能描述中的动作主体\n2. 当检测到「写入」「添加」「插入」等语义相近但表述不同的动词时\n3. 结合术语库校验：若文档中已有高频使用词（如案例中的「添加」出现频次＞3次）\n4. 上下文语义分析确认动词指向同类操作（如本例中「注释内容」和「元素结束标记」均属文档标记操作）"
    },
    {
      "defect_id": 45235,
      "sentence": "获取LauncherAbilityInfos，使用Promise异步回调。",
      "reference_sentence": "获取所有的LauncherAbilityInfos，使用callback异步回调。",
      "line_num": 56,
      "context": "",
      "修改建议": "混用了'获取'与'获取所有的'，且'使用Promise异步回调'与'使用callback异步回调'不一致。",
      "更改后示例": "获取所有的LauncherAbilityInfos，使用Promise异步回调。",
      "触发条件": "同一操作描述存在动词/修饰词不一致（如\"获取\"与\"获取所有的\"混用）或异步机制术语不统一（如\"Promise\"与\"callback\"共存）时触发。"
    },
    {
      "defect_id": 47186,
      "sentence": "1. 刚被 request.agent.create 接口创建的任务",
      "reference_sentence": "1. 刚被request.agent.create接口创建的任务",
      "line_num": 3729,
      "context": "",
      "修改建议": "混用了'request.agent.create 接口'和'request.agent.create接口'概念",
      "更改后示例": "1. 刚被request.agent.create接口创建的任务",
      "触发条件": "当同一文档中出现相同技术术语存在格式不一致（如接口名称与\"接口\"之间空格使用不统一）时触发。\n\n识别模式：\n1. 检测技术术语（如request.agent.create）与后缀词（如\"接口\"）的间距一致性\n2. 对比文档中所有同类结构（如XXX接口/XXX 接口），识别出混合使用带空格与无空格两种格式的情况"
    },
    {
      "defect_id": 121720,
      "sentence": "下文将展示如何在应用内增加一个按钮，并单击该按钮以调用Hidebug Ndk接口。",
      "reference_sentence": "HiDebug模块对外提供应用调试功能。",
      "line_num": 22,
      "context": "",
      "修改建议": "混用了'HiDebug'和'Hidebug'术语",
      "更改后示例": "下文将展示如何在应用内增加一个按钮，并单击该按钮以调用HiDebug Ndk接口。",
      "触发条件": "当同一术语在文档中存在大小写或拼写形式不一致（如HiDebug/Hidebug），且存在明确定义的参考标准形式（如参考句中的HiDebug）时触发。"
    },
    {
      "defect_id": 107081,
      "sentence": "| hidebug.startJsCpuProfiling        | 启动虚拟机Profiling方法跟踪。                                |",
      "reference_sentence": "HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling采集等操作。",
      "line_num": 19,
      "context": "",
      "修改建议": "原文中使用了'虚拟机CPU Profiling采集'，而此处使用了'启动虚拟机Profiling方法跟踪'，应保持一致。",
      "更改后示例": "| hidebug.startJsCpuProfiling        | 启动虚拟机CPU Profiling方法跟踪。                                |",
      "触发条件": "当同一技术术语在文档中出现关键修饰词（如\"CPU\"）缺失或变更，且该术语在上下文或参考内容中存在完整表述时触发。\n\n识别模式：\n1. 通过术语嵌套结构识别（如\"X Y\" vs 单独使用\"Y\"）\n2. 对比文档中相同技术点的不同表述（如\"Profiling方法跟踪\" vs \"CPU Profiling采集\"）\n3. 检测核心参数/限定词的一致性（如CPU、内存等专业修饰语）\n4. 匹配参考内容中的完整术语表达形式（参考句中的\"CPU Profiling\"作为基准）"
    },
    {
      "defect_id": 107080,
      "sentence": "HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling采集等操作。",
      "reference_sentence": "HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling采集等操作。",
      "line_num": 3,
      "context": "",
      "修改建议": "原文中使用了'虚拟机CPU Profiling采集'，而下文使用了'启动虚拟机Profiling方法跟踪'和'停止虚拟机Profiling方法跟踪'，应保持一致。",
      "更改后示例": "HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling方法跟踪等操作。",
      "触发条件": "同一术语在文档中出现多种表达形式，且相邻上下文存在相关操作描述需保持动词一致性。\n\n识别模式：当特定名词短语（如\"虚拟机CPU Profiling\"）后接不同动作动词（如\"采集\"与\"方法跟踪\"），且上下文存在关联操作（如\"启动/停止...方法跟踪\"）时，需统一动作描述。通过对比术语的修饰成分及其在文档中的使用场景进行识别。"
    },
    {
      "defect_id": 121721,
      "sentence": "4. 将TestHidebugNdk注册为ArkTS接口：",
      "reference_sentence": "HiDebug模块对外提供应用调试功能。",
      "line_num": 70,
      "context": "",
      "修改建议": "混用了'HiDebug'和'Hidebug'术语",
      "更改后示例": "4. 将TestHiDebugNdk注册为ArkTS接口：",
      "触发条件": "同一术语在文档中存在拼写变体（如HiDebug与Hidebug）、大小写不一致或缩写形式冲突时触发；特定技术名词在参考句/标准术语库中有明确定义，但实际使用出现偏离时触发。\n\n识别模式：通过术语抽取匹配技术名词变体（如Hidebug/HiDebug），结合上下文语义分析判断是否为同一概念；对比预定义术语表或参考句中的标准表达（如\"HiDebug模块\"），检测是否存在字母组合/语义等价性偏差。"
    },
    {
      "defect_id": 47187,
      "sentence": "2. 使用 request.agent.create 接口创建的已经失败或者停止的下载任务",
      "reference_sentence": "2. 使用request.agent.create接口创建的已经失败或者停止的下载任务",
      "line_num": 3730,
      "context": "",
      "修改建议": "混用了'request.agent.create 接口'和'request.agent.create接口'概念",
      "更改后示例": "2. 使用request.agent.create接口创建的已经失败或者停止的下载任务",
      "触发条件": "同一技术术语在相邻位置存在格式差异（如接口名称与\"接口\"之间是否保留空格），且文档中存在该术语的标准书写形式作为参照。  \n\n识别模式：通过对比同一文档中相同术语的书写形式（如\"X接口\"与\"X 接口\"），检测术语与后续词汇间的空格一致性，当出现术语连接词间距不一致且存在明确参照标准时触发规则。"
    },
    {
      "defect_id": 121876,
      "sentence": "### 结构体",
      "reference_sentence": "### 结构体",
      "line_num": 20,
      "context": "",
      "修改建议": "用词不一致，建议将“结构体”改为“结构体定义”，以保持一致。",
      "更改后示例": "### 结构体定义",
      "触发条件": "当检测到文档中存在相同层级或相邻标题结构，且核心术语（如\"结构体\"）与上下文同类标题存在用词差异时触发。识别模式需满足：1) 标题符层级相同（如###级）且语法结构相似；2) 术语在相同语义范畴内存在多种表达形式（如基础词与扩展词混用）。"
    },
    {
      "defect_id": 107082,
      "sentence": "| hidebug.stopJsCpuProfiling         | 停止虚拟机Profiling方法跟踪。                                |",
      "reference_sentence": "HiDebug对外提供系统调试相关功能的接口，包括应用进程的静态堆内存（native heap）信息、应用进程内存占用PSS（Proportional Set Size）信息的获取等，也可完成虚拟机内存切片导出，虚拟机CPU Profiling采集等操作。",
      "line_num": 20,
      "context": "",
      "修改建议": "原文中使用了'虚拟机CPU Profiling采集'，而此处使用了'停止虚拟机Profiling方法跟踪'，应保持一致。",
      "更改后示例": "| hidebug.stopJsCpuProfiling         | 停止虚拟机CPU Profiling方法跟踪。                                |",
      "触发条件": "当同一技术术语在文档中存在带限定词（如\"CPU\"）和未带限定词（如\"Profiling\"）两种表达形式时，或关键限定词（如CPU/内存/堆等）在同类描述中被不一致省略时触发。\n\n识别模式：\n1. 检查技术名词是否与文档其他章节的完整命名冲突（如参考句中的\"CPU Profiling\" vs 问题句的\"Profiling\"）\n2. 识别技术动作描述中是否缺少必要限定词，特别是当限定词涉及具体技术维度（CPU/内存/网络等）且文档中存在完整表述先例时"
    },
    {
      "defect_id": 121874,
      "sentence": "HiDebug模块代码结构体定义。 \\@kit PerformanceAnalysisKit",
      "reference_sentence": "HiDebug模块代码结构体定义。 \\@kit PerformanceAnalysisKit",
      "line_num": 6,
      "context": "",
      "修改建议": "无用词混用，文档中应避免使用特殊符号或标记，除非是约定俗成的标记。此处的`\\@kit`未在文档规范中提及，建议移除。",
      "更改后示例": "HiDebug模块代码结构体定义。",
      "触发条件": "检测到文档中存在未在规范中定义的特殊符号/标记（如非标准标签`\\@kit`），或使用了未被认可的混合格式符号时触发。\n\n识别模式：通过正则表达式匹配非常规符号（如`\\@[a-zA-Z]+`）、对比预设白名单（如仅允许`@param`/`@return`等标准标签）进行识别，若符号既非约定俗成格式，又未在文档规范中明确说明用途，则判定为冗余标记需移除。"
    },
    {
      "defect_id": 47105,
      "sentence": "后台任务通知开关，开启后可在通知中显示下载状态(默认使用false)。",
      "reference_sentence": "后台任务通知开关，开启后可在通知中显示下载状态(默认使用false)。",
      "line_num": 2318,
      "context": "",
      "修改建议": "虽然用词一致，但可以简化描述以保持一致性和清晰度。",
      "更改后示例": "后台任务通知开关，开启后可在通知中显示下载状态（默认值为false）。",
      "触发条件": "当同一技术参数存在\"默认值/默认设置/默认使用\"等不同表述方式时，或当括号符号（全角/半角）与上下文格式规范不一致时触发。\n\n识别模式：\n1. 术语一致性检测：通过预定义技术术语库（如{\"默认值\":\"默认设置\",\"默认使用\"}）匹配非标准表述\n2. 符号规范检测：识别括号符号是否遵循上下文的全角/半角使用规范（中文文档多采用全角括号）\n3. 跨文档对比：当同一参数在系统其他位置使用\"默认值\"标准表述时，当前\"默认使用\"即构成表述不一致"
    },
    {
      "defect_id": 174662,
      "sentence": "## 亮点/特征",
      "reference_sentence": "## 亮点/特性",
      "line_num": 46,
      "context": "{\"41\":\"- 支持应用触发数据备份恢复（仅对系统应用开放）。\",\"42\":\"<!--DelEnd-->\",\"43\":\"- 提供[用户文件访问框架](#用户文件访问框架)，用于开发者访问和管理用户文件。例如选择与保存用户文件<!--Del-->和开发用户文件管理器（仅对系统应用开放）<!--DelEnd-->。\",\"44\":\"- 支持跨设备的文件访问和拷贝能力。\",\"45\":\"\",\"46\":\"## 亮点/特征\",\"47\":\"\",\"48\":\"- 沙箱隔离：\",\"49\":\"访问和管理应用文件，对于每个应用，系统会在内部存储空间映射出一个专属的“[应用沙箱目录](app-sandbox-directory.md#应用沙箱目录)”，它是“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。有以下优点：\",\"50\":\"  - 隔离性：应用沙箱提供了一个完全隔离的环境，使用户可以安全地访问应用文件。\",\"51\":\"  - 安全性：应用沙箱限制了应用可见的数据的最小范围，保护了应用文件的安全。\"}",
      "修改建议": "混用了“特征”和“特性”描述同一概念",
      "更改后示例": "## 亮点/特性",
      "触发条件": "同一文档中在相近上下文或同一概念描述中混用了多个同义或近义术语（如“特征”与“特性”），且存在已统一使用的参考术语模式。\n\n识别模式：\n1. 在相邻章节标题/同级列表项中检测到术语变体（如“特征”与“特性”交替出现）\n2. 通过对比上下文术语使用频率，发现非常用术语与已建立的术语模式（如参考句中的“特性”）冲突\n3. 术语差异出现在关键位置（如标题层级、技术概念定义处），影响文档专业性和一致性"
    },
    {
      "defect_id": 121881,
      "sentence": "应用程序进程内存限制结构类型定义。",
      "reference_sentence": "应用程序进程内存限制结构类型定义。",
      "line_num": 27,
      "context": "",
      "修改建议": "用词不一致，建议将“结构类型定义”改为“结构体”，以保持一致。",
      "更改后示例": "应用程序进程内存限制结构体。",
      "触发条件": "同一文档中同一技术概念存在多个不同术语表达（如“结构类型定义”与“结构体”），且其中一个术语已被上下文或规范明确为统一用词时触发。\n\n识别模式：\n1. **术语冲突检测**：通过NLP识别同指实体（如“结构类型定义”与“结构体”指向同一数据结构）；\n2. **上下文一致性验证**：比对文档内已统一使用的标准术语（如参考句子中的“结构体”高频出现）；\n3. **领域规范匹配**：技术文档中需符合编程术语惯例（如“结构体”为C/C++标准术语）。"
    },
    {
      "defect_id": 121877,
      "sentence": "### 宏定义",
      "reference_sentence": "### 宏定义",
      "line_num": 30,
      "context": "",
      "修改建议": "用词不一致，建议将“宏定义”改为“宏定义列表”，以保持一致。",
      "更改后示例": "### 宏定义列表",
      "触发条件": "当标题术语与文档内同类标题结构不一致（如缺少必要后缀/限定词），且存在已确立的命名模式（如\"X列表\"）时触发。"
    },
    {
      "defect_id": 47104,
      "sentence": "设置是否允许在漫游网络中下载(默认使用false)。",
      "reference_sentence": "设置是否允许在漫游网络中下载(默认使用false)。",
      "line_num": 2313,
      "context": "",
      "修改建议": "虽然用词一致，但可以简化描述以保持一致性和清晰度。",
      "更改后示例": "设置是否允许在漫游网络中下载（默认值为false）。",
      "触发条件": "检测到参数默认值描述存在术语不一致（如\"使用\"与\"值\"混用）或存在冗余表达（如\"默认使用\"替代\"默认值\"）时触发。"
    },
    {
      "defect_id": 182392,
      "sentence": "本文主要介绍如何使用HiAppEvent提供的ArkTs接口订阅应用崩溃事件",
      "reference_sentence": "## 接口描述",
      "line_num": 5,
      "context": "{\"1\":\"# 订阅崩溃事件（ArkTS）\",\"2\":\"\",\"3\":\"## 接口描述\",\"4\":\"\",\"5\":\"本文主要介绍如何使用HiAppEvent提供的ArkTs接口订阅应用崩溃事件，接口的详细使用说明（参数使用限制、具体取值范围等）请参考[应用事件打点API文档](../reference/apis-performance-analysis-kit/js-apis-hiviewdfx-hiappevent.md)。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 使用ArkTS接口订阅崩溃事件，包含JsError和NativeCrash两种崩溃类型。\",\"10\":\"\"}",
      "修改建议": "混用了`ArkTS`和`ArkTs`概念",
      "更改后示例": "本文主要介绍如何使用HiAppEvent提供的ArkTS接口订阅应用崩溃事件",
      "触发条件": "同一文档中技术术语存在大小写不一致（如\"ArkTS\"与\"ArkTs\"混用），且上下文存在该术语的标准拼写形式（如标题/代码规范中的\"ArkTS\"）。"
    },
    {
      "defect_id": 121879,
      "sentence": "系统内存信息结构类型定义。",
      "reference_sentence": "系统内存信息结构类型定义。",
      "line_num": 25,
      "context": "",
      "修改建议": "用词不一致，建议将“结构类型定义”改为“结构体”，以保持一致。",
      "更改后示例": "系统内存信息结构体。",
      "触发条件": "检测到同一技术术语存在多种表述形式（如“结构类型定义”与“结构体”），且其中至少一种表述不符合项目规范或高频使用惯例时触发。\n\n识别模式：\n1. 通过术语库/高频词表匹配，识别非常规表述（如\"结构类型定义\"在代码库中无对应定义）\n2. 对比上下文同类表述（如相邻章节的\"结构体声明\"），发现命名逻辑断层\n3. 验证技术准确性（如C/C++中struct的标准中文译法应为\"结构体\"）"
    },
    {
      "defect_id": 121878,
      "sentence": "应用程序所有线程的CPU使用率结构体定义。",
      "reference_sentence": "应用程序所有线程的CPU使用率结构体定义。",
      "line_num": 24,
      "context": "",
      "修改建议": "用词不一致，建议将“结构体定义”改为“结构体”，以保持一致。",
      "更改后示例": "应用程序所有线程的CPU使用率结构体。",
      "触发条件": "当同一术语在文档中存在冗余后缀（如\"定义\"）或命名不一致时触发，特别是当核心术语（如\"结构体\"）已在上下文明确指代技术概念的情况下。  \n\n识别模式：  \n1. 检测\"名词+冗余限定词\"结构（如XX定义/XX类型/XX数据）  \n2. 对比上下文术语使用频率，当短格式术语（如\"结构体\"）已成为主要表达方式时，长格式表达需被修正"
    },
    {
      "defect_id": 121880,
      "sentence": "应用程序进程本机内存信息结构类型定义。",
      "reference_sentence": "应用程序进程本机内存信息结构类型定义。",
      "line_num": 26,
      "context": "",
      "修改建议": "用词不一致，建议将“结构类型定义”改为“结构体”，以保持一致。",
      "更改后示例": "应用程序进程本机内存信息结构体。",
      "触发条件": "当同一技术概念存在多个术语变体（如\"结构类型定义\"与\"结构体\"）且上下文存在明确统一用词标准时，或当名词性术语与动词性描述混合使用导致语义模糊时。\n\n识别模式：\n1. 检测名词短语中是否包含冗余修饰词（如\"类型定义\"对\"结构体\"）\n2. 比对文档术语库/上下文高频用词，识别非常规表达形式\n3. 分析复合术语的构词逻辑，验证是否符合\"核心名词+限定词\"的标准结构\n4. 检查技术术语是否保持单一词性（如统一使用名词形式而非动名词结构）"
    },
    {
      "defect_id": 214992,
      "sentence": "首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。",
      "reference_sentence": "首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。",
      "line_num": 81,
      "context": "{\"76\":\"\",\"77\":\"### 客户端连接服务，获取服务代理proxy\",\"78\":\"\",\"79\":\"**创建变量want和connect**\",\"80\":\"\",\"81\":\"  首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。<br/>\",\"82\":\"  其次，构造变量connect，指定连接成功、连接失败和断开连接时的回调函数。<br/>\",\"83\":\"\",\"84\":\"  在IPC场景下，创建变量want和connect，连接服务。\",\"85\":\"  ```ts\",\"86\":\"    import { Want, common } from '@kit.AbilityKit';\"}",
      "修改建议": "术语'NetworkId'未在术语表中定义，需要在术语表中给出解释。",
      "更改后示例": "首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的网络标识（NetworkId）（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的网络标识（NetworkId））。",
      "触发条件": "当文档中首次出现未在术语表定义的英文缩略词时，或同一术语的中英文混合表达在上下文出现不一致（如首次使用全英文形式，后续却改用中文+英文括号标注形式）时触发该规则。\n\n识别模式：通过检测括号内外的术语对应关系（如\"NetworkId\"与\"网络标识\"）、术语首次出现是否遵循\"中文全称（英文缩写）\"格式，以及同一术语在段落中是否保持完全一致的表达形式（如重复出现时仅保留中文或英文）。"
    },
    {
      "defect_id": 214476,
      "sentence": "FA模型使用featureAbility提供的[connectAbility](../reference/apis-ability-kit/js-apis-ability-featureAbility.md#featureabilitydisconnectability7)接口连接Ability。",
      "reference_sentence": "FA模型使用FeatureAbility提供的[connectAbility](../reference/apis-ability-kit/js-apis-ability-featureAbility.md#featureabilitydisconnectability7)接口连接Ability。",
      "line_num": 159,
      "context": "{\"154\":\"    }\",\"155\":\"  ```\",\"156\":\"\",\"157\":\"**连接服务**\",\"158\":\"\",\"159\":\"  FA模型使用featureAbility提供的[connectAbility](../reference/apis-ability-kit/js-apis-ability-featureAbility.md#featureabilitydisconnectability7)接口连接Ability。\",\"160\":\"\",\"161\":\"  ```ts\",\"162\":\"    import { featureAbility } from '@kit.AbilityKit';\",\"163\":\"\",\"164\":\"    // 建立连接后返回的Id需要保存下来，在解绑服务时需要作为参数传入\"}",
      "修改建议": "混用了'featureAbility'与'FeatureAbility'，应保持一致。",
      "更改后示例": "FA模型使用FeatureAbility提供的[connectAbility](../reference/apis-ability-kit/js-apis-ability-featureAbility.md#featureabilitydisconnectability7)接口连接Ability。",
      "触发条件": "当同一术语在相邻上下文中出现大小写形式不一致（如首字母大小写混用），且存在明确的文档规范或参考用例时触发。识别模式需检测术语变体（如\"featureAbility\"与\"FeatureAbility\"）在同一段落/代码块中的共存冲突。"
    },
    {
      "defect_id": 188598,
      "sentence": "取消通过[on](#on)注册的事件处理函数。",
      "reference_sentence": "注册事件处理函数来监听可写流上的不同事件。",
      "line_num": 337,
      "context": "{\"332\":\"\",\"333\":\"### off\",\"334\":\"\",\"335\":\"off(event: string, callback?: Callback<emitter.EventData>): void\",\"336\":\"\",\"337\":\"取消通过[on](#on)注册的事件处理函数。\",\"338\":\"\",\"339\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"340\":\"\",\"341\":\"**系统能力：** SystemCapability.Utils.Lang\",\"342\":\"\"}",
      "修改建议": "这里使用了'取消'与'注册'的对比，建议使用'移除'与'注册'，以保持一致。",
      "更改后示例": "移除通过[on](#on)注册的事件处理函数。",
      "触发条件": "当文档中动词与上下文已建立的术语搭配模式不一致时（如\"注册\"对应\"移除\"而非\"取消\"），或存在语义关联动作但用词未形成规范配对时触发。"
    },
    {
      "defect_id": 214475,
      "sentence": "RPC 场景下，构造变量want和connect，连接服务。",
      "reference_sentence": "RPC 场景下，创建变量want和connect，连接服务。",
      "line_num": 114,
      "context": "{\"109\":\"        hilog.info(0x0000, 'testTag', 'RpcClient: onFailed');\",\"110\":\"      }\",\"111\":\"    };\",\"112\":\"  ```\",\"113\":\"\",\"114\":\"  RPC 场景下，构造变量want和connect，连接服务。\",\"115\":\"  ```ts \",\"116\":\"    import { Want, common } from '@kit.AbilityKit';\",\"117\":\"    import { rpc } from '@kit.IPCKit';\",\"118\":\"    import { hilog } from '@kit.PerformanceAnalysisKit';\",\"119\":\"    import { distributedDeviceManager } from '@kit.DistributedServiceKit';\"}",
      "修改建议": "混用了'构造'与'创建'，应保持一致。",
      "更改后示例": "RPC 场景下，创建变量want和connect，连接服务。",
      "触发条件": "同一上下文或相邻段落中出现描述相同操作时使用不一致的动词（如\"构造\"与\"创建\"混用），且存在已定义的规范术语（如参考句中的\"创建\"）时触发。\n\n识别模式：\n1. 动词冲突检测：在技术操作描述中识别具有相同语义的动词（如创建/构造/初始化）\n2. 上下文一致性验证：检查当前动词是否与参考句/规范文档的术语保持一致\n3. 邻近性判断：当不一致术语出现在同一功能模块描述或相邻代码注释中（如案例中变量声明代码块与操作说明的紧邻关系）时优先触发"
    },
    {
      "defect_id": 223280,
      "sentence": "这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。",
      "reference_sentence": "这个信号表示浮点溢出错误。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。",
      "line_num": 446,
      "context": "{\"441\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\",\"442\":\"| -------- | -------- | -------- | -------- |\",\"443\":\"| 1 | FPE_INTDIV | 整数除法错误。 | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。|\",\"444\":\"| 2 | FPE_INTOVF | 整数溢出错误。 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。|\",\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"450\":\"| 8 | FPE_FLTSUB | 浮点陷阱错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"451\":\"\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“浮点数除法中的除数为负数的情况”但实际上应该是“浮点溢出错误”。",
      "更改后示例": "这个信号表示浮点溢出错误。当一个程序尝试进行浮点数运算，结果超出浮点数范围时，会发出这个信号。",
      "触发条件": "当文档中同一实体的分类/解释（如\"浮点溢出错误\"）与触发原因描述（如\"除数为负数\"）存在术语矛盾或逻辑不一致时；或同类条目间存在关键术语（如错误类型与触发条件）的异常偏差时。  \n\n识别模式：  \n1. 垂直校验：检查同一行内分类名称（如FPE_FLTOVF）对应的解释字段（浮点溢出错误）是否与触发原因描述（运算结果超出范围）逻辑匹配  \n2. 横向对比：识别同类信号（如所有FPE_FLT*条目）是否保持错误类型（溢出/下溢/未定义等）与触发条件（除数/运算结果等）的对应关系一致性"
    },
    {
      "defect_id": 214851,
      "sentence": "上述onConnect回调函数中的proxy对象需要等ability异步连接成功后才会被赋值，然后才可调用proxy对象的[registerDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#registerdeathrecipient9-1)接口方法注册死亡回调，在proxy不再使用的时候，调用[unregisterDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#unregisterdeathrecipient9-1)接口方法注销死亡回调。",
      "reference_sentence": "上述onConnect回调函数中的Proxy对象需要等ability异步连接成功后才会被赋值，然后才可调用Proxy对象的[registerDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#registerdeathrecipient9-1)接口方法注册死亡回调，在Proxy不再使用的时候，调用[unregisterDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#unregisterdeathrecipient9-1)接口方法注销死亡回调。",
      "line_num": 61,
      "context": "{\"56\":\"\",\"57\":\"let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext; // UIAbilityContext\",\"58\":\"let connectionId = context.connectServiceExtensionAbility(want, connect);\",\"59\":\"```\",\"60\":\"\",\"61\":\"上述onConnect回调函数中的proxy对象需要等ability异步连接成功后才会被赋值，然后才可调用proxy对象的[registerDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#registerdeathrecipient9-1)接口方法注册死亡回调，在proxy不再使用的时候，调用[unregisterDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#unregisterdeathrecipient9-1)接口方法注销死亡回调。\",\"62\":\"\",\"63\":\"```ts\",\"64\":\"import { rpc } from '@kit.IPCKit';\",\"65\":\"import { hilog } from '@kit.PerformanceAnalysisKit';\",\"66\":\"\"}",
      "修改建议": "混用了'proxy'和'Proxy'，建议统一使用'Proxy'。",
      "更改后示例": "上述onConnect回调函数中的Proxy对象需要等ability异步连接成功后才会被赋值，然后才可调用Proxy对象的[registerDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#registerdeathrecipient9-1)接口方法注册死亡回调，在Proxy不再使用的时候，调用[unregisterDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#unregisterdeathrecipient9-1)接口方法注销死亡回调。",
      "触发条件": "同一术语在上下文出现大小写混用（如\"Proxy/proxy\"）或与项目命名规范不符，且存在至少两处不一致的拼写形式时触发。\n\n识别模式：通过NLP工具检测特定名词在文档中的连续出现形式，当检测到同一词汇存在不同大小写变体（如驼峰式 vs 全小写），且上下文未明确区分不同语义时，结合代码上下文中的类名大写惯例（如代码示例中的UIAbilityContext）进行交叉验证。"
    },
    {
      "defect_id": 214472,
      "sentence": "首先，构造变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。",
      "reference_sentence": "首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。",
      "line_num": 81,
      "context": "{\"76\":\"\",\"77\":\"### 客户端连接服务，获取服务代理proxy\",\"78\":\"\",\"79\":\"**构造变量want和connect**\",\"80\":\"\",\"81\":\"  首先，构造变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。<br/>\",\"82\":\"  其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。<br/>\",\"83\":\"\",\"84\":\"  IPC 场景下，构造变量want和connect，连接服务。\",\"85\":\"  ```ts\",\"86\":\"    import { Want, common } from '@kit.AbilityKit';\"}",
      "修改建议": "混用了'构造'与'创建'，应保持一致。",
      "更改后示例": "首先，创建变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。",
      "触发条件": "当同一上下文中对相同操作使用不同动词（如\"构造\"与\"创建\"）时，或同一技术概念存在多个表达术语时触发。\n\n识别模式：\n1. 对比相邻段落/标题中描述相同技术动作的动词一致性（如变量初始化动作在标题用\"构造\"，正文却用\"创建\"）\n2. 检查核心技术名词是否与上下文/参考规范保持统一（如变量定义操作应固定使用\"创建\"而非\"构造\"）\n3. 通过相邻句子的平行结构检测术语突变（如\"构造变量want...构造变量connect\"应保持动词一致性）"
    },
    {
      "defect_id": 214850,
      "sentence": "这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地proxy对象以及相关资源。",
      "reference_sentence": "这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地Proxy对象以及相关资源。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"IPC/RPC提供对远端Stub对象状态的订阅机制。当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种状态通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。使用这种订阅机制的用户需要实现死亡通知接口DeathRecipient，并实现onRemoteDied方法清理资源。该方法会在远端Stub对象所在进程退出或当前RPC通信依赖的软总线连接断开时被回调。需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied回调方法。\",\"4\":\"\",\"5\":\"## 使用场景\",\"6\":\"\",\"7\":\"这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地proxy对象以及相关资源。此外，RPC不提供匿名Stub对象的死亡通知，即只有向SAMgr注册过的服务才能被订阅死亡通知，而IPC支持匿名对象的死亡通知。\",\"8\":\"\",\"9\":\"## ArkTS侧接口\",\"10\":\"\",\"11\":\"> **说明：**\",\"12\":\">\"}",
      "修改建议": "混用了'proxy'和'Proxy'，建议统一使用'Proxy'。",
      "更改后示例": "这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地Proxy对象以及相关资源。",
      "触发条件": "同一术语在相邻或同一上下文中出现大小写不一致（例如\"Proxy/proxy\"），且该术语在文档中被明确定义为专有名词或技术组件时。  \n识别模式：通过对比术语在上下文中的首次规范形式（如首字母大写\"Proxy\"）与后续出现的变体形式（如全小写\"proxy\"），检测是否存在非技术性的大小写混用。"
    },
    {
      "defect_id": 215025,
      "sentence": "在成功添加死亡通知订阅后，当远端对象死亡时，将自动调用本方法。",
      "reference_sentence": "在成功添加死亡通知订阅后，当远端对象死亡时，将自动调用本方法。",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"| 接口名                                                       | 返回值类型 | 功能描述                                                     |\",\"20\":\"| ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |\",\"21\":\"| [registerDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#registerdeathrecipient9-1) | void       | 注册用于接收远程对象死亡通知的回调，该方法应该在proxy侧调用。 |\",\"22\":\"| [unregisterDeathRecipient](../reference/apis-ipc-kit/js-apis-rpc.md#unregisterdeathrecipient9-1) | void       | 注销用于接收远程对象死亡通知的回调。                         |\",\"23\":\"| [onRemoteDied](../reference/apis-ipc-kit/js-apis-rpc.md#onremotedied) | void       | 在成功添加死亡通知订阅后，当远端对象死亡时，将自动调用本方法。 |\",\"24\":\"\",\"25\":\"### 参考代码\",\"26\":\"\",\"27\":\"```ts\",\"28\":\"// FA模型需要从@kit.AbilityKit导入featureAbility\"}",
      "修改建议": "使用了'死亡通知订阅'和'死亡通知'两种不同的词汇描述同一概念。",
      "更改后示例": "在成功添加死亡通知后，当远端对象死亡时，将自动调用本方法。",
      "触发条件": "同一文档或相邻段落中存在对同一概念使用不同术语的情况，且这些术语在接口定义或功能描述中已有明确统一表述。识别模式为检查核心名词短语是否与上下文接口命名、参数命名或已有术语库保持一致。"
    },
    {
      "defect_id": 214990,
      "sentence": "> - 当前使用场景： 客户端是三方应用，服务端是系统应用。",
      "reference_sentence": "> - 当前使用场景： 客户端是三方应用，服务端是系统应用。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> - 当前不支持三方应用实现ServiceExtensionAbility，三方应用的UIAbility组件可以通过[Context](../application-models/uiability-usage.md#获取uiability的上下文信息)连接系统提供的ServiceExtensionAbility实现。\",\"12\":\">\",\"13\":\"> - 当前使用场景： 客户端是三方应用，服务端是系统应用。\",\"14\":\"\",\"15\":\"### 创建ServiceExtensionAbility，实现服务端\",\"16\":\"\",\"17\":\"  定义一个stub类，继承自[rpc.RemoteObject](../reference/apis-ipc-kit/js-apis-rpc.md#remoteobject)的对象，实现[onRemoteMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#onremotemessagerequest9)方法，用来处理客户端的请求。\",\"18\":\"\"}",
      "修改建议": "术语'客户端'和'服务端'未在术语表中定义，需要在术语表中给出解释。",
      "更改后示例": "> - 当前使用场景： 客户端（Client）是三方应用，服务端（Server）是系统应用。",
      "触发条件": "文档中首次出现未在术语表定义的领域专有名词，且该术语存在官方英文对应词需要补充说明时。识别模式需同时满足：(1) 术语未在术语表注册；(2) 术语首次出现在当前文档；(3) 存在需要明确的英文技术对应词（如Client/Server）。"
    },
    {
      "defect_id": 214474,
      "sentence": "IPC 场景下，构造变量want和connect，连接服务。",
      "reference_sentence": "IPC 场景下，创建变量want和connect，连接服务。",
      "line_num": 84,
      "context": "{\"79\":\"**构造变量want和connect**\",\"80\":\"\",\"81\":\"  首先，构造变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。<br/>\",\"82\":\"  其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。<br/>\",\"83\":\"\",\"84\":\"  IPC 场景下，构造变量want和connect，连接服务。\",\"85\":\"  ```ts\",\"86\":\"    import { Want, common } from '@kit.AbilityKit';\",\"87\":\"    import { rpc } from '@kit.IPCKit';\",\"88\":\"    import { hilog } from '@kit.PerformanceAnalysisKit';\",\"89\":\"    import { distributedDeviceManager } from '@kit.DistributedServiceKit';\"}",
      "修改建议": "混用了'构造'与'创建'，应保持一致。",
      "更改后示例": "IPC 场景下，创建变量want和connect，连接服务。",
      "触发条件": "同一段落或邻近上下文中对同一操作（如变量初始化）使用了多个不同的动词（如“构造”与“创建”），且存在已确立的标准术语（如参考句中的“创建”）。\n\n识别模式：\n1. **术语冲突检测**：在相邻句子或同一技术步骤描述中，针对同一对象（如变量）出现不同动作动词；\n2. **上下文锚定**：通过文档前文（如问题上下文第79/81行）或参考句确认标准术语，对比当前用词是否偏离。"
    },
    {
      "defect_id": 223256,
      "sentence": "napi_value超出NAPI框架的scope，如下：",
      "reference_sentence": "napi_value只能在napi_handle_scope的作用域范围内进行使用，离开napi_handle_scope作用域范围后，napi_value及它所持有的js对象的生命周期不再得到保护，一旦引用计数为0，就会被GC回收掉，此时再去使用napi_value就会访问已释放的内存，产生问题。",
      "line_num": 352,
      "context": "{\"347\":\"\",\"348\":\"根据崩溃栈反编译找到出现问题的napi接口的上层接口，在上层接口内找到出问题的napi_value，检查napi_value的使用范围是否超出了napi_handle_scope的作用域范围。\",\"349\":\"\",\"350\":\"**案例**\",\"351\":\"\",\"352\":\"napi_value超出NAPI框架的scope，如下：\",\"353\":\"\",\"354\":\"![cppcrash-demo9](figures/cppcrash_image_016.png)\",\"355\":\"\",\"356\":\"js侧通过Add接口添加数据，native侧以napi_value保存到vector，js侧通过get接口获取添加的数据，native侧将保存的napi_value以数组形式返回回去，然后js侧读取数据的属性。出现报错：Can not get Prototype on non ECMA Object。跨napi的native_value未使用napi_ref保存，导致native_value失效。\",\"357\":\"注：NAPI框架的scope即napi_handle_scope，napi开发者可以通过napi_handle_scope来管理napi_value的生命周期。框架层的scope嵌入在js call native的端到端流程中，即进入开发者自己写的native方法前open scope，native方法结束后close scope。\"}",
      "修改建议": "混用了`scope`和`作用域`概念",
      "更改后示例": "napi_value超出napi_handle_scope的作用域范围，如下：",
      "触发条件": "同一技术概念在相邻段落或同一技术描述中混用中英文术语（如\"scope\"与\"作用域\"），且未通过括号说明建立等价关系时。\n\n识别模式：\n1. 术语冲突检测：在问题描述/修复建议/参考句子等关联段落中，同一技术实体存在两种及以上语言形式的命名（如英文术语\"scope\"与中文术语\"作用域\"）\n2. 语义等价验证：未通过\"即\"、\"即指\"等说明性句式建立术语映射关系（如问题上下文第357行通过\"scope即napi_handle_scope\"明确术语对应关系则不触发）"
    },
    {
      "defect_id": 215024,
      "sentence": "当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种状态通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。",
      "reference_sentence": "当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种状态通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。",
      "line_num": 3,
      "context": "{\"1\":\"# 远端状态订阅开发实例\",\"2\":\"\",\"3\":\"IPC/RPC提供对远端Stub对象状态的订阅机制。当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种状态通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。使用这种订阅机制的用户需要实现死亡通知接口DeathRecipient，并实现onRemoteDied方法清理资源。该方法会在远端Stub对象所在进程退出或当前RPC通信依赖的软总线连接断开时被回调。需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied方法。\",\"4\":\"\",\"5\":\"## 使用场景\",\"6\":\"\",\"7\":\"这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地Proxy对象以及相关资源。此外，RPC不提供匿名Stub对象的死亡通知，即只有向SAMgr注册过的服务才能被订阅死亡通知，而IPC支持匿名对象的死亡通知。\",\"8\":\"\"}",
      "修改建议": "使用了'死亡通知'和'状态通知订阅'两种不同的词汇描述同一概念。",
      "更改后示例": "当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种死亡通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。",
      "触发条件": "同一概念在相邻或近距上下文(间隔≤2句)中出现术语不一致，且未存在语义差异说明时触发。典型表现为技术名词(如\"死亡通知\")与泛化表述(如\"状态通知订阅\")交替使用。\n\n识别模式：\n1. 核心术语重复出现场景：通过实体识别技术标记技术名词(如\"死亡通知\")，检测其后续指代是否保持词根一致性\n2. 上下文距离检测：当替代表述出现在原术语的2句范围内时激活校验\n3. 语义等价判断：使用词向量模型计算候选词相似度(如\"死亡通知\"与\"状态通知\"相似度＞0.7)，结合领域知识库验证是否为同义替换"
    },
    {
      "defect_id": 223278,
      "sentence": "SIGTRAP信号通常用于调试和跟踪程序的执行。下面是上面列出的四种SIGTRAP信号类别的问题场景介绍：",
      "reference_sentence": "SIGTRAP信号通常用于调试和跟踪程序的执行。下面是SIGTRAP信号类别的问题场景介绍：",
      "line_num": 420,
      "context": "{\"415\":\"| 5 | ILL_PRVOPC | 特权操作码异常。 | 这种异常通常发生在普通用户尝试执行特权指令时。|\",\"416\":\"| 6 | ILL_PRVREG | 特权寄存器异常。 | 这种异常通常发生在普通用户尝试访问特权寄存器时。|\",\"417\":\"| 7 | ILL_COPROC | 协处理器异常。 | 这种异常通常发生在程序尝试使用未定义的协处理器指令时。|\",\"418\":\"| 8 | ILL_BADSTK | 无效的堆栈异常。 | 这种异常通常发生在程序尝试在无效的堆栈地址上执行操作时，或者是在堆栈溢出时。|\",\"419\":\"\",\"420\":\"SIGTRAP信号通常用于调试和跟踪程序的执行。下面是上面列出的四种SIGTRAP信号类别的问题场景介绍：\",\"421\":\"\",\"422\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\",\"423\":\"| -------- | -------- | -------- | -------- |\",\"424\":\"| 1 | TRAP_BRKPT | 软件断点。 | 这个信号是由软件断点引起的，当程序执行到设置的断点时会触发该信号。软件断点通常用于调试程序，可以在程序的关键位置设置断点，以便在调试时暂停程序的执行并检查变量值等信息。|\",\"425\":\"| 2 | TRAP_TRACE | 单步调试。 | 这个信号是由单步执行引起的，当程序执行单个指令时会触发该信号。单步执行通常用于调试程序，可以逐步执行程序并检查每个指令的执行结果。|\"}",
      "修改建议": "原文中提到“下面列出的四种SIGTRAP信号类别”，但实际列出的类别不止四种。",
      "更改后示例": "SIGTRAP信号通常用于调试和跟踪程序的执行。下面是SIGTRAP信号类别的问题场景介绍：",
      "触发条件": "当文本中明确使用数量词（如\"四种\"）限定后续列表项，但实际列出的项目数量与所述数值不符时触发；或当上下文存在显式/隐式的数量承诺（如\"下面列出的X种...\"）时，需验证数值与实体元素严格对应。\n\n识别模式：通过正则匹配\"列出的[零一二三四五六七八九十]+种\"等数量描述结构，并检查后续列表项（表格行数/枚举条目）的实际计数是否匹配。若存在>1的数量级偏差（如案例中\"四种\"但实际仅两类），则判定为不一致。"
    },
    {
      "defect_id": 223279,
      "sentence": "这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。",
      "reference_sentence": "这个信号表示整数溢出错误。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。",
      "line_num": 444,
      "context": "{\"439\":\"SIGFPE是一个信号，它表示浮点异常或算术异常。下面是这些SIGFPE信号类别的问题场景：\",\"440\":\"\",\"441\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\",\"442\":\"| -------- | -------- | -------- | -------- |\",\"443\":\"| 1 | FPE_INTDIV | 整数除法错误。 | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。|\",\"444\":\"| 2 | FPE_INTOVF | 整数溢出错误。 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。|\",\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“整数除法中的除数为负数的情况”但实际上应该是“整数溢出错误”。",
      "更改后示例": "这个信号表示整数溢出错误。当一个程序尝试进行整数运算，结果超出整数范围时，会发出这个信号。",
      "触发条件": "当同一上下文中的\"解释\"字段与\"触发原因\"字段对信号类型的描述存在术语矛盾（如\"整数溢出错误\" vs \"除数为负数的情况\"），或错误类型与触发场景逻辑不一致时触发。"
    },
    {
      "defect_id": 214849,
      "sentence": "需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied回调方法。",
      "reference_sentence": "需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied方法。",
      "line_num": 3,
      "context": "{\"1\":\"# 远端状态订阅开发实例\",\"2\":\"\",\"3\":\"IPC/RPC提供对远端Stub对象状态的订阅机制。当远端Stub对象死亡时，可以触发死亡通知，告知本地Proxy对象。这种状态通知订阅需要调用指定接口完成。不再需要订阅时，也需要调用指定接口取消订阅。使用这种订阅机制的用户需要实现死亡通知接口DeathRecipient，并实现onRemoteDied方法清理资源。该方法会在远端Stub对象所在进程退出或当前RPC通信依赖的软总线连接断开时被回调。需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied回调方法。\",\"4\":\"\",\"5\":\"## 使用场景\",\"6\":\"\",\"7\":\"这种订阅机制适用于以下场景：本地Proxy对象需要感知远端Stub对象所在进程死亡，或当前RPC通信依赖的软总线连接断开。当Proxy感知到Stub端死亡后，应该清理本地proxy对象以及相关资源。此外，RPC不提供匿名Stub对象的死亡通知，即只有向SAMgr注册过的服务才能被订阅死亡通知，而IPC支持匿名对象的死亡通知。\",\"8\":\"\"}",
      "修改建议": "混用了'回调方法'和'方法'，建议统一使用'方法'。",
      "更改后示例": "需要注意的是，调用这些接口时需注意顺序：首先，Proxy订阅Stub死亡通知，若在订阅期间Stub状态正常，则在不再需要时取消订阅；若在订阅期间Stub所在进程退出或当前RPC通信依赖的软总线连接断开，则会自动触发执行Proxy自定义的onRemoteDied方法。",
      "触发条件": "同一技术术语在相邻上下文或同一功能描述中出现不一致表达（如\"方法\"与\"回调方法\"混用），且存在明确的参考基准（如文档前文已统一使用\"方法\"超过3次）。\n\n识别模式：\n1. 检测同一概念出现不同后缀修饰（如\"X方法\"与\"X回调方法\"）\n2. 验证相邻段落（前后3句内）是否存在已建立的术语基准\n3. 检查技术语境是否需要保持绝对一致性（如API名称、回调机制等关键概念）"
    },
    {
      "defect_id": 214473,
      "sentence": "其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。",
      "reference_sentence": "其次，创建变量connect，指定连接成功、连接失败、断开连接时的回调函数。",
      "line_num": 82,
      "context": "{\"77\":\"### 客户端连接服务，获取服务代理proxy\",\"78\":\"\",\"79\":\"**构造变量want和connect**\",\"80\":\"\",\"81\":\"  首先，构造变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。<br/>\",\"82\":\"  其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。<br/>\",\"83\":\"\",\"84\":\"  IPC 场景下，构造变量want和connect，连接服务。\",\"85\":\"  ```ts\",\"86\":\"    import { Want, common } from '@kit.AbilityKit';\",\"87\":\"    import { rpc } from '@kit.IPCKit';\"}",
      "修改建议": "混用了'构造'与'创建'，应保持一致。",
      "更改后示例": "其次，创建变量connect，指定连接成功、连接失败、断开连接时的回调函数。",
      "触发条件": "当同一上下文或相邻段落中，对同一操作（如变量初始化）出现多个不同动词（如\"构造\"与\"创建\"）且存在明确统一用法的参考基准时。"
    },
    {
      "defect_id": 214471,
      "sentence": "构造变量want和connect",
      "reference_sentence": "构造变量want和connect",
      "line_num": 79,
      "context": "{\"74\":\"    }\",\"75\":\"   ```\",\"76\":\"\",\"77\":\"### 客户端连接服务，获取服务代理proxy\",\"78\":\"\",\"79\":\"**构造变量want和connect**\",\"80\":\"\",\"81\":\"  首先，构造变量want，指定要连接的Ability所在应用的包名、组件名。如果是跨设备的场景，还需要连接目标设备的NetworkId（组网场景下对应设备的标识符，可以使用distributedDeviceManager获取目标设备的NetworkId）。<br/>\",\"82\":\"  其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。<br/>\",\"83\":\"\",\"84\":\"  IPC 场景下，构造变量want和connect，连接服务。\"}",
      "修改建议": "混用了'构造'与'创建'，应保持一致。",
      "更改后示例": "创建变量want和connect",
      "触发条件": "同一文档或上下文中，针对同一操作（如变量生成）使用了多个不同动词（如“构造”与“创建”），且未遵循统一术语规范时触发。"
    },
    {
      "defect_id": 215053,
      "sentence": "当前使用场景： 客户端是三方应用，服务端是系统应用。",
      "reference_sentence": "当前不支持三方应用实现ServiceExtensionAbility，三方应用的UIAbility组件可以通过[Context](../application-models/uiability-usage.md#获取uiability的上下文信息)连接系统提供的ServiceExtensionAbility实现。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> - 当前不支持三方应用实现ServiceExtensionAbility，三方应用的UIAbility组件可以通过[Context](../application-models/uiability-usage.md#获取uiability的上下文信息)连接系统提供的ServiceExtensionAbility实现。\",\"12\":\">\",\"13\":\"> - 当前使用场景： 客户端是三方应用，服务端是系统应用。\",\"14\":\"\",\"15\":\"### 创建ServiceExtensionAbility，实现服务端\",\"16\":\"\",\"17\":\"  定义一个继承自[rpc.RemoteObject](../reference/apis-ipc-kit/js-apis-rpc.md#remoteobject)的stub类，实现[onRemoteMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#onremotemessagerequest9)方法，用来处理客户端的请求。\",\"18\":\"\"}",
      "修改建议": "混用了'客户端'与'三方应用'，'服务端'与'系统应用'，导致表意不一致。",
      "更改后示例": "当前使用场景： 三方应用是客户端，系统应用是服务端。",
      "触发条件": "同一句子或相邻上下文中，同一实体被交替使用角色名称（如客户端/服务端）和应用类型（如三方应用/系统应用）两种不同维度的术语描述时触发。\n\n识别模式：\n1. 存在成对术语混用（如\"客户端\"对应\"三方应用\"，\"服务端\"对应\"系统应用\"）\n2. 同一实体在参考句段中已有明确术语规范（如参考句段始终使用\"三方应用\"指代客户端）\n3. 术语维度不统一（角色维度 vs 应用类型维度）造成理解歧义"
    },
    {
      "defect_id": 223234,
      "sentence": "使用内存时应考虑是否存在重复释放或者未释放的可能，另外定位内存访问类崩溃问题（一般是SIGSEGV类型问题）时，如果根据崩溃栈分析问题无头绪时，应优先考虑使能HWASan版本复现问题。",
      "reference_sentence": "根据堆栈继续分析，JsiWeak析构或重置的时候会触发其成员(类型为JsiObject/JsiValue/JsiFunction)父类JsiType中CopyableGlobal被释放，如下图：",
      "line_num": 332,
      "context": "{\"327\":\"\",\"328\":\"JsiWeak调用SetWeakCallback，传入callback，在GC过程中IterateWeakEcmaGlobalStorage释放WeakNode时，通知JsiWeak对其保存的CopyableGlobal进行重置，确保同一个地址不被double-free。\",\"329\":\"\",\"330\":\"**建议与总结**\",\"331\":\"\",\"332\":\"使用内存时应考虑是否存在重复释放或者未释放的可能，另外定位内存访问类崩溃问题（一般是SIGSEGV类型问题）时，如果根据崩溃栈分析问题无头绪时，应优先考虑使能HWASan版本复现问题。\",\"333\":\"\",\"334\":\"### 案例4：生命周期类问题\",\"335\":\"\",\"336\":\"不匹配的对象生命周期，比如使用裸指针（不含有封装、自动内存管理等特性的指针）保存sptr类型以及shared_ptr类型，会导致内存泄漏和悬空指针问题。裸指针是指不含有封装、自动内存管理等特性的指针。它只是一个指向内存地址的简单指针，没有对指针指向的内存进行保护或管理。裸指针可以直接访问指向的内存，但也容易出现内存泄漏、空指针引用等问题。因此，在使用裸指针时需要特别小心，避免出现潜在的安全问题；推荐使用智能指针来管理内存。\",\"337\":\"\"}",
      "修改建议": "用词不一致，应使用'根据堆栈继续分析'以保持一致",
      "更改后示例": "使用内存时应考虑是否存在重复释放或者未释放的可能，另外定位内存访问类崩溃问题（一般是SIGSEGV类型问题）时，如果根据堆栈继续分析问题无头绪时，应优先考虑使能HWASan版本复现问题。",
      "触发条件": "同一文档中针对同一技术概念（如\"崩溃栈\"与\"堆栈\"）存在术语混用，且上下文存在明确的标准表达范式（如参考句中的\"根据堆栈继续分析\"）时触发。\n\n识别模式：\n1. 术语冲突检测：通过对比相邻段落/参考句中的核心名词组合（如\"崩溃栈\" vs \"堆栈\"）\n2. 句式结构匹配：识别\"根据...分析\"等固定句式中的变量部分是否与既定表达范式一致\n3. 技术场景关联：当多个术语出现在相同技术上下文（内存问题定位）时进行交叉验证"
    },
    {
      "defect_id": 223281,
      "sentence": "这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。",
      "reference_sentence": "这个信号表示浮点下溢错误。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。",
      "line_num": 447,
      "context": "{\"442\":\"| -------- | -------- | -------- | -------- |\",\"443\":\"| 1 | FPE_INTDIV | 整数除法错误。 | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。|\",\"444\":\"| 2 | FPE_INTOVF | 整数溢出错误。 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。|\",\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"450\":\"| 8 | FPE_FLTSUB | 浮点陷阱错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"451\":\"\",\"452\":\"SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“浮点数除法中的除数为零的情况”但实际上应该是“浮点下溢错误”。",
      "更改后示例": "这个信号表示浮点下溢错误。当一个程序尝试进行浮点数运算，结果小于最小可表示值时，会发出这个信号。",
      "触发条件": "当文档中使用的关键术语（如错误类型名称）与后续解释中的触发原因或具体场景存在语义不一致时触发，特别是当错误类型定义与具体触发条件描述出现概念性矛盾时。\n\n识别模式：1) 检查核心术语（如\"FPE_FLTUND\"）是否与描述中的错误原因（如\"除数为零\"）保持逻辑对应 2) 验证错误类型定义（如\"浮点下溢错误\"）是否与触发场景（如\"结果小于最小可表示值\"）存在因果关系"
    },
    {
      "defect_id": 218800,
      "sentence": "enableArrow为true时，placement未设置或者值为非法值，默认在目标物上方显示，否则按照placement的位置优先显示。当前位置显示不下时，会自动调整位置，enableArrow为undefined时，不显示箭头。bindContextMenu从API version 10开始支持该属性；bindMenu从API version 12开始支持该属性。",
      "reference_sentence": "enableArrow为true时，placement未设置或者值为非法值，默认在目标物上方显示，否则按照placement的位置优先显示。当前位置显示不下时，会自动调整位置，enableArrow为undefined时，不显示箭头。bindContextMenu从API version 10开始支持该属性；bindMenu从API version 12开始支持该属性。",
      "line_num": 127,
      "context": "{\"122\":\"\",\"123\":\"| 名称                  | 类型                                                         | 必填 | 说明                                                         |\",\"124\":\"| --------------------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"125\":\"| offset                | [Position](ts-types.md#position)                            | 否   | 菜单弹出位置的偏移量，不会导致菜单显示超出屏幕范围。<br/>默认值：{ x: 0, y: 0 }，不支持设置百分比。<br/>**说明：** <br />菜单类型为相对⽗组件区域弹出时，⾃动根据菜单位置属性 (placement)将区域的宽或⾼计⼊偏移量中。<br/>当菜单相对父组件出现在上侧时（placement设置为Placement.TopLeft，Placement.Top，Placement.TopRight），x为正值，菜单相对组件向右进行偏移，y为正值，菜单相对组件向上进行偏移。<br/>当菜单相对父组件出现在下侧时（placement设置为Placement.BottomLeft，Placement.Bottom，Placement.BottomRight），x为正值，菜单相对组件向右进行偏移，y为正值，菜单相对组件向下进行偏移。<br/>当菜单相对父组件出现在左侧时（placement设置为Placement.LeftTop，Placement.Left，Placement.LeftBottom），x为正值，菜单相对组件向左进行偏移，y为正值，菜单相对组件向下进行偏移。<br/>当菜单相对父组件出现在右侧时（placement设置为Placement.RightTop，Placement.Right，Placement.RightBottom），x为正值，菜单相对组件向右进行偏移，y为正值，菜单相对组件向下进行偏移。<br/>如果菜单调整了显示位置（与placement初始值主方向不⼀致），则偏移值 (offset) 失效。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"126\":\"| placement             | [Placement](ts-appendix-enums.md#placement8)                 | 否   | 菜单组件优先显示的位置，当前位置显示不下时，会自动调整位置。<br/>**说明：**<br />placement值设置为undefined、null或没有设置此选项时，按未设置placement处理，当使用[bindMenu](#bindmenu11)，按默认值：Placement.BottomLeft设置，当使用[bindContextMenu<sup>8+</sup>](#bindcontextmenu8)，菜单跟随点击位置弹出；当使用[bindContextMenu<sup>12+</sup>](#bindcontextmenu12)，按默认值：Placement.BottomLeft设置。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"127\":\"| enableArrow           | boolean                                                      | 否   | 是否显示箭头。如果菜单的大小和位置不足以放置箭头时，不会显示箭头。 <br/>默认值：false，不显示箭头。<br/>**说明：**<br />enableArrow为true时，placement未设置或者值为非法值，默认在目标物上方显示，否则按照placement的位置优先显示。当前位置显示不下时，会自动调整位置，enableArrow为undefined时，不显示箭头。bindContextMenu从API version 10开始支持该属性；bindMenu从API version 12开始支持该属性。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"128\":\"| enableHoverMode<sup>18+</sup>      | boolean                                                      | 否   | 菜单组件是否响应悬停态变化。如果菜单的点击位置在悬停态折痕区域，菜单组件不会响应悬停态。 <br/>默认值：false，菜单组件不响应悬停态变化。<br/>**说明：**<br />enableHoverMode为false、未设置或者值为非法值时，菜单组件不会响应悬停态，enableHoverMode为true时，响应悬停态。<br />**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"129\":\"| arrowOffset           | [Length](ts-types.md#length)                                 | 否   | 箭头在菜单处的偏移。偏移量必须合法且转换为具体数值时大于0才会生效，另外该值生效时不会导致箭头超出菜单四周的安全距离。<br/>默认值：0<br />单位：vp<br />**说明：**<br />箭头距菜单四周的安全距离为菜单圆角大小与箭头宽度的一半之和。<br />根据配置的placement来计算是在水平还是垂直方向上偏移。<br />箭头在菜单水平方向时，偏移量为箭头至最左侧箭头安全距离处的距离。箭头在菜单垂直方向时，偏移量为箭头至最上侧箭头安全距离处的距离。<br />根据配置的placement的不同，箭头展示的默认位置不同：<br />在菜单不发生避让的情况下，placement设置为Placement.Top、Placement.Bottom时，箭头显示在水平方向且默认居中；<br />placement设置为Placement.Left、Placement.Right时，箭头显示在垂直方向且默认居中；<br />placement设置为Placement.TopLeft、Placement.BottomLeft时，箭头默认显示在水平方向，且距离菜单左侧边缘距离为箭头安全距离；<br />placement设置为Placement.TopRight、Placement.BottomRight时，箭头默认显示在水平方向，且距离菜单右侧距离为箭头安全距离；<br />placement设置为Placement.LeftTop、Placement.RightTop时，箭头默认显示在垂直方向，且距离菜单上侧距离为箭头安全距离；<br />placement设置为Placement.LeftBottom、Placement.RightBottom时，箭头默认显示在垂直方向，且距离菜单下侧距离为箭头安全距离；<br />  bindContextMenu从API version 10开始支持该属性；bindMenu从API version 12开始支持该属性。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"130\":\"| preview<sup>11+</sup> | [MenuPreviewMode](#menupreviewmode11)\\\\|&nbsp;[CustomBuilder](ts-types.md#custombuilder8) | 否   | 长按悬浮菜单或使用[bindContextMenu<sup>12+</sup>](#bindcontextmenu12)显示菜单的预览内容样式，可以为目标组件的截图，也可以为用户自定义的内容。<br/>默认值：MenuPreviewMode.NONE，无预览内容。<br/>**说明：**<br />- 不支持responseType为ResponseType.RightClick时触发，如果responseType为ResponseType.RightClick，则不会显示预览内容。<br />- 当未设置preview参数或preview参数设置为MenuPreviewMode.NONE时，enableArrow参数生效。<br />- 当preview参数设置为MenuPreviewMode.IMAGE或CustomBuilder时，enableArrow为true时也不显示箭头。<br />**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"131\":\"| previewAnimationOptions<sup>11+</sup> | [ContextMenuAnimationOptions](#contextmenuanimationoptions11) | 否    | 控制长按预览显示动画开始倍率和结束倍率（相对预览原图比例）。<br/>默认值：{ scale: [0.95, 1.1], transition: undefined, hoverScale: undefined }。<br/>**说明：**<br />倍率设置参数小于等于0时，不生效。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"132\":\"| onAppear              | ()&nbsp;=&gt;&nbsp;void                                      | 否   | 菜单弹出时的事件回调。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。                                       |\"}",
      "修改建议": "重复描述，建议合并",
      "更改后示例": "enableArrow为true时，placement未设置或者值为非法值，默认在目标物上方显示，否则按照placement的位置优先显示。当前位置显示不下时，会自动调整位置。enableArrow为undefined时，不显示箭头。bindContextMenu从API version 10开始支持该属性；bindMenu从API version 12开始支持该属性。",
      "触发条件": "当同一属性或条件在相邻句子中被重复描述（如enableArrow为true/undefined的两种状态分句说明），且句式结构高度相似时触发该规则。通过识别相邻分句中重复出现的属性名、值判断逻辑（如\"为...时\"）及结论描述（如\"不显示箭头\"）的冗余模式判定需合并。"
    },
    {
      "defect_id": 223283,
      "sentence": "这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。",
      "reference_sentence": "这个信号表示无效浮点操作错误。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。",
      "line_num": 449,
      "context": "{\"444\":\"| 2 | FPE_INTOVF | 整数溢出错误。 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。|\",\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"450\":\"| 8 | FPE_FLTSUB | 浮点陷阱错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"451\":\"\",\"452\":\"SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：\",\"453\":\"\",\"454\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“浮点数除法中的除数为负数的情况”但实际上应该是“无效浮点操作错误”。",
      "更改后示例": "这个信号表示无效浮点操作错误。当一个程序尝试进行无效的浮点数运算时，会发出这个信号。",
      "触发条件": "当文档中使用的错误名称/术语（如\"无效浮点操作错误\"）与后续具体触发原因描述（如\"除数为负数\"）存在逻辑不匹配，或与上下文同类条目呈现的\"错误类型-触发条件\"对应模式不一致时触发。\n\n识别模式：1) 检查错误名称是否准确涵盖具体触发条件（如\"除数为负数\"属于\"无效操作\"的子集）；2) 对比相邻条目是否保持\"错误类型→具体场景\"的递进结构（如其他条目均为\"信号表示X错误，当发生Y情况时触发\"的平行结构）。"
    },
    {
      "defect_id": 252339,
      "sentence": "该示例通过设置不同的HitTestMode值演示了Block和Transparent的触摸类型效果。",
      "reference_sentence": "该示例通过设置不同的HitTestMode值演示了Block和Transparent的触摸测试效果。",
      "line_num": 37,
      "context": "{\"32\":\"| None        | 3 |自身不响应触摸测试，不会阻塞子节点和兄弟节点的触摸测试。不会影响祖先节点的触摸测试。 |\",\"33\":\"\",\"34\":\"\",\"35\":\"## 示例\",\"36\":\"\",\"37\":\"该示例通过设置不同的HitTestMode值演示了Block和Transparent的触摸类型效果。\",\"38\":\"\",\"39\":\"```ts\",\"40\":\"// xxx.ets\",\"41\":\"@Entry\",\"42\":\"@Component\"}",
      "修改建议": "描述中混用了'触摸类型'和'触摸测试'，应使用一致的术语。",
      "更改后示例": "该示例通过设置不同的HitTestMode值演示了Block和Transparent的触摸测试效果。",
      "触发条件": "当同一技术概念在文档中存在多个不同术语表述（如\"触摸类型\"和\"触摸测试\"），且上下文已建立标准术语（如\"触摸测试\"在参数说明中重复出现）时触发。\n\n识别模式：\n1. 通过相邻段落/参数表的术语定义建立基准词汇（如上下文表格中3次重复\"触摸测试\"）\n2. 检测同一语义场景下出现的同义异形词（如\"类型\"与\"测试\"的修饰冲突）\n3. 验证术语是否与API命名保持映射（HitTestMode中的\"Test\"对应\"测试\"而非\"类型\"）"
    },
    {
      "defect_id": 243778,
      "sentence": "气泡大小有内部的builder大小或者message的长度决定的。",
      "reference_sentence": "气泡大小由内部的builder大小或者message的长度决定。",
      "line_num": 228,
      "context": "{\"223\":\"\",\"224\":\"气泡除了可以通过builder实现自定义气泡，还可以通过接口设置气泡的样式和显示效果。\",\"225\":\"\",\"226\":\"背景颜色：气泡的背景色默认为透明，但是会有一个默认的模糊效果，手机上为COMPONENT\\\\_ULTRA\\\\_THICK。\",\"227\":\"蒙层样式：气泡默认有蒙层，且蒙层的颜色为透明。\",\"228\":\"显示大小：气泡大小有内部的builder大小或者message的长度决定的。\",\"229\":\"显示位置：气泡默认显示在宿主组件的下方，可以通过Placement接口来配置其显示位置以及对齐方向。\",\"230\":\"以下示例通过设置popupColor（背景颜色）、mask（蒙层样式）、width（气泡宽度）、placement（显示位置）实现气泡的样式。\",\"231\":\"\",\"232\":\"```ts\",\"233\":\"// xxx.ets\"}",
      "修改建议": "混用了'有...决定'与'由...决定'。",
      "更改后示例": "气泡大小由内部的builder大小或者message的长度决定。",
      "触发条件": "当句子中同时出现“有...决定”的错误搭配结构，且存在正确表达“由...决定”的上下文对照时触发。\n\n识别模式：检测介词与动词“决定”的异常组合（如“有”+“决定”），并对比相邻句子或技术文档中同类表达（如“由...配置”“由...设置”），确认是否存在句式不统一问题。"
    },
    {
      "defect_id": 244007,
      "sentence": "设置下拉菜单初始选项的索引，第一项的索引为0。当不设置selected属性或设置异常值时，默认选择值为-1，菜单项不选中；当设置为undefined、null时，选中第一项。",
      "reference_sentence": "无",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"### selected\",\"42\":\"\",\"43\":\"selected(value: number | Resource)\",\"44\":\"\",\"45\":\"设置下拉菜单初始选项的索引，第一项的索引为0。当不设置selected属性或设置异常值时，默认选择值为-1，菜单项不选中；当设置为undefined、null时，选中第一项。\",\"46\":\"\",\"47\":\"从API version 10开始，该属性支持[$$](../../../ui/state-management/arkts-two-way-sync.md)双向绑定变量。\",\"48\":\"从API version 18开始，该参数支持[!!](../../../ui/state-management/arkts-new-binding.md#系统组件参数双向绑定)双向绑定变量。\",\"49\":\"\",\"50\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\"}",
      "修改建议": "使用了“设置异常值”和“默认选择值为-1”等表述，建议统一使用“设置为异常值时，默认选中值为-1”",
      "更改后示例": "设置下拉菜单初始选项的索引，第一项的索引为0。当不设置selected属性或设置为异常值时，默认选中值为-1，菜单项不选中；当设置为undefined、null时，选中第一项。",
      "触发条件": "同一句子中动词短语结构不一致（如\"设置异常值\"与\"设置为异常值\"）或关键参数描述存在术语混用（如\"选择值\"与\"选中值\"）时触发该规则，需统一动词介词搭配和核心参数命名。"
    },
    {
      "defect_id": 223284,
      "sentence": "这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。",
      "reference_sentence": "这个信号表示浮点陷阱错误。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。",
      "line_num": 450,
      "context": "{\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"450\":\"| 8 | FPE_FLTSUB | 浮点陷阱错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"451\":\"\",\"452\":\"SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：\",\"453\":\"\",\"454\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\",\"455\":\"| -------- | -------- | -------- | -------- |\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“浮点数除法中的除数为零的情况”但实际上应该是“浮点陷阱错误”。",
      "更改后示例": "这个信号表示浮点陷阱错误。当一个程序尝试进行浮点数运算，触发浮点陷阱时，会发出这个信号。",
      "触发条件": "当文档中具体触发原因的描述与上级分类/定义的错误类型存在术语不一致（如将\"浮点陷阱错误\"具体描述为\"浮点数除法错误\"），或错误复用了其他同类条目的触发条件模板时。"
    },
    {
      "defect_id": 238279,
      "sentence": "true表示该区域语言从右至左显示，false表示该区域语言从左至右显示。",
      "reference_sentence": "true表示该区域语言从右到左显示，false表示该区域语言从左到右显示。",
      "line_num": 638,
      "context": "{\"633\":\"\",\"634\":\"**返回值：**\",\"635\":\"\",\"636\":\"| 类型      | 说明                                       |\",\"637\":\"| ------- | ---------------------------------------- |\",\"638\":\"| boolean | true表示该区域语言从右至左显示，false表示该区域语言从左至右显示。 |\",\"639\":\"\",\"640\":\"**示例：**\",\"641\":\"  ```ts\",\"642\":\"  let isZhRTL: boolean = i18n.isRTL('zh-CN'); // 中文不是RTL语言，返回false\",\"643\":\"  let isArRTL: boolean = i18n.isRTL('ar-EG'); // 阿语是RTL语言，返回true\"}",
      "修改建议": "使用了不同的词汇描述同一方向，'至'与'到'混用。",
      "更改后示例": "true表示该区域语言从右到左显示，false表示该区域语言从左到右显示。",
      "触发条件": "同一上下文或相邻描述中，针对同一方向性描述出现介词混用（如\"至\"与\"到\"）或同义词交替使用的情况，且未保持全篇统一表达时触发。\n\n识别模式：\n1. 检测相邻/对称句式中的方向描述短语（如\"从X至Y\"与\"从X到Y\"）\n2. 比对同一参数的正反说明（如true/false对应的方向描述）\n3. 验证方向性介词在参考句例中的标准化表达（如规范采用\"到\"而非\"至\"）"
    },
    {
      "defect_id": 218791,
      "sentence": "给组件绑定菜单，触发方式为控制绑定的isShown。",
      "reference_sentence": "给组件绑定菜单，点击后弹出菜单。弹出菜单项支持图标+文本排列和自定义两种功能。",
      "line_num": 81,
      "context": "{\"76\":\"\",\"77\":\"## bindContextMenu<sup>12+</sup>\",\"78\":\"\",\"79\":\"bindContextMenu(isShown: boolean, content: CustomBuilder, options?: ContextMenuOptions)\",\"80\":\"\",\"81\":\"给组件绑定菜单，触发方式为控制绑定的isShown。\",\"82\":\"\",\"83\":\"isShown为true，弹出菜单。isShown为false，隐藏菜单。弹出菜单项需要自定义。\",\"84\":\"\",\"85\":\"菜单弹出不跟随点击位置，只与placement设置有关。\",\"86\":\"\"}",
      "修改建议": "描述菜单项的功能时，使用了不同的词汇（'控制绑定的isShown'与'点击'）。",
      "更改后示例": "给组件绑定菜单，通过控制绑定的isShown触发。",
      "触发条件": "同一功能描述中存在多个不一致的动作术语（如\"控制\"与\"点击\"），或操作方式描述与上下文API参数（如isShown）存在逻辑断裂时触发。\n\n识别模式：\n1. 动词冲突检测：对比功能描述中的动作词（触发方式为\"控制\"）与上下文参考句的动作词（\"点击\"）是否矛盾\n2. 参数关联验证：检查操作方式是否与API参数特性匹配（isShown是布尔状态量，应使用\"控制\"而非瞬时动作\"点击\"）"
    },
    {
      "defect_id": 243893,
      "sentence": "由于[CustomDialogController](../reference/apis-arkui/arkui-ts/ts-methods-custom-dialog-box.md#customdialogcontroller)在使用上存在诸多限制，不支持动态创建也不支持动态刷新，在相对较复杂的应用场景中推荐使用UIContext中获取到的PromptAction对象提供的[openCustomDialog](../reference/apis-arkui/js-apis-arkui-UIContext.md#opencustomdialog12)接口来实现自定义弹出框。",
      "reference_sentence": "由于[CustomDialogController](../reference/apis-arkui/arkui-ts/ts-methods-custom-dialog-box.md#customdialogcontroller)在使用上存在诸多限制，不支持动态创建也不支持动态刷新，在相对较复杂的应用场景中推荐使用UIContext中获取到的PromptAction对象提供的[openCustomDialog](../reference/apis-arkui/js-apis-arkui-UIContext.md#opencustomdialog12)接口来实现自定义弹出框。",
      "line_num": 3,
      "context": "{\"1\":\"# 不依赖UI组件的全局自定义弹出框 (openCustomDialog)（推荐）\",\"2\":\"\",\"3\":\"由于[CustomDialogController](../reference/apis-arkui/arkui-ts/ts-methods-custom-dialog-box.md#customdialogcontroller)在使用上存在诸多限制，不支持动态创建也不支持动态刷新，在相对较复杂的应用场景中推荐使用UIContext中获取到的PromptAction对象提供的[openCustomDialog](../reference/apis-arkui/js-apis-arkui-UIContext.md#opencustomdialog12)接口来实现自定义弹出框。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\"> \",\"7\":\"> 弹出框（openCustomDialog）存在两种入参方式创建自定义弹出框：\",\"8\":\"> - openCustomDialog（传参为ComponentContent形式）：通过ComponentContent封装内容可以与UI界面解耦，调用更加灵活，可以满足开发者的封装诉求。拥有更强的灵活性，弹出框样式是完全自定义的，且在弹出框打开之后可以使用updateCustomDialog方法动态更新弹出框的一些参数。\"}",
      "修改建议": "句子中的'使用'和'应用场景'表述不一致，建议统一使用'应用场景'。",
      "更改后示例": "由于[CustomDialogController](../reference/apis-arkui/arkui-ts/ts-methods-custom-dialog-box.md#customdialogcontroller)在应用场景上存在诸多限制，不支持动态创建也不支持动态刷新，在相对较复杂的应用场景中推荐使用UIContext中获取到的PromptAction对象提供的[openCustomDialog](../reference/apis-arkui/js-apis-arkui-UIContext.md#opencustomdialog12)接口来实现自定义弹出框。",
      "触发条件": "同一句子或邻近上下文中存在多个相似语义的术语混用（如\"使用\"与\"应用场景\"），且这些术语在表达同一技术概念时未保持统一。识别模式需检测技术文档中描述限制条件、应用场景等关键位置是否存在同义但不同形的专业术语交替使用。"
    },
    {
      "defect_id": 223282,
      "sentence": "这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。",
      "reference_sentence": "这个信号表示浮点结果未定义错误。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。",
      "line_num": 448,
      "context": "{\"443\":\"| 1 | FPE_INTDIV | 整数除法错误。 | 这个信号表示整数除法中的除数为零的情况。当一个程序尝试进行整数除法，但除数为零时，会发出这个信号。|\",\"444\":\"| 2 | FPE_INTOVF | 整数溢出错误。 | 这个信号表示整数除法中的除数为负数的情况。当一个程序尝试进行整数除法，但除数为负数时，会发出这个信号。|\",\"445\":\"| 3 | FPE_FLTDIV | 浮点除法错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"446\":\"| 4 | FPE_FLTOVF | 浮点溢出错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"447\":\"| 5 | FPE_FLTUND | 浮点下溢错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"448\":\"| 6 | FPE_FLTRES | 浮点结果未定义错误。 | 这个信号表示浮点数除法中的除数为正数的情况。当一个程序尝试进行浮点数除法，但除数为正数时，会发出这个信号。|\",\"449\":\"| 7 | FPE_FLTINV | 无效浮点操作错误。 | 这个信号表示浮点数除法中的除数为负数的情况。当一个程序尝试进行浮点数除法，但除数为负数时，会发出这个信号。|\",\"450\":\"| 8 | FPE_FLTSUB | 浮点陷阱错误。 | 这个信号表示浮点数除法中的除数为零的情况。当一个程序尝试进行浮点数除法，但除数为零时，会发出这个信号。|\",\"451\":\"\",\"452\":\"SIGSEGV是一种信号，它表示进程试图访问一个不属于它的内存地址，或者试图访问一个已被操作系统标记为不可访问的内存地址。SIGSEGV信号通常是由以下两种情况引起的：\",\"453\":\"\"}",
      "修改建议": "这里描述的触发原因与解释不一致，描述为“浮点数除法中的除数为正数的情况”但实际上应该是“浮点结果未定义错误”。",
      "更改后示例": "这个信号表示浮点结果未定义错误。当一个程序尝试进行浮点数运算，结果未定义时，会发出这个信号。",
      "触发条件": "当文档中相邻条目使用相同的句式结构描述不同错误类型，但某条目的错误原因描述与官方定义或上下文术语体系不一致时触发。\n\n识别模式：\n1. 结构对比：检查相邻条目是否采用统一模板（如\"这个信号表示...情况。当...时\"句式）\n2.术语验证：核对错误名称（如FPE_FLTRES）与标准定义是否匹配，发现\"结果未定义错误\"被错误描述为\"除数为正数\"的语义偏差\n3. 逻辑矛盾：识别描述中存在的自相矛盾（如将结果未定义错误归因于特定除数状态）\n4. 上下文一致性：检测当前条目与相邻条目（如FPE_FLTDIV描述除数为零）是否保持平行结构但正确区分不同错误类型"
    },
    {
      "defect_id": 253523,
      "sentence": "设置组件是否独占事件。事件范围包括组件自带的事件和开发者自定义的点击、触摸、手势事件。<br />",
      "reference_sentence": "设置组件是否独占事件。",
      "line_num": 3,
      "context": "{\"1\":\"# 事件独占控制\",\"2\":\"\",\"3\":\"设置组件是否独占事件，事件范围包括组件自带的事件和开发者自定义的点击、触摸、手势事件。<br />\",\"4\":\"在一个窗口内，设置了独占控制的组件上的事件如果首先响应，则本次交互只允许此组件上设置的事件响应，窗口内其他组件上的事件不会响应。\",\"5\":\"\",\"6\":\">  **说明：**\",\"7\":\">\",\"8\":\">  从API Version 11开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\"}",
      "修改建议": "用词不一致，'点击'应与'单击'保持一致",
      "更改后示例": "设置组件是否独占事件。事件范围包括组件自带的事件和开发者自定义的单击、触摸、手势事件。<br />",
      "触发条件": "同一文档中出现相同概念使用不同术语（如\"点击\"与\"单击\"混用），且存在参考基准（如标题/核心语句已确立标准用词）时触发。\n\n识别模式：\n1. 语义等价词检测：识别描述相同交互行为但使用不同动作动词（点击/单击/按压/触摸）\n2. 上下文锚定匹配：当段落内已存在标准术语（如参考句中的\"单击\"），后续出现同义异形词时自动标记\n3. 技术文档特征识别：针对事件响应、交互控制等特定技术场景建立术语白名单"
    },
    {
      "defect_id": 243820,
      "sentence": "通过调用openPopup接口弹出气泡，需要提供绑定组件的信息[TargetInfo](../reference/apis-arkui/js-apis-arkui-UIContext.md#targetinfo18)。若未传入有效的target，则无法弹出气泡。",
      "reference_sentence": "通过[openMenu](../reference/apis-arkui/js-apis-arkui-UIContext.md#openmenu18)可以弹出菜单。",
      "line_num": 82,
      "context": "{\"77\":\"   ```\",\"78\":\"\",\"79\":\"\",\"80\":\"### 绑定组件信息\",\"81\":\"   \",\"82\":\"   通过调用openPopup接口弹出气泡，需要提供绑定组件的信息[TargetInfo](../reference/apis-arkui/js-apis-arkui-UIContext.md#targetinfo18)。若未传入有效的target，则无法弹出气泡。\",\"83\":\"   \",\"84\":\"   ```ts\",\"85\":\"   let frameNode: FrameNode | null = this.ctx.getFrameNodeByUniqueId(this.getUniqueId());\",\"86\":\"   let targetId = frameNode?.getChild(0)?.getUniqueId();\",\"87\":\"   ```\"}",
      "修改建议": "混用了`openPopup`和`openMenu`概念，且描述了不同的操作。",
      "更改后示例": "通过调用openMenu接口弹出菜单，需要提供绑定组件的信息[TargetInfo](../reference/apis-arkui/js-apis-arkui-UIContext.md#targetinfo18)。若未传入有效的target，则无法弹出菜单。",
      "触发条件": "同一功能描述中接口名称与操作结果术语不匹配（如openPopup对应\"气泡\"与openMenu对应\"菜单\"），或同一上下文出现多个描述同一功能的不同术语（如混用\"弹出气泡\"和\"弹出菜单\"）。"
    },
    {
      "defect_id": 252399,
      "sentence": "设置组件点击时回弹效果。",
      "reference_sentence": "设置当前组件点击回弹效果。",
      "line_num": 3,
      "context": "{\"1\":\"# 点击回弹效果\",\"2\":\"\",\"3\":\"设置组件点击时回弹效果。\",\"4\":\"\",\"5\":\">  **说明：**\",\"6\":\">\",\"7\":\"> 从API Version 10开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\",\"8\":\"\"}",
      "修改建议": "混用了“点击时”和“点击”两种表达方式，导致用词不一致。",
      "更改后示例": "设置组件点击回弹效果。",
      "触发条件": "同一上下文中的同一动作或概念存在两种及以上冗余表达（如“点击时”与“点击”混用），或存在冗余时间状语（如“时”）导致用词不一致。  \n识别模式：检测相邻句子或段落中描述相同动作的短语是否包含非必要时间修饰词（如“时”），并与上下文高频术语（如“点击”）形成冗余冲突。"
    },
    {
      "defect_id": 239123,
      "sentence": "其他公开接口参见[@ohos.i18n (国际化-I18n)](js-apis-intl.md)。",
      "reference_sentence": "本模块提供系统相关的或者增强的国际化能力，包括区域管理、电话号码处理、日历等，相关接口为ECMA 402标准中未定义的补充接口。[Intl模块](js-apis-intl.md)提供了ECMA 402标准定义的基础国际化接口，与本模块共同使用可提供完整地国际化支持能力。",
      "line_num": 10,
      "context": "{\"5\":\">  **说明：**\",\"6\":\">  - 本模块首批接口从API version 7开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"7\":\">\",\"8\":\">  - 从API version 11开始，本模块部分接口支持在ArkTS卡片中使用。\",\"9\":\">\",\"10\":\">  - 当前页面仅包含本模块的系统接口，其他公开接口参见[@ohos.i18n (国际化-I18n)](js-apis-intl.md)。\",\"11\":\"\",\"12\":\"\",\"13\":\"## 导入模块\",\"14\":\"\",\"15\":\"```ts\"}",
      "修改建议": "混用了“国际化-I18n”和“国际化”概念",
      "更改后示例": "其他公开接口参见[@ohos.i18n (国际化)](js-apis-intl.md)。",
      "触发条件": "当同一模块或术语在文档中存在全称与缩写混用（如\"国际化\"与\"国际化-I18n\"）时，或链接文本与上下文命名规范不一致时触发。识别模式为检测方括号链接[@module]中的冗余后缀或括号补充说明是否破坏命名统一性。"
    },
    {
      "defect_id": 238293,
      "sentence": "设置日历对象内部的时间、日期。",
      "reference_sentence": "设置日历对象内部的时间、日期。",
      "line_num": 805,
      "context": "{\"800\":\"\",\"801\":\"### setTime<sup>8+</sup>\",\"802\":\"\",\"803\":\"setTime(time: number): void\",\"804\":\"\",\"805\":\"设置日历对象内部的时间、日期。\",\"806\":\"\",\"807\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"808\":\"\",\"809\":\"**系统能力**：SystemCapability.Global.I18n\",\"810\":\"\"}",
      "修改建议": "重复句子，导致冗余。",
      "更改后示例": "设置日历对象内部的时间。",
      "触发条件": "当同一文档上下文中存在两个完全相同的功能描述句子，且重复内容出现在相邻或相关API接口说明时触发。识别模式需检测重复字符串在邻近行号或相同功能模块中的重复出现。"
    },
    {
      "defect_id": 238283,
      "sentence": "识别文本中的实体信息。",
      "reference_sentence": "获取日历对象。",
      "line_num": 717,
      "context": "{\"712\":\"\",\"713\":\"### findEntityInfo<sup>11+</sup>\",\"714\":\"\",\"715\":\"findEntityInfo(text: string): Array&lt;EntityInfoItem&gt;\",\"716\":\"\",\"717\":\"识别文本中的实体信息。\",\"718\":\"\",\"719\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"720\":\"\",\"721\":\"**系统能力**：SystemCapability.Global.I18n\",\"722\":\"\"}",
      "修改建议": "描述对象操作时使用了不同的动词，应保持一致。",
      "更改后示例": "获取文本中的实体信息。",
      "触发条件": "当同一功能或操作在相邻/关联描述中使用不同动词，且存在已确立的参考动词模式时触发（如API方法名含\"find\"但描述使用\"识别\"，而上下文存在\"获取\"的规范表达）。"
    },
    {
      "defect_id": 257605,
      "sentence": "继承于[BaseGestureEvent](#basegestureevent对象说明)。可将该对象作为[onGestureJudgeBegin](#ongesturejudgebegin)的event参数来传递。",
      "reference_sentence": "## TapGestureEvent对象说明继承于[BaseGestureEvent](#basegestureevent对象说明)。可将该对象作为[onGestureJudgeBegin](#ongesturejudgebegin)的event参数来传递。",
      "line_num": 143,
      "context": "{\"138\":\"\",\"139\":\"## RotationGestureEvent对象说明\",\"140\":\"\",\"141\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"142\":\"\",\"143\":\"继承于[BaseGestureEvent](#basegestureevent对象说明)。可将该对象作为[onGestureJudgeBegin](#ongesturejudgebegin)的event参数来传递。\",\"144\":\"| 名称         | 类型                                      | 描述         |\",\"145\":\"| ------------  | ----------------------------------------  | -----------|\",\"146\":\"| angle         | number | 表示旋转角度，单位为deg。<br/>**说明：**<br/>角度计算方式：当滑动手势被识别后，连接两根手指之间的线被识别为起始线条。随着手指的滑动，手指之间的线条会发生旋转。根据起始线条和当前线条两端点的坐标，使用反正切函数分别计算其相对于水平方向的夹角。最终的旋转角度为 arctan2(cy2-cy1, cx2-cx1) - arctan2(y2-y1, x2-x1)。在起始线条为坐标系的情况下，顺时针旋转为0到180度，逆时针旋转为-180到0度。  |\",\"147\":\"\",\"148\":\"## SwipeGestureEvent对象说明\"}",
      "修改建议": "句式不一致，建议统一使用祈使句描述动作。",
      "更改后示例": "继承于[BaseGestureEvent](#basegestureevent对象说明)。将该对象作为[onGestureJudgeBegin](#ongesturejudgebegin)的event参数来传递。",
      "触发条件": "同一段落或相邻上下文中存在混合使用陈述句（含\"可\"等助动词）与祈使句描述操作步骤的情况，且句式结构呈现\"可+动词\"模式时触发。\n\n识别模式：\n1. 检测技术文档中操作说明性语句是否包含\"可+动词\"结构（如\"可将...\"）\n2. 对比上下文句式结构，当相邻语句采用无主祈使句（如\"将该对象...\"）时判定为不一致\n3. 特别关注参数传递、方法调用等操作步骤描述场景，此类场景通常要求统一使用祈使句"
    },
    {
      "defect_id": 264832,
      "sentence": "设置分割线样式，不设置该属性则按“默认值”展示分割线。",
      "reference_sentence": "设置选中项的文本颜色、字号、字体粗细。默认值：{<br/>color: '#ff007dff',<br/>font: {<br/>size: '20vp', <br/>weight: FontWeight.Medium<br/>}<br/>}",
      "line_num": 181,
      "context": "{\"176\":\"\",\"177\":\"### divider<sup>12+</sup>\",\"178\":\"\",\"179\":\"divider(value: DividerOptions | null)\",\"180\":\"\",\"181\":\"设置分割线样式，不设置该属性则按“默认值”展示分割线。\",\"182\":\"\",\"183\":\"startMargin + endMargin 超过组件宽度后startMargin和endMargin会被置0。\",\"184\":\"\",\"185\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"186\":\"\"}",
      "修改建议": "句式不一致，应当使用祈使句",
      "更改后示例": "设置分割线样式，不设置该属性则按默认值展示分割线。",
      "触发条件": "当文档中存在混合使用祈使句与陈述句的说明性语句，或术语引用方式（如引号标注）与上下文规范不一致时触发。  \n识别模式：检测句子是否以动词开头的祈使句为主干，但后半部分转为被动/陈述句式（如\"按...展示\"）；或特定术语（如\"默认值\"）出现非常规符号包裹（如中文引号），与同文档其他术语标注模式冲突。"
    },
    {
      "defect_id": 238478,
      "sentence": "与 U_UNASSIGNED 相同。",
      "reference_sentence": "与 U_UNASSIGNED 相同。",
      "line_num": 2389,
      "context": "{\"2384\":\"一般类别值如下，更详细的介绍可以参考Unicode标准。\",\"2385\":\"\",\"2386\":\"| 名称 | 值 | 说明 |\",\"2387\":\"| ---- | -------- | ---------- |\",\"2388\":\"| U_UNASSIGNED | U_UNASSIGNED | 表示未分配和非字符代码点对应类别。 |\",\"2389\":\"| U_GENERAL_OTHER_TYPES | U_GENERAL_OTHER_TYPES | 与 U_UNASSIGNED 相同。 |\",\"2390\":\"| U_UPPERCASE_LETTER | U_UPPERCASE_LETTER | 表示大写字母。 |\",\"2391\":\"| U_LOWERCASE_LETTER | U_LOWERCASE_LETTER | 表示小写字母。  |\",\"2392\":\"| U_TITLECASE_LETTER | U_TITLECASE_LETTER | 表示首字母大写。 |\",\"2393\":\"| U_MODIFIER_LETTER | U_MODIFIER_LETTER | 表示字母修饰符。 |\",\"2394\":\"| U_OTHER_LETTER | U_OTHER_LETTER | 表示其它字母，不属于大写字母、小写字母、首字母大写或修饰符字母的字母。 |\"}",
      "修改建议": "使用了“相同”这个词，建议使用更明确的词汇描述。",
      "更改后示例": "与 U_UNASSIGNED 一致。",
      "触发条件": "当技术文档中出现\"相同\"等模糊表述描述技术属性对应关系，且存在推荐术语(如\"一致\")时触发；当同一文档中存在术语混用且需要统一表达规范时触发。"
    },
    {
      "defect_id": 265492,
      "sentence": "ProgressMask设置遮罩的进度、最大值和遮罩颜色。",
      "reference_sentence": "在当前组件上加上指定形状的遮罩。",
      "line_num": 121,
      "context": "{\"116\":\"| ------ | ------------------------------------------------------------ | ---- | -------------------------------- |\",\"117\":\"| value  | [CircleShape](../js-apis-arkui-shape.md#circleshape)&nbsp;\\\\|&nbsp;[EllipseShape](../js-apis-arkui-shape.md#ellipseshape)&nbsp;\\\\|&nbsp;[PathShape](../js-apis-arkui-shape.md#pathshape)&nbsp;\\\\|&nbsp;[RectShape](../js-apis-arkui-shape.md#rectshape) | 是   | 在当前组件上加上指定形状的遮罩。 |\",\"118\":\"\",\"119\":\"## ProgressMask<sup>10+</sup>\",\"120\":\"\",\"121\":\"ProgressMask设置遮罩的进度、最大值和遮罩颜色。\",\"122\":\"\",\"123\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"124\":\"\",\"125\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"126\":\"\"}",
      "修改建议": "描述遮罩功能时用词不一致，应统一为'设置遮罩的进度、最大值和颜色'。",
      "更改后示例": "ProgressMask设置遮罩的进度、最大值和颜色。",
      "触发条件": "同一功能描述中出现重复修饰词（如\"遮罩颜色\"与前文\"遮罩的\"形成冗余），或并列成分存在修饰语不统一现象（如\"遮罩的进度、最大值和遮罩颜色\"结构失衡）。通过检测名词短语中重复出现的限定词与并列结构的修饰一致性进行识别。"
    },
    {
      "defect_id": 253525,
      "sentence": "如果开发者通过[parallelGesture](ts-gesture-settings.md)绑定了与子组件同时触发的手势，如[PanGesture](ts-basic-gestures-pangesture.md)，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。",
      "reference_sentence": "如果开发者通过[parallelGesture](ts-gesture-settings.md)绑定了与子组件同时触发的手势，如[PanGesture](ts-basic-gestures-pangesture.md)，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。",
      "line_num": 25,
      "context": "{\"20\":\"**参数：** \",\"21\":\"\",\"22\":\"\",\"23\":\"| 参数名   | 类型 | 必填 | 说明                  |\",\"24\":\"| ----------- | -------- | ------------------------ | ------------------------ |\",\"25\":\"| monopolize | boolean  | 是 | 设置组件是否独占事件。true表示组件独占事件，false表示组件不独占事件。<br />默认值：false <br />**说明：**<br />1、如果第一根手指触发了组件事件独占，在抬起前又按下了一根手指，则第二根手指的交互继续处于组件独占状态，依次类推。<br />2、如果开发者通过[parallelGesture](ts-gesture-settings.md)绑定了与子组件同时触发的手势，如[PanGesture](ts-basic-gestures-pangesture.md)，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。|\",\"26\":\"\",\"27\":\"## 示例\",\"28\":\"\",\"29\":\"该示例通过配置monopolizeEvents实现组件是否独占事件。\",\"30\":\"\"}",
      "修改建议": "用词不一致，'触发'应与'响应'保持一致",
      "更改后示例": "如果开发者通过[parallelGesture](ts-gesture-settings.md)绑定了与子组件同时响应的手势，如[PanGesture](ts-basic-gestures-pangesture.md)，子组件设置了独占控制且首个响应事件，则父组件的手势不会响应。",
      "触发条件": "在同一段落或相邻上下文中，描述同一交互事件时，混合使用了\"触发\"与\"响应\"等不同动作动词，且存在明确的术语对照关系（如手势事件的生命周期阶段）。 \n\n识别模式：\n1. 存在描述事件处理流程的连续句子\n2. 出现具有时序关联性的动作动词（如触发/响应/处理）\n3. 相邻句子中相同语义的动作描述使用了不同动词\n4. 上下文存在明确的事件处理阶段说明（如该案例的手势绑定-响应机制）"
    },
    {
      "defect_id": 264852,
      "sentence": "该示例通过配置disableTextStyleAnimation、defaultTextStyle实现文本选择器禁用文本样式变化动效与此时的文本样式。",
      "reference_sentence": "### 示例2（设置文本样式）该示例通过配置disappearTextStyle、textStyle、selectedTextStyle实现文本选择器中的文本样式。",
      "line_num": 549,
      "context": "{\"544\":\"\",\"545\":\"![textpicker](figures/textpicker4.gif)\",\"546\":\"\",\"547\":\"### 示例6（设置禁用文本样式变化动效与对应文本样式）\",\"548\":\"\",\"549\":\"该示例通过配置disableTextStyleAnimation、defaultTextStyle实现文本选择器禁用文本样式变化动效与此时的文本样式。\",\"550\":\"\",\"551\":\"```ts\",\"552\":\"// xxx.ets\",\"553\":\"@Entry\",\"554\":\"@Component\"}",
      "修改建议": "混用了“文本样式”和“文本样式变化动效”概念，且“设置”与“实现”用词不一致",
      "更改后示例": "该示例通过配置disableTextStyleAnimation、defaultTextStyle实现文本选择器禁用文本样式变化动效与此时的文本样式设置。",
      "触发条件": "同一句子中混用不同层级的概念术语（如功能属性与操作动作），或存在动词与宾语搭配不一致（如\"实现\"与\"设置\"动作冲突）。\n\n识别模式：\n1. 检测名词短语是否包含多级概念（如\"文本样式变化动效\"属性配置 vs \"文本样式\"设置操作）\n2. 验证动宾结构一致性（如\"实现...设置\"应保持动词连贯性，\"配置...实现...设置\"形成完整动作链）"
    },
    {
      "defect_id": 223308,
      "sentence": "该信号是由用户空间的进程发送给另一个进程的，通常是通过kill()系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。",
      "reference_sentence": "该信号是由内核发送给进程的，通常是由内核检测到某些错误或异常情况时发出的。例如，当进程访问无效的内存地址或者执行非法指令时，内核会发送一个SIGSEGV信号给进程。",
      "line_num": 463,
      "context": "{\"458\":\"\",\"459\":\"二级分类(code)除了以上根据信号值(signo)维度分类，还可以根据信号产生的原因维度分类。其中根据信号值(signo)维度分类是每个信号值(signo)特有的，根据信号产生的原因维度分类是所有信号值(signo)共有的，当前已有信号产生原因分类的code值如下：\",\"460\":\"\",\"461\":\"| 二级分类 | 信号字符串 | 解释 | 触发原因 |\",\"462\":\"| -------- | -------- | -------- | -------- |\",\"463\":\"| 0 | SI_USER | 用户空间信号。 |该信号是由用户空间的进程发送给另一个进程的，通常是通过kill()系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。|\",\"464\":\"| 0x80 | SI_KERNEL | 内核信号。 |该信号是由内核发送给进程的，通常是由内核检测到某些错误或异常情况时发出的。例如，当进程访问无效的内存地址或者执行非法指令时，内核会发送一个SIGSEGV信号给进程。|\",\"465\":\"| -1 | SI_QUEUE | sigqueue()函数信号。 |该信号是由sigqueue()系统调用发送的，可以携带一个附加的整数值和一个指针。通常用于进程间高级通信，例如传递数据或者通知进程某个事件已经发生。|\",\"466\":\"| -2 | SI_TIMER | 定时器信号。 |该信号是由定时器发送的，通常用于定时任务或者周期性任务的执行。例如，当一个定时器到期时，内核会向进程发送一个SIGALRM信号。|\",\"467\":\"| -3 | SI_MESGQ | 消息队列信号。 |该信号是由消息队列发送的，通常用于进程间通信。例如，当一个进程向一个消息队列发送消息时，内核会向接收进程发送一个SIGIO信号。|\",\"468\":\"| -4 | SI_ASYNCIO | 异步I/O信号。 |该信号是由异步I/O操作发送的，通常用于非阻塞I/O操作。例如，当一个文件描述符上的I/O操作完成时，内核会向进程发送一个SIGIO信号。|\"}",
      "修改建议": "混用了'发送给另一个进程'和'发送给进程'的表述，以及'系统调用'和'系统调用发送的'的表述不一致",
      "更改后示例": "该信号是由用户空间的进程发送给进程的，通常是通过kill()系统调用发送的。例如，当用户在终端中按下Ctrl+C时，会发送一个SIGINT信号给前台进程组中的所有进程。",
      "触发条件": "同一上下文或相邻语句中出现对同一概念使用不同表述方式（如\"发送给另一个进程\"与\"发送给进程\"混用），或同一动词结构出现时态/语态不一致（如\"通过kill()系统调用发送\"与\"系统调用发送的\"混用）。\n\n识别模式：\n1. 对比相邻句子或同类型描述段落（如表格中的同类解释项）\n2. 检测核心动词短语结构一致性（如\"发送给+对象\"的宾语表述是否统一）\n3. 验证技术术语使用稳定性（如\"系统调用发送\"是否保持动宾结构统一）\n4. 检查同一语义要素的冗余限定词（如\"另一个\"是否破坏上下文一致性）"
    },
    {
      "defect_id": 265094,
      "sentence": "设置宫格圆点在“选中“状态的填充颜色。",
      "reference_sentence": "设置宫格圆点在“选中”状态的填充颜色。",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"### selectedColor\",\"93\":\"\",\"94\":\"selectedColor(value: ResourceColor)\",\"95\":\"\",\"96\":\"设置宫格圆点在“选中“状态的填充颜色。\",\"97\":\"\",\"98\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"99\":\"\",\"100\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"101\":\"\"}",
      "修改建议": "双引号不一致，前文使用的是“”，后文使用的是“”",
      "更改后示例": "设置宫格圆点在“选中”状态的填充颜色。",
      "触发条件": "同一对引号或相邻引号存在符号样式不一致（如全角/半角混用、中文/英文引号混用），或与上下文引号使用风格不统一时触发。\n\n识别模式：\n1. 检测引号对内部符号一致性：匹配引号对（“.*”）时，检查开闭引号是否均为中文全角符号（“”）\n2. 上下文一致性验证：当相邻段落/句子存在规范引号用法时，对比当前引号使用是否符合上下文风格\n3. 特殊符号冲突检测：识别引号中夹杂半角符号（如\"）、全角符号错误（如“与\"混用）等异常组合形态"
    },
    {
      "defect_id": 252144,
      "sentence": "由历史点组成的数组。",
      "reference_sentence": "Array&lt;[HistoricalPoint](#historicalpoint10对象说明)&gt;",
      "line_num": 59,
      "context": "{\"54\":\"\",\"55\":\"**返回值：**\",\"56\":\"\",\"57\":\"| 类型     | 描述                      |\",\"58\":\"| ------ | ----------------------- |\",\"59\":\"| Array&lt;[HistoricalPoint](#historicalpoint10对象说明)&gt; | 由历史点组成的数组。 |\",\"60\":\"\",\"61\":\"\",\"62\":\"## TouchObject对象说明\",\"63\":\"\",\"64\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\"}",
      "修改建议": "术语不一致，'由历史点组成的数组'应与'Array&lt;[HistoricalPoint](#historicalpoint10对象说明)&gt;'保持一致。",
      "更改后示例": "返回由历史点组成的数组。",
      "触发条件": "当文档中存在明确定义的术语格式（如带链接的类型声明\"Array<[HistoricalPoint]>...\"），但在相邻描述中检测到未使用该术语格式的自然语言表达（如\"由历史点组成的数组\"）时触发。\n\n识别模式：\n1. 结构化术语检测：识别代码块/表格中带格式的类型声明（如`Array<[HistoricalPoint]>`）\n2. 自然语言映射验证：检查相邻自然语言描述是否包含对应术语的非结构化表达（如\"历史点组成的数组\"未包含类型链接和格式）\n3. 位置关联性：术语定义与问题描述需处于同一上下文单元（如相邻表格行或相同参数说明区域）"
    },
    {
      "defect_id": 284337,
      "sentence": "应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。这些文件存储在应用文件目录中。",
      "reference_sentence": "设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。",
      "line_num": 3,
      "context": "{\"1\":\"# 应用文件概述\",\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。这些文件存储在应用文件目录中。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放。\",\"6\":\"\",\"7\":\"- “应用文件目录”与部分系统文件（应用运行必需的系统文件）所在的目录共同组成一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此，“应用文件目录”位于“应用沙箱目录”内。\",\"8\":\"\"}",
      "修改建议": "“应用文件目录”与“应用专属的目录”为同一概念，但用词不一致。",
      "更改后示例": "应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。这些文件存储在应用专属的目录中。",
      "触发条件": "同一概念在相邻段落或上下文中出现不同术语表述（如\"应用文件目录\"与\"应用专属的目录\"），且存在明确定义关系（如上下文已说明两者为同一概念）时触发。\n\n识别模式：\n1. 检测相邻段落/句子中存在语义重复的术语组合\n2. 验证术语间是否存在定义关系（如通过定义句式\"X称为Y\"）\n3. 检查是否违反就近一致性原则（优先使用最近定义/引用的术语）"
    },
    {
      "defect_id": 362905,
      "sentence": "对常量重新赋值会造成编译时错误。",
      "reference_sentence": "使用关键字`const`声明的只读常量只能被赋值一次。",
      "line_num": 40,
      "context": "{\"35\":\"\",\"36\":\"```typescript\",\"37\":\"const hello: string = 'hello';\",\"38\":\"```\",\"39\":\"\",\"40\":\"对常量重新赋值会造成编译时错误。\",\"41\":\"\",\"42\":\"#### 自动类型推断\",\"43\":\"\",\"44\":\"由于ArkTS是一种静态类型语言，所有数据的类型都必须在编译时确定。\",\"45\":\"\"}",
      "修改建议": "“常量”应与“只读常量”保持一致",
      "更改后示例": "对只读常量重新赋值会造成编译时错误。",
      "触发条件": "当文档中同一概念存在全称与简称混用（如\"只读常量\"与\"常量\"），且上下文中已明确定义过全称术语时；或同一术语在相邻段落中出现不一致修饰（如是否包含\"只读\"属性描述）时。\n\n识别模式：通过对比当前句子中的术语与上下文/参考句中的标准术语（如检查是否存在缺失的关键属性词），当检测到术语描述完整度不一致但指向同一实体时触发规则。需建立术语映射表（如{常量→只读常量}）并执行跨段落一致性扫描。"
    },
    {
      "defect_id": 284331,
      "sentence": "“应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。",
      "reference_sentence": "“应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。\",\"6\":\"\",\"7\":\"- “应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。\",\"8\":\"\",\"9\":\"- 系统文件及其目录对于应用是只读的；应用仅能保存文件到“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。\",\"10\":\"\",\"11\":\"下文将详细介绍应用沙箱、应用文件目录、应用文件访问与管理、应用文件分享等相关内容。\"}",
      "修改建议": "“应用文件目录”与“应用沙箱目录”混用，容易造成用户理解上的混淆。",
      "更改后示例": "“应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此，应用文件目录是在应用沙箱目录内的。",
      "触发条件": "当同一术语在相邻句子中存在不一致的格式标记（如引号/无引号、链接/纯文本），且该术语已在上下文被明确定义时。\n\n识别模式：\n1. 检查术语首次出现时的标记特征（如带链接的方括号`[xx](link)`或带引号的`\"xx\"`）\n2. 在后续相邻段落中检测同一术语是否出现格式偏差（如变为纯文本或无引号）\n3. 特别关注结论性语句（如\"因此\"后的内容），需与定义段保持绝对一致性\n\n（注：本例中\"应用沙箱目录\"在定义时同时包含链接和引号`[应用沙箱目录](...)`，但在结论句却变为纯引号`\"应用沙箱目录\"`，这种相邻段落间的格式降级触发了规则）"
    },
    {
      "defect_id": 302733,
      "sentence": "场景1：不配置自定义加密/解密参数，此时会使用默认的配置进行数据库的加密和解密。",
      "reference_sentence": "场景2：使用OH_Rdb_SetCryptoParam接口配置加密参数，此时会使用开发者自定义的密钥和算法参数进行数据库的加密/解密。",
      "line_num": 24,
      "context": "{\"19\":\"\",\"20\":\"当encrypt为true时，支持开发者通过调用OH_Rdb_SetCryptoParam方法设置自定义的加密/解密密钥和算法等参数。\",\"21\":\"\",\"22\":\"针对是否配置自定义加密/解密参数，有如下两种场景：\",\"23\":\"\",\"24\":\"场景1：不配置自定义加密/解密参数，此时会使用默认的配置进行数据库的加密和解密。\",\"25\":\"\",\"26\":\"```cpp\",\"27\":\"OH_Rdb_ConfigV2* config = OH_Rdb_CreateConfig();\",\"28\":\"OH_Rdb_SetDatabaseDir(config, \\\"/data/storage/el2/database\\\");\",\"29\":\"OH_Rdb_SetArea(config, RDB_SECURITY_AREA_EL2);\"}",
      "修改建议": "混用了`加密和解密`和`加密/解密`两种表述，建议统一使用`加密/解密`。",
      "更改后示例": "场景1：不配置自定义加密/解密参数，此时会使用默认的配置进行数据库的加密/解密。",
      "触发条件": "同一术语在相邻或相近上下文中出现不同连接符号（如\"加密/解密\"与\"加密和解密\"），或同一文档内存在两种及以上分隔符形式（如\"和\"与\"/\"混用）。识别模式：检测术语中连接词结构（如A/B、A和B）的重复出现，并通过上下文对比发现同一语义单元存在不同分隔符表达。"
    },
    {
      "defect_id": 302710,
      "sentence": "如果操作的过程中出现问题，开发者可以使用恢复功能，将数据库恢复到之前的状态，重新对数据库进行操作。",
      "reference_sentence": "无",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## 场景介绍\",\"10\":\"\",\"11\":\"当应用在处理一项重要的操作，显然是不能被打断的。例如：写入多个表关联的事务。此时，每个表的写入都是单独的，但是表与表之间的事务关联性不能被分割。\",\"12\":\"\",\"13\":\"如果操作的过程中出现问题，开发者可以使用恢复功能，将数据库恢复到之前的状态，重新对数据库进行操作。\",\"14\":\"\",\"15\":\"在数据库被篡改、删除、或者设备断电场景下，数据库可能会因为数据丢失、数据损坏、脏数据等而不可用，可以通过数据库的备份恢复能力将数据库恢复至可用状态。\",\"16\":\"\",\"17\":\"## 关系型数据库备份\",\"18\":\"\"}",
      "修改建议": "句式不一致，使用了陈述句和祈使句混用，建议统一使用祈使句",
      "更改后示例": "如果操作过程中出现问题，使用恢复功能将数据库恢复到之前状态，重新操作数据库。",
      "触发条件": "当同一句子或相邻句子中混合使用陈述句（描述事实）和祈使句（指令性表达），且上下文为操作步骤说明时触发。识别模式为条件状语从句（如\"如果...\"）后接的主句出现主语（如\"开发者可以...\"）而非直接指令动作（如\"使用...\"）。"
    },
    {
      "defect_id": 269384,
      "sentence": "滑动过程中选项进入分割线区域内，触发该回调。",
      "reference_sentence": "滑动TextPicker过程中，选项进入分割线区域内，触发该回调。",
      "line_num": 601,
      "context": "{\"596\":\"\",\"597\":\"## TextPickerEnterSelectedAreaCallback<sup>18+</sup>\",\"598\":\"\",\"599\":\"type TextPickerEnterSelectedAreaCallback = (value: string | string[], index: number | number[]) => void\",\"600\":\"\",\"601\":\"滑动过程中选项进入分割线区域内，触发该回调。\",\"602\":\"\",\"603\":\"在多列联动场景中，不建议使用该回调，由于该回调标识的是滑动过程中选项进入分割线区域内的节点，而跟随变化的选项并不涉及滑动，因此，回调的返回值中，仅当前滑动列的值会正常变化，其余未滑动列的值保持不变。\",\"604\":\"\",\"605\":\"**卡片能力：** 从API version 18开始，该接口支持在ArkTS卡片中使用。\",\"606\":\"\"}",
      "修改建议": "描述同一事件时使用了不同的词汇，缺少'TextPicker'",
      "更改后示例": "滑动TextPicker过程中，选项进入分割线区域内，触发该回调。",
      "触发条件": "当描述组件特定行为时未使用上下文中已明确定义的组件名称（如TextPicker），导致术语不一致，且上下文存在明确组件指向时触发该规则。识别模式需检测行为描述是否缺少前置引入的关键组件名称，同时验证上下文是否存在需要保持术语统一性的技术名词。"
    },
    {
      "defect_id": 286282,
      "sentence": "4. 查询周围上线并且可信的设备。",
      "reference_sentence": "1. 申请分布式数据同步权限。",
      "line_num": 223,
      "context": "{\"218\":\"\",\"219\":\"2. 发现周边不可信设备。\",\"220\":\"   \",\"221\":\"3. 建立设备间的可信关系。\",\"222\":\"\",\"223\":\"4. 查询周围上线并且可信的设备。\",\"224\":\"\",\"225\":\"   ```ts\",\"226\":\"   try {\",\"227\":\"     let deviceInfoList: Array<distributedDeviceManager.DeviceBasicInfo> = dmInstance.getAvailableDeviceListSync();\",\"228\":\"   } catch (err) {\"}",
      "修改建议": "前后文使用了‘周围’与‘周边’，建议统一。",
      "更改后示例": "4. 查询周边上线并且可信的设备。",
      "触发条件": "同一文档中相邻上下文出现多个同义词（如\"周围\"和\"周边\"），且这些词汇指向相同语义概念时触发。\n\n识别模式：\n1. 在相邻段落/列表项中检测到具有相同语义的定位词汇（如空间关系描述词）\n2. 通过词向量相似度分析确认\"周围\"与\"周边\"等词汇的语义重叠度超过阈值\n3. 检查参考句（例中219条）已建立的标准术语表达形式（如\"周边\"）"
    },
    {
      "defect_id": 362901,
      "sentence": "方舟编译运行时（ArkCompiler）支持ArkTS、TS和JS的编译运行，目前主要分为ArkTS编译工具链和ArkTS运行时两部分。ArkTS编译工具链负责将高级语言编译为方舟字节码文件（*.abc），ArkTS运行时则负责在设备侧运行字节码文件，执行程序逻辑。",
      "reference_sentence": "方舟编译器，是OpenHarmony内置的组件化、可配置的多语言编译和运行平台，包含编译器、工具链、运行时等关键部件，支持高级语言在多种芯片平台的编译与运行，并支撑OpenHarmony标准操作系统及其应用和服务运行在手机、个人电脑、平板、电视、汽车和智能穿戴等多种设备上的需求。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"ArkTS基础类库和容器类库增强了语言的基础功能，提供包括[高精度浮点运算](../reference/apis-arkts/js-apis-arkts-decimal.md)、[二进制Buffer](buffer.md)、[XML生成解析转换](xml-overview.md)和多种容器库等能力，协助开发者简化开发工作，提升开发效率。\",\"8\":\"\",\"9\":\"针对TS/JS并发能力支持有限的问题，ArkTS对并发编程API和能力进行了增强，提供了[TaskPool](taskpool-introduction.md)和[Worker](worker-introduction.md)两种并发API供开发者选择。另外，ArkTS进一步提出了Sendable的概念来支持对象在并发实例间的引用传递，提升ArkTS对象在并发实例间的通信性能。\",\"10\":\"\",\"11\":\"方舟编译运行时（ArkCompiler）支持ArkTS、TS和JS的编译运行，目前主要分为ArkTS编译工具链和ArkTS运行时两部分。ArkTS编译工具链负责将高级语言编译为方舟字节码文件（\\\\*.abc），ArkTS运行时则负责在设备侧运行字节码文件，执行程序逻辑。\",\"12\":\"\",\"13\":\"未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并发能力增强、系统类型增强、分布式开发范式等更多特性。\"}",
      "修改建议": "混用了'方舟编译运行时（ArkCompiler）'和'方舟编译器'描述同一事物",
      "更改后示例": "方舟编译器支持ArkTS、TS和JS的编译运行，目前主要分为ArkTS编译工具链和ArkTS运行时两部分。ArkTS编译工具链负责将高级语言编译为方舟字节码文件（*.abc），ArkTS运行时则负责在设备侧运行字节码文件，执行程序逻辑。",
      "触发条件": "同一技术组件在文档中先后出现两种及以上不同命名形式（如全称/简称/别名混用），且未在首次出现时明确标注等价关系。\n\n识别模式：通过实体指称一致性检查，当同一段落或邻近上下文中存在指向相同实体的多个命名变体（如\"方舟编译运行时\"与\"方舟编译器\"），且缺乏明确的\"括号注释\"或\"亦称\"等说明性文字时触发。需结合术语表验证命名规范性，排除合理使用缩略语/全称的情况。"
    },
    {
      "defect_id": 302732,
      "sentence": "当encrypt为true时，支持开发者通过调用OH_Rdb_SetCryptoParam方法设置自定义的加密/解密密钥和算法等参数。",
      "reference_sentence": "isEncrypted参数为true时表示加密，为false时表示不加密，默认不加密。",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"## 关系型数据库加密\",\"17\":\"\",\"18\":\"关系型数据库通过调用OH_Rdb_SetEncrypted方法来设置是否加密。isEncrypted参数为true时表示加密，为false时表示不加密，默认不加密。\",\"19\":\"\",\"20\":\"当encrypt为true时，支持开发者通过调用OH_Rdb_SetCryptoParam方法设置自定义的加密/解密密钥和算法等参数。\",\"21\":\"\",\"22\":\"针对是否配置自定义加密/解密参数，有如下两种场景：\",\"23\":\"\",\"24\":\"场景1：不配置自定义加密/解密参数，此时会使用默认的配置进行数据库的加密和解密。\",\"25\":\"\"}",
      "修改建议": "混用了`encrypt`和`isEncrypted`两个术语，建议统一使用`isEncrypted`。",
      "更改后示例": "当isEncrypted为true时，支持开发者通过调用OH_Rdb_SetCryptoParam方法设置自定义的加密/解密密钥和算法等参数。",
      "触发条件": "同一参数/变量在相邻段落中存在多个命名形式（如encrypt/isEncrypted），且上下文已明确定义推荐术语（如isEncrypted参数）。\n\n识别模式：\n1. 参数命名模式冲突：检测到同一功能属性存在不同命名形式（如布尔参数前缀混用isXxx/xxx）\n2. 上下文锚定验证：在相邻段落（3行内）存在明确定义的推荐术语（如\"isEncrypted参数为true\"的声明式定义）\n3. 语义等价判断：通过词干分析确认不同术语指向同一概念（如encrypt与isEncrypted均指向数据库加密状态）"
    },
    {
      "defect_id": 284265,
      "sentence": "2. 二级目录storage/：代表本应用持久化文件目录。",
      "reference_sentence": "在此主要介绍应用文件目录，如下图所示。应用文件目录下某个文件或某个具体目录的路径称为应用文件路径。",
      "line_num": 49,
      "context": "{\"44\":\"> - 禁止直接使用上图中四级目录之前的目录名组成的路径字符串，否则可能导致后续应用版本因应用文件路径变化导致不兼容问题。\",\"45\":\"> - 应通过Context属性获取应用文件路径，包括但不限于上图中绿色背景的路径。 Context上下文获取及上述应用文件路径的获取，详见[应用上下文Context](../application-models/application-context-stage.md)。\",\"46\":\"\",\"47\":\"1. 一级目录data/：代表应用文件目录。\",\"48\":\"\",\"49\":\"2. 二级目录storage/：代表本应用持久化文件目录。\",\"50\":\"\",\"51\":\"3. 三级目录el1/~el5/：代表不同文件加密类型。\",\"52\":\"\",\"53\":\"    EL1(Encryption Level 1):\",\"54\":\"     - 保护设备上的所有文件的基础安全能力。在设备开机后，不需要用户先完成身份认证即可访问EL1保护的文件。如无特殊必要，不推荐使用该方式。\"}",
      "修改建议": "“本应用持久化文件目录”和“应用文件目录”表述不一致，建议统一。",
      "更改后示例": "2. 二级目录storage/：代表应用文件目录下的持久化文件目录。",
      "触发条件": "同一文档中相同术语存在修饰词（如“本应用”）或结构不一致（如“持久化文件目录”与“应用文件目录”未形成层级关联），且上下文存在已明确定义的上级术语（如“应用文件目录”）时触发。\n\n识别模式：\n1. **修饰冲突**：检测术语是否添加了冗余限定词（如“本”），导致与上下文定义的核心术语（如“应用文件目录”）脱节；\n2. **层级断裂**：判断子级描述（如二级目录）是否未明确关联父级术语（如一级目录），未通过“X目录下的Y目录”等结构保持逻辑连贯性。"
    },
    {
      "defect_id": 285424,
      "sentence": "返回预设滑动手势识别器触发滑动手势滑动方向阈值。",
      "reference_sentence": "返回预设滑动手势识别器触发滑动手势滑动方向。",
      "line_num": 438,
      "context": "{\"433\":\"\",\"434\":\"### getDirection<sup>18+</sup>\",\"435\":\"\",\"436\":\"getDirection(): SwipeDirection\",\"437\":\"\",\"438\":\"返回预设滑动手势识别器触发滑动手势滑动方向阈值。\",\"439\":\"\",\"440\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"441\":\"\",\"442\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"443\":\"\"}",
      "修改建议": "“滑动方向阈值”与“滑动方向”不一致。",
      "更改后示例": "返回预设滑动手势识别器触发滑动手势滑动方向。",
      "触发条件": "当文档中的术语组合（如\"滑动方向阈值\"）与API方法实际返回参数（如\"SwipeDirection\"）或上下文定义的关键术语（如\"滑动方向\"）存在不匹配时，且存在冗余/无关的限定词（如\"阈值\"）导致概念混淆。"
    },
    {
      "defect_id": 284266,
      "sentence": "3. 三级目录el1/~el5/：代表不同文件加密类型。",
      "reference_sentence": "在此主要介绍应用文件目录，如下图所示。应用文件目录下某个文件或某个具体目录的路径称为应用文件路径。",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"1. 一级目录data/：代表应用文件目录。\",\"48\":\"\",\"49\":\"2. 二级目录storage/：代表本应用持久化文件目录。\",\"50\":\"\",\"51\":\"3. 三级目录el1/~el5/：代表不同文件加密类型。\",\"52\":\"\",\"53\":\"    EL1(Encryption Level 1):\",\"54\":\"     - 保护设备上的所有文件的基础安全能力。在设备开机后，不需要用户先完成身份认证即可访问EL1保护的文件。如无特殊必要，不推荐使用该方式。\",\"55\":\"     - 如果直接窃取设备存储介质上的密文，攻击者无法脱机进行解密。\",\"56\":\"\"}",
      "修改建议": "“不同文件加密类型”和“应用文件目录”表述不一致，建议统一。",
      "更改后示例": "3. 三级目录el1/~el5/：代表应用文件目录下的不同文件加密类型。",
      "触发条件": "当文档中层级结构描述未延续上级已明确定义的统一术语，或同一概念存在上下文术语表述不一致时触发。  \n\n识别模式：检查条目是否继承上级目录的核心限定词（如\"应用文件目录\"），并比对上下文是否存在相同概念使用不同表述（如\"不同文件加密类型\"未关联前文定义的\"应用文件目录\"）。"
    },
    {
      "defect_id": 284287,
      "sentence": "应用沙箱路径与真实物理路径对应关系如下表所示。",
      "reference_sentence": "应用沙箱路径与真实物理路径的对应关系如下表所示。",
      "line_num": 102,
      "context": "{\"97\":\"   | preferences | preferencesDir | 应用首选项文件路径 | 应用在本设备内部存储上通过数据库API存储配置类或首选项的目录；随应用卸载而清理。详见[通过用户首选项实现数据持久化](../database/data-persistence-by-preferences.md)。 <br>可以用于保存应用的首选项数据，主要包括应用首选项文件以及配置文件等。此路径下仅适用于存储小量数据。|\",\"98\":\"   | temp | tempDir | 应用临时文件路径 | 应用在本设备内部存储上仅在应用运行期间产生和需要的文件，应用退出后即清理。<br>可以用于保存应用的临时生成的数据，主要包括数据库缓存、图片缓存、临时日志文件、以及下载的应用安装包文件等。此路径下存储使用后即可删除的数据。 |\",\"99\":\"\",\"100\":\"## 应用沙箱路径和真实物理路径的对应关系\",\"101\":\"\",\"102\":\"在应用沙箱路径下读写文件，经过映射转换，实际读写的是真实物理路径中的应用文件，应用沙箱路径与真实物理路径对应关系如下表所示。\",\"103\":\"\",\"104\":\"其中&lt;USERID&gt;为当前用户ID，从100开始递增，&lt;EXTENSIONPATH&gt;为moduleName-extensionName。应用是否以Extension独立沙箱运行可参考[ExtensionAbility组件](../application-models/extensionability-overview.md)。\",\"105\":\"\",\"106\":\"| 应用沙箱路径 | 物理路径 |\",\"107\":\"| -------- | -------- |\"}",
      "修改建议": "句子中'对应关系'与'的对应关系'用词不一致",
      "更改后示例": "应用沙箱路径与真实物理路径的对应关系如下表所示。",
      "触发条件": "当同一段落或相邻上下文中存在同一名词短语（如“对应关系”）的结构不一致（如“的对应关系”与“对应关系”混用）时触发。\n\n识别模式：\n1. **邻近重复检查**：在问题句子的上下文中（如问题上下文第100行），存在正确表述“的对应关系”，而当前句子（第102行）省略了“的”，导致同一概念表达形式不一致。\n2. **结构对比**：通过匹配名词短语核心词（如“对应关系”），识别其修饰成分（如“的”是否存在）是否与上下文或参考范例一致。若存在差异且影响语义连贯性，则判定为需修复。"
    },
    {
      "defect_id": 283955,
      "sentence": "动态设置组件绑定的手势，支持开发者在属性设置时使用if/else语法。",
      "reference_sentence": "动态设置组件绑定的手势。",
      "line_num": 3,
      "context": "{\"1\":\"# 动态手势设置\",\"2\":\"\",\"3\":\"动态设置组件绑定的手势，支持开发者在属性设置时使用if/else语法。\",\"4\":\"\",\"5\":\">  **说明：**\",\"6\":\">\",\"7\":\">  从API version 12开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\",\"8\":\"\"}",
      "修改建议": "前文使用了“动态设置组件绑定的手势”，后文使用了“在属性设置时使用if/else语法”，导致用词不一致。",
      "更改后示例": "动态设置组件绑定的手势，支持开发者在属性设置时使用if/else语法进行动态设置。",
      "触发条件": "当同一句子或相邻上下文中，同一核心动作（如\"动态设置\"）使用不同动词结构（如\"使用\"替代\"动态设置\"）且未保持术语复现时触发；或关键操作描述存在前后表述断层（如前半句强调动作，后半句缺少对应动作承接）时触发。"
    },
    {
      "defect_id": 284329,
      "sentence": "应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。",
      "reference_sentence": "应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。",
      "line_num": 3,
      "context": "{\"1\":\"# 应用文件概述\",\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。\",\"6\":\"\",\"7\":\"- “应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。\",\"8\":\"\"}",
      "修改建议": "“应用文件”与“应用文件目录”混用，容易造成用户理解上的混淆。",
      "更改后示例": "应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。这些文件存储在应用文件目录中。",
      "触发条件": "当同一段落或相邻段落中出现多个相似术语（如\"应用文件\"和\"应用文件目录\"），且这些术语在上下文中有明确定义差异但未建立清晰指代关系时触发。\n\n识别模式：\n1. 存在两个及以上相似术语（词根重复+新增限定词）\n2. 术语定义分散在不同位置（如案例中\"应用文件\"在第3段定义，\"应用文件目录\"在第5段定义）\n3. 未在首次出现时建立术语间的逻辑关联（如未说明\"应用文件存储在应用文件目录中\"）\n4. 存在用户反馈或内部检查发现的术语混淆风险"
    },
    {
      "defect_id": 284330,
      "sentence": "设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。",
      "reference_sentence": "设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。",
      "line_num": 5,
      "context": "{\"1\":\"# 应用文件概述\",\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。\",\"6\":\"\",\"7\":\"- “应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。\",\"8\":\"\",\"9\":\"- 系统文件及其目录对于应用是只读的；应用仅能保存文件到“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。\",\"10\":\"\"}",
      "修改建议": "“应用文件”与“应用文件目录”混用，容易造成用户理解上的混淆。",
      "更改后示例": "设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放。",
      "触发条件": "当同一段落或相邻上下文中出现多个关联术语（如\"应用文件\"和\"应用文件目录\"），且存在用核心词重复但实际指代不同的概念时；或术语定义层级关系（如目录→文件）但表述中发生概念交叉引用时。"
    },
    {
      "defect_id": 284338,
      "sentence": "“应用文件目录”与部分系统文件（应用运行必需的系统文件）所在的目录共同组成一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此，“应用文件目录”位于“应用沙箱目录”内。",
      "reference_sentence": "系统文件及其目录对于应用是只读的。应用仅能保存文件到“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。这些文件存储在应用文件目录中。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放。\",\"6\":\"\",\"7\":\"- “应用文件目录”与部分系统文件（应用运行必需的系统文件）所在的目录共同组成一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此，“应用文件目录”位于“应用沙箱目录”内。\",\"8\":\"\",\"9\":\"- 系统文件及其目录对于应用是只读的。应用仅能保存文件到“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。\",\"10\":\"\",\"11\":\"下文将详细介绍应用沙箱、应用文件目录、应用文件访问与管理、应用文件分享等相关内容。\"}",
      "修改建议": "“应用文件目录”与“应用专属的目录”为同一概念，但用词不一致。",
      "更改后示例": "“应用专属的目录”与部分系统文件（应用运行必需的系统文件）所在的目录共同组成一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此，“应用专属的目录”位于“应用沙箱目录”内。",
      "触发条件": "同一文档中出现多个不同术语指代同一核心概念，且这些术语在相邻段落或关联上下文中交替使用而未保持统一。 \n\n识别模式：通过比对术语定义、超链接锚点及上下文逻辑关系，检测出在相近位置（如问题案例中第5段与第7段）存在语义重复但表述不一致的术语（如“应用专属的目录”与“应用文件目录”），且未通过注释或格式（如括号说明、同义词标注）明确其等价性。"
    },
    {
      "defect_id": 284263,
      "sentence": "同时，所有应用的目录可见范围均经过权限隔离与文件路径挂载隔离，形成了独立的路径视图，屏蔽了实际物理路径：",
      "reference_sentence": "在应用沙箱保护机制下，应用无法获知除自身应用文件目录之外的其他应用或用户的数据目录位置及存在。",
      "line_num": 18,
      "context": "{\"13\":\"**图1** 应用沙箱文件访问关系图  \",\"14\":\"![Application sandbox file access relationship](figures/application-sandbox-file-access-relationship.png)\",\"15\":\"\",\"16\":\"## 应用沙箱目录与应用沙箱路径\",\"17\":\"\",\"18\":\"在应用沙箱保护机制下，应用无法获知除自身应用文件目录之外的其他应用或用户的数据目录位置及存在。同时，所有应用的目录可见范围均经过权限隔离与文件路径挂载隔离，形成了独立的路径视图，屏蔽了实际物理路径：\",\"19\":\"\",\"20\":\"- 如下图所示，在普通应用（也称三方应用）视角下，不仅可见的目录与文件数量限制了范围，并且可见的目录与文件路径也与系统进程等其他进程看到的不同。我们将普通应用视角下看到的“应用沙箱目录”下某个文件或某个具体目录的路径，称为“应用沙箱路径”。\",\"21\":\"\",\"22\":\"<!--RP1-->\",\"23\":\"- 一般情况下，开发者的hdc shell环境等效于系统进程视角，因此“应用沙箱路径”与开发者使用hdc工具调试时看到的真实物理路径不同，其对应关系详见[应用沙箱路径和真实物理路径的对应关系](#应用沙箱路径和真实物理路径的对应关系)。\"}",
      "修改建议": "“路径视图”和“数据目录位置及存在”表述不一致，建议统一。",
      "更改后示例": "同时，所有应用的目录可见范围均经过权限隔离与文件路径挂载隔离，形成了独立的路径视图，屏蔽了其他应用或用户的数据目录位置及存在。",
      "触发条件": "当同一段落或相邻句子中存在描述同一技术概念时，若出现术语不一致（如\"实际物理路径\"与\"数据目录位置及存在\"）、或关键信息要素缺失（如缺少\"其他应用或用户\"的限定范围），且上下文存在明确对应的规范表述时触发。\n\n识别模式：\n1. 核心概念匹配：通过对比上下文中的规范术语（如参考句中的\"数据目录位置及存在\"），检测当前句子是否存在同义但表述不一致的短语\n2. 信息完整性验证：检查是否缺失关键限定要素（如案例中缺少\"其他应用或用户的\"限定词）\n3. 逻辑衔接分析：当句子包含\"屏蔽/隔离/限制\"等动作时，需确保被作用对象与上下文保护目标完全对应"
    },
    {
      "defect_id": 362899,
      "sentence": "ArkTS是OpenHarmony应用开发的官方高级语言。",
      "reference_sentence": "ArkTS是OpenHarmony生态的应用开发语言。",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS简介\",\"2\":\"\",\"3\":\"ArkTS是OpenHarmony应用开发的官方高级语言。\",\"4\":\"\",\"5\":\"ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。\",\"6\":\"\",\"7\":\"ArkTS基础类库和容器类库增强了语言的基础功能，提供包括[高精度浮点运算](../reference/apis-arkts/js-apis-arkts-decimal.md)、[二进制Buffer](buffer.md)、[XML生成解析转换](xml-overview.md)和多种容器库等能力，协助开发者简化开发工作，提升开发效率。\",\"8\":\"\"}",
      "修改建议": "混用了'官方高级语言'和'应用开发语言'描述同一事物",
      "更改后示例": "ArkTS是OpenHarmony生态的应用开发语言。",
      "触发条件": "同一文档中对同一概念或实体使用了不一致的术语或描述性短语，且上下文存在已定义的标准表达方式。\n\n识别模式：\n1. 检测同一实体在相邻段落或章节中是否被不同术语描述（如\"官方高级语言\" vs \"应用开发语言\"）\n2. 匹配预定义术语库或上下文已出现的标准表达（如参考句中的\"应用开发语言\"）\n3. 验证同义表述是否违反既定命名规范（如\"生态\"限定词的使用一致性）"
    },
    {
      "defect_id": 284264,
      "sentence": "下图展示了应用沙箱下，应用可访问的文件范围和方式。",
      "reference_sentence": "下图展示了应用沙箱路径（不同权限与角色的进程下可见的文件路径不同）",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"- 应用沙箱限制了应用可见的数据范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。\",\"8\":\"\",\"9\":\"- 应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问[用户文件](user-file-overview.md)，则需要通过特定API同时经过用户的相应授权才能进行。\",\"10\":\"\",\"11\":\"下图展示了应用沙箱下，应用可访问的文件范围和方式。\",\"12\":\"\",\"13\":\"**图1** 应用沙箱文件访问关系图  \",\"14\":\"![Application sandbox file access relationship](figures/application-sandbox-file-access-relationship.png)\",\"15\":\"\",\"16\":\"## 应用沙箱目录与应用沙箱路径\"}",
      "修改建议": "“应用可访问的文件范围和方式”和“不同权限与角色的进程下可见的文件路径不同”表述不一致，建议统一。",
      "更改后示例": "下图展示了应用沙箱下，不同权限与角色的进程下可见的文件路径。",
      "触发条件": "当文档中同一概念存在多个表述形式（如\"应用可访问的文件范围\"与\"不同权限角色的进程可见路径\"），且上下文已存在标准表述（如\"不同权限与角色的进程下可见的文件路径不同\"）时触发。\n\n识别模式：\n1. 核心概念重复出现但表述结构不同（\"可访问的文件范围\" vs \"可见的文件路径\"）\n2. 相邻段落存在明确的概念定义（第7段详细说明权限角色与可见路径的关系）\n3. 关键限定条件缺失或变形（原句未体现\"不同权限角色\"这一核心差异点）\n4. 动词与名词搭配不一致（\"访问\"与\"可见\"的语义差异）"
    },
    {
      "defect_id": 363098,
      "sentence": "注解不支持在类的getter和setter方法添加，若添加注解会编译报错。",
      "reference_sentence": "注解不支持对抽象类和抽象方法使用注解，否则会有编译报错。",
      "line_num": 1915,
      "context": "{\"1910\":\"注解不是类型，把注解当类型使用时会出现编译报错（例如：对注解使用类型别名）。\",\"1911\":\"```typescript\",\"1912\":\"@interface Position {}\",\"1913\":\"type Pos = Position; // 编译错误：注解不是类型\",\"1914\":\"```\",\"1915\":\"注解不支持在类的getter和setter方法添加，若添加注解会编译报错。\",\"1916\":\"```typescript\",\"1917\":\"@interface ClassAuthor {\",\"1918\":\"  authorName: string;\",\"1919\":\"}\",\"1920\":\"\"}",
      "修改建议": "混用了'添加'和'使用'，表意不一致",
      "更改后示例": "注解不支持在类的getter和setter方法中使用，若使用注解会编译报错。",
      "触发条件": "同一段落或相邻句子中重复描述同一操作时，使用不一致的动词/术语（如\"添加\"与\"使用\"），且存在文档内其他同类描述的标准用词（如参考句中的\"使用\"）。\n\n识别模式：\n1. 定位重复性操作描述（本案例两次说明\"注解应用在方法会报错\"）\n2. 检测关键动词的语义等价性（\"添加\"与\"使用\"均指向注解应用行为）\n3. 对比上下文标准用词（参考句1910明确使用\"使用\"作为标准术语）\n4. 验证术语冲突（\"添加\"与既定术语\"使用\"产生表意割裂）。"
    },
    {
      "defect_id": 362939,
      "sentence": "构造函数函数体的第一条语句可以使用关键字`super`来显式调用直接父类的构造函数。",
      "reference_sentence": "关键字`super`可用于访问父类的实例字段、实例方法和构造函数。",
      "line_num": 1135,
      "context": "{\"1130\":\"\",\"1131\":\"在这种情况下，默认构造函数使用字段类型的默认值初始化实例中的字段。\",\"1132\":\"\",\"1133\":\"#### 派生类的构造函数\",\"1134\":\"\",\"1135\":\"构造函数函数体的第一条语句可以使用关键字`super`来显式调用直接父类的构造函数。\",\"1136\":\"\",\"1137\":\"```typescript\",\"1138\":\"class RectangleSize {\",\"1139\":\"  constructor(width: number, height: number) {\",\"1140\":\"    // ...\"}",
      "修改建议": "混用了'父类'和'基类'，建议使用一致的术语。",
      "更改后示例": "构造函数函数体的第一条语句可以使用关键字`super`来显式调用直接基类的构造函数。",
      "触发条件": "同一文档中出现多个同义术语指代同一概念（如\"父类\"与\"基类\"混用），且上下文存在已确立的标准术语（如参考句中的\"父类\"持续使用模式）。"
    },
    {
      "defect_id": 363265,
      "sentence": "TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用`as any`转换对象的类型，或者在编译TS代码时关闭严格类型检查的配置，或者在代码中通过`@ts-ignore`忽略类型检查。",
      "reference_sentence": "TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用`as any`转换对象的类型，或者在编译TS代码时关闭严格类型检查的配置，或者在代码中通过`@ts-ignore`忽略类型检查。",
      "line_num": 80,
      "context": "{\"75\":\"\",\"76\":\"- 向对象中添加新的属性或方法。\",\"77\":\"- 从对象中删除已有的属性或方法。\",\"78\":\"- 将任意类型的值赋值给对象属性。\",\"79\":\"\",\"80\":\"TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用`as any`转换对象的类型，或者在编译TS代码时关闭严格类型检查的配置，或者在代码中通过`@ts-ignore`忽略类型检查。\",\"81\":\"\",\"82\":\"在ArkTS中，严格类型检查不是可配置项。ArkTS强制进行部分严格类型检查，并通过规范禁止使用`any`类型，禁止在代码中使用`@ts-ignore`。\",\"83\":\"\",\"84\":\"**示例**\",\"85\":\"\"}",
      "修改建议": "混用了`编译器`和`编译TS代码时`，建议统一使用`编译器`。",
      "更改后示例": "TypeScript编译器已经禁止了许多此类操作。然而，有些操作还是有可能绕过编译器的，例如，使用`as any`转换对象的类型，或者关闭编译器的严格类型检查配置，或者在代码中通过`@ts-ignore`忽略类型检查。",
      "触发条件": "同一上下文或相邻句子中出现对同一概念使用不同术语表述（如\"编译器\"和\"编译TS代码时\"），且在并列结构中存在表达方式不统一的情况。"
    },
    {
      "defect_id": 363056,
      "sentence": "关键字`this`只能在类的实例方法中使用。",
      "reference_sentence": "关键字`this`的指向: * 调用实例方法的对象 * 正在构造的对象",
      "line_num": 1766,
      "context": "{\"1761\":\"\",\"1762\":\"## 关键字\",\"1763\":\"\",\"1764\":\"### this\",\"1765\":\"\",\"1766\":\"关键字`this`只能在类的实例方法中使用。\",\"1767\":\"\",\"1768\":\"**示例**\",\"1769\":\"\",\"1770\":\"```typescript\",\"1771\":\"class A {\"}",
      "修改建议": "前后文对`this`的使用场景描述不一致，建议统一。",
      "更改后示例": "关键字`this`只能在类的实例方法中使用，指向调用实例方法的对象或正在构造的对象。",
      "触发条件": "当同一术语的关键属性描述在相邻段落中存在详细度差异（如使用场景与具体指向分离说明），且未通过明确关联词建立逻辑呼应时触发\n\n识别模式需检测以下特征组合：\n1. 核心术语在紧凑文本区间(≤3段)内重复出现\n2. 前句包含限制条件(如\"只能在...使用\")，后文存在扩展解释但未使用衔接词(如\"具体指\"/\"包括\")\n3. 参考句中的列举结构(星号列表)未与限制条件语句形成语法关联\n4. 存在可合并的平行语义要素(使用场景限制+指向对象说明)被分散表述"
    },
    {
      "defect_id": 363185,
      "sentence": "当语句过长或可读性不佳时，需要在合适的地方进行换行。",
      "reference_sentence": "表达式换行需保持一致性，运算符放行末",
      "line_num": 297,
      "context": "{\"292\":\"\",\"293\":\"**【级别】建议**\",\"294\":\"\",\"295\":\"**【描述】**\",\"296\":\"\",\"297\":\"当语句过长或可读性不佳时，需要在合适的地方进行换行。\",\"298\":\"换行时将操作符放在行末，表示“未结束，后续还有”，保持与常用的格式化工具的默认配置一致。\",\"299\":\"\",\"300\":\"**【正例】**\",\"301\":\"\",\"302\":\"```\"}",
      "修改建议": "混用了“语句”和“表达式”的表述，不一致",
      "更改后示例": "当表达式过长或可读性不佳时，需要在合适的地方进行换行。",
      "触发条件": "当同一术语（如\"语句\"和\"表达式\"）在相邻句子或同一规则条目中混用，且上下文明确指向同一技术概念时触发。\n\n识别模式：\n1. 检测相邻句子/段落中存在指代同一技术实体的不同术语（如语句/表达式）\n2. 对比上下文中的标准术语使用（如参考案例中的\"表达式\"）\n3. 验证术语差异是否造成概念歧义（如语句与表达式在编程中的不同定义）"
    },
    {
      "defect_id": 362924,
      "sentence": "`Object`类型是所有引用类型的基类型。任何值，包括基本类型的值，都可以直接被赋给`Object`类型的变量（基本类型值会被自动装箱）。`Object`类型用于表示除基本类型外的类型。",
      "reference_sentence": "无",
      "line_num": 156,
      "context": "{\"151\":\"let instance: Class <void>\",\"152\":\"```\",\"153\":\"\",\"154\":\"#### `Object`类型\",\"155\":\"\",\"156\":\"`Object`类型是所有引用类型的基类型。任何值，包括基本类型的值，都可以直接被赋给`Object`类型的变量（基本类型值会被自动装箱）。`Object`类型用于表示除基本类型外的类型。\",\"157\":\"\",\"158\":\"#### `array`类型\",\"159\":\"\",\"160\":\"`array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。\",\"161\":\"数组可由数组复合字面量赋值。数组复合字面量是用方括号括起来的零个或多个表达式列表，每个表达式为数组中的一个元素。数组的长度由数组中元素的个数确定。数组中第一个元素的索引为0。\"}",
      "修改建议": "使用了不规范的术语`基类型`，应使用`基类`或`基类型`中的一个，且全文应保持一致。",
      "更改后示例": "`Object`类型是所有引用类型的基类。任何值，包括基本类型的值，都可以直接被赋给`Object`类型的变量（基本类型值会被自动装箱）。`Object`类型用于表示除基本类型外的类型。",
      "触发条件": "当文档中同一概念存在多个术语变体（如\"基类型\"和\"基类\"），且未保持统一表达时触发；当检测到技术术语与上下文/行业标准用法不一致时触发。\n\n识别模式：\n1. 术语同义冲突：通过NLP识别同一语义概念的不同表达形式（如\"基类\"vs\"基类型\"）\n2. 上下文一致性检查：比对当前术语与文档历史术语库（如问题上下文第160行使用\"元素类型\"而非\"成员类型\"）\n3. 领域规范匹配：验证术语是否符合技术领域标准（如面向对象编程中\"基类\"比\"基类型\"更规范）"
    },
    {
      "defect_id": 363230,
      "sentence": "在标准的TS/JS中，JSON的数字格式要求小数点后必须跟随数字，例如 `2.e3` 这类科学计数法不被允许，会导致`SyntaxError`。而在方舟运行时中，支持这类科学计数法",
      "reference_sentence": "## 支持与TS/JS的交互ArkTS支持与TS/JS的高效互操作。在当前版本中，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互时，将TS/JS的数据和对象作为ArkTS的数据和对象使用，可能会绕过ArkTS的静态编译检查，导致非预期的行为或增加额外的开销。",
      "line_num": 189,
      "context": "{\"184\":\"\",\"185\":\"    ```\",\"186\":\"\",\"187\":\"**与标准TS/JS的差异**\",\"188\":\"\",\"189\":\"在标准的TS/JS中，JSON的数字格式要求小数点后必须跟随数字，例如 `2.e3` 这类科学计数法不被允许，会导致`SyntaxError`。而在方舟运行时中，支持这类科学计数法\"}",
      "修改建议": "混用了“TS/JS”和“标准TS/JS”两个术语，应保持一致。",
      "更改后示例": "在标准的TS/JS中，JSON的数字格式要求小数点后必须跟随数字，例如 `2.e3` 这类科学计数法不被允许，会导致`SyntaxError`。而在方舟运行时中，支持这类科学计数法。",
      "触发条件": "同一术语在相邻上下文或同一主题下出现带/不带修饰词（如\"标准TS/JS\"与\"TS/JS\"）的不一致表述，且未通过语境明确区分不同概念时触发。"
    },
    {
      "defect_id": 363055,
      "sentence": "如果`Person`实例的`spouse`属性不为空，并且`spouse`的`nick`属性也不为空时，输出`spouse.nick`。否则，输出`undefined`。",
      "reference_sentence": "可选链访问对象属性时，如果属性是`undefined`或`null`，可选链运算符返回`undefined`。",
      "line_num": 1625,
      "context": "{\"1620\":\"\",\"1621\":\"**说明**：`getSpouseNick`的返回类型必须为`string | null | undefined`，因为该方法在某些情况下会返回`null`或`undefined`。\",\"1622\":\"\",\"1623\":\"可选链可以任意长，可以包含任意数量的`?.`运算符。\",\"1624\":\"\",\"1625\":\"在以下示例中，如果`Person`实例的`spouse`属性不为空，并且`spouse`的`nick`属性也不为空时，输出`spouse.nick`。否则，输出`undefined`。\",\"1626\":\"\",\"1627\":\"```typescript\",\"1628\":\"class Person {\",\"1629\":\"  nick: string | null = null;\",\"1630\":\"  spouse?: Person;\"}",
      "修改建议": "前后文对`undefined`和`null`的处理不一致，建议统一使用`undefined`。",
      "更改后示例": "如果`Person`实例的`spouse`属性不为`undefined`，并且`spouse`的`nick`属性也不为`undefined`时，输出`spouse.nick`。否则，输出`undefined`。",
      "触发条件": "当同一文档段落中同时存在`undefined`和`null`的空值判断，且上下文存在明确的类型定义（如`string | null | undefined`）或技术规范（如可选链运算符行为）要求统一空值描述时。\n\n识别模式：\n1. 检测相邻句子/条件中是否存在`undefined`和`null`的混用（如\"不为空\"隐含`null`判断与显式`undefined`判断共存）\n2. 匹配上下文类型声明（如1621行返回值类型包含`null | undefined`）与参考技术规范（如1623行可选链运算符行为）\n3. 识别条件判断与结果输出阶段是否使用相同的空值术语（如问题句用\"不为空\"但输出`undefined`）"
    },
    {
      "defect_id": 363184,
      "sentence": "在`if`、`for`、`do`、`while`等语句的执行体加大括号`{}`是一种最佳实践，因为省略大括号容易导致错误，并且降低代码的清晰度。",
      "reference_sentence": "条件语句和循环语句的实现必须使用大括号",
      "line_num": 242,
      "context": "{\"237\":\"\",\"238\":\"**【级别】建议**\",\"239\":\"\",\"240\":\"**【描述】**\",\"241\":\"\",\"242\":\"在`if`、`for`、`do`、`while`等语句的执行体加大括号`{}`是一种最佳实践，因为省略大括号容易导致错误，并且降低代码的清晰度。\",\"243\":\"\",\"244\":\"**【反例】**\",\"245\":\"\",\"246\":\"```\",\"247\":\"if (condition)\"}",
      "修改建议": "混用了“条件语句”和“`if`、`for`、`do`、`while`等语句”的表述，不一致",
      "更改后示例": "在条件语句和循环语句的执行体加大括号`{}`是一种最佳实践，因为省略大括号容易导致错误，并且降低代码的清晰度。",
      "触发条件": "同一上下文或规范条款中混用具体语句示例（如`if`、`for`）与分类术语（如\"条件语句\"、\"循环语句\"），导致概念表述不一致。\n\n识别模式：检查技术文档中是否存在同一概念同时使用具体代码结构名称（动词性描述）和抽象分类术语（名词性描述）的情况，且两者未在相邻语句中建立明确对应关系。例如当\"if语句\"与\"条件语句\"交替出现且未声明等价性时，触发规则。"
    },
    {
      "defect_id": 363187,
      "sentence": "应保持一致的大括号风格。建议将大括号置于控制语句或声明语句的同一行。",
      "reference_sentence": "大括号`{`和语句在同一行",
      "line_num": 548,
      "context": "{\"543\":\"\",\"544\":\"**【级别】建议**\",\"545\":\"\",\"546\":\"**【描述】**\",\"547\":\"\",\"548\":\"应保持一致的大括号风格。建议将大括号置于控制语句或声明语句的同一行。\",\"549\":\"\",\"550\":\"**【反例】**\",\"551\":\"\",\"552\":\"```\",\"553\":\"function foo()\"}",
      "修改建议": "混用了“控制语句或声明语句”和“语句”的表述，不一致",
      "更改后示例": "应保持一致的大括号风格。建议将大括号置于语句的同一行。",
      "触发条件": "同一文档段落内出现针对相同概念使用不同术语表述（如\"控制语句或声明语句\"与\"语句\"），且上下文未明确区分其语义差异时。\n\n识别模式：通过自然语言处理检测相邻句子/条款中是否对同一技术要素（如大括号位置）使用不同限定词（\"控制语句或声明语句\"→\"语句\"），同时验证参考规范（如\"与语句在同一行\"）是否存在明确术语标准。当检测到冗余限定词且未增加有效信息时触发规则。"
    },
    {
      "defect_id": 363267,
      "sentence": "具体采用哪种方法，情况如下：",
      "reference_sentence": "具体采用哪种方法，情况如下：",
      "line_num": 189,
      "context": "{\"184\":\"\",\"185\":\"let t: T = new T();\",\"186\":\"greeter(t); // 是否允许？\",\"187\":\"```\",\"188\":\"\",\"189\":\"具体采用哪种方法，情况如下：\",\"190\":\"\",\"191\":\"- `T`和`U`没有继承关系或没有`implements`相同的接口，但由于它们具有相同的`public`API，它们“在某种程度上是相等的”，所以上述两个问题的答案都是“是”。\",\"192\":\"- `T`和`U`没有继承关系或没有`implements`相同的接口，应当始终被视为完全不同的类型，因此上述两个问题的答案都是“否”。\",\"193\":\"\",\"194\":\"采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。\"}",
      "修改建议": "混用了`方法`和`情况`，建议统一使用`情况`。",
      "更改后示例": "具体情况如下：",
      "触发条件": "同一段落或相邻句子中混用了指代同一核心概念的不同术语（如\"方法\"和\"情况\"），且上下文存在明确统一的术语使用模式（如参考句子后续内容持续使用\"情况\"）。当检测到同一语义概念存在两种及以上表达形式时触发。"
    },
    {
      "defect_id": 363670,
      "sentence": "方式1.将.ts文件的后缀修改为ets，并按ArkTS语法规则适配代码。",
      "reference_sentence": "方式1.将.ts文件的后缀修改为ets，并按ArkTS语法规则适配代码。",
      "line_num": 2017,
      "context": "{\"2012\":\"\",\"2013\":\"不允许.ts、.js文件`import`.ets文件源码。\",\"2014\":\"\",\"2015\":\"**建议改法**\",\"2016\":\"\",\"2017\":\"方式1.将.ts文件的后缀修改为ets，并按ArkTS语法规则适配代码。\",\"2018\":\"\",\"2019\":\"方式2.将.ets文件中被.ts文件依赖的代码单独抽取到.ts文件中。\",\"2020\":\"\",\"2021\":\"## arkts-no-special-imports\",\"2022\":\"\"}",
      "修改建议": "前后描述不一致，建议使用统一的描述方式",
      "更改后示例": "方式1.将.ts文件的后缀修改为.ets，并按ArkTS语法规则适配代码。",
      "触发条件": "同一文档中对文件后缀的表述存在带点（如.ets）与不带点（如ets）混用，且在相邻/相关语句中形成矛盾时触发。"
    },
    {
      "defect_id": 363266,
      "sentence": "当前，只有少数项目允许在运行时变更对象布局，一些常用的代码检查工具也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。",
      "reference_sentence": "当前，只有少数项目允许在运行时变更对象布局，一些常用的代码检查工具也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。",
      "line_num": 131,
      "context": "{\"126\":\"console.log('Distance between p5 and p6: ' + distance(p5, p6));\",\"127\":\"```\",\"128\":\"\",\"129\":\"修改对象布局会影响代码可读性和运行时性能。定义类后，在其他地方修改对象布局，容易引起困惑乃至引入错误。此外，还需要额外的运行时支持，增加执行开销。这与静态类型约束冲突：使用显式类型时，不应添加或删除属性。\",\"130\":\"\",\"131\":\"当前，只有少数项目允许在运行时变更对象布局，一些常用的代码检查工具也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。\",\"132\":\"\",\"133\":\"### 限制运算符的语义\",\"134\":\"\",\"135\":\"为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。详细的语义限制，请参考[约束说明](#约束说明)。\",\"136\":\"\"}",
      "修改建议": "混用了`项目`和`代码检查工具`，建议统一使用`项目`。",
      "更改后示例": "当前，只有少数项目允许在运行时变更对象布局，一些常用的项目也增加了相应的限制规则。这个约束只会导致少量代码重构，但会提升性能。",
      "触发条件": "同一段落或相邻句子中存在两个及以上不同术语指代同一实体，且上下文未明确其关联性差异时。  \n\n识别模式：  \n1. 核心术语冲突：当关键主体词（如\"项目\"和\"代码检查工具\"）在相近语境中交替出现，且未通过逻辑连接词（如\"例如\"\"包括\"）建立包含关系时  \n2. 功能指向重叠：不同术语描述的行为/功能高度相似（如案例中\"项目允许变更\"与\"工具增加规则\"均表达约束动作），但未通过说明性语句区分其角色差异时"
    },
    {
      "defect_id": 363054,
      "sentence": "对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替`new`表达式。",
      "reference_sentence": "可以使用关键字`new`创建实例：",
      "line_num": 1213,
      "context": "{\"1208\":\"}\",\"1209\":\"```\",\"1210\":\"\",\"1211\":\"### 对象字面量\",\"1212\":\"\",\"1213\":\"对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替`new`表达式。\",\"1214\":\"\",\"1215\":\"对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。\",\"1216\":\"\",\"1217\":\"```typescript\",\"1218\":\"class C {\"}",
      "修改建议": "混用了`new`和`new`表达式，建议统一使用`new`表达式",
      "更改后示例": "对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替`new`关键字。",
      "触发条件": "当同一术语在文档中存在多种表述形式（如\"new表达式\"与\"new关键字\"混用），且上下文存在明确的术语定义或统一用法（如参考句中的\"关键字`new`\"）时触发。\n\n识别模式：\n1. 检测技术术语是否包含具有相同核心词但修饰词冲突的变体（如\"new表达式\" vs \"new关键字\"）\n2. 交叉验证上下文是否存在明确的标准表述（如参考句中的\"关键字`new`\"）\n3. 检查技术动作描述中是否出现概念混淆（如将关键字本身与使用该关键字的表达式混为一谈）"
    },
    {
      "defect_id": 363306,
      "sentence": "### 不支持一些utility类型",
      "reference_sentence": "### 不支持一些utility类型",
      "line_num": 2920,
      "context": "{\"2915\":\"import * as M from 'file1'\",\"2916\":\"\",\"2917\":\"let x = M.abc;\",\"2918\":\"```\",\"2919\":\"\",\"2920\":\"### 不支持一些utility类型\",\"2921\":\"\",\"2922\":\"**规则：**`arkts-no-utility-types`\",\"2923\":\"\",\"2924\":\"**级别：错误**\",\"2925\":\"\"}",
      "修改建议": "句子中使用了小写的`utility`，而之前使用的是大写的`Utility`。",
      "更改后示例": "### 不支持一些Utility类型",
      "触发条件": "当同一术语在文档中存在大小写不一致（如`Utility`与`utility`混用），且上下文存在该术语已定义的标准形式时触发。识别需对比文档历史用词，检测术语大小写与先前定义或常规规范是否冲突。"
    },
    {
      "defect_id": 363544,
      "sentence": "可以将对象转换为Record类型，以便访问其属性。",
      "reference_sentence": "可以将对象转换为Record类型，以便访问其属性。",
      "line_num": 361,
      "context": "{\"356\":\"console.log(t.createController()!.value);\",\"357\":\"```\",\"358\":\"\",\"359\":\"## arkts-no-props-by-index\",\"360\":\"\",\"361\":\"可以将对象转换为Record类型，以便访问其属性。\",\"362\":\"\",\"363\":\"**应用代码**\",\"364\":\"\",\"365\":\"```typescript\",\"366\":\"function foo(params: Object) {\"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "将对象转换为Record类型，以便访问其属性。",
      "触发条件": "当文档中的指导性语句未使用祈使句结构（动词开头），且上下文属于操作步骤/规范要求时触发，特别是存在\"可以\"等情态动词的陈述句式。识别模式为检测到\"可以将...\"/\"应...\"等非祈使结构出现在技术操作说明段落中。"
    },
    {
      "defect_id": 363322,
      "sentence": "使用确定赋值断言符会增加运行时开销，应尽量避免使用。",
      "reference_sentence": "ArkTS不支持确定赋值断言，例如：`let v!: T`。改为在声明变量的同时为变量赋值。",
      "line_num": 3108,
      "context": "{\"3103\":\"\",\"3104\":\"在定义类时，如果无法在声明时或者构造函数中初始化某实例属性，那么可以使用确定赋值断言符`!`来消除`strictPropertyInitialization`的报错。\",\"3105\":\"\",\"3106\":\"使用确定赋值断言符会增加代码错误风险。开发者需确保实例属性在使用前已赋值，否则可能产生运行时异常。\",\"3107\":\"\",\"3108\":\"使用确定赋值断言符会增加运行时开销，应尽量避免使用。\",\"3109\":\"\",\"3110\":\"使用确定赋值断言符将产生`warning: arkts-no-definite-assignment`。\",\"3111\":\"\",\"3112\":\"**TypeScript**\",\"3113\":\"\"}",
      "修改建议": "前后文混用了确定赋值断言符的描述",
      "更改后示例": "使用确定赋值断言符会增加代码错误风险，应尽量避免使用。开发者需确保实例属性在使用前已赋值，否则可能产生运行时异常。",
      "触发条件": "同一术语在文档不同位置出现描述矛盾（如\"运行时开销\"与\"代码错误风险\"），或同一概念在原因/影响/建议维度存在表述不一致。  \n\n识别模式：通过术语关联性检测（如\"确定赋值断言符\"）比对上下文中的负面描述（如开销、错误、异常），当发现同一概念被不同负面因素解释时触发规则。"
    },
    {
      "defect_id": 363541,
      "sentence": "使用函数类型进行替代。",
      "reference_sentence": "使用函数类型进行替代。",
      "line_num": 121,
      "context": "{\"116\":\"}\",\"117\":\"```\",\"118\":\"\",\"119\":\"## arkts-no-call-signature\",\"120\":\"\",\"121\":\"使用函数类型进行替代。\",\"122\":\"\",\"123\":\"**应用代码**\",\"124\":\"\",\"125\":\"```typescript\",\"126\":\"interface I {\"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "使用函数类型替代。",
      "触发条件": "检测到技术文档中的建议或说明句未采用祈使句结构，且存在冗余助词（如\"进行\"\"加以\"）时触发。\n\n识别模式：通过句法分析识别动词短语结构，当发现\"使用+名词+进行+动词\"或类似非祈使句式，且上下文同类语句均采用\"动词+宾语\"的简洁祈使结构时，判定为表达不一致需修复。"
    },
    {
      "defect_id": 363268,
      "sentence": "采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。",
      "reference_sentence": "采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。",
      "line_num": 194,
      "context": "{\"189\":\"具体采用哪种方法，情况如下：\",\"190\":\"\",\"191\":\"- `T`和`U`没有继承关系或没有`implements`相同的接口，但由于它们具有相同的`public`API，它们“在某种程度上是相等的”，所以上述两个问题的答案都是“是”。\",\"192\":\"- `T`和`U`没有继承关系或没有`implements`相同的接口，应当始终被视为完全不同的类型，因此上述两个问题的答案都是“否”。\",\"193\":\"\",\"194\":\"采用第一种方法的语言支持structural typing，而采用第二种方法的语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。\",\"195\":\"\",\"196\":\"关于structural typing是否有助于生成清晰、易理解的代码，目前尚未有定论。ArkTS不支持structural typing的原因如下：\",\"197\":\"\",\"198\":\"因为对structural typing的支持是一个重大的特性，需要在语言规范、编译器和运行时进行大量的考虑和仔细的实现。另外，由于ArkTS使用静态类型，运行时为了支持这个特性需要额外的性能开销。\",\"199\":\"\"}",
      "修改建议": "混用了`方法`和`语言`，建议统一使用`语言`。",
      "更改后示例": "采用第一种语言支持structural typing，而采用第二种语言则不支持structural typing。目前TypeScript支持structural typing，而ArkTS不支持。",
      "触发条件": "同一段落或相邻句子中出现指代同一概念但使用不同术语（如\"方法\"和\"语言\"），且上下文存在明确对应关系时触发。\n\n识别模式：\n1. 检测相邻句子/并列结构中存在相同语法位置的关键词（如\"第一种X\"和\"第二种Y\"）\n2. 验证X/Y是否为同一语义层级的术语（如\"方法\"与\"语言\"属于不同抽象层级）\n3. 结合上下文判断是否存在明确的对应关系（如问题上下文189行明确将两种方法对应到语言特性）"
    },
    {
      "defect_id": 363542,
      "sentence": "使用Record类型进行替代。",
      "reference_sentence": "使用Record类型进行替代。",
      "line_num": 219,
      "context": "{\"214\":\"console.log(t.createController()!.value);\",\"215\":\"```\",\"216\":\"\",\"217\":\"## arkts-no-indexed-signatures\",\"218\":\"\",\"219\":\"使用Record类型进行替代。\",\"220\":\"\",\"221\":\"**应用代码**\",\"222\":\"\",\"223\":\"```typescript\",\"224\":\"function foo(data: { [key: string]: string }) {\"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "使用Record类型替代。",
      "触发条件": "当文档中的建议或规则条目存在句式冗余（如含“进行”等冗余动词结构）或未统一使用简洁祈使句时触发，需与上下文同类条目保持动词主导的指令结构一致。"
    },
    {
      "defect_id": 363669,
      "sentence": "删除忽略注释，为所有变量显式声明类型。",
      "reference_sentence": "ArkTS不支持通过注释的方式绕过严格类型检查。首先将注释（`// @ts-nocheck`或者`// @ts-ignore`）删去，再根据报错信息修改其他代码。",
      "line_num": 1990,
      "context": "{\"1985\":\"}\",\"1986\":\"```\",\"1987\":\"\",\"1988\":\"## arkts-strict-typing-required\",\"1989\":\"\",\"1990\":\"删除忽略注释，为所有变量显式声明类型。\",\"1991\":\"\",\"1992\":\"**应用代码**\",\"1993\":\"\",\"1994\":\"```typescript\",\"1995\":\"// @ts-nocheck\"}",
      "修改建议": "前后描述不一致，建议使用统一的描述方式",
      "更改后示例": "删除忽略注释，并为所有变量显式声明类型。",
      "触发条件": "当同一句子中存在两个及以上需要并列执行的操作指令，但缺乏统一连接词或语法结构不一致时触发。\n\n识别模式：1. 句子包含多个动宾结构的操作要求（如\"删除...\"和\"声明...\"） 2. 操作项之间使用逗号分隔但未使用并列连词（如\"并\"）衔接 3. 前后动词短语在语法结构上存在不对称性（如单动词 vs 介词短语）"
    },
    {
      "defect_id": 362900,
      "sentence": "ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。",
      "reference_sentence": "ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称 TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS简介\",\"2\":\"\",\"3\":\"ArkTS是OpenHarmony应用开发的官方高级语言。\",\"4\":\"\",\"5\":\"ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。\",\"6\":\"\",\"7\":\"ArkTS基础类库和容器类库增强了语言的基础功能，提供包括[高精度浮点运算](../reference/apis-arkts/js-apis-arkts-decimal.md)、[二进制Buffer](buffer.md)、[XML生成解析转换](xml-overview.md)和多种容器库等能力，协助开发者简化开发工作，提升开发效率。\",\"8\":\"\",\"9\":\"针对TS/JS并发能力支持有限的问题，ArkTS对并发编程API和能力进行了增强，提供了[TaskPool](taskpool-introduction.md)和[Worker](worker-introduction.md)两种并发API供开发者选择。另外，ArkTS进一步提出了Sendable的概念来支持对象在并发实例间的引用传递，提升ArkTS对象在并发实例间的通信性能。\",\"10\":\"\"}",
      "修改建议": "混用了'TS'和'TS'的缩写形式",
      "更改后示例": "ArkTS在[TypeScript](https://www.typescriptlang.org/)（简称 TS）生态基础上做了进一步扩展，保持了TS的基本风格，同时通过规范定义强化开发期静态检查和分析，提升代码健壮性，并实现更好的程序执行稳定性和性能。对比标准TS的差异可以参考[从TypeScript到ArkTS的适配规则](../quick-start/typescript-to-arkts-migration-guide.md)。ArkTS同时也支持与TS/JavaScript（简称JS）高效互操作。",
      "触发条件": "同一文档中术语缩写首次定义时存在空格使用不一致（例如\"简称TS\"与\"简称 JS\"共存），或同一术语在定义与后续使用中存在全称/缩写混用模式（如TypeScript首次定义为\"TS\"后文却出现全称）。  \n\n识别模式：  \n1. 检测括号内\"简称\"与缩写词之间的空格一致性（如\"简称TS\" vs \"简称 TS\"）  \n2. 对比首次定义缩写后的全称使用场景（如已定义TS为TypeScript缩写后，在非必要场景重复出现TypeScript全称）  \n3. 验证跨术语的格式统一性（如TS与JS的缩写定义是否采用相同空格规范）"
    },
    {
      "defect_id": 363099,
      "sentence": "不允许对注解使用任何其他形式的import/export，会发生编译报错。",
      "reference_sentence": "不允许对注解使用任何其他形式的import/export，会发生编译报错。",
      "line_num": 2035,
      "context": "{\"2030\":\"```\",\"2031\":\"- 不允许在import中对注解进行重命名。\",\"2032\":\"```typescript\",\"2033\":\"import { MyAnno as Anno } from './a'; // 编译错误：不允许在import中对注解进行重命名\",\"2034\":\"```\",\"2035\":\"不允许对注解使用任何其他形式的import/export，会发生编译报错。\",\"2036\":\"- 由于注解不是类型，因此禁止使用`type`符号进行导入和导出。\",\"2037\":\"```typescript\",\"2038\":\"import type { MyAnno } from './a'; // 编译错误：注解不允许使用'type'符号进行导入和导出\",\"2039\":\"```\",\"2040\":\"\"}",
      "修改建议": "前后表述不一致，'使用'与'使用其他形式'表意不同",
      "更改后示例": "不允许对注解使用其他形式的import/export，会发生编译报错。",
      "触发条件": "同一文档中相邻或相关规则条款存在修饰词（如\"任何\"）、动词结构（如\"使用其他形式\"）或强调范围不一致的情况，且影响表意准确性时触发。\n\n识别模式：1) 对比上下文相似规则句式，检测是否存在冗余限定词（如\"任何\"）或结构差异 2) 检查动词短语搭配是否统一（如\"使用\"与\"使用其他形式\"的语义冲突）3) 验证核心术语（如\"注解\"）的修饰方式是否保持连贯"
    },
    {
      "defect_id": 363545,
      "sentence": "所有泛型调用都应显式标注泛型参数类型，如 Map\\<string, T\\>、.map\\<T\\>()。",
      "reference_sentence": "所有泛型调用都应显式标注泛型参数类型，如 Map\\<string, T\\>、.map\\<T\\>()。",
      "line_num": 383,
      "context": "{\"378\":\"}\",\"379\":\"```\",\"380\":\"\",\"381\":\"## arkts-no-inferred-generic-params\",\"382\":\"\",\"383\":\"所有泛型调用都应显式标注泛型参数类型，如 Map\\\\<string, T\\\\>、.map\\\\<T\\\\>()。\",\"384\":\"\",\"385\":\"**应用代码**\",\"386\":\"\",\"387\":\"```typescript\",\"388\":\"class A {\"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "显式标注所有泛型调用的泛型参数类型，如 Map\\<string, T\\>、.map\\<T\\>()。",
      "触发条件": "当规则描述或建议中存在陈述句式（如含\"应\"字结构），但文档规范要求使用祈使句时触发；或同一文档中规则说明的句式与其他条目存在主谓结构与动宾结构混用的情况时触发。"
    },
    {
      "defect_id": 363307,
      "sentence": "### 不支持`as const`断言",
      "reference_sentence": "### 不支持`as const`断言",
      "line_num": 2965,
      "context": "{\"2960\":\"**错误码：10605140**\",\"2961\":\"\",\"2962\":\"ArkTS禁用标准库函数`Function.bind`。标准库使用这些函数显式设置被调用函数的`this`参数。在ArkTS中，`this`仅限于传统OOP风格，函数体中禁用使用`this`。\",\"2963\":\"\",\"2964\":\"\",\"2965\":\"### 不支持`as const`断言\",\"2966\":\"\",\"2967\":\"**规则：**`arkts-no-as-const`\",\"2968\":\"\",\"2969\":\"**级别：错误**\",\"2970\":\"\"}",
      "修改建议": "句子中使用了小写的`const`，而之前使用的是大写的`Const`。",
      "更改后示例": "### 不支持`as Const`断言",
      "触发条件": "同一文档中同一术语或代码元素的大小写形式与上下文或参考实例不一致（例如，之前使用大写的`Const`，后续出现小写的`const`）。"
    },
    {
      "defect_id": 363742,
      "sentence": "建议使用参数传递函数外的变量替代。",
      "reference_sentence": "建议使用参数传递函数外部的变量，以替代使用闭包。",
      "line_num": 98,
      "context": "{\"93\":\"}\",\"94\":\"\",\"95\":\"foo();\",\"96\":\"```\",\"97\":\"\",\"98\":\"建议使用参数传递函数外部的变量，以替代使用闭包。\",\"99\":\"``` TypeScript\",\"100\":\"let arr = [0, 1, 2];\",\"101\":\"\",\"102\":\"function foo(array: number[]): number {\",\"103\":\"  return array[0] + array[1];\"}",
      "修改建议": "重复描述了相同的内容，导致句式不一致。建议使用一致的祈使句。",
      "更改后示例": "使用参数传递函数外部的变量，以替代使用闭包。",
      "触发条件": "同一段落或相邻建议句中出现重复内容但句式结构不一致（如陈述句与祈使句混用），或相同语义表达存在术语/连接词不统一（如\"外\"与\"外部\"、\"替代\"与\"以替代\"）。"
    },
    {
      "defect_id": 368036,
      "sentence": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。",
      "reference_sentence": "[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。",
      "line_num": 48,
      "context": "{\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\",\"47\":\"\",\"48\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\",\"52\":\"HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"53\":\"\"}",
      "修改建议": "用词不一致，'value'应改为'值'；'key-value键值对'应改为'键值对'",
      "更改后示例": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中值是唯一的。",
      "触发条件": "当同一术语在相邻上下文或参考示例中存在中英文混用（如\"value\"与\"值\"交替出现），或与已定义的标准化表述（如\"键值对\"）不一致时。"
    },
    {
      "defect_id": 367654,
      "sentence": "一般符合先进先出的场景可以使用Queue。",
      "reference_sentence": "需要频繁的插入删除元素，并且需要使用双向链表时，推荐使用LinkedList高效操作。",
      "line_num": 135,
      "context": "{\"130\":\"\",\"131\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"132\":\"\",\"133\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"134\":\"\",\"135\":\"一般符合先进先出的场景可以使用Queue。\",\"136\":\"\",\"137\":\"Queue支持增、删、改、查操作，常用API如下：\",\"138\":\"\",\"139\":\"| 操作 | 方法 | 描述 |\",\"140\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "混用了'可以使用'与'推荐使用'，导致用词不一致。",
      "更改后示例": "一般符合先进先出的场景推荐使用Queue。",
      "触发条件": "当同一文档或上下文中出现相同/相似语境下使用不一致的建议动词（如\"可以\"与\"推荐\"混用）时触发，需统一为同一建议强度表述。"
    },
    {
      "defect_id": 367652,
      "sentence": "Queue依据泛型定义，存储位置必须是连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。",
      "reference_sentence": "Deque依据泛型定义，要求存储位置为连续的内存空间，其初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。",
      "line_num": 129,
      "context": "{\"124\":\"\",\"125\":\"## Queue\",\"126\":\"\",\"127\":\"[Queue](../reference/apis-arkts/js-apis-queue.md)可用来构造队列对象，存储元素遵循先进先出的规则。\",\"128\":\"\",\"129\":\"Queue依据泛型定义，存储位置必须是连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。\",\"130\":\"\",\"131\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"132\":\"\",\"133\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"134\":\"\"}",
      "修改建议": "混用了'必须是'与'要求'，以及'存储位置'与'存储位置为'，导致用词不一致。",
      "更改后示例": "Queue依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。",
      "触发条件": "同一文档中出现相同概念使用不一致的强制性表述（如\"必须\"/\"要求\"混用）或存在冗余/缺失的语法结构（如\"存储位置必须是\"与\"存储位置为\"句式不匹配），且上下文存在可供对齐的参考表达（如相邻的Deque描述句式）时触发。"
    },
    {
      "defect_id": 367684,
      "sentence": "此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：",
      "reference_sentence": "Vector支持增、删、改、查操作，常用API如下：",
      "line_num": 206,
      "context": "{\"201\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"202\":\"| 删除元素 | removeByRange(fromIndex:number,toIndex:number) | 删除指定范围内的元素。 |\",\"203\":\"\",\"204\":\"## 线性容器的使用\",\"205\":\"\",\"206\":\"此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：\",\"207\":\"\",\"208\":\"\",\"209\":\"```ts\",\"210\":\"// ArrayList\",\"211\":\"import { ArrayList } from '@kit.ArkTS'; // 导入ArrayList模块\"}",
      "修改建议": "混用了'增加、访问、修改'和'增加元素、访问元素及修改'的表述",
      "更改后示例": "此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改元素等操作。示例代码如下所示：",
      "触发条件": "当同一句子或相邻上下文中存在并列的动词短语/动宾结构时，若出现部分短语带宾语、部分不带宾语的混合表述（如\"增加元素、访问元素及修改\"），则触发该规则。\n\n识别模式：通过检测并列连词（如\"及\"\"、\"等）连接的短语结构一致性，识别出同一语义场景下\"动词+宾语\"与\"单独动词\"混用的情况（如\"增加元素、访问元素及修改\"中前两项带宾语、末项无宾语）。"
    },
    {
      "defect_id": 365968,
      "sentence": "如果配置了transformLib且对应的动态库文件能正确加载，编译器将先生成方舟字节码文件到默认目标位置，然后调用动态库中的Transform方法，并将方舟字节码文件的路径作为参数传入。Transform方法包含开发者自定义的修改逻辑，用于重新生成方舟字节码文件，同时更新字节码文件的落盘操作是由用户执行。",
      "reference_sentence": "方舟字节码（ArkCompiler Bytecode）文件，是ArkCompiler的编译工具链以源代码作为输入编译生成的产物，其文件后缀名为.abc。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。\",\"8\":\"\",\"9\":\"## 能力执行机制\",\"10\":\"\",\"11\":\"如果配置了transformLib且对应的动态库文件能正确加载，编译器将先生成方舟字节码文件到默认目标位置，然后调用动态库中的Transform方法，并将方舟字节码文件的路径作为参数传入。Transform方法包含开发者自定义的修改逻辑，用于重新生成方舟字节码文件，同时更新字节码文件的落盘操作是由用户执行。\",\"12\":\"\",\"13\":\"下面是一个动态库的模板，开发者可根据需求实现Transform的具体逻辑。\",\"14\":\"\",\"15\":\"## 开发示例\",\"16\":\"\"}",
      "修改建议": "混用了“方舟字节码文件”和“方舟字节码”概念",
      "更改后示例": "如果配置了transformLib且对应的动态库文件能正确加载，编译器将先生成方舟字节码到默认目标位置，然后调用动态库中的Transform方法，并将方舟字节码的路径作为参数传入。Transform方法包含开发者自定义的修改逻辑，用于重新生成方舟字节码，同时更新字节码的落盘操作是由用户执行。",
      "触发条件": "同一术语在相邻或同一段落中多次出现时，存在全称（如“方舟字节码文件”）与简称（如“方舟字节码”）混用的情况。\n\n识别模式：\n1. 核心术语检查：通过标点符号（如括号、句号）分割相邻句子，检测核心名词（如“方舟字节码”）是否出现冗余修饰词（如“文件”）的增减变化；\n2. 上下文验证：结合参考句子的定义（如“.abc文件”已隐含“文件”属性）和问题上下文（如段落7已完整使用“方舟字节码文件”），判断后续描述是否可省略冗余修饰词；\n3. 语义等价判断：当“字节码文件”与“字节码”在相同操作场景（如路径传递、落盘操作）中出现时，识别是否指向同一实体。"
    },
    {
      "defect_id": 368039,
      "sentence": "[TreeMap](../reference/apis-arkts/js-apis-treemap.md)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。",
      "reference_sentence": "[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。",
      "line_num": 71,
      "context": "{\"66\":\"| 删除元素 | remove(value: T) | 删除set中匹配到的值。 |\",\"67\":\"| 删除元素 | clear() | 清空整个set。 |\",\"68\":\"\",\"69\":\"## TreeMap\",\"70\":\"\",\"71\":\"[TreeMap](../reference/apis-arkts/js-apis-treemap.md)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。\",\"72\":\"\",\"73\":\"TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。\",\"74\":\"\",\"75\":\"TreeMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"76\":\"\"}",
      "修改建议": "用词不一致，'用于'应改为'可用来'",
      "更改后示例": "[TreeMap](../reference/apis-arkts/js-apis-treemap.md)可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，每个key对应一个value值。",
      "触发条件": "当同一文档的相邻功能模块（如TreeMap与HashMap）或相同语义场景中，存在描述相同操作/用途但用词不一致（如\"用于\"与\"可用来\"混用）时触发。  \n识别模式：通过对比相邻条目或同类API的句式结构（如\"[类名]+[动词]+存储...\"），检测动词/短语是否与参考句式的标准表达（如\"可用来\"）严格匹配。"
    },
    {
      "defect_id": 367656,
      "sentence": "Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue基于循环队列实现，只能在头部删除元素，尾部增加元素，而Stack都在一端操作。",
      "reference_sentence": "Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。",
      "line_num": 155,
      "context": "{\"150\":\"\",\"151\":\"[Stack](../reference/apis-arkts/js-apis-stack.md)可用来构造栈对象，存储元素遵循先进后出的规则。\",\"152\":\"\",\"153\":\"Stack依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的1.5倍。Stack底层基于数组实现，入栈和出栈操作均在数组的一端进行。\",\"154\":\"\",\"155\":\"Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue基于循环队列实现，只能在头部删除元素，尾部增加元素，而Stack都在一端操作。\",\"156\":\"\",\"157\":\"一般符合先进后出的场景可以使用Stack。\",\"158\":\"\",\"159\":\"Stack支持增、删、改、查操作，常用API如下：\",\"160\":\"\"}",
      "修改建议": "混用了'只能在头部删除元素，尾部增加元素'与'仅支持在头部删除元素，尾部增加元素'，以及'都在一端操作'与'在一端操作'，导致用词不一致。",
      "更改后示例": "Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue仅支持在头部删除元素，尾部增加元素，而Stack在一端操作。",
      "触发条件": "在同一上下文或相邻句子中，描述同类操作时混用了不同限制性动词（如\"只能\"与\"仅支持\"）或存在结构不对称（如\"都在一端\"与\"在一端\"），且在对比场景下未保持表达方式统一。"
    },
    {
      "defect_id": 366007,
      "sentence": "使用Disassembler反汇编工具将字节数据反汇编成可阅读的汇编指令。",
      "reference_sentence": "使用Disassembler反汇编工具将字节数据反汇编成可阅读的汇编指令。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"4. 字节码编译：使用方舟编译器生成方舟字节码文件（\\\\*.abc）。\",\"16\":\"\",\"17\":\"5. 自定义修改方舟字节码：提供开发者修改字节码能力的入口，在字节码编译落盘前调用。\",\"18\":\"\",\"19\":\"6. 反汇编：使用Disassembler反汇编工具将字节数据反汇编成可阅读的汇编指令。\",\"20\":\"\",\"21\":\"ArkTS编译工具链在构建hap流程参考下图：\",\"22\":\"\",\"23\":\"![compilation-tool-overview](figures/compilation-tool-overview.png)\",\"24\":\"\"}",
      "修改建议": "建议使用“使用Disassembler反汇编工具将字节数据反汇编成可读的汇编指令”以保持句式一致。",
      "更改后示例": "使用Disassembler反汇编工具将字节数据反汇编成可读的汇编指令。",
      "触发条件": "当相邻步骤或同一列表项中出现相同句式结构但关键形容词/短语不一致（如\"可读\"与\"可阅读\"），且上下文存在统一表达范式时触发。\n\n识别模式：\n1. 结构匹配：检测\"将...反汇编成可[X]的...\"句式在相邻步骤中的重复出现\n2. 用词冲突：识别同一功能描述中形容词短语的形态差异（如双字词\"可读\"与三字词\"可阅读\"）\n3. 上下文验证：检查前序步骤（如步骤4/5）是否已建立\"可读\"的标准化表达范式"
    },
    {
      "defect_id": 367992,
      "sentence": "存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。",
      "reference_sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。",
      "line_num": 20,
      "context": "{\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\",\"21\":\"\",\"22\":\"HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。\",\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\"}",
      "修改建议": "混用了`key-value`和`键值对`概念",
      "更改后示例": "存储具有关联关系的键值对集合，存储元素中键是唯一的，每个键会对应一个值。",
      "触发条件": "同一术语在相邻上下文或同一文档中存在中英文混用（如同时出现\"key\"/\"键\"或\"value\"/\"值\"），且存在明确的中文术语使用惯例（如参考句已使用\"键值对\"统一表达）。"
    },
    {
      "defect_id": 363745,
      "sentence": "创建异常时会构造异常的栈帧，造成性能损耗。",
      "reference_sentence": "创建异常时会构造异常的栈帧，造成性能损耗。",
      "line_num": 195,
      "context": "{\"190\":\"\",\"191\":\"## 异常\",\"192\":\"\",\"193\":\"### 避免频繁抛出异常\",\"194\":\"\",\"195\":\"创建异常时会构造异常的栈帧，造成性能损耗。在性能敏感场景下，如`for`循环语句中，应避免频繁抛出异常。\",\"196\":\"\",\"197\":\"优化前的代码示例：\",\"198\":\"\",\"199\":\"``` TypeScript\",\"200\":\"function div(a: number, b: number): number {\"}",
      "修改建议": "句子较长，建议拆分为短句，使句式一致。",
      "更改后示例": "创建异常时会构造异常的栈帧。这会导致性能损耗。",
      "触发条件": "句子采用复合句式（如逗号连接多个分句）且上下文存在短句表达模式时触发；当分句间逻辑关系为因果/承接且未使用句式统一结构时触发。\n\n识别模式：检测长句是否包含两个及以上独立语义单元（如\"构造栈帧\"和\"性能损耗\"），同时检查相邻段落（如问题上下文195行后续说明句）是否采用分句隔离的短句结构，通过句式对比识别表达风格不一致。"
    },
    {
      "defect_id": 367680,
      "sentence": "Vector支持增、删、改、查操作，常用API如下：",
      "reference_sentence": "Queue支持增、删、改、查操作，常用API如下：",
      "line_num": 182,
      "context": "{\"177\":\"\",\"178\":\"[Vector](../reference/apis-arkts/js-apis-vector.md)是指连续存储结构，用来构造全局的数组对象。Vector依据泛型定义，要求存储位置是为连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容为原始容量的2倍。\",\"179\":\"\",\"180\":\"Vector和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector支持操作符访问，并增加了get/set接口，提供更完善的校验及容错机制，满足用户不同场景的需求。\",\"181\":\"\",\"182\":\"Vector支持增、删、改、查操作，常用API如下：\",\"183\":\"\",\"184\":\"| 操作 | 方法 | 描述 |\",\"185\":\"| --------- | ------- | ------- |\",\"186\":\"| 增加元素 | add(element: T) | 在数组尾部增加一个元素。 |\",\"187\":\"| 增加元素 | insert(element: T, index: number) | 在指定位置插入一个元素。 |\"}",
      "修改建议": "混用了'增、删、改、查'和'增加、删除、修改、访问'的表述",
      "更改后示例": "Vector支持增加、删除、修改、访问操作，常用API如下：",
      "触发条件": "当同一文档中混用动词的缩略形式（单字）与完整形式（双字）描述同类操作，且相邻上下文存在一致性表达范例时触发。\n\n识别模式：通过检测并列动词短语中单双字混用现象（如\"增/增加\"、\"查/访问\"），结合上下文相似功能模块的表达一致性（如参考句中的\"增、删、改、查\"统一模式），识别术语表述不匹配问题。"
    },
    {
      "defect_id": 367997,
      "sentence": "| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |",
      "reference_sentence": "| 修改元素 | replace(key: K, newValue: V) | 修改指定键对应的值。 |",
      "line_num": 41,
      "context": "{\"36\":\"| 访问元素 | keys() | 返回一个迭代器对象，包含map中的所有key值。 |\",\"37\":\"| 访问元素 | values() | 返回一个迭代器对象，包含map中的所有value值。 |\",\"38\":\"| 访问元素 | entries() | 返回一个迭代器对象，包含map中的所有键值对。 |\",\"39\":\"| 访问元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 遍历访问整个map的元素。 |\",\"40\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;[K,V]&gt; | 创建迭代器以访问数据。 |\",\"41\":\"| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |\",\"42\":\"| 修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 通过遍历修改整个map的元素。 |\",\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\"}",
      "修改建议": "混用了`key`和`键`概念",
      "更改后示例": "| 修改元素 | replace(key: K, newValue: V) | 修改指定键对应的值。 |",
      "触发条件": "同一术语在中文翻译和英文原词之间出现混用（如\"key\"和\"键\"交替出现），且上下文存在统一用词标准（如相邻条目使用\"键值对\"等规范表达）时触发。\n\n识别模式：\n1. 检测技术术语存在中英双版本表达（如key/键、value/值）\n2. 比对上下文相邻条目（如问题句所在表格的上下行）的用词习惯\n3. 验证参数名与描述文本的对应关系（如方法签名使用英文参数名key，但中文描述应统一使用\"键\"）"
    },
    {
      "defect_id": 367995,
      "sentence": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。",
      "reference_sentence": "存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。",
      "line_num": 26,
      "context": "{\"21\":\"\",\"22\":\"HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。\",\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\",\"26\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。\",\"27\":\"\",\"28\":\"需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。\",\"29\":\"\",\"30\":\"HashMap支持增、删、改、查操作，常用API如下：\",\"31\":\"\"}",
      "修改建议": "混用了`key`和`值`概念",
      "更改后示例": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由键、值两个值组成。在HashSet中，只处理值对象。",
      "触发条件": "同一技术术语在相邻上下文或同一句子中存在中英文混用（如key/键、value/值），或与文档已定义的标准术语（如参考句中的\"值\"）产生概念表述冲突时触发。"
    },
    {
      "defect_id": 366006,
      "sentence": "提供开发者修改字节码能力的入口，在字节码编译落盘前调用。",
      "reference_sentence": "提供开发者修改字节码能力的入口，在字节码编译落盘前调用。",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"3. 源码混淆：使用ArkGuard源码混淆工具对源码进行混淆，开发者可根据业务需要选择开启。\",\"14\":\"\",\"15\":\"4. 字节码编译：使用方舟编译器生成方舟字节码文件（\\\\*.abc）。\",\"16\":\"\",\"17\":\"5. 自定义修改方舟字节码：提供开发者修改字节码能力的入口，在字节码编译落盘前调用。\",\"18\":\"\",\"19\":\"6. 反汇编：使用Disassembler反汇编工具将字节数据反汇编成可阅读的汇编指令。\",\"20\":\"\",\"21\":\"ArkTS编译工具链在构建hap流程参考下图：\",\"22\":\"\"}",
      "修改建议": "建议使用“提供开发者修改字节码的能力入口”以保持句式一致。",
      "更改后示例": "提供开发者修改字节码的能力入口，在字节码编译落盘前调用。",
      "触发条件": "同一列表或段落中存在多个相同句式结构（如动宾短语），但当前句子在相同语义下出现名词修饰顺序不一致（如\"能力的入口\"与\"能力入口\"结构差异）。"
    },
    {
      "defect_id": 365966,
      "sentence": "开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。",
      "reference_sentence": "方舟字节码（ArkCompiler Bytecode）文件，是ArkCompiler的编译工具链以源代码作为输入编译生成的产物，其文件后缀名为.abc。",
      "line_num": 3,
      "context": "{\"1\":\"# 编译期自定义修改方舟字节码\",\"2\":\"\",\"3\":\"开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。\",\"4\":\"\",\"5\":\"## 能力配置说明\",\"6\":\"\",\"7\":\"准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。\",\"8\":\"\"}",
      "修改建议": "混用了“方舟字节码文件”和“方舟字节码”概念",
      "更改后示例": "开发者如果希望自定义修改方舟字节码的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码能力。",
      "触发条件": "同一术语在相邻上下文中存在冗余限定词（如\"文件\"）与核心概念（如\"字节码\"）混用，且参考定义已明确二者层级关系（如\".abc文件是字节码的载体\"）。\n\n识别模式：检测同一段落内是否交替出现\"X\"与\"X文件\"表述，同时结合术语定义判断是否违反\"抽象概念（字节码）\"与\"实体对象（字节码文件）\"的区分原则。当操作对象实质为数据内容而非文件实体时，应删除冗余的\"文件\"限定词。"
    },
    {
      "defect_id": 367996,
      "sentence": "需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。",
      "reference_sentence": "需要快速存取、插入删除键值对数据时推荐使用。",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\",\"26\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。\",\"27\":\"\",\"28\":\"需要快速存取、删除以及插入键值对数据时，推荐使用HashMap。\",\"29\":\"\",\"30\":\"HashMap支持增、删、改、查操作，常用API如下：\",\"31\":\"\",\"32\":\"| 操作 | 方法 | 描述 |\",\"33\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "混用了`删除`和`插入删除`概念",
      "更改后示例": "需要快速存取、插入删除键值对数据时，推荐使用HashMap。",
      "触发条件": "当同一组操作动词在相邻上下文中出现顺序不一致（如\"删除、插入\"与\"插入删除\"）或分合表达不统一（如单独使用\"删除\"与合并使用\"插入删除\"）时触发。"
    },
    {
      "defect_id": 367653,
      "sentence": "Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。",
      "reference_sentence": "Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。",
      "line_num": 133,
      "context": "{\"128\":\"\",\"129\":\"Queue依据泛型定义，存储位置必须是连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。\",\"130\":\"\",\"131\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"132\":\"\",\"133\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"134\":\"\",\"135\":\"一般符合先进先出的场景可以使用Queue。\",\"136\":\"\",\"137\":\"Queue支持增、删、改、查操作，常用API如下：\",\"138\":\"\"}",
      "修改建议": "混用了'一端删除一端增加'与'头部删除元素，尾部增加元素'，以及'增删'与'增删操作'，导致用词不一致。",
      "更改后示例": "Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue仅支持在头部删除元素，尾部增加元素，而Deque支持两端增删操作。",
      "触发条件": "同一段落或相邻句子中对同一概念使用不一致的术语（如\"一端删除\"与\"头部删除元素\"）或动作描述结构（如\"增删\"与\"增删操作\"），且上下文存在可参照的统一表达方式时触发。\n\n识别模式：\n1. 对比同一功能描述的动词结构（如\"增删\"是否应补全为\"增删操作\"）\n2. 检查位置描述是否统一（如\"一端\"是否应具体化为\"头部/尾部\"）\n3. 验证相邻句子是否存在已确立的标准表达（如参考句中的\"头部删除元素，尾部增加元素\"结构）"
    },
    {
      "defect_id": 368038,
      "sentence": "HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。",
      "reference_sentence": "HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。",
      "line_num": 52,
      "context": "{\"47\":\"\",\"48\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\",\"52\":\"HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"53\":\"\",\"54\":\"可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。\",\"55\":\"\",\"56\":\"HashSet支持增、删、改、查操作，常用API如下：\",\"57\":\"\"}",
      "修改建议": "用词不一致，'存取'应改为'存储'",
      "更改后示例": "HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存储，不支持用户指定排序方式，而TreeSet中的数据有序存储，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。",
      "触发条件": "同一文档中对相同操作或概念使用不同动词表述（如\"存放\"与\"存储\"混用），且上下文存在已确立的标准用词（如\"存储\"）时触发。\n\n识别模式：\n1. 在相邻段落或同一技术描述场景中检测同义动词（如存放/存储、存取/访问）\n2. 对比文档其他部分的用词惯例（如上下文48行\"存储元素\"、50行\"存储位置\"已确立\"存储\"为规范用词）\n3. 验证参考句中的术语使用模式（如\"存取数据\"与\"有序存取\"保持动词一致性）"
    },
    {
      "defect_id": 367993,
      "sentence": "HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "reference_sentence": "HashMap依据泛型定义，集合中通过键的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于哈希表实现，冲突策略采用链地址法。",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\",\"21\":\"\",\"22\":\"HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。\",\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\",\"26\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。\",\"27\":\"\"}",
      "修改建议": "混用了`key`和`键`概念，以及`HashTable`和`哈希表`概念",
      "更改后示例": "HashMap依据泛型定义，集合中通过键的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于哈希表实现，冲突策略采用链地址法。",
      "触发条件": "同一术语在相邻上下文中存在中文/英文混用（如\"key\"与\"键\"）或不同译法变体（如\"HashTable\"与\"哈希表\"），且上下文已有标准化表达形式时触发。\n\n识别模式：\n1. 检测相邻段落（±3行）或同文档其他位置是否已存在同一概念的标准化术语（如上下文第20/24行已使用\"键\"）\n2. 对比专业术语中英文形式一致性（如Java标准术语应统一为\"哈希表\"而非\"HashTable\"）\n3. 验证技术名词大小写规范（如\"HashTable\"应为小写开头的\"哈希表\"）"
    },
    {
      "defect_id": 365971,
      "sentence": "3. 在DevEco Studio中配置build-profile.json5的transformLib选项（以windows环境为例）。",
      "reference_sentence": "方舟字节码（ArkCompiler Bytecode）文件，是ArkCompiler的编译工具链以源代码作为输入编译生成的产物，其文件后缀名为.abc。",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"   ```\",\"50\":\"   g++ --shared -o example.so example.cpp\",\"51\":\"   ```\",\"52\":\"\",\"53\":\"3. 在DevEco Studio中配置build-profile.json5的transformLib选项（以windows环境为例）。\",\"54\":\"\",\"55\":\"   选项中配置的路径为步骤2生成的链接库文件在项目中的路径（这里是dll目录下）。\",\"56\":\"\",\"57\":\"   ![zh-cn_image_0000002079773605](figures/zh-cn_image_0000002079773605.png)\",\"58\":\"\"}",
      "修改建议": "混用了“方舟字节码文件”和“方舟字节码”概念",
      "更改后示例": "3. 在DevEco Studio中配置build-profile.json5的transformLib选项（以Windows环境为例）。",
      "触发条件": "检测到专有名词（如Windows操作系统）或已定义术语（如方舟字节码）的大小写形式与标准用法或上下文中的统一表达不一致。例如：操作系统名称未使用首字母大写，或同一概念存在全称/简称混用（如\"ArkCompiler Bytecode\"与\"方舟字节码\"需保持对应关系）。"
    },
    {
      "defect_id": 368079,
      "sentence": "当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。",
      "reference_sentence": "LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值的集合，LightWeightSet占用内存更小。",
      "line_num": 165,
      "context": "{\"160\":\"\",\"161\":\"LightWeightSet底层通过hash实现唯一value的标识，冲突策略采用线性探测法，查找策略基于二分查找法。\",\"162\":\"\",\"163\":\"LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值的集合，LightWeightSet占用内存更小。\",\"164\":\"\",\"165\":\"当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。\",\"166\":\"\",\"167\":\"LightWeightSet支持增、删、改、查操作，常用API如下：\",\"168\":\"\",\"169\":\"| 操作 | 方法 | 描述 |\",\"170\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "前后句子中对LightWeightSet功能的描述不一致，前文提到'存储键值的集合'，后文提到'存取某个集合或是对某个集合去重'。",
      "更改后示例": "当需要存取唯一的值或对集合去重时，推荐使用占用内存更小的LightWeightSet。",
      "触发条件": "当同一功能或概念在相邻段落中存在术语不一致（如\"键值\" vs \"集合\"）或操作目的描述矛盾（如\"存储\" vs \"去重\"）时触发。\n\n识别模式：\n1. 对比当前句子与上下文中的核心概念表述（如通过共现的API名称\"LightWeightSet\"建立关联）\n2. 检测关键术语一致性（如\"存储键值\" vs \"存取集合\"）\n3. 验证操作目的匹配度（前文强调\"唯一value标识\"，后文应保持\"唯一值\"表述）"
    },
    {
      "defect_id": 367681,
      "sentence": "删除第一个匹配到的元素。",
      "reference_sentence": "对队首元素进行出队操作并删除。",
      "line_num": 200,
      "context": "{\"195\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"196\":\"| 修改元素 | set(index:number, element: T) | 修改指定index位置的元素值为element。 |\",\"197\":\"| 修改元素 | vec[index] = element | 修改指定index位置的元素值为element。 |\",\"198\":\"| 修改元素 | replaceAllElements(callbackFn: (value: T, index?: number, vector?: Vector&lt;T&gt;) => T, thisArg?: Object) | 逐个替换Vector内的元素。|\",\"199\":\"| 修改元素 | setLength(newSize:number) | 设置Vector的长度大小。 |\",\"200\":\"| 删除元素 | remove(element: T) | 删除第一个匹配到的元素。 |\",\"201\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"202\":\"| 删除元素 | removeByRange(fromIndex:number,toIndex:number) | 删除指定范围内的元素。 |\",\"203\":\"\",\"204\":\"## 线性容器的使用\",\"205\":\"\"}",
      "修改建议": "混用了'删除'和'移除'的表述",
      "更改后示例": "移除第一个匹配到的元素。",
      "触发条件": "同一功能模块或相邻上下文中，相同操作使用了不同动词（如“删除”与“移除”），且存在已统一的参考表述（如其他同类方法描述或文档规范）。"
    },
    {
      "defect_id": 367657,
      "sentence": "Vector依据泛型定义，要求存储位置是为连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容为原始容量的2倍。",
      "reference_sentence": "Queue依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。",
      "line_num": 178,
      "context": "{\"173\":\"\",\"174\":\"> **说明**：\",\"175\":\">\",\"176\":\"> API version 9开始，该接口不再维护，推荐使用[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)。\",\"177\":\"\",\"178\":\"[Vector](../reference/apis-arkts/js-apis-vector.md)是指连续存储结构，用来构造全局的数组对象。Vector依据泛型定义，要求存储位置是为连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容为原始容量的2倍。\",\"179\":\"\",\"180\":\"Vector和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector支持操作符访问，并增加了get/set接口，提供更完善的校验及容错机制，满足用户不同场景的需求。\",\"181\":\"\",\"182\":\"Vector支持增、删、改、查操作，常用API如下：\",\"183\":\"\"}",
      "修改建议": "混用了'要求存储位置是为'与'要求存储位置为'，以及'初始容量大小为10'与'初始容量大小为8'，导致用词不一致。",
      "更改后示例": "Vector依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容为原始容量的2倍。",
      "触发条件": "当同一术语或结构在文档不同位置出现介词混用（如\"是为\"与\"为\"）或数值矛盾（如\"10\"与\"8\"），且上下文存在同类描述作为参照时触发。识别模式需检测邻近段落中相同语法结构的介词统一性及关键数值的一致性。"
    },
    {
      "defect_id": 368037,
      "sentence": "HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。",
      "reference_sentence": "HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "line_num": 50,
      "context": "{\"45\":\"\",\"46\":\"## HashSet\",\"47\":\"\",\"48\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\",\"52\":\"HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"53\":\"\",\"54\":\"可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。\",\"55\":\"\"}",
      "修改建议": "用词不一致，'value'应改为'值'；'key的hash值'应改为'hash值'",
      "更改后示例": "HashSet依据泛型定义，集合中通过值的hash值确定其存储位置，从而快速找到该值。HashSet的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。值的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对值对象进行处理。底层数据结构与HashMap一致。",
      "触发条件": "同一术语存在中英文混用（如\"value\"与\"值\"交替出现），或相邻上下文存在关联术语不对称（如HashMap用\"key\"对应HashSet用\"值\"但未保持对称）时触发。\n\n识别模式：\n1. 术语形态检测：识别同一概念存在全中文/全英文/简写混合形态（如\"value\"与\"值\"）\n2. 对称性检测：对比相邻数据结构描述（如HashMap与HashSet），验证关联术语是否保持对称（如HashMap的\"key\"对应HashSet的\"值\"）\n3. 跨段落一致性：检查同一文档中相同技术概念是否保持统一表达形式（如全篇应统一用\"hash值\"而非\"hash值\"与\"哈希值\"混用）"
    },
    {
      "defect_id": 368040,
      "sentence": "TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。",
      "reference_sentence": "HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "line_num": 73,
      "context": "{\"68\":\"\",\"69\":\"## TreeMap\",\"70\":\"\",\"71\":\"[TreeMap](../reference/apis-arkts/js-apis-treemap.md)用于存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key对应一个value值。\",\"72\":\"\",\"73\":\"TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。\",\"74\":\"\",\"75\":\"TreeMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"76\":\"\",\"77\":\"一般需要存储有序键值对的场景，可以使用TreeMap。\",\"78\":\"\"}",
      "修改建议": "用词不一致，'key的类型'应改为'键的类型'",
      "更改后示例": "TreeMap依据泛型定义，键是有序存储的。底层基于红黑树实现，支持快速的插入和删除，键的类型满足ECMA标准。",
      "触发条件": "同一术语在同一段落或相邻上下文中出现中英文混用（如\"key\"与\"键\"交替出现），且存在已确立的中文术语参考（如参考句中的\"键\"持续使用）。"
    },
    {
      "defect_id": 363744,
      "sentence": "根据业务需求，将相同类型的数据放在同一数组中。",
      "reference_sentence": "根据业务需求，将相同类型的数据放在同一数组中。",
      "line_num": 183,
      "context": "{\"178\":\"let arrNum: number[] = [1, 1.1, 2];  // 数值数组中混合使用整型数据和浮点型数据\",\"179\":\"\",\"180\":\"let arrUnion: (number | string)[] = [1, 'hello'];  // 联合类型数组\",\"181\":\"```\",\"182\":\"\",\"183\":\"根据业务需求，将相同类型的数据放在同一数组中。  \",\"184\":\"``` TypeScript\",\"185\":\"let arrInt: number[] = [1, 2, 3];\",\"186\":\"let arrDouble: number[] = [0.1, 0.2, 0.3];\",\"187\":\"let arrString: string[] = ['hello', 'world'];\",\"188\":\"```\"}",
      "修改建议": "句子较长，建议拆分为短句，使句式一致。",
      "更改后示例": "根据业务需求，将相同类型的数据放在同一数组中。这样可以避免数组中混合不同类型的数据。",
      "触发条件": "当文档中相邻的说明性句子存在句式结构不一致（如长句与短句混杂），或同一段落内出现复合句与简单句混合影响阅读节奏时触发。\n\n识别模式：通过检测相邻句子的标点数量（如原句缺少分号/句号拆分）、谓语动词密度（如\"这样可以...\"属于解释性从句），以及上下文句式对比（如代码示例前的说明均使用单句结构）来识别需要拆分的复合句。"
    },
    {
      "defect_id": 368067,
      "sentence": "当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。",
      "reference_sentence": "一般需要存储有序键值对的场景，可以使用TreeMap。",
      "line_num": 132,
      "context": "{\"127\":\"\",\"128\":\"初始默认容量为8，每次扩容为原始容量的2倍。\",\"129\":\"\",\"130\":\"LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。\",\"131\":\"\",\"132\":\"当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。\",\"133\":\"\",\"134\":\"LightWeightMap支持增、删、改、查操作，常用API如下：\",\"135\":\"\",\"136\":\"| 操作 | 方法 | 描述 |\",\"137\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "前后文风格不一致，建议使用祈使句",
      "更改后示例": "推荐使用占用内存更小的LightWeightMap存储key-value键值对。",
      "触发条件": "当文档中的建议性语句存在冗余条件从句结构（如\"当...时\"），且同一上下文存在使用祈使句的同类建议时触发。\n\n识别模式：\n1. 句子包含\"推荐/建议/可以\"等引导词\n2. 存在前置条件状语（如\"当...时\"）导致句式冗长\n3. 相邻段落或同类型说明项采用\"动词+宾语\"的祈使结构（如\"可以使用...\"）\n4. 上下文存在语义重复的键值对存储说明场景"
    },
    {
      "defect_id": 368443,
      "sentence": "1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。",
      "reference_sentence": "Buffer模块基于内存管理机制，将内存区域抽象为可以读写、修改的逻辑对象，旨在提供二进制数据处理的高效接口。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"Buffer模块基于内存管理机制，将内存区域抽象为可以读写、修改的逻辑对象，旨在提供二进制数据处理的高效接口。每个Buffer实例对象都是连续的字节序列，支持创建自定义大小的内存块，方便存储和操作各种不同类型的数据。\",\"4\":\"\",\"5\":\"Buffer模块的核心功能包括：\",\"6\":\"\",\"7\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"8\":\"\",\"9\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"10\":\"\",\"11\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"12\":\"\"}",
      "修改建议": "使用了不同的术语描述同一概念，'内存容量'与'内存块'混用",
      "更改后示例": "1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定大小的内存块。",
      "触发条件": "同一技术概念在相邻上下文或同一功能描述中使用了不同术语（如\"内存容量\"与\"内存块\"），且存在上下文明确的标准术语引用（如参考句中的\"内存块\"）。 \n\n识别模式：通过对比同一段落/相邻段落中核心名词短语的语义等价性，检测是否存在同义异形词（如容量/大小/块），并验证上下文是否存在已定义的标准术语（如第3段明确使用\"内存块\"）。"
    },
    {
      "defect_id": 368874,
      "sentence": "该值会传给napi_release_threadsafe_function。",
      "reference_sentence": "该值会传给napi_release_threadsafe_function。",
      "line_num": 80,
      "context": "{\"75\":\"  napi_tsfn_release,\",\"76\":\"  napi_tsfn_abort\",\"77\":\"} napi_threadsafe_function_release_mode;\",\"78\":\"```\",\"79\":\"\",\"80\":\"该值会传给napi_release_threadsafe_function。\",\"81\":\"\",\"82\":\"```cpp\",\"83\":\"napi_release_threadsafe_function(napi_threadsafe_function func,\",\"84\":\"                                 napi_threadsafe_function_release_mode mode);\",\"85\":\"```\"}",
      "修改建议": "前后文中的“该值”没有具体说明，可能导致理解上的模糊。",
      "更改后示例": "该值会传递给napi_release_threadsafe_function。",
      "触发条件": "同一文档中，同一动词短语存在介词搭配不一致（如\"传给\"与\"传递给\"混用），且上下文存在相同功能接口描述时。  \n识别模式：通过对比相邻代码注释/接口说明中的动词结构（如参考句\"传递给\"与问题句\"传给\"），检测介词\"给\"的完整性差异。"
    },
    {
      "defect_id": 369572,
      "sentence": "- 存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。",
      "reference_sentence": "该结构体定义了一个包含两个无符号64位整数的类型标签，用于标识一个JSVM-API值的类型信息。",
      "line_num": 265,
      "context": "{\"260\":\"    uint64_t lower;\",\"261\":\"    uint64_t upper;\",\"262\":\"} JSVM_TypeTag;\",\"263\":\"```\",\"264\":\"\",\"265\":\"- 存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。\",\"266\":\"\",\"267\":\"- 比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。\",\"268\":\"\",\"269\":\"- JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。\",\"270\":\"\"}",
      "修改建议": "术语前后不一致，应使用术语表中的术语",
      "更改后示例": "- 存储了两个无符号64位整数的128位值，用于标记JavaScript对象，确保它们属于某种类型。",
      "触发条件": "当句子中使用的动词短语（如“用它来”）与上下文或术语表中规定的标准表达（如“用于”）不一致，且存在明确术语表对应关系（如参考句子的\"用于标识\"）时，应触发该规则。识别需匹配动词结构是否与术语表推荐的介词短语模式冲突。"
    },
    {
      "defect_id": 368444,
      "sentence": "2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。",
      "reference_sentence": "Buffer模块基于内存管理机制，将内存区域抽象为可以读写、修改的逻辑对象，旨在提供二进制数据处理的高效接口。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"Buffer模块的核心功能包括：\",\"6\":\"\",\"7\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"8\":\"\",\"9\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"10\":\"\",\"11\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"12\":\"\",\"13\":\"4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。\",\"14\":\"\"}",
      "修改建议": "使用了不同的术语描述同一概念，'读取'与'读写'混用",
      "更改后示例": "2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读写，支持将Buffer的某部分复制到另一个Buffer或数组。",
      "触发条件": "同一语境下存在同一动词概念的拆分形式（如\"读取和写入\"）与合并形式（如\"读写\"）混用，或相邻条目动词短语结构不一致时触发。\n\n识别模式：\n1. 检测相邻功能点条目中动词短语结构差异（如条目7使用\"创建和分配\"，条目9使用\"读写和复制\"）\n2. 识别同一句子内动词表达形式突变（如标题用合并式\"读写\"，内容却拆分为\"读取和写入\"）\n3. 对比上下文标准表达（如参考句中\"读写、修改\"的统一结构）验证一致性"
    },
    {
      "defect_id": 368066,
      "sentence": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。",
      "reference_sentence": "TreeMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。",
      "line_num": 130,
      "context": "{\"125\":\"\",\"126\":\"[LightWeightMap](../reference/apis-arkts/js-apis-lightweightmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用更加轻量级的结构，底层通过hash实现唯一key，冲突策略为线性探测。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准。\",\"127\":\"\",\"128\":\"初始默认容量为8，每次扩容为原始容量的2倍。\",\"129\":\"\",\"130\":\"LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。\",\"131\":\"\",\"132\":\"当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。\",\"133\":\"\",\"134\":\"LightWeightMap支持增、删、改、查操作，常用API如下：\",\"135\":\"\"}",
      "修改建议": "描述风格不一致，建议保持一致",
      "更改后示例": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，LightWeightMap占用内存更小。",
      "触发条件": "当文档中存在多对象对比描述但未使用统一比较句式（如\"X和Y相比，X...\"结构），或出现前后分句主语不一致导致逻辑断裂时触发。"
    },
    {
      "defect_id": 369320,
      "sentence": "在应用运行期间直接执行一段动态加载的JS代码。也可以选择将一些对性能、底层系统调用有较高要求的核心功能用C/C++实现并将C++方法注册到JS侧，在JS代码中直接调用，提高应用的执行效率。",
      "reference_sentence": "在应用运行期间直接执行一段动态加载的JS代码。也可以选择将一些对性能、底层系统调用有较高要求的核心功能用C/C++实现并将C++方法注册到JS侧，在JS代码中直接调用，提高应用的执行效率。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"OpenHarmony JSVM-API是基于标准JS引擎提供的一套稳定的API，为开发者提供了较为完整的JS引擎能力，包括创建和销毁引擎，执行JS代码，JS/C++交互等关键能力。\",\"6\":\"\",\"7\":\"OpenHarmony JSVM-API是C语言接口，遵循C99标准。\",\"8\":\"\",\"9\":\"通过JSVM-API，开发者可以在应用运行期间直接执行一段动态加载的JS代码。也可以选择将一些对性能、底层系统调用有较高要求的核心功能用C/C++实现并将C++方法注册到JS侧，在JS代码中直接调用，提高应用的执行效率。\",\"10\":\"\",\"11\":\"本文中如无特别说明，后续均使用JSVM-API指代OpenHarmony JSVM-API能力。\",\"12\":\"\",\"13\":\"\",\"14\":\"## JSVM-API的组成架构\"}",
      "修改建议": "混用了'执行'与'调用'，建议统一使用'执行'。",
      "更改后示例": "在应用运行期间直接执行一段动态加载的JS代码。也可以选择将一些对性能、底层系统调用有较高要求的核心功能用C/C++实现并将C++方法注册到JS侧，在JS代码中直接执行，提高应用的执行效率。",
      "触发条件": "同一段落或相邻上下文中存在对同一操作（如JS代码运行）使用不同动词（如\"执行\"与\"调用\"），且前文已建立明确术语（如\"执行JS代码\"）的情况下触发。"
    },
    {
      "defect_id": 369798,
      "sentence": "创建typedarray，以Int32Array为例：",
      "reference_sentence": "创建一个指定大小的 ArrayBuffer 对象",
      "line_num": 1026,
      "context": "{\"1021\":\"    OH_JSVM_CreateUint32(env, i * 2, &element);\",\"1022\":\"    OH_JSVM_SetElement(env, arr, i, element);\",\"1023\":\"}\",\"1024\":\"```\",\"1025\":\"\",\"1026\":\"创建typedarray，以Int32Array为例：\",\"1027\":\"\",\"1028\":\"```c++\",\"1029\":\"JSVM_Value arrayBuffer = nullptr;\",\"1030\":\"void *arrayBufferPtr = nullptr;\",\"1031\":\"size_t arrayBufferSize = 16;\"}",
      "修改建议": "混用了`typedarray`和`TypedArray`概念",
      "更改后示例": "创建TypedArray，以Int32Array为例：",
      "触发条件": "技术术语存在大小写混用（如驼峰式与全小写混搭）且与上下文/行业标准拼写冲突时触发，例如\"TypedArray\"被错误写作\"typedarray\"。\n\n识别模式：通过匹配预定义术语库（如ECMAScript规范中的\"TypedArray\"）并检测其拼写变形（如全小写、错误驼峰），结合上下文是否出现正确拼写形式（如参考句中的\"ArrayBuffer\"采用标准首字母大写）进行双重验证。"
    },
    {
      "defect_id": 368063,
      "sentence": "一般需要存储有序集合的场景，可以使用TreeSet。",
      "reference_sentence": "TreeSet支持增、删、改、查操作，常用API如下：",
      "line_num": 107,
      "context": "{\"102\":\"\",\"103\":\"TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。\",\"104\":\"\",\"105\":\"TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。两者集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"106\":\"\",\"107\":\"一般需要存储有序集合的场景，可以使用TreeSet。\",\"108\":\"\",\"109\":\"TreeSet支持增、删、改、查操作，常用API如下：\",\"110\":\"\",\"111\":\"| 操作 | 方法 | 描述 |\",\"112\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "前后文风格不一致，建议使用祈使句",
      "更改后示例": "使用TreeSet存储有序集合。",
      "触发条件": "当检测到技术文档中操作建议类语句使用陈述句式（含\"可以\"等情态动词），而上下文同类建议采用祈使句结构时触发。识别模式需匹配\"可以/应当/建议+动词\"句式，并与相邻参考句的\"动词+宾语\"祈使结构形成风格对比。"
    },
    {
      "defect_id": 369976,
      "sentence": "用给定的属性的名称，查询目标对象是否有此属性，此方法等效于使用从作为 utf8Name 传入的字符串创建的 JSVM_Value 调用 OH_JSVM_HasProperty。",
      "reference_sentence": "用给定的属性的名称，查询目标对象是否有此属性",
      "line_num": 1340,
      "context": "{\"1335\":\"|OH_JSVM_HasProperty | 用给定的属性的名称，查询目标对象是否有此属性。 |\",\"1336\":\"|OH_JSVM_DeleteProperty | 用给定的属性的名称，删除目标对象属性。 |\",\"1337\":\"|OH_JSVM_HasOwnProperty | 检查目标对象是否具有指定的自有属性。 |\",\"1338\":\"|OH_JSVM_SetNamedProperty | 用给定的属性的名称为目标对象设置属性，此方法等效于使用从作为 utf8Name 传入的字符串创建的 JSVM_Value 调用 OH_JSVM_SetProperty。 |\",\"1339\":\"|OH_JSVM_GetNamedProperty | 用给定的属性的名称，检索目标对象的属性，此方法等效于使用从作为 utf8Name 传入的字符串创建的 JSVM_Value 调用 OH_JSVM_GetProperty。 |\",\"1340\":\"|OH_JSVM_HasNamedProperty | 用给定的属性的名称，查询目标对象是否有此属性，此方法等效于使用从作为 utf8Name 传入的字符串创建的 JSVM_Value 调用 OH_JSVM_HasProperty。 |\",\"1341\":\"|OH_JSVM_SetElement | 在给定对象的指定索引处设置元素。 |\",\"1342\":\"|OH_JSVM_GetElement | 获取给定对象指定索引处的元素。 |\",\"1343\":\"|OH_JSVM_HasElement | 若给定对象的指定索引处拥有属性，获取该元素。 |\",\"1344\":\"|OH_JSVM_DeleteElement | 尝试删除给定对象的指定索引处的元素。 |\",\"1345\":\"|OH_JSVM_DefineProperties |  批量的向给定对象中定义属性。 |\"}",
      "修改建议": "句式不一致，缺少句号",
      "更改后示例": "用给定的属性的名称，查询目标对象是否有此属性。此方法等效于使用从作为 utf8Name 传入的字符串创建的 JSVM_Value 调用 OH_JSVM_HasProperty。",
      "触发条件": "当同一功能描述包含多个独立分句但未使用统一分隔符（如句号），或与上下文同类条目句式结构（分句分隔方式）存在明显差异时触发。\n\n识别模式：检测到复合句中存在逗号连接两个完整语义模块（如功能描述+等效方法说明），且同文档其他同类条目（如相邻API说明）均采用句号分隔独立语义单元时，需强制添加分隔符保持句式一致性。"
    },
    {
      "defect_id": 368875,
      "sentence": "napi_handle_scope数据类型是用来管理JavaScript对象的生命周期的。",
      "reference_sentence": "napi_handle_scope数据类型是用来管理JavaScript对象的生命周期的。",
      "line_num": 115,
      "context": "{\"110\":\"\",\"111\":\"Node-API包含以下内存管理类型：\",\"112\":\"\",\"113\":\"**napi_handle_scope**\",\"114\":\"\",\"115\":\"napi_handle_scope数据类型是用来管理JavaScript对象的生命周期的。它允许JavaScript对象在一定范围内保持活动状态，以便在JavaScript代码中使用。在创建napi_handle_scope时，所有在该范围内创建的JavaScript对象都会保持活动状态，直到结束。这样可以做到JavaScript对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。\",\"116\":\"\",\"117\":\"**napi_escapable_handle_scope**\",\"118\":\"\",\"119\":\"- 由napi_open_escapable_handle_scope接口创建，由napi_close_escapable_handle_scope接口关闭。\",\"120\":\"\"}",
      "修改建议": "前后文中的“数据类型”和“数据类型”不一致，建议统一。",
      "更改后示例": "napi_handle_scope数据类型用于管理JavaScript对象的生命周期。",
      "触发条件": "当同一术语或短语在相邻或相关上下文中重复出现，但搭配的动词或语法结构存在不一致（例如“是用来”与“用于”混用，或术语重复冗余）时触发。  \n识别模式：检测重复性术语（如“数据类型”）的邻近重复出现，并对比其搭配动词/表达是否统一（如“是用来” vs “用于”），或术语本身是否冗余重复（如“数据类型”与“类型”交替使用）。"
    },
    {
      "defect_id": 369573,
      "sentence": "当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。",
      "reference_sentence": "**JSVM_PropertyHandlerConfigurationStruct**",
      "line_num": 312,
      "context": "{\"307\":\"typedef void (*JSVM_Finalize)(JSVM_Env env, void* finalizeData, void* finalizeHint);\",\"308\":\"```\",\"309\":\"\",\"310\":\"**JSVM_PropertyHandlerConfigurationStruct**\",\"311\":\"\",\"312\":\"当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。\",\"313\":\"\",\"314\":\"```c++\",\"315\":\"typedef struct {\",\"316\":\"    JSVM_Value(JSVM_CDECL* genericNamedPropertyGetterCallback)(JSVM_Env env,\",\"317\":\"                                                               JSVM_Value name,\"}",
      "修改建议": "术语前后不一致，应使用术语表中的术语",
      "更改后示例": "当执行对象的getter、setter、deleter和enumerator操作时，对应的回调将会触发。",
      "触发条件": "当检测到技术术语表述与官方术语表存在不一致（如\"作\"与\"操作\"），或存在影响术语完整性的错别字（如\"enumerator作\"漏\"操\"字）时触发。\n\n识别模式：通过比对上下文中的标准术语（如结构体名称中的\"PropertyHandler\"）和动词搭配规范性（\"执行...操作\"），识别术语缺失核心语素或动词搭配不当的表述问题。"
    },
    {
      "defect_id": 369321,
      "sentence": "Native方法将会被挂载到JS执行环境的全局上下文即GlobalThis。",
      "reference_sentence": "Native方法将会被挂载到JS执行环境的全局上下文即GlobalThis。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"![JSVM-API 关键交互流程](figures/process_jsvm-api.png)\",\"53\":\"\",\"54\":\"JSVM-API和Native模块之间的交互流程，主要分为以下两步：\",\"55\":\"\",\"56\":\"1. **初始化阶段**：在Native模块上初始化JSVM和JS上下文，并完成Native函数的注册。Native方法将会被挂载到JS执行环境的全局上下文即GlobalThis。\",\"57\":\"\",\"58\":\"2. **调用阶段**：当JS侧调用通过JSVM-API注册到JS全局上下文的方法时，JS引擎会找到并调用对应的C/C++方法。\"}",
      "修改建议": "混用了'全局上下文'与'全局环境'，建议统一使用'全局上下文'。",
      "更改后示例": "Native方法将会被挂载到JS执行环境的全局上下文。",
      "触发条件": "当同一文档中出现对同一技术概念使用不同术语表述（如\"全局上下文\"与\"全局环境\"混用），或存在冗余解释导致术语不一致时触发。\n\n识别模式：\n1. 术语重复校验：检测同一段落/章节中是否存在描述同一技术概念的不同近义词（通过预定义的同义术语库匹配）\n2. 冗余标记识别：定位含有\"即\"\"也就是\"等解释性连接词的结构，检查前后术语是否应统一（如\"全局上下文即GlobalThis\"中的双重表述）"
    },
    {
      "defect_id": 368445,
      "sentence": "1. **大数据传输**：当需要传输大量数据，如二进制文件、数据库记录或网络报文时，使用Buffer作为数据的存储和处理容器，可减少拷贝和内存消耗，提升传输效率。",
      "reference_sentence": "Buffer模块基于内存管理机制，将内存区域抽象为可以读写、修改的逻辑对象，旨在提供二进制数据处理的高效接口。",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。\",\"14\":\"\",\"15\":\"Buffer模块的主要应用场景包括：\",\"16\":\"\",\"17\":\"1. **大数据传输**：当需要传输大量数据，如二进制文件、数据库记录或网络报文时，使用Buffer作为数据的存储和处理容器，可减少拷贝和内存消耗，提升传输效率。\",\"18\":\"\",\"19\":\"2. **图像和音频处理**：在图像编码、解码，音频数据流处理等方面，Buffer可帮助开发者方便地操作像素或采样数据，确保数据的完整性。\",\"20\":\"\",\"21\":\"3. **二进制数据操作**：Buffer提供稳定的接口解析和操作二进制数据。\",\"22\":\"\"}",
      "修改建议": "使用了不同的术语描述同一概念，'数据的存储和处理容器'与'数据的存储和操作容器'混用",
      "更改后示例": "1. **大数据传输**：当需要传输大量数据，如二进制文件、数据库记录或网络报文时，使用Buffer作为数据的存储和操作容器，可减少拷贝和内存消耗，提升传输效率。",
      "触发条件": "当同一技术概念在相邻条目或上下文描述中使用了不同动词术语（如\"处理\"与\"操作\"混用），且参考段落存在明确术语规范（如\"操作\"在内存管理、二进制数据等关联场景中形成统一表达链）时触发。\n\n识别模式：\n1. 定位核心动词在技术场景中的一致性，比对问题句与上下文/参考句的用词差异\n2. 检测相邻条目（如应用场景1-3条目）是否存在术语表达链（本例中\"操作\"在条目2、3及模块描述中形成连贯表达）\n3. 验证动词是否指向同一技术行为（如\"处理容器\"与\"操作容器\"均描述Buffer对数据的控制行为）"
    },
    {
      "defect_id": 369861,
      "sentence": "判断一个 JavaScript 对象是否为 Dataview 类型对象",
      "reference_sentence": "判断一个 JavaScript 对象是否为 DataView 类型对象",
      "line_num": 1193,
      "context": "{\"1188\":\"|OH_JSVM_Instanceof | 判断一个对象是否是某个构造函数的实例 |\",\"1189\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1190\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1191\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\"}",
      "修改建议": "混用了`Dataview`和`DataView`，应保持一致",
      "更改后示例": "判断一个 JavaScript 对象是否为 DataView 类型对象",
      "触发条件": "当检测到同一技术术语在相邻或相关条目中存在大小写不一致（如DataView/Dataview），且上下文存在明确的标准拼写形式（如JavaScript内置类型命名规范）时触发。\n\n识别模式：\n1. 术语形态比对：识别驼峰命名法的标准形式（如DataView应保持首字母大写和内部大写）\n2.上下文一致性检查：对比相邻条目（如ArrayBuffer/TypedArray的规范命名）和参考句子的术语使用模式\n3. 规范匹配验证：核对JavaScript语言规范定义的标准类型名称（如MDN文档中的DataView类型）"
    },
    {
      "defect_id": 369717,
      "sentence": "在此scope范围外创建的对象不受父作用域保护",
      "reference_sentence": "在此scope范围外创建的对象不受父作用域保护",
      "line_num": 899,
      "context": "{\"894\":\"| 接口 | 功能说明 |\",\"895\":\"| -------- | -------- |\",\"896\":\"| OH_JSVM_OpenHandleScope| 打开一个新的scope，在关闭该scope之前创建的对象在scope范围内不会被GC回收 |\",\"897\":\"| OH_JSVM_CloseHandleScope| 关闭一个scope，在此scope范围内创建的对象在关闭scope后可以被GC回收|\",\"898\":\"| OH_JSVM_OpenEscapableHandleScope| 打开一个新的scope逃逸handle scope，在关闭该scope之前创建的对象与父作用域有相同的生命周期 |\",\"899\":\"| OH_JSVM_CloseEscapableHandleScope| 关闭一个scope，在此scope范围外创建的对象不受父作用域保护 |\",\"900\":\"| OH_JSVM_EscapeHandle| 将 JavaScript 对象的句柄提升到外部作用域，确保在外部作用域中可以持续地使用该对象 |\",\"901\":\"| OH_JSVM_CreateReference| 以指定的引用计数为JavaScript对象创建一个新的引用，该引用将指向传入的对象，引用允许在不同的上下文中使用和共享对象，并且可以有效地监测对象的生命周期 |\",\"902\":\"| OH_JSVM_DeleteReference| 释放由 OH_JSVM_CreateReference 创建的引用，确保对象在不再被使用时能够被正确地释放和回收，避免内存泄漏 |\",\"903\":\"| OH_JSVM_ReferenceRef| 增加由OH_JSVM_CreateReference 创建的引用的引用计数，以确保对象在有引用时不会被提前释放 |\",\"904\":\"| OH_JSVM_ReferenceUnref| 减少由OH_JSVM_CreateReference 创建的引用的引用计数，以确保没有任何引用指向该对象时能正确地释放和回收 |\"}",
      "修改建议": "混用了'scope'和'作用域'术语，需保持一致",
      "更改后示例": "在此作用域范围外创建的对象不受父作用域保护",
      "触发条件": "同一技术概念在相邻上下文中交替使用中英文术语（如\"scope\"和\"作用域\"），或同一复合词内部存在术语混用（如\"scope范围\"）。需通过术语表匹配和相邻语句对比识别不一致表达。"
    },
    {
      "defect_id": 369714,
      "sentence": "使用OH_JSVM_GetAndClearLastException后将异常信息以字符串形式打印",
      "reference_sentence": "使用OH_JSVM_GetAndClearLastException后将异常信息以字符串形式打印",
      "line_num": 855,
      "context": "{\"850\":\"bool isError = false;\",\"851\":\"OH_JSVM_IsError(env, error, &isError);\",\"852\":\"OH_JSVM_ThrowTypeError(env, nullptr, \\\"type error1\\\");\",\"853\":\"```\",\"854\":\"\",\"855\":\"使用OH_JSVM_GetAndClearLastException后将异常信息以字符串形式打印\",\"856\":\"\",\"857\":\"```c++\",\"858\":\"if (status != JSVM_OK) // 当执行失败出现异常时\",\"859\":\"{\",\"860\":\"    bool isPending = false;\"}",
      "修改建议": "混用了'异常'和'异常信息'术语，需保持一致",
      "更改后示例": "使用OH_JSVM_GetAndClearLastException后将异常以字符串形式打印",
      "触发条件": "同一段落或相邻上下文中出现同一概念使用不同术语（如\"异常\"与\"异常信息\"交替出现），且存在已确定的文档规范术语（如参考句中的\"异常信息\"）。通过检测术语在局部上下文中的重复模式及与参考规范的比对进行识别。"
    },
    {
      "defect_id": 369977,
      "sentence": "JS对象属性的增删获取和判断",
      "reference_sentence": "JS对象属性的增加、删除、获取和判断",
      "line_num": 1352,
      "context": "{\"1347\":\"|OH_JSVM_ObjectSeal | 密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。 |\",\"1348\":\"|OH_JSVM_ObjectSetPrototypeOf | 为给定对象设置一个原型。 |\",\"1349\":\"|OH_JSVM_ObjectGetPrototypeOf | 获取给定JavaScript对象的原型。 |\",\"1350\":\"\",\"1351\":\"场景示例:\",\"1352\":\"JS对象属性的增删获取和判断\",\"1353\":\"\",\"1354\":\"```c++\",\"1355\":\"// 创建一个空对象\",\"1356\":\"JSVM_Value myObject = nullptr;\",\"1357\":\"OH_JSVM_CreateObject(env, &myObject);\"}",
      "修改建议": "混用了`增删`和`增加、删除`",
      "更改后示例": "JS对象属性的增加、删除、获取和判断",
      "触发条件": "当并列结构中出现缩略词（如\"增删\"）与完整动词短语（如\"增加、删除\"）混用时，或同一语义范畴的并列项存在表达形式不统一时触发。\n\n识别模式：\n1. 检测并列结构中存在\"缩略词+完整短语\"混合模式（例如\"增删\"与\"获取\"并列）\n2. 验证上下文存在同类语义的完整表达形式（如参考句子中统一使用\"增加、删除\"）\n3. 检查语法结构是否属于同一逻辑层级的枚举项（如多个动词短语并列描述操作类型）"
    },
    {
      "defect_id": 370015,
      "sentence": "在C/C++侧获取并调用JS方法",
      "reference_sentence": "在C/C++侧调用JS方法",
      "line_num": 1456,
      "context": "{\"1451\":\"    JSVM_Status status = OH_JSVM_CreateFunction(env, \\\"func\\\", JSVM_AUTO_LENGTH, &param, &funcValue);\",\"1452\":\"    return funcValue;\",\"1453\":\"}\",\"1454\":\"```\",\"1455\":\"\",\"1456\":\"在C/C++侧获取并调用JS方法\",\"1457\":\"\",\"1458\":\"```c++\",\"1459\":\"static JSVM_Value CallFunction(JSVM_Env env, JSVM_CallbackInfo info)\",\"1460\":\"{\",\"1461\":\"    size_t argc = 1;\"}",
      "修改建议": "混用了'获取并调用'和'调用'，应保持一致",
      "更改后示例": "在C/C++侧调用JS方法",
      "触发条件": "同一上下文中对同一操作使用不一致的动词短语（如\"获取并调用\"与\"调用\"混用），且存在参考规范表达时。\n\n识别模式：\n1. 检查相邻段落/代码块描述相同功能时是否出现冗余动词组合（如\"获取并调用\"）\n2. 对比上下文是否存在更简洁的标准表达（如参考句中的\"调用\"）\n3. 当动词短语包含可合并的连续动作时触发（获取+调用→调用）"
    },
    {
      "defect_id": 370019,
      "sentence": "对象绑定及监听拦截属性操作。",
      "reference_sentence": "对象绑定操作",
      "line_num": 1589,
      "context": "{\"1584\":\"    return nullptr;\",\"1585\":\"}\",\"1586\":\"```\",\"1587\":\"\",\"1588\":\"场景示例：\",\"1589\":\"对象绑定及监听拦截属性操作。\",\"1590\":\"\",\"1591\":\"```c++\",\"1592\":\"static int aa = 0;\",\"1593\":\"static JSVM_Value hello(JSVM_Env env, JSVM_CallbackInfo info) {\",\"1594\":\"    JSVM_Value output;\"}",
      "修改建议": "混用了'对象绑定及监听拦截属性操作'和'对象绑定操作'，应保持一致",
      "更改后示例": "对象绑定操作及监听拦截属性操作。",
      "触发条件": "同一上下文中存在并列结构的名词短语，且短语内部结构不一致（如部分含动作性后缀\"操作\"而另一部分缺失），导致语义表达不对称。  \n\n识别模式：  \n1. **并列连词检测**：句子中出现\"及\"、\"和\"等并列连词连接多个短语；  \n2. **结构对比**：并列项中至少一项包含动作性后缀（如\"操作\"），而其他项缺失该后缀，形成\"X及Y操作\"类不对称结构（如\"对象绑定及监听拦截属性操作\"）。"
    },
    {
      "defect_id": 369860,
      "sentence": "判断一个 JavaScript 对象是否为 Arraybuffer 类型对象",
      "reference_sentence": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象",
      "line_num": 1190,
      "context": "{\"1185\":\"|OH_JSVM_CoerceToString | 将目标值转换为 String 类型对象 |\",\"1186\":\"|OH_JSVM_CoerceToBigInt | 将目标值转换为 BigInt 类型对象 |\",\"1187\":\"|OH_JSVM_Typeof | 返回 JavaScript 对象的类型 |\",\"1188\":\"|OH_JSVM_Instanceof | 判断一个对象是否是某个构造函数的实例 |\",\"1189\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1190\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1191\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\"}",
      "修改建议": "混用了`Arraybuffer`和`ArrayBuffer`，应保持一致",
      "更改后示例": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象",
      "触发条件": "当技术术语或专有名词在文档中存在大小写不一致（如ArrayBuffer/Arraybuffer），或与上下文/官方标准拼写冲突时触发，尤其当同一文档中出现相同术语的规范写法（如参考句中的ArrayBuffer）时。"
    },
    {
      "defect_id": 370016,
      "sentence": "创建Function:",
      "reference_sentence": "创建JavaScript函数操作",
      "line_num": 1480,
      "context": "{\"1475\":\"    JSVM_CALL(env, OH_JSVM_CallFunction(env, global, args[0], 0, nullptr, &ret));\",\"1476\":\"    return ret;\",\"1477\":\"}\",\"1478\":\"```\",\"1479\":\"\",\"1480\":\"创建Function:\",\"1481\":\"\",\"1482\":\"```c++\",\"1483\":\"JSVM_Value script;\",\"1484\":\"OH_JSVM_CreateStringUtf8(env, \\\"return a + b;\\\", JSVM_AUTO_LENGTH, &script);\",\"1485\":\"JSVM_Value param1;\"}",
      "修改建议": "混用了'Function'和'JavaScript函数'，应保持一致",
      "更改后示例": "创建JavaScript函数:",
      "触发条件": "当同一术语在相邻上下文或技术描述中出现中英文混用（如\"Function\"与\"JavaScript函数\"），且存在已确立的参考表达（如\"创建JavaScript函数操作\"）时触发。"
    },
    {
      "defect_id": 365967,
      "sentence": "准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。",
      "reference_sentence": "方舟字节码（ArkCompiler Bytecode）文件，是ArkCompiler的编译工具链以源代码作为输入编译生成的产物，其文件后缀名为.abc。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。\",\"4\":\"\",\"5\":\"## 能力配置说明\",\"6\":\"\",\"7\":\"准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。\",\"8\":\"\",\"9\":\"## 能力执行机制\",\"10\":\"\",\"11\":\"如果配置了transformLib且对应的动态库文件能正确加载，编译器将先生成方舟字节码文件到默认目标位置，然后调用动态库中的Transform方法，并将方舟字节码文件的路径作为参数传入。Transform方法包含开发者自定义的修改逻辑，用于重新生成方舟字节码文件，同时更新字节码文件的落盘操作是由用户执行。\",\"12\":\"\"}",
      "修改建议": "混用了“方舟字节码文件”和“方舟字节码”概念",
      "更改后示例": "准备一个操作方舟字节码的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。",
      "触发条件": "同一文档中对同一核心概念使用不同术语变体（如\"方舟字节码文件\"与\"方舟字节码\"），且上下文存在该概念的明确定义（如参考句子的.abc文件定义）时触发。\n\n识别模式：\n1. 概念锚定：通过技术文档中的定义句（如参考句子）确定标准术语形式\n2. 变体检测：在相邻段落（如本案例的3-11行上下文）扫描是否存在冗余修饰词（如\"文件\"）的增减\n3. 混淆验证：当变体形式可能引发理解歧义（如\"字节码\"可能指内存对象而非文件）时判定为违规"
    },
    {
      "defect_id": 369862,
      "sentence": "判断JS值是否为数组类型",
      "reference_sentence": "判断一个 JavaScript 对象是否为 Array 类型对象",
      "line_num": 1214,
      "context": "{\"1209\":\"|OH_JSVM_Equals | 判断两个 JSVM_Value 对象是否宽松相等 |\",\"1210\":\"|OH_JSVM_DetachArraybuffer | 调用 ArrayBuffer 对象的Detach操作 |\",\"1211\":\"|OH_JSVM_IsDetachedArraybuffer | 检查给定的 ArrayBuffer 是否已被分离(detached) |\",\"1212\":\"\",\"1213\":\"场景示例:\",\"1214\":\"判断JS值是否为数组类型\",\"1215\":\"\",\"1216\":\"```c++\",\"1217\":\"JSVM_Value array = nullptr;\",\"1218\":\"OH_JSVM_CreateArray(env, &array);\",\"1219\":\"bool isArray = false;\"}",
      "修改建议": "混用了`数组类型`和`Array 类型对象`，应保持一致",
      "更改后示例": "判断JS值是否为Array类型",
      "触发条件": "同一技术术语在相邻条目或参考句中出现中英文混用表述（如\"数组类型\"与\"Array类型\"），且上下文已建立英文术语标准（如ArrayBuffer/Array类型对象）时触发。\n\n识别模式：\n1. 术语对照：检测中文术语是否对应到上下文已确立的英文标准术语（如\"数组\"对应Array）\n2. 邻近一致性：检查问题句子所在条目组内（如ID 1209-1217）是否存在同类英文术语规范用法\n3. 参考句匹配：当存在明确的英文术语使用范例（如\"Array类型对象\"）时，中文直译表述将被识别为不一致"
    },
    {
      "defect_id": 371107,
      "sentence": "wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "reference_sentence": "wasm 缓存 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## 基本概念\",\"10\":\"\",\"11\":\"- **wasm module**：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm cache 创建 wasm module。通过 `OH_JSVM_IsWasmModuleObject` 接口可以判断一个 JSVM_Value 是否是一个 wasm module。\",\"12\":\"- **wasm function**：表示 wasm module 中定义的函数，wasm function 在导出后被外部代码使用。`OH_JSVM_CompileWasmFunction` 接口提供了将 wasm function 编译为优化后的机器码的能力，方便开发者对指定 wasm function 提前编译和函数粒度的并行编译。\",\"13\":\"- **wasm cache**：对 wasm module 中的机器码进行序列化，生成的数据被称为 wasm cache。wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                          | 功能说明                                                                                 |\",\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\"}",
      "修改建议": "混用了`cache`和`缓存`概念",
      "更改后示例": "wasm 缓存 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "触发条件": "当同一技术术语在中文翻译和英文原词混用（如\"cache\"与\"缓存\"交替出现）且处于同一语义段落时，或同一概念存在两种及以上中文译名时触发。\n\n识别模式：\n1. 术语对照检测：当英文术语(如\"cache\")与其对应中文翻译(如\"缓存\")在相邻句子/同一段落中交替出现时\n2. 概念一致性验证：检查同一段落内是否存在同一英文术语对应多个中文译名（如\"cache\"同时被译为\"缓存\"和\"cache\"）\n3. 上下文锚定匹配：通过代码符号(如`OH_JSVM_CreateWasmCache`)中的英文术语反向验证对应中文译名的统一性"
    },
    {
      "defect_id": 371117,
      "sentence": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传递参数进行调用，或者直接在JSVM模块中创建一个JavaScript方法。",
      "reference_sentence": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传递参数进行调用，或者直接在JSVM模块中创建一个JavaScript函数。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行函数创建和调用\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"函数调用允许开发者从JSVM模块中调用JavaScript函数，并传递参数进行调用，或者直接在JSVM模块中创建一个JavaScript方法。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"函数是一种非常重要的编程概念，可以执行特定的任务或操作、提高代码的可读性、把复杂任务简化、提高代码复用性以及支持代码的组织与管理。每个函数可以负责不同的功能，提供一种将代码模块化和组织结构化的方式，使其更易于理解、维护和重用。\",\"10\":\"\"}",
      "修改建议": "混用了'函数'和'方法'概念",
      "更改后示例": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传递参数进行调用，或者直接在JSVM模块中创建一个JavaScript函数。",
      "触发条件": "同一技术概念在相邻上下文中出现术语混用（如函数/方法），且参考文档已确立统一术语规范时触发。\n\n识别模式：\n1. 术语冲突检测：在2-3个相邻句子内，同一概念出现不同术语表达（如\"函数\"与\"方法\"交替使用）\n2. 概念定义验证：检查文档\"基本概念\"等定义性段落，确认已确立标准术语（如该案例第9段明确定义\"函数\"）\n3. 技术准确性校验：当混用术语属于易混淆技术概念时（函数/method具有明确技术差异）强制触发"
    },
    {
      "defect_id": 372717,
      "sentence": "使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。",
      "reference_sentence": "使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行array相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。以下是一些关键概念：\",\"10\":\"\"}",
      "修改建议": "混用了'数组（array）'和'JavaScript 数组'，应保持用词一致",
      "更改后示例": "使用 JSVM-API 接口进行 JavaScript 数组相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 数组。",
      "触发条件": "同一文档中出现同一术语的中英文混用（如\"数组（array）\"与\"JavaScript数组\"）或同一概念存在带/不带修饰词（如\"JavaScript\"）的不一致表达。\n\n识别模式：\n1. 相邻段落中相同语义词汇存在括号注释差异（如\"数组（array）\"与纯中文\"数组\"交替出现）\n2. 同一章节内核心术语的修饰成分不一致（如问题句的\"JavaScript中的数组\"与参考句的\"JavaScript数组\"结构差异）\n3. 英文缩写/全称与中文术语的映射关系未保持统一（如标题用\"array\"而正文用带括号的\"数组（array）\"）"
    },
    {
      "defect_id": 370883,
      "sentence": "**【规则】**：调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。调用JSVM-API生成的类、对象同理。",
      "reference_sentence": "**【规则】** 多引擎实例（VM）场景下，禁止通过JSVM-API跨引擎实例访问JS对象。",
      "line_num": 393,
      "context": "{\"388\":\"\",\"389\":\"    ```\",\"390\":\"\",\"391\":\"## 上下文绑定对象\",\"392\":\"\",\"393\":\"**【规则】**：调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。调用JSVM-API生成的类、对象同理。\",\"394\":\"\",\"395\":\"**示例**：\",\"396\":\"\",\"397\":\"```\",\"398\":\"JSVM_Value JSFunc = nullptr;\"}",
      "修改建议": "使用了不同的词汇描述同一概念，'对象'与'JS对象'混用",
      "更改后示例": "**【规则】**：调用JSVM-API生成的JS函数、JS对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。调用JSVM-API生成的类、JS对象同理。",
      "触发条件": "同一技术术语在相邻或相关语句中存在不一致的修饰词/缩写形式（如\"对象\"与\"JS对象\"混用），或同一概念出现多种命名变体时触发。\n\n识别模式：\n1. 检查相邻句子/段落中描述同一技术实体（如JS对象、JS函数）时是否保持完全一致的限定词修饰\n2. 验证技术术语是否在首次定义后始终采用相同的完整形态（如带\"JS\"前缀），未出现无理由的缩略形态\n3. 识别技术场景中成对出现的关联概念（如JS函数与JS对象）是否保持对称的修饰方式"
    },
    {
      "defect_id": 372690,
      "sentence": "解析JSON字符串，并将结果存储在JSON对象。",
      "reference_sentence": "解析JSON字符串，并将结果存储在JSON对象。",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                       | 功能说明                       |\",\"14\":\"|----------------------------|--------------------------------|\",\"15\":\"| OH_JSVM_JsonParse          | 解析JSON字符串，并将结果存储在JSON对象。 |\",\"16\":\"| OH_JSVM_JsonStringify      | 将对象字符串化，并将结果存储在JSVM字符串对象。 |\",\"17\":\"\",\"18\":\"## 使用示例\",\"19\":\"\",\"20\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\"}",
      "修改建议": "用词一致，但建议使用更规范的表述",
      "更改后示例": "解析JSON字符串，并将结果存储在JSON对象中。",
      "触发条件": "当句子中\"存储在...\"结构缺少方位词\"中\"，且上下文存在相同动词短语需要保持介词结构一致性时触发。识别模式为动词\"存储\"后接\"在+名词\"但缺失方位词结尾，同时文档中存在其他同类结构（如\"存储在JSVM字符串对象\"）形成表达不一致。"
    },
    {
      "defect_id": 371105,
      "sentence": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。",
      "reference_sentence": "JSVM-API 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly 缓存 序列化和反序列化的能力。",
      "line_num": 6,
      "context": "{\"1\":\"# 使用JSVM-API接口进行WebAssembly模块相关开发\",\"2\":\"\",\"3\":\"\",\"4\":\"## 简介\",\"5\":\"\",\"6\":\"JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。\",\"7\":\"注意：WebAssembly相关接口需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"8\":\"\",\"9\":\"## 基本概念\",\"10\":\"\",\"11\":\"- **wasm module**：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm cache 创建 wasm module。通过 `OH_JSVM_IsWasmModuleObject` 接口可以判断一个 JSVM_Value 是否是一个 wasm module。\"}",
      "修改建议": "混用了`cache`和`缓存`概念",
      "更改后示例": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly 缓存 序列化和反序列化的能力。",
      "触发条件": "当同一技术术语在相邻上下文或同一文档中存在中英文混用（如\"cache\"与\"缓存\"），且该术语已在当前文档中被明确定义或高频使用统一译法时。\n\n识别模式：\n1. 检测并列结构中相同前缀的术语形态（如\"WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache\"三并列项）\n2. 对比上下文已建立的术语映射关系（如问题上下文第11点已使用\"wasm cache -> wasm缓存\"对应关系）\n3. 检查同一技术概念是否在文档其他位置存在标准化译法（如参考句子已使用\"缓存\"作为规范表达）"
    },
    {
      "defect_id": 372718,
      "sentence": "使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。",
      "reference_sentence": "使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **数组的创建**：若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建数组，将数组传递给 JavaScript 层。\",\"12\":\"- **数组相关操作**：在 JSVM 模块中通过对应的接口获取 JavaScript 数组的长度、检索指定索引处的元素以及设置指定索引处的元素值，从而实现 JSVM 模块与 JavaScript 数组的交互。\",\"13\":\"- **TypedArray**：JavaScript 中的 TypedArray 是一种用来描述二进制数据的类数组数据视图，可以简单理解为一种指定元素类型的数组，TypedArray 没有直接构造器，但是可以用它的子类构造器构造 TypedArray 类型的数据。TypedArray 的子类有：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array 等。\",\"14\":\"- **ArrayBuffer**：ArrayBuffer 是固定长度的二进制数据缓冲区。\"}",
      "修改建议": "混用了'数组（array）'和'JavaScript 数组'，应保持用词一致",
      "更改后示例": "使用 JSVM-API 接口进行 JavaScript 数组相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。",
      "触发条件": "同一技术术语在相邻段落或同一章节内出现两种及以上表述形式（如中文+英文括号注释/带不同修饰词），且上下文存在明确指向同一概念的情况。\n\n识别模式：\n1. 术语变体检测：匹配\"X(Y)\"结构（如\"数组(array)\"）与带修饰词的全称（如\"JavaScript数组\"）\n2.上下文语义验证：在半径3-5句范围内存在相同技术实体的其他表述，且通过：\n   - 共现相同动词操作（创建/访问/修改）\n   - 共享相同技术上下文（JSVM-API/模块交互）\n   - 指向相同技术组件（如ArrayBuffer/TypedArray）"
    },
    {
      "defect_id": 372825,
      "sentence": "根据Uint64类型对象创建JavaScript Bigint对象。",
      "reference_sentence": "根据Uint64类型对象创建 JavaScript BigInt对象。",
      "line_num": 239,
      "context": "{\"234\":\"JSVM GetValueBigintUint64 success:1\",\"235\":\"```\",\"236\":\"\",\"237\":\"### OH_JSVM_CreateBigintInt64\",\"238\":\"\",\"239\":\"根据Uint64类型对象创建JavaScript Bigint对象。\",\"240\":\"\",\"241\":\"cpp部分代码\",\"242\":\"\",\"243\":\"```cpp\",\"244\":\"// hello.cpp\"}",
      "修改建议": "混用了`Bigint`和`BigInt`概念",
      "更改后示例": "根据Uint64类型对象创建 JavaScript BigInt对象。",
      "触发条件": "同一术语在文档中出现大小写不一致（如`Bigint`与`BigInt`），且存在明确正确形式的参考实例（如相邻代码/上下文中规范写法）。\n\n识别模式：通过对比术语拼写变体（如首字母大小写差异）与上下文/代码示例中的标准形式，检测到非规范写法（如`Bigint`）时触发规则。"
    },
    {
      "defect_id": 371108,
      "sentence": "将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。",
      "reference_sentence": "将 wasm module 中的机器码序列化为 wasm 缓存，如果 wasm module 不包含机器码，则会序列化失败。",
      "line_num": 22,
      "context": "{\"17\":\"| 接口                          | 功能说明                                                                                 |\",\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"19\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。 |\",\"20\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"21\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是一个 wasm module。                                                             |\",\"22\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。                    |\",\"23\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"24\":\"\",\"25\":\"## code cache 校验规格说明\",\"26\":\"| 规格        | 规格说明                                         |\",\"27\":\"| ---------- | ------------------------------------------------ |\"}",
      "修改建议": "混用了`cache`和`缓存`概念",
      "更改后示例": "将 wasm module 中的机器码序列化为 wasm 缓存，如果 wasm module 不包含机器码，则会序列化失败。",
      "触发条件": "同一文档中同一技术术语存在中英文混用（如\"cache\"和\"缓存\"交替出现），且上下文已建立该术语的标准翻译形式。\n\n识别模式：\n1. 检测相邻段落/接口说明中同一概念的中英文表达形式（如接口名\"CreateWasmCache\"与中文段落中的\"缓存\"）\n2. 验证术语在技术规范标题（如\"code cache 校验规格说明\"）与操作说明中的一致性\n3. 对比接口参数名（如cache参数）与功能描述中的中文翻译是否统一"
    },
    {
      "defect_id": 372856,
      "sentence": "OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。",
      "reference_sentence": "OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。",
      "line_num": 24,
      "context": "{\"19\":\"| OH_JSVM_GetNewTarget  | 获取函数的元属性new.target。|\",\"20\":\"| OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持。|\",\"21\":\"| OH_JSVM_Wrap           | 在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例。|\",\"22\":\"| OH_JSVM_Unwrap         | 解包先前封装在JavaScript对象中的原生实例。|\",\"23\":\"| OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例并释放封装。|\",\"24\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"29\":\"\"}",
      "修改建议": "混用了'定义'与'用于定义'，导致用词不一致。",
      "更改后示例": "OH_JSVM_DefineClassWithOptions | 用于定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入的DefineClassOptions来决定是否需要为所定义的类设置属性代理、预留internal-field槽位、为类作为函数进行调用时设置函数回调。",
      "触发条件": "当同一文档中描述同类功能的动词短语结构不一致（如\"定义\"与\"用于定义\"混用），或存在术语大小写/用词不统一（如\"Class\"/\"类\"交替出现）时触发。\n\n识别模式：\n1. 动词短语结构比对：检查同类条目是否采用统一句式（如参考条目\"用于在...定义\"与问题条目\"定义...\"形成结构冲突）\n2. 术语一致性检测：识别英文术语首字母大小写差异（Class/class）、中英文术语混用（\"类\"与\"Class\"）\n3. 上下文模式匹配：验证当前条目是否与相邻条目（如OH_JSVM_DefineClass）保持相同的\"用于...\"引导句式规范"
    },
    {
      "defect_id": 371106,
      "sentence": "通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm cache 创建 wasm module。",
      "reference_sentence": "通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm 缓存 创建 wasm module。",
      "line_num": 11,
      "context": "{\"6\":\"JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。\",\"7\":\"注意：WebAssembly相关接口需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"8\":\"\",\"9\":\"## 基本概念\",\"10\":\"\",\"11\":\"- **wasm module**：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm cache 创建 wasm module。通过 `OH_JSVM_IsWasmModuleObject` 接口可以判断一个 JSVM_Value 是否是一个 wasm module。\",\"12\":\"- **wasm function**：表示 wasm module 中定义的函数，wasm function 在导出后被外部代码使用。`OH_JSVM_CompileWasmFunction` 接口提供了将 wasm function 编译为优化后的机器码的能力，方便开发者对指定 wasm function 提前编译和函数粒度的并行编译。\",\"13\":\"- **wasm cache**：对 wasm module 中的机器码进行序列化，生成的数据被称为 wasm cache。wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\"}",
      "修改建议": "混用了`cache`和`缓存`概念",
      "更改后示例": "通过 `OH_JSVM_CompileWasmModule` 接口可以从 wasm 字节码或 wasm 缓存 创建 wasm module。",
      "触发条件": "同一文档中存在同一术语的中英文混用（如“cache”和“缓存”），且上下文已明确该术语的标准翻译形式。\n\n识别模式：\n1. **术语对照检查**：当句子中术语的英文原词（如“cache”）与其中文翻译（如“缓存”）混用时触发；\n2. **上下文一致性验证**：若文档其他位置（如定义、接口说明）已明确定义该术语的标准译法（如“wasm 缓存”），则强制统一为译法。"
    },
    {
      "defect_id": 371118,
      "sentence": "OH_JSVM_CreateFunction     | 用于创建JavaScript函数,用于从JavaScript环境中调用C/C++代码中的函数, 需要设置到一个js对象中才可以进行调用。",
      "reference_sentence": "OH_JSVM_CreateFunction     | 用于创建JavaScript函数,用于从JavaScript环境中调用C/C++代码中的函数, 需要设置到一个JS对象中才可以进行调用。",
      "line_num": 18,
      "context": "{\"13\":\"| 接口                       | 功能说明                       |\",\"14\":\"|----------------------------|--------------------------------|\",\"15\":\"| OH_JSVM_GetCbInfo          | 从给定的callback info中获取有关调用的详细信息，如参数和this指针。|\",\"16\":\"| OH_JSVM_CallFunction       | 在C/C++侧调用JavaScript方法。|\",\"17\":\"| OH_JSVM_IsFunction         | 判断对象是否为函数对象。 |\",\"18\":\"| OH_JSVM_CreateFunction     | 用于创建JavaScript函数,用于从JavaScript环境中调用C/C++代码中的函数, 需要设置到一个js对象中才可以进行调用。 |\",\"19\":\"\",\"20\":\"## 使用示例\",\"21\":\"\",\"22\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"23\":\"\"}",
      "修改建议": "混用了'js对象'和'JS对象'概念",
      "更改后示例": "OH_JSVM_CreateFunction     | 用于创建JavaScript函数,用于从JavaScript环境中调用C/C++代码中的函数, 需要设置到一个JS对象中才可以进行调用。",
      "触发条件": "同一术语在文档中存在大小写不一致（如\"js\"与\"JS\"混用）且上下文已存在统一表达形式（如参考句中的\"JS对象\"）。"
    },
    {
      "defect_id": 370988,
      "sentence": "## ArkTS侧调用C/C++方法实现",
      "reference_sentence": "此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口，从而实现跨语言交互为例，呈现使用JSVM-API进行跨语言交互的流程。",
      "line_num": 211,
      "context": "{\"206\":\"  \",\"207\":\"  extern \\\"C\\\" __attribute__((constructor)) void RegisterEntryModule(void) { napi_module_register(&demoModule); }\",\"208\":\"  ```\",\"209\":\"  <!-- @[oh_jsvm_process](K3278code/DocsSample/ArkTs/JSVMAPI/JsvmProcess/entry/src/main/cpp/hello.cpp) -->\",\"210\":\"  \",\"211\":\"## ArkTS侧调用C/C++方法实现\",\"212\":\"\",\"213\":\"```ts\",\"214\":\"import hilog from '@ohos.hilog';\",\"215\":\"// 通过import的方式，引入Native能力。\",\"216\":\"import napitest from 'libentry.so';\"}",
      "修改建议": "术语不一致，使用了‘ArkTS侧’与‘ArkTS/JS侧’两种不同的表述。",
      "更改后示例": "## ArkTS/JS侧调用C/C++方法实现",
      "触发条件": "同一文档中同一技术术语存在多种不一致表述（如“ArkTS侧”与“ArkTS/JS侧”），且其他章节已建立标准术语（如“ArkTS/JS侧”）时触发。\n\n识别模式：\n1. 术语对比：检测同一概念是否出现不同缩略形式（如单独术语\"ArkTS\"与复合术语\"ArkTS/JS\"）\n2. 上下文验证：检查文档其他章节（如参考句）是否已确立标准术语用法（如\"ArkTS/JS侧\"被多次规范使用）"
    },
    {
      "defect_id": 370819,
      "sentence": "1. Q：`OH_JSVM_GetCbInfo`的无法获取JS函数参数",
      "reference_sentence": "2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`",
      "line_num": 85,
      "context": "{\"80\":\"\",\"81\":\"   A：检查HandleScope的使用是否正确，见[生命周期管理](jsvm-guidelines.md#生命周期管理)\",\"82\":\"\",\"83\":\"## JSVM-API执行失败类\",\"84\":\"\",\"85\":\"1. Q：`OH_JSVM_GetCbInfo`的无法获取JS函数参数\",\"86\":\"\",\"87\":\"   A：检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)\",\"88\":\"\",\"89\":\"2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`\",\"90\":\"\"}",
      "修改建议": "混用了'无法'与'失败'，建议统一使用'失败'",
      "更改后示例": "1. Q：`OH_JSVM_GetCbInfo`调用失败，无法获取JS函数参数",
      "触发条件": "同一文档中存在混用\"无法\"与\"失败\"等不同动词描述函数调用问题，且上下文已有统一使用\"调用失败\"的规范表达时。识别模式为：问题描述句中出现\"无法获取/执行\"等非标准表达，而参考案例采用\"函数调用失败\"结构(动词前置+结果状态)。"
    },
    {
      "defect_id": 372805,
      "sentence": "判断一个 JavaScript 对象是否为 Arraybuffer 类型对象。",
      "reference_sentence": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象。",
      "line_num": 79,
      "context": "{\"74\":\"```\",\"75\":\"<!-- @[oh_jsvm_get_arraybuffer_info](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTs/JSVMAPI/JsvmUsageGuide/JsvmAboutArraybuffer/getarraybufferinfo/src/main/cpp/hello.cpp) -->\",\"76\":\"\",\"77\":\"### OH_JSVM_IsArraybuffer\",\"78\":\"\",\"79\":\"判断一个 JavaScript 对象是否为 Arraybuffer 类型对象。\",\"80\":\"\",\"81\":\"cpp 部分代码\",\"82\":\"\",\"83\":\"```cpp\",\"84\":\"// hello.cpp\"}",
      "修改建议": "混用了 `Arraybuffer` 和 `ArrayBuffer`，术语大小写不一致。",
      "更改后示例": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象。",
      "触发条件": "当同一术语在文档中出现大小写不一致（如`Arraybuffer`与`ArrayBuffer`混用），或与官方技术规范/上下文标准命名（如`ArrayBuffer`）不符时触发。\n\n识别模式：通过对比术语在文档内其他位置或技术标准中的拼写形式（如首字母大写、驼峰命名等），检测是否存在非一致的大小写变体（如全小写、错误驼峰）。"
    },
    {
      "defect_id": 371050,
      "sentence": "基于虚拟机的起始快照，创建一个新的环境",
      "reference_sentence": "基于虚拟机的启动快照，创建一个新的环境",
      "line_num": 18,
      "context": "{\"13\":\"## 接口说明\",\"14\":\"\",\"15\":\"| 接口                       | 功能说明                       |\",\"16\":\"|----------------------------|-------------------------------|\",\"17\":\"| OH_JSVM_CreateSnapshot     | 用于创建虚拟机的启动快照        |\",\"18\":\"|OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的起始快照，创建一个新的环境 |\",\"19\":\"## 使用示例\",\"20\":\"\",\"21\":\"### OH_JSVM_CreateSnapshot & OH_JSVM_CreateEnvFromSnapshot\",\"22\":\"\",\"23\":\"用于创建和使用虚拟机的启动快照。\"}",
      "修改建议": "混用了'起始快照'和'启动快照'概念",
      "更改后示例": "基于虚拟机的启动快照，创建一个新的环境",
      "触发条件": "当同一技术概念在相邻或相关段落中出现术语不一致（如\"起始快照\"与\"启动快照\"），且存在明确上下文参考（如接口定义、功能说明）要求术语统一时触发。\n\n识别模式：\n1. 核心术语在相近位置存在多版本表达（如接口说明与接口示例中的名词差异）\n2. 上下文存在权威术语引用（如接口名称/功能描述已明确定义\"启动快照\"）\n3. 术语差异出现在同一技术场景描述中（如虚拟机快照管理模块）"
    },
    {
      "defect_id": 371109,
      "sentence": "释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "reference_sentence": "释放由 JSVM 接口生成的 缓存。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "line_num": 23,
      "context": "{\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"19\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。 |\",\"20\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"21\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是一个 wasm module。                                                             |\",\"22\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。                    |\",\"23\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"24\":\"\",\"25\":\"## code cache 校验规格说明\",\"26\":\"| 规格        | 规格说明                                         |\",\"27\":\"| ---------- | ------------------------------------------------ |\",\"28\":\"| 完整性校验  | 由用户保证                                        |\"}",
      "修改建议": "混用了`cache`和`缓存`概念",
      "更改后示例": "释放由 JSVM 接口生成的 缓存。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "触发条件": "同一技术术语在中文文档中同时存在英文原词和中文翻译混用（如\"cache\"与\"缓存\"交替出现），且上下文未保持术语表达统一时触发。\n\n识别模式：\n1. 术语中英混用检测：在相邻段落或同一技术描述中，检测同一概念是否同时存在英文术语（如\"cache\"）和中文直译（如\"缓存\"）\n2. 上下文一致性验证：检查参考文档中该术语的标准表达形式（如参考句显示统一使用\"缓存\"），对比问题句是否存在偏离\n3. 技术参数关联性：当术语直接关联API参数命名（如\"cacheType/cacheData\"）时，需特别验证参数描述文本的术语一致性"
    },
    {
      "defect_id": 372857,
      "sentence": "解包先前封装在JavaScript对象中的原生实例",
      "reference_sentence": "在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例",
      "line_num": 212,
      "context": "{\"207\":\"\",\"208\":\"在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例\",\"209\":\"\",\"210\":\"### OH_JSVM_Unwrap\",\"211\":\"\",\"212\":\"解包先前封装在JavaScript对象中的原生实例\",\"213\":\"\",\"214\":\"### OH_JSVM_RemoveWrap\",\"215\":\"\",\"216\":\"解包先前封装在JavaScript对象中的原生实例并释放封装\",\"217\":\"\"}",
      "修改建议": "前后句子不一致，应保持用词一致。",
      "更改后示例": "在JavaScript对象中解包先前封装的原生实例",
      "触发条件": "同一文档中相邻或相关句子的相同动作描述存在介词结构位置不一致（如\"在...中\"前置/后置差异），或相同动词搭配的关键状语成分语序不统一时触发。  \n\n识别模式：  \n1. 比较动词短语结构（如\"在X中封装Y\" vs\"解包Y在X中\"）  \n2. 检测相同操作链（封装/解包）中是否保持\"在+对象+方位词\"的固定状语位置  \n3. 验证核心动词（解包/封装）与关键技术名词（JavaScript对象/原生实例）的修饰关系是否镜像对称"
    },
    {
      "defect_id": 372806,
      "sentence": "检查给定的 ArrayBuffer 是否已被分离。",
      "reference_sentence": "检查给定的 ArrayBuffer 是否已被分离(detached)。",
      "line_num": 129,
      "context": "{\"124\":\"\",\"125\":\"调用 ArrayBuffer 对象的 Detach 操作。\",\"126\":\"\",\"127\":\"### OH_JSVM_IsDetachedArraybuffer\",\"128\":\"\",\"129\":\"检查给定的 ArrayBuffer 是否已被分离。\",\"130\":\"\",\"131\":\"cpp 部分代码\",\"132\":\"\",\"133\":\"```cpp\",\"134\":\"// hello.cpp\"}",
      "修改建议": "混用了 `分离` 和 `分离(detached)`，术语不一致。",
      "更改后示例": "检查给定的 ArrayBuffer 是否已被分离(detached)。",
      "触发条件": "同一技术术语在相邻语境中同时存在纯中文和带括号英文两种形式（如\"分离\"和\"分离(detached)\"），且参考句已确立带括号英文的标准表达形式。\n\n识别模式：通过对比术语在问题句与参考句/上下文中的呈现形式差异，检测是否违反\"首次定义后保持统一\"或\"技术术语强制中英对照\"的文档规范。"
    },
    {
      "defect_id": 371011,
      "sentence": "修改微任务执行策略,通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。",
      "reference_sentence": "设置微任务执行策略",
      "line_num": 141,
      "context": "{\"136\":\"```\",\"137\":\"JSVM API TEST: Called with instance [object Object]\",\"138\":\"JSVM API TEST: Called Finally\",\"139\":\"```\",\"140\":\"### OH_JSVM_SetMicrotaskPolicy\",\"141\":\"修改微任务执行策略,通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。\",\"142\":\"\",\"143\":\"微任务策略：\",\"144\":\"- JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT ： 微任务在用户调用 OH_JSVM_PerformMicrotaskCheckpoint 后执行\",\"145\":\"- JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO： 微任务在 JS 调用栈为空时自动执行\",\"146\":\"\"}",
      "修改建议": "混用了'修改微任务执行策略'和'设置微任务执行策略'，表述不一致",
      "更改后示例": "设置微任务执行策略，通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。",
      "触发条件": "同一上下文中对同一操作或概念使用不一致的动词表述（如\"修改\"与\"设置\"混用），且存在明确的参考表述模式（如标题/前文已使用\"设置\"）。\n\n识别模式：\n1. 动词冲突检测：在相邻段落/同一功能描述中，检测描述同一操作的关键动词（如修改/设置/配置）是否发生变更\n2. 上下文锚定匹配：当存在明确的参考表述（如标题\"OH_JSVM_SetMicrotaskPolicy\"含\"Set/设置\"），检查正文描述是否与标题动词保持词根一致性\n3. 术语重复验证：对同一技术概念（如微任务执行策略）的操作描述，要求在同一语义单元内保持完全一致的动词+名词组合"
    },
    {
      "defect_id": 372719,
      "sentence": "若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建数组，将数组传递给 JavaScript 层。",
      "reference_sentence": "使用 JSVM-API 接口进行数组（array）相关开发时，调用相关接口可以在 JSVM 模块中直接操作和处理 JavaScript 中的数组。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"使用 JSVM-API 接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在 JSVM 模块中如何与 JavaScript 数组交互非常重要。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **数组的创建**：若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建数组，将数组传递给 JavaScript 层。\",\"12\":\"- **数组相关操作**：在 JSVM 模块中通过对应的接口获取 JavaScript 数组的长度、检索指定索引处的元素以及设置指定索引处的元素值，从而实现 JSVM 模块与 JavaScript 数组的交互。\",\"13\":\"- **TypedArray**：JavaScript 中的 TypedArray 是一种用来描述二进制数据的类数组数据视图，可以简单理解为一种指定元素类型的数组，TypedArray 没有直接构造器，但是可以用它的子类构造器构造 TypedArray 类型的数据。TypedArray 的子类有：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array 等。\",\"14\":\"- **ArrayBuffer**：ArrayBuffer 是固定长度的二进制数据缓冲区。\",\"15\":\"- **DataView**：DataView 是 JavaScript 中的一种视图，是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。\",\"16\":\"\"}",
      "修改建议": "混用了'数组'和'JavaScript 数组'，应保持用词一致",
      "更改后示例": "若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建 JavaScript 数组，将数组传递给 JavaScript 层。",
      "触发条件": "当同一技术概念在同一段落或上下文中出现全称与简称混用（如\"JavaScript 数组\"与\"数组\"交替出现），且未通过括号说明/首次定义时触发；当接口参数/返回值类型描述与接口名称隐含的类型信息不一致时触发（如OH_JSVM_CreateArray接口的\"数组\"未明确为\"JavaScript 数组\"）。\n\n识别模式：\n1. 检测核心技术名词是否在相邻语句中存在完整形态与省略形态的交替使用（如\"JavaScript 数组\"→\"数组\"）\n2. 验证接口名称中的技术标识（如JSVM）是否与参数描述中的类型修饰符（如JavaScript）保持语义连贯\n3. 对比上下文标准表述（如参考句中的\"JavaScript中的数组\"）判断是否存在术语降级风险"
    },
    {
      "defect_id": 372858,
      "sentence": "解包先前封装在JavaScript对象中的原生实例并释放封装",
      "reference_sentence": "在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例",
      "line_num": 216,
      "context": "{\"211\":\"\",\"212\":\"解包先前封装在JavaScript对象中的原生实例\",\"213\":\"\",\"214\":\"### OH_JSVM_RemoveWrap\",\"215\":\"\",\"216\":\"解包先前封装在JavaScript对象中的原生实例并释放封装\",\"217\":\"\",\"218\":\"cpp部分代码\",\"219\":\"\",\"220\":\"```cpp\",\"221\":\"// hello.cpp\"}",
      "修改建议": "前后句子不一致，应保持用词一致。",
      "更改后示例": "在JavaScript对象中解包先前封装的原生实例并释放封装",
      "触发条件": "同一上下文或相邻句子中，相同动作（如封装/解包）的介词结构（如\"在...中\"）位置不一致，或核心动词（如\"解包\"）与修饰语（如\"释放封装\"）存在逻辑断裂时触发。\n\n识别模式：1）检测介词短语位置差异（如问题句将\"在JavaScript对象中\"置于动词后，而参考句置于动词前）；2）验证复合动作描述中是否存在冗余表述（如\"释放封装\"与\"解包\"语义重复）；3）对比相邻API说明句式结构（如OH_JSVM_Unwrap()的\"解包原生实例\"简洁表述）。"
    },
    {
      "defect_id": 372691,
      "sentence": "将对象字符串化，并将结果存储在JSVM字符串对象。",
      "reference_sentence": "将对象字符串化，并将结果存储在JSVM字符串对象。",
      "line_num": 16,
      "context": "{\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                       | 功能说明                       |\",\"14\":\"|----------------------------|--------------------------------|\",\"15\":\"| OH_JSVM_JsonParse          | 解析JSON字符串，并将结果存储在JSON对象。 |\",\"16\":\"| OH_JSVM_JsonStringify      | 将对象字符串化，并将结果存储在JSVM字符串对象。 |\",\"17\":\"\",\"18\":\"## 使用示例\",\"19\":\"\",\"20\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"21\":\"\"}",
      "修改建议": "用词一致，但建议使用更规范的表述",
      "更改后示例": "将对象字符串化，并将结果存储在JSVM字符串对象中。",
      "触发条件": "当句子中出现“存储”动词后接“在...对象”结构且缺少方位词“中”时触发，需匹配“存储在[某对象]”模式并检测结尾是否存在方位词缺失。"
    },
    {
      "defect_id": 372855,
      "sentence": "OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例并释放封装。",
      "reference_sentence": "OH_JSVM_Unwrap         | 解包先前封装在JavaScript对象中的原生实例。",
      "line_num": 23,
      "context": "{\"18\":\"| OH_JSVM_NewInstance   | 通过给定的构造函数，构建一个实例。|\",\"19\":\"| OH_JSVM_GetNewTarget  | 获取函数的元属性new.target。|\",\"20\":\"| OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持。|\",\"21\":\"| OH_JSVM_Wrap           | 在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例。|\",\"22\":\"| OH_JSVM_Unwrap         | 解包先前封装在JavaScript对象中的原生实例。|\",\"23\":\"| OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例并释放封装。|\",\"24\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\"}",
      "修改建议": "混用了'解包'与'移除'，导致表意模糊。",
      "更改后示例": "OH_JSVM_RemoveWrap     | 移除先前封装在JavaScript对象中的原生实例并释放封装。",
      "触发条件": "同一功能模块中动词术语存在多译混用（如\"解包\"与\"移除\"并存），且相邻条目已建立标准译法对应关系（如Unwrap→解包，Remove→移除）。\n\n识别模式：\n1. 动词冲突检测：在功能描述中，核心动词与API命名中的英文动词存在语义偏离（如Remove对应\"解包\"）\n2. 上下文一致性校验：相邻条目已形成固定术语对照表（如第21行Wrap→封装、第22行Unwrap→解包），后续条目需延续该映射关系\n3. 操作链断裂识别：当同一操作链（封装-解包-移除）出现术语断裂时（如用\"解包\"描述Remove操作），需强制保持动词一致性"
    },
    {
      "defect_id": 371010,
      "sentence": "启动任务队列，执行任务。",
      "reference_sentence": "启动任务队列的运行",
      "line_num": 26,
      "context": "{\"21\":\"\",\"22\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"23\":\"注意：Wasm字节码需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"24\":\"### OH_JSVM_PumpMessageLoop && OH_JSVM_PerformMicrotaskCheckpoint\",\"25\":\"\",\"26\":\"启动任务队列，执行任务。\",\"27\":\"\",\"28\":\"cpp代码\",\"29\":\"\",\"30\":\"```cpp\",\"31\":\"#include <chrono>\"}",
      "修改建议": "混用了'启动任务队列'和'启动任务队列的运行'，表述不一致",
      "更改后示例": "启动任务队列的运行，执行任务。",
      "触发条件": "同一上下文或相邻句子中对同一操作/概念存在不同动词短语表述（如\"启动X\"与\"启动X的运行\"），且存在已确立的标准表达形式（如参考句中的\"启动X的运行\"）。\n\n识别模式：检查动词+宾语结构是否在相邻语句中存在术语差异（如完整动作描述vs.简化描述），并通过上下文确认是否存在明确的标准表达需要统一。"
    },
    {
      "defect_id": 372945,
      "sentence": "OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript Promise",
      "reference_sentence": "OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript promise",
      "line_num": 27,
      "context": "{\"22\":\"| 接口                       | 功能说明                       |\",\"23\":\"|----------------------------|--------------------------------|\",\"24\":\"| OH_JSVM_IsPromise            | 查询Promise是否为Promise对象|\",\"25\":\"| OH_JSVM_CreatePromise        | 创建一个延迟对象和一个JavaScript promise|\",\"26\":\"| OH_JSVM_ResolveDeferred      | 通过与之关联的延迟对象来解析JavaScript promise|\",\"27\":\"| OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript Promise|\",\"28\":\"| OH_JSVM_PromiseRegisterHandler | 为 Promise 创建兑现或拒绝后的回调 |\",\"29\":\"\",\"30\":\"## 使用示例\",\"31\":\"\",\"32\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\"}",
      "修改建议": "用词不一致，'Promise'与'promise'大小写不一致。",
      "更改后示例": "OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript promise",
      "触发条件": "同一术语在文档中存在大小写不一致（如\"Promise\"与\"promise\"），且上下文存在已确定的标准形式（如参考句中的小写\"promise\"）。\n\n识别模式：\n1. 检测相邻条目中相同技术术语（如promise）的大小写形态\n2. 对比上下文已建立的统一格式（如第25/26行已使用小写），当新条目出现首字母大写时触发规则\n3. 验证术语在技术规范中的标准写法（JavaScript术语中promise通常小写）"
    },
    {
      "defect_id": 372738,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 548,
      "context": "{\"543\":\"```\",\"544\":\"### OH_JSVM_GetDataviewInfo\",\"545\":\"\",\"546\":\"获取 Dataview 对象的信息。\",\"547\":\"\",\"548\":\"cpp 部分代码\",\"549\":\"\",\"550\":\"```cpp\",\"551\":\"// hello.cpp\",\"552\":\"#include \\\"napi/native_api.h\\\"\",\"553\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "同一文档中交替使用术语的不同大小写形式（如\"cpp\"与\"C++\"混用）或存在同一概念的不同拼写变体，且在相邻段落/代码注释等上下文中形成不一致表达时触发。"
    },
    {
      "defect_id": 372734,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 160,
      "context": "{\"155\":\"```\",\"156\":\"### OH_JSVM_CreateTypedarray\",\"157\":\"\",\"158\":\"在现有的 ArrayBuffer上 创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型。\",\"159\":\"\",\"160\":\"cpp 部分代码\",\"161\":\"\",\"162\":\"```cpp\",\"163\":\"// hello.cpp\",\"164\":\"#include \\\"napi/native_api.h\\\"\",\"165\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "当同一术语在文档中存在全称（如\"C++\"）和缩写（如\"cpp\"）混用，且上下文未明确区分技术术语与代码标识符时。识别模式为检测到同一概念使用不同大小写或拼写形式（如C++/cpp）出现在相邻段落或相同技术语境中。"
    },
    {
      "defect_id": 373436,
      "sentence": "将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。",
      "reference_sentence": "将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。",
      "line_num": 22,
      "context": "{\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\",\"23\":\"| napi_get_value_double | 将ArkTS环境中获取的number类型数据转为Node-API模块中的double类型数据。 |\",\"24\":\"| napi_create_int32 | 将Node-API模块中的int32_t类型转换为ArkTS环境中number类型。 |\",\"25\":\"| napi_create_uint32 | 将Node-API模块中的uint32_t类型转换为ArkTS环境中number类型。 |\",\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\",\"27\":\"| napi_create_double | 将Node-API模块中的double类型转换为ArkTS环境中number类型。 |\"}",
      "修改建议": "混用了“获取”和“转为”，应保持句式一致。",
      "更改后示例": "将ArkTS环境中number类型数据转为Node-API模块中的int64类型数据。",
      "触发条件": "当同一结构中出现冗余动词（如\"获取\"）导致句式与其他并列条目不一致，或在相同语法位置存在动词使用不统一时。"
    },
    {
      "defect_id": 372899,
      "sentence": "在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。",
      "reference_sentence": "在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作的功能，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。这些操作是在处理JavaScript对象时非常常见的，提供了一种与JavaScript对象交互的方式。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM接口开发中，经常需要定义和操作对象。例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。\",\"10\":\"\",\"11\":\"- **接口（API）**：接口定义了组件之间的交互协议，包括输入参数、输出结果以及可能的错误处理。通过接口，组件可以相互调用和交换数据，而无需了解对方的内部实现细节。\",\"12\":\"- **对象（Object）**：在JavaScript，对象是一种复合数据类型，允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。\",\"13\":\"\",\"14\":\"## 接口说明\"}",
      "修改建议": "“相兼容”与“兼容”混用，建议统一使用“兼容”",
      "更改后示例": "在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法兼容。",
      "触发条件": "同一文档中同一概念存在\"冗余前缀+核心词\"（如\"相兼容\"）和\"核心词单独使用\"（如\"兼容\"）两种表达形式时。\n\n识别模式：当句子中出现\"相X\"类冗余结构（如\"相兼容\"），且上下文存在单独使用核心词（如\"兼容\"）的实例时，判定为表达不一致。需通过文本匹配算法检测同一语义单元的不同表达变体（如\"兼容\"与\"相兼容\"），并结合术语库验证标准表达形式。"
    },
    {
      "defect_id": 372733,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 99,
      "context": "{\"94\":\"```\",\"95\":\"### OH_JSVM_CreateArrayWithLength\",\"96\":\"\",\"97\":\"创建一个指定长度的 JavaScript 数组对象。\",\"98\":\"\",\"99\":\"cpp 部分代码：\",\"100\":\"\",\"101\":\"```cpp\",\"102\":\"// hello.cpp\",\"103\":\"#include \\\"napi/native_api.h\\\"\",\"104\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "检测到技术术语存在大小写或拼写形式不一致（如\"cpp\"与\"C++\"混用），且同一概念在相邻上下文中出现多种表达形式时触发。"
    },
    {
      "defect_id": 372922,
      "sentence": "用于获取JavaScript null",
      "reference_sentence": "用于获取给定布尔值的JavaScript单例对象。",
      "line_num": 379,
      "context": "{\"374\":\"JSVM OH_JSVM_GetGlobal success\",\"375\":\"```\",\"376\":\"\",\"377\":\"### OH_JSVM_GetNull\",\"378\":\"\",\"379\":\"用于获取JavaScript null\",\"380\":\"\",\"381\":\"cpp 部分代码\",\"382\":\"\",\"383\":\"```cpp\",\"384\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，应该统一使用'用于...的作用'形式",
      "更改后示例": "用于获取JavaScript null对象",
      "触发条件": "当文档中的句子以“用于获取...”开头，但宾语部分缺少明确的对象类型描述（如“对象”），且上下文存在同类型条目采用“用于获取...对象”的固定句式时。"
    },
    {
      "defect_id": 372900,
      "sentence": "判断一个对象是否是某个构造函数的实例。",
      "reference_sentence": "判断一个对象是否是某个构造函数的实例。",
      "line_num": 23,
      "context": "{\"18\":\"| OH_JSVM_GetPrototype         | 获取给定JavaScript对象的原型。             |\",\"19\":\"| OH_JSVM_CreateObject         | 创建一个默认的JavaScript Object对象。                   |\",\"20\":\"| OH_JSVM_ObjectFreeze         | 冻结给定的对象，防止向其添加新属性，删除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。                             |\",\"21\":\"| OH_JSVM_ObjectSeal           |  密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。                             |\",\"22\":\"| OH_JSVM_Typeof                | 返回JavaScript对象的类型。  |\",\"23\":\"| OH_JSVM_Instanceof            | 判断一个对象是否是某个构造函数的实例。    |\",\"24\":\"| OH_JSVM_TypeTagObject       | 将type_tag指针的值与JavaScript对象或外部对象相关联。                  |\",\"25\":\"| OH_JSVM_CheckObjectTypeTag | 检查给定的类型标签是否与对象上的类型标签匹配。 |\",\"26\":\"| OH_JSVM_CreateSymbol         | 根据给定的描述符创建一个Symbol对象。                     |\",\"27\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol，如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol。 |\",\"28\":\"| OH_JSVM_CreateExternal       | 创建一个包装了外部指针的JavaScript对象。               |\"}",
      "修改建议": "“判断”与“检查”混用，建议统一使用“检查”",
      "更改后示例": "检查一个对象是否是某个构造函数的实例。",
      "触发条件": "当同一文档中相邻或相关条目对相同操作使用不同动词（如“判断”与“检查”），且上下文存在统一用词倾向（如其他条目已使用“检查”）时触发。  \n识别模式：通过对比相邻条目动词选择（如问题句的“判断”与上下文第25行的“检查”），检测同语义动作表述不一致，并结合文档已有高频用词倾向判断需修复对象。"
    },
    {
      "defect_id": 372736,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 373,
      "context": "{\"368\":\"```\",\"369\":\"### OH_JSVM_GetArrayLength\",\"370\":\"\",\"371\":\"返回 Array 对象的长度。\",\"372\":\"\",\"373\":\"cpp 部分代码\",\"374\":\"\",\"375\":\"```cpp\",\"376\":\"// hello.cpp\",\"377\":\"#include \\\"napi/native_api.h\\\"\",\"378\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "同一文档中交替出现技术术语的不同表达形式（如\"cpp\"与\"C++\"），且存在至少一处使用该术语的规范形式（如\"C++\"）作为参照依据。具体表现为非代码块的正文内容中出现非规范缩写形式（如小写\"cpp\"），与上下文或文档其他位置使用的规范形式（如\"C++\"）形成显性冲突。"
    },
    {
      "defect_id": 373329,
      "sentence": "本接口是Node-API中用于创建并复制数据到Buffer对象的函数。它可以在Node-API模块中创建一个新的Buffer对象，并将指定的数据复制到该Buffer对象中。",
      "reference_sentence": "此接口用于创建Buffer对象。Buffer对象是用于在Node-API模块中操作二进制数据的一种特殊类型。",
      "line_num": 75,
      "context": "{\"70\":\"}\",\"71\":\"```\",\"72\":\"\",\"73\":\"### napi_create_buffer_copy\",\"74\":\"\",\"75\":\"本接口是Node-API中用于创建并复制数据到Buffer对象的函数。它可以在Node-API模块中创建一个新的Buffer对象，并将指定的数据复制到该Buffer对象中。\",\"76\":\"\",\"77\":\"cpp部分代码\",\"78\":\"\",\"79\":\"```cpp\",\"80\":\"#include <string>\"}",
      "修改建议": "重复定义了“Buffer对象”",
      "更改后示例": "本接口用于创建并复制数据到Buffer对象。",
      "触发条件": "同一术语在相邻句子中被重复定义或冗余解释，导致上下文出现不必要的概念复述。\n\n识别模式：\n1. 核心名词（如\"Buffer对象\"）首次出现时已附带完整定义\n2. 后续相邻句子中重复使用\"的\"字结构（如\"的Buffer对象\"）进行二次定义\n3. 存在明显的语义重复结构（如\"创建并复制数据到Buffer对象\"与\"创建新的Buffer对象\"的叠加说明）"
    },
    {
      "defect_id": 373435,
      "sentence": "将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。",
      "reference_sentence": "将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\",\"23\":\"| napi_get_value_double | 将ArkTS环境中获取的number类型数据转为Node-API模块中的double类型数据。 |\",\"24\":\"| napi_create_int32 | 将Node-API模块中的int32_t类型转换为ArkTS环境中number类型。 |\",\"25\":\"| napi_create_uint32 | 将Node-API模块中的uint32_t类型转换为ArkTS环境中number类型。 |\",\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\"}",
      "修改建议": "混用了“获取”和“转为”，应保持句式一致。",
      "更改后示例": "将ArkTS环境中number类型数据转为Node-API模块中的int32类型数据。",
      "触发条件": "当同一语境下的多个并列结构出现动词使用不一致（如同时存在\"获取\"和\"转为\"动作描述），且存在已验证的标准句式作为参照时。"
    },
    {
      "defect_id": 372732,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"### OH_JSVM_CreateArray\",\"42\":\"\",\"43\":\"创建一个新的 JavaScript 数组对象。\",\"44\":\"\",\"45\":\"cpp 部分代码\",\"46\":\"\",\"47\":\"```cpp\",\"48\":\"// hello.cpp\",\"49\":\"#include \\\"napi/native_api.h\\\"\",\"50\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "同一文档中交替使用同一术语的不同形式（如\"C++\"的缩写\"cpp\"与标准名称\"C++\"混用），且存在至少两个不一致实例。  \n\n识别模式：  \n1. 检测到技术术语存在大小写变体（如\"cpp\"与\"C++\"）  \n2. 上下文存在相同术语的标准化写法对比（如参考句使用\"cpp\"但修复建议改为\"C++\"）  \n3. 术语变体出现在相邻段落或相同功能模块描述中（如问题句与代码注释区域共存不一致写法）"
    },
    {
      "defect_id": 376466,
      "sentence": "证书本数。",
      "reference_sentence": "证书数据的指针。",
      "line_num": 44,
      "context": "{\"39\":\"\",\"40\":\"```\",\"41\":\"uint32_t OH_Huks_CertChain::certsCount\",\"42\":\"```\",\"43\":\"**描述**\",\"44\":\"证书本数。\"}",
      "修改建议": "混用了'本数'和'数量'，应该使用一致的术语。",
      "更改后示例": "证书数量。",
      "触发条件": "同一术语在文档中存在多个不一致的中文表达（如\"数量\"与\"本数\"混用），且存在明确参考术语（如代码变量名certsCount对应\"数量\"）时触发。\n\n识别模式：通过对比代码变量名/接口参数（如certsCount）的中英对应关系，检测其相邻描述文本（如\"证书本数\"）是否采用非匹配译法。当同一概念出现两种及以上中文表达且存在参考基准时，判定为术语不一致。"
    },
    {
      "defect_id": 373913,
      "sentence": "创建并获取一个带文本信息的ArkTS TypeError。",
      "reference_sentence": "创建并获取一个带文本信息的ArkTS TypeError。",
      "line_num": 287,
      "context": "{\"282\":\"}\",\"283\":\"```\",\"284\":\"\",\"285\":\"### napi_throw_type_error\",\"286\":\"\",\"287\":\"创建并获取一个带文本信息的ArkTS TypeError。\",\"288\":\"\",\"289\":\"cpp部分代码\",\"290\":\"\",\"291\":\"```cpp\",\"292\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了'创建'和'获取'，建议统一使用'创建'。",
      "更改后示例": "创建一个带文本信息的ArkTS TypeError。",
      "触发条件": "同一指令中混用多个不同动作动词（如\"创建\"和\"获取\"），且上下文未体现多步骤操作需求时触发；动词短语存在语义重复或矛盾（如同时要求新建和获取已有对象）时触发。"
    },
    {
      "defect_id": 373438,
      "sentence": "将ArkTS value转为Node-API模块中的int32类型数据。",
      "reference_sentence": "将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。",
      "line_num": 88,
      "context": "{\"83\":\"hilog.info(0x0000, 'Node-API', 'get_value_uint32_number %{public}d', testNapi.getValueUint32<number>(100));\",\"84\":\"```\",\"85\":\"\",\"86\":\"### napi_get_value_int32\",\"87\":\"\",\"88\":\"将ArkTS value转为Node-API模块中的int32类型数据。\",\"89\":\"\",\"90\":\"cpp部分代码\",\"91\":\"\",\"92\":\"```cpp\",\"93\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了“转为”和“转为”，应保持句式一致。",
      "更改后示例": "将ArkTS环境中number类型数据转为Node-API模块中的int32类型数据。",
      "触发条件": "同一文档中存在相同句式结构但关键术语或动词使用不一致（如\"ArkTS value\"与\"ArkTS环境中number类型数据\"混用，或\"转为\"与其他动词形式交替出现），且上下文存在可供对齐的参考句式时触发。"
    },
    {
      "defect_id": 372735,
      "sentence": "cpp部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 265,
      "context": "{\"260\":\"```\",\"261\":\"### OH_JSVM_CreateDataview\",\"262\":\"\",\"263\":\"在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象，DataView 对象在底层数据缓冲区上提供类似数组的视图。\",\"264\":\"\",\"265\":\"cpp部分代码\",\"266\":\"\",\"267\":\"```cpp\",\"268\":\"static int DIFF_VALUE_FOUR = 4;\",\"269\":\"static int DIFF_VALUE_TWELVE = 12;\",\"270\":\"// OH_JSVM_CreateDataview的样例方法\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "同一文档中交替出现编程语言的缩写形式（如\"cpp\"）和官方名称（如\"C++\"），且未保持术语统一性时触发。\n\n识别模式：\n1. 检测到技术术语存在大小写变体（如C++/cpp）或缩写/全称混用\n2. 上下文存在明确的参考标准（如代码块标记```cpp与正文描述形成对照）\n3. 同一段落/章节出现术语的多种表达形式（如问题句中的\"cpp\"与建议修复的\"C++\"相邻出现）"
    },
    {
      "defect_id": 372737,
      "sentence": "cpp 部分代码",
      "reference_sentence": "cpp 部分代码",
      "line_num": 434,
      "context": "{\"429\":\"```\",\"430\":\"### OH_JSVM_GetTypedarrayInfo\",\"431\":\"\",\"432\":\"获取 TypedArray（类型化数组）对象的信息。\",\"433\":\"\",\"434\":\"cpp 部分代码\",\"435\":\"\",\"436\":\"```cpp\",\"437\":\"// hello.cpp\",\"438\":\"#include \\\"napi/native_api.h\\\"\",\"439\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "混用了“cpp”和“C++”概念",
      "更改后示例": "C++ 部分代码",
      "触发条件": "同一文档中交替出现技术术语的缩写形式（如\"cpp\"）与标准全称形式（如\"C++\"），且上下文存在已确立的行业标准术语（如\"C++\"为官方名称）时触发。\n\n识别模式：\n1. 术语变体检测：识别代码语言名称的非常规写法（如全小写\"cpp\"）与标准写法（\"C++\"）共存\n2. 上下文冲突验证：当代码块标记（如```cpp）与正文描述（应保持\"C++\"写法）出现术语形式差异时\n3. 行业标准对照：匹配技术术语的ISO/官方命名规范（如C++标准名称为\"C++\"而非\"cpp\"）"
    },
    {
      "defect_id": 374195,
      "sentence": "如果任务全部完成，则关闭copyWorker1",
      "reference_sentence": "如果任务全部完成，则关闭copyWorker1",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"   copyWorker1.onmessage = async (e : MessageEvents) => {\",\"63\":\"     console.info('copyWorker1 onmessage:' + e.data);\",\"64\":\"     await asyncLock.lockAsync(() => {\",\"65\":\"       count1--;\",\"66\":\"       if (count1 == 0) {\",\"67\":\"         // 如果copyWorker1的任务全部完成，则关闭copyWorker1\",\"68\":\"         console.info('copyWorker1 close');\",\"69\":\"         copyWorker1.terminate();\",\"70\":\"       }\",\"71\":\"       sum--;\"}",
      "修改建议": "句式一致问题，应使用祈使句。",
      "更改后示例": "关闭copyWorker1",
      "触发条件": "当句子位于需要统一句式结构的指令性上下文（如代码注释、操作步骤）中，且存在混合使用祈使句与非祈使句（如条件陈述句）的情况时触发。\n\n识别模式：\n1. 上下文包含同类指令语句（如代码中的worker关闭操作）\n2. 目标句采用\"如果...则...\"的条件句式\n3. 相邻/同类语句使用祈使句式（如参考句的\"关闭copyWorker1\"）\n4. 语义表达重点落在操作行为而非条件判断时"
    },
    {
      "defect_id": 374440,
      "sentence": "3. 宿主线程定义注册及销毁的行为。",
      "reference_sentence": "3. 宿主线程定义注册及销毁的行为。",
      "line_num": 33,
      "context": "{\"28\":\"       emitter.off(1)\",\"29\":\"     })\",\"30\":\"   }\",\"31\":\"   ```\",\"32\":\"\",\"33\":\"3. 宿主线程定义注册及销毁的行为。\",\"34\":\"   - 注册：发起长时任务，并通过emitter接收监听数据。\",\"35\":\"   - 销毁：发送取消传感器监听的事件，并结束长时任务。\",\"36\":\"\",\"37\":\"   ```ts\",\"38\":\"   // Index.ets\"}",
      "修改建议": "销毁与删除混用",
      "更改后示例": "3. 宿主线程定义注册及删除的行为。",
      "触发条件": "同一文档或相邻上下文中，对同一操作或概念使用不一致的动词（如\"销毁\"与\"删除\"混用），或技术术语与代码示例中的实际方法名（如off/delete）存在表达冲突时触发。"
    },
    {
      "defect_id": 372955,
      "sentence": "用于对Promise关联的deferred对象进行解析，OH_JSVM_ResolveDeferred将其从挂起状态转换为已兑现状态，OH_JSVM_RejectDeferred将其从挂起状态转换为已拒绝状态。",
      "reference_sentence": "此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\r此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。",
      "line_num": 88,
      "context": "{\"83\":\"\",\"84\":\"OH_JSVM_CreatePromise用于创建一个Promise对象。\",\"85\":\"\",\"86\":\"### OH_JSVM_ResolveDeferred & OH_JSVM_RejectDeferred\",\"87\":\"\",\"88\":\"用于对Promise关联的deferred对象进行解析，OH_JSVM_ResolveDeferred将其从挂起状态转换为已兑现状态，OH_JSVM_RejectDeferred将其从挂起状态转换为已拒绝状态。\",\"89\":\"\",\"90\":\"cpp部分代码\",\"91\":\"\",\"92\":\"```cpp\",\"93\":\"// hello.cpp\"}",
      "修改建议": "混用了“挂起”和“pending”描述同一状态，以及“已兑现”和“fulfilled”，“已拒绝”和“rejected”描述同一结果。",
      "更改后示例": "用于对Promise关联的deferred对象进行解析，OH_JSVM_ResolveDeferred将其从pending（待定）状态转换为fulfilled（已兑现）状态，OH_JSVM_RejectDeferred将其从pending（待定）状态转换为rejected（已拒绝）状态。",
      "触发条件": "同一技术术语存在中文和英文混用（如\"挂起/pending\"），或同一概念在文档中使用了不同中文译名（如\"已兑现/fulfilled\"），且上下文存在已建立的标准术语对照关系。\n\n识别模式：通过以下特征组合检测：\n1. 同一段落/相邻段落出现同一概念的两种表达形式（如中文术语与括号英文）；\n2. 存在未保持术语对照关系的中英文交替使用（如前文用\"pending（待定）\"，后文单独使用\"挂起\"）；\n3. 关键状态机描述中出现非标准译名（如用\"挂起\"而非行业通用的\"待定\"翻译pending）。"
    },
    {
      "defect_id": 374192,
      "sentence": "如果所有任务全部完成，则关闭父Worker",
      "reference_sentence": "如果所有任务全部完成，则关闭父Worker",
      "line_num": 90,
      "context": "{\"85\":\"         // 如果copyWorker2的任务全部完成，则关闭copyWorker2\",\"86\":\"         console.info('copyWorker2 close')\",\"87\":\"         copyWorker2.terminate();\",\"88\":\"       }\",\"89\":\"       if (sum == 0) {\",\"90\":\"         // 如果所有任务全部完成，则关闭父Worker\",\"91\":\"         workerPort.close();\",\"92\":\"       }\",\"93\":\"     })\",\"94\":\"   }\",\"95\":\"\"}",
      "修改建议": "句式一致问题，应使用祈使句。",
      "更改后示例": "关闭父Worker",
      "触发条件": "当注释或说明性文本包含条件引导的复合句式（如“如果...则...”），且上下文存在使用祈使句的同类描述时，应触发该规则。识别模式为：检测到“如果...则...”条件状语结构，且相邻代码块/同类场景的注释采用无条件的祈使句式（如“关闭copyWorker2”）。"
    },
    {
      "defect_id": 374191,
      "sentence": "如果所有任务全部完成，则关闭父Worker",
      "reference_sentence": "如果所有任务全部完成，则关闭父Worker",
      "line_num": 73,
      "context": "{\"68\":\"         console.info('copyWorker1 close');\",\"69\":\"         copyWorker1.terminate();\",\"70\":\"       }\",\"71\":\"       sum--;\",\"72\":\"       if (sum == 0) {\",\"73\":\"         // 如果所有任务全部完成，则关闭父Worker\",\"74\":\"         workerPort.close();\",\"75\":\"       }\",\"76\":\"     })\",\"77\":\"   }\",\"78\":\"\"}",
      "修改建议": "句式一致问题，应使用祈使句。",
      "更改后示例": "关闭父Worker",
      "触发条件": "在代码注释或文档中存在使用条件句式（如“如果...则...”）的指令性语句，且上下文存在要求使用祈使句的规范或模式时触发。\n\n识别模式：\n1. 检测到包含条件关联词（如“如果”“则”）的复合句式\n2. 上下文存在明确的祈使句规范（如其他注释使用\"关闭...\"直接指令）\n3. 语句功能属于操作指令而非描述性说明\n4. 主谓结构完整但包含冗余条件引导词（如\"则\"）"
    },
    {
      "defect_id": 372923,
      "sentence": "用于获取JavaScript undefined",
      "reference_sentence": "用于获取给定布尔值的JavaScript单例对象。",
      "line_num": 420,
      "context": "{\"415\":\"JSVM OH_JSVM_GetNull success\",\"416\":\"```\",\"417\":\"\",\"418\":\"### OH_JSVM_GetUndefined\",\"419\":\"\",\"420\":\"用于获取JavaScript undefined\",\"421\":\"\",\"422\":\"cpp 部分代码\",\"423\":\"\",\"424\":\"```cpp\",\"425\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，应该统一使用'用于...的作用'形式",
      "更改后示例": "用于获取JavaScript undefined对象",
      "触发条件": "当文档中\"用于获取...\"句式未完整补充\"的[类型]对象\"结构，或与上下文同类条目（如OH_JSVM_GetNull）的\"用于...作用\"表达模式不一致时触发。\n\n识别模式：\n1. 结构检测：匹配\"用于获取\"开头但未以\"的[类型]对象\"结尾的句子（如\"undefined\"后缺失\"对象\"）\n2. 上下文对比：检查相邻函数描述（如OH_JSVM_GetNull）是否采用\"用于获取...[类型]对象\"的标准句式"
    },
    {
      "defect_id": 376470,
      "sentence": "证书本数。",
      "reference_sentence": "证书本数。",
      "line_num": 23,
      "context": "{\"18\":\"### 成员变量\",\"19\":\"\",\"20\":\"| 名称 | 描述 | \",\"21\":\"| -------- | -------- |\",\"22\":\"| struct [OH_Huks_Blob](_o_h___huks___blob.md) \\\\* [certs](#certs) | 指向证书数据的指针。  | \",\"23\":\"| uint32_t [certsCount](#certscount) | 证书本数。  | \",\"24\":\"\",\"25\":\"\",\"26\":\"## 结构体成员变量说明\",\"27\":\"\",\"28\":\"\"}",
      "修改建议": "使用了'本数'，建议使用'数量'以保持用词一致",
      "更改后示例": "证书数量。",
      "触发条件": "同一文档中同一概念或术语存在不一致的表达形式（如“本数”与“数量”），且上下文存在已确定的规范用词（如参考句或关联变量名中的“数量”）。  \n识别模式：通过对比变量命名（如“certsCount”隐含“数量”）、相邻描述或全局术语表，检测到非常规/不一致的用词（如“本数”），需替换为统一表达。"
    },
    {
      "defect_id": 376671,
      "sentence": "销毁参数集。",
      "reference_sentence": "销毁参数集。",
      "line_num": 30,
      "context": "{\"25\":\"| 名称 | 描述 | \",\"26\":\"| -------- | -------- |\",\"27\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_InitParamSet](#oh_huks_initparamset) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*\\\\*paramSet) | 初始化参数集。给paramSet预分配内存。  | \",\"28\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_AddParams](#oh_huks_addparams) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, const struct [OH_Huks_Param](_o_h___huks___param.md) \\\\*params, uint32_t paramCnt) | 添加参数到参数集里面。需要先调用OH_Huks_InitParamSet对paramSet进行初始化。  | \",\"29\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_BuildParamSet](#oh_huks_buildparamset) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*\\\\*paramSet) | 构造正式的参数集。往paramSet中添加完参数之后，需要调用OH_Huks_BuildParamSet整合参数集。  | \",\"30\":\"| void [OH_Huks_FreeParamSet](#oh_huks_freeparamset) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*\\\\*paramSet) | 销毁参数集。  | \",\"31\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_CopyParamSet](#oh_huks_copyparamset) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*fromParamSet, uint32_t fromParamSetSize, struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*\\\\*paramSet) | 复制参数集（深拷贝）。  | \",\"32\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_GetParam](#oh_huks_getparam) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, uint32_t tag, struct [OH_Huks_Param](_o_h___huks___param.md) \\\\*\\\\*param) | 从参数集中获取参数。  | \",\"33\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_FreshParamSet](#oh_huks_freshparamset) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, bool isCopy) | 刷新参数集内[OH_Huks_Blob](_o_h___huks___blob.md)类型的数据。  | \",\"34\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_IsParamSetTagValid](#oh_huks_isparamsettagvalid) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet) | 检查参数集中的参数是否有效、是否有重复。  | \",\"35\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_IsParamSetValid](#oh_huks_isparamsetvalid) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, uint32_t size) | 检查参数集大小是否有效。  | \"}",
      "修改建议": "同一个术语“销毁”在描述不同函数时应保持一致，但这里`OH_Huks_FreeParamSet`和`OH_Huks_FreeKeyAliasSet`两个函数都使用了“销毁”，建议统一为“释放”以避免混淆。",
      "更改后示例": "释放参数集。",
      "触发条件": "同一文档中存在多个相同/相关功能点使用不同动词描述资源释放操作（如\"销毁\"与\"释放\"混用），且函数命名包含明确的操作动词（如Free）时触发。\n\n识别模式：\n1. 通过动词冲突检测：当技术文档中描述资源回收的动词（销毁/释放/删除等）在相同功能模块出现不一致\n2. 通过函数名映射验证：当函数命名包含特定操作动词（如Free）时，对应的中文描述必须采用对应映射术语（如\"释放\"）\n3. 通过上下文关联分析：识别参数集/密钥集等同类资源管理函数群，确保其生命周期操作术语的统一性"
    },
    {
      "defect_id": 397751,
      "sentence": "如需详细了解ArkTS语言，请参阅[ArkTS具体指南](../arkts-utils/arkts-overview.md)<!--RP1--><!--RP1End-->。",
      "reference_sentence": "本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，助力开发者使用ArkTS高效构建高性能的移动应用。",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"ArkTS语言设计中考虑了与TypeScript和JavaScript的互通性。许多移动应用开发者希望重用TypeScript和JavaScript代码及库，因此ArkTS提供与TypeScript和JavaScript的无缝互通，使开发者可以轻松集成TypeScript和JavaScript代码到应用中，充分利用现有代码和库进行ArkTS开发。\",\"12\":\"\",\"13\":\"本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，助力开发者使用ArkTS高效构建高性能的移动应用。\",\"14\":\"\",\"15\":\"如需详细了解ArkTS语言，请参阅[ArkTS具体指南](../arkts-utils/arkts-overview.md)<!--RP1--><!--RP1End-->。\",\"16\":\"\",\"17\":\"## 基本知识\",\"18\":\"\",\"19\":\"### 声明\",\"20\":\"\"}",
      "修改建议": "混用了'具体指南'和'教程'描述同一文档",
      "更改后示例": "如需详细了解ArkTS语言，请参阅[ArkTS教程](../arkts-utils/arkts-overview.md)<!--RP1--><!--RP1End-->。",
      "触发条件": "当同一文档在链接文本中被不同术语（如\"教程\"和\"具体指南\"）交替描述，且上下文存在明确统一术语（如\"本教程\"）时触发。\n\n识别模式：\n1. 检测超链接文本中使用的文档描述词（如\"指南\"）\n2. 匹配上下文是否存在同文档的标准化命名（如\"教程\"）\n3. 验证链接目标路径是否指向同一文档\n4. 对比发现术语不一致（如\"指南\" vs \"教程\"）即触发修复"
    },
    {
      "defect_id": 376672,
      "sentence": "销毁参数集。",
      "reference_sentence": "销毁参数集。",
      "line_num": 37,
      "context": "{\"32\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_GetParam](#oh_huks_getparam) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, uint32_t tag, struct [OH_Huks_Param](_o_h___huks___param.md) \\\\*\\\\*param) | 从参数集中获取参数。  | \",\"33\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_FreshParamSet](#oh_huks_freshparamset) (struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, bool isCopy) | 刷新参数集内[OH_Huks_Blob](_o_h___huks___blob.md)类型的数据。  | \",\"34\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_IsParamSetTagValid](#oh_huks_isparamsettagvalid) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet) | 检查参数集中的参数是否有效、是否有重复。  | \",\"35\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_IsParamSetValid](#oh_huks_isparamsetvalid) (const struct [OH_Huks_ParamSet](_o_h___huks___param_set.md) \\\\*paramSet, uint32_t size) | 检查参数集大小是否有效。  | \",\"36\":\"| struct [OH_Huks_Result](_o_h___huks___result.md) [OH_Huks_CheckParamMatch](#oh_huks_checkparammatch) (const struct [OH_Huks_Param](_o_h___huks___param.md) \\\\*baseParam, const struct [OH_Huks_Param](_o_h___huks___param.md) \\\\*param) | 比较两个参数是否相同。 | \",\"37\":\"| void [OH_Huks_FreeKeyAliasSet](#oh_huks_freekeyaliasset) (struct [OH_Huks_KeyAliasSet](_o_h___huks___key_alias_set.md) \\\\*keyAliasSet) | 销毁参数集。  | \",\"38\":\"\",\"39\":\"\",\"40\":\"## 函数说明\",\"41\":\"\",\"42\":\"\"}",
      "修改建议": "同一个术语“销毁”在描述不同函数时应保持一致，但这里`OH_Huks_FreeParamSet`和`OH_Huks_FreeKeyAliasSet`两个函数都使用了“销毁”，建议统一为“释放”以避免混淆。",
      "更改后示例": "释放参数集。",
      "触发条件": "同一上下文中的多个相关函数对相同操作使用不一致的动词（如\"销毁\"与\"释放\"），且存在明确的术语映射关系（如函数名含\"Free\"对应\"释放\"）。\n\n识别模式：\n1. 相邻函数群组中存在相同操作对象（如参数集）\n2. 函数命名包含相同语义成分（如\"FreeParamSet\"与\"FreeKeyAliasSet\"）\n3. 对应的描述动词与函数命名隐含语义冲突（\"Free\"对应\"销毁\"）\n4. 存在已确立的术语标准（参考案例中\"Free\"应统一对应\"释放\"）"
    },
    {
      "defect_id": 397741,
      "sentence": "自API version 10起，ArkTS进一步通过规范强化静态检查和分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：",
      "reference_sentence": "自API version 10起，ArkTS进一步通过规范强化静态检查和分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"\",\"4\":\"ArkTS是OpenHarmony优选的主力应用开发语言，它在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了扩展，保持TS的基本风格，通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。\",\"5\":\"\",\"6\":\"\",\"7\":\"自API version 10起，ArkTS进一步通过规范强化静态检查和分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：\",\"8\":\"\",\"9\":\"\",\"10\":\"- 强制使用静态类型：静态类型是ArkTS最重要的特性之一。如果使用静态类型，那么程序中变量的类型就是确定的。同时，由于所有类型在程序实际运行前都是已知的，编译器可以验证代码的正确性，从而减少运行时的类型检查，有助于性能提升。\",\"11\":\"\",\"12\":\"- 禁止在运行时改变对象布局：为实现最优性能，ArkTS要求在程序执行期间不能更改对象布局。\"}",
      "修改建议": "原文中使用了'静态检查'和'静态类型'两个概念，但没有明确区分，可能导致混淆。",
      "更改后示例": "自API version 10起，ArkTS进一步通过规范强化静态检查和类型分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：",
      "触发条件": "当同一段落或相邻上下文中出现对同一技术概念使用不同术语（如\"静态检查\"与\"类型分析\"），且后续内容明确指向特定子类概念（如\"静态类型\"）时触发。\n\n识别模式：\n1. 核心术语在相邻段落存在隐性扩展关系（如\"检查和分析\"→\"类型分析\"）\n2. 上下文出现被定义的关键子概念（如第10段明确\"静态类型\"）\n3. 存在可能引发概念混淆的广义表述（如未明确区分\"静态检查\"与\"静态类型\"的层级关系）"
    },
    {
      "defect_id": 397763,
      "sentence": "`array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。",
      "reference_sentence": "`Array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。",
      "line_num": 165,
      "context": "{\"160\":\"let o3: Object = 1;\",\"161\":\"```\",\"162\":\"\",\"163\":\"#### `array`类型\",\"164\":\"\",\"165\":\"`array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。\",\"166\":\"数组可由数组复合字面量赋值。数组复合字面量是用方括号括起来的零个或多个表达式列表，每个表达式为数组中的一个元素。数组的长度由数组中元素的个数确定。数组中第一个元素的索引为0。\",\"167\":\"\",\"168\":\"以下示例将创建包含三个元素的数组：\",\"169\":\"\",\"170\":\"```typescript\"}",
      "修改建议": "混用了`array`和`Array`术语",
      "更改后示例": "`Array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。",
      "触发条件": "当文档中同一技术术语存在大小写不一致（如array/Array）且上下文存在统一用法时，或当代码示例中的类型名称（如Array）与自然语言描述术语（如array）出现拼写差异时。\n\n识别模式：\n1. 检测技术术语在代码块/类型声明中的标准拼写（如首字母大写的Array）\n2. 对比自然语言段落中对应术语的拼写形式（如小写array）\n3. 验证上下文是否存在已建立的统一术语用法（如参考句中的Array）"
    },
    {
      "defect_id": 382993,
      "sentence": "定义应用保活信息，可以通过[getKeepAliveBundles](#appmanagergetkeepalivebundles14)或[getKeepAliveAppServiceExtensions](#appmanagergetkeepaliveappserviceextensions20)获取当前应用的相关信息。",
      "reference_sentence": "## KeepAliveBundleInfo<sup>14+</sup>",
      "line_num": 60,
      "context": "{\"55\":\"| SYSTEM | 0 | 应用保活设置方为系统。 |\",\"56\":\"| USER  | 1 | 应用保活设置方为用户。  |\",\"57\":\"\",\"58\":\"## KeepAliveBundleInfo<sup>14+</sup>\",\"59\":\"\",\"60\":\"定义应用保活信息，可以通过[getKeepAliveBundles](#appmanagergetkeepalivebundles14)或[getKeepAliveAppServiceExtensions](#appmanagergetkeepaliveappserviceextensions20)获取当前应用的相关信息。\",\"61\":\"\",\"62\":\"**系统能力**：SystemCapability.Ability.AbilityRuntime.Core\",\"63\":\"\",\"64\":\"**系统接口**：此接口为系统接口。\",\"65\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一对象，'应用保活信息'与'应用保活'混用。",
      "更改后示例": "定义应用保活信息，可以通过[getKeepAliveBundles](#appmanagergetkeepalivebundles14)或[getKeepAliveAppServiceExtensions](#appmanagergetkeepaliveappserviceextensions20)获取当前应用的保活信息。",
      "触发条件": "当同一段落或相邻上下文中出现同一概念的不同术语表述（如\"应用保活信息\"与\"相关信息\"混用），且上下文已存在明确规范术语时触发。需识别同一语义链中术语的异常替换（如抽象词替代具体词、简称替代全称等）。"
    },
    {
      "defect_id": 397740,
      "sentence": "ArkTS是OpenHarmony优选的主力应用开发语言，它在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了扩展，保持TS的基本风格，通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。",
      "reference_sentence": "ArkTS是OpenHarmony优选的主力应用开发语言，它在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了扩展，保持TS的基本风格，通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。",
      "line_num": 4,
      "context": "{\"1\":\"# 初识ArkTS语言\",\"2\":\"\",\"3\":\"\",\"4\":\"ArkTS是OpenHarmony优选的主力应用开发语言，它在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了扩展，保持TS的基本风格，通过规范定义强化开发期静态检查和分析，提升程序执行稳定性和性能。\",\"5\":\"\",\"6\":\"\",\"7\":\"自API version 10起，ArkTS进一步通过规范强化静态检查和分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：\",\"8\":\"\",\"9\":\"\"}",
      "修改建议": "原文中使用了'静态检查'和'静态类型'两个概念，但没有明确区分，可能导致混淆。",
      "更改后示例": "ArkTS是OpenHarmony优选的主力应用开发语言，它在[TypeScript](https://www.typescriptlang.org/)（简称TS）生态基础上做了扩展，保持TS的基本风格，通过规范定义强化开发期静态检查和类型分析，提升程序执行稳定性和性能。",
      "触发条件": "当同一段落中出现多个相关技术术语（如\"静态检查\"和\"静态类型\"）但未保持统一表述，或存在概念边界模糊时触发。\n\n识别模式：通过检测相邻句子/段落中是否存在(1)语义关联但表述不一致的术语（如检查→类型），且(2)缺乏明确的概念界定说明时，判定为术语一致性风险。需结合术语词库匹配和依存句法分析识别概念关联性。"
    },
    {
      "defect_id": 397789,
      "sentence": "如果在异步函数中，可以使用let module = await import(modulePath)。",
      "reference_sentence": "如果在异步函数中，可以使用`let module = await import(modulePath)`。",
      "line_num": 1819,
      "context": "{\"1814\":\"}).catch((err: Error) => {\",\"1815\":\"  console.error(\\\"Module dynamic import error: \\\", err);\",\"1816\":\"});\",\"1817\":\"```\",\"1818\":\"\",\"1819\":\"如果在异步函数中，可以使用let module = await import(modulePath)。\",\"1820\":\"\",\"1821\":\"```typescript\",\"1822\":\"// say.ts\",\"1823\":\"export function hi() {\",\"1824\":\"  console.log('Hello');\"}",
      "修改建议": "代码块中的`import`关键字未使用反引号包裹",
      "更改后示例": "如果在异步函数中，可以使用`let module = await import(modulePath)`。",
      "触发条件": "当文本中出现未被反引号包裹的内联代码片段（如变量声明、函数调用、API名称等）时触发。\n\n识别模式：\n1. 检测句子中包含代码特征（如赋值符号、await关键字、方法调用等）\n2. 验证代码片段是否被反引号包裹（如`import`未包裹）\n3. 结合上下文判断是否为技术说明场景（如前后存在代码块、技术术语等）"
    },
    {
      "defect_id": 397791,
      "sentence": "注解字段的默认值必须使用常量表达式来指定。<br>常量表达式的场景如下所示：",
      "reference_sentence": "注解字段的默认值必须使用常量表达式来指定。<br>常量表达式的场景如下所示：",
      "line_num": 1951,
      "context": "{\"1946\":\">**说明：**\",\"1947\":\">\",\"1948\":\"> - 如果使用其他类型用作注解字段的类型，则会发生编译错误。\",\"1949\":\"> - 注解字段类型不支持bigint。\",\"1950\":\"\",\"1951\":\"注解字段的默认值必须使用常量表达式来指定。<br>常量表达式的场景如下所示：\",\"1952\":\"* 数字字面量\",\"1953\":\"* 布尔字面量\",\"1954\":\"* 字符串字面量\",\"1955\":\"* 枚举值（需要在编译时确定值）\",\"1956\":\"* 以上常量组成的数组\"}",
      "修改建议": "使用了`<br>`标签，不符合Markdown规范",
      "更改后示例": "注解字段的默认值必须使用常量表达式来指定。常量表达式的场景如下所示：",
      "触发条件": "当文档中存在使用HTML标签（如`<br>`）进行段落分隔而非Markdown规范的空行或列表结构，且上下文存在同类内容采用连贯句式或标准标点时。"
    },
    {
      "defect_id": 397765,
      "sentence": "`Aliases`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。",
      "reference_sentence": "`Alias`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。",
      "line_num": 240,
      "context": "{\"235\":\"}\",\"236\":\"```\",\"237\":\"\",\"238\":\"#### `Aliases`类型\",\"239\":\"\",\"240\":\"`Aliases`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。\",\"241\":\"\",\"242\":\"```typescript\",\"243\":\"type Matrix = number[][];\",\"244\":\"type Handler = (s: string, no: number) => string;\",\"245\":\"type Predicate <T> = (x: T) => boolean;\"}",
      "修改建议": "混用了`Aliases`和`Alias`术语",
      "更改后示例": "`Alias`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。",
      "触发条件": "同一术语在相邻上下文或同一文档中出现单复数形式不一致（如\"Aliases\"与\"Alias\"混用），且存在已定义的统一表达形式（如参考句子中的\"`Alias`类型\"）。"
    },
    {
      "defect_id": 397764,
      "sentence": "`enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。",
      "reference_sentence": "`Enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。",
      "line_num": 176,
      "context": "{\"171\":\"let names: string[] = ['Alice', 'Bob', 'Carol'];\",\"172\":\"```\",\"173\":\"\",\"174\":\"#### `enum`类型\",\"175\":\"\",\"176\":\"`enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。\",\"177\":\"使用枚举常量时必须以枚举类型名称为前缀。\",\"178\":\"\",\"179\":\"```typescript\",\"180\":\"enum ColorSet { Red, Green, Blue }\",\"181\":\"let c: ColorSet = ColorSet.Red;\"}",
      "修改建议": "混用了`enum`和`Enum`术语",
      "更改后示例": "`Enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。",
      "触发条件": "当同一术语在文档不同位置出现大小写不一致时触发（如代码块使用小写`enum`，正文描述却使用首字母大写`Enum`），或同一段落中术语形式与上下文参考句式存在冲突时触发。\n\n识别模式：1. 检查技术术语在代码块中的书写形式（如语言关键字`enum`）；2. 验证正文中对该术语的引用是否保持首字母大写一致性（如应统一为`Enum`类型）；3. 对比上下文是否存在术语形态冲突（如本段出现`enum`但其他段落使用`Enum`）。"
    },
    {
      "defect_id": 397742,
      "sentence": "ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。",
      "reference_sentence": "ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"- 限制运算符语义：为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。例如，一元加法运算符只能作用于数字，不能用于其他类型的变量等。\",\"15\":\"\",\"16\":\"- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，后续会重新考虑是否支持Structural typing。\",\"17\":\"\",\"18\":\"ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。\",\"19\":\"\",\"20\":\"未来，ArkTS会结合应用开发/运行的需求持续演进，逐步增强并行和并发能力、扩展系统类型，以及引入分布式开发范式等更多特性。\",\"21\":\"\",\"22\":\"如需深入了解ArkTS语言，可参考[ArkTS具体指南](../arkts-utils/arkts-overview.md)。\"}",
      "修改建议": "原文中使用了'兼容'和'支持'两个概念，但没有明确区分，可能导致混淆。",
      "更改后示例": "ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS兼容的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。",
      "触发条件": "同一段落或相邻上下文中，针对同一技术概念交替使用\"兼容\"和\"支持\"等近义词且未明确区分语义差异时。\n\n识别模式：\n1. 检查同一技术主体（如ArkTS/TS/JS）在邻近句子中是否出现不同动词描述其关系（如兼容/支持/允许等）\n2. 验证术语是否指向完全相同的技术行为，当存在多个动词描述同一技术关系且缺乏明确定义时触发\n3. 特别注意技术文档中关键概念描述，要求核心术语在上下文保持严格一致性"
    },
    {
      "defect_id": 397752,
      "sentence": "由于`void`是引用类型，因此它可以用于泛型类型参数。",
      "reference_sentence": "引用类型包括对象、数组和函数等复杂数据结构。这些类型通过引用访问数据，对象和数组可以包含多个值或键值对，函数则可以封装可执行的代码逻辑。引用类型在内存中通过指针访问数据，修改引用会影响原始数据。",
      "line_num": 145,
      "context": "{\"140\":\"```\",\"141\":\"\",\"142\":\"#### `void`类型\",\"143\":\"\",\"144\":\"`void`类型用于指定函数没有返回值。\",\"145\":\"此类型只有一个值，同样是`void`。由于`void`是引用类型，因此它可以用于泛型类型参数。\",\"146\":\"\",\"147\":\"```typescript\",\"148\":\"class Class<T> {\",\"149\":\"  //...\",\"150\":\"}\"}",
      "修改建议": "混用了'引用类型'和'引用类型'描述同一概念，但后者更详细",
      "更改后示例": "由于`void`是引用类型，因此它可以用于泛型类型参数。引用类型在内存中通过指针访问数据，修改引用会影响原始数据。",
      "触发条件": "同一术语（如\"引用类型\"）在相邻段落/章节中重复出现时，若后续出现时未保持首次引入时的解释维度（如首次仅定义类型归属，后续却扩展内存特性），且未采用分层表述结构。  \n\n识别模式：  \n1. 核心术语重复出现时，检查是否在相同抽象层级进行描述（如类型归属 vs 内存机制）  \n2. 验证相邻段落是否形成\"总-分\"结构（如问题句应作为总述，参考句应通过分段/列表展开细节）  \n3. 检测是否存在概念解释断层（如问题句仅说明类型归属，修复后补充的内存特性属于同一概念的新维度）"
    },
    {
      "defect_id": 397788,
      "sentence": "### 可选链",
      "reference_sentence": "### 可选链",
      "line_num": 1686,
      "context": "{\"1681\":\"    return this.nick ?? '';\",\"1682\":\"  }\",\"1683\":\"}\",\"1684\":\"```\",\"1685\":\"\",\"1686\":\"### 可选链\",\"1687\":\"\",\"1688\":\"访问对象属性时，如果属性是`undefined`或`null`，可选链运算符返回`undefined`。\",\"1689\":\"\",\"1690\":\"```typescript\",\"1691\":\"class Person {\"}",
      "修改建议": "缺少使用说明或具体示例，容易导致理解模糊",
      "更改后示例": "### 可选链可选链运算符`?.`用于访问对象属性时，如果属性是`undefined`或`null`，则返回`undefined`。",
      "触发条件": "当相同层级的标题描述存在结构缺失（如未明确标注运算符符号`?.`）或与上下文同类术语表述模式不匹配（如缺少\"用于...\"的语法说明句式）时触发。"
    },
    {
      "defect_id": 397790,
      "sentence": "`用户自定义注解`的定义与`interface`的定义类似，其中的`interface`关键字以符号`@`为前缀。<br>",
      "reference_sentence": "`用户自定义注解`的定义与`interface`的定义类似，其中的`interface`关键字以符号`@`为前缀。",
      "line_num": 1939,
      "context": "{\"1934\":\"注解不是Typescript中的特性，只能在`.ets/.d.ets`文件中使用。\",\"1935\":\"\",\"1936\":\"### 用户自定义注解\",\"1937\":\"\",\"1938\":\"#### 用户自定义注解的声明\",\"1939\":\"`用户自定义注解`的定义与`interface`的定义类似，其中的`interface`关键字以符号`@`为前缀。<br>\",\"1940\":\"注解字段仅限于下面列举的类型：\",\"1941\":\"* number\",\"1942\":\"* boolean\",\"1943\":\"* string\",\"1944\":\"* 枚举\"}",
      "修改建议": "使用了`<br>`标签，不符合Markdown规范",
      "更改后示例": "`用户自定义注解`的定义与`interface`的定义类似，其中的`interface`关键字以符号`@`为前缀。",
      "触发条件": "在Markdown格式的文本中检测到使用HTML换行标签`<br>`，且上下文存在使用标准Markdown换行符（如双空格或段落分隔）的规范表达模式时触发。"
    },
    {
      "defect_id": 397841,
      "sentence": "注解必须定义在顶层作用域（top-level），否则会出现编译报错。<br>",
      "reference_sentence": "顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。",
      "line_num": 1973,
      "context": "{\"1968\":\"\",\"1969\":\"@interface Position {\",\"1970\":\"  data: number = X.x; // 编译错误：注解字段的默认值必须使用常量表达式\",\"1971\":\"}\",\"1972\":\"```\",\"1973\":\"注解必须定义在顶层作用域（top-level），否则会出现编译报错。<br>\",\"1974\":\"注解的名称不能与注解定义所在作用域内可见的其他实体名称相同，否则会出现编译报错。<br>\",\"1975\":\"注解不支持类型Typescript中的合并，否则会出现编译报错。\",\"1976\":\"```typescript\",\"1977\":\"namespace ns {\",\"1978\":\"  @interface MataInfo { // 编译错误：注解必须定义在顶层作用域\"}",
      "修改建议": "混用了“顶层作用域”和“顶层语句”概念",
      "更改后示例": "注解必须定义在顶层语句中，否则会出现编译报错。<br>",
      "触发条件": "当文档中相邻或相关语句对同一技术概念使用不同术语表述（如\"顶层作用域\"和\"顶层语句\"），且未明确说明其等价关系时触发。识别模式为检测同一段落/列表中是否存在语义相同但用词不一致的核心术语（通过词干提取+领域词典匹配），并验证上下文是否缺少必要的术语等价性说明。"
    },
    {
      "defect_id": 397842,
      "sentence": "注解的名称不能与注解定义所在作用域内可见的其他实体名称相同，否则会出现编译报错。<br>",
      "reference_sentence": "未导出的声明名称被视为私有名称，只能在声明该名称的模块中使用。",
      "line_num": 1974,
      "context": "{\"1969\":\"@interface Position {\",\"1970\":\"  data: number = X.x; // 编译错误：注解字段的默认值必须使用常量表达式\",\"1971\":\"}\",\"1972\":\"```\",\"1973\":\"注解必须定义在顶层作用域（top-level），否则会出现编译报错。<br>\",\"1974\":\"注解的名称不能与注解定义所在作用域内可见的其他实体名称相同，否则会出现编译报错。<br>\",\"1975\":\"注解不支持类型Typescript中的合并，否则会出现编译报错。\",\"1976\":\"```typescript\",\"1977\":\"namespace ns {\",\"1978\":\"  @interface MataInfo { // 编译错误：注解必须定义在顶层作用域\",\"1979\":\"    // ...\"}",
      "修改建议": "混用了“名称”和“实体名称”概念",
      "更改后示例": "注解的名称不能与注解定义所在作用域内可见的其他名称相同，否则会出现编译报错。<br>",
      "触发条件": "当同一句子或相邻上下文中存在术语混用（如\"名称\"与\"实体名称\"）且指代同一概念时触发，特别是当冗余限定词（如\"实体\"）破坏术语一致性时。\n\n识别模式：\n1. 检测同一语义范围内出现同一核心术语的不同变体（如\"名称\" vs \"实体名称\"）\n2. 对比上下文术语使用惯例（如参考句中的\"声明名称\"未添加冗余限定词）\n3. 验证冗余限定词是否改变原意（此案例中\"实体\"未增加必要语义信息）"
    },
    {
      "defect_id": 397891,
      "sentence": "途经点List：语音入口调用时必填Array<PoiLocation>，途径点包含字段与srcLocation中的字段一致，最多传5个。",
      "reference_sentence": "支持设置出发地、目的地、途经点、目的地类型及交通方式等参数，适用于驾车、步行、骑行、公交、地铁等多种出行场景。",
      "line_num": 79,
      "context": "{\"74\":\"| 参数名 | 类型 | 必选 | 说明                                                                               | 数据样例 |\",\"75\":\"|-------------|-----|--------|----------------------------------------------------------------------------------|---------|\",\"76\":\"| entityId    | string | 否   | 意图实体ID，长度不超过64个字符。                                                                  | \\\"12949589\\\" |\",\"77\":\"| srcLocation | object | 否   | 出发地信息，包含如下字段：<br>- locationSystem：指定坐标系（默认使用GCJ-02坐标系）。<br>- poiId：poi的唯一标识。<br>- locationName：地点名称。<br>- longitude：经度。<br>- latitude：纬度。<br>- address：详细地址信息。      | {<br>  \\\"locationSystem\\\": \\\"GCJ02\\\",<br>  \\\"poiId\\\": \\\"1236\\\",<br>  \\\"locationName\\\": \\\"北京站\\\",<br>  \\\"latitude\\\": \\\"39.902895\\\",<br>  \\\"longitude\\\": \\\"116.427915\\\",<br>  \\\"address\\\": \\\"北京市东城区北京站\\\"<br>} |\",\"78\":\"| dstLocation | object | 否   | 目的地的信息，包含如下字段：<br>- locationSystem：指定坐标系（默认使用GCJ-02坐标系）。<br>- poiId：poi的唯一标识。<br>- locationName：地点名称。<br>- longitude：经度。<br>- latitude：纬度。<br>- address：详细地址信息。     | {<br>  \\\"locationSystem\\\": \\\"GCJ02\\\",<br>  \\\"poiId\\\": \\\"1248\\\",<br>  \\\"locationName\\\": \\\"北京西站\\\",<br>  \\\"latitude\\\": \\\"39.89534\\\",<br>  \\\"longitude\\\": \\\"116.32128\\\",<br>  \\\"address\\\": \\\"北京市丰台区北京西站\\\"<br>} |\",\"79\":\"| wayPoints   | array | 否   | 途经点List：语音入口调用时必填Array\\\\<PoiLocation>，途径点包含字段与srcLocation中的字段一致，最多传5个。                                      | [{<br>  \\\"locationSystem\\\": \\\"GCJ02\\\",<br>  \\\"poiId\\\": \\\"1445\\\",<br>  \\\"locationName\\\": \\\"前门东大街社区\\\",<br>  \\\"latitude\\\": \\\"39.89995\\\",<br>  \\\"longitude\\\": \\\"116.35628\\\",<br>  \\\"address\\\": \\\"北京市东城区前门街道\\\"<br>}] |\",\"80\":\"| dstLocationType | string | 否   | 目的地类型，比如\\\"家\\\"、\\\"公司\\\"等。                                                               | \\\"家\\\" |\",\"81\":\"| trafficType | string | 否   | 交通方式（类型）。<br>- Drive：驾车（默认值）。<br>- Walk：步行。<br>- Cycle：骑行。<br>- Bus：公交。<br>- Subway：地铁。 | \\\"Cycle\\\" |\",\"82\":\"\",\"83\":\"**返回值**：\",\"84\":\"\"}",
      "修改建议": "混用了'List'和'Array'概念",
      "更改后示例": "途经点Array：语音入口调用时必填Array<PoiLocation>，途径点包含字段与srcLocation中的字段一致，最多传5个。",
      "触发条件": "当同一参数描述中混用不同数据结构术语（如\"List\"和\"Array\"），且上下文参数类型定义（如array）与描述术语不一致时触发。\n\n识别模式：检查技术文档中参数类型声明（如表格中的array类型）与对应文字描述是否使用相同术语体系，当发现同一参数在类型字段、说明字段、示例字段出现两种及以上数据结构表述时（如array/list/collection混用），即触发一致性规则。"
    },
    {
      "defect_id": 397844,
      "sentence": "注解不是类型，把注解当类型使用时会出现编译报错（例如：对注解使用类型别名）。",
      "reference_sentence": "注解不是Typescript中的特性，只能在`.ets/.d.ets`文件中使用。",
      "line_num": 1999,
      "context": "{\"1994\":\"\",\"1995\":\"@interface ClassAuthor { // 编译错误：注解的名称不能与注解定义所在作用域内可见的其他实体名称相同\",\"1996\":\"  data: sting;\",\"1997\":\"}\",\"1998\":\"```\",\"1999\":\"注解不是类型，把注解当类型使用时会出现编译报错（例如：对注解使用类型别名）。\",\"2000\":\"```typescript\",\"2001\":\"@interface Position {}\",\"2002\":\"type Pos = Position; // 编译错误：注解不是类型\",\"2003\":\"```\",\"2004\":\"注解不支持在类的getter和setter方法添加，若添加注解会编译报错。\"}",
      "修改建议": "混用了“类型”和“特性”概念",
      "更改后示例": "注解不是类型，将其用作类型时会出现编译报错（例如：对注解使用类型别名）。",
      "触发条件": "当文档中混用\"当\"和\"用作\"表述功能误用时，或错误地将注解与类型/特性概念混用时应触发规则。识别模式为检测\"把...当...使用\"的非标准表达，及同一上下文中\"类型\"与\"特性\"等核心概念的不一致表述。"
    },
    {
      "defect_id": 397843,
      "sentence": "注解不支持类型Typescript中的合并，否则会出现编译报错。",
      "reference_sentence": "注解不是Typescript中的特性，只能在`.ets/.d.ets`文件中使用。",
      "line_num": 1975,
      "context": "{\"1970\":\"  data: number = X.x; // 编译错误：注解字段的默认值必须使用常量表达式\",\"1971\":\"}\",\"1972\":\"```\",\"1973\":\"注解必须定义在顶层作用域（top-level），否则会出现编译报错。<br>\",\"1974\":\"注解的名称不能与注解定义所在作用域内可见的其他实体名称相同，否则会出现编译报错。<br>\",\"1975\":\"注解不支持类型Typescript中的合并，否则会出现编译报错。\",\"1976\":\"```typescript\",\"1977\":\"namespace ns {\",\"1978\":\"  @interface MataInfo { // 编译错误：注解必须定义在顶层作用域\",\"1979\":\"    // ...\",\"1980\":\"  }\"}",
      "修改建议": "混用了“类型”和“特性”概念",
      "更改后示例": "注解不支持在TypeScript中进行合并，否则会出现编译报错。",
      "触发条件": "当文档中针对同一技术概念使用不一致的术语（如\"类型\"与\"特性\"混用），或出现与上下文既定表述（如\"特性\"）相冲突的用词时触发。\n\n识别模式：\n1. **术语冲突检测**：比对当前句子与上下文/参考句中的核心术语（例如\"类型Typescript\" vs 参考句的\"Typescript中的特性\"）\n2. **结构模式匹配**：识别\"不支持X中的Y\"句式时，校验X是否为准确的技术领域描述（如应使用\"在TypeScript中进行\"而非\"类型Typescript\"）\n3. **跨句关联验证**：当出现\"注解不支持...\"类警示说明时，需与上下文同类警告保持术语统一（如1973-1975行均使用\"在TypeScript中\"作为环境描述）"
    },
    {
      "defect_id": 397901,
      "sentence": "用于请求查看用户的地铁或公交乘车码，支持指定交通类型（地铁/公交）和城市区域代码，适用于公共交通出行场景。",
      "reference_sentence": "用于发起导航请求，支持设置出发地、目的地、途经点、目的地类型及交通方式等参数，适用于驾车、步行、骑行、公交、地铁等多种出行场景。",
      "line_num": 91,
      "context": "{\"86\":\"| ------ | ----  | ---- |------------------------------------| -------- |\",\"87\":\"| code   | number| 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0 |\",\"88\":\"| result | object| 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"89\":\"\",\"90\":\"### 查看乘车码  \",\"91\":\"用于请求查看用户的地铁或公交乘车码，支持指定交通类型（地铁/公交）和城市区域代码，适用于公共交通出行场景。 \",\"92\":\"\",\"93\":\"**起始版本**：1.0.1 \",\"94\":\"\",\"95\":\"**参数**：  \",\"96\":\"\"}",
      "修改建议": "句式不一致，建议统一为祈使句。",
      "更改后示例": "请求查看用户的地铁或公交乘车码，支持指定交通类型（地铁/公交）和城市区域代码，适用于公共交通出行场景。",
      "触发条件": "功能描述句使用\"用于...\"等非祈使结构，而文档规范要求统一使用\"动词+宾语\"的祈使句式时触发。\n\n识别模式：\n1. 句首出现\"用于\"、\"用来\"等表用途的介词结构\n2. 上下文存在同类功能描述（如参考句）使用标准祈使句\"发起导航请求\"\n3. 语义表达功能操作而非状态说明，需保持行为动词引导的句式统一性\n\n具体表现为：当检测到功能说明性语句采用\"用于+动宾结构\"，但同类型接口文档规范要求使用\"动词+宾语\"的祈使句结构（如\"发起导航请求\"）时，应触发句式一致性修正规则。"
    },
    {
      "defect_id": 397846,
      "sentence": "如果注解中定义了数组类型的字段，则使用数字字面量来设置该字段的值。",
      "reference_sentence": "注解字段仅限于下面列举的类型： * number * boolean * string * 枚举 * 以上类型的数组",
      "line_num": 2071,
      "context": "{\"2066\":\"@ClassPreamble() // 编译错误：authorName字段未定义\",\"2067\":\"class C1 {\",\"2068\":\"  // ...\",\"2069\":\"}\",\"2070\":\"```\",\"2071\":\"如果注解中定义了数组类型的字段，则使用数字字面量来设置该字段的值。\",\"2072\":\"```typescript\",\"2073\":\"@interface ClassPreamble {\",\"2074\":\"  authorName: string;\",\"2075\":\"  revision: number = 1;\",\"2076\":\"  reviewers: string[];\"}",
      "修改建议": "混用了“数字字面量”和“常量表达式”概念",
      "更改后示例": "如果注解中定义了数组类型的字段，则使用常量表达式来设置该字段的值。",
      "触发条件": "当文档中同一技术概念出现多个不同术语（如\"数字字面量\"与\"常量表达式\"），且存在更准确的官方推荐术语时；或当特定上下文（如类型系统/注解定义）要求使用精确术语时。\n\n识别模式：\n1. 术语冲突检测：在相邻段落/同一规则中，发现对同一技术概念使用不同命名（如字面量 vs 常量表达式）\n2. 类型系统验证：当描述类型约束（如数组/注解字段）时，需匹配参考文档的官方术语体系（如number/boolean/string/enum的数组类型对应常量表达式）\n3. 概念覆盖度检查：当狭义术语（数字字面量）无法覆盖全部合法用例时，需替换为广义术语（常量表达式）"
    },
    {
      "defect_id": 397885,
      "sentence": "会员已失效，且歌曲没有试听片段。",
      "reference_sentence": "0表示成功；其他表示失败，如下：",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"**返回值**： \",\"40\":\"\",\"41\":\"| 参数名 | 类型  | 必选 | 说明                                                                                                                                                                                                                                     | 数据样例 |\",\"42\":\"| ------ | ---- | ---- |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-|\",\"43\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，如下：<br>- 100060101：不支持播放会员歌曲、付费歌曲。<br>- 100060102：会员已失效，且歌曲没有试听片段。<br>- 100060201：开启了儿童保护、或登录儿童账号场景、脏标的歌曲。<br>- 100060202：歌单已下架，无法播放。<br>- 100060203：歌曲在本平台版权到期，无法播放。<br>- 100060301：歌曲/歌手被加入了屏蔽名单，歌曲无法播放。<br>- 100060401：软件故障。 | 100060101 |\",\"44\":\"| result | object | 是   | 意图调用返回的数据。以键值对形式返回，长度不超过8000个字符。                                                                                                                                                                          | {\\\"musicSize\\\":\\\"4M\\\",\\\"dataReceiveTime\\\":1704868765000} |\",\"45\":\"\",\"46\":\"### 播放有声\",\"47\":\"\",\"48\":\"用于请求播放特定的有声节目内容，支持按意图实体ID和有声节目ID进行精确查找，并返回播放结果状态。\"}",
      "修改建议": "使用了不同的词汇描述同一事物：'会员'与'帐户'混用",
      "更改后示例": "帐户已失效，且歌曲没有试听片段。",
      "触发条件": "同一文档中出现对同一实体使用多个不同术语（如\"会员\"和\"帐户\"），且上下文存在已确立的标准用词（如其他错误码描述统一使用\"帐户\"）时触发。通过对比相邻条目术语使用模式（如错误码列表的用词一致性）识别矛盾点。"
    },
    {
      "defect_id": 397878,
      "sentence": "用于触发视频播放操作，支持指定视频实体、分集信息等参数，返回操作结果及数据。",
      "reference_sentence": "用于播放指定歌单的音乐内容，支持按场景、城市等条件筛选，并返回播放结果状态。",
      "line_num": 4,
      "context": "{\"1\":\"# 标准意图接入规范\",\"2\":\"## 影音娱乐垂域\",\"3\":\"### 播放视频  \",\"4\":\"用于触发视频播放操作，支持指定视频实体、分集信息等参数，返回操作结果及数据。\",\"5\":\"\",\"6\":\"**起始版本**：1.0.1\",\"7\":\"\",\"8\":\"**参数**：  \",\"9\":\"\"}",
      "修改建议": "两个句子中，描述返回内容的词汇不一致，前文使用了'操作结果及数据'，后文使用了'播放结果状态'。",
      "更改后示例": "用于触发视频播放操作，支持指定视频实体、分集信息等参数，并返回播放结果状态。",
      "触发条件": "同一功能描述中相邻句子或上下文出现对相同概念使用不同术语（如\"操作结果\"与\"播放结果\"），且存在动词-宾语结构（如\"返回...结果\"）时出现表述偏差。"
    },
    {
      "defect_id": 398022,
      "sentence": "用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短信和数据流量等使用情况。",
      "reference_sentence": "用于查询指定手机号所享有的各项权益和服务，包括但不限于套餐优惠、增值服务、积分奖励等内容，帮助用户全面了解其手机号码的权益情况。",
      "line_num": 414,
      "context": "{\"409\":\"| code | number | 是  | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0 |\",\"410\":\"| result | object | 是  | 返回结果列表对象。如果无内容，则返回空。 | - |\",\"411\":\"\",\"412\":\"### 查看电话账单\",\"413\":\"\",\"414\":\"用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短信和数据流量等使用情况。\",\"415\":\"\",\"416\":\"**起始版本**：1.0.1\",\"417\":\"\",\"418\":\"**参数**：\",\"419\":\"\"}",
      "修改建议": "混用了'短信'和'短消息'，应保持一致。",
      "更改后示例": "用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短消息和数据流量等使用情况。",
      "触发条件": "同一文档中出现多个同义词或不同术语指代同一概念，或在相邻上下文中存在表述方式不统一的情况。识别模式为检测到相同语义内容使用两种及以上不同表述（如\"短信\"与\"短消息\"），且这些表述出现在同一功能描述或关联性较强的上下文环境中。"
    },
    {
      "defect_id": 397900,
      "sentence": "### 查看乘车码",
      "reference_sentence": "### 开始导航",
      "line_num": 90,
      "context": "{\"85\":\"| 参数名  | 类型  | 必选 | 说明                                 | 数据样例 |\",\"86\":\"| ------ | ----  | ---- |------------------------------------| -------- |\",\"87\":\"| code   | number| 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0 |\",\"88\":\"| result | object| 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"89\":\"\",\"90\":\"### 查看乘车码  \",\"91\":\"用于请求查看用户的地铁或公交乘车码，支持指定交通类型（地铁/公交）和城市区域代码，适用于公共交通出行场景。 \",\"92\":\"\",\"93\":\"**起始版本**：1.0.1 \",\"94\":\"\",\"95\":\"**参数**：  \"}",
      "修改建议": "标题格式不一致，建议统一为祈使句。",
      "更改后示例": "### 请求查看乘车码",
      "触发条件": "当同一章节或上下文中存在多个功能标题，且部分标题未使用与其他标题一致的祈使句动词结构（如缺少动作发起词\"请求\"\"开始\"等）时触发。\n\n识别模式：\n1. 对比相邻/同类标题的动词结构（如\"开始导航\"含发起词\"开始\"）\n2. 检测标题是否描述用户主动操作但未包含明确的动作发起动词\n3. 验证上下文是否存在统一句式规范（如所有API方法标题均采用\"动词+功能\"的祈使结构）"
    },
    {
      "defect_id": 398040,
      "sentence": "查询个人所得税专项附加扣除的详细信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及3岁以下婴幼儿照护等扣除类型的相关政策、扣除标准及申报条件，帮助用户合理规划个人所得税减免。",
      "reference_sentence": "查看电话账单用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短信和数据流量等使用情况。",
      "line_num": 506,
      "context": "{\"501\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0  |\",\"502\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"503\":\"\",\"504\":\"### 查看专项附加扣除\",\"505\":\"\",\"506\":\"查询个人所得税专项附加扣除的详细信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及3岁以下婴幼儿照护等扣除类型的相关政策、扣除标准及申报条件，帮助用户合理规划个人所得税减免。\",\"507\":\"\",\"508\":\"**起始版本**：1.0.1\",\"509\":\"\",\"510\":\"**参数**：\",\"511\":\"\"}",
      "修改建议": "混用了'查询'和'查看'，应保持用词一致。",
      "更改后示例": "查看个人所得税专项附加扣除的详细信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及3岁以下婴幼儿照护等扣除类型的相关政策、扣除标准及申报条件，帮助用户合理规划个人所得税减免。",
      "触发条件": "同一上下文或相邻段落中对相同操作使用不同动词（如\"查询\"和\"查看\"），且存在明确的上下文用词参照（如标题已使用\"查看\"）。识别模式为：在特定功能描述范围内（如专项附加扣除模块），检测核心操作动词与标题/相邻接口用词是否冲突。"
    },
    {
      "defect_id": 398039,
      "sentence": "查询特定城市的婚姻登记相关信息，包括结婚登记流程、所需材料、办理地点及离婚登记服务等，为用户提供婚姻登记事务的指引与支持。",
      "reference_sentence": "查看电话账单用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短信和数据流量等使用情况。",
      "line_num": 486,
      "context": "{\"481\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0  |\",\"482\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"483\":\"\",\"484\":\"### 查看婚姻登记\",\"485\":\"\",\"486\":\"查询特定城市的婚姻登记相关信息，包括结婚登记流程、所需材料、办理地点及离婚登记服务等，为用户提供婚姻登记事务的指引与支持。\",\"487\":\"\",\"488\":\"**起始版本**：1.0.1\",\"489\":\"\",\"490\":\"**参数**：\",\"491\":\"\"}",
      "修改建议": "混用了'查询'和'查看'，应保持用词一致。",
      "更改后示例": "查看特定城市的婚姻登记相关信息，包括结婚登记流程、所需材料、办理地点及离婚登记服务等，为用户提供婚姻登记事务的指引与支持。",
      "触发条件": "当同一功能描述在相邻上下文中出现动词不一致（如\"查询\"与\"查看\"混用），且存在明确的前后文用词参照（如模块标题使用\"查看\"）时触发。\n\n识别模式：\n1. 检测功能操作动词与所在模块标题动词的匹配度\n2. 识别同一功能段落中描述相同操作时使用的不同近义词（如查询/查看/检索）\n3. 验证参数说明与功能描述动词的一致性（如result字段说明与操作动词的对应关系）"
    },
    {
      "defect_id": 397903,
      "sentence": "用于发起打车请求，支持设置出发地、目的地、车型、入口标识等参数，适用于多种打车场景（如快车、出租车、拼车等）。",
      "reference_sentence": "用于发起导航请求，支持设置出发地、目的地、途经点、目的地类型及交通方式等参数，适用于驾车、步行、骑行、公交、地铁等多种出行场景。",
      "line_num": 110,
      "context": "{\"105\":\"| ------ | ------| ---- |------------------------------------------------------------------| -------- |\",\"106\":\"| code   | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。                                          | 0 |\",\"107\":\"| result | object | 是   | 意图调用返回的数据。以键值对形式返回，不超过8000个字符。 | -       |\",\"108\":\"\",\"109\":\"### 开始打车  \",\"110\":\"用于发起打车请求，支持设置出发地、目的地、车型、入口标识等参数，适用于多种打车场景（如快车、出租车、拼车等）。\",\"111\":\"\",\"112\":\"**起始版本**：1.0.1\",\"113\":\"\",\"114\":\"**参数**：  \",\"115\":\"\"}",
      "修改建议": "句式不一致，建议统一为祈使句。",
      "更改后示例": "发起打车请求，支持设置出发地、目的地、车型、入口标识等参数，适用于多种打车场景（如快车、出租车、拼车等）。",
      "触发条件": "功能描述句以\"用于\"开头，且上下文存在同类型功能描述使用祈使句结构（无主语动词短语开头）时触发。\n\n识别模式：\n1. 检查句子是否出现在功能说明段落（如\"开始打车\"等操作指南章节）\n2. 匹配\"用于[动词短语]\"的句式结构\n3. 对比上下文相邻功能描述句式（如参考句\"发起导航请求...\"的祈使结构）\n4. 验证当前句式与文档规范要求的动词短语一致性（技术文档常要求统一使用祈使句）"
    },
    {
      "defect_id": 398041,
      "sentence": "用于查询用户指定年度的个人所得税综合所得年度汇算情况，帮助纳税人了解年度收入、应纳税额、已缴税额及退税/补税金额等关键财务信息，支持税务筹划和个人财务管理。",
      "reference_sentence": "查看电话账单用于查询用户的电话账单信息，支持按日期筛选账单记录，帮助用户了解通话、短信和数据流量等使用情况。",
      "line_num": 526,
      "context": "{\"521\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0  |\",\"522\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"523\":\"\",\"524\":\"### 查看年度汇算\",\"525\":\"\",\"526\":\"用于查询用户指定年度的个人所得税综合所得年度汇算情况，帮助纳税人了解年度收入、应纳税额、已缴税额及退税/补税金额等关键财务信息，支持税务筹划和个人财务管理。\",\"527\":\"\",\"528\":\"**起始版本**：1.0.1\",\"529\":\"\",\"530\":\"**参数**：\",\"531\":\"\"}",
      "修改建议": "混用了'查询'和'查看'，应保持用词一致。",
      "更改后示例": "查看用户指定年度的个人所得税综合所得年度汇算情况，帮助纳税人了解年度收入、应纳税额、已缴税额及退税/补税金额等关键财务信息，支持税务筹划和个人财务管理。",
      "触发条件": "同一功能模块中相邻上下文存在多个同义动词（如\"查询/查看\"），且未保持术语一致性时触发。\n\n识别模式：\n1. 功能标题与正文描述动词不一致（如标题用\"查看\"，正文用\"查询\"）\n2. 参数/返回值说明与功能描述动词存在同义替换（如参数区用\"search\"，功能描述用\"query\"）\n3. 同一段落内出现可互换的同义动作词汇（如检索/查找、下载/获取等）"
    },
    {
      "defect_id": 397902,
      "sentence": "### 开始打车",
      "reference_sentence": "### 开始导航",
      "line_num": 109,
      "context": "{\"104\":\"| 参数名  | 类型  | 必选 | 说明                                                               | 数据样例 |\",\"105\":\"| ------ | ------| ---- |------------------------------------------------------------------| -------- |\",\"106\":\"| code   | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。                                          | 0 |\",\"107\":\"| result | object | 是   | 意图调用返回的数据。以键值对形式返回，不超过8000个字符。 | -       |\",\"108\":\"\",\"109\":\"### 开始打车  \",\"110\":\"用于发起打车请求，支持设置出发地、目的地、车型、入口标识等参数，适用于多种打车场景（如快车、出租车、拼车等）。\",\"111\":\"\",\"112\":\"**起始版本**：1.0.1\",\"113\":\"\",\"114\":\"**参数**：  \"}",
      "修改建议": "标题格式不一致，建议统一为祈使句。",
      "更改后示例": "### 请求开始打车",
      "触发条件": "检测到同级标题的句法结构不一致（如动宾短语与祈使句混用），或未匹配文档中其他同级标题的动词前缀模式（如「请求」「开始」等动作导向关键词）时触发。\n\n具体表现为：\n1. 标题未采用动词主导的祈使句结构（如缺少动作主体或请求语义）\n2. 与上下文相邻的同级标题（如「### 开始导航」）存在明显句式差异\n3. 不符合预设的文档规范（如要求所有功能类标题统一包含「请求」前缀）"
    },
    {
      "defect_id": 397886,
      "sentence": "登录儿童账号场景、脏标的歌曲。",
      "reference_sentence": "0表示成功；其他表示失败，如下：",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"**返回值**： \",\"40\":\"\",\"41\":\"| 参数名 | 类型  | 必选 | 说明                                                                                                                                                                                                                                     | 数据样例 |\",\"42\":\"| ------ | ---- | ---- |----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-|\",\"43\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，如下：<br>- 100060101：不支持播放会员歌曲、付费歌曲。<br>- 100060102：会员已失效，且歌曲没有试听片段。<br>- 100060201：开启了儿童保护、或登录儿童账号场景、脏标的歌曲。<br>- 100060202：歌单已下架，无法播放。<br>- 100060203：歌曲在本平台版权到期，无法播放。<br>- 100060301：歌曲/歌手被加入了屏蔽名单，歌曲无法播放。<br>- 100060401：软件故障。 | 100060101 |\",\"44\":\"| result | object | 是   | 意图调用返回的数据。以键值对形式返回，长度不超过8000个字符。                                                                                                                                                                          | {\\\"musicSize\\\":\\\"4M\\\",\\\"dataReceiveTime\\\":1704868765000} |\",\"45\":\"\",\"46\":\"### 播放有声\",\"47\":\"\",\"48\":\"用于请求播放特定的有声节目内容，支持按意图实体ID和有声节目ID进行精确查找，并返回播放结果状态。\"}",
      "修改建议": "使用了不同的词汇描述同一事物：'登录'与'帐户'混用",
      "更改后示例": "登录儿童帐户场景、脏标的歌曲。",
      "触发条件": "同一文档中出现同音异形词（如\"账号/帐户\"）混用，或同一术语存在多种表达形式（如\"登录+账号\"与\"帐户\"组合不一致）时触发。\n\n识别模式：\n1. 检测发音相同但写法不同的词汇组合（如zhàng hù的\"账号/帐户\"变体）\n2. 验证核心操作流程中的术语搭配一致性（如\"登录\"动作需统一搭配\"账号\"或\"帐户\"）\n3. 对比相邻上下文中的同类表述（如错误码说明与参数说明间的术语对应关系）"
    },
    {
      "defect_id": 397963,
      "sentence": "用于查询快递物流信息，支持通过快递单号或快递实体ID进行查询，并返回快递的最新物流状态。",
      "reference_sentence": "用于发起快递寄件请求，系统将解析需求并返回寄件操作结果。",
      "line_num": 294,
      "context": "{\"289\":\"| code | number | 是 | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0   |\",\"290\":\"| result | object | 是 | 返回结果列表对象。如果无内容，则返回空。 | - |\",\"291\":\"\",\"292\":\"## 便捷生活垂域\",\"293\":\"### 查看快递   \",\"294\":\"用于查询快递物流信息，支持通过快递单号或快递实体ID进行查询，并返回快递的最新物流状态。\",\"295\":\"\",\"296\":\"**起始版本**：1.0.1\",\"297\":\"\",\"298\":\"**参数**：     \",\"299\":\"\"}",
      "修改建议": "混用了'快递单号'和'快递实体ID'，以及'查询'和'寄件'近义词。",
      "更改后示例": "用于查询快递物流信息，支持通过快递单号或快递ID进行查询，并返回快递的最新物流状态。",
      "触发条件": "同一文档中出现同一概念使用不同术语表述（如\"快递实体ID\"与\"快递ID\"混用），或存在可能引发歧义的近义词（如\"查询\"与\"寄件\"混用）时触发。\n\n识别模式：\n1. 术语一致性检查：识别同一参数/对象出现不同命名形式（如\"实体ID\"与\"ID\"的后缀冗余）\n2. 动词一致性验证：检测功能描述中动作动词是否与上下文保持统一（如\"查询\"与\"寄件\"的功能指向差异）\n3. 跨段落比对：通过问题上下文参数表（如行289-299）验证术语使用的一致性"
    },
    {
      "defect_id": 403794,
      "sentence": "以下Node-API接口主要用于与ArkTS Promise对象进行交互。他们的使用场景如下：",
      "reference_sentence": "以下Node-API接口主要用于与ArkTS Promise对象进行交互。他们的使用场景如下：",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。Node-API提供的方法可以帮助开发者在C/C++应用中处理ArkTS中的异步操作。\",\"19\":\"\",\"20\":\"## 场景和功能介绍\",\"21\":\"\",\"22\":\"以下Node-API接口主要用于与ArkTS Promise对象进行交互。他们的使用场景如下：\",\"23\":\"\",\"24\":\"| 接口 | 描述 |\",\"25\":\"| -------- | -------- |\",\"26\":\"| napi_is_promise | 检查一个napi_value是否代表一个Promise对象时，可以使用这个函数。 |\",\"27\":\"| napi_create_promise | 需要创建一个Promise对象时，可以使用这个函数。 |\"}",
      "修改建议": "用词一致，建议使用“它们”代替“他们的”",
      "更改后示例": "以下Node-API接口主要用于与ArkTS Promise对象进行交互。它们的使用场景如下：",
      "触发条件": "当代词（如“他们”）指代前文无生命或复数主体（如“接口”）时，且存在与主体生命性/单复数不一致的物主代词（如“他们的”），应触发规则。"
    },
    {
      "defect_id": 402424,
      "sentence": "为防止二义性，其原函数名会按照匿名函数命名。",
      "reference_sentence": "为防止二义性，其原函数名会按照匿名函数命名。",
      "line_num": 78,
      "context": "{\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\",\"77\":\"    ```\",\"78\":\"* 如果属性名包含`\\\\`，`.`，为防止二义性，其原函数名会按照匿名函数命名。\",\"79\":\"    ```ts\",\"80\":\"    let a = {\",\"81\":\"        \\\"a.b#c^2\\\": () => {}                     // 原函数名为\\\"\\\"\",\"82\":\"        \\\"x\\\\\\\\y#\\\": () => {}                       // 原函数名为\\\"^1\\\"\",\"83\":\"    }\"}",
      "修改建议": "建议将“命名”改为“名称”，以保持用词一致。",
      "更改后示例": "为防止二义性，其原函数名会按照匿名函数名称。",
      "触发条件": "当同一术语在相邻或相关上下文中存在不一致的名词/动词形式（例如\"命名\"与\"名称\"），且该术语指向同一技术概念时。\n\n识别模式：\n1. 检测相邻句子或同一段落中重复出现的核心术语（如\"命名\"）\n2. 对比术语在语法角色上的统一性（名词应使用\"名称\"，动词应使用\"命名\"）\n3. 验证技术文档中是否已建立标准术语表（如参考句显示应优先使用\"名称\"作为名词形式）\n\n具体触发示例：当名词性位置出现动词形态的\"命名\"，而上下文存在应保持一致的\"名称\"用法时。"
    },
    {
      "defect_id": 403851,
      "sentence": "用于检查ArkTS对象中是否包含指定的命名属性。",
      "reference_sentence": "用于检查传入的Object是否包含自己的命名属性，不包括从原型链上继承的属性。",
      "line_num": 507,
      "context": "{\"502\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_get_named_property : %{public}s', testNapi.napiGetNamedProperty(obj, 'null'));\",\"503\":\"```\",\"504\":\"\",\"505\":\"### napi_has_named_property\",\"506\":\"\",\"507\":\"用于检查ArkTS对象中是否包含指定的命名属性。\",\"508\":\"\",\"509\":\"cpp部分代码\",\"510\":\"\",\"511\":\"```cpp\",\"512\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "使用了“包含”和“具有”两个近义词，导致表意不一致。",
      "更改后示例": "用于检查ArkTS对象中是否具有指定的命名属性。",
      "触发条件": "同一文档的相邻或相关描述中，对相同功能使用语义相近但不同的动词（如“包含”与“具有”），且上下文存在统一术语倾向时触发。"
    },
    {
      "defect_id": 403791,
      "sentence": "reject函数可以使其状态从pending变为rejected(已拒绝)",
      "reference_sentence": "reject函数可以使其状态从pending变为rejected（已拒绝）",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用Node-API接口处理异步操作。异步操作是指需要一定时间才能完成的操作，例如从网络下载数据或读取大型文件。与同步操作不同，异步操作不会阻塞主线程，而是会在后台执行。当异步操作完成后，事件循环将把它放入任务队列中，等待主线程空闲时执行。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\"}",
      "修改建议": "括号内的解释应保持一致，原句使用了中文括号，而问题句使用了英文括号",
      "更改后示例": "reject函数可以使其状态从pending变为rejected（已拒绝）",
      "触发条件": "当同一上下文中的括号类型（中文/英文）与其他同类术语解释性文字使用的括号类型不一致时触发。\n\n识别模式：检查括号形式是否与邻近相同结构内容（如技术术语+括号解释）的括号类型匹配，特别是当存在多个平行术语解释时（如\"pending（待定）\"与\"rejected(已拒绝)\"），需确保所有括号类型（中文全角/英文半角）保持统一。"
    },
    {
      "defect_id": 403594,
      "sentence": "如果属性名不包含`\\`，`.`，那么原函数名是属性名。",
      "reference_sentence": "如果属性名包含 `\\` 或 `.`，为防止二义性，其原函数名将按照匿名函数命名。",
      "line_num": 72,
      "context": "{\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名称。例如：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并被赋值给一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么原函数名是属性名。\",\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\",\"77\":\"    ```\"}",
      "修改建议": "前后描述中对属性名的检查条件不一致，前文使用了逗号分隔，后文使用了 ` 或 ` 分隔。",
      "更改后示例": "如果属性名不包含 `\\` 或 `.`，那么原函数名是属性名。",
      "触发条件": "同一文档中出现对同一条件使用不同分隔符（如逗号与\"或\"）的表述，且存在参考句式应采用统一逻辑连接词的情况。\n\n识别模式：当相邻条款或相关规则中，对并列条件的描述存在标点符号与连接词混用（如\"`\\`，`.`\"与\"`\\` 或 `.`\"）时，需检查上下文是否存在已确立的标准表达方式（如参考句中的\"或\"连接），并强制统一为规范格式。"
    },
    {
      "defect_id": 398099,
      "sentence": "用于获取特定分类的资讯博客内容列表，支持通过博客频道分类进行筛选查询，也可不指定分类获取默认博客内容。",
      "reference_sentence": "### 查看榜单用于获取特定榜单的内容列表，支持通过榜单内容ID精确查询，也可不指定榜单内容ID获取默认榜单内容。",
      "line_num": 720,
      "context": "{\"715\":\"| code  | number  | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。               | 0  |\",\"716\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"717\":\"\",\"718\":\"### 查看资讯博客\",\"719\":\"\",\"720\":\"用于获取特定分类的资讯博客内容列表，支持通过博客频道分类进行筛选查询，也可不指定分类获取默认博客内容。\",\"721\":\"\",\"722\":\"**起始版本**：1.0.1\",\"723\":\"\",\"724\":\"**参数**：\",\"725\":\"\"}",
      "修改建议": "混用了'分类'和'内容ID'的概念，且'获取'与'查询'近义词混用。",
      "更改后示例": "用于获取特定分类的资讯博客内容列表，支持通过博客频道分类进行精确查询，也可不指定分类获取默认博客内容。",
      "触发条件": "当同一功能描述中混用不同术语指代同一概念（如\"分类\"与\"内容ID\"），或同一操作使用多个近义动词（如\"获取\"与\"查询\"）时触发。识别模式需检测：1) 关键参数/对象存在多个命名表述 2) 操作动词在相同语义场景出现非必要替换。"
    },
    {
      "defect_id": 403792,
      "sentence": "当异步操作完成后，事件循环将把它放入任务队列中，等待主线程空闲时执行。",
      "reference_sentence": "当异步操作完成后，事件循环将把它放入任务队列中，等待主线程空闲时执行。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口处理异步操作\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用Node-API接口处理异步操作。异步操作是指需要一定时间才能完成的操作，例如从网络下载数据或读取大型文件。与同步操作不同，异步操作不会阻塞主线程，而是会在后台执行。当异步操作完成后，事件循环将把它放入任务队列中，等待主线程空闲时执行。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\"}",
      "修改建议": "句式一致，建议统一使用祈使句描述动作",
      "更改后示例": "将异步操作完成后放入任务队列，等待主线程空闲时执行。",
      "触发条件": "同一段落中存在混合句式（陈述句与祈使句）描述操作流程，且上下文已建立祈使句主导模式时触发。\n\n识别模式：\n1. 检测到包含\"将...\"结构的陈述句（隐含被动执行主体）\n2. 上下文存在≥2个无主语的祈使句（如\"等待...\"/\"执行...\"）\n3. 句子位于操作流程描述段落（非概念定义段落）\n\n具体表现为：当技术文档的操作说明部分出现\"事件循环将把它...\"这类主语+动作的结构，而相邻语句均采用\"等待主线程...\"等无主语祈使结构时，判定为句式不一致需修复。"
    },
    {
      "defect_id": 403852,
      "sentence": "用于定义对象的属性。",
      "reference_sentence": "用于定义对象的属性。",
      "line_num": 570,
      "context": "{\"565\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_has_named_property : %{public}s', testNapi.napiHasNamedProperty(obj, 'bol'));\",\"566\":\"```\",\"567\":\"\",\"568\":\"### napi_define_properties\",\"569\":\"\",\"570\":\"用于定义对象的属性。\",\"571\":\"\",\"572\":\"cpp部分代码\",\"573\":\"\",\"574\":\"```cpp\",\"575\":\"#include <string>\"}",
      "修改建议": "使用了“定义”和“设置”两个近义词，导致表意不一致。",
      "更改后示例": "用于设置对象的属性。",
      "触发条件": "同一文档中对相同功能或操作使用多个近义术语（如“定义”与“设置”），或与API接口名称中的动词（如napi_define_properties中的“define”）不一致时触发。\n\n识别模式：\n1. **术语冲突检测**：匹配句子中的动作动词（如“定义/设置/创建”）与对应API名称中的核心动词（如“define”）是否一致。\n2. **上下文近义对比**：在相邻段落或相同功能模块中，检测描述同类操作的动词是否出现非必要替换（如“定义”与“设置”交替使用）。"
    },
    {
      "defect_id": 403793,
      "sentence": "这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。",
      "reference_sentence": "这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。",
      "line_num": 18,
      "context": "{\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\",\"17\":\"\",\"18\":\"这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。Node-API提供的方法可以帮助开发者在C/C++应用中处理ArkTS中的异步操作。\",\"19\":\"\",\"20\":\"## 场景和功能介绍\",\"21\":\"\",\"22\":\"以下Node-API接口主要用于与ArkTS Promise对象进行交互。他们的使用场景如下：\",\"23\":\"\"}",
      "修改建议": "句式一致，建议统一使用祈使句描述动作",
      "更改后示例": "理解这些基本概念，通过适当的方法处理异步操作，使用Promise链式调用多个异步操作，使代码清晰整洁，便于维护。",
      "触发条件": "同一段落中存在混合句式结构（陈述句与祈使句混用），且上下文要求统一使用指导性语言风格（如操作建议类内容）。\n\n识别模式：当连续三个及以上并列分句出现\"需要...处理\"（陈述句）、\"可以...调用\"（能力描述句）与未出现主语的\"使用...调用\"（祈使句）混用时，检测到句式断裂。具体通过动词短语结构差异（主语+谓语 vs 无主语的动宾结构）和语义意图（客观陈述能力 vs 操作指引）双重维度判断。"
    },
    {
      "defect_id": 398145,
      "sentence": "用户通过该意图触发系统创建一个新的账户，完成必要的信息验证与账户初始化流程。",
      "reference_sentence": "用户通过该意图触发与客服系统的连接，获取客服支持，解决使用过程中的问题或咨询相关信息。",
      "line_num": 907,
      "context": "{\"902\":\"| code  | number | 是       | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。            | 0  |\",\"903\":\"| result | object | 是       | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"904\":\"\",\"905\":\"### 创建新账户\",\"906\":\"\",\"907\":\"用户通过该意图触发系统创建一个新的账户，完成必要的信息验证与账户初始化流程。\",\"908\":\"\",\"909\":\"**起始版本**：1.0.1\",\"910\":\"\",\"911\":\"**参数**：  \",\"912\":\"\"}",
      "修改建议": "描述同一事物时，用词不一致，'账户'与'帐户'混用。",
      "更改后示例": "用户通过该意图触发系统创建一个新的帐户，完成必要的信息验证与帐户初始化流程。",
      "触发条件": "当同一术语（如\"账户/帐户\"）在相邻上下文或同一功能描述中出现两种及以上拼写变体，且指代完全相同的概念时触发。\n\n识别模式：通过近义词检测算法匹配发音相同但写法不同的词汇（如中文同音异形词），结合上下文语义分析确认是否指向同一实体。特别关注技术文档中高频术语在3个句子距离范围内的重复出现情况，若检测到\"账户\"与\"帐户\"类混用，且前后无定义变更说明时判定违规。"
    },
    {
      "defect_id": 402422,
      "sentence": "如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。",
      "reference_sentence": "如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。",
      "line_num": 67,
      "context": "{\"62\":\"() => { }                                   // 原函数名为\\\"\\\"\",\"63\":\"() => { }                                   // 原函数名为\\\"^1\\\"\",\"64\":\"```\",\"65\":\"\",\"66\":\"#### 特殊情况\",\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。比如下面的例子：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么它的原函数名则是这个属性名。\"}",
      "修改建议": "建议将“变量名”改为“变量名称”，以保持用词一致。",
      "更改后示例": "如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名称。",
      "触发条件": "当同一术语在文档中存在多个不一致的表达形式（如\"变量名\"和\"变量名称\"），且上下文存在已确立的标准用词（如参考句中的\"变量名\"）时触发。需通过术语变体匹配（如\"名\"与\"名称\"后缀差异）和上下文用词对比进行识别。"
    },
    {
      "defect_id": 402423,
      "sentence": "如果属性名不包含`\\`，`.`，那么它的原函数名则是这个属性名。",
      "reference_sentence": "如果属性名不包含`\\`，`.`，那么它的原函数名则是这个属性名。",
      "line_num": 72,
      "context": "{\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。比如下面的例子：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么它的原函数名则是这个属性名。\",\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\",\"77\":\"    ```\"}",
      "修改建议": "建议将“属性名”改为“属性名称”，以保持用词一致。",
      "更改后示例": "如果属性名不包含`\\`，`.`，那么它的原函数名则是这个属性名称。",
      "触发条件": "当同一术语在文档中存在多个变体表达（如“属性名”与“属性名称”），且上下文已明确采用某一规范用词时触发。识别模式需检测相邻段落或同一逻辑单元内术语表达的变体冲突。"
    },
    {
      "defect_id": 398100,
      "sentence": "用于获取指定书籍的阅读权限和内容数据，支持通过书籍ID精确查找，并返回阅读结果状态及书籍元数据信息。",
      "reference_sentence": "### 查看榜单用于获取特定榜单的内容列表，支持通过榜单内容ID精确查询，也可不指定榜单内容ID获取默认榜单内容。",
      "line_num": 740,
      "context": "{\"735\":\"| code | number | 是 | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。     | 0                                                           |\",\"736\":\"| result | object | 是 | 返回结果列表对象。如果无内容，则返回空。 | - |\",\"737\":\"\",\"738\":\"### 阅读书籍    \",\"739\":\"\",\"740\":\"用于获取指定书籍的阅读权限和内容数据，支持通过书籍ID精确查找，并返回阅读结果状态及书籍元数据信息。\",\"741\":\"\",\"742\":\"**起始版本**：1.0.1\",\"743\":\"\",\"744\":\"**参数**：\",\"745\":\"\"}",
      "修改建议": "混用了'获取'和'查询'的概念，且'内容数据'与'内容列表'不一致。",
      "更改后示例": "用于获取指定书籍的阅读权限和内容数据，支持通过书籍ID精确查询，并返回阅读结果状态及书籍元数据信息。",
      "触发条件": "同一功能描述中混用不同动词（如\"获取/查找/查询\"）或关键术语（如\"内容数据/内容列表\"）不一致，且上下文存在明确的标准用词（如参考句中的\"查询\"和\"内容列表\"）。"
    },
    {
      "defect_id": 398128,
      "sentence": "用于获取特定购物场景或商品的攻略信息，支持通过意图实体ID精准定位攻略内容，为用户提供专业的购物指导和建议。",
      "reference_sentence": "用于获取指定书籍的阅读权限和内容数据，支持通过书籍ID精确查找，并返回阅读结果状态及书籍元数据信息。",
      "line_num": 780,
      "context": "{\"775\":\"| code | number | 是  | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0 |\",\"776\":\"| result | object | 是  | 返回结果列表对象。如果无内容，则返回空。 | {\\\"items\\\": [{\\\"productId\\\": \\\"12345\\\", \\\"name\\\": \\\"示例商品\\\", \\\"price\\\": 99.99}]} |\",\"777\":\"\",\"778\":\"### 查看购物攻略\",\"779\":\"\",\"780\":\"用于获取特定购物场景或商品的攻略信息，支持通过意图实体ID精准定位攻略内容，为用户提供专业的购物指导和建议。\",\"781\":\"\",\"782\":\"**起始版本**：1.0.1\",\"783\":\"\",\"784\":\"**参数**：    \",\"785\":\"\"}",
      "修改建议": "同一概念（意图实体ID）在不同段落中使用了不同的表述方式。",
      "更改后示例": "用于获取特定购物场景或商品的攻略信息，支持通过书籍ID精准定位攻略内容，为用户提供专业的购物指导和建议。",
      "触发条件": "当同一概念在相邻段落或相关参数中出现术语不一致（如\"意图实体ID\" vs \"书籍ID\"），且上下文存在已定义的规范表述（如参考句中的\"书籍ID\"）时触发。\n\n识别模式：\n1. 核心实体存在多版本命名（通过NLP识别同指实体）\n2. 同一功能模块的参数命名与描述文本不一致（如参数列使用productId，描述文本使用意图实体ID）\n3. 相邻段落/接口存在规范术语参考（如参考句中确立的\"书籍ID\"标准表述）"
    },
    {
      "defect_id": 398136,
      "sentence": "用户通过该意图触发系统查询并返回当前可用的付款码信息，用于线下支付场景。",
      "reference_sentence": "用户通过该意图触发系统查询并展示当前有效的医保码（电子医保凭证），用于线下医疗费用结算或医保相关服务场景。",
      "line_num": 854,
      "context": "{\"849\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"850\":\"\",\"851\":\"## 实用工具垂域\",\"852\":\"### 查看付款码\",\"853\":\"\",\"854\":\"用户通过该意图触发系统查询并返回当前可用的付款码信息，用于线下支付场景。\",\"855\":\"\",\"856\":\"**起始版本**：1.0.1\",\"857\":\"\",\"858\":\"**参数**：\",\"859\":\"\"}",
      "修改建议": "混用了“查询并返回”和“查询并展示”描述同一操作。",
      "更改后示例": "用户通过该意图触发系统查询并展示当前可用的付款码信息，用于线下支付场景。",
      "触发条件": "同一文档中对相同操作使用不一致的动词（如\"返回\"与\"展示\"），且上下文存在已确立的标准表述（如参考句中的\"查询并展示\"）时触发。\n\n识别模式：\n1. 动词冲突检测：识别描述同类系统动作时使用的不同动词（如返回/展示/显示）\n2.上下文一致性验证：检查问题参数描述（如\"返回结果列表对象\"）与用户操作描述（应使用\"展示\"）的语义分层是否被破坏\n3.参考对标匹配：当存在已定义的标准化表达（如参考句的\"查询并展示\"）时，检测偏离该标准的表述"
    },
    {
      "defect_id": 403796,
      "sentence": "napi_create_promise用于创建一个Promise对象。",
      "reference_sentence": "napi_create_promise用于创建一个Promise对象。",
      "line_num": 86,
      "context": "{\"81\":\"hilog.info(0x0000, 'Node-API', 'napi_is_promise string %{public}s', testNapi.isPromise(''));\",\"82\":\"```\",\"83\":\"\",\"84\":\"### napi_create_promise\",\"85\":\"\",\"86\":\"napi_create_promise用于创建一个Promise对象。\",\"87\":\"\",\"88\":\"使用该接口时应注意：\",\"89\":\"\",\"90\":\"1. 当有异常未处理时调用`napi_create_promise`，会返回`napi_pending_exception`。\",\"91\":\"2. 使用`napi_create_promise`后未判断返回值是否为`napi_ok`，之后使用了无效的`deferred`和`promise`导致应用崩溃。\"}",
      "修改建议": "句式一致，建议统一使用祈使句描述动作",
      "更改后示例": "使用napi_create_promise创建一个Promise对象。",
      "触发条件": "当文档中描述接口功能时使用陈述句（如\"用于...\"结构），而上下文或规范要求统一使用祈使句（动词开头）结构时触发。\n\n识别模式：\n1. 检测到\"用于+动词\"的陈述句式（如\"用于创建...\"）\n2. 对比上下文发现存在同类接口描述使用祈使句（如\"使用...创建...\"）\n3. 句子的语义功能属于操作说明而非概念解释时"
    },
    {
      "defect_id": 398137,
      "sentence": "用户通过该意图触发系统调用设备摄像头进行扫码或图像识别功能，支持多种扫描模式，包括通用扫码、文字提取、翻译、物体识别及多种证件扫描等。",
      "reference_sentence": "用户通过该意图触发系统查询并展示当前有效的医保码（电子医保凭证），用于线下医疗费用结算或医保相关服务场景。",
      "line_num": 871,
      "context": "{\"866\":\"| code  | number | 是       | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。            | 0  |\",\"867\":\"| result | object | 是       | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"868\":\"\",\"869\":\"### 扫码\",\"870\":\"\",\"871\":\"用户通过该意图触发系统调用设备摄像头进行扫码或图像识别功能，支持多种扫描模式，包括通用扫码、文字提取、翻译、物体识别及多种证件扫描等。\",\"872\":\"\",\"873\":\"**起始版本**：1.0.1\",\"874\":\"\",\"875\":\"**参数**：\",\"876\":\"\"}",
      "修改建议": "混用了“调用设备摄像头进行扫码或图像识别功能”和“查询并展示”描述同一操作。",
      "更改后示例": "用户通过该意图触发系统调用设备摄像头进行扫码或图像识别，并展示扫描结果，支持多种扫描模式，包括通用扫码、文字提取、翻译、物体识别及多种证件扫描等。",
      "触发条件": "当同一功能描述中混用不同动词结构（如\"调用功能\"与\"查询并展示\"），且上下文存在规范表达范例时。  \n\n识别模式：检查句子是否在同一操作流程中使用了不一致的动作表述（如功能调用与结果展示分离），并对比上下文是否存在标准化的\"触发系统[动作]+[结果]\"结构作为参照。"
    },
    {
      "defect_id": 403848,
      "sentence": "用于检查传入的Object是否具有自己的命名属性，不包括从原型链上继承的属性。",
      "reference_sentence": "用于检查传入的Object是否具有自己的命名属性，不包括从原型链上继承的属性。",
      "line_num": 321,
      "context": "{\"316\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_delete_property config: %{public}s', testNapi.deleteProperty(obj, 'config'));\",\"317\":\"```\",\"318\":\"\",\"319\":\"### napi_has_own_property\",\"320\":\"\",\"321\":\"用于检查传入的Object是否具有自己的命名属性，不包括从原型链上继承的属性。\",\"322\":\"\",\"323\":\"cpp部分代码\",\"324\":\"\",\"325\":\"```cpp\",\"326\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "使用了“具有”和“包含”两个近义词，导致表意不一致。",
      "更改后示例": "用于检查传入的Object是否包含自己的命名属性，不包括从原型链上继承的属性。",
      "触发条件": "同一文档相邻上下文或相同功能描述中，针对同一概念/操作使用不同近义词（如\"具有\"与\"包含\"），且存在明确统一用词参照时。"
    },
    {
      "defect_id": 403795,
      "sentence": "当需要对promise关联的deferred对象进行resolve，将其从挂起状态转换为已解决状态时，可以使用这个函数。",
      "reference_sentence": "当需要对promise关联的deferred对象进行resolve，将其从挂起状态转换为已解决状态时，可以使用这个函数。",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"| 接口 | 描述 |\",\"25\":\"| -------- | -------- |\",\"26\":\"| napi_is_promise | 检查一个napi_value是否代表一个Promise对象时，可以使用这个函数。 |\",\"27\":\"| napi_create_promise | 需要创建一个Promise对象时，可以使用这个函数。 |\",\"28\":\"| napi_resolve_deferred | 当你需要对promise关联的deferred对象进行resolve，将其从挂起状态转换为已解决状态时，可以使用这个函数。 |\",\"29\":\"| napi_reject_deferred | 当你需要对promise关联的deferred对象进行reject，将其从挂起状态转换为已拒绝状态时，可以使用这个函数。 |\",\"30\":\"\",\"31\":\"## 使用示例\",\"32\":\"\",\"33\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\"}",
      "修改建议": "用词一致，建议使用“已兑现”代替“已解决”",
      "更改后示例": "当需要对promise关联的deferred对象进行resolve，将其从挂起状态转换为已兑现状态时，可以使用这个函数。",
      "触发条件": "当同一文档中对相同技术概念存在两种及以上中文译法（如\"已解决\"和\"已兑现\"），且存在已明确定义的规范术语时触发。\n\n识别模式：\n1. 通过对比上下文相同语义位置（如并列的接口描述）的术语使用差异\n2. 检测技术术语是否与既定规范（如官方文档、术语表）存在冲突\n3. 识别同一技术动作（resolve/reject）对应的状态转换术语是否形成逻辑对应关系（如\"已兑现/已拒绝\"的对称表述）"
    },
    {
      "defect_id": 398092,
      "sentence": "用于查询特定租房房源的详细信息，包括房屋基本信息、租金价格、地理位置、配套设施等内容，辅助用户进行租房决策。",
      "reference_sentence": "用于远程访问和管理智能设备（如摄像头、监控设备等）的实时画面或历史录像，支持按设备唯一标识定位目标设备，并指定查看模式（实时画面或录像回放），满足用户对设备状态的实时监控和历史记录追溯需求。",
      "line_num": 639,
      "context": "{\"634\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。 | 0  |\",\"635\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。   | -    |\",\"636\":\"\",\"637\":\"### 查看租房信息\",\"638\":\"\",\"639\":\"用于查询特定租房房源的详细信息，包括房屋基本信息、租金价格、地理位置、配套设施等内容，辅助用户进行租房决策。\",\"640\":\"\",\"641\":\"**起始版本**：1.0.1\",\"642\":\"\",\"643\":\"**参数**：\",\"644\":\"\"}",
      "修改建议": "句式不一致，建议使用统一的祈使句",
      "更改后示例": "查询特定租房房源的详细信息，包括房屋基本信息、租金价格、地理位置、配套设施等内容，辅助用户进行租房决策。",
      "触发条件": "功能描述句首出现“用于”等非祈使句结构，且上下文同类条目采用统一动词原形开头。"
    },
    {
      "defect_id": 403841,
      "sentence": "检查对象中是否存在指定的属性，可以避免访问不存在属性导致的异常或错误。",
      "reference_sentence": "在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。",
      "line_num": 199,
      "context": "{\"194\":\"}\",\"195\":\"```\",\"196\":\"\",\"197\":\"### napi_has_property\",\"198\":\"\",\"199\":\"检查对象中是否存在指定的属性，可以避免访问不存在属性导致的异常或错误。\",\"200\":\"\",\"201\":\"cpp部分代码\",\"202\":\"\",\"203\":\"```cpp\",\"204\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "前后描述矛盾，前文描述了在访问前检查属性的必要性，而此处重复了相同的理由。",
      "更改后示例": "检查对象中是否存在指定的属性，可以避免访问不存在的属性导致的异常或错误。",
      "触发条件": "当同一段落或相邻上下文中出现相同语义但表述不一致的术语（如\"不存在属性\"与\"不存在的属性\"），且存在重复的说明性内容时触发。\n\n识别模式：1) 检查相邻语句是否存在重复的\"属性检查-异常规避\"逻辑链 2) 对比\"不存在属性\"的语法结构是否统一（是否缺失助词\"的\"）3) 检测是否在相同API说明场景下重复出现相同的风险提示。"
    },
    {
      "defect_id": 403849,
      "sentence": "用于在传入的ArkTS对象上设置一个命名属性。",
      "reference_sentence": "用于在传入的ArkTS对象上设置一个命名属性。",
      "line_num": 385,
      "context": "{\"380\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_has_own_property inherited: %{public}s', testNapi.napiHasOwnProperty(myObj, 'inheritedProperty'));\",\"381\":\"```\",\"382\":\"\",\"383\":\"### napi_set_named_property\",\"384\":\"\",\"385\":\"用于在传入的ArkTS对象上设置一个命名属性。\",\"386\":\"\",\"387\":\"cpp部分代码\",\"388\":\"\",\"389\":\"```cpp\",\"390\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "使用了“设置”和“添加”两个近义词，导致表意不一致。",
      "更改后示例": "用于在传入的ArkTS对象上添加一个命名属性。",
      "触发条件": "同一文档或相邻上下文中出现多个近义词描述同一操作，且存在已定义的规范术语（如参考句子中的\"设置\"）。通过对比动词选择与上下文术语的一致性，识别需统一表述的冲突点。"
    },
    {
      "defect_id": 402773,
      "sentence": "可以基于ArrayBuffer构造XmlPullParser对象，也可以基于DataView构造XmlPullParser对象（两种构造方式返回结果无区别可任选一种）。",
      "reference_sentence": "可以基于ArrayBuffer构造XmlPullParser对象，也可以基于DataView构造XmlPullParser对象（两种构造方式返回结果无区别可任选一种）。",
      "line_num": 38,
      "context": "{\"33\":\"    import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文本编码\",\"34\":\"    ```\",\"35\":\"\",\"36\":\"2. 对XML文本编码后调用XmlPullParser。\",\"37\":\"\",\"38\":\"   可以基于ArrayBuffer构造XmlPullParser对象，也可以基于DataView构造XmlPullParser对象（两种构造方式返回结果无区别可任选一种）。\",\"39\":\"\",\"40\":\"    ```ts\",\"41\":\"    let strXml: string =\",\"42\":\"    '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>' +\",\"43\":\"      '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\"}",
      "修改建议": "表意模糊，'构造'与'创建'不一致",
      "更改后示例": "可以基于ArrayBuffer创建XmlPullParser对象，也可以基于DataView创建XmlPullParser对象（两种创建方式返回结果无区别可任选一种）。",
      "触发条件": "在同一上下文或相邻语句中，对同一操作行为使用了不同的动词表述（如\"构造\"与\"创建\"混用），且存在明确的标准参考表达（如参考句中的\"构造\"统一用法）。"
    },
    {
      "defect_id": 398127,
      "sentence": "用于获取指定商品的详细信息，支持通过商品链接或意图实体ID两种方式查询商品数据，满足不同场景下的商品信息获取需求。",
      "reference_sentence": "用于获取指定书籍的阅读权限和内容数据，支持通过书籍ID精确查找，并返回阅读结果状态及书籍元数据信息。",
      "line_num": 760,
      "context": "{\"755\":\"| result | object  | 是  | 意图调用返回的数据。以键值对形式返回，不超过8000个字符。                                                                                                                                                                                                                                                                                        | {\\\"bookSize\\\":\\\"4M\\\",\\\"dataReceiveTime\\\":1704868765000} |\",\"756\":\"\",\"757\":\"## 购物比价垂域\",\"758\":\"### 查看商品\",\"759\":\"\",\"760\":\"用于获取指定商品的详细信息，支持通过商品链接或意图实体ID两种方式查询商品数据，满足不同场景下的商品信息获取需求。\",\"761\":\"\",\"762\":\"**起始版本**：1.0.2\",\"763\":\"\",\"764\":\"**参数**：  \",\"765\":\"\"}",
      "修改建议": "同一概念（意图实体ID）在不同段落中使用了不同的表述方式。",
      "更改后示例": "用于获取指定商品的详细信息，支持通过商品链接或书籍ID两种方式查询商品数据，满足不同场景下的商品信息获取需求。",
      "触发条件": "同一概念在相邻上下文或关联功能描述中出现术语不一致，且存在更符合领域特征的标准表述时触发。\n\n识别模式：通过对比文档中相同功能模块的参数命名（如\"意图实体ID\"与参考句中的\"书籍ID\"）、检查领域特征词匹配度（购物垂域应使用\"商品ID/书籍ID\"而非通用术语\"意图实体ID\"），以及验证术语与接口参数定义的一致性（上下文参数列表未出现\"意图实体ID\"）来识别问题。"
    },
    {
      "defect_id": 402770,
      "sentence": "获取tagValue回调函数，打印标签及标签值。默认为undefined，表示不解析XML标签和标签值。",
      "reference_sentence": "获取tagValue回调函数，打印标签及标签值。默认为undefined，表示不解析XML标签和标签值。",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"| 名称 | 类型 | 必填 | 说明 |\",\"13\":\"| -------- | -------- | -------- | -------- |\",\"14\":\"| supportDoctype | boolean | 否 | 是否解析文档类型，false表示不解析文档类型，true表示解析文档类型，默认false。 |\",\"15\":\"| ignoreNameSpace | boolean | 否 | 是否忽略命名空间，忽略命名空间后，将不会对其进行解析。true表示忽略命名空间，false表示不忽略命名空间，默认false。|\",\"16\":\"| tagValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取tagValue回调函数，打印标签及标签值。默认为undefined，表示不解析XML标签和标签值。 |\",\"17\":\"| attributeValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取attributeValue回调函数，打印属性及属性值。默认为undefined，表示不解析XML属性和属性值。 |\",\"18\":\"| tokenValueCallbackFunction | (eventType: EventType, value: ParseInfo) =&gt; boolean | 否 | 获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。 |\",\"19\":\"\",\"20\":\"\",\"21\":\"## 注意事项\"}",
      "修改建议": "表意模糊，'标签'与'XML标签'不一致",
      "更改后示例": "获取tagValue回调函数，打印XML标签及标签值。默认为undefined，表示不解析XML标签和标签值。",
      "触发条件": "当同一术语在相邻条目或上下文描述中存在非对称表述（如\"标签\"与\"XML标签\"混用），且存在可对照的标准化表达范例（如其他参数描述中的\"XML属性\"）时触发。\n\n识别模式：\n1. 术语不对称：核心名词在描述同一对象时出现基础形式与限定形式混用（如通用\"标签\" vs 限定\"XML标签\"）\n2. 对照异常：在相邻参数描述中存在平行结构的标准化表达（如attributeValueCallbackFunction明确使用\"XML属性\"）\n3. 歧义风险：基础形式可能引发多义解读（单独\"标签\"可指代XML标签/HTML标签/其他标记）"
    },
    {
      "defect_id": 403934,
      "sentence": "2. HAP包的开发者需要重点知悉[混淆规则的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆规则的情况。",
      "reference_sentence": "推荐开发者在默认混淆（包含局部变量和参数混淆）的基础上，开启混淆配置文件中的以下四项基础混淆选项：",
      "line_num": 26,
      "context": "{\"21\":\"当应用功能调试正常后，还可继续开启代码压缩（`-compact`）与日志删除（`-remove-log`）等功能以发布release应用包。\",\"22\":\"\",\"23\":\"## HAP包混淆建议\",\"24\":\"\",\"25\":\"1. 开启混淆规则。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。\",\"26\":\"2. HAP包的开发者需要重点知悉[混淆规则的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆规则的情况。\",\"27\":\"\",\"28\":\"3. 在此基础上，还需了解哪种依赖包内的代码会跟随本模块一起参与编译混淆，因为这会影响混淆新生成的名称和部分全局生效（如属性名称）的白名单，从而影响到本模块最终的混淆效果。具体而言：\",\"29\":\"    - 当依赖本地HAR包时，其代码会跟随本模块一起混淆，混淆前后的名称会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"30\":\"    - 当依赖发布态源码HAR包时，安装在工程级`oh_modules`目录下的代码会跟随本模块一起混淆，混淆前后的名称也会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"31\":\"    - 当依赖发布态字节码HAR包或HSP包时，参与编译的是其中的二进制字节码和声明文件，由于ArkGuard工具只支持源码混淆，不支持字节码混淆，且为了保证声明文件中的接口与二进制中的实现的一致性，不会对这部分代码进行混淆。但是，若三方库未正确提供接口的声明或者未在`consumer-rules`中配置白名单，在HAP中使用这些三方库接口的地方可能会被混淆，此时HAP包开发者可以自行配置，来保证运行时的正确性。\"}",
      "修改建议": "混用了“混淆规则”和“混淆选项”",
      "更改后示例": "2. HAP包的开发者需要重点知悉[混淆选项的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆选项的情况。",
      "触发条件": "在同一上下文或相邻段落中，同一技术概念（如\"混淆规则\"与\"混淆选项\"）存在术语混用，且存在以下任一特征：(1) 同一句子内术语前后不一致；(2) 与参考定义（如配置文件描述）或已统一使用的术语（如\"混淆选项\"在配置场景的规范用法）产生冲突。"
    },
    {
      "defect_id": 402772,
      "sentence": "获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。",
      "reference_sentence": "获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。",
      "line_num": 18,
      "context": "{\"13\":\"| -------- | -------- | -------- | -------- |\",\"14\":\"| supportDoctype | boolean | 否 | 是否解析文档类型，false表示不解析文档类型，true表示解析文档类型，默认false。 |\",\"15\":\"| ignoreNameSpace | boolean | 否 | 是否忽略命名空间，忽略命名空间后，将不会对其进行解析。true表示忽略命名空间，false表示不忽略命名空间，默认false。|\",\"16\":\"| tagValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取tagValue回调函数，打印标签及标签值。默认为undefined，表示不解析XML标签和标签值。 |\",\"17\":\"| attributeValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取attributeValue回调函数，打印属性及属性值。默认为undefined，表示不解析XML属性和属性值。 |\",\"18\":\"| tokenValueCallbackFunction | (eventType: EventType, value: ParseInfo) =&gt; boolean | 否 | 获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。 |\",\"19\":\"\",\"20\":\"\",\"21\":\"## 注意事项\",\"22\":\"\",\"23\":\"- 确保传入的XML数据符合标准格式。\"}",
      "修改建议": "表意模糊，'标签事件类型'与'XML事件类型'不一致",
      "更改后示例": "获取tokenValue回调函数，打印XML事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。",
      "触发条件": "同一文档或上下文中出现对同一概念使用多个不一致的术语表述（例如\"标签事件类型\"与\"XML事件类型\"），且存在已定义的统一术语（如上下文其他条目均使用\"XML\"前缀）时触发。\n\n识别模式：\n1. 术语冲突检测：识别句子中与上下文已定义术语（如\"XML事件类型\"）存在语义重叠但表述形式不同的词汇（如\"标签事件类型\"）\n2. 前缀一致性验证：检查特定领域前缀（如\"XML\"）是否在同类参数描述中形成固定搭配模式（上下文参数均采用\"XML+事件类型/标签/属性\"结构）"
    },
    {
      "defect_id": 403977,
      "sentence": "HAR包功能验证。需注意，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，则本HAR包发布后的代码还会跟随使用方被二次混淆，因为需要充分验证使用方开启混淆时HAR包功能是否正常。",
      "reference_sentence": "HAR包功能验证。需注意，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，则本HAR包发布后的代码还会跟随使用方被二次混淆，因为需要充分验证使用方开启混淆时HAR包功能是否正常。",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"1. 开启混淆规则。建议开启推荐的[四项混淆规则](#推荐混淆功能)，其它选项按需添加。\",\"68\":\"2. 了解需要[配置白名单的场景](source-obfuscation.md#保留选项)，配置HAR中的白名单：\",\"69\":\"    - obfuscation-rules.txt中配置HAR包对外导出接口及其相关属性名称、此次构建过程不能被混淆的名称等。\",\"70\":\"    - consumer-rules.txt配置不能被二次混淆的接口、属性等名称。\",\"71\":\"3. HAR包功能验证。需注意，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，则本HAR包发布后的代码还会跟随使用方被二次混淆，因为需要充分验证使用方开启混淆时HAR包功能是否正常。\",\"72\":\"4. 发布HAR包。\",\"73\":\"\",\"74\":\"> **说明**：\",\"75\":\">\",\"76\":\"> 当被其他模块依赖时，有以下两点需要注意：\"}",
      "修改建议": "句式不一致，建议统一使用祈使句",
      "更改后示例": "验证HAR包功能。需注意，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，则本HAR包发布后的代码还会跟随使用方被二次混淆，因此需要充分验证使用方开启混淆时HAR包功能是否正常。",
      "触发条件": "同一列表项或上下文中存在句式混用（陈述句与祈使句混用），且句首出现因果连词（\"因为\"/\"因此\"）与相邻条目动词开头的结构不一致时触发。\n\n识别模式：\n1. 在编号列表/条目化结构中，当某条目出现\"因为需要...\"的陈述句式，而相邻条目采用\"动词+宾语\"的祈使结构（如\"开启规则\"\"了解场景\"）时\n2. 句首存在因果连词（\"因为\"）与动作要求混用，导致该条目与上下文句式结构不平行"
    },
    {
      "defect_id": 403933,
      "sentence": "1. 开启混淆规则。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。",
      "reference_sentence": "推荐开发者在默认混淆（包含局部变量和参数混淆）的基础上，开启混淆配置文件中的以下四项基础混淆选项：",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"当应用功能调试正常后，还可继续开启代码压缩（`-compact`）与日志删除（`-remove-log`）等功能以发布release应用包。\",\"22\":\"\",\"23\":\"## HAP包混淆建议\",\"24\":\"\",\"25\":\"1. 开启混淆规则。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。\",\"26\":\"2. HAP包的开发者需要重点知悉[混淆规则的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆规则的情况。\",\"27\":\"\",\"28\":\"3. 在此基础上，还需了解哪种依赖包内的代码会跟随本模块一起参与编译混淆，因为这会影响混淆新生成的名称和部分全局生效（如属性名称）的白名单，从而影响到本模块最终的混淆效果。具体而言：\",\"29\":\"    - 当依赖本地HAR包时，其代码会跟随本模块一起混淆，混淆前后的名称会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"30\":\"    - 当依赖发布态源码HAR包时，安装在工程级`oh_modules`目录下的代码会跟随本模块一起混淆，混淆前后的名称也会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\"}",
      "修改建议": "混用了“混淆规则”和“混淆选项”",
      "更改后示例": "1. 开启混淆选项。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。",
      "触发条件": "同一文档中相邻段落或同一功能描述中，出现针对同一技术概念的多个不同术语（如\"规则\"与\"选项\"混用），且上下文存在明确的标准术语参照（如参考句中的\"混淆选项\"）。"
    },
    {
      "defect_id": 402771,
      "sentence": "获取attributeValue回调函数，打印属性及属性值。默认为undefined，表示不解析XML属性和属性值。",
      "reference_sentence": "获取attributeValue回调函数，打印属性及属性值。默认为undefined，表示不解析XML属性和属性值。",
      "line_num": 17,
      "context": "{\"12\":\"| 名称 | 类型 | 必填 | 说明 |\",\"13\":\"| -------- | -------- | -------- | -------- |\",\"14\":\"| supportDoctype | boolean | 否 | 是否解析文档类型，false表示不解析文档类型，true表示解析文档类型，默认false。 |\",\"15\":\"| ignoreNameSpace | boolean | 否 | 是否忽略命名空间，忽略命名空间后，将不会对其进行解析。true表示忽略命名空间，false表示不忽略命名空间，默认false。|\",\"16\":\"| tagValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取tagValue回调函数，打印标签及标签值。默认为undefined，表示不解析XML标签和标签值。 |\",\"17\":\"| attributeValueCallbackFunction | (name: string, value: string) =&gt; boolean | 否 | 获取attributeValue回调函数，打印属性及属性值。默认为undefined，表示不解析XML属性和属性值。 |\",\"18\":\"| tokenValueCallbackFunction | (eventType: EventType, value: ParseInfo) =&gt; boolean | 否 | 获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。 |\",\"19\":\"\",\"20\":\"\",\"21\":\"## 注意事项\",\"22\":\"\"}",
      "修改建议": "表意模糊，'属性'与'XML属性'不一致",
      "更改后示例": "获取attributeValue回调函数，打印XML属性及属性值。默认为undefined，表示不解析XML属性和属性值。",
      "触发条件": "当同一参数说明中核心术语（如\"属性\"）与上下文相邻条目（如\"XML属性\"）存在简写与全称表述差异，且该差异导致指代范围模糊时触发。\n\n识别模式：\n1. 对比相邻参数说明的术语结构（如第16行\"标签→XML标签\"与问题句\"属性→XML属性\"）\n2. 检测核心名词前是否缺失上下文已确立的限定词（此处XML解析场景下\"属性\"需明确为\"XML属性\"）\n3. 验证同一句子内部是否存在术语断层（前半句用简写，后半句用全称）"
    },
    {
      "defect_id": 404444,
      "sentence": "Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程投递到 ArkTS 线程。底层队列会根据任务的优先级和入队方式去处理这些任务。",
      "reference_sentence": "异步线程向 ArkTS 线程投递的任务会按照任务的优先级和入队方式去处理。",
      "line_num": 2,
      "context": "{\"1\":\"# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务\",\"2\":\"Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程投递到 ArkTS 线程。底层队列会根据任务的优先级和入队方式去处理这些任务。\",\"3\":\"\",\"4\":\"## 函数说明\",\"5\":\"\",\"6\":\"```cpp\",\"7\":\"napi_status napi_call_threadsafe_function_with_priority(napi_threadsafe_function func, void *data,\"}",
      "修改建议": "前后描述不一致，前文使用了'投递到 ArkTS 线程'，后文使用了'向 ArkTS 线程投递'。",
      "更改后示例": "Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程向 ArkTS 线程投递。底层队列会根据任务的优先级和入队方式去处理这些任务。",
      "触发条件": "同一文档中相邻或相关句子对同一动作方向使用不同介词（如\"到\"与\"向\"），或同一操作主体/客体存在语法结构不一致（如主被动转换）时触发。\n\n识别模式：通过对比上下文动词短语的语法结构，检测同一语义场景下是否保持统一的方向介词（如\"向...投递\"）、主谓宾顺序（如异步线程作为主语时保持主动态）及术语搭配方式（\"投递任务\"与\"处理任务\"的动宾结构匹配）。"
    },
    {
      "defect_id": 404496,
      "sentence": "Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程投递到 ArkTS 线程。",
      "reference_sentence": "Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 2,
      "context": "{\"1\":\"# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务\",\"2\":\"Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程投递到 ArkTS 线程。底层队列根据任务的优先级和入队方式处理这些任务。\",\"3\":\"\",\"4\":\"## 函数说明\",\"5\":\"\",\"6\":\"```cpp\",\"7\":\"napi_status napi_call_threadsafe_function_with_priority(napi_threadsafe_function func, void *data,\"}",
      "修改建议": "混用了“投递”和“投递指定优先级和入队方式的的任务”两种表述",
      "更改后示例": "Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将指定优先级和入队方式的任务从异步线程投递到 ArkTS 线程。",
      "触发条件": "同一接口功能的描述在相邻段落中混用简略表达与详细说明，导致关键参数或行为特征表述不一致。  \n\n识别模式：当同一技术术语或操作（如\"投递任务\"）在上下文出现时，若前文已明确包含附加条件（如\"指定优先级和入队方式\"），后续句子却省略该条件，则触发规则。需对比段落间动词宾语结构的完整性，检测是否存在核心修饰语缺失或冗余。"
    },
    {
      "defect_id": 404527,
      "sentence": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"    // 异步线程中调用该接口向ArkTS线程投递指定优先级和入队方式的任务\",\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true); // 投递指定优先级为napi_priority_idle，入队方式为队列尾部入队的任务",
      "触发条件": "当代码中的参数配置（如优先级/入队方式）与相邻注释或上下文描述存在语义关联但未显式对应时触发，或当同一代码段内存在同类参数的标准注释模板而当前语句未遵循时触发。\n\n识别模式：\n1. 检测函数调用包含优先级枚举值（如napi_priority_*）和入队位置布尔值参数\n2. 匹配上下文注释中是否包含\"指定优先级和入队方式\"等规范性描述模板\n3. 验证当前语句是否缺少与参数值直接对应的\"优先级为X，入队方式为Y\"的显式说明注释"
    },
    {
      "defect_id": 404445,
      "sentence": "异步线程向 ArkTS 线程投递的任务会按照任务的优先级和入队方式去处理。",
      "reference_sentence": "Node-API 中的 `napi_call_threadsafe_function_with_priority` 接口用于将任务从异步线程投递到 ArkTS 线程。底层队列会根据任务的优先级和入队方式去处理这些任务。",
      "line_num": 19,
      "context": "{\"14\":\"| data           | 异步线程期望传递给主线程的数据  |\",\"15\":\"| priority       | 指定任务的优先级[napi_task_priority](napi-data-types-interfaces.md#线程安全任务优先级) |\",\"16\":\"| isTail         | 指定任务的入队方式，true代表任务从队列的尾部入队，false代表任务从队列的头部入队。 |\",\"17\":\"\",\"18\":\"## 场景介绍\",\"19\":\"异步线程向 ArkTS 线程投递的任务会按照任务的优先级和入队方式去处理。\",\"20\":\"\",\"21\":\"## 调用异步的ArkTS接口示例\",\"22\":\"\",\"23\":\"### 示例代码\",\"24\":\"\"}",
      "修改建议": "前后描述不一致，前文使用了'投递到 ArkTS 线程'，后文使用了'向 ArkTS 线程投递'。",
      "更改后示例": "异步线程向 ArkTS 线程投递的任务会根据任务的优先级和入队方式进行处理。",
      "触发条件": "同一上下文出现对同一动作使用不同介词结构（如\"投递到\"与\"向...投递\"）或对同一逻辑关系使用不同动词搭配（如\"按照...去处理\"与\"根据...进行处理\"）时触发。\n\n识别模式：\n1. 检测关键动词短语的介词搭配一致性（如\"投递+到/向\"）\n2. 验证逻辑关系表达的统一性（如\"按照...去处理\"与\"根据...进行处理\"的语义等价性）\n3. 对比前文已确立的固定表达方式（如参考句中\"投递到\"的用法）"
    },
    {
      "defect_id": 404524,
      "sentence": "Node-API中的napi_call_threadsafe_function_with_priority接口的功能是从异步线程向ArkTS线程投递任务，底层队列会根据任务的优先级和入队方式来处理任务。",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 2,
      "context": "{\"1\":\"# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务\",\"2\":\"Node-API中的napi_call_threadsafe_function_with_priority接口的功能是从异步线程向ArkTS线程投递任务，底层队列会根据任务的优先级和入队方式来处理任务。\",\"3\":\"\",\"4\":\"## 函数说明\",\"5\":\"\",\"6\":\"```cpp\",\"7\":\"napi_status napi_call_threadsafe_function_with_priority(napi_threadsafe_function func, void *data,\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "Node-API中的napi_call_threadsafe_function_with_priority接口的功能是从异步线程向ArkTS线程投递指定优先级和入队方式的任务，底层队列会根据任务的优先级和入队方式来处理任务。",
      "触发条件": "当文档中同一接口的功能描述与上下文或参考句子的关键参数（如优先级、入队方式）不一致，且未明确提及已被其他部分定义的具体参数时触发。  \n识别模式：检查接口描述是否遗漏了上下文中已明确声明的参数（通过对比函数说明、示例代码或相邻段落），例如参数名称、任务属性等关键信息是否匹配。"
    },
    {
      "defect_id": 404498,
      "sentence": "异步线程中调用该接口向 ArkTS 线程投递指定优先级和入队方式的任务",
      "reference_sentence": "Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 59,
      "context": "{\"54\":\"        napi_call_function(env, undefined, jsCb, INT_NUM_2, argv, &resultNumber);\",\"55\":\"        int32_t res = 0;\",\"56\":\"        napi_get_value_int32(env, resultNumber, &res);\",\"57\":\"    }\",\"58\":\"\",\"59\":\"    // 异步线程中调用该接口向 ArkTS 线程投递指定优先级和入队方式的任务\",\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 设置任务优先级为napi_priority_idle，入队方式为队列尾部。\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\"}",
      "修改建议": "混用了“投递指定优先级和入队方式的任务”和“投递任务”两种表述",
      "更改后示例": "异步线程中调用该接口向 ArkTS 线程投递指定优先级和入队方式的任务。",
      "触发条件": "当同一段落或相邻语句中对同一操作/功能使用不同长度的描述性短语（如完整描述与简化表述并存）时触发；当技术术语结构在上下文出现不必要变化（如\"投递...任务\"与\"投递指定...的任务\"混用）时触发。"
    },
    {
      "defect_id": 404526,
      "sentence": "## 调用异步的ArkTS接口示例",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 21,
      "context": "{\"16\":\"| isTail         | 指定任务的入队方式，true代表任务从队列的尾部入队，false代表任务从队列的头部入队。 |\",\"17\":\"\",\"18\":\"## 场景介绍\",\"19\":\"异步线程向ArkTS主线程投递的任务需要根据任务指定的优先级和入队方式进行处理。\",\"20\":\"\",\"21\":\"## 调用异步的ArkTS接口示例\",\"22\":\"\",\"23\":\"### 示例代码\",\"24\":\"\",\"25\":\"- 模块注册\",\"26\":\"\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "## 调用指定优先级和入队方式的ArkTS接口示例",
      "触发条件": "当文档上下文明确提及特定参数或条件（如\"优先级\"和\"入队方式\"），但对应章节标题未完整包含这些关键限定词时触发；或当存在同主题参考案例已采用完整参数描述时触发。\n\n识别模式：通过对比问题句子的语义完整性（是否缺失上下文已定义的关键参数）、检查同文档其他章节的术语一致性（如参考句子的命名范式），以及验证标题是否准确反映操作的核心限定条件（如API调用场景的特殊参数要求）。"
    },
    {
      "defect_id": 404497,
      "sentence": "异步线程向 ArkTS 线程投递的任务根据优先级和入队方式处理。",
      "reference_sentence": "Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 19,
      "context": "{\"14\":\"| data           | 异步线程期望传递给主线程的数据  |\",\"15\":\"| priority       | 指定任务的优先级（[napi_task_priority](napi-data-types-interfaces.md#线程安全任务优先级)） |\",\"16\":\"| isTail         | 指定任务的入队方式，true代表任务从队列的尾部入队，false代表任务从队列的头部入队。 |\",\"17\":\"\",\"18\":\"## 场景介绍\",\"19\":\"异步线程向 ArkTS 线程投递的任务根据优先级和入队方式处理。\",\"20\":\"\",\"21\":\"## 调用异步的ArkTS接口示例\",\"22\":\"\",\"23\":\"### 示例代码\",\"24\":\"\"}",
      "修改建议": "混用了“投递的任务”和“投递指定优先级和入队方式的的任务”两种表述",
      "更改后示例": "异步线程向 ArkTS 线程投递的指定优先级和入队方式的任务根据优先级和入队方式处理。",
      "触发条件": "当同一名词短语在上下文不同位置出现修饰语不一致（如\"任务\"前缺少\"指定优先级和入队方式的\"限定），且上下文参数定义明确要求该限定属性时触发。\n\n识别模式：通过对比名词短语的完整表述形式（如参考句中的\"投递指定优先级和入队方式的任务\"）与当前句的简化表述（如\"投递的任务\"），结合上下文参数表（priority/isTail）验证该限定是否属于必要技术属性。"
    },
    {
      "defect_id": 404530,
      "sentence": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 66,
      "context": "{\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\",\"71\":\"    static void WorkComplete(napi_env env, napi_status status, void *data) {\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true); // 投递指定优先级为napi_priority_immediate，入队方式为队列尾部入队的任务",
      "触发条件": "当代码中的函数调用包含显式的优先级参数(napi_priority_*)和入队方式参数(true/false)，但对应的行内注释未同时明确说明\"指定优先级为X，入队方式为Y\"的结构化描述时触发，尤其当上下文存在同类函数调用已包含完整注释描述时。"
    },
    {
      "defect_id": 403974,
      "sentence": "在需要管理异步资源上下文环境的创建和销毁时，可以使用napi_async_init和napi_async_destroy来管理这些环境。需要注意的是，这些函数不支持与async_hook相关的能力，所以在使用时需要注意可能会存在的限制。",
      "reference_sentence": "在需要管理异步资源上下文环境的创建和销毁时，可以使用napi_async_init和napi_async_destroy来管理这些环境。需要注意的是，这些函数不支持与async_hook相关的能力，所以在使用时需要注意可能存在的一些限制。",
      "line_num": 30,
      "context": "{\"25\":\"\",\"26\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"27\":\"\",\"28\":\"### napi_async_init、napi_async_destroy\",\"29\":\"\",\"30\":\"在需要管理异步资源上下文环境的创建和销毁时，可以使用napi_async_init和napi_async_destroy来管理这些环境。需要注意的是，这些函数不支持与async_hook相关的能力，所以在使用时需要注意可能会存在的限制。\",\"31\":\"\",\"32\":\"### napi_make_callback\",\"33\":\"\",\"34\":\"在编写Node-API模块时，需要在异步操作完成后调用ArkTS回调函数。可以使用napi_async_init创建异步资源上下文环境，然后使用napi_make_callback在该环境中执行ArkTS回调函数。\",\"35\":\"\"}",
      "修改建议": "混用了“可能会存在的”和“可能存在的一些”描述同一对象",
      "更改后示例": "在需要管理异步资源上下文环境的创建和销毁时，可以使用napi_async_init和napi_async_destroy来管理这些环境。需要注意的是，这些函数不支持与async_hook相关的能力，所以在使用时需要注意可能存在的一些限制。",
      "触发条件": "同一段落或相邻句子中对同一对象使用不同结构/修饰词描述可能性时（例如\"可能会存在的\"和\"可能存在的一些\"混用）\n\n识别模式：当检测到相邻语句中针对同一限制条件出现\"可能+会存在的\"与\"可能+存在+数量词\"两种不同修饰结构时，触发一致性校验。具体特征为动词\"存在\"前出现不同副词修饰（\"会\"）或后接不同数量词（\"一些\"）的混合表达。"
    },
    {
      "defect_id": 404708,
      "sentence": "处理Promise对象：将Promise与c++回调绑定，处理异步结果。",
      "reference_sentence": "当ArkTS的返回值为promise，开发者可以按照以下方式在自己创建的ArkTS运行环境中调用异步的ArkTS接口。",
      "line_num": 8,
      "context": "{\"3\":\"## 场景介绍\",\"4\":\"当ArkTS的返回值为promise，开发者可以按照以下方式在自己创建的ArkTS运行环境中调用异步的ArkTS接口。\",\"5\":\"\",\"6\":\"## 调用异步的ArkTS接口示例\",\"7\":\"从c++使用NAPI调用返回Promise的ArkTS方法。\",\"8\":\"处理Promise对象：将Promise与c++回调绑定，处理异步结果。\",\"9\":\"转换数据类型：在回调中将JavaScript结果转换为c++可用的数据。\",\"10\":\"线程安全处理：确保跨线程操作的安全性。\",\"11\":\"\",\"12\":\"### 示例代码\",\"13\":\"- 模块注册\"}",
      "修改建议": "混用了'Promise'和'promise'，大小写不一致",
      "更改后示例": "处理promise对象：将promise与C++回调绑定，处理异步结果。",
      "触发条件": "同一技术术语在文档中出现大小写不一致（如\"Promise\"与\"promise\"混用），或编程语言/框架名称未遵循标准格式（如\"C++\"被错误拼写为\"c++\"）。通过对比上下文术语形态（如参考句中的\"promise\"全小写）及技术规范（如\"C++\"官方大写格式）识别需修复的拼写矛盾。"
    },
    {
      "defect_id": 403973,
      "sentence": "这些Node-API接口可以在Node-API模块中执行异步操作、进行ArkTS回调以及管理相关资源的生命周期。通过使用这些函数，可以有效地与ArkTS环境进行交互，并实现复杂的异步操作。他们的使用场景如下：",
      "reference_sentence": "这些Node-API接口可以在Node-API模块中执行异步操作、进行ArkTS回调以及管理相关资源的生命周期。通过使用这些函数，可以有效地与ArkTS环境进行交互，并实现复杂的异步操作。它们的使用场景如下：",
      "line_num": 17,
      "context": "{\"12\":\"- **临时结果：** 当原生方法（即Node-API代码）被调用时，它会立即返回一个临时结果给ArkTS调用者。这个临时结果通常是一个表示异步操作正在进行中的标志，或者是用于后续处理异步操作结果的句柄。\",\"13\":\"- **回调或Promise：** 当异步操作完成后，结果会通过回调函数或Promise对象返回给ArkTS调用者。这样，ArkTS代码就可以在异步操作完成后继续执行后续的逻辑。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"这些Node-API接口可以在Node-API模块中执行异步操作、进行ArkTS回调以及管理相关资源的生命周期。通过使用这些函数，可以有效地与ArkTS环境进行交互，并实现复杂的异步操作。他们的使用场景如下：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_async_init、napi_async_destroy | 用于创建和销毁异步资源上下文环境。这些函数可以用于处理长时间运行的异步操作，例如文件I/O操作、网络请求等。在这些情况下，创建异步资源上下文环境，执行必要的异步任务，然后销毁资源以释放相关的资源和内容。 |\",\"21\":\"| napi_make_callback | 用于在异步资源上下文环境中执行ArkTS回调函数。在处理异步操作的结果后，将结果传递回ArkTS代码。 |\",\"22\":\"| napi_open_callback_scope、napi_close_callback_scope | 用于创建和关闭回调作用域。在异步操作期间执行ArkTS代码并管理其上下文。 |\"}",
      "修改建议": "混用了“他们”和“它们”描述同一对象",
      "更改后示例": "这些Node-API接口可以在Node-API模块中执行异步操作、进行ArkTS回调以及管理相关资源的生命周期。通过使用这些函数，可以有效地与ArkTS环境进行交互，并实现复杂的异步操作。它们的使用场景如下：",
      "触发条件": "同一段落或相邻上下文中出现对同一无生命对象使用不同人称代词（如\"他们\"与\"它们\"）的指代不一致现象，且上下文明确显示所指对象为非人类实体（如接口/函数/模块）时触发。\n\n具体识别模式：\n1. 检测相邻3-5句内存在重复指代同一技术组件的情况\n2. 匹配中文人称代词（他们/它们/其）的混用模式\n3. 通过上下文语义分析确认所指对象为非人类实体\n4. 验证前文名词（如\"接口/函数\"）与代词单复数的一致性（复数名词对应复数代词）"
    },
    {
      "defect_id": 403924,
      "sentence": "用于创建一个Latin1编码的ArkTS字符串。",
      "reference_sentence": "需要通过ISO-8859-1编码的字符串创建ArkTS string值时使用这个函数。",
      "line_num": 266,
      "context": "{\"261\":\"hilog.info(0x0000, 'testTag', 'Test Node-API get_value_string_latin1_string %{public}s', testNapi.getValueStringLatin1('abo ABP=-&*/'));\",\"262\":\"```\",\"263\":\"\",\"264\":\"### napi_create_string_latin1\",\"265\":\"\",\"266\":\"用于创建一个Latin1编码的ArkTS字符串。\",\"267\":\"\",\"268\":\"cpp部分代码\",\"269\":\"\",\"270\":\"```cpp\",\"271\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`创建一个Latin1编码的ArkTS字符串`和`通过ISO-8859-1编码的字符串创建ArkTS string值`的表述",
      "更改后示例": "用于通过ISO-8859-1编码的字符串创建ArkTS string值。",
      "触发条件": "同一技术术语存在多个不一致的别名表述（如Latin1/ISO-8859-1），或相同操作动作使用不同动词结构（如\"创建\"与\"通过...创建\"）时触发。\n\n识别模式：通过对比文档上下文，检测对同一编码标准使用不同名称（需建立术语映射表）、对相同API功能描述使用不同句式结构（需预设\"创建\"类动词的标准表达范式）的情况。"
    },
    {
      "defect_id": 403975,
      "sentence": "在需要创建一个回调作用域来确保异步操作期间ArkTS环境仍然可用时。可以使用napi_open_callback_scope创建回调作用域，然后在异步操作完成后使用napi_close_callback_scope关闭该作用域。",
      "reference_sentence": "在需要创建一个回调作用域来确保异步操作期间ArkTS环境仍然可用时，可以使用napi_open_callback_scope创建回调作用域，然后在异步操作完成后使用napi_close_callback_scope关闭该作用域。",
      "line_num": 38,
      "context": "{\"33\":\"\",\"34\":\"在编写Node-API模块时，需要在异步操作完成后调用ArkTS回调函数。可以使用napi_async_init创建异步资源上下文环境，然后使用napi_make_callback在该环境中执行ArkTS回调函数。\",\"35\":\"\",\"36\":\"### napi_open_callback_scope、napi_close_callback_scope\",\"37\":\"\",\"38\":\"在需要创建一个回调作用域来确保异步操作期间ArkTS环境仍然可用时。可以使用napi_open_callback_scope创建回调作用域，然后在异步操作完成后使用napi_close_callback_scope关闭该作用域。\",\"39\":\"\",\"40\":\"cpp部分代码\",\"41\":\"\",\"42\":\"```cpp\",\"43\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句式不一致，缺少连接词",
      "更改后示例": "在需要创建一个回调作用域来确保异步操作期间ArkTS环境仍然可用时，可以使用napi_open_callback_scope创建回调作用域，然后在异步操作完成后使用napi_close_callback_scope关闭该作用域。",
      "触发条件": "当条件状语从句（如\"在...时\"）与主句之间使用句号分隔导致句式断裂，且主句缺少连接词（如\"可以\"）时触发。"
    },
    {
      "defect_id": 404547,
      "sentence": "1. napi_add_env_cleanup_hook*",
      "reference_sentence": "napi_add_env_cleanup_hook",
      "line_num": 343,
      "context": "{\"338\":\">\",\"339\":\"> current napi interface cannot run in multi-thread, thread id: &lt;env tid&gt;, current thread id: &lt;current tid&gt;\",\"340\":\"\",\"341\":\"该维测手段覆盖范围如下：\",\"342\":\"\",\"343\":\"1. napi_add_env_cleanup_hook*\",\"344\":\"2. napi_remove_env_cleanup_hook*\",\"345\":\"3. napi_add_async_cleanup_hook\",\"346\":\"4. napi_set_instance_data\",\"347\":\"5. napi_get_instance_data\",\"348\":\"\"}",
      "修改建议": "前后文对同一接口使用了不同的表述（“napi_add_env_cleanup_hook*”与“napi_add_env_cleanup_hook”）。",
      "更改后示例": "1. napi_add_env_cleanup_hook",
      "触发条件": "同一术语或接口名称在相邻上下文或列表中存在不一致的符号/格式（如带*号与无*号变体），且未声明特殊用途说明时触发。"
    },
    {
      "defect_id": 403918,
      "sentence": "使用Node-API关于string的六个接口，可以让Node-API模块和ArkTS字符串进行交互。",
      "reference_sentence": "使用Node-API接口创建和获取string值",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口创建和获取string值\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用Node-API关于string的六个接口，可以让Node-API模块和ArkTS字符串进行交互。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"string是编程中常用的数据类型之一。它可以存储和操作文本数据，用于表示和处理字符序列。还可用于构建用户界面元素，如标签、按钮和文本框，处理用户输入，验证和格式化输入数据。不同的编码支持不同的字符集和语言，以下是一些主要的编码方案及其区别：\",\"10\":\"\"}",
      "修改建议": "混用了`关于string的六个接口`和`创建和获取string值`的表述",
      "更改后示例": "使用Node-API接口创建和获取string值，可以让Node-API模块和ArkTS字符串进行交互。",
      "触发条件": "同一文档上下文或相邻段落中对同一概念存在术语替换（如\"关于string的六个接口\"与\"创建和获取string值\"）、结构变化（动词短语与名词短语混用）或不同描述方式时触发。\n\n识别模式：通过对比当前句子与上下文标题/核心段落（如示例中的章节标题\"# 使用Node-API接口创建和获取string值\"）的关键术语一致性，检测是否存在同一功能模块使用两种及以上不同表述的情况。当核心动词结构（创建和获取）与名词性描述（六个接口）指向同一对象但表述不统一时，即判定为需要修复的不一致问题。"
    },
    {
      "defect_id": 403922,
      "sentence": "将ArkTS的字符类型的数据转换为utf16编码的字符。",
      "reference_sentence": "需要将ArkTS的字符类型的数据转换为utf16编码的字符时使用这个函数。",
      "line_num": 128,
      "context": "{\"123\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_create_string_utf8:%{public}s', testNapi.createStringUtf8());\",\"124\":\"```\",\"125\":\"\",\"126\":\"### napi_get_value_string_utf16\",\"127\":\"\",\"128\":\"将ArkTS的字符类型的数据转换为utf16编码的字符。\",\"129\":\"\",\"130\":\"cpp部分代码\",\"131\":\"\",\"132\":\"```cpp\",\"133\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`转换为utf16编码的字符`和`将字符类型的数据转换为utf16编码的字符`的表述",
      "更改后示例": "将ArkTS的字符类型的数据转换为UTF-16编码的字符。",
      "触发条件": "同一技术术语在文档中存在大小写或格式不一致（如\"utf16\"与\"UTF-16\"混用），且不符合行业标准命名规范（如RFC标准要求的大写+连字符格式）。"
    },
    {
      "defect_id": 404529,
      "sentence": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 65,
      "context": "{\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true); // 投递指定优先级为napi_priority_high，入队方式为队列尾部入队的任务",
      "触发条件": "当代码中的函数调用包含关键配置参数（如优先级、入队方式），但未在注释中显式说明参数对应语义，且上下文存在同类调用已明确注释时触发。"
    },
    {
      "defect_id": 404707,
      "sentence": "从c++使用NAPI调用返回Promise的ArkTS方法。",
      "reference_sentence": "当ArkTS的返回值为promise，开发者可以按照以下方式在自己创建的ArkTS运行环境中调用异步的ArkTS接口。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"当ArkTS的返回值为promise，开发者可以按照以下方式在自己创建的ArkTS运行环境中调用异步的ArkTS接口。\",\"5\":\"\",\"6\":\"## 调用异步的ArkTS接口示例\",\"7\":\"从c++使用NAPI调用返回Promise的ArkTS方法。\",\"8\":\"处理Promise对象：将Promise与c++回调绑定，处理异步结果。\",\"9\":\"转换数据类型：在回调中将JavaScript结果转换为c++可用的数据。\",\"10\":\"线程安全处理：确保跨线程操作的安全性。\",\"11\":\"\",\"12\":\"### 示例代码\"}",
      "修改建议": "混用了'Promise'和'promise'，大小写不一致",
      "更改后示例": "从C++使用NAPI调用返回promise的ArkTS方法。",
      "触发条件": "同一术语在文档中出现大小写混用（如\"Promise\"与\"promise\"），或特定技术术语（如\"C++\"）未遵循标准大小写形式时触发。\n\n识别模式：\n1. 通过对比上下文（如参考句子中的\"promise\"全小写）和问题句子中的\"Promise\"首字母大写，检测术语一致性\n2. 检查技术专有名词是否遵循规范（如\"c++\"应修正为\"C++\"，\"NAPI\"保持全大写形式正确）\n3. 建立术语表自动匹配异常大小写形式，当同一术语在文档中出现≥2种大小写形态时触发告警"
    },
    {
      "defect_id": 403920,
      "sentence": "将ArkTS的字符类型的数据转换为utf8编码的字符。",
      "reference_sentence": "需要将ArkTS的字符类型的数据转换为utf8编码的字符时使用这个函数。",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"32\":\"\",\"33\":\"### napi_get_value_string_utf8\",\"34\":\"\",\"35\":\"将ArkTS的字符类型的数据转换为utf8编码的字符。\",\"36\":\"\",\"37\":\"cpp部分代码\",\"38\":\"\",\"39\":\"```cpp\",\"40\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`转换为utf8编码的字符`和`将字符类型的数据转换为utf8编码的字符`的表述",
      "更改后示例": "将ArkTS的字符类型的数据转换为UTF-8编码的字符。",
      "触发条件": "当同一术语在文档中存在拼写形式不一致（如大小写差异、连字符使用不统一）时触发，例如\"UTF-8\"与\"utf8\"混用，或\"Node-API\"与\"node api\"表述并存时。"
    },
    {
      "defect_id": 403923,
      "sentence": "用于创建一个UTF-16编码的ArkTS字符串。",
      "reference_sentence": "需要通过UTF16编码的C字符串创建ArkTS string值时使用这个函数。",
      "line_num": 178,
      "context": "{\"173\":\"hilog.info(0x0000,'testTag','Node-API napi_get_value_string_utf16:%{public}s', result);\",\"174\":\"```\",\"175\":\"\",\"176\":\"### napi_create_string_utf16\",\"177\":\"\",\"178\":\"用于创建一个UTF-16编码的ArkTS字符串。\",\"179\":\"\",\"180\":\"cpp部分代码\",\"181\":\"\",\"182\":\"```cpp\",\"183\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`创建一个UTF-16编码的ArkTS字符串`和`通过UTF16编码的C字符串创建ArkTS string值`的表述",
      "更改后示例": "用于通过UTF-16编码的C字符串创建ArkTS string值。",
      "触发条件": "同一功能描述中混用不同动词结构（如“创建”与“通过...创建”）或术语（如“字符串”与“string值”），且涉及跨语言数据转换（如C字符串到ArkTS）时触发。"
    },
    {
      "defect_id": 404544,
      "sentence": "napi_delete_reference*",
      "reference_sentence": "napi_delete_reference",
      "line_num": 34,
      "context": "{\"29\":\"   >    current tsfn was created by dead env, owner id: &lt;owner id&gt;, current env id: &lt;current id&gt;\",\"30\":\"\",\"31\":\"该维测手段目前覆盖范围如下：\",\"32\":\"\",\"33\":\"1. napi_get_reference_value\",\"34\":\"2. napi_delete_reference*\",\"35\":\"3. napi_queue_async_work\",\"36\":\"4. napi_queue_async_work_with_qos\",\"37\":\"5. napi_cancel_async_work\",\"38\":\"6. napi_call_threadsafe_function*\",\"39\":\"7. napi_release_threadsafe_function*\"}",
      "修改建议": "前后文对同一接口使用了不同的表述（“napi_delete_reference*”与“napi_delete_reference”）。",
      "更改后示例": "napi_delete_reference",
      "触发条件": "当同一文档或相邻条目中存在同一接口/术语使用不一致的符号（如\"*\"）或拼写形式时，或当列表/上下文中相邻条目命名规范出现异常偏差时。"
    },
    {
      "defect_id": 404531,
      "sentence": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 68,
      "context": "{\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\",\"71\":\"    static void WorkComplete(napi_env env, napi_status status, void *data) {\",\"72\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"73\":\"        napi_release_threadsafe_function(callbackData->tsfn, napi_tsfn_release);\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false); // 投递指定优先级为napi_priority_high，入队方式为队列头部入队的任务",
      "触发条件": "当代码中的函数调用包含关键配置参数（如优先级/入队方式等枚举值），但未通过注释明确参数含义，且上下文存在对应参数描述的文档说明时触发。\n\n识别模式：\n1. 检测函数调用中是否包含枚举类型/布尔型参数（如napi_priority_high、false）\n2. 验证调用点是否缺失参数含义注释\n3. 匹配上下文注释/文档中是否存在对应的参数组合描述（如\"指定优先级和入队方式\"）\n4. 确认参数顺序与文档描述的一致性要求（优先级参数在前，入队方式参数在后）"
    },
    {
      "defect_id": 404545,
      "sentence": "napi_call_threadsafe_function*",
      "reference_sentence": "napi_call_threadsafe_function",
      "line_num": 38,
      "context": "{\"33\":\"1. napi_get_reference_value\",\"34\":\"2. napi_delete_reference*\",\"35\":\"3. napi_queue_async_work\",\"36\":\"4. napi_queue_async_work_with_qos\",\"37\":\"5. napi_cancel_async_work\",\"38\":\"6. napi_call_threadsafe_function*\",\"39\":\"7. napi_release_threadsafe_function*\",\"40\":\"\",\"41\":\"> \\\\*：具有该标志的接口，仅能触发第二种场景的维测信息。\",\"42\":\"\",\"43\":\"### 案例及示例代码\"}",
      "修改建议": "前后文对同一接口使用了不同的表述（“napi_call_threadsafe_function*”与“napi_call_threadsafe_function”）。",
      "更改后示例": "napi_call_threadsafe_function",
      "触发条件": "当同一术语在相邻或相关上下文中出现不一致的符号/格式（如多余符号\"*\"）且无明确功能区分说明时，或当术语与官方接口名称存在非必要符号差异时触发。\n\n识别模式：\n1. **符号冗余检测**：匹配术语中非标准符号（如\"*\"）是否在上下文其他同类接口中重复出现，若同一接口存在带/不带符号的混合表述则需修复；\n2. **命名规范对齐**：对比官方API名称（如参考句子中的\"napi_call_threadsafe_function\"），验证文档表述是否严格遵循原始命名，删除非功能性附加符号。"
    },
    {
      "defect_id": 404528,
      "sentence": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);",
      "reference_sentence": "# 使用Node-API接口从异步线程向ArkTS线程投递指定优先级和入队方式的的任务",
      "line_num": 64,
      "context": "{\"59\":\"    // 异步线程中调用该接口向ArkTS线程投递指定优先级和入队方式的任务\",\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\"}",
      "修改建议": "原文中提到“指定优先级和入队方式的任务”，而问题句子中未明确指出“指定优先级和入队方式”",
      "更改后示例": "napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true); // 投递指定优先级为napi_priority_low，入队方式为队列尾部入队的任务",
      "触发条件": "当代码注释中提及参数选项（如优先级、入队方式）但未具体说明参数值对应语义，或相邻代码同类调用存在详细参数说明时触发。\n\n识别模式：\n1. 函数调用包含枚举型参数（如napi_priority_low）或布尔型参数（如true/false）\n2. 上下文存在明确说明参数语义的注释模板（如\"指定优先级为X，入队方式为Y\"）\n3. 当前代码行注释未完整映射参数值与业务语义（如仅保留参数值未解释含义）"
    },
    {
      "defect_id": 403921,
      "sentence": "用于创建一个UTF-8编码的ArkTS字符串。",
      "reference_sentence": "需要通过UTF8编码的C字符串创建ArkTS string值时使用这个函数。",
      "line_num": 88,
      "context": "{\"83\":\"hilog.info(0x0000, 'testTag', 'Test Node-API get_value_string_utf8_not_string %{public}s', testNapi.getValueStringUtf8(50));\",\"84\":\"```\",\"85\":\"\",\"86\":\"### napi_create_string_utf8\",\"87\":\"\",\"88\":\"用于创建一个UTF-8编码的ArkTS字符串。\",\"89\":\"\",\"90\":\"cpp部分代码\",\"91\":\"\",\"92\":\"```cpp\",\"93\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`创建一个UTF-8编码的ArkTS字符串`和`通过UTF8编码的C字符串创建ArkTS string值`的表述",
      "更改后示例": "用于通过UTF-8编码的C字符串创建ArkTS string值。",
      "触发条件": "同一功能描述中混用不同术语（如“创建”与“通过...创建”）或关键元素（如来源类型\"C字符串\"、目标类型\"ArkTS string值\"）缺失/不统一时触发。\n\n识别模式：检查句子是否缺少操作来源/目标类型的明确对应关系（如未说明\"通过C字符串\"创建），或与上下文参考句的动宾结构（\"通过X创建Y\"）不一致。需对比相邻段落中同类API描述的动词短语结构和术语组合。"
    },
    {
      "defect_id": 404546,
      "sentence": "napi_release_threadsafe_function*",
      "reference_sentence": "napi_release_threadsafe_function",
      "line_num": 39,
      "context": "{\"34\":\"2. napi_delete_reference*\",\"35\":\"3. napi_queue_async_work\",\"36\":\"4. napi_queue_async_work_with_qos\",\"37\":\"5. napi_cancel_async_work\",\"38\":\"6. napi_call_threadsafe_function*\",\"39\":\"7. napi_release_threadsafe_function*\",\"40\":\"\",\"41\":\"> \\\\*：具有该标志的接口，仅能触发第二种场景的维测信息。\",\"42\":\"\",\"43\":\"### 案例及示例代码\",\"44\":\"\"}",
      "修改建议": "前后文对同一接口使用了不同的表述（“napi_release_threadsafe_function*”与“napi_release_threadsafe_function”）。",
      "更改后示例": "napi_release_threadsafe_function",
      "触发条件": "同一技术术语或接口名称在相邻条目/列表中存在符号不一致（如带/不带星号）或格式差异时触发。  \n\n识别模式：检查列表项、函数名称等是否在相同上下文中保持完全一致的符号使用（如星号）和命名格式，若发现相邻条目存在同一接口的不同表述形式（如\"napi_release_threadsafe_function*\"与无星号版本混用），则判定为不一致。"
    },
    {
      "defect_id": 404709,
      "sentence": "线程安全处理：确保跨线程操作的安全性。",
      "reference_sentence": "处理Promise对象：将Promise与c++回调绑定，处理异步结果。",
      "line_num": 10,
      "context": "{\"5\":\"\",\"6\":\"## 调用异步的ArkTS接口示例\",\"7\":\"从c++使用NAPI调用返回Promise的ArkTS方法。\",\"8\":\"处理Promise对象：将Promise与c++回调绑定，处理异步结果。\",\"9\":\"转换数据类型：在回调中将JavaScript结果转换为c++可用的数据。\",\"10\":\"线程安全处理：确保跨线程操作的安全性。\",\"11\":\"\",\"12\":\"### 示例代码\",\"13\":\"- 模块注册\",\"14\":\"    ```c++\",\"15\":\"    #include \\\"hilog/log.h\\\"\"}",
      "修改建议": "句式不一致，应统一使用祈使句描述动作",
      "更改后示例": "确保跨线程操作的安全性。",
      "触发条件": "在同一列表或上下文中，条目结构不一致，冒号前使用名词短语而非统一要求的动宾结构（祈使句）时触发。\n\n识别模式：\n1. 检查条目是否采用\"主题描述：具体措施\"的分隔结构\n2.对比相邻条目主题描述部分的语法结构（如\"处理Promise对象\"vs\"线程安全处理\"）\n3. 检测冒号前短语是否包含动词缺失（名词化结构）或时态不一致\n4. 验证上下文是否存在统一的祈使句规范（如所有条目都以动词开头）"
    },
    {
      "defect_id": 404548,
      "sentence": "2. napi_remove_env_cleanup_hook*",
      "reference_sentence": "napi_remove_env_cleanup_hook",
      "line_num": 344,
      "context": "{\"339\":\"> current napi interface cannot run in multi-thread, thread id: &lt;env tid&gt;, current thread id: &lt;current tid&gt;\",\"340\":\"\",\"341\":\"该维测手段覆盖范围如下：\",\"342\":\"\",\"343\":\"1. napi_add_env_cleanup_hook*\",\"344\":\"2. napi_remove_env_cleanup_hook*\",\"345\":\"3. napi_add_async_cleanup_hook\",\"346\":\"4. napi_set_instance_data\",\"347\":\"5. napi_get_instance_data\",\"348\":\"\",\"349\":\"> \\\\*：具有该标志的接口，在维测触发的情况下，仅打印带有调用栈信息的ERROR日志，并不会中断进程。\"}",
      "修改建议": "前后文对同一接口使用了不同的表述（“napi_remove_env_cleanup_hook*”与“napi_remove_env_cleanup_hook”）。",
      "更改后示例": "2. napi_remove_env_cleanup_hook",
      "触发条件": "同一术语在相邻条目或上下文中存在不一致的附加符号（如星号/注释符）且无明确功能差异时触发。\n\n具体识别模式：\n1. 列表中相邻条目或同类型术语存在符号差异（如带*/不带*）\n2. 同一接口名称在正文与注释中出现不同形式（如\"napi_remove_env_cleanup_hook*\"与参考句子\"napi_remove_env_cleanup_hook\"）\n3. 符号差异未在文档中明确定义特殊含义（如示例中星号仅在349行统一说明，不应出现在具体条目）"
    },
    {
      "defect_id": 404798,
      "sentence": "5. 模块初始化以及ArkTS侧调用接口。",
      "reference_sentence": "5. 模块初始化以及ArkTS侧调用接口。",
      "line_num": 137,
      "context": "{\"132\":\"       callbackData->tsfn = nullptr;\",\"133\":\"       callbackData->work = nullptr;\",\"134\":\"   }\",\"135\":\"   ```\",\"136\":\"\",\"137\":\"5. 模块初始化以及ArkTS侧调用接口。\",\"138\":\"   ```c++\",\"139\":\"   // 模块初始化\",\"140\":\"   static napi_value Init(napi_env env, napi_value exports) {\",\"141\":\"       CallbackData *callbackData = new CallbackData(); // 可在线程退出时释放\",\"142\":\"       napi_property_descriptor desc[] = {\"}",
      "修改建议": "建议使用祈使句",
      "更改后示例": "初始化模块并在ArkTS侧调用接口。",
      "触发条件": "当文档中的编号列表项或步骤描述使用名词短语结构而非祈使句时触发，尤其出现在操作指南、接口调用说明等需要明确动作的语境中。识别模式为检测条目是否以动词缺失的并列名词短语（如\"X以及Y\"）开头且缺乏动作指向性。"
    },
    {
      "defect_id": 404751,
      "sentence": "异步调用支持callback方式和Promise方式，使用哪种方式由应用开发者决定。下面为两种方式的示例代码：",
      "reference_sentence": "异步调用支持callback方式和Promise方式，使用哪种方式由应用开发者决定。下面为两种方式的示例代码：",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"- 图像处理：当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。\",\"14\":\"\",\"15\":\"napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。\",\"16\":\"\",\"17\":\"异步调用支持callback方式和Promise方式，使用哪种方式由应用开发者决定。下面为两种方式的示例代码：\",\"18\":\"\",\"19\":\"![NAPI 异步任务线程](figures/napi_async_work.png)\",\"20\":\"\",\"21\":\"## 使用Promise方式示例\",\"22\":\"\"}",
      "修改建议": "句子本身没有问题，但为了保持句式一致，建议使用祈使句。",
      "更改后示例": "支持异步调用的callback方式和Promise方式，应用开发者决定使用哪种方式。下面为两种方式的示例代码：",
      "触发条件": "同一段落或相邻句子中存在祈使句与陈述句混用，且上下文存在明确句式倾向性（如技术文档统一要求使用祈使句）。具体通过识别\"动词前置型\"（支持...）与\"主语前置型\"（异步调用支持...）句式冲突触发。"
    },
    {
      "defect_id": 404615,
      "sentence": "3. 参考以下报错案例，若遇到相似场景，可参照对应解决方法快速处理。",
      "reference_sentence": "3. 参考以下报错案例，若遇到相似场景，可参照对应解决方法快速处理。",
      "line_num": 15,
      "context": "{\"10\":\"    2. [-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)为属性混淆开关，配置白名单的主要场景包括网络数据访问、json字段访问、动态属性访问、调用so库接口等不能混淆的场景，需要使用[-keep-property-name](source-obfuscation.md#-keep-property-name)来保留指定的属性名称。\",\"11\":\"\",\"12\":\"    3. [-enable-export-obfuscation](source-obfuscation.md#-enable-export-obfuscation)为导出名称混淆，一般与`-enable-toplevel-obfuscation`和`-enable-property-obfuscation`选项配合使用；配置白名单的主要场景为模块对外接口不能混淆，需要使用[-keep-global-name](source-obfuscation.md#-keep-global-name)来保留指定的导出/导入名称。\",\"13\":\"\",\"14\":\"    4. [-enable-filename-obfuscation](source-obfuscation.md#-enable-filename-obfuscation)为文件名混淆，配置白名单的主要场景为动态import或运行时直接加载的文件路径，需要使用[-keep-file-name](source-obfuscation.md#-keep-file-name)来保留这些文件路径及名称。\",\"15\":\"3. 参考以下报错案例，若遇到相似场景，可参照对应解决方法快速处理。\",\"16\":\"4. 若以下报错案例中未找到相似场景，建议依据各项配置功能正向定位（若不需要相应功能，可删除对应配置项）。\",\"17\":\"5. 应用运行时崩溃分析方法：\",\"18\":\"    1. 打开应用运行日志，或点击DevEco Studio中出现的Crash弹窗，找到运行时崩溃栈。\",\"19\":\"\",\"20\":\"    2. 应用运行时崩溃栈中的行号为[编译产物](source-obfuscation-guide.md#查看混淆效果)的行号，方法名也可能为混淆后名称；因此排查时建议直接根据崩溃栈查看编译产物，进而分析哪些名称不能被混淆，然后将其配置到白名单中。\"}",
      "修改建议": "句子中'报错案例'与'错误案例'混用",
      "更改后示例": "3. 参考以下错误案例，若遇到相似场景，可参照对应解决方法快速处理。",
      "触发条件": "同一文档的相邻上下文或同一逻辑单元内，同一概念出现两种及以上不同术语表达（如\"报错案例\"与\"错误案例\"），且术语差异可能引发理解歧义时触发。\n\n识别模式：\n1. 在5个相邻段落/列表项范围内，检测到同义但用词不同的专业术语\n2. 在相同编号层级的说明性文本中（如本案例的步骤3），存在术语表达形式不统一\n3. 术语差异属于\"核心名词+限定词\"组合的局部替换（如\"报错/错误\"+案例）"
    },
    {
      "defect_id": 404795,
      "sentence": "2. 在工作线程中调用ExecuteWork，并执行线程安全函数。",
      "reference_sentence": "2. 在工作线程中调用ExecuteWork，并执行线程安全函数。",
      "line_num": 53,
      "context": "{\"48\":\"       napi_queue_async_work(env, callbackData->work);\",\"49\":\"       return nullptr;\",\"50\":\"   }\",\"51\":\"   ```\",\"52\":\"\",\"53\":\"2. 在工作线程中调用ExecuteWork，并执行线程安全函数。\",\"54\":\"   ```c++\",\"55\":\"   static void ExecuteWork(napi_env env, void *data)\",\"56\":\"   {\",\"57\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"58\":\"       std::promise<std::string> promise;\"}",
      "修改建议": "建议使用祈使句",
      "更改后示例": "在工作线程中调用ExecuteWork并执行线程安全函数。",
      "触发条件": "当技术文档中的步骤说明使用复合祈使句时，若存在冗余标点（如逗号）分割连续动作，且相邻步骤保持无标点紧凑结构时触发。通过识别编号步骤项中\"并\"连接的多动词结构，检测是否存在不必要的标点分割动作短语。"
    },
    {
      "defect_id": 405067,
      "sentence": "开启混淆开关  ",
      "reference_sentence": "在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。",
      "line_num": 8,
      "context": "{\"3\":\"## 开启源码混淆\",\"4\":\"\",\"5\":\"### 开启混淆步骤\",\"6\":\"源码混淆能力已在系统中集成，可通过以下方式在DevEco Studio开启使用。\",\"7\":\"\",\"8\":\"* 开启混淆开关  \",\"9\":\"    在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。\",\"10\":\"    ```\",\"11\":\"    \\\"arkOptions\\\": {\",\"12\":\"      \\\"obfuscation\\\": {\",\"13\":\"        \\\"ruleOptions\\\": {\"}",
      "修改建议": "混用了'开关'和'开关'不同形式的表述",
      "更改后示例": "开启混淆功能  ",
      "触发条件": "同一功能描述在邻近段落中混用不同术语（如\"开关\"与\"功能\"），且存在已明确定义的参考表述（如\"开启混淆\"）时触发。识别模式为检测同一功能节点下名词性术语（如\"开关/功能/配置项\"）与上下文参考表述产生概念性表述分歧。"
    },
    {
      "defect_id": 405096,
      "sentence": "开发人员可使用DevEco Studio命令工具Command Line Tools中的[hstack插件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-hstack)来还原源码堆栈，进而分析问题。",
      "reference_sentence": "若应用出现功能异常，依据混淆后的报错栈从对应的[中间产物](#查看混淆效果)中找到报错行的代码，排查需要配置的白名单并使用`-keep-property-name`进行保留。",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"  ![build-product](figures/build-product.png)\",\"145\":\"\",\"146\":\"## 报错栈还原\",\"147\":\"\",\"148\":\"经过混淆的应用程序，代码名称会发生更改，导致crash时打印的报错栈难以理解。开发人员可使用DevEco Studio命令工具Command Line Tools中的[hstack插件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-hstack)来还原源码堆栈，进而分析问题。  \",\"149\":\"反混淆工具需要使用应用编译过程中生成的sourceMaps.map文件以及混淆名称映射文件nameCache.json文件，请本地备份这些文件。\",\"150\":\"* 源代码映射信息文件：sourceMaps.map，该文件记录了压缩/转换后的代码到原始源代码之间的映射关系。\",\"151\":\"\",\"152\":\"![obfuscation-product](figures/obfuscation-product.png)\"}",
      "修改建议": "前后文对‘报错栈’的表述不一致",
      "更改后示例": "开发人员可使用DevEco Studio命令工具Command Line Tools中的[hstack插件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-hstack)来还原源码报错栈，进而分析问题。",
      "触发条件": "当同一文档上下文中出现对同一技术术语的多种表述形式（如\"报错栈\"与\"堆栈\"），且存在明确的标准术语引用（如章节标题\"## 报错栈还原\"）时，触发语言表达一致性规则。识别模式需检测邻近段落（±3段）及同级标题中是否存在术语表述冲突。"
    },
    {
      "defect_id": 404651,
      "sentence": "为了确保其他模块能正常调用HSP模块的方法，需在混淆配置中添加白名单。主模块和HSP模块应保持相同的白名单配置，建议按以下步骤操作：",
      "reference_sentence": "为了确保其他模块能正常调用HSP模块的方法，需在混淆配置中添加白名单。主模块和HSP模块应保持相同的白名单配置，建议按以下步骤操作：",
      "line_num": 308,
      "context": "{\"303\":\"| HAP/HSP | 本地HAR | 本地HAR与主模块一起编译，混淆后名称一致。 |\",\"304\":\"| HAP/HSP | 三方库  | 三方库中导出的名称及其属性会被收集到白名单，因此导入和导出时都不会被混淆。 |\",\"305\":\"\",\"306\":\"**解决方案**\",\"307\":\"\",\"308\":\"为了确保其他模块能正常调用HSP模块的方法，需在混淆配置中添加白名单。主模块和HSP模块应保持相同的白名单配置，建议按以下步骤操作：\",\"309\":\"\",\"310\":\"1. 在HSP模块的混淆配置文件（如 hsp-white-list.txt）中添加白名单。\",\"311\":\"2. 在依赖HSP的其他模块的混淆配置中，通过files字段引入该配置文件。\",\"312\":\"这样可以确保白名单配置的一致性，避免重复维护。配置方法参考下图：\",\"313\":\"\"}",
      "修改建议": "句子中使用了“白名单”，但未解释该术语的具体作用。",
      "更改后示例": "为了确保其他模块能正常调用HSP模块的方法，需在混淆配置中添加白名单。白名单配置确保指定的名称不会被混淆。主模块和HSP模块应保持相同的白名单配置，建议按以下步骤操作：",
      "触发条件": "当文档中首次使用专业术语（如\"白名单\"）或关键概念时未提供必要定义，且该术语在上下文未明确解释其具体功能作用的情况下触发。特别在涉及多模块协同工作的技术场景中，若操作步骤依赖该术语的特定含义但未作说明时需强制触发。"
    },
    {
      "defect_id": 404793,
      "sentence": "例如以下场景：",
      "reference_sentence": "例如以下场景：",
      "line_num": 6,
      "context": "{\"1\":\"# 使用Node-API接口进行线程安全开发\",\"2\":\"\",\"3\":\"\",\"4\":\"## 场景介绍\",\"5\":\"\",\"6\":\"napi_create_threadsafe_function是Node-API接口之一，用于创建一个线程安全的JavaScript函数。主要用于在多个线程之间共享和调用，而不会出现竞争条件或死锁。例如以下场景：\",\"7\":\"\",\"8\":\"\",\"9\":\"- 异步计算：如果需要进行耗时的计算或IO操作，可以创建一个线程安全的函数，将计算或IO操作放在另一个线程中执行，避免阻塞主线程，提高程序的响应速度。\",\"10\":\"\",\"11\":\"- 数据共享：如果多个线程需要访问同一份数据，可以创建一个线程安全的函数，确保数据的读写操作不会发生竞争条件或死锁等问题。\"}",
      "修改建议": "虽然没有问题，但为了保持一致性，建议使用祈使句",
      "更改后示例": "包含以下场景：",
      "触发条件": "当文档中存在多个相同语义的列表引导句式时，若其中部分语句未采用统一祈使句结构（如\"包含以下场景：\"与\"例如以下场景：\"混用），且上下文存在已确立的祈使句规范。"
    },
    {
      "defect_id": 404796,
      "sentence": "3. 在JS线程执行异步回调函数。",
      "reference_sentence": "3. 在JS线程执行异步回调函数。",
      "line_num": 70,
      "context": "{\"65\":\"           // OH_LOG_INFO(LOG_APP, \\\"XXX, Result from JS %{public}s\\\", e.what());\",\"66\":\"       }\",\"67\":\"   }\",\"68\":\"   ```\",\"69\":\"\",\"70\":\"3. 在JS线程执行异步回调函数。\",\"71\":\"   ```c++\",\"72\":\"   static constexpr int INT_NUM_2 = 2;   // int类型数值2\",\"73\":\"   static constexpr int INT_BUF_32 = 32; // int类型字符串长度32\",\"74\":\"\",\"75\":\"   static napi_value ResolvedCallback(napi_env env, napi_callback_info info)\"}",
      "修改建议": "建议使用祈使句",
      "更改后示例": "在JS线程中执行异步回调函数。",
      "触发条件": "当步骤描述中缺少必要介词（如“中”）导致结构不完整，或句式（陈述句/祈使句）与上下文规范不一致时触发。"
    },
    {
      "defect_id": 404612,
      "sentence": "## 如何排查功能异常",
      "reference_sentence": "## 如何排查功能异常",
      "line_num": 3,
      "context": "{\"1\":\"# ArkGuard混淆常见问题\",\"2\":\"\",\"3\":\"## 如何排查功能异常\",\"4\":\"\",\"5\":\"### 排查功能异常步骤\",\"6\":\"1. 先在obfuscation-rules.txt配置-disable-obfuscation选项关闭混淆，确认问题是否由混淆引起。\",\"7\":\"2. 若确认是开启混淆后功能出现异常，请先阅读文档了解[-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)、[-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)、[-enable-filename-obfuscation](source-obfuscation.md#-enable-filename-obfuscation)、[-enable-export-obfuscation](source-obfuscation.md#-enable-export-obfuscation)等混淆规则的能力以及哪些语法场景需要配置白名单来保证应用功能正常。下文简要介绍默认开启的四项选项功能，想要了解这四项选项的具体细节，请阅读对应选项的完整描述。  \",\"8\":\"    1. [-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)为顶层作用域名称混淆开关。\"}",
      "修改建议": "标题和内容中的'功能'与'特性'混用",
      "更改后示例": "## 如何排查特性异常",
      "触发条件": "同一文档或章节中存在对同一概念使用多个不同术语（如\"功能\"和\"特性\"混用），且标题与正文、相邻段落或上下文出现术语表述不一致时触发。\n\n识别模式：\n1. 术语映射检测：通过建立同义词库识别同一语义范畴的不同表达（如功能/特性/能力）\n2. 上下文一致性验证：检查标题与对应章节内容、相邻段落（如示例中问题标题与下级小标题\"排查功能异常步骤\"）是否使用相同术语\n3. 高频词冲突分析：当两个相似术语在相近位置出现频率超过阈值时（如标题用\"特性\"而正文连续出现5次\"功能\"）触发告警"
    },
    {
      "defect_id": 404794,
      "sentence": "1. 在Native入口定义线程安全函数。",
      "reference_sentence": "1. 在Native入口定义线程安全函数。",
      "line_num": 18,
      "context": "{\"13\":\"- 多线程编程：如果需要进行多线程编程，可以创建一个线程安全的函数，确保多个线程之间的通信和同步操作正确无误。\",\"14\":\"\",\"15\":\"\",\"16\":\"## 使用示例\",\"17\":\"\",\"18\":\"1. 在Native入口定义线程安全函数。\",\"19\":\"   ```c++\",\"20\":\"   #include \\\"napi/native_api.h\\\"\",\"21\":\"   #include \\\"hilog/log.h\\\"\",\"22\":\"   #include <future>\",\"23\":\"\"}",
      "修改建议": "建议使用祈使句",
      "更改后示例": "定义线程安全函数在Native入口。",
      "触发条件": "步骤说明项未使用动词开头的祈使句结构，或存在\"在...做...\"等非标准语序时触发。识别模式为：检测到编号列表项/步骤描述采用\"在+位置状语+动词\"的倒装句式，且上下文同类步骤均采用\"动词+宾语+位置状语\"的标准祈使结构。"
    },
    {
      "defect_id": 404843,
      "sentence": "## ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message",
      "reference_sentence": "## ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message",
      "line_num": 3,
      "context": "{\"1\":\"# Node-API常见问题\",\"2\":\"\",\"3\":\"## ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message\",\"4\":\"\",\"5\":\"1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。\",\"6\":\"   如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。\",\"7\":\"\",\"8\":\"2. 排查so是否加载成功。\"}",
      "修改建议": "句子中混用了“报错显示”和“显示报错”两种表达方式，建议统一使用一种表达方式。",
      "更改后示例": "## ArkTS/JS侧import xxx from libxxx.so后，使用xxx显示报错undefined/not callable或明确的Error message",
      "触发条件": "同一文档或上下文中存在相同语义但语序结构不一致的动词短语（如“报错显示”与“显示报错”），且涉及同一操作流程描述时。  \n\n识别模式：检测相邻句子或相同技术场景描述中，是否出现动词+名词/名词+动词的语序混用（如 [报错]作为名词前置+[显示]作为动词，与 [显示]作为动词前置+[报错]作为名词），导致表达逻辑不连贯。"
    },
    {
      "defect_id": 404614,
      "sentence": "1. 先在obfuscation-rules.txt配置-disable-obfuscation选项关闭混淆，确认问题是否由混淆引起。",
      "reference_sentence": "1. 先在obfuscation-rules.txt配置-disable-obfuscation选项关闭混淆，确认问题是否由混淆引起。",
      "line_num": 6,
      "context": "{\"1\":\"# ArkGuard混淆常见问题\",\"2\":\"\",\"3\":\"## 如何排查功能异常\",\"4\":\"\",\"5\":\"### 排查功能异常步骤\",\"6\":\"1. 先在obfuscation-rules.txt配置-disable-obfuscation选项关闭混淆，确认问题是否由混淆引起。\",\"7\":\"2. 若确认是开启混淆后功能出现异常，请先阅读文档了解[-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)、[-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)、[-enable-filename-obfuscation](source-obfuscation.md#-enable-filename-obfuscation)、[-enable-export-obfuscation](source-obfuscation.md#-enable-export-obfuscation)等混淆规则的能力以及哪些语法场景需要配置白名单来保证应用功能正常。下文简要介绍默认开启的四项选项功能，想要了解这四项选项的具体细节，请阅读对应选项的完整描述。  \",\"8\":\"    1. [-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)为顶层作用域名称混淆开关。\",\"9\":\"\",\"10\":\"    2. [-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)为属性混淆开关，配置白名单的主要场景包括网络数据访问、json字段访问、动态属性访问、调用so库接口等不能混淆的场景，需要使用[-keep-property-name](source-obfuscation.md#-keep-property-name)来保留指定的属性名称。\",\"11\":\"\"}",
      "修改建议": "选项名`-disable-obfuscation`与上文`-enable-property-obfuscation`等选项名大小写不一致",
      "更改后示例": "1. 先在obfuscation-rules.txt配置`-disable-obfuscation`选项关闭混淆，确认问题是否由混淆引起。",
      "触发条件": "当检测到文档中同类术语（如命令行选项）存在命名格式不一致（大小写/连字符使用差异），且上下文存在正确格式的同类术语作为参照时触发。\n\n识别模式：\n1. 结构对比：识别同类元素（如选项参数`-enable-xxx`和`-disable-xxx`）\n2. 格式特征检测：检查大小写（如全小写）、连字符数量（如单个`-`开头）、命名结构（如动宾结构）\n3. 上下文验证：确认文档其他位置存在相同类别元素的规范格式（如参考句中的`-enable-property-obfuscation`）"
    },
    {
      "defect_id": 405068,
      "sentence": "在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。",
      "reference_sentence": "在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"### 开启混淆步骤\",\"6\":\"源码混淆能力已在系统中集成，可通过以下方式在DevEco Studio开启使用。\",\"7\":\"\",\"8\":\"* 开启混淆开关  \",\"9\":\"    在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆。\",\"10\":\"    ```\",\"11\":\"    \\\"arkOptions\\\": {\",\"12\":\"      \\\"obfuscation\\\": {\",\"13\":\"        \\\"ruleOptions\\\": {\",\"14\":\"          \\\"enable\\\": true,\"}",
      "修改建议": "混用了'配置'和'配置'不同形式的表述",
      "更改后示例": "在本模块`build-profile.json5`配置文件中的`arkOptions.obfuscation.ruleOptions`字段中，通过`enable`字段配置是否开启混淆功能。",
      "触发条件": "当同一句子中连续使用相同动词（如\"配置\"）但后续成分缺失导致表述不完整，或同一功能描述存在\"动词+宾语\"与\"动词裸用\"两种不同结构时触发。\n\n识别模式：检测动词后是否缺少必要宾语（如\"功能\"），并检查相邻语句中同一动词是否出现不同语法结构（如\"配置是否开启混淆\"与\"配置是否开启混淆功能\"的完整性差异）。通过依存句法分析识别动词支配关系缺失，结合术语重复密度判断表达一致性。"
    },
    {
      "defect_id": 405097,
      "sentence": "反混淆工具需要使用应用编译过程中生成的sourceMaps.map文件以及混淆名称映射文件nameCache.json文件，请本地备份这些文件。",
      "reference_sentence": "该文件记录了源码名称混淆的映射关系。",
      "line_num": 149,
      "context": "{\"144\":\"  ![build-product](figures/build-product.png)\",\"145\":\"\",\"146\":\"## 报错栈还原\",\"147\":\"\",\"148\":\"经过混淆的应用程序，代码名称会发生更改，导致crash时打印的报错栈难以理解。开发人员可使用DevEco Studio命令工具Command Line Tools中的[hstack插件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-hstack)来还原源码堆栈，进而分析问题。  \",\"149\":\"反混淆工具需要使用应用编译过程中生成的sourceMaps.map文件以及混淆名称映射文件nameCache.json文件，请本地备份这些文件。\",\"150\":\"* 源代码映射信息文件：sourceMaps.map，该文件记录了压缩/转换后的代码到原始源代码之间的映射关系。\",\"151\":\"\",\"152\":\"![obfuscation-product](figures/obfuscation-product.png)\"}",
      "修改建议": "前后文对‘名称映射文件’的表述不一致",
      "更改后示例": "反混淆工具需要使用应用编译过程中生成的sourceMaps.map文件以及名称映射文件nameCache.json文件，请本地备份这些文件。",
      "触发条件": "当同一文档中对同一技术概念（如文件/功能）出现不一致的修饰词（如\"混淆名称映射文件\" vs \"名称映射文件\"），且相邻上下文存在标准化表述时触发。\n\n识别模式：\n1. 检测相邻段落（±3行）是否存在相同实体的不同命名结构（如冗余形容词、修饰语增减）\n2. 对比技术术语与上下文标准化表述（如参考句中的\"名称混淆的映射关系\"对应\"名称映射文件\"）\n3. 定位名词短语中非必要修饰词冲突（如\"混淆名称\"中的\"混淆\"在上下文未重复强调）"
    },
    {
      "defect_id": 404613,
      "sentence": "### 排查功能异常步骤",
      "reference_sentence": "### 排查功能异常步骤",
      "line_num": 5,
      "context": "{\"1\":\"# ArkGuard混淆常见问题\",\"2\":\"\",\"3\":\"## 如何排查功能异常\",\"4\":\"\",\"5\":\"### 排查功能异常步骤\",\"6\":\"1. 先在obfuscation-rules.txt配置-disable-obfuscation选项关闭混淆，确认问题是否由混淆引起。\",\"7\":\"2. 若确认是开启混淆后功能出现异常，请先阅读文档了解[-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)、[-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)、[-enable-filename-obfuscation](source-obfuscation.md#-enable-filename-obfuscation)、[-enable-export-obfuscation](source-obfuscation.md#-enable-export-obfuscation)等混淆规则的能力以及哪些语法场景需要配置白名单来保证应用功能正常。下文简要介绍默认开启的四项选项功能，想要了解这四项选项的具体细节，请阅读对应选项的完整描述。  \",\"8\":\"    1. [-enable-toplevel-obfuscation](source-obfuscation.md#-enable-toplevel-obfuscation)为顶层作用域名称混淆开关。\",\"9\":\"\",\"10\":\"    2. [-enable-property-obfuscation](source-obfuscation.md#-enable-property-obfuscation)为属性混淆开关，配置白名单的主要场景包括网络数据访问、json字段访问、动态属性访问、调用so库接口等不能混淆的场景，需要使用[-keep-property-name](source-obfuscation.md#-keep-property-name)来保留指定的属性名称。\"}",
      "修改建议": "标题和内容中的'功能'与'特性'混用",
      "更改后示例": "### 排查特性异常步骤",
      "触发条件": "同一文档章节内出现相同概念使用不同术语表述（如\"功能\"与\"特性\"混用），且上下文存在直接关联的标题层级或连续段落。"
    },
    {
      "defect_id": 405095,
      "sentence": "若该模块开启混淆，则HAR包会被二次混淆。",
      "reference_sentence": "若构建HAR模块并发布给其他模块使用的场景，要在HAR模块中的consumer-rules.txt文件中将不能被二次混淆的属性使用`-keep-property-name`保留。",
      "line_num": 133,
      "context": "{\"128\":\"    3. 若代码中有传入ohmUrl进行页面跳转，如```router.pushUrl({url: '@bundle:com.example.routerPage/Library/Index')```，使用`-keep-file-name`来保留这个路径。\",\"129\":\"    4. 验证应用功能，排查遗漏的场景。若应用出现功能异常，且报错栈中的路径为混淆后的路径，可以在模块中的`build/default/[...]/release/obfuscation/nameCache.json`文件中查询到原始路径，进而找到源码文件。另外，[插件hstack](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-command-line-hstack)支持自动还原混淆后的报错堆栈。在定位到需要保留的路径后，使用`-keep-file-name`来保留此路径。\",\"130\":\"\",\"131\":\"### 说明\",\"132\":\"* 目前不支持在hvigor构建流程中插入自定义混淆插件。\",\"133\":\"* 混淆的HAR包被某模块依赖，若该模块开启混淆，则HAR包会被二次混淆。\",\"134\":\"\",\"135\":\"## 查看混淆效果\",\"136\":\"\",\"137\":\"在混淆结束后会生成中间产物，因此可以在编译产物build目录中找到混淆后的中间产物以查看混淆效果，同时可以找到混淆生成的名称映射表及系统API白名单文件。\",\"138\":\"\"}",
      "修改建议": "前后文对‘混淆’的表述不一致",
      "更改后示例": "若该模块开启混淆，则HAR包的混淆配置会被重复应用。",
      "触发条件": "当相邻或同一上下文中的动词短语（如\"开启混淆\"与\"被二次混淆\"）对同一技术动作的主动/被动形态表述不一致，且存在更符合上下文术语体系的同义表达（如\"混淆配置被重复应用\"）时触发。\n\n识别模式：通过检测①技术动作的施动主体与受动对象是否在语态上匹配（如主动开启 vs 被动被混淆）②是否在相同技术场景下存在更精确的术语表达（如用\"配置重复应用\"替代笼统的\"二次\"表述）来实现精准定位。"
    },
    {
      "defect_id": 405222,
      "sentence": "其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。",
      "reference_sentence": "其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS跨语言交互\",\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "了解OpenHarmony的Node-API，它是Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。",
      "触发条件": "同一段落或相邻句子中存在句式混用（如祈使句与陈述句交替出现），且当前句子结构与上下文要求的表达方式（如操作指南中的统一祈使语气）不匹配时触发。"
    },
    {
      "defect_id": 404902,
      "sentence": "问题：在使用`napi_wrap`把两个 C++ 对象包装成两个 JavaScript 对象的场景中，由于这两个 C++ 对象存在依赖关系，要求其中一个c++对象必须在另一个c++对象之前析构。然而，JavaScript 垃圾回收（GC）的时机不确定，直接在`napi_wrap`的`finalize_cb`回调里销毁 C++ 对象，没办法保证析构顺序符合要求。该如何保证两个c++对象析构的前后顺序？",
      "reference_sentence": "问题：在使用`napi_wrap`把两个 C++ 对象包装成两个 JavaScript 对象的场景中，由于这两个 C++ 对象存在依赖关系，要求其中一个C++对象必须在另一个C++对象之前析构。然而，JavaScript 垃圾回收（GC）的时机不确定，直接在`napi_wrap`的`finalize_cb`回调里销毁 C++ 对象，没办法保证析构顺序符合要求。该如何保证两个C++对象析构的前后顺序？",
      "line_num": 356,
      "context": "{\"351\":\"相关参考资料链接：\",\"352\":\"[使用Node-API接口注册和使用环境清理钩子](use-napi-about-cleanuphook.md)\",\"353\":\"[方舟运行时的NApi](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615)\",\"354\":\"\",\"355\":\"## `napi_wrap`如何保证被wrap的对象按期望顺序析构\",\"356\":\"问题：在使用`napi_wrap`把两个 C++ 对象包装成两个 JavaScript 对象的场景中，由于这两个 C++ 对象存在依赖关系，要求其中一个c++对象必须在另一个c++对象之前析构。然而，JavaScript 垃圾回收（GC）的时机不确定，直接在`napi_wrap`的`finalize_cb`回调里销毁 C++ 对象，没办法保证析构顺序符合要求。该如何保证两个c++对象析构的前后顺序？\",\"357\":\"\",\"358\":\"参考方案：  \",\"359\":\"先标记可释放状态，当A和B都为可释放状态时同时释放C++对象   \",\"360\":\"原理：将所有依赖对象的释放逻辑集中在最后一个被销毁的 JS 对象的 finalize_cb 中处理。  \",\"361\":\"实现步骤：   \"}",
      "修改建议": "“c++对象”与“C++对象”用词不一致",
      "更改后示例": "问题：在使用`napi_wrap`把两个 C++ 对象包装成两个 JavaScript 对象的场景中，由于这两个 C++ 对象存在依赖关系，要求其中一个C++对象必须在另一个C++对象之前析构。然而，JavaScript 垃圾回收（GC）的时机不确定，直接在`napi_wrap`的`finalize_cb`回调里销毁 C++ 对象，没办法保证析构顺序符合要求。该如何保证两个C++对象析构的前后顺序？",
      "触发条件": "同一文档或上下文中出现同一术语的大小写不一致（如\"C++对象\"与\"c++对象\"）或中英文混用（如\"JS对象\"与\"JavaScript对象\"）时触发。识别模式需检测相邻段落中相同语义词汇的拼写/格式差异，并通过术语表或上下文基准词进行自动匹配校验。"
    },
    {
      "defect_id": 405258,
      "sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和对象追踪（即Tracing GC）。",
      "reference_sentence": "GC（全称 Garbage Collection），即垃圾回收。",
      "line_num": 3,
      "context": "{\"1\":\"# GC垃圾回收\",\"2\":\"\",\"3\":\"GC（全称 Garbage Collection），即垃圾回收。在计算机领域，GC是指识别并释放内存中的不再使用的对象，以回收内存空间。当前主流编程语言实现的GC算法主要分为两大类：引用计数和对象追踪（即Tracing GC）。\",\"4\":\"\",\"5\":\"## GC算法简述\",\"6\":\"\",\"7\":\"### GC的类型\",\"8\":\"\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "触发条件": "同一术语在上下文存在多种中文/英文表达变体（如括号解释与正文术语不一致），或相邻段落中对同一概念使用不同称谓。"
    },
    {
      "defect_id": 404900,
      "sentence": "2. 对于注册失败的问题，需要使用者评估想注册的函数到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。",
      "reference_sentence": "2. 对于注册失败的问题，需要使用者评估想注册的函数到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。",
      "line_num": 348,
      "context": "{\"343\":\"}\",\"344\":\"```\",\"345\":\"\",\"346\":\"修复建议：\",\"347\":\"1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的js线程上。\",\"348\":\"2. 对于注册失败的问题，需要使用者评估想注册的函数到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。\",\"349\":\"3. 对于删除失败的问题，需要使用者确保`args`之前被注册过且未被删除。\",\"350\":\"\",\"351\":\"相关参考资料链接：\",\"352\":\"[使用Node-API接口注册和使用环境清理钩子](use-napi-about-cleanuphook.md)\",\"353\":\"[方舟运行时的NApi](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615)\"}",
      "修改建议": "“函数”与“回调”用词不一致",
      "更改后示例": "2. 对于注册失败的问题，需要使用者评估想注册的回调到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。",
      "触发条件": "同一上下文或相邻语句中对同一概念使用不一致的术语（如\"函数\"与\"回调\"），且存在已定义的规范表达（如参考文档中明确使用\"回调\"作为标准术语）。\n\n识别模式：\n1. 定位同一语义场景下的关键实体（如注册失败问题中的\"被注册对象\"）\n2. 检测相邻/关联语句中对该实体的指代是否统一（如问题描述与修复建议的对比）\n3. 交叉验证参考资料或文档规范（如相关NApi文档中\"napi_add_env_cleanup_hook\"的参数定义要求传递回调函数）"
    },
    {
      "defect_id": 404844,
      "sentence": "1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。",
      "reference_sentence": "1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。",
      "line_num": 5,
      "context": "{\"1\":\"# Node-API常见问题\",\"2\":\"\",\"3\":\"## ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message\",\"4\":\"\",\"5\":\"1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。\",\"6\":\"   如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。\",\"7\":\"\",\"8\":\"2. 排查so是否加载成功。\",\"9\":\"   应用启动时过滤模块加载相关日志，重点搜索\\\"dlopen\\\"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。\",\"10\":\"\"}",
      "修改建议": "句子中混用了“so的名称”和“模块名称”两种表达方式，建议统一使用一种表达方式。",
      "更改后示例": "1. 排查.cpp文件在注册模块时的模块名称与so名称匹配一致。",
      "触发条件": "当同一句子或相邻上下文中，同一概念的名词短语结构存在冗余变体（如\"so的名称\"与\"模块名称\"混用）时触发；或同一术语出现\"的\"字冗余/缺失的不一致表达（如\"so的名称\"与\"so名称\"交替出现）时触发。"
    },
    {
      "defect_id": 404899,
      "sentence": "1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的js线程上。",
      "reference_sentence": "1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的JS线程上。",
      "line_num": 347,
      "context": "{\"342\":\"    return nullptr;\",\"343\":\"}\",\"344\":\"```\",\"345\":\"\",\"346\":\"修复建议：\",\"347\":\"1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的js线程上。\",\"348\":\"2. 对于注册失败的问题，需要使用者评估想注册的函数到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。\",\"349\":\"3. 对于删除失败的问题，需要使用者确保`args`之前被注册过且未被删除。\",\"350\":\"\",\"351\":\"相关参考资料链接：\",\"352\":\"[使用Node-API接口注册和使用环境清理钩子](use-napi-about-cleanuphook.md)\"}",
      "修改建议": "“js线程”与“JS线程”用词不一致",
      "更改后示例": "1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的JS线程上。",
      "触发条件": "当同一文档中相邻或相关语句出现同一术语的大小写形式不一致（如\"js线程\"与\"JS线程\"），且存在明确的已定义标准格式（如参考句中的\"JS线程\"）时触发。"
    },
    {
      "defect_id": 405203,
      "sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "reference_sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "line_num": 12,
      "context": "{\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\",\"9\":\"- 系统库：使用libc++.so，随系统镜像发布。\",\"10\":\"- 应用Native库：使用libc++_shared.so，随应用发布。\",\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\"}",
      "修改建议": "混用了“C++命名空间”和“C++ 符号的命名空间”（建议统一使用“C++命名空间”）",
      "更改后示例": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++命名空间，而 libc++_shared.so使用__n1作为 C++命名空间。",
      "触发条件": "同一文档中相邻句子或段落内，针对同一技术概念出现术语变体（如\"命名空间\"与\"符号的命名空间\"）且存在冗余修饰词（如\"符号的\"）时。\n\n识别模式：\n1. 邻近位置重复出现同一核心术语（如\"命名空间\"）\n2. 术语存在非必要的修饰词增减（如\"符号的\"）\n3. 术语结构不一致（如带/不带空格：\"C++命名空间\"与\"C++ 符号的命名空间\"）\n4. 上下文已明确概念范畴（前文已说明讨论C++标准库的命名空间隔离问题，\"符号\"修饰成为冗余）"
    },
    {
      "defect_id": 404885,
      "sentence": "- native_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。",
      "reference_sentence": "- napi_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。",
      "line_num": 50,
      "context": "{\"45\":\"- 将该异常继续向上抛到ArkTS层，在ArkTS层进行捕获。\",\"46\":\"  发生异常时，可以选择走异常分支， 确保不再走多余的Native逻辑 ，直接返回到ArkTS层。\",\"47\":\"\",\"48\":\"## napi_value和napi_ref的生命周期有何区别\",\"49\":\"\",\"50\":\"- native_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。\",\"51\":\"\",\"52\":\"- napi_ref由开发者自己管理，需要手动delete。\",\"53\":\"\",\"54\":\"## Node-API接口返回值不是napi_ok时，如何排查定位\",\"55\":\"\"}",
      "修改建议": "混用了`native_value`和`napi_value`概念",
      "更改后示例": "- napi_value由HandleScope管理，一般开发者不需要自己加HandleScope（uv_queue_work的complete callback除外）。",
      "触发条件": "同一技术术语在文档中出现拼写不一致（如\"native_value\"与\"napi_value\"混用），或与官方API定义的关键词存在字符级差异（如native/napi前缀错误）。"
    },
    {
      "defect_id": 404897,
      "sentence": "2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。特征报错日志`AddCleanupHook Failed`。",
      "reference_sentence": "2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。特征报错日志`AddCleanupHook Failed`。",
      "line_num": 323,
      "context": "{\"318\":\"```\",\"319\":\"\",\"320\":\"## napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook调用报错，该如何处理\",\"321\":\"`napi_add_env_cleanup_hook`/`napi_remove_env_cleanup_hook`调用报错，有以下几个常见原因和对应的特征日志，均为接口使用不当导致。\",\"322\":\"1. 在`env`所在的js线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。\",\"323\":\"2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。特征报错日志`AddCleanupHook Failed`。\",\"324\":\"3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在（或已被删除）的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。\",\"325\":\"\",\"326\":\"常见错误场景示例如下：\",\"327\":\"\",\"328\":\"```c++\"}",
      "修改建议": "“功能/崩溃问题”中的“/”表意模糊，应改为“或”",
      "更改后示例": "2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能或崩溃问题。特征报错日志`AddCleanupHook Failed`。",
      "触发条件": "当文档中出现使用斜杠\"/\"连接多个中文词语表示并列或选择关系(如\"功能/崩溃问题\")，且上下文需要明确语义时，应触发规则。识别模式为检测到中文语境下非路径/URL场景的\"X/Y\"结构，其中X、Y为具有并列属性的名词短语。"
    },
    {
      "defect_id": 404898,
      "sentence": "3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在（或已被删除）的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。",
      "reference_sentence": "3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在（或已被删除）的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。",
      "line_num": 324,
      "context": "{\"319\":\"\",\"320\":\"## napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook调用报错，该如何处理\",\"321\":\"`napi_add_env_cleanup_hook`/`napi_remove_env_cleanup_hook`调用报错，有以下几个常见原因和对应的特征日志，均为接口使用不当导致。\",\"322\":\"1. 在`env`所在的js线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。\",\"323\":\"2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。特征报错日志`AddCleanupHook Failed`。\",\"324\":\"3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在（或已被删除）的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。\",\"325\":\"\",\"326\":\"常见错误场景示例如下：\",\"327\":\"\",\"328\":\"```c++\",\"329\":\"void AddEnvCleanupHook(napi_env env)\"}",
      "修改建议": "“不存在（或已被删除）”中的“（或已被删除）”表意模糊，应改为“或已被删除的”",
      "更改后示例": "3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在或已被删除的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。",
      "触发条件": "当文档中存在使用括号包裹的\"或\"字并列结构（如\"不存在（或已被删除）\"），且该结构导致修饰成分与核心名词分离时，触发语言表达一致性规则。\n\n识别模式：\n1. 检测括号内包含\"或\"字并列的同类型说明项（如状态描述/操作结果）\n2. 验证括号内容与主句成分属于同一语义层级（此处均为args的状态描述）\n3. 判断括号使用是否造成修饰结构断裂（原句括号使\"的args\"与修饰语分离）"
    },
    {
      "defect_id": 405204,
      "sentence": "OpenHarmony中动态库加载namespace配置的情况",
      "reference_sentence": "OpenHarmony中动态库加载namespace配置的情况",
      "line_num": 29,
      "context": "{\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\",\"33\":\"- ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。\",\"34\":\"\"}",
      "修改建议": "混用了“namespace”和“namespace”（建议统一使用“命名空间”）",
      "更改后示例": "OpenHarmony中动态库加载命名空间配置的情况",
      "触发条件": "同一术语在文档中存在中英文混用（如\"namespace\"与\"命名空间\"交替出现），且上下文已明确该术语的中文标准译法（如\"命名空间（namespace）\"定义性说明）。  \n\n识别模式：当检测到同一概念在相邻段落/条目中交替使用英文术语和其中文译名（如\"namespace\"与\"命名空间\"），且存在明确的术语定义（如括号标注\"namespace下面统称为ns\"）时触发规则。"
    },
    {
      "defect_id": 404847,
      "sentence": "| try to load abc file from $FILEPATH failed. | 通常加载动态库和abc文件为二选一：如果是要加载动态库并且加载失败，该告警可以忽略；如果是要加载abc文件，则该错误打印的原因是abc文件不存在，$FILEPATH表示模块路径。 |",
      "reference_sentence": "| try to load abc file from $FILEPATH failed. | 通常加载动态库和abc文件为二选一：如果是要加载动态库并且加载失败，该告警可以忽略；如果是要加载abc文件，则该错误打印的原因是abc文件不存在，$FILEPATH表示模块路径。 |",
      "line_num": 24,
      "context": "{\"19\":\"| **已知关键错误日志** | **修改建议** |\",\"20\":\"| -------- | -------- |\",\"21\":\"| module $SO is not allowed to load in restricted runtime. | $SO表示模块名。该模块不在受限worker线程的so加载白名单，不允许加载，建议用户删除该模块。 |\",\"22\":\"| module $SO is in blocklist, loading prohibited. | $SO表示模块名。受卡片或者Extension管控，该模块在黑名单内，不允许加载，建议用户删除该模块。 |\",\"23\":\"| load module failed. $ERRMSG. | 动态库加载失败。$ERRMSG表示加载失败原因，一般常见原因是so文件不存在、依赖的so文件不存在或者符号未定义，需根据加载失败原因具体分析。 |\",\"24\":\"| try to load abc file from $FILEPATH failed. | 通常加载动态库和abc文件为二选一：如果是要加载动态库并且加载失败，该告警可以忽略；如果是要加载abc文件，则该错误打印的原因是abc文件不存在，$FILEPATH表示模块路径。 |\",\"25\":\"\",\"26\":\"5. 如果有明确的Error message，可以通过Error message判断当前问题。\",\"27\":\"\",\"28\":\"| **Error message** | **修改建议** |\",\"29\":\"| -------- | -------- |\"}",
      "修改建议": "句子中混用了“模块路径”和“路径”两种表达方式，建议统一使用一种表达方式。",
      "更改后示例": "| try to load abc file from $FILEPATH failed. | 通常加载动态库和abc文件为二选一：如果是要加载动态库并且加载失败，该告警可以忽略；如果是要加载abc文件，则该错误打印的原因是abc文件不存在，$FILEPATH表示路径。 |",
      "触发条件": "同一变量或概念在相邻条目/上下文中出现不一致的术语表述（如\"模块路径\"与\"路径\"混用），且存在可替换的标准化表达时触发。\n\n识别模式：\n1. 检查同一变量（如$FILEPATH）在相邻表格行或上下文中的描述是否统一\n2. 对比相同语义概念（如路径描述）在不同位置的表达方式是否一致\n3. 发现同一技术要素存在两种及以上不同命名表述（如\"模块路径\"和\"路径\"指代相同内容）"
    },
    {
      "defect_id": 404846,
      "sentence": "3. 排查依赖的so是否加载成功。",
      "reference_sentence": "3. 排查依赖的so是否加载成功。",
      "line_num": 11,
      "context": "{\"6\":\"   如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。\",\"7\":\"\",\"8\":\"2. 排查so是否加载成功。\",\"9\":\"   应用启动时过滤模块加载相关日志，重点搜索\\\"dlopen\\\"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。\",\"10\":\"\",\"11\":\"3. 排查依赖的so是否加载成功。\",\"12\":\"   确定所依赖的其它so是否打包到应用中以及是否有权限打开。常见加载失败原因有权限不足、so文件不存在等，可根据以下关键错误日志确认问题。\",\"13\":\"\",\"14\":\"4. 排查模块导入方式与so路径是否对应。\",\"15\":\"   若JS侧导入模块的形式为： import xxx from '\\\\@ohos.yyy.zzz'，则该so将在/system/lib/module/yyy中找libzzz.z.so或libzzz_napi.z.so，若so不存在或名称无法对应，则报错日志中会出现dlopen相关日志。\",\"16\":\"\"}",
      "修改建议": "句子中混用了“so是否加载成功”和“so加载是否成功”两种表达方式，建议统一使用一种表达方式。",
      "更改后示例": "3. 排查依赖的so加载是否成功。",
      "触发条件": "同一文档中相邻条目或同类操作步骤出现\"是否+动词\"与\"动词+是否\"两种语序混用时触发，通过对比上下文句式结构识别需统一表达的重复性操作描述。"
    },
    {
      "defect_id": 404845,
      "sentence": "2. 排查so是否加载成功。",
      "reference_sentence": "2. 排查so是否加载成功。",
      "line_num": 8,
      "context": "{\"3\":\"## ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message\",\"4\":\"\",\"5\":\"1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。\",\"6\":\"   如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。\",\"7\":\"\",\"8\":\"2. 排查so是否加载成功。\",\"9\":\"   应用启动时过滤模块加载相关日志，重点搜索\\\"dlopen\\\"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。\",\"10\":\"\",\"11\":\"3. 排查依赖的so是否加载成功。\",\"12\":\"   确定所依赖的其它so是否打包到应用中以及是否有权限打开。常见加载失败原因有权限不足、so文件不存在等，可根据以下关键错误日志确认问题。\",\"13\":\"\"}",
      "修改建议": "句子中混用了“so是否加载成功”和“so加载是否成功”两种表达方式，建议统一使用一种表达方式。",
      "更改后示例": "2. 排查so加载是否成功。",
      "触发条件": "同一文档中出现同一概念采用\"是否+动词\"与\"动词+是否\"两种不同语序表达，且相邻列表项存在相同语法结构的表达冲突。\n\n识别模式：\n1. 检测疑问句式中的\"是否\"位置异常：当\"是否\"出现在动词前(\"是否加载\")与动词后(\"加载是否\")两种形式并存时\n2. 上下文对比验证：检查相邻列表项(如当前第8项与第11项均使用\"是否加载成功\")或同类操作步骤中的语法结构一致性\n3. 语义重复性判断：确认不同语序表达的是完全相同的检查动作(如\"so是否加载\"与\"so加载是否\"指代同一操作)"
    },
    {
      "defect_id": 404886,
      "sentence": "Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若napi接口返回值不为napi_ok，可从以下几个方面进行排查。",
      "reference_sentence": "Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若napi接口返回值不为napi_ok，可从以下几个方面进行排查。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"- napi_ref由开发者自己管理，需要手动delete。\",\"53\":\"\",\"54\":\"## Node-API接口返回值不是napi_ok时，如何排查定位\",\"55\":\"\",\"56\":\"Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若napi接口返回值不为napi_ok，可从以下几个方面进行排查。\",\"57\":\"\",\"58\":\"- Node-API接口执行前一般会进行入参校验，首先进行的是判空校验。在代码中体现为：\",\"59\":\"\",\"60\":\"  ```cpp\",\"61\":\"  CHECK_ENV： env判空校验\"}",
      "修改建议": "混用了`napi接口`和`Node-API接口`概念",
      "更改后示例": "Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若Node-API接口返回值不为napi_ok，可从以下几个方面进行排查。",
      "触发条件": "同一文档中交替使用全称与缩写形式指代同一技术术语（如\"Node-API接口\"与\"napi接口\"），或相邻段落出现同一概念的大小写/连字符不一致（如node-api与Node-API）。"
    },
    {
      "defect_id": 405221,
      "sentence": "除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。",
      "reference_sentence": "除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS跨语言交互\",\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "使用ArkTS进行开发，也可以通过Node-API实现ArkTS和C/C++（Native）的跨语言交互。",
      "触发条件": "同一段落或相邻上下文中存在多个描述相似功能的句子，且句式结构不一致（如混合使用被动句与主动句、包含主语与省略主语）。通过检测动词形态/主语显隐差异识别需统一为祈使句的情况。"
    },
    {
      "defect_id": 404901,
      "sentence": "3. 对于删除失败的问题，需要使用者确保`args`之前被注册过且未被删除。",
      "reference_sentence": "3. 对于删除失败的问题，需要使用者确保`args`之前被注册过且未被删除。",
      "line_num": 349,
      "context": "{\"344\":\"```\",\"345\":\"\",\"346\":\"修复建议：\",\"347\":\"1. 对于多线程安全问题，需确保调用接口的线程在`env`所在的js线程上。\",\"348\":\"2. 对于注册失败的问题，需要使用者评估想注册的函数到底是哪一个。需要保证`key`值（也就是`napi_add_env_cleanup_hook`的第三个入参）是唯一的即可。\",\"349\":\"3. 对于删除失败的问题，需要使用者确保`args`之前被注册过且未被删除。\",\"350\":\"\",\"351\":\"相关参考资料链接：\",\"352\":\"[使用Node-API接口注册和使用环境清理钩子](use-napi-about-cleanuphook.md)\",\"353\":\"[方舟运行时的NApi](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615)\",\"354\":\"\"}",
      "修改建议": "“删除”与“移除”用词不一致",
      "更改后示例": "3. 对于移除失败的问题，需要使用者确保`args`之前被注册过且未被移除。",
      "触发条件": "同一技术概念在邻近上下文（如同一条目、相邻条目或关联操作描述）中使用了两种及以上不同术语表述，且存在明确术语对照关系（如\"删除/移除\"、\"注册/注销\"等动词性近义词配对）时触发。  \n\n识别模式：  \n1. 结构特征：在相同编号条目或相邻列表项中，针对同类操作场景使用不同动词  \n2.语义特征：存在可互换的近义词对（如删除/移除），且前后未保持统一表述  \n3.语境特征：操作对象（如`args`）、问题类型（如失败场景）等上下文要素完全一致"
    },
    {
      "defect_id": 404896,
      "sentence": "1. 在`env`所在的js线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。",
      "reference_sentence": "1. 在`env`所在的JS线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。",
      "line_num": 322,
      "context": "{\"317\":\"}\",\"318\":\"```\",\"319\":\"\",\"320\":\"## napi_add_env_cleanup_hook/napi_remove_env_cleanup_hook调用报错，该如何处理\",\"321\":\"`napi_add_env_cleanup_hook`/`napi_remove_env_cleanup_hook`调用报错，有以下几个常见原因和对应的特征日志，均为接口使用不当导致。\",\"322\":\"1. 在`env`所在的js线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。\",\"323\":\"2. 调用`napi_add_env_cleanup_hook`时，重复使用同一个`args`注册不同的回调函数，导致后续注册失败问题。该接口第三个入参`args`是作为接口内部`map`的`key`值，当重复注册同一个`args`的回调时，后续注册动作将会失败，仅第一次注册才会成功。注册失败可能会引起后续业务上的功能/崩溃问题。特征报错日志`AddCleanupHook Failed`。\",\"324\":\"3. 调用`napi_remove_env_cleanup_hook`时，尝试通过一个不存在（或已被删除）的`args`删除回调函数，该接口调用失败，出现特征报错日志`RemoveCleanupHook Failed`。\",\"325\":\"\",\"326\":\"常见错误场景示例如下：\",\"327\":\"\"}",
      "修改建议": "“js线程”与“JS线程”用词不一致",
      "更改后示例": "1. 在`env`所在的JS线程外使用上述两个接口，导致多线程安全问题。特征报错日志`ecma_vm cannot run in multi-thread`。",
      "触发条件": "当同一术语在相邻或相关段落中存在不一致的大小写形式（如\"js线程\"与\"JS线程\"），且上下文存在该术语的标准写法（如参考句中的\"JS线程\"）时触发。\n\n识别模式：\n1. 通过正则表达式匹配特定技术术语（如/[A-Z]{2,}/或驼峰式命名）及其小写变体\n2. 检查同一文档段落中是否存在同一术语的多种书写形式\n3. 对比问题点与上下文参考句的术语表达差异（如问题句322与修复后参考句的\"JS线程\"对比）"
    },
    {
      "defect_id": 405205,
      "sentence": "例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。",
      "reference_sentence": "例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。",
      "line_num": 49,
      "context": "{\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\",\"53\":\"```\",\"54\":\"![zh-cn_image_musl_ld_rpath](figures/dl_rpath.png)\"}",
      "修改建议": "混用了“路径”和“目录”（建议统一使用“路径”或“目录”）",
      "更改后示例": "例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载`module`目录下的`libworld.so`。",
      "触发条件": "同一段落或相邻句子中，针对同一文件系统位置描述时混用\"路径\"和\"目录\"等近义术语，且上下文已存在明确术语倾向（如问题段落前文已使用\"路径\"9次、\"目录\"3次）。\n\n识别模式：\n1. 检测同一语义单元（通常为段落）内存在多个文件位置描述词（路径/目录/文件夹等）\n2. 通过词频统计确认上下文存在主导术语（如\"路径\"出现频次显著高于其他近义词）\n3. 验证术语混用发生在相同逻辑层级的位置描述（如都用于描述动态库存储位置）\n4. 排除合理的技术术语固定搭配（如\"安装目录\"作为专有名词可保留）"
    },
    {
      "defect_id": 405224,
      "sentence": "[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。",
      "reference_sentence": "[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "查看[Node-API扩展能力接口](../napi/use-napi-about-extension.md)，了解进一步扩展NAPI功能的额外接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)，高效地进行跨语言功能开发。",
      "触发条件": "同一段落中存在混合句式结构（陈述句与祈使句并存），且涉及操作指引（如\"参考\"\"查看\"等动词）时，触发语言一致性规则。\n\n识别模式：\n1. 检测相邻句子中是否交替出现含主语的陈述句（如\"开发者可...\"）和无主语的祈使句（如\"参考...\"）\n2. 识别包含操作类动词（参考/查看/使用等）的句子结构差异\n3. 通过依存句法分析确认主语缺失/存在状态，对比上下文动词短语结构一致性"
    },
    {
      "defect_id": 405259,
      "sentence": "#### 对象追踪",
      "reference_sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "line_num": 38,
      "context": "{\"33\":\"  parent.child = child;\",\"34\":\"  child.parent = parent;\",\"35\":\"}\",\"36\":\"```\",\"37\":\"在上述代码中，对象parent被对象child持有，parent的引用计数加1。同时，child也被parent持有，child的引用计数也加1。这导致了循环引用，直到main函数结束，parent和child仍无法释放，从而引发内存泄漏。\",\"38\":\"#### 对象追踪\",\"39\":\"\",\"40\":\"![image](./figures/tracing-gc.png)\",\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "#### Tracing GC",
      "触发条件": "当同一术语在文档中出现中英文混用（如 \"对象追踪\" 与 \"Tracing GC\"），且该术语已在上下文或参考句中被明确定义/标准化时触发。\n\n识别模式：\n1. 术语对照检测：识别中文术语与括号/相邻位置出现的英文术语（如 \"对象追踪(Tracing GC)\" 结构）\n2. 跨段落一致性验证：检查标题术语与正文技术描述、图表文件名（如问题上下文中的 `tracing-gc.png`）是否匹配\n3. 关键位置扫描：特别关注章节标题、图表标题等强调术语规范性的位置\n4. 首现参照原则：若某术语已在文档前部标准化（如参考句中的 \"Tracing GC\"），则后续出现非标准表达时触发告警"
    },
    {
      "defect_id": 405260,
      "sentence": "对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。",
      "reference_sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "line_num": 43,
      "context": "{\"38\":\"#### 对象追踪\",\"39\":\"\",\"40\":\"![image](./figures/tracing-gc.png)\",\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\",\"48\":\"### 对象追踪的三种类型\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "Tracing GC算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。",
      "触发条件": "同一技术概念在文档中先后出现两种及以上不同术语表述（如\"对象追踪\"和\"Tracing GC\"），且未通过括号说明建立等价关系时触发。\n\n识别模式：\n1. 邻近段落存在相同概念的两种表述（如上下文第43行\"对象追踪算法\"与第46行\"Tracing GC\"）\n2. 存在被广泛认可的规范术语时（如参考句已确立\"Tracing GC\"为正式分类）\n3. 术语混用可能造成理解混淆时（如算法名称与实现名称混用）"
    },
    {
      "defect_id": 405418,
      "sentence": "传入的XML文本中若包含“&”字符，请使用实体引用“\\&amp;”替换。",
      "reference_sentence": "XML解析及转换需要确保传入的XML数据符合标准格式。",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"2. 输入待转换的XML，设置转换选项，支持的转换选项及含义具体可见[ConvertOptions](../reference/apis-arkts/js-apis-convertxml.md#convertoptions)。\",\"26\":\"\",\"27\":\"   > **说明：**\",\"28\":\"   >\",\"29\":\"   > 传入的XML文本中若包含“&”字符，请使用实体引用“\\\\&amp;”替换。\",\"30\":\"\",\"31\":\"   ```ts\",\"32\":\"   let xml: string =\",\"33\":\"    '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>' +\",\"34\":\"    '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\"}",
      "修改建议": "“传入的XML文本中若包含‘&’字符，请使用实体引用‘\\&amp;’替换”与“XML解析及转换需要确保传入的XML数据符合标准格式”表述不一致，且存在表意模糊。",
      "更改后示例": "请确保传入的XML文本符合标准格式，若包含“&”字符，请使用实体引用“\\&amp;”替换。",
      "触发条件": "当文档相邻或上下文语句存在表述结构差异（如条件式vs陈述式）、术语不一致（如\"XML文本\" vs \"XML数据\"），且与核心参考句式（如\"需要确保...符合标准格式\"）产生风格冲突时触发。"
    },
    {
      "defect_id": 405262,
      "sentence": "引用计数和对象追踪算法各有优劣。",
      "reference_sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\",\"48\":\"### 对象追踪的三种类型\",\"49\":\"\",\"50\":\"对象追踪算法通过遍历对象图标记出垃圾，而根据垃圾回收方式的不同，对象追踪可以分为三种基本类型：标记-清扫回收、标记-复制回收、标记-整理回收。以下图示中蓝色标记为可达对象，黄色标记为不可达对象。\",\"51\":\"\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "引用计数和Tracing GC算法各有优劣。",
      "触发条件": "同一文档中对同一技术概念使用多个不同术语（如“对象追踪”和“Tracing GC”），且这些术语已被上下文明确定义为等价关系（例如通过括号说明或术语表）。需通过术语同义匹配和上下文关联性检测识别不一致表达。"
    },
    {
      "defect_id": 405285,
      "sentence": "根据系统分配堆空间总大小64MB-128MB/128MB-256MB/大于256MB的三个范围，以下参数系统会设置不同的大小。如果表格内范围仅有一个值，则表示该参数值不随堆空间总大小变化。手机设备堆空间总大小默认为大于256MB。",
      "reference_sentence": "根据系统分配堆空间总大小64MB-128MB/128MB-256MB/大于256MB的三个范围，以下参数系统会设置不同的大小。如果表格内范围仅有一个值，则表示该参数值不随堆空间总大小变化。手机设备堆空间总大小默认为大于256MB。",
      "line_num": 129,
      "context": "{\"124\":\"\",\"125\":\"> **注意：**\",\"126\":\"> \",\"127\":\"> 以下参数未提示可配置的均为不可配置项，由系统自行设定。\",\"128\":\"\",\"129\":\"根据系统分配堆空间总大小64MB-128MB/128MB-256MB/大于256MB的三个范围，以下参数系统会设置不同的大小。如果表格内范围仅有一个值，则表示该参数值不随堆空间总大小变化。手机设备堆空间总大小默认为大于256MB。  \",\"130\":\"开发者可以查阅[hidebug接口文档](../reference/apis-performance-analysis-kit/js-apis-hidebug.md)，使用相关接口查询内存信息。\",\"131\":\"#### 堆大小相关参数\",\"132\":\"\",\"133\":\"| 参数名 | 范围 | 作用 |\",\"134\":\"| --- | --- | --- |\"}",
      "修改建议": "用词不一致，'堆空间总大小'与'堆大小'混用。",
      "更改后示例": "根据系统分配堆大小总大小64MB-128MB/128MB-256MB/大于256MB的三个范围，以下参数系统会设置不同的大小。如果表格内范围仅有一个值，则表示该参数值不随堆大小总大小变化。手机设备堆大小总大小默认为大于256MB。",
      "触发条件": "同一文档中同一技术概念存在多个不同术语表述（如\"堆空间总大小\"与\"堆大小\"），且这些术语在相邻段落/表格标题等关键位置重复出现。\n\n识别模式：\n1. 通过NLP检测同一段落内相同语义的复合名词存在词形差异（如包含/缺失\"空间\"等修饰词）\n2. 结合上下文特征判断：当表格标题（如\"堆大小相关参数\"）与正文描述术语不一致，且参数作用域存在直接关联时\n3. 验证术语连续性：核心参数名称在首次定义后，后续引用出现词素增减或结构变化的情况"
    },
    {
      "defect_id": 405263,
      "sentence": "由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。",
      "reference_sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\",\"48\":\"### 对象追踪的三种类型\",\"49\":\"\",\"50\":\"对象追踪算法通过遍历对象图标记出垃圾，而根据垃圾回收方式的不同，对象追踪可以分为三种基本类型：标记-清扫回收、标记-复制回收、标记-整理回收。以下图示中蓝色标记为可达对象，黄色标记为不可达对象。\",\"51\":\"\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "由于引用计数存在内存泄漏问题，ArkTS运行时选择基于Tracing GC算法设计GC。",
      "触发条件": "同一技术概念在相邻段落或同一句子中混用中英文术语或不同译名，且存在已定义的统一术语时。  \n\n识别模式：  \n1. **术语对照检查**：在括号解释（如“即Tracing GC”）或邻近上下文中，检测核心术语是否与文档已确立的标准术语（如“Tracing GC”）不一致。  \n2. **邻近重复冲突**：若同一段落或相邻段落内同一概念出现两种表达（如“对象追踪”和“Tracing GC”），且未明确说明为同义词，则判定为不一致。"
    },
    {
      "defect_id": 405440,
      "sentence": "当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\<number\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。",
      "reference_sentence": "当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array<number> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图像处理和文件接收上传等。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"## FastBuffer\",\"30\":\"\",\"31\":\"FastBuffer是一种高性能二进制数据容器，专为固定长度字节序列的存储与处理设计。相比 Buffer，它在效率、读写速度上具有显著优势。\",\"32\":\"\",\"33\":\"当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\\\<number\\\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。\",\"34\":\"\",\"35\":\"FastBuffer模块的核心功能包括：\",\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\"}",
      "修改建议": "混用了'图片'和'图像'概念",
      "更改后示例": "当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array<number> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图像处理和文件接收上传等。",
      "触发条件": "当同一文档或上下文范围内，对同一技术概念或应用场景出现多个同义词/近义词混用（如图片 vs 图像），且存在明确的规范术语（由参考句子或技术规范定义）时触发。\n\n识别模式：\n1. 检测技术场景描述中的核心术语（如二进制数据处理的应用领域）\n2. 比对同段落/相邻段落是否存在同概念的不同表达形式\n3. 验证参考句子或技术规范中是否已明确定义标准术语（如图像处理）\n4. 当非标准术语（图片处理）与标准术语（图像处理）同时存在时标记异常"
    },
    {
      "defect_id": 405287,
      "sentence": "初始化时均设定为Heap剩余未分配空间的大小，默认手机设备主线程OldSpaceSize上限接近350MB。",
      "reference_sentence": "初始化时均设定为Heap剩余未分配空间的大小，默认手机设备主线程OldSpaceSize上限接近350MB。",
      "line_num": 156,
      "context": "{\"151\":\"| semiSpaceSize | 2MB-4MB/2MB-8MB/2MB-16MB | SemiSpace空间大小，会根据堆总大小有不同的范围限制。 |\",\"152\":\"| semiSpaceTriggerConcurrentMark | 1M/1.5M/1.5M| 首次单独触发Semi Space的并发mark的界限值，超过该值则触发。 |\",\"153\":\"| semiSpaceStepOvershootSize| 2MB | 允许过冲最大大小。 |\",\"154\":\"\",\"155\":\"#### Old Space 和 Huge Object Space\",\"156\":\"初始化时均设定为Heap剩余未分配空间的大小，默认手机设备主线程OldSpaceSize上限接近350MB。\",\"157\":\"\",\"158\":\"| 参数名 | 范围 | 作用 |\",\"159\":\"| --- | --- | --- |\",\"160\":\"| oldSpaceOvershootSize | 4MB/8MB/8MB | OldSpace允许过冲最大大小。 |\",\"161\":\"\"}",
      "修改建议": "用词不一致，'Heap'与'堆'混用。",
      "更改后示例": "初始化时均设定为堆剩余未分配空间的大小，默认手机设备主线程OldSpaceSize上限接近350MB。",
      "触发条件": "同一技术术语在相邻或相关上下文中出现中英文混用（如\"Heap\"与\"堆\"），且未保持全文统一表达形式。\n\n识别模式：\n1. 在相近段落/表格中检测到同一概念存在两种语言形式（如英文术语与中文译名交替出现）\n2. 通过术语对照表验证该词汇属于应保持统一表达的技术专有名词\n3. 结合上下文判断是否属于同一语义场景（如本例中\"Heap剩余未分配空间\"与下文\"堆总大小\"指代相同内存结构）"
    },
    {
      "defect_id": 405261,
      "sentence": "和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。",
      "reference_sentence": "当前主流编程语言实现的GC算法主要分为两大类：引用计数和Tracing GC。",
      "line_num": 44,
      "context": "{\"39\":\"\",\"40\":\"![image](./figures/tracing-gc.png)\",\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\",\"48\":\"### 对象追踪的三种类型\",\"49\":\"\"}",
      "修改建议": "术语 '对象追踪' 和 'Tracing GC' 混用，应保持一致。",
      "更改后示例": "和引用计数算法相反，Tracing GC算法较为复杂，且有短暂的STW阶段。",
      "触发条件": "当同一技术概念在相邻段落中出现多个已定义的术语变体（如中文直译与英文术语），且存在术语混用导致表述不一致时触发。\n\n识别模式：通过以下特征组合检测问题：\n1. 存在同义术语对（如\"对象追踪算法\"与\"Tracing GC\"）\n2. 在文档前文已建立术语关联（如第46行的括号说明）\n3. 术语混用出现在同一技术对比场景中（如引用计数 vs Tracing GC的优缺点分析）\n4. 术语变体间隔不超过3个段落（保证读者短期记忆关联性）"
    },
    {
      "defect_id": 405525,
      "sentence": "[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)可用于构造双向链表对象，支持在任意节点向前或向后遍历List。",
      "reference_sentence": "[List](../reference/apis-arkts/js-apis-list.md)可用来构造一个单向链表对象，若需要查找List中某一个元素，只能从头结点开始遍历。",
      "line_num": 70,
      "context": "{\"65\":\"| 删除元素 | remove(element: T) | 通过 === 运算符逐个比对链表中的元素，删除第一个匹配成功的节点。对于对象类型，只有当传入的对象与链表中某节点的引用完全一致时才会被删除。 |\",\"66\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素，如果index超出范围，则会报out of range错误。 |\",\"67\":\"\",\"68\":\"## LinkedList\",\"69\":\"\",\"70\":\"[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)可用于构造双向链表对象，支持在任意节点向前或向后遍历List。LinkedList依据泛型定义，其元素在内存中的存储位置可以不连续。\",\"71\":\"\",\"72\":\"LinkedList和[List](../reference/apis-arkts/js-apis-list.md)相比，LinkedList是双向链表，支持快速的头尾增删操作，而List是单向链表，不支持双向操作。\",\"73\":\"\",\"74\":\"LinkedList和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相比，LinkedList插入数据的效率高于ArrayList，而ArrayList的查询效率高于LinkedList。\",\"75\":\"\"}",
      "修改建议": "混用了`List`和`LinkedList`概念",
      "更改后示例": "[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)可用于构造双向链表对象，支持在任意节点向前或向后遍历LinkedList。",
      "触发条件": "当文档中混用具有从属关系或相似功能的术语（如\"List\"和\"LinkedList\"），且上下文明确指向特定数据结构时；当同一段落/章节内出现术语指代不一致，可能造成概念混淆时。\n\n识别模式：\n1. 检查核心术语是否与当前章节标题/API名称完全匹配（如LinkedList章节应统一使用LinkedList）\n2. 检测相邻比较句式中是否存在术语混用（如\"与List相比，LinkedList...\"的对比结构）\n3. 验证代词/简称是否与首次出现的全称定义一致（若首次定义\"LinkedList\"，后续不应简化为\"List\"）\n4. 识别具有包含关系的术语对（如LinkedList是List的子类型），确保不出现父类术语替代子类的情况"
    },
    {
      "defect_id": 405286,
      "sentence": "heap中生成两个Semi Space供copying使用。",
      "reference_sentence": "heap中生成两个Semi Space供copying使用。",
      "line_num": 148,
      "context": "{\"143\":\"| 参数名 | 范围 | 作用 |\",\"144\":\"| --- | --- | --- |\",\"145\":\"| HeapSize  | 768 MB | worker类型线程堆空间大小。 |\",\"146\":\"\",\"147\":\"#### Semi Space\",\"148\":\"heap中生成两个Semi Space供copying使用。\",\"149\":\"| 参数名 | 范围 | 作用 |\",\"150\":\"| --- | --- | --- |\",\"151\":\"| semiSpaceSize | 2MB-4MB/2MB-8MB/2MB-16MB | SemiSpace空间大小，会根据堆总大小有不同的范围限制。 |\",\"152\":\"| semiSpaceTriggerConcurrentMark | 1M/1.5M/1.5M| 首次单独触发Semi Space的并发mark的界限值，超过该值则触发。 |\",\"153\":\"| semiSpaceStepOvershootSize| 2MB | 允许过冲最大大小。 |\"}",
      "修改建议": "用词不一致，'heap'与'堆'混用。",
      "更改后示例": "堆中生成两个Semi Space供copying使用。",
      "触发条件": "同一技术术语在中文文档中出现中英文混用，且上下文存在明确对应的中文/英文统一表达形式时触发。\n\n识别模式：\n1. 术语对照检测：当参数定义位置（如145行\"HeapSize\"对应\"堆空间\"）已建立中英对照关系\n2. 邻近不一致：在相邻段落（间隔≤5行）中出现同一术语的不同语言形态（如\"HeapSize\"与\"堆\"在145行，148行出现\"heap\"）"
    },
    {
      "defect_id": 405417,
      "sentence": "语言基础类库提供ConvertXML类将XML文本转换为JavaScript对象",
      "reference_sentence": "将XML文本转换为JavaScript对象便于处理和操作数据，适合在JavaScript应用程序中使用。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"\",\"4\":\"将XML文本转换为JavaScript对象便于处理和操作数据，适合在JavaScript应用程序中使用。\",\"5\":\"\",\"6\":\"\",\"7\":\"语言基础类库提供ConvertXML类将XML文本转换为JavaScript对象，输入为待转换的XML字符串及转换选项，输出为转换后的JavaScript对象。具体转换选项可见[API参考@ohos.convertxml](../reference/apis-arkts/js-apis-convertxml.md)。\",\"8\":\"\",\"9\":\"\",\"10\":\"## 注意事项\",\"11\":\"\",\"12\":\"XML解析及转换需要确保传入的XML数据符合标准格式。\"}",
      "修改建议": "混用了“语言基础类库提供ConvertXML类”和“将XML文本转换为JavaScript对象”两个概念，导致表述不一致。",
      "更改后示例": "语言基础类库提供ConvertXML类，将XML文本转换为JavaScript对象，便于处理和操作数据，适合在JavaScript应用程序中使用。",
      "触发条件": "当句子中混合使用不同层级的概念（如类库功能与具体操作效果）且缺乏逻辑衔接，或同一段落内存在表述焦点不一致（如功能说明与使用场景割裂）时触发。\n\n识别模式：1) 检查主谓结构是否承载多个未用连接词关联的独立信息点 2) 对比上下文句式结构（如相邻句子均采用\"功能+效果\"的扩展结构时，孤立的功能陈述句构成不一致）3) 验证核心术语的使用场景是否统一（如原句单独使用技术术语而未关联用户价值，与上下文强调实用性的表达模式冲突）。"
    },
    {
      "defect_id": 405531,
      "sentence": "| 删除元素 | pop() | 将栈顶元素作为返回值进行返回，并将其出队。|",
      "reference_sentence": "| 删除元素 | popFirst() | 将队首元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。|",
      "line_num": 163,
      "context": "{\"158\":\"| 增加元素 | push(item: T) | 在栈顶增加一个元素。 |\",\"159\":\"| 访问元素 | peek() | 获取栈顶元素，不进行出队操作。 |\",\"160\":\"| 访问元素 | locate(element: T) | 获取元素对应的位置。 |\",\"161\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, stack?: Stack&lt;T&gt;) =&gt; void, thisArg?: Object) | 遍历访问整个Stack容器的每个元素，并执行指定的回调函数。 |\",\"162\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"163\":\"| 删除元素 | pop() | 将栈顶元素作为返回值进行返回，并将其出队。|\",\"164\":\"\",\"165\":\"## Vector\",\"166\":\"\",\"167\":\"> **说明**：\",\"168\":\">\"}",
      "修改建议": "混用了'出队'和'移除'，且'栈顶'与'头部'近义词混用",
      "更改后示例": "| 删除元素 | pop() | 将栈顶元素作为返回值进行返回，并将其移除。|",
      "触发条件": "同一文档中对同一操作使用不同术语（如\"出队\"和\"移除\"混用），或数据结构特性与操作术语不匹配（如栈结构使用队列术语\"出队\"）时触发。"
    },
    {
      "defect_id": 405070,
      "sentence": "释放编译与debug编译的区别不仅限于混淆。",
      "reference_sentence": "release编译与debug编译的区别不仅限于混淆。",
      "line_num": 54,
      "context": "{\"49\":\"* 指定release编译  \",\"50\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"51\":\"\",\"52\":\"    > **注意：**\",\"53\":\"    >\",\"54\":\"    > release编译与debug编译的区别不仅限于混淆。若要明确应用行为差异是否由混淆引起，应通过开启或关闭混淆开关进行排查，而不是仅通过切换编译模式。\",\"55\":\"\",\"56\":\"### 三种混淆配置文件\",\"57\":\"* `obfuscation-rules.txt`  \",\"58\":\"    在HAP、HAR和HSP模块的`build-profile.json5`配置文件中，均包含`arkOptions.obfuscation.ruleOptions.files`字段，该字段用于指定当前模块在编译过程中所应用的混淆规则，新建工程时，系统默认会生成混淆规则文件`obfuscation-rules.txt`作为初始配置。\",\"59\":\"\"}",
      "修改建议": "混用了'释放'和'release'不同形式的表述",
      "更改后示例": "release编译与debug编译的区别不仅限于混淆。",
      "触发条件": "同一术语在邻近上下文中存在两种及以上不同表达形式（如中英文混用），且与参考段落中的标准表述产生冲突。\n\n识别模式：\n1. 术语对照检测：当\"中文直译词\"（如释放）与\"英文原词\"（如release）同时出现在同一段落或相邻段落中\n2. 上下文一致性验证：检查问题术语是否与最近的标准表述段落（如第54行）存在冲突\n3. 功能词校验：重点检查带有技术含义的核心术语（如release编译），排除通用词汇干扰"
    },
    {
      "defect_id": 405528,
      "sentence": "Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。",
      "reference_sentence": "Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。",
      "line_num": 130,
      "context": "{\"125\":\"\",\"126\":\"Queue依据泛型定义，存储位置必须是连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。\",\"127\":\"\",\"128\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"129\":\"\",\"130\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"131\":\"\",\"132\":\"一般符合先进先出的场景可以使用Queue。\",\"133\":\"\",\"134\":\"Queue支持增、删、改、查操作，常用API如下：\",\"135\":\"\"}",
      "修改建议": "混用了'增删'和'增删操作'，且'删除'与'移除'近义词混用",
      "更改后示例": "Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue仅支持在头部删除元素，尾部增加元素，而Deque支持在两端进行元素的增删操作。",
      "触发条件": "同一上下文存在近义词混用（如\"删除/移除\"）或同类概念表述结构不一致（如\"增删\"与\"增删操作\"）时触发。\n\n识别模式：\n1. 检测相邻/对比句中的动词短语（如\"删除元素\"与\"移除\"）\n2. 匹配核心操作词是否保持\"动词+宾语\"结构一致性（如\"增删操作\"应统一带\"操作\"后缀）\n3. 识别对比句式中的对称性缺失（如\"一端删除一端增加\"与\"两端增删\"结构不对称）"
    },
    {
      "defect_id": 405529,
      "sentence": "Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue基于循环队列实现，只能在头部删除元素，尾部增加元素，而Stack都在一端操作。",
      "reference_sentence": "Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。",
      "line_num": 150,
      "context": "{\"145\":\"\",\"146\":\"[Stack](../reference/apis-arkts/js-apis-stack.md)可用来构造栈对象，存储元素遵循先进后出的规则。\",\"147\":\"\",\"148\":\"Stack依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的1.5倍。Stack底层基于数组实现，入栈和出栈操作均在数组的一端进行。\",\"149\":\"\",\"150\":\"Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue基于循环队列实现，只能在头部删除元素，尾部增加元素，而Stack都在一端操作。\",\"151\":\"\",\"152\":\"一般符合先进后出的场景可以使用Stack。\",\"153\":\"\",\"154\":\"Stack支持增、删、改、查操作，常用API如下：\",\"155\":\"\"}",
      "修改建议": "混用了'增删操作'和'删除元素'，且'删除'与'移除'近义词混用",
      "更改后示例": "Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue仅支持在头部删除元素，尾部增加元素，而Stack都在一端进行操作。",
      "触发条件": "当同一上下文中的相似操作描述存在动词不一致（如\"删除\"与\"移除\"混用）或结构不对称（如\"增删操作\"与\"删除元素\"表述差异），且存在可对齐的参考表达模式时触发。\n\n识别模式：\n1. 近义动词冲突：检测同一功能描述中交替使用\"删除/移除/删\"等近义动词\n2. 抽象层级错位：识别操作描述在具体动作（删除元素）与抽象术语（增删操作）之间的不匹配\n3. 结构对比异常：当对比两个组件时（如Stack vs Queue），检测描述句式结构不对称（如\"基于...实现\"与\"在...操作\"）"
    },
    {
      "defect_id": 405530,
      "sentence": "| 删除元素 | pop() | 将队首元素作为返回值进行返回，并将其出队。|",
      "reference_sentence": "| 删除元素 | popFirst() | 将队首元素作为返回值进行返回，并将其出队，如果队列为空，则返回undefined。|",
      "line_num": 142,
      "context": "{\"137\":\"| --------- | ------- | ------- |\",\"138\":\"| 增加元素 | add(element: T) | 在尾部增加一个元素。 |\",\"139\":\"| 访问元素 | getFirst() | 获取队首元素，不进行出队操作。 |\",\"140\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, queue?: Queue&lt;T&gt;) =&gt; void,thisArg?: Object) | 遍历访问整个Queue容器的每个元素，并执行指定的回调函数。 |\",\"141\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"142\":\"| 删除元素 | pop() | 将队首元素作为返回值进行返回，并将其出队。|\",\"143\":\"\",\"144\":\"## Stack\",\"145\":\"\",\"146\":\"[Stack](../reference/apis-arkts/js-apis-stack.md)可用来构造栈对象，存储元素遵循先进后出的规则。\",\"147\":\"\"}",
      "修改建议": "混用了'出队'和'移除'，且'队首'与'头部'近义词混用",
      "更改后示例": "| 删除元素 | pop() | 将队首元素作为返回值进行返回，并将其移除。|",
      "触发条件": "同一文档中对同一操作或概念使用了不一致的术语（如\"出队/移除\"），或存在近义词混用（如\"队首/头部\"），且上下文存在明确统一的表达范式时触发。\n\n识别模式：\n1. 术语冲突：在相邻条目/相同功能模块中，检测到相同操作使用不同动词（如删除操作同时出现\"出队\"和\"移除\"）\n2. 近义混用：在相同上下文环境中，关键位置名词出现近义词交替使用（如数据结构描述中同时出现\"队首\"和\"头部\"）\n3. 范式验证：通过比对参考句式和上下文条目（如行138-141统一使用\"队首\"），识别偏离既定表达范式的异常表述"
    },
    {
      "defect_id": 405533,
      "sentence": "此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。",
      "line_num": 199,
      "context": "{\"194\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"195\":\"| 删除元素 | removeByRange(fromIndex:number,toIndex:number) | 删除指定范围内的元素。 |\",\"196\":\"\",\"197\":\"## 线性容器的使用\",\"198\":\"\",\"199\":\"此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：\",\"200\":\"\",\"201\":\"\",\"202\":\"```ts\",\"203\":\"// ArrayList\",\"204\":\"import { ArrayList } from '@kit.ArkTS'; // 导入ArrayList模块\"}",
      "修改建议": "混用了`List`和`ArrayList`概念，且'增加'与'添加'近义词混用。",
      "更改后示例": "此处列举常用的线性容器ArrayList、Deque、Stack的使用示例，包括导入模块、添加元素、访问元素及修改等操作。",
      "触发条件": "当同一上下文中出现术语混用（如List与ArrayList并存）或近义动词混用（如\"增加\"与\"添加\"交替出现）时触发。\n\n识别模式：\n1. 术语一致性检测：通过领域词库匹配容器/模块名称（如ArrayList/Deque/Stack/List），识别同一功能描述中是否混用不同层级的概念\n2. 动词一致性检测：构建近义词库（如增加/添加/插入），当相邻段落出现多个近义动词描述相同操作时触发警告\n3. 上下文关联验证：结合代码示例中的具体API名称（如removeByIndex）验证描述动词的准确性"
    },
    {
      "defect_id": 405638,
      "sentence": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。",
      "reference_sentence": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。",
      "line_num": 130,
      "context": "{\"125\":\"\",\"126\":\"[LightWeightMap](../reference/apis-arkts/js-apis-lightweightmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用更加轻量级的结构，底层通过hash实现唯一key，冲突策略为线性探测。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准。\",\"127\":\"\",\"128\":\"初始默认容量为8，每次扩容为原始容量的2倍。\",\"129\":\"\",\"130\":\"LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。\",\"131\":\"\",\"132\":\"当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。\",\"133\":\"\",\"134\":\"LightWeightMap支持增、删、改、查操作，常用API如下：\",\"135\":\"\"}",
      "修改建议": "前文使用了“存储具有关联关系的key-value键值对集合”，而这里使用了“存储键值对的集合”，用词不一致",
      "更改后示例": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储具有关联关系的key-value键值对集合，LightWeightMap占用内存更小。",
      "触发条件": "当同一文档中相邻段落或相关描述对相同概念使用不同术语（如\"key-value键值对\"与\"键值对\"），且存在已建立的标准化表述时触发；当同一术语在上下文出现两种及以上变体表达（完整形式vs缩略形式）时触发。"
    },
    {
      "defect_id": 405639,
      "sentence": "当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。",
      "reference_sentence": "当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。",
      "line_num": 132,
      "context": "{\"127\":\"\",\"128\":\"初始默认容量为8，每次扩容为原始容量的2倍。\",\"129\":\"\",\"130\":\"LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。\",\"131\":\"\",\"132\":\"当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。\",\"133\":\"\",\"134\":\"LightWeightMap支持增、删、改、查操作，常用API如下：\",\"135\":\"\",\"136\":\"| 操作 | 方法 | 描述 |\",\"137\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "前文使用了“存储具有关联关系的key-value键值对集合”，而这里使用了“存取key-value键值对”，用词不一致",
      "更改后示例": "当需要存储具有关联关系的key-value键值对集合时，推荐使用占用内存更小的LightWeightMap。",
      "触发条件": "同一上下文或相邻段落中对同一操作或概念使用了不一致的动词（如“存储”与“存取”），或关键术语（如“集合”缺失）未保持统一表达时触发。\n\n识别模式：\n1. **动词一致性检测**：当句子中描述同类操作（如数据操作）的动词与前文定义或相邻参考句存在差异时（如“存储”vs“存取”）。\n2. **术语完整性匹配**：若前文明确包含特定限定词（如“具有关联关系的...集合”），后文省略关键描述成分（如缺少“集合”），则判定为不一致。"
    },
    {
      "defect_id": 405664,
      "sentence": "初始默认容量大小为16，每次扩容大小为原始容量的2倍。",
      "reference_sentence": "初始默认容量为8，每次扩容为原始容量的2倍。",
      "line_num": 187,
      "context": "{\"182\":\"\",\"183\":\"## PlainArray\",\"184\":\"\",\"185\":\"[PlainArray](../reference/apis-arkts/js-apis-plainarray.md)可用来存储具有关联关系的键值对集合，存储元素中key是唯一的，并且对于PlainArray来说，其key的类型为number类型。每个key会对应一个value值，类型依据泛型的定义，PlainArray采用更加轻量级的结构，集合中的key值的查找依赖于二分查找算法，然后映射到其他数组中的value值。\",\"186\":\"\",\"187\":\"初始默认容量大小为16，每次扩容大小为原始容量的2倍。\",\"188\":\"\",\"189\":\"PlainArray和[LightWeightMap](../reference/apis-arkts/js-apis-lightweightmap.md)都是用来存储键值对，且均采用轻量级结构，但PlainArray的key值类型仅限于number。\",\"190\":\"\",\"191\":\"当需要存储key值为number类型的键值对时，可以使用PlainArray。\",\"192\":\"\"}",
      "修改建议": "混用了'容量'和'容量大小'，同一概念应使用同一词汇",
      "更改后示例": "初始默认容量为16，每次扩容为原始容量的2倍。",
      "触发条件": "同一概念在相邻或相近上下文中出现不同词汇表达（如\"容量\"与\"容量大小\"混用），且存在可替换的规范术语（如参考句中的\"容量\"）。  \n\n识别模式：  \n1. 检测同一段落内对同一技术属性的描述存在冗余修饰词（如\"大小\"）与核心术语（如\"容量\"）交替使用  \n2. 对比上下文术语使用模式（如问题句中的\"容量大小\"与参考句/其他段落的\"容量\"形成冲突）"
    },
    {
      "defect_id": 405633,
      "sentence": "可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。",
      "reference_sentence": "需要不重复的集合或需要去重某个集合时可以使用。",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\",\"52\":\"HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"53\":\"\",\"54\":\"可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合的时候使用。\",\"55\":\"\",\"56\":\"HashSet支持增、删、改、查操作，常用API如下：\",\"57\":\"\",\"58\":\"| 操作 | 方法 | 描述 |\",\"59\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "描述风格不一致，应使用一致的描述风格",
      "更改后示例": "可以利用HashSet不重复的特性，当需要不重复的集合或需要去重某个集合时使用。",
      "触发条件": "同一句子或相邻上下文中出现时间状语结构不一致（如\"时\"与\"的时候\"混用）导致表达风格冲突，或相同语法位置使用不同助词（如\"的\"冗余）造成句式不对称。"
    },
    {
      "defect_id": 408127,
      "sentence": "完成对象图遍历后，擦除不可达对象内容，并将其放入空闲队列，以便下次对象分配。",
      "reference_sentence": "完成对象图遍历后，擦除不可达对象内容，并将其放入空闲队列，以便下次对象分配。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"#### 标记-清扫回收\",\"53\":\"\",\"54\":\"![image](./figures/mark-clearn.png)\",\"55\":\"  \",\"56\":\"完成对象图遍历后，擦除不可达对象内容，并将其放入空闲队列，以便下次对象分配。  \",\"57\":\"该回收方式不搬移对象，因此效率高。但因回收对象内存地址不连续，会导致内存碎片化，降低分配效率。极端情况下，即使有大量空闲内存，也可能无法放入较大的对象。  \",\"58\":\"\",\"59\":\"#### 标记-复制回收\",\"60\":\"\",\"61\":\"![image](./figures/mark-copy.png)\"}",
      "修改建议": "原文中使用了'擦除'，但根据规则，建议使用'删除'以保持一致性。",
      "更改后示例": "完成对象图遍历后，删除不可达对象内容，并将其放入空闲队列，以便下次对象分配。",
      "触发条件": "当同一文档中多个同义术语（如“擦除”与“删除”）被交替使用，且存在已确立的统一目标词汇（如“删除”）时触发。\n\n识别模式：\n1. **同义词冲突检测**：通过NLP识别描述同一操作的不同动词（如擦除/删除/清除）\n2. **上下文锚点匹配**：在相邻段落或相同技术模块中（如标记-清扫回收章节）存在目标术语的既定用法（如其他句子已使用\"删除\"）\n3. **功能一致性验证**：确保替换后的术语（如\"删除\"）在技术语义层面与原词（\"擦除\"）完全等价，不会产生歧义"
    },
    {
      "defect_id": 408129,
      "sentence": "完成对象图遍历后，将可达对象（蓝色）往本区域（或指定区域）的头部空闲位置复制，然后将已经完成复制的对象回收整理到空闲队列中。",
      "reference_sentence": "完成对象图遍历后，将可达对象（蓝色）往本区域（或指定区域）的头部空闲位置复制，然后将已经完成复制的对象回收整理到空闲队列中。",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"#### 标记-整理回收\",\"67\":\"\",\"68\":\"![image](./figures/mark-shuffle.png)\",\"69\":\"\",\"70\":\"完成对象图遍历后，将可达对象（蓝色）往本区域（或指定区域）的头部空闲位置复制，然后将已经完成复制的对象回收整理到空闲队列中。  \",\"71\":\"这种回收方式既解决了“标记-清扫回收”导致的大量内存碎片问题，同时避免了“标记-复制回收”浪费一半内存空间的缺点，但性能开销比“标记-复制回收”高。  \",\"72\":\"### HPP GC\",\"73\":\"\",\"74\":\"HPP GC（High Performance Partial Garbage Collection），即高性能部分垃圾回收，其中“High Performance”主要体现在三方面，分代模型、混合算法和GC流程优化。在算法方面，HPP GC会根据不同对象区域、采取不同的回收方式。\",\"75\":\"\"}",
      "修改建议": "原文中使用了'回收整理'，但根据规则，建议使用'整理回收'以保持一致性。",
      "更改后示例": "完成对象图遍历后，将可达对象（蓝色）往本区域（或指定区域）的头部空闲位置复制，然后将已经完成复制的对象整理回收到空闲队列中。",
      "触发条件": "当相邻动词/名词顺序与上下文既定术语或标准表述顺序不一致时触发，特别是当存在明确的规则定义或前后文已建立固定搭配模式时。\n\n识别模式：检查术语组合是否违反章节标题（如\"标记-整理回收\"）、领域规范（如GC算法命名惯例）或同一文档中已确立的表述顺序（如\"整理回收\"在前文被定义为标准流程）。"
    },
    {
      "defect_id": 405666,
      "sentence": "LightWeightSet底层通过hash实现唯一value的标识，冲突策略采用线性探测法，查找策略基于二分查找法。",
      "reference_sentence": "LightWeightMap依据泛型定义，采用更加轻量级的结构，底层通过hash实现唯一key，冲突策略为线性探测。",
      "line_num": 161,
      "context": "{\"156\":\"\",\"157\":\"[LightWeightSet](../reference/apis-arkts/js-apis-lightweightset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"158\":\"\",\"159\":\"LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量大小为8，每次扩容大小为原始容量的2倍。集合中的value值的查找依赖于hash以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准。\",\"160\":\"\",\"161\":\"LightWeightSet底层通过hash实现唯一value的标识，冲突策略采用线性探测法，查找策略基于二分查找法。\",\"162\":\"\",\"163\":\"LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值的集合，LightWeightSet占用内存更小。\",\"164\":\"\",\"165\":\"当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。\",\"166\":\"\"}",
      "修改建议": "混用了'标识'和'实现唯一key'，同一概念应使用同一词汇",
      "更改后示例": "LightWeightSet底层通过hash实现唯一value，冲突策略采用线性探测法，查找策略基于二分查找法。",
      "触发条件": "同一技术概念在相邻/相同上下文中出现术语混用（如\"实现唯一value的标识\"与参考句\"实现唯一key\"），或同一功能描述存在冗余词汇差异（如\"标识\"与无标识表述）。"
    },
    {
      "defect_id": 408163,
      "sentence": "根据设定的区域存活对象大小阀值，将满足条件的区域纳入初步的CSet队列，并根据存活率进行从低到高的排序（注：存活率=存活对象大小/区域大小）。",
      "reference_sentence": "根据设定的释放区域个数阈值，选出最终的CSet队列，进行整理回收。",
      "line_num": 95,
      "context": "{\"90\":\"- 部分整理+部分清扫\",\"91\":\"根据老年代对象的特点，引入启发式Collection Set（简称CSet）选择算法。此选择算法的基本原理是：在标记阶段对每个区域的存活对象进行大小统计，然后在回收阶段优先选出存活对象少、回收代价小的区域进行对象整理回收，再对剩下的区域进行清扫回收。\",\"92\":\"\",\"93\":\"回收策略如下：\",\"94\":\"\",\"95\":\"- 根据设定的区域存活对象大小阈值，将满足条件的区域纳入初步的CSet队列，并根据存活率进行从低到高的排序（注：存活率=存活对象大小/区域大小）。\",\"96\":\"\",\"97\":\"- 根据设定的释放区域个数阈值，选出最终的CSet队列，进行整理回收。\",\"98\":\"\",\"99\":\"- 对未被选入CSet队列的区域进行清扫回收。\",\"100\":\"\"}",
      "修改建议": "“阀值”和“阈值”混用，应使用统一的术语。",
      "更改后示例": "根据设定的区域存活对象大小阈值，将满足条件的区域纳入初步的CSet队列，并根据存活率进行从低到高的排序（注：存活率=存活对象大小/区域大小）。",
      "触发条件": "文档中存在同义术语变体（如\"阀值\"与\"阈值\"）混用，且上下文已确立统一术语（如参考句和问题上下文中均使用\"阈值\"）时触发。\n\n识别模式：\n1. 检测近音/形似术语（如\"阀值-阈值\"）在文档中的共存\n2. 验证上下文存在已确立的标准术语（通过参考句和相邻段落验证）\n3. 对比当前术语与上下文高频使用术语的一致性（如第95/97行均使用\"阈值\"）"
    },
    {
      "defect_id": 408164,
      "sentence": "根据设定的释放区域个数阀值，选出最终的CSet队列，进行整理回收。",
      "reference_sentence": "根据设定的释放区域个数阈值，选出最终的CSet队列，进行整理回收。",
      "line_num": 97,
      "context": "{\"92\":\"\",\"93\":\"回收策略如下：\",\"94\":\"\",\"95\":\"- 根据设定的区域存活对象大小阈值，将满足条件的区域纳入初步的CSet队列，并根据存活率进行从低到高的排序（注：存活率=存活对象大小/区域大小）。\",\"96\":\"\",\"97\":\"- 根据设定的释放区域个数阈值，选出最终的CSet队列，进行整理回收。\",\"98\":\"\",\"99\":\"- 对未被选入CSet队列的区域进行清扫回收。\",\"100\":\"\",\"101\":\"启发式CSet选择算法结合了“标记-整理回收”和“标记-清扫回收”算法的优点，避免了内存碎片问题，同时提升了性能。\",\"102\":\"\"}",
      "修改建议": "“阀值”和“阈值”混用，应使用统一的术语。",
      "更改后示例": "根据设定的释放区域个数阈值，选出最终的CSet队列，进行整理回收。",
      "触发条件": "同一技术术语在文档中存在多种拼写变体（如“阀值”与“阈值”），且上下文已确立标准术语（如参考句及相邻条目均使用“阈值”）时触发。\n\n识别模式：通过术语交叉比对发现非常用词汇（如“阀值”为低频词），结合上下文同概念表述（如相邻条目重复出现“阈值”）判定为术语不一致，需对齐至高频/标准形式。"
    },
    {
      "defect_id": 408128,
      "sentence": "这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。",
      "reference_sentence": "这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。",
      "line_num": 64,
      "context": "{\"59\":\"#### 标记-复制回收\",\"60\":\"\",\"61\":\"![image](./figures/mark-copy.png)\",\"62\":\"\",\"63\":\"遍历对象图时，将可达对象复制到新内存空间。遍历完成后，一次回收旧内存空间。  \",\"64\":\"这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。  \",\"65\":\"\",\"66\":\"#### 标记-整理回收\",\"67\":\"\",\"68\":\"![image](./figures/mark-shuffle.png)\",\"69\":\"\"}",
      "修改建议": "原文中使用了'拷贝'，但根据规则，建议使用'复制'以保持一致性。",
      "更改后示例": "这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被复制，导致空间利用率较低。",
      "触发条件": "当同一术语在文档中存在多种中文译名（如\"拷贝\"与\"复制\"）且上下文已建立规范用词时，或当规则明确定义了特定术语的优先用词（如强制要求使用\"复制\"）时。\n\n识别模式：\n1. 检测同段落/相邻段落中是否存在相同概念的不同表达形式\n2. 比对参考上下文（如问题上下文第63行已使用\"复制\"）\n3. 匹配预设术语表（如有明确规则定义\"复制\"为规范用词）"
    },
    {
      "defect_id": 405663,
      "sentence": "LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值的集合，LightWeightSet占用内存更小。",
      "reference_sentence": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。",
      "line_num": 163,
      "context": "{\"158\":\"\",\"159\":\"LightWeightSet依据泛型定义，采用更加轻量级的结构，初始默认容量大小为8，每次扩容大小为原始容量的2倍。集合中的value值的查找依赖于hash以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的value值，value的类型满足ECMA标准。\",\"160\":\"\",\"161\":\"LightWeightSet底层通过hash实现唯一value的标识，冲突策略采用线性探测法，查找策略基于二分查找法。\",\"162\":\"\",\"163\":\"LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值的集合，LightWeightSet占用内存更小。\",\"164\":\"\",\"165\":\"当需要存取某个集合或是对某个集合去重时，推荐使用占用内存更小的LightWeightSet。\",\"166\":\"\",\"167\":\"LightWeightSet支持增、删、改、查操作，常用API如下：\",\"168\":\"\"}",
      "修改建议": "混用了'键值'和'键值对'，同一概念应使用同一词汇",
      "更改后示例": "LightWeightSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)都是用来存储键值对的集合，LightWeightSet占用内存更小。",
      "触发条件": "同一概念在相邻或相关段落中出现术语混用（如\"键值\"与\"键值对\"），且存在已定义的参考表达模式（如参考句中的\"键值对\"）。\n\n识别模式：\n1. 通过对比相邻段落或同类API描述句式（如LightWeightMap与LightWeightSet的平行结构），检测同一语义概念是否使用不同词汇\n2. 当检测到术语差异（如\"键值\" vs \"键值对\"）且上下文存在明确参考基准（如参考句中的规范表达）时，触发一致性校验"
    },
    {
      "defect_id": 405628,
      "sentence": "HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "reference_sentence": "HashMap依据泛型定义，集合中通过键的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\",\"21\":\"\",\"22\":\"HashMap依据泛型定义，集合中通过key的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。\",\"23\":\"\",\"24\":\"HashMap和[TreeMap](../reference/apis-arkts/js-apis-treemap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"25\":\"\",\"26\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)基于HashMap实现。HashMap的输入参数由key、value两个值组成。在HashSet中，只处理value对象。\",\"27\":\"\"}",
      "修改建议": "混用了“key”和“键”",
      "更改后示例": "HashMap依据泛型定义，集合中通过键的hash值确定其存储位置，从而快速找到键值对。HashMap的初始容量大小为16，并支持动态扩容，每次扩容为原始容量的2倍。HashMap底层基于HashTable实现，冲突策略采用链地址法。",
      "触发条件": "同一术语在相邻或同一主题内容中存在中英文混用（如\"key\"与\"键\"交替出现），且上下文存在明确的术语统一用法（如参考句已使用\"键\"或前文已建立中文术语规范）。\n\n识别模式：通过对比当前句子与上下文术语使用习惯（如问题上下文第20/24行已使用\"键\"），检测同一概念出现中英文两种表达形式（如\"key的hash值\"与\"键的hashCode\"共存），且无特殊强调需求时触发规则。"
    },
    {
      "defect_id": 405636,
      "sentence": "TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。",
      "reference_sentence": "TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。",
      "line_num": 103,
      "context": "{\"98\":\"\",\"99\":\"[TreeSet](../reference/apis-arkts/js-apis-treeset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"100\":\"\",\"101\":\"TreeSet依据泛型定义，值是有序存储的，底层基于红黑树实现，支持快速的插入和删除。value的类型满足ECMA标准。\",\"102\":\"\",\"103\":\"TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。\",\"104\":\"\",\"105\":\"TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。两者集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"106\":\"\",\"107\":\"一般需要存储有序集合的场景，可以使用TreeSet。\",\"108\":\"\"}",
      "修改建议": "前半句和后半句内容重复，且后半句中“用于存储值的集合”与前文中的“存储一系列值的集合”用词不一致",
      "更改后示例": "TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象，用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。",
      "触发条件": "同一段落或相邻上下文中存在重复的说明性内容，或对同一概念（如集合存储行为）使用了不一致的术语表述（如“存储值的集合”与“存储一系列值的集合”）。\n\n识别模式：\n1. **冗余重复检测**：通过语义相似度分析识别相邻句子/段落是否重复描述同一功能（如案例中第99行与第103行均描述集合存储特性）\n2. **术语一致性校验**：建立领域术语表（如\"存储值的集合\"），当同一概念出现不同表述（如\"存储一系列值的集合\"）时触发警告\n3. **上下文关联分析**：结合前文已明确说明的特性（如唯一性、排序机制），检测后续是否出现冗余补充说明"
    },
    {
      "defect_id": 405632,
      "sentence": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。",
      "reference_sentence": "HashMap可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的。",
      "line_num": 48,
      "context": "{\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\",\"47\":\"\",\"48\":\"[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中value是唯一的。\",\"49\":\"\",\"50\":\"HashSet依据泛型定义，集合中通过value的hash值确定其存储位置，从而快速找到该值。HashSet初始容量大小为16，支持动态扩容，每次扩容为原始容量的2倍。value的类型满足ECMA标准中要求的类型。HashSet基于[HashMap](../reference/apis-arkts/js-apis-hashmap.md)实现，只对value对象进行处理。底层数据结构与HashMap一致。\",\"51\":\"\",\"52\":\"HashSet和[TreeSet](../reference/apis-arkts/js-apis-treeset.md)相比，HashSet中的数据无序存放，不支持用户指定排序方式，而TreeSet中的数据有序存放，支持用户通过排序函数对元素进行排序。它们集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"53\":\"\"}",
      "修改建议": "混用了`value`和`key`概念",
      "更改后示例": "[HashSet](../reference/apis-arkts/js-apis-hashset.md)可用来存储一系列值的集合，存储元素中值是唯一的。",
      "触发条件": "当同一数据结构文档中混用中英文术语（如\"value\"与\"值\"）且存在关联数据结构（如HashMap/HashSet）的交叉术语干扰时触发。\n\n识别模式：\n1. 检测到技术名词存在中英文混用（如\"value\"未翻译为\"值\"）\n2. 上下文存在关联数据结构术语映射（如HashMap的key-value定义）\n3. 通过语义分析确认术语冲突（如HashSet本应使用纯值存储，却错误引入key-value概念）"
    },
    {
      "defect_id": 408165,
      "sentence": "HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清扫（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。",
      "reference_sentence": "HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清扫（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"启发式CSet选择算法结合了“标记-整理回收”和“标记-清扫回收”算法的优点，避免了内存碎片问题，同时提升了性能。\",\"102\":\"\",\"103\":\"#### 流程优化\",\"104\":\"\",\"105\":\"HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清扫（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。\",\"106\":\"\",\"107\":\"## Heap结构及其配置参数\",\"108\":\"\",\"109\":\"### Heap结构\",\"110\":\"\"}",
      "修改建议": "“清扫”和“清理”混用，应使用统一的术语。",
      "更改后示例": "HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清理（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。",
      "触发条件": "同一技术术语在相邻段落或上下文出现两种及以上中文译法（如\"清扫\"与\"清理\"），且参考句已建立明确术语对应关系（如\"Sweep=清扫\"）。"
    },
    {
      "defect_id": 408170,
      "sentence": "切换后台后主动触发一次Full GC。",
      "reference_sentence": "应用切换到后台场景之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC。DumpHeapSnapshot 和 AllocationTracker 工具默认会触发Full GC。Native 接口和ArkTS 也有接口可以触发。",
      "line_num": 242,
      "context": "{\"237\":\"- 说明：影响是否进行全量mark，以及是否开始并发mark。\",\"238\":\"\",\"239\":\"#### 切换后台触发GC\",\"240\":\"\",\"241\":\"- 函数方法：`ChangeGCParams`\",\"242\":\"- 说明：切换后台后主动触发一次Full GC。\",\"243\":\"- 典型日志：`app is inBackground` 和 `app is not inBackground`。\",\"244\":\"  GC 日志中可区分GCReason::SWITCH_BACKGROUND。\",\"245\":\"\",\"246\":\"### 执行策略\",\"247\":\"\"}",
      "修改建议": "混用了'后台'和'后台场景'，应统一为'后台场景'。",
      "更改后示例": "切换到后台场景后主动触发一次Full GC。",
      "触发条件": "同一文档中同一概念存在多个术语变体（如“后台”和“后台场景”），且上下文或参考句已明确定义统一术语（如“后台场景”）时触发。\n\n识别模式：通过对比相邻段落、参考句及术语定义，检测关键名词是否出现未统一缩略/扩展形式（如\"后台\"应匹配上下文高频使用的\"后台场景\"），且存在明确统一目标术语的语境支撑。"
    },
    {
      "defect_id": 408166,
      "sentence": "heap中生成两个Semi Space供copying使用。",
      "reference_sentence": "heap中生成两个Semi Space供copying使用。",
      "line_num": 148,
      "context": "{\"143\":\"| 参数名 | 范围 | 作用 |\",\"144\":\"| --- | --- | --- |\",\"145\":\"| HeapSize  | 768 MB | worker类型线程堆空间大小。 |\",\"146\":\"\",\"147\":\"#### Semi Space\",\"148\":\"heap中生成两个Semi Space供copying使用。\",\"149\":\"| 参数名 | 范围 | 作用 |\",\"150\":\"| --- | --- | --- |\",\"151\":\"| semiSpaceSize | 2MB-4MB/2MB-8MB/2MB-16MB | SemiSpace空间大小，会根据堆总大小有不同的范围限制。 |\",\"152\":\"| semiSpaceTriggerConcurrentMark | 1M/1.5M/1.5M| 首次单独触发Semi Space的并发mark的界限值，超过该值则触发。 |\",\"153\":\"| semiSpaceStepOvershootSize| 2MB | 允许过冲最大大小。 |\"}",
      "修改建议": "“Semi Space”和“SemiSpace”混用，应使用统一的术语。",
      "更改后示例": "heap中生成两个SemiSpace供copying使用。",
      "触发条件": "同一术语在文档中多次出现时存在拼写或格式不一致（如空格、连字符等），且上下文存在已确定的统一用法参考（如参数名、标题等）。\n\n识别模式：通过对比术语在文档中的不同变体（如\"Semi Space\"与\"SemiSpace\"），并检查其与上下文参数名（如\"semiSpaceSize\"）、标题（如\"#### Semi Space\"）或其他明确用法的一致性，判定需修复为统一形式。"
    },
    {
      "defect_id": 405918,
      "sentence": "需要通过`napi_destroy_ark_runtime`来销毁所创建的ArkTS基础运行时环境",
      "reference_sentence": "需要通过`napi_destroy_ark_runtime`来销毁所创建的ArkTS运行时环境",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口创建ArkTS运行时环境\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"开发者通过pthread_create创建新线程后，可以通过`napi_create_ark_runtime`来创建一个新的ArkTS基础运行时环境，并通过该运行时环境加载ArkTS模块。当使用结束后，开发者需要通过`napi_destroy_ark_runtime`来销毁所创建的ArkTS基础运行时环境。\",\"6\":\"\",\"7\":\"## 约束限制\",\"8\":\"\",\"9\":\"一个进程最多只能创建64个运行时环境。\",\"10\":\"\"}",
      "修改建议": "混用了“基础运行时环境”和“运行时环境”",
      "更改后示例": "需要通过`napi_destroy_ark_runtime`来销毁所创建的ArkTS运行时环境",
      "触发条件": "当同一技术术语在文档中出现多个变体表述（如\"ArkTS运行时环境\"与\"ArkTS基础运行时环境\"），且上下文未明确说明需要区分不同层级/类型的运行时环境时触发。\n\n识别模式：\n1. 核心术语匹配：识别包含相同核心词（如\"运行时环境\"）但修饰词不一致（如\"基础\"）的术语变体\n2. 上下文验证：检查问题术语所在段落是否已存在标准表述（如参考句中的\"ArkTS运行时环境\"），且未出现需要区分特殊场景的说明性内容"
    },
    {
      "defect_id": 408168,
      "sentence": "#### 其他空间",
      "reference_sentence": "#### 其他参数",
      "line_num": 187,
      "context": "{\"182\":\"| MIN_TASKPOOL_THREAD_NUM | 3 | 线程池最小线程数。 |\",\"183\":\"| MAX_TASKPOOL_THREAD_NUM | 7 | 线程池最大线程数。 |\",\"184\":\"\",\"185\":\"注：该线程池主要用于执行GC流程中的并发任务。线程池初始化时，会综合参考gcThreadNum和线程数的上下限。如果gcThreadNum为负值，线程池的线程数将初始化为CPU核心数的一半。\",\"186\":\"\",\"187\":\"#### 其他参数\",\"188\":\"\",\"189\":\"| 参数名 | 值 | 作用 |\",\"190\":\"| --- | --- | --- |\",\"191\":\"| minAllocLimitGrowingStep | 2M/4M/8M | heap整体重新计算空间大小限制时，控制oldSpace、heapObject和globalNative的最小增长步长。 |\",\"192\":\"| minGrowingStep | 4M/8M/16M | 调整oldSpace的最小增长步长。 |\"}",
      "修改建议": "使用了不同的词汇描述同一概念，应统一为'参数'。",
      "更改后示例": "#### 其他参数",
      "触发条件": "同一章节或相邻上下文中存在描述同一概念的不同术语（如\"空间\"与\"参数\"），且上下文已存在明确统一用法的参考实例（如\"参数名\"表头及\"其他参数\"同级标题）。"
    },
    {
      "defect_id": 408700,
      "sentence": "加载远程HAR模块名",
      "reference_sentence": "加载远程HAR模块名",
      "line_num": 35,
      "context": "{\"30\":\"| 系统模块        |    加载@ohos.*或 @system.*  | -                            |\",\"31\":\"| 本地工程模块   | 加载ets目录下文件中的模块      | 要求路径以ets开头             |\",\"32\":\"| 本地工程模块   | 加载模块内文件路径       | 要求路径以moduleName开头             |\",\"33\":\"| 本地工程模块   | 加载HAR模块名           | -                            |\",\"34\":\"| 本地工程模块   | 加载HSP模块名           | -                            |\",\"35\":\"| 远程包         | 加载远程HAR模块名        | -                            |\",\"36\":\"| 远程包         | 加载ohpm包名            | -                            |\",\"37\":\"| 模块Native库   | 加载libNativeLibrary.so | -                            |\",\"38\":\"\",\"39\":\"- **加载系统模块**\",\"40\":\"\"}",
      "修改建议": "混用了“模块名”和“模块名称”",
      "更改后示例": "加载远程HAR模块名称",
      "触发条件": "当同一文档中同一术语存在\"全称\"与\"缩略形式\"混用（如\"模块名称\"与\"模块名\"），且相邻上下文存在相同语义表达时触发。识别模式为检测到同一技术概念在相邻条目/段落中出现\"名\"与\"名称\"等近义词交替使用。"
    },
    {
      "defect_id": 405917,
      "sentence": "可以通过`napi_create_ark_runtime`来创建一个新的ArkTS基础运行时环境",
      "reference_sentence": "可以通过`napi_create_ark_runtime`来创建一个新的ArkTS运行时环境",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口创建ArkTS运行时环境\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"开发者通过pthread_create创建新线程后，可以通过`napi_create_ark_runtime`来创建一个新的ArkTS基础运行时环境，并通过该运行时环境加载ArkTS模块。当使用结束后，开发者需要通过`napi_destroy_ark_runtime`来销毁所创建的ArkTS基础运行时环境。\",\"6\":\"\",\"7\":\"## 约束限制\",\"8\":\"\",\"9\":\"一个进程最多只能创建64个运行时环境。\",\"10\":\"\"}",
      "修改建议": "混用了“基础运行时环境”和“运行时环境”",
      "更改后示例": "可以通过`napi_create_ark_runtime`来创建一个新的ArkTS运行时环境",
      "触发条件": "同一文档上下文中，同一技术概念出现多个不一致的术语变体（如\"运行时环境\"与\"基础运行时环境\"），且无明确语义差异说明时触发。识别模式：检测同一名词短语是否在相邻段落/功能描述中存在冗余修饰词（如\"基础\"）增减或缩写扩展的不匹配现象。"
    },
    {
      "defect_id": 408169,
      "sentence": "应用切换后台之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC。DumpHeapSnapshot 和 AllocationTracker 工具默认会触发Full GC。Native 接口和ArkTS 也有接口可以触发。",
      "reference_sentence": "切换后台后主动触发一次Full GC。",
      "line_num": 217,
      "context": "{\"212\":\"- **场景**：前台场景。\",\"213\":\"- **日志关键词**：`[ HPP OldGC ]`\",\"214\":\"\",\"215\":\"#### Full GC\",\"216\":\"\",\"217\":\"- **触发机制**：不会由内存阈值触发。应用切换后台之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC。DumpHeapSnapshot 和 AllocationTracker 工具默认会触发Full GC。Native 接口和ArkTS 也有接口可以触发。\",\"218\":\"- **说明**：会对年轻代和老年代做全量压缩，主要用于性能不敏感场景，最大限度回收内存空间。\",\"219\":\"- **场景**：后台场景。\",\"220\":\"- **日志关键词**：`[ CompressGC ]`\",\"221\":\"\",\"222\":\"此后的Smart GC或IDLE GC都会从上述三种GC中选择。\"}",
      "修改建议": "混用了'后台'和'后台场景'，应统一为'后台场景'。",
      "更改后示例": "应用切换到后台场景之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC。DumpHeapSnapshot 和 AllocationTracker 工具默认会触发Full GC。Native 接口和ArkTS 也有接口可以触发。",
      "触发条件": "当同一术语在相邻上下文或同一文档中存在多种变体表达（如\"后台\"和\"后台场景\"），且该术语在文档其他部分已有明确统一用法（如参考句中的\"后台\"和问题上下文中的\"后台场景\"）时触发。\n\n识别模式：\n1. 检查同一概念是否在相邻条目/段落中出现不同缩略表达（如核心词缺失/冗余）\n2. 对比文档中已建立的术语标准（如问题上下文中第219行明确使用\"后台场景\"作为标准术语）\n3. 发现同一语义单元存在词形变化（如动词短语\"切换后台\"与名词短语\"后台场景\"的表述差异）"
    },
    {
      "defect_id": 408693,
      "sentence": "Node-API中的napi_load_module接口的功能是在主线程中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数。",
      "reference_sentence": "Node-API中的napi_load_module接口的功能是在主线程中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_named_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口在主线程中进行模块加载\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"Node-API中的napi_load_module接口的功能是在主线程中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数。\",\"6\":\"\",\"7\":\"## 函数说明\",\"8\":\"\",\"9\":\"```cpp\",\"10\":\"napi_status napi_load_module(napi_env env, const char* path, napi_value* result);\"}",
      "修改建议": "混用了`napi_get_property`和`napi_get_named_property`，两者功能相似，建议统一使用`napi_get_named_property`",
      "更改后示例": "Node-API中的napi_load_module接口的功能是在主线程中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_named_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数。",
      "触发条件": "同一上下文中出现功能相似的多个API接口名称交替使用，且未保持术语统一性。\n\n识别模式：当检测到相邻语句或同一功能描述中，存在两个及以上功能相近但命名不同的技术术语（如`napi_get_property`和`napi_get_named_property`）被交替使用时，应触发该规则。需通过对比上下文中的API命名模式，识别出非必要的术语混用现象。"
    },
    {
      "defect_id": 408694,
      "sentence": "建议使用[napi_load_module_with_info](use-napi-load-module-with-info.md)来进行模块加载，该接口支持了更多的场景。",
      "reference_sentence": "建议使用[napi_load_module_with_info](use-napi-load-module-with-info.md)来进行模块加载，该接口支持了更多场景。",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"- 禁止在非主线程当中使用该接口。\",\"22\":\"- 禁止在Init函数中使用该接口。\",\"23\":\"- 禁止在线程安全函数的回调函数当中进行文件路径的加载。\",\"24\":\"\",\"25\":\"建议使用[napi_load_module_with_info](use-napi-load-module-with-info.md)来进行模块加载，该接口支持了更多的场景。\",\"26\":\"\",\"27\":\"## napi_load_module支持的场景\",\"28\":\"| 场景            | 详细分类           | 说明                         |\",\"29\":\"| :------------- | :----------------------------- | :--------------------------- |\",\"30\":\"| 系统模块        |    加载@ohos.*或 @system.*  | -                            |\"}",
      "修改建议": "混用了“更多的场景”和“更多场景”",
      "更改后示例": "建议使用[napi_load_module_with_info](use-napi-load-module-with-info.md)来进行模块加载，该接口支持了更多场景。",
      "触发条件": "当同一名词短语在文档中同时存在\"数量词+的+名词\"（如\"更多的场景\"）和\"数量词+名词\"（如\"更多场景\"）两种结构时，应触发语言表达一致性规则。\n\n识别模式：通过对比文档中相同语义的修饰结构，检测是否存在\"的\"字冗余/缺失的情况，重点关注\"更多/较多/许多\"等数量词与核心名词的组合结构是否保持统一。"
    },
    {
      "defect_id": 405919,
      "sentence": "1. 创建基础运行环境",
      "reference_sentence": "1. 创建运行环境",
      "line_num": 93,
      "context": "{\"88\":\"   #include <pthread.h>\",\"89\":\"   #include \\\"napi/native_api.h\\\"\",\"90\":\"\",\"91\":\"   static void *CreateArkRuntimeFunc(void *arg)\",\"92\":\"   {\",\"93\":\"       // 1. 创建基础运行环境\",\"94\":\"       napi_env env;\",\"95\":\"       napi_status ret = napi_create_ark_runtime(&env);\",\"96\":\"       if (ret != napi_ok) {\",\"97\":\"           return nullptr;\",\"98\":\"       }\"}",
      "修改建议": "混用了“基础运行环境”和“运行环境”",
      "更改后示例": "1. 创建运行环境",
      "触发条件": "同一术语在相邻或相关上下文中存在冗余修饰词（如“基础”）的不一致表述，且已有标准化术语（如“运行环境”）作为参考依据。"
    },
    {
      "defect_id": 405920,
      "sentence": "4. 销毁ArkTS环境",
      "reference_sentence": "4. 销毁ArkTS运行时环境",
      "line_num": 115,
      "context": "{\"110\":\"       if (ret != napi_ok) {\",\"111\":\"           return nullptr;\",\"112\":\"       }\",\"113\":\"       ret = napi_call_function(env, objUtils, logger, 0, nullptr, nullptr);\",\"114\":\"\",\"115\":\"       // 4. 销毁ArkTS环境\",\"116\":\"       ret = napi_destroy_ark_runtime(&env);\",\"117\":\"       return nullptr;\",\"118\":\"   }\",\"119\":\"\",\"120\":\"   static napi_value CreateArkRuntime(napi_env env, napi_callback_info info)\"}",
      "修改建议": "混用了“环境”和“运行时环境”",
      "更改后示例": "4. 销毁ArkTS运行时环境",
      "触发条件": "同一术语在相邻或相关条目中存在不一致的表达形式（如“环境”与“运行时环境”），或与代码上下文中的技术术语（如`napi_destroy_ark_runtime`隐含的“运行时”）存在显性矛盾时触发。\n\n识别模式：通过对比步骤标题/描述中的核心术语（如“环境”）与参考规范、代码注释或相邻条目中的对应术语（如“运行时环境”），检测是否违反单一表达原则。"
    },
    {
      "defect_id": 408188,
      "sentence": "- SharedOldSpace：共享老年代空间（这里并不区分年轻代老年代），存放一般的共享对象。",
      "reference_sentence": "#### Young GC- **触发机制**：年轻代GC触发阈值在2MB-16MB变化，根据分配速度和存活率等会变化。",
      "line_num": 287,
      "context": "{\"282\":\"\",\"283\":\"### SharedHeap结构\",\"284\":\"\",\"285\":\"![image](./figures/gc-shared-heap.png)\",\"286\":\"\",\"287\":\"- SharedOldSpace：共享老年代空间（这里并不区分年轻代老年代），存放一般的共享对象。\",\"288\":\"- SharedHugeObjectSpace：共享大对象空间，使用单独的Region存放一个大对象的空间。\",\"289\":\"- SharedReadOnlySpace：共享只读空间，存放运行期间的只读数据。\",\"290\":\"- SharedNonMovableSpace：共享不可移动空间，存放不可移动的对象。\",\"291\":\"\",\"292\":\"注：SharedHeap用于线程间共享对象，提高效率并节省内存。共享堆不单独属于任何线程，保存具有共享价值的对象，提高对象的存活率，去除了SemiSpace类型。\"}",
      "修改建议": "混用了`年轻代`和`老年代`概念",
      "更改后示例": "- SharedOldSpace：共享老年代空间，存放一般的共享对象。",
      "触发条件": "当同一术语或紧密关联的术语（如\"老年代/年轻代\"）在相邻上下文中出现概念混淆或不必要混合使用时，且存在明确区分需求的场景。  \n识别模式：检测到在定义单一概念时（如\"SharedOldSpace\"）出现反向关联术语（如\"年轻代\"）的冗余解释，且参考上下文（如Young GC的独立定义）已明确区分该术语边界。"
    },
    {
      "defect_id": 408185,
      "sentence": "#### new space GC前后的阈值调整",
      "reference_sentence": "#### Young GC- **触发机制**：年轻代GC触发阈值在2MB-16MB变化，根据分配速度和存活率等会变化。",
      "line_num": 254,
      "context": "{\"249\":\"\",\"250\":\"- 函数方法：`TryTriggerConcurrentMarking`\",\"251\":\"- 说明：尝试触发并发mark，将遍历对象进行标记的任务交由线程池中并发运行，减少UI主线程挂起时间。\",\"252\":\"- 典型日志：`fullMarkRequested`，`trigger full mark`，`Trigger the first full mark`，`Trigger full mark`，`Trigger the first semi mark`，`Trigger semi mark`。\",\"253\":\"\",\"254\":\"#### new space GC前后的阈值调整\",\"255\":\"\",\"256\":\"- 函数方法：`AdjustCapacity`\",\"257\":\"- 说明：GC后调整SemiSpace的触发水线，优化空间结构。\",\"258\":\"- 典型日志：无直接日志，可以通过GC统计日志看出，GC前young space的阈值有动态调整。\",\"259\":\"\"}",
      "修改建议": "混用了`new space`和`年轻代`概念",
      "更改后示例": "#### 年轻代GC前后的阈值调整",
      "触发条件": "同一技术概念在文档中使用了多个不同术语（如\"new space\"和\"年轻代\"），且存在已明确定义的标准术语（如参考句中的\"年轻代GC\"）时触发。\n\n识别模式：\n1. 术语冲突检测：在相邻段落/章节中，同一技术组件出现两种及以上不同表述\n2. 标准术语对照：存在明确使用标准术语的参考句（如Young GC对应的中文\"年轻代GC\"）\n3. 概念映射验证：通过上下文确认不同术语指向同一技术实体（如new space=年轻代）"
    },
    {
      "defect_id": 408189,
      "sentence": "若需开启所有GC执行的日志，需使用命令在设备中开启。",
      "reference_sentence": "### 开启全量日志",
      "line_num": 323,
      "context": "{\"318\":\"\",\"319\":\"## 日志解释\",\"320\":\"\",\"321\":\"### 开启全量日志\",\"322\":\"\",\"323\":\"默认情况下，详细的GC日志仅在GC耗时超过40毫秒时才会打印。若需开启所有GC执行的日志，需使用命令在设备中开启。\",\"324\":\"\",\"325\":\"**使用样例：**\",\"326\":\"\",\"327\":\"```shell\",\"328\":\"# 设置开启GC全量日志参数，开启参数为0x905d，关闭GC全量日志，设置为默认值为0x105c\"}",
      "修改建议": "使用了不同的词汇描述同一操作",
      "更改后示例": "若需开启所有GC日志，需使用命令在设备中开启。",
      "触发条件": "同一文档中对同一操作或概念使用了不一致的术语（如\"所有GC执行的日志\" vs \"GC全量日志\"），且在相邻段落/标题中存在标准表达参考（如标题### 开启全量日志）。当检测到同一上下文出现多组同义但表述差异的短语（如\"所有GC...日志\"与\"全量日志\"）时触发规则。"
    },
    {
      "defect_id": 408187,
      "sentence": "#### PartialGC的CSet 选择策略",
      "reference_sentence": "### HPP GC的类型#### Young GC- **触发机制**：年轻代GC触发阈值在2MB-16MB变化，根据分配速度和存活率等会变化。",
      "line_num": 272,
      "context": "{\"267\":\"\",\"268\":\"- 函数方法：`RecomputeLimits`\",\"269\":\"- 说明：根据当前GC统计的数据变化，重新计算并调整`newOldSpaceLimit`、`newGlobalSpaceLimit`、`globalSpaceNativeLimit`和增长因子。\",\"270\":\"- 日志关键词：`RecomputeLimits`。\",\"271\":\"\",\"272\":\"#### PartialGC的CSet 选择策略\",\"273\":\"\",\"274\":\"- 函数方法：`OldSpace::SelectCSet()`\",\"275\":\"- 说明：PartialGC执行时采用该策略，优先选择存活对象数量少、回收代价小的Region进行GC。\",\"276\":\"- 典型日志：\",\"277\":\"    - `Select CSet failure: number is too few`\"}",
      "修改建议": "混用了`PartialGC`和`Old GC`概念",
      "更改后示例": "#### Partial Old GC的CSet 选择策略",
      "触发条件": "当同一技术概念在标题或正文中使用不一致的术语（如缩写与全称混用，或未与上下文关联术语对齐）时触发，例如PartialGC与Old GC未统一，或标题未体现与相关代码/上下文的OldSpace等术语关联。"
    },
    {
      "defect_id": 408412,
      "sentence": "`List`提供了多种方法来操作数据，例如添加、移除和查找元素",
      "reference_sentence": "`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素",
      "line_num": 10,
      "context": "{\"5\":\"arkOptions主要提供ArkTS编译相关配置，当前文档介绍arkOptions中types配置类型、maxFlowDepth配置控制流分析最大栈深度等，arkOptions中的其他配置项请参考[build-profile.json5](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-configuration-file-overview)。\",\"6\":\"\",\"7\":\"## types\",\"8\":\"\",\"9\":\"### types配置文件标签说明\",\"10\":\"\",\"11\":\"  arkOptions的types字段配置文件标签说明：\",\"12\":\"\",\"13\":\"| 属性名称 | 含义 | 配置范围 | 数据类型 | 是否可缺省 |\",\"14\":\"| -------- | -------- | -------- | -------- | -------- |\",\"15\":\"| types | 通过types字段将指定的类型声明文件作为全局引入，从而避免在每个源码文件中单独引入。 | 模块级 | 数组 | 该标签可缺省，缺省值为空。 |\"}",
      "修改建议": "混用了`List`和`ArrayList`概念，且'删除'与'移除'近义词混用",
      "更改后示例": "`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素",
      "触发条件": "同一技术概念使用不同术语（如接口与实现类混用），或同一语义场景下混用近义词（如\"删除/移除\"）而未保持统一。  \n\n识别模式：  \n1. **术语一致性检查**：识别关键名词（如`List`/`ArrayList`）是否与上下文或参考文档中的定义一致，避免抽象接口与具体实现类混淆。  \n2. **近义词冲突检测**：在并列操作描述中（如\"添加、移除、查找\"），检查动词是否与API方法命名（如`add`/`remove`对应\"添加\"/\"删除\"）或文档既定术语一致，排除非必要近义词替换。"
    },
    {
      "defect_id": 408699,
      "sentence": "加载HSP模块名",
      "reference_sentence": "加载HSP模块名",
      "line_num": 34,
      "context": "{\"29\":\"| :------------- | :----------------------------- | :--------------------------- |\",\"30\":\"| 系统模块        |    加载@ohos.*或 @system.*  | -                            |\",\"31\":\"| 本地工程模块   | 加载ets目录下文件中的模块      | 要求路径以ets开头             |\",\"32\":\"| 本地工程模块   | 加载模块内文件路径       | 要求路径以moduleName开头             |\",\"33\":\"| 本地工程模块   | 加载HAR模块名           | -                            |\",\"34\":\"| 本地工程模块   | 加载HSP模块名           | -                            |\",\"35\":\"| 远程包         | 加载远程HAR模块名        | -                            |\",\"36\":\"| 远程包         | 加载ohpm包名            | -                            |\",\"37\":\"| 模块Native库   | 加载libNativeLibrary.so | -                            |\",\"38\":\"\",\"39\":\"- **加载系统模块**\"}",
      "修改建议": "混用了“模块名”和“模块名称”",
      "更改后示例": "加载HSP模块名称",
      "触发条件": "当同一文档中相邻条目或相同语义场景下，出现\"模块名\"与\"模块名称\"等同一概念的不同术语变体（缩略/全称混用）时触发。\n\n识别模式：通过对比上下文表格结构（如第33行\"加载HAR模块名\"与第34行\"加载HSP模块名\"），检测同一语义位置是否出现术语不一致（如其他条目使用\"模块名称\"），并验证术语在文档全局范围的统一性。"
    },
    {
      "defect_id": 408701,
      "sentence": "加载ohpm包名",
      "reference_sentence": "加载ohpm包名",
      "line_num": 36,
      "context": "{\"31\":\"| 本地工程模块   | 加载ets目录下文件中的模块      | 要求路径以ets开头             |\",\"32\":\"| 本地工程模块   | 加载模块内文件路径       | 要求路径以moduleName开头             |\",\"33\":\"| 本地工程模块   | 加载HAR模块名           | -                            |\",\"34\":\"| 本地工程模块   | 加载HSP模块名           | -                            |\",\"35\":\"| 远程包         | 加载远程HAR模块名        | -                            |\",\"36\":\"| 远程包         | 加载ohpm包名            | -                            |\",\"37\":\"| 模块Native库   | 加载libNativeLibrary.so | -                            |\",\"38\":\"\",\"39\":\"- **加载系统模块**\",\"40\":\"\",\"41\":\"    ```cpp\"}",
      "修改建议": "混用了“包名”和“包名称”",
      "更改后示例": "加载ohpm包名称",
      "触发条件": "同一文档或上下文中，同一概念存在“名”与“名称”等近义术语混用，且相邻条目或同类条目已形成固定表达模式（如“模块名”高频出现）。"
    },
    {
      "defect_id": 408703,
      "sentence": "1. 需要当前模块的build-profile.json5文件中进行以下配置：",
      "reference_sentence": "1. 需要在工程的build-profile.json5文件中进行以下配置：",
      "line_num": 140,
      "context": "{\"135\":\"      console.log(\\\"Hello OpenHarmony\\\");\",\"136\":\"    }\",\"137\":\"    export {value, test};\",\"138\":\"    ```\",\"139\":\"\",\"140\":\"1. 需要当前模块的build-profile.json5文件中进行以下配置：\",\"141\":\"\",\"142\":\"    ```json\",\"143\":\"    {\",\"144\":\"      \\\"buildOption\\\" : {\",\"145\":\"        \\\"arkOptions\\\" : {\"}",
      "修改建议": "混用了“当前模块”和“工程”两个概念",
      "更改后示例": "1. 需要在当前模块的build-profile.json5文件中进行以下配置：",
      "触发条件": "同一文档或上下文中，对同一概念（如“模块”和“工程”）存在术语混用，且未通过上下文明确区分其差异。\n\n识别模式：\n1. 检查相邻段落或同类型操作步骤中是否出现指向同一实体的不同术语（如“模块”↔“工程”）。\n2. 匹配预定义术语对照表，当非等价术语（如模块≠工程）出现在相同语法位置（如路径描述）时触发告警。"
    },
    {
      "defect_id": 408457,
      "sentence": "若开发者未对字段进行配置时，则默认不使用该功能。",
      "reference_sentence": "若开发者未对maxFlowDepth字段进行配置时，则该字段默认为2000；若开发者对maxFlowDepth字段配置的值超过可配置范围，则会出现编译构建相关报错。",
      "line_num": 134,
      "context": "{\"129\":\"```\",\"130\":\"修改方舟字节码能力可参考[编译期自定义修改方舟字节码](customize-bytecode-during-compilation.md)。\",\"131\":\"\",\"132\":\"### 注意事项\",\"133\":\"\",\"134\":\"- 若开发者未对字段进行配置时，则默认不使用该功能。\",\"135\":\"- HAP、HSP模块配置即生效，HAR模块仅字节码HAR配置生效，非字节码HAR配置不生效。\",\"136\":\"- 文件格式要求：Windows：.dll文件，Linux/Mac：.so文件。\"}",
      "修改建议": "前后文用词不一致，'字段'应与'配置项'保持一致。",
      "更改后示例": "若开发者未对配置项进行配置时，则默认不使用该功能。",
      "触发条件": "当同一文档中出现多个术语指代同一技术概念（如\"字段\"与\"配置项\"），且上下文存在已确立的标准术语时；或当相邻语句/参考案例中已建立特定术语使用范式时。通过术语库比对和上下文模式匹配识别，当检测到同一语义实体存在两种及以上表述形式时触发规则。"
    },
    {
      "defect_id": 408702,
      "sentence": "加载libNativeLibrary.so",
      "reference_sentence": "加载libNativeLibrary.so",
      "line_num": 37,
      "context": "{\"32\":\"| 本地工程模块   | 加载模块内文件路径       | 要求路径以moduleName开头             |\",\"33\":\"| 本地工程模块   | 加载HAR模块名           | -                            |\",\"34\":\"| 本地工程模块   | 加载HSP模块名           | -                            |\",\"35\":\"| 远程包         | 加载远程HAR模块名        | -                            |\",\"36\":\"| 远程包         | 加载ohpm包名            | -                            |\",\"37\":\"| 模块Native库   | 加载libNativeLibrary.so | -                            |\",\"38\":\"\",\"39\":\"- **加载系统模块**\",\"40\":\"\",\"41\":\"    ```cpp\",\"42\":\"    static napi_value loadModule(napi_env env, napi_callback_info info) {\"}",
      "修改建议": "混用了“库”和“库文件”",
      "更改后示例": "加载libNativeLibrary.so库文件",
      "触发条件": "同一文档结构中相邻条目在描述同类操作时，若当前条目省略了对象类型描述（如“库文件”），而其他条目明确包含类型（如“模块名”“包名”），则触发一致性规则。\n\n识别模式：\n1. 检查同一表格/列表中的相邻条目是否采用“动词+对象名称+类型”结构（如“加载xx模块名”）；\n2. 对比当前条目是否缺失与上下文匹配的类型说明词（如“库文件”与“模块名”“包名”形成结构不对称）。"
    },
    {
      "defect_id": 408869,
      "sentence": "1. CMakeLists.txt文件需要按照如下配置",
      "reference_sentence": "2. 需要在工程的build-profile.json5文件中进行以下配置",
      "line_num": 128,
      "context": "{\"123\":\"    // index.d.ts\",\"124\":\"    export const runEventLoop: (isDefault: boolean) => object;\",\"125\":\"    ```\",\"126\":\"\",\"127\":\"- 编译配置\",\"128\":\"1. CMakeLists.txt文件需要按照如下配置\",\"129\":\"    ```\",\"130\":\"    // CMakeLists.txt\",\"131\":\"    # the minimum version of CMake.\",\"132\":\"    cmake_minimum_required(VERSION 3.4.1)\",\"133\":\"    project(myapplication)\"}",
      "修改建议": "使用了不同的词汇（文件、配置）描述同一事物，应保持一致",
      "更改后示例": "1. CMakeLists.txt配置文件需要按照如下配置",
      "触发条件": "当同一文档中对同一事物使用不一致的术语（如\"文件\"与\"配置\"），且存在相邻上下文或参考表达时触发。\n\n识别模式：\n1. 检测同一实体被多个修饰词描述（如\"CMakeLists.txt文件\"与参考句中的\"build-profile.json5文件...配置\"）\n2. 匹配上下文中的术语使用模式（如相邻段落出现\"配置文件\"的规范表达）\n3. 识别关键实体后的语义冲突（\"文件\"作为通用描述与\"配置\"作为功能描述的逻辑矛盾）"
    },
    {
      "defect_id": 408725,
      "sentence": "3. 用napi_load_module加载library，调用函数test以及获取变量value：",
      "reference_sentence": "3. 用napi_load_module加载sharedlibrary，调用函数test以及获取变量value：",
      "line_num": 222,
      "context": "{\"217\":\"        }\",\"218\":\"      }\",\"219\":\"    }\",\"220\":\"    ```\",\"221\":\"\",\"222\":\"3. 用napi_load_module加载library，调用函数test以及获取变量value：\",\"223\":\"\",\"224\":\"    ```cpp\",\"225\":\"    static napi_value loadModule(napi_env env, napi_callback_info info) {\",\"226\":\"        napi_value result;\",\"227\":\"        // 1. 使用napi_load_module加载library\"}",
      "修改建议": "混用了library和sharedlibrary概念，应使用同一术语",
      "更改后示例": "3. 用napi_load_module加载sharedlibrary，调用函数test以及获取变量value：",
      "触发条件": "同一文档或上下文中，同一概念存在多个不一致的术语表述（如\"library\"和\"sharedlibrary\"交替出现），且相邻代码/注释已使用正确术语（如参考句中的\"sharedlibrary\"）。"
    },
    {
      "defect_id": 408726,
      "sentence": "2. 在使用library的模块中，对build-profile.json5进行配置：",
      "reference_sentence": "2. 在使用library的模块中，对build-profile.json5进行配置：",
      "line_num": 272,
      "context": "{\"267\":\"        \\\"sharedlibrary\\\": \\\"file:../sharedlibrary\\\"\",\"268\":\"      }\",\"269\":\"    }\",\"270\":\"    ```\",\"271\":\"\",\"272\":\"2. 在使用library的模块中，对build-profile.json5进行配置：\",\"273\":\"\",\"274\":\"    ```json\",\"275\":\"    {\",\"276\":\"      \\\"buildOption\\\" : {\",\"277\":\"        \\\"arkOptions\\\" : {\"}",
      "修改建议": "前后描述不一致，应使用同一术语",
      "更改后示例": "2. 在使用sharedlibrary的模块中，对build-profile.json5进行配置：",
      "触发条件": "当文档中同一概念出现多个不同术语指代（如\"library\"和\"sharedlibrary\"），且相邻上下文存在明确的标准术语（如代码块中的\"sharedlibrary\"）时触发。通过对比文本描述与代码/配置项命名一致性进行识别。"
    },
    {
      "defect_id": 408960,
      "sentence": "- **加载API模块**",
      "reference_sentence": "- **加载远程HAR模块名**",
      "line_num": 353,
      "context": "{\"348\":\"        napi_call_function(env, defaultValue, stringifyFn, 1, args, &returnValue);\",\"349\":\"        return result;\",\"350\":\"    }\",\"351\":\"    ```\",\"352\":\"\",\"353\":\"- **加载API模块**\",\"354\":\"\",\"355\":\"```cpp\",\"356\":\"static napi_value loadModule(napi_env env, napi_callback_info info) {\",\"357\":\"    // 1. 使用napi_load_module_with_info加载模块@ohos.hilog\",\"358\":\"    napi_value result;\"}",
      "修改建议": "混用了'加载API模块'与'加载远程HAR模块名'，导致概念不一致",
      "更改后示例": "- **加载远程API模块**",
      "触发条件": "同一文档中出现多个描述相似功能模块的术语时，若其修饰词（如\"远程\"）或核心词（如\"API/HAR\"）存在结构性差异，且上下文指向同一技术场景。识别模式需检测相邻段落中是否存在同类术语的固定修饰前缀（如\"远程\"）或后缀（如\"模块名\"）缺失/冗余。"
    },
    {
      "defect_id": 408724,
      "sentence": "HAR包Index.ets文件如下：",
      "reference_sentence": "HSP包Index.ets文件如下：",
      "line_num": 185,
      "context": "{\"180\":\"    }\",\"181\":\"    ```\",\"182\":\"\",\"183\":\"- **加载HAR模块名**\",\"184\":\"\",\"185\":\"    HAR包Index.ets文件如下：\",\"186\":\"\",\"187\":\"    ```javascript\",\"188\":\"    //library Index.ets\",\"189\":\"    let value = 123;\",\"190\":\"    function test() {\"}",
      "修改建议": "混用了HAR和HSP概念，应使用同一术语",
      "更改后示例": "HSP包Index.ets文件如下：",
      "触发条件": "当同一技术概念在文档中交替使用多个不同术语（如HAR/HSP混用）且未明确区分含义时，或上下文存在与既定术语（如参考句中的HSP）相冲突的表述时触发。\n\n识别模式：通过比对相邻段落术语使用一致性（如问题句\"HAR包\"与参考句\"HSP包\"冲突）、检查核心技术名词重复率（如HAR/HSP在短篇幅内交替出现），结合领域知识库验证术语准确性。"
    },
    {
      "defect_id": 408833,
      "sentence": "使用这个函数将ArkTS中的布尔值转为等价的C布尔值。",
      "reference_sentence": "用于根据给定的ArkTS boolean值，获取等价的C/C++布尔值。",
      "line_num": 266,
      "context": "{\"261\":\"hilog.info(0x0000, 'testTag', 'Test Node-API napi_get_boolean:%{public}s', data);\",\"262\":\"```\",\"263\":\"\",\"264\":\"### napi_get_value_bool\",\"265\":\"\",\"266\":\"使用这个函数将ArkTS中的布尔值转为等价的C布尔值。\",\"267\":\"\",\"268\":\"cpp部分代码\",\"269\":\"\",\"270\":\"```cpp\",\"271\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了'布尔值'和'boolean值'，应保持一致。",
      "更改后示例": "使用这个函数将ArkTS中的boolean值转为等价的C布尔值。",
      "触发条件": "同一技术术语在文档中出现中英文混合表述（如\"布尔值\"与\"boolean值\"），且上下文存在已确立的统一表达形式（如参考句中的\"ArkTS boolean值\"）。\n\n识别模式：通过对比问题句与上下文术语使用习惯（如代码片段、相邻章节），检测技术名词中英文形态一致性，当同一概念出现中文全称与英文类型声明混用（如ArkTS+boolean/布尔值）时触发规则。"
    },
    {
      "defect_id": 408925,
      "sentence": "Node-API中的napi_load_module_with_info接口的功能是进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用，即napi_create_ark_runtime接口创建的运行时环境。",
      "reference_sentence": "Node-API中的napi_load_module_with_info接口的功能是进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用，即napi_create_ark_runtime接口创建的运行时环境。",
      "line_num": 3,
      "context": "{\"1\":\"# 使用Node-API接口进行模块加载\",\"2\":\"\",\"3\":\"Node-API中的napi_load_module_with_info接口的功能是进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用，即napi_create_ark_runtime接口创建的运行时环境。\",\"4\":\"\",\"5\":\"## 函数说明\",\"6\":\"\",\"7\":\"```cpp\",\"8\":\"napi_status napi_load_module_with_info(napi_env env, const char* path, const char* module_info, napi_value* result);\"}",
      "修改建议": "使用了'函数'和'接口'两种不同的词汇描述同一事物，导致用词不一致。",
      "更改后示例": "Node-API中的napi_load_module_with_info接口的功能是进行模块的加载，当模块加载出来之后，可以使用napi_get_property接口获取模块导出的变量，也可以使用napi_get_named_property接口获取模块导出的函数，该接口可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用，即napi_create_ark_runtime接口创建的运行时环境。",
      "触发条件": "同一技术概念在相邻语句中出现不同术语指代（如\"函数\"和\"接口\"混用），且上下文存在明确的技术术语规范（如参考句已确立\"接口\"为统一表述）。\n\n识别模式：\n1. 检测同一段落内对技术组件（如napi_get_property）的称谓是否统一\n2. 匹配技术术语库（如接口/API/函数等易混淆词汇）\n3. 结合上下文判断指代对象是否属于同一技术层级（此处接口均为Node-API方法）\n4. 验证参考句或技术规范中已确立的术语标准（如问题上下文第7行函数声明实际对应\"接口\"概念）"
    },
    {
      "defect_id": 408945,
      "sentence": "3. 用napi_load_module_with_info加载json5，调用函数stringify：",
      "reference_sentence": "3. 使用napi_load_module_with_info加载library，调用函数test以及获取变量value：",
      "line_num": 320,
      "context": "{\"315\":\"            }\",\"316\":\"        }\",\"317\":\"    }\",\"318\":\"    ```\",\"319\":\"\",\"320\":\"3. 用napi_load_module_with_info加载json5，调用函数stringify：\",\"321\":\"\",\"322\":\"    ```cpp\",\"323\":\"    static napi_value loadModule(napi_env env, napi_callback_info info) {\",\"324\":\"        napi_value result;\",\"325\":\"        // 1. 使用napi_load_module_with_info加载json5\"}",
      "修改建议": "用词不一致，应使用'使用napi_load_module_with_info加载json5，调用函数stringify'的表述",
      "更改后示例": "3. 使用napi_load_module_with_info加载json5，调用函数stringify：",
      "触发条件": "同一操作步骤中动词表述与上下文或参考案例中的标准用词不一致（如\"用\"与\"使用\"混用），且存在明确对应的规范表述模板。"
    },
    {
      "defect_id": 409174,
      "sentence": "type，标识fd通过何种封装形式进行管理，例如 `FDSAN_OWNER_TYPE_FILE`就表示fd通过普通文件进行管理，type类型在 `fdsan_owner_type`进行定义。",
      "reference_sentence": "type，标识fd通过何种封装形式进行管理，例如 `FDSAN_OWNER_TYPE_FILE`就表示fd通过普通文件进行管理，type类型在 `fdsan_owner_type`进行定义。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"设计思路：当打开已有文件或创建一个新文件的时候，在得到返回fd后，设置一个关联的tag，来标记fd的属主信息；关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常文件关闭流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。\",\"10\":\"\",\"11\":\"tag由两部分组成，最高位的8-bit构成type，后面的56-bit构成value。\",\"12\":\"\",\"13\":\"type，标识fd通过何种封装形式进行管理，例如 `FDSAN_OWNER_TYPE_FILE`就表示fd通过普通文件进行管理，type类型在 `fdsan_owner_type`进行定义。\",\"14\":\"\",\"15\":\"value，则用于标识实际的owner tag。\",\"16\":\"\",\"17\":\" tag构成图示\",\"18\":\"\"}",
      "修改建议": "混用了'普通文件'和'文件'，建议统一使用'文件'。",
      "更改后示例": "type，标识fd通过何种封装形式进行管理，例如 `FDSAN_OWNER_TYPE_FILE`就表示fd通过文件进行管理，type类型在 `fdsan_owner_type`进行定义。",
      "触发条件": "同一技术术语在相邻语句中存在冗余修饰词（如\"普通文件\"与\"文件\"）混用，且上下文未定义修饰词的特殊含义时；或同一概念在定义段与示例段使用不同词汇表述时。\n\n识别模式：\n1. 定位技术定义段落中的核心术语（如\"文件\"）\n2. 检测其修饰词在示例/说明中的必要性（如\"普通\"是否带来必要区分）\n3. 验证修饰词是否在文档其它位置有明确定义或对应类型\n4. 对比术语在定义段与示例段的一致性（如定义段用\"文件\"，示例段是否需保持统一）"
    },
    {
      "defect_id": 408864,
      "sentence": "调用的ArkTS接口为异步接口时，需要通过扩展接口napi_run_event_loop将异步线程中的事件循环运行起来，底层事件队列中的异步任务将被处理执行。",
      "reference_sentence": "开发者在自己创建的ArkTS运行环境中调用异步的ArkTS接口时，可以通过使用Node-API中的扩展接口napi_run_event_loop和napi_stop_event_loop来运行和停止ArkTS实例中的事件循环。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"开发者在自己创建的ArkTS运行环境中调用异步的ArkTS接口时，可以通过使用Node-API中的扩展接口napi_run_event_loop和napi_stop_event_loop来运行和停止ArkTS实例中的事件循环。\",\"5\":\"\",\"6\":\"## 调用异步的ArkTS接口示例\",\"7\":\"调用的ArkTS接口为异步接口时，需要通过扩展接口napi_run_event_loop将异步线程中的事件循环运行起来，底层事件队列中的异步任务将被处理执行。当前Node-API扩展了两种事件循环模式来运行异步线程的事件循环，分别为napi_event_mode_nowait模式和napi_event_mode_default模式。\",\"8\":\"如果使用napi_event_mode_nowait模式运行底层事件循环，系统会尝试从底层的事件队列中取出一个任务并处理，完成之后事件循环停止，如果底层的事件队列中没有任务，事件循环会立刻停止，当前的异步线程不会被阻塞；\",\"9\":\"如果使用napi_event_mode_default模式来运行底层事件循环，系统会阻塞当前的线程，同时会一直尝试从事件队列中获取任务并执行处理这些任务。如果不想当前线程继续被阻塞，可以使用扩展接口napi_stop_event_loop将正在运行的事件循环停止。\",\"10\":\"\",\"11\":\"### 示例代码\",\"12\":\"- 模块注册\"}",
      "修改建议": "混用了`异步线程`和`ArkTS实例`概念",
      "更改后示例": "调用的ArkTS接口为异步接口时，需要通过扩展接口napi_run_event_loop将ArkTS实例中的事件循环运行起来，底层事件队列中的异步任务将被处理执行。",
      "触发条件": "当同一技术概念在相邻段落或上下文引用中使用了不一致的术语表述(如\"异步线程\"与\"ArkTS实例\")，且存在已明确定义的标准术语时。\n\n识别模式：\n1. 通过上下文比对发现同一技术实体被不同术语指代(如问题句的\"异步线程\" vs 参考句的\"ArkTS实例\")\n2. 存在已明确定义的规范术语(如参考句已建立\"ArkTS实例中的事件循环\"的标准表达)\n3. 术语混用导致概念边界模糊(如线程与运行环境实例属于不同维度的技术概念)"
    },
    {
      "defect_id": 408750,
      "sentence": "1. 在har1中的oh-package.json5文件中配置dependencies项：",
      "reference_sentence": "1. 在当前模块下的oh-package.json5文件中配置dependencies项：",
      "line_num": 488,
      "context": "{\"483\":\"      console.log(\\\"Hello OpenHarmony\\\");\",\"484\":\"    }\",\"485\":\"    export {value, test};\",\"486\":\"    ```\",\"487\":\"\",\"488\":\"1. 在har1中的oh-package.json5文件中配置dependencies项：\",\"489\":\"\",\"490\":\"    ```json\",\"491\":\"    {\",\"492\":\"      \\\"dependencies\\\": {\",\"493\":\"        \\\"har2\\\": \\\"file:../har2\\\"\"}",
      "修改建议": "前后描述不一致，应统一为'在当前模块下的oh-package.json5文件中配置dependencies项'",
      "更改后示例": "1. 在当前模块下的oh-package.json5文件中配置dependencies项：",
      "触发条件": "当文档中同一实体的描述存在命名/路径不一致（如\"har1\"与\"当前模块下\"的表述冲突），且上下文存在明确的标准术语（如\"当前模块下的oh-package.json5\"）时触发。"
    },
    {
      "defect_id": 408734,
      "sentence": "3. 用napi_load_module加载@ohos/axios，获取VERSION变量：",
      "reference_sentence": "3. 用napi_load_module加载library，调用函数test以及获取变量value：",
      "line_num": 392,
      "context": "{\"387\":\"        }\",\"388\":\"      }\",\"389\":\"    }\",\"390\":\"    ```\",\"391\":\"\",\"392\":\"3. 用napi_load_module加载@ohos/axios，获取VERSION变量：\",\"393\":\"\",\"394\":\"    ```cpp\",\"395\":\"    static napi_value loadModule(napi_env env, napi_callback_info info) {\",\"396\":\"        napi_value result;\",\"397\":\"        // 1. 使用napi_load_module加载@ohos/axios\"}",
      "修改建议": "混用了不同模块加载的方式，且“获取VERSION变量”与“获取变量value”用词不一致",
      "更改后示例": "3. 用napi_load_module加载@ohos/axios，获取变量VERSION：",
      "触发条件": "同一文档中出现术语位置不一致（如“变量X”和“X变量”交替使用），且上下文存在相同操作模式（如获取变量/调用函数）时触发。\n\n识别模式：\n1. 检测\"动词+名词短语\"结构中术语顺序异常（如“获取[大写名称]变量”）\n2. 对比上下文相似句式（如参考句中的\"获取变量value\"），当术语\"变量/函数\"与目标词顺序颠倒时告警\n3. 匹配模式：/(获取|调用)\\s*([A-Z_]+)\\s*(变量|函数)/ vs 标准模式/(获取|调用)\\s*(变量|函数)\\s*([a-z_]+)/i"
    },
    {
      "defect_id": 408931,
      "sentence": "- **加载源码HAR模块**",
      "reference_sentence": "- **加载模块内文件路径**",
      "line_num": 111,
      "context": "{\"106\":\"        napi_get_property(env, result, key, &value);\",\"107\":\"        return result;\",\"108\":\"    }\",\"109\":\"    ~~~\",\"110\":\"\",\"111\":\"- **加载源码HAR模块**\",\"112\":\"\",\"113\":\"HAR包Index.ets文件如下：\",\"114\":\"\",\"115\":\"```javascript\",\"116\":\"//library Index.ets\"}",
      "修改建议": "同一概念使用了不同的表述，导致混淆",
      "更改后示例": "- **加载模块内文件路径**",
      "触发条件": "同一技术概念在相邻上下文或关联段落中使用了不一致的术语表述，且存在已明确定义的标准术语（如参考句中的\"模块内文件路径\"）。\n\n识别模式：当检测到关键名词（如\"源码HAR模块\"）与上下文既定术语（如\"模块内文件路径\"）存在语义重叠但表述差异，且可能导致用户对同一实体产生歧义时触发规则。需结合术语邻近性（如问题句与参考句间隔≤3行）和概念等价性进行判定。"
    },
    {
      "defect_id": 408865,
      "sentence": "如果不想当前线程继续被阻塞，可以使用扩展接口napi_stop_event_loop将正在运行的事件循环停止。",
      "reference_sentence": "如果使用napi_event_mode_default模式来运行底层事件循环，系统会阻塞当前的线程，同时会一直尝试从事件队列中获取任务并执行处理这些任务。",
      "line_num": 9,
      "context": "{\"4\":\"开发者在自己创建的ArkTS运行环境中调用异步的ArkTS接口时，可以通过使用Node-API中的扩展接口napi_run_event_loop和napi_stop_event_loop来运行和停止ArkTS实例中的事件循环。\",\"5\":\"\",\"6\":\"## 调用异步的ArkTS接口示例\",\"7\":\"调用的ArkTS接口为异步接口时，需要通过扩展接口napi_run_event_loop将异步线程中的事件循环运行起来，底层事件队列中的异步任务将被处理执行。当前Node-API扩展了两种事件循环模式来运行异步线程的事件循环，分别为napi_event_mode_nowait模式和napi_event_mode_default模式。\",\"8\":\"如果使用napi_event_mode_nowait模式运行底层事件循环，系统会尝试从底层的事件队列中取出一个任务并处理，完成之后事件循环停止，如果底层的事件队列中没有任务，事件循环会立刻停止，当前的异步线程不会被阻塞；\",\"9\":\"如果使用napi_event_mode_default模式来运行底层事件循环，系统会阻塞当前的线程，同时会一直尝试从事件队列中获取任务并执行处理这些任务。如果不想当前线程继续被阻塞，可以使用扩展接口napi_stop_event_loop将正在运行的事件循环停止。\",\"10\":\"\",\"11\":\"### 示例代码\",\"12\":\"- 模块注册\",\"13\":\"    ```c++\",\"14\":\"    // hello.cpp\"}",
      "修改建议": "混用了`事件循环`和`当前线程`概念",
      "更改后示例": "如果不想当前线程继续被阻塞，可以使用扩展接口napi_stop_event_loop将正在运行的ArkTS实例中的事件循环停止。",
      "触发条件": "当文档中提及\"事件循环\"但未明确限定其所属的ArkTS运行环境实例时，或当同一技术概念存在上下文相关的不同限定词（如线程/实例）时。\n\n识别模式：\n1. 检测技术名词是否缺失必要限定词（如\"ArkTS实例中的\"）\n2. 检查相邻段落是否存在相同技术概念的标准表达方式（如上下文多次出现\"ArkTS实例中的事件循环\"）\n3. 验证是否存在跨概念关联（如将线程阻塞状态与实例级事件循环直接关联）\n4. 对比参考句中的完整技术路径描述（如\"运行底层事件循环→阻塞当前线程\"的因果关系）"
    },
    {
      "defect_id": 408733,
      "sentence": "3. 用napi_load_module加载@ohos/hypium，获取DEFAULT变量：",
      "reference_sentence": "3. 用napi_load_module加载library，调用函数test以及获取变量value：",
      "line_num": 343,
      "context": "{\"338\":\"        }\",\"339\":\"      }\",\"340\":\"    }\",\"341\":\"    ```\",\"342\":\"\",\"343\":\"3. 用napi_load_module加载@ohos/hypium，获取DEFAULT变量：\",\"344\":\"\",\"345\":\"    ```cpp\",\"346\":\"    static napi_value loadModule(napi_env env, napi_callback_info info) {\",\"347\":\"        napi_value result;\",\"348\":\"        // 1. 使用napi_load_module加载@ohos/hypium\"}",
      "修改建议": "混用了不同模块加载的方式，且“获取DEFAULT变量”与“获取变量value”用词不一致",
      "更改后示例": "3. 用napi_load_module加载@ohos/hypium，获取变量DEFAULT：",
      "触发条件": "当同一文档中存在相同操作的不同描述结构（如\"变量DEFAULT\"与\"DEFAULT变量\"的语序混用），且上下文存在统一表达模式（如\"获取变量value\"）时触发。"
    },
    {
      "defect_id": 408932,
      "sentence": "- **加载源码HSP模块**",
      "reference_sentence": "- **加载模块内文件路径**",
      "line_num": 177,
      "context": "{\"172\":\"        napi_get_property(env, result, key, &value);\",\"173\":\"        return result;\",\"174\":\"    }\",\"175\":\"    ```\",\"176\":\"\",\"177\":\"- **加载源码HSP模块**\",\"178\":\"\",\"179\":\"HSP包Index.ets文件如下：\",\"180\":\"\",\"181\":\"```javascript\",\"182\":\"//hsp Index.ets\"}",
      "修改建议": "同一概念使用了不同的表述，导致混淆",
      "更改后示例": "- **加载模块内文件路径**",
      "触发条件": "同一文档或相邻上下文中出现对同一技术概念使用不同术语表述（如\"源码HSP模块\"与\"模块内文件路径\"），且该表述出现在技术操作步骤、代码注释等需要术语精确性的位置时触发。"
    },
    {
      "defect_id": 408961,
      "sentence": "- **加载Native库**",
      "reference_sentence": "- **加载远程HAR模块名**",
      "line_num": 386,
      "context": "{\"381\":\"    napi_call_function(env, result, infoFn, 3, args, nullptr);\",\"382\":\"    return result;\",\"383\":\"}\",\"384\":\"```\",\"385\":\"\",\"386\":\"- **加载Native库**\",\"387\":\"\",\"388\":\"libentry.so的index.d.ts文件如下：\",\"389\":\"\",\"390\":\"```javascript\",\"391\":\"//index.d.ts\"}",
      "修改建议": "混用了'加载Native库'与'加载远程HAR模块名'，导致概念不一致",
      "更改后示例": "- **加载远程Native库**",
      "触发条件": "同一文档或相邻上下文中存在相同操作但术语或结构不一致（如动词短语中核心修饰词缺失或核心术语不匹配）。  \n\n识别模式：  \n1. **相邻结构对比**：当相邻列表项/标题的动词短语结构差异明显（如“加载远程HAR模块名” vs. “加载Native库”中“远程”修饰词缺失、术语类型不一致）。  \n2. **术语冲突**：同一概念使用不同术语（如“HAR模块”与“Native库”未统一），或修饰词（如“远程”）在同类操作中未保持一致性。"
    },
    {
      "defect_id": 409173,
      "sentence": "关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常文件关闭流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。",
      "reference_sentence": "关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常文件关闭流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"fdsan针对的操作对象是文件描述符，主要用于检测不同使用者对相同文件描述符的错误操作，包括多次关闭（double-close）和关闭后使用（use-after-close)。这些文件描述符可以是操作系统中的文件、目录、网络套接字和其他I/O设备等，在程序中，打开文件或套接字会生成一个文件描述符，如果此文件描述符在使用后出现反复关闭、或者关闭后使用等场景，就会造成内存泄露、文件句柄泄露等安全隐患问题。该类问题非常隐蔽，且难以排查，为了更好地检测此类问题，因此引入了此种针对文件描述符错误操作的检测工具fdsan。\",\"6\":\"\",\"7\":\"## 2. 实现原理\",\"8\":\"\",\"9\":\"设计思路：当打开已有文件或创建一个新文件的时候，在得到返回fd后，设置一个关联的tag，来标记fd的属主信息；关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常文件关闭流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。\",\"10\":\"\",\"11\":\"tag由两部分组成，最高位的8-bit构成type，后面的56-bit构成value。\",\"12\":\"\",\"13\":\"type，标识fd通过何种封装形式进行管理，例如 `FDSAN_OWNER_TYPE_FILE`就表示fd通过普通文件进行管理，type类型在 `fdsan_owner_type`进行定义。\",\"14\":\"\"}",
      "修改建议": "混用了'关闭文件'和'文件关闭'，建议统一使用'关闭文件'。",
      "更改后示例": "关闭文件前，检测fd关联的tag，判断是否符合预期(属主信息一致)，符合就继续走正常关闭文件流程；如果不符合就是检测到异常，根据设置，调用对应的异常处理。",
      "触发条件": "同一文档上下文中出现同一概念采用不同动词-名词结构（如\"关闭文件\"与\"文件关闭\"），且存在已确立的标准表达形式（如参考句中的\"关闭文件\"）时触发。\n\n识别模式：\n1. 检测相邻段落中同一动作的动宾结构（动词+名词）与偏正结构（名词性短语）混用\n2. 对比上下文已建立的标准化表达（如问题段落前文连续使用\"关闭文件\"作为标准术语）\n3. 定位到技术流程描述中关键操作步骤的短语结构不一致（如\"正常文件关闭流程\"与\"正常关闭文件流程\"）"
    },
    {
      "defect_id": 408944,
      "sentence": "- **加载ohpm包名**",
      "reference_sentence": "- **加载源码HAR模块**",
      "line_num": 292,
      "context": "{\"287\":\"        napi_get_property(env, result, key, &defaultValue);\",\"288\":\"        return result;\",\"289\":\"    }\",\"290\":\"    ```\",\"291\":\"\",\"292\":\"- **加载ohpm包名**\",\"293\":\"\",\"294\":\"1. 在oh-package.json5文件中配置dependencies项：\",\"295\":\"\",\"296\":\"    ```json\",\"297\":\"    {\"}",
      "修改建议": "用词不一致，应使用'加载源码HAR模块'的表述",
      "更改后示例": "- **加载源码HAR模块**",
      "触发条件": "当检测到文档中相同概念存在多个术语变体（如\"ohpm包名\"与\"源码HAR模块\"），且上下文存在已确立的标准表述（如参考句子的\"加载源码HAR模块\"）时触发。\n\n识别模式：通过对比相邻段落/列表项中的术语使用，识别同一操作对象（如包/模块）出现的非标准缩略语（ohpm）、非统一命名格式（包名 vs 模块）等词汇偏差。"
    },
    {
      "defect_id": 408943,
      "sentence": "- **加载远程HAR模块名**",
      "reference_sentence": "- **加载源码HAR模块**",
      "line_num": 243,
      "context": "{\"238\":\"        napi_get_property(env, result, key, &value);\",\"239\":\"        return result;\",\"240\":\"    }\",\"241\":\"    ```\",\"242\":\"\",\"243\":\"- **加载远程HAR模块名**\",\"244\":\"\",\"245\":\"1. 在oh-package.json5文件中配置dependencies项：\",\"246\":\"\",\"247\":\"    ```json\",\"248\":\"    {\"}",
      "修改建议": "用词不一致，应使用'加载源码HAR模块'的表述",
      "更改后示例": "- **加载源码HAR模块**",
      "触发条件": "当检测到文档中相同功能模块存在\"远程/源码\"修饰词不一致，且上下文存在已确立的标准术语（如\"源码HAR模块\"）时触发。\n\n识别模式：通过对比相邻条目/相似上下文中的模块命名结构（动词+修饰词+模块类型+模块名），识别修饰词（如\"远程\"与\"源码\"）与标准术语的匹配度差异。"
    },
    {
      "defect_id": 408870,
      "sentence": "2. 需要在工程的build-profile.json5文件中进行以下配置",
      "reference_sentence": "1. CMakeLists.txt配置文件需要按照如下配置",
      "line_num": 146,
      "context": "{\"141\":\"    include_directories(${NATIVERENDER_ROOT_PATH}\",\"142\":\"                        ${NATIVERENDER_ROOT_PATH}/include)\",\"143\":\"    add_library(entry SHARED hello.cpp)\",\"144\":\"    target_link_libraries(entry PUBLIC libace_napi.z.so)\",\"145\":\"    ```\",\"146\":\"2. 需要在工程的build-profile.json5文件中进行以下配置\",\"147\":\"    ```json\",\"148\":\"    {\",\"149\":\"        \\\"buildOption\\\" : {\",\"150\":\"            \\\"arkOptions\\\" : {\",\"151\":\"                \\\"runtimeOnly\\\" : {\"}",
      "修改建议": "使用了不同的词汇（文件、配置）描述同一事物，应保持一致",
      "更改后示例": "2. 需要在工程的build-profile.json5配置文件中进行以下配置",
      "触发条件": "同一文档或邻近上下文中，对同一事物（如文件、配置项）使用不同修饰词（如\"文件\"/\"配置文件\"）进行描述，且存在已确定的正确术语参考（如参考句中的\"配置文件\"）。\n\n识别模式：\n1. 检测名词短语中修饰词与核心名词的组合方式（如\"JSON5文件\" vs \"JSON5配置文件\"）\n2. 匹配相邻段落/列表中相同类型的对象描述（如配置文件类名词）\n3. 对比预定义术语表或参考句中的标准表达（如\"配置文件\"作为规范术语）"
    },
    {
      "defect_id": 408962,
      "sentence": "- **HAR加载HAR模块名**",
      "reference_sentence": "- **加载远程HAR模块名**",
      "line_num": 451,
      "context": "{\"446\":\"        napi_call_function(env, result, addFn, INT_NUM_2, args, &returnValue);\",\"447\":\"        return result;\",\"448\":\"    }\",\"449\":\"    ```\",\"450\":\"\",\"451\":\"- **HAR加载HAR模块名**\",\"452\":\"\",\"453\":\"场景为har1加载har2，har2中的Index.ets文件如下：\",\"454\":\"\",\"455\":\"```javascript\",\"456\":\"//har2 Index.ets\"}",
      "修改建议": "混用了'HAR加载HAR模块名'与'加载远程HAR模块名'，导致概念不一致",
      "更改后示例": "- **加载远程HAR模块**",
      "触发条件": "当同一文档或上下文中出现同一概念采用不同术语结构（如\"名词+动词\"与\"动词+修饰词+名词\"混用），且相邻条目存在明确的一致性表达范式时触发。\n\n识别模式：\n1. 结构对比：检查相邻条目是否采用统一动宾结构（如\"加载远程HAR模块\"为\"动词+修饰词+名词\"结构，问题句\"名词+动词\"结构形成冲突）\n2. 术语匹配：识别核心术语是否保持完整一致性（如\"远程\"修饰词在参考句中存在但在问题句缺失）\n3. 上下文验证：结合参考句的规范表达范式（如\"加载远程HAR模块名\"）判断当前表达是否破坏平行条目间的术语体系一致性"
    },
    {
      "defect_id": 409269,
      "sentence": "在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。",
      "reference_sentence": "在上述代码中，setTimeout函数模拟了一个异步操作，1秒后生成一个随机数。如果随机数大于0.5，调用resolve回调函数并传递该随机数；否则调用reject回调函数并传递一个错误对象。",
      "line_num": 108,
      "context": "{\"103\":\"  }\",\"104\":\"}\",\"105\":\"```\",\"106\":\"<!-- @[async_await_sync_operation](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/AsyncConcurrencyOverview/entry/src/main/ets/pages/Index.ets) -->\",\"107\":\"\",\"108\":\"在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。\",\"109\":\"\",\"110\":\"需要注意的是，等待异步操作时，需将整个操作包在async函数中，并搭配await使用，同时也可使用try/catch块来捕获异步操作中的异常。\",\"111\":\"\",\"112\":\"```ts\",\"113\":\"async function myAsyncFunction(): Promise<void> {\"}",
      "修改建议": "前后描述中，模拟的异步操作时间不一致，前文是1秒，后文是3秒。",
      "更改后示例": "在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。注意，此处模拟的异步操作是在3秒后返回一个字符串。",
      "触发条件": "当文档中同一技术参数（如时间数值、函数行为）在相邻段落或同一示例中出现不一致描述时触发，需识别数值差异或矛盾陈述。"
    },
    {
      "defect_id": 409301,
      "sentence": "也可以等待生产者完成所有生产任务，通过序列化通信将结果发送给UI线程。UI线程接收完毕后，由消费者统一消费结果。",
      "reference_sentence": "生产者生产出结果后，通过序列化通信将结果发送给UI线程，UI线程消费结果后再发送新的生产任务给生产者线程。",
      "line_num": 201,
      "context": "{\"196\":\"  }\",\"197\":\"}\",\"198\":\"```\",\"199\":\"<!-- @[actor_model](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/MultiThreadConcurrencyOverview/entry/src/main/ets/pages/Index.ets) -->\",\"200\":\"\",\"201\":\"也可以等待生产者完成所有生产任务，通过序列化通信将结果发送给UI线程。UI线程接收完毕后，由消费者统一消费结果。\",\"202\":\"\",\"203\":\"```ts\",\"204\":\"import { taskpool } from '@kit.ArkTS';\",\"205\":\"\",\"206\":\"// 跨线程并发任务\"}",
      "修改建议": "混用了“序列化通信”和“消息传递机制”概念，且“消费结果”与“消费结果后再发送新的生产任务”为近义词混用",
      "更改后示例": "也可以等待生产者完成所有生产任务，通过消息传递机制将结果发送给UI线程。UI线程接收完毕后，由消费者统一消费结果。",
      "触发条件": "同一技术概念在相邻段落中出现术语不一致（如\"序列化通信\"与\"消息传递机制\"混用），或同一操作流程使用不同动词描述（如\"消费结果\"与\"消费结果后再发送\"交替出现）。"
    },
    {
      "defect_id": 410434,
      "sentence": "长时间无任务分发时会缩容，减少工作线程数量。",
      "reference_sentence": "当工作线程达到最大数量时，任务的执行效率可能会下降。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"TaskPool运作机制示意图\",\"8\":\"\",\"9\":\"![zh-cn_image_0000001964858368](figures/zh-cn_image_0000001964858368.png)\",\"10\":\"\",\"11\":\"TaskPool支持开发者在宿主线程提交任务到任务队列，系统选择合适的工作线程执行任务，再将结果返回给宿主线程。接口易用，支持任务执行、取消和指定优先级，同时通过系统统一线程管理，结合动态调度及负载均衡算法，可以节约系统资源。系统默认启动一个任务工作线程，任务多时会扩容。工作线程数量上限取决于设备的物理核数，内部管理具体数量，确保调度和执行效率最优。长时间无任务分发时会缩容，减少工作线程数量。具体扩缩容机制详情请见[TaskPool扩缩容机制](taskpool-introduction.md#taskpool扩缩容机制)。\",\"12\":\"\",\"13\":\"## TaskPool注意事项\",\"14\":\"\",\"15\":\"- 实现任务的函数需要使用[@Concurrent装饰器](#concurrent装饰器)标注，且仅支持在.ets文件中使用。\",\"16\":\"\"}",
      "修改建议": "混用了“分发”与“执行”描述同一动作",
      "更改后示例": "长时间无任务执行时会缩容，减少工作线程数量。",
      "触发条件": "同一上下文中存在描述同一动作的多个不一致动词（如\"分发\"与\"执行\"），且文档其他位置存在明确的统一用词（如参考句中的\"执行\"）时触发。\n\n识别模式：通过语义关联分析检测相邻段落中相同动作主体的不同动词表达，结合文档全局术语库验证是否存在用词冲突。当检测到类似\"任务分发\"与\"任务执行\"在描述同一流程环节时，需对比参考句中的规范用词进行一致性修正。"
    },
    {
      "defect_id": 409300,
      "sentence": "Actor并发模型中，线程不共享内存，需通过线程间通信机制传递任务和结果。",
      "reference_sentence": "Actor并发模型每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制触发对方Actor的行为，不同Actor之间不能直接访问对方的内存空间。",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"Actor并发模型每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制触发对方Actor的行为，不同Actor之间不能直接访问对方的内存空间。\",\"25\":\"\",\"26\":\"Actor并发模型相较于内存共享并发模型，不同线程间的内存是隔离的，因此不会出现线程竞争同一内存资源的情况。开发者无需处理内存上锁相关的问题，从而提高开发效率。\",\"27\":\"\",\"28\":\"Actor并发模型中，线程不共享内存，需通过线程间通信机制传递任务和结果。\",\"29\":\"\",\"30\":\"本文以经典的生产者消费者问题为例，对比呈现这两种模型在解决具体问题时的差异。\",\"31\":\"\",\"32\":\"### 内存共享模型\",\"33\":\"\"}",
      "修改建议": "混用了“线程”和“Actor”概念，且“消息传递机制”和“线程间通信机制”为近义词混用",
      "更改后示例": "Actor并发模型中，每个Actor不共享内存，需通过消息传递机制传递任务和结果。",
      "触发条件": "同一上下文存在同一概念使用不同术语的情况，或出现与领域专有名词定义不一致的近义词混用。\n\n具体识别模式：\n1. 术语一致性检查：当句子中的核心概念（如\"Actor\"）被替换为其他领域术语（如\"线程\"），且上下文已明确定义该专有名词时触发\n2. 近义表达规范检查：当出现与已定义的标准表达（如\"消息传递机制\"）构成同义但表述不同的短语（如\"线程间通信机制\"），且可能造成理解歧义时触发\n\n识别方法：通过上下文语义关联分析，建立领域术语表进行概念映射，结合词向量相似度检测近义表达差异，当检测到术语偏移或非标准近义表达时触发规则。"
    },
    {
      "defect_id": 409181,
      "sentence": "默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。",
      "reference_sentence": "默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"| 名称                       | 说明                                                         |\",\"63\":\"| -------------------------- | ------------------------------------------------------------ |\",\"64\":\"| `FDSAN_OWNER_TYPE_GENERIC_00` | 默认未使用fd对应的type值。     |\",\"65\":\"| `FDSAN_OWNER_TYPE_GENERIC_FF` | 默认非法fd对应的type值。 |\",\"66\":\"| `FDSAN_OWNER_TYPE_FILE` | 默认普通文件对应的type值，使用fopen或fdopen打开的文件具有该类型。 |\",\"67\":\"| `FDSAN_OWNER_TYPE_DIRECTORY` | 默认文件夹对应的type值，使用opendir或fdopendir打开的文件具有该类型。 |\",\"68\":\"| `FDSAN_OWNER_TYPE_UNIQUE_FD` | 默认unique_fd对应的type值，保留暂未使用。 |\",\"69\":\"| `FDSAN_OWNER_TYPE_ZIPARCHIVE` | 默认zip压缩文件对应的type值，保留暂未使用。 |\",\"70\":\"\",\"71\":\"**返回值：** 返回创建的tag，可以用于fdsan_exchange_owner_tag函数的输入。\"}",
      "修改建议": "混用了'普通文件'和'文件'，建议统一使用'文件'。",
      "更改后示例": "默认文件对应的type值，使用fopen或fdopen打开的文件具有该类型。",
      "触发条件": "同一概念在相邻上下文或同一文档范围内出现术语不一致（如\"普通文件\"与\"文件\"混用），且存在可对齐的参考表达（如相邻条目统一使用\"文件夹\"而非\"普通文件夹\"）。\n\n识别模式：\n1. 在结构化文本（如表格）中检测同类条目间的术语差异\n2. 通过相邻条目建立术语基准（如第67行使用\"文件夹\"对应DIRECTORY，则第66行应保持\"文件\"对应FILE的对称性）\n3. 识别同一语义概念的多重表达（\"普通文件\"与\"文件\"指代相同实体但修饰词不一致）"
    },
    {
      "defect_id": 409268,
      "sentence": "async函数通过返回Promise对象实现异步操作，其内部可以包含零个或者多个await关键字，通过await暂停执行直至关联的Promise完成状态转换（fulfilled/rejected）。",
      "reference_sentence": "Promise有三种状态：pending（进行中）、fulfilled（已完成，也叫resolved）和rejected（已拒绝）。",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"## async/await\",\"67\":\"\",\"68\":\"async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。\",\"69\":\"\",\"70\":\"async函数通过返回Promise对象实现异步操作，其内部可以包含零个或者多个await关键字，通过await暂停执行直至关联的Promise完成状态转换（fulfilled/rejected）。若函数执行过程中抛出异常，该异常将直接触发返回的Promise进入rejected状态，错误对象可通过.catch()方法或then的第二个回调参数捕获。\",\"71\":\"\",\"72\":\"下面是一个使用async/await的例子，其中模拟了一个以同步方式执行异步操作的场景，该操作会在3秒钟后返回一个字符串。\",\"73\":\"\",\"74\":\"```ts\",\"75\":\"async function myAsyncFunction(): Promise<string> {\"}",
      "修改建议": "混用了'fulfilled'和'已完成'的表述，导致用词不一致。",
      "更改后示例": "async函数通过返回Promise对象实现异步操作，其内部可以包含零个或者多个await关键字，通过await暂停执行直至关联的Promise状态转换为fulfilled或rejected。",
      "触发条件": "当同一技术术语在文档中存在多种表述形式（如中英文混用或不同翻译版本），或同一段落中关键术语的语法结构出现矛盾（如\"状态转换（fulfilled/rejected）\"中动词与名词结构不匹配）时触发。\n\n识别模式需检测：\n1. 术语表述一致性：比对同一概念是否出现中英文交替使用（如\"已完成\"与\"fulfilled\"）\n2. 语法结构一致性：检查并列术语的语法形态是否统一（如\"完成状态转换（fulfilled/rejected）\"中\"完成\"对应动词形态，而fulfilled/rejected为被动语态形容词）"
    },
    {
      "defect_id": 410435,
      "sentence": "任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。",
      "reference_sentence": "TaskPool支持开发者在宿主线程封装任务并提交给任务队列，理论上支持的任务数量没有上限。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"- 实现任务的函数需要使用[@Concurrent装饰器](#concurrent装饰器)标注，且仅支持在.ets文件中使用。\",\"16\":\"\",\"17\":\"- 从API version 11开始，跨并发实例传递带方法的实例对象时，该类必须使用装饰器[@Sendable装饰器](arkts-sendable.md#sendable装饰器)标注，且仅支持在.ets文件中使用。\",\"18\":\"\",\"19\":\"- 任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。\",\"20\":\"\",\"21\":\"- 实现任务的函数入参需满足序列化支持的类型，详情请参见[线程间通信对象](interthread-communication-overview.md)。目前不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。\",\"22\":\"\",\"23\":\"- ArrayBuffer参数在TaskPool中默认转移，需要设置转移列表的话可通过接口[setTransferList()](../reference/apis-arkts/js-apis-taskpool.md#settransferlist10)设置。如果需要多次调用使用ArrayBuffer作为参数的task，则需要通过接口[setCloneList()](../reference/apis-arkts/js-apis-taskpool.md#setclonelist11)把ArrayBuffer在线程中的传输行为改成拷贝传递，避免对原有对象产生影响。\",\"24\":\"\"}",
      "修改建议": "混用了“执行”与“封装”描述同一动作",
      "更改后示例": "任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的运行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。",
      "触发条件": "在同一文档或相邻上下文中，对同一动作或概念使用了不一致的动词（如“执行”与“封装”），且存在其他明确术语（如“运行”）作为统一表达时触发。\n\n识别模式：\n1. 检测同一段落或相邻条目中描述同一行为的动词是否统一（如问题句的“执行”与参考句的“封装”冲突）\n2. 检查文档是否存在已定义的规范术语（如修复后的“运行”与上下文线程行为描述形成统一语义场）"
    },
    {
      "defect_id": 410468,
      "sentence": "扩容后，TaskPool新建多个工作线程，但当任务数减少后，这些线程就会处于空闲状态，造成资源浪费，因此TaskPool提供缩容机制。",
      "reference_sentence": "一般情况下，开发者向任务队列提交任务时会触发扩容检测。扩容检测首先判断当前空闲的工作线程数是否大于任务数，如果大于，说明线程池中存在空闲工作线程，无需扩容。否则，通过负载计算确定所需工作线程数并创建。",
      "line_num": 443,
      "context": "{\"438\":\"\",\"439\":\"一般情况下，开发者向任务队列提交任务时会触发扩容检测。扩容检测首先判断当前空闲的工作线程数是否大于任务数，如果大于，说明线程池中存在空闲工作线程，无需扩容。否则，通过负载计算确定所需工作线程数并创建。\",\"440\":\"\",\"441\":\"### 缩容机制\",\"442\":\"\",\"443\":\"扩容后，TaskPool新建多个工作线程，但当任务数减少后，这些线程就会处于空闲状态，造成资源浪费，因此TaskPool提供缩容机制。TaskPool使用了定时器，定时检测当前负载。定时器30s触发一次，每次尝试释放空闲的工作线程。释放的线程需要满足如下条件：\",\"444\":\"\",\"445\":\"- 该线程空闲时长达到30s。\",\"446\":\"\",\"447\":\"- 该线程上未执行长时任务（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)）。\",\"448\":\"\"}",
      "修改建议": "混用了'扩容'和'扩增'，应统一为'扩容'。",
      "更改后示例": "扩容后，TaskPool创建多个工作线程，但当任务数减少后，这些线程就会处于空闲状态，造成资源浪费，因此TaskPool提供缩容机制。",
      "触发条件": "当同一技术概念在相邻段落或同一功能描述中使用了不同术语（如\"新建\"与\"创建\"），且上下文存在明确的标准术语（如参考句中的\"创建\"）时触发。\n\n识别模式：通过对比当前句子与上下文核心动词/名词的术语使用一致性，检测技术动作描述（如线程操作）中是否存在同义词混用，特别关注存在明确术语标准的前后段落（如示例中438-443行连续使用\"创建\"作为标准术语）。"
    },
    {
      "defect_id": 409267,
      "sentence": "异步并发是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。",
      "reference_sentence": "Promise和async/await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同一时间只有一段代码执行。",
      "line_num": 12,
      "context": "{\"7\":\"\",\"8\":\"- 任务轻量且无 CPU 阻塞​​：单次任务执行时间短。\",\"9\":\"\",\"10\":\"- 逻辑依赖清晰​​：任务有明确的顺序或并行关系。\",\"11\":\"\",\"12\":\"异步并发是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。\",\"13\":\"\",\"14\":\"## Promise\",\"15\":\"\",\"16\":\"Promise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一种状态机制来管理异步操作的不同阶段，Promise有三种状态：pending（进行中）、fulfilled（已完成，也叫resolved）和rejected（已拒绝）。其创建后处于pending状态，异步操作完成后转换为fulfilled或rejected状态。\",\"17\":\"\"}",
      "修改建议": "混用了'异步并发'和'异步代码'的表述，导致用词不一致。",
      "更改后示例": "异步并发是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他异步代码。",
      "触发条件": "当同一核心概念在相邻上下文或同一段落中使用了不同术语表述（如\"异步并发\"与\"异步代码\"），且存在文档内已明确定义的统一表达形式时触发。\n\n识别模式：\n1. 术语对照：检查核心名词（如\"异步代码\"）是否在上下文/参考句中存在明确定义的对应表达\n2. 逻辑连贯性验证：当后句行为主体（\"继续执行其他操作\"）与前句核心概念（\"异步并发\"）存在逻辑关联时，要求行为描述必须使用该概念的规范术语（应改为\"异步代码\"）"
    },
    {
      "defect_id": 410469,
      "sentence": "定时器30s触发一次，每次尝试释放空闲的工作线程。",
      "reference_sentence": "定时器30s触发一次，每次尝试释放空闲的工作线程。",
      "line_num": 443,
      "context": "{\"438\":\"\",\"439\":\"一般情况下，开发者向任务队列提交任务时会触发扩容检测。扩容检测首先判断当前空闲的工作线程数是否大于任务数，如果大于，说明线程池中存在空闲工作线程，无需扩容。否则，通过负载计算确定所需工作线程数并创建。\",\"440\":\"\",\"441\":\"### 缩容机制\",\"442\":\"\",\"443\":\"扩容后，TaskPool新建多个工作线程，但当任务数减少后，这些线程就会处于空闲状态，造成资源浪费，因此TaskPool提供缩容机制。TaskPool使用了定时器，定时检测当前负载。定时器30s触发一次，每次尝试释放空闲的工作线程。释放的线程需要满足如下条件：\",\"444\":\"\",\"445\":\"- 该线程空闲时长达到30s。\",\"446\":\"\",\"447\":\"- 该线程上未执行长时任务（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)）。\",\"448\":\"\"}",
      "修改建议": "混用了'触发'和'启动'，应统一为'触发'。",
      "更改后示例": "定时器每30秒触发一次，每次尝试释放空闲的工作线程。",
      "触发条件": "同一功能描述中混用不同动词（如\"触发\"与\"启动\"）或时间表达方式（如\"30s\"与\"每30秒\"），且上下文存在相同场景的标准化表达（如\"触发扩容检测\"）。通过对比相邻段落/参考句的动词使用模式，识别术语不匹配现象。"
    },
    {
      "defect_id": 412882,
      "sentence": "如果非Sendable类实现Sendable接口，可能会被误认为是Sendable类，从而导致错误使用。",
      "reference_sentence": "Sendable数据不能持有非Sendable数据，因此Sendable类或接口的成员变量必须是[Sendable支持的数据类型](arkts-sendable.md#sendable支持的数据类型)。",
      "line_num": 84,
      "context": "{\"79\":\"\",\"80\":\"## 接口实现规则\",\"81\":\"\",\"82\":\"### 非Sendable类禁止实现Sendable接口\",\"83\":\"\",\"84\":\"如果非Sendable类实现Sendable接口，可能会被误认为是Sendable类，从而导致错误使用。\",\"85\":\"\",\"86\":\"**正例：**\",\"87\":\"\",\"88\":\"```ts\",\"89\":\"interface I {};\"}",
      "修改建议": "句式不一致，前文使用了‘因此’引导结论，后文使用了‘从而’。",
      "更改后示例": "如果非Sendable类实现Sendable接口，可能会被误认为是Sendable类，因此导致错误使用。",
      "触发条件": "当同一文档中相邻或相关段落出现相同逻辑关系的表达，但使用不同因果连接词（如\"因此\"和\"从而\"）时触发；当重复出现的句式结构在结论引导词使用上出现不统一时触发。\n\n具体识别模式：\n1. 检测相邻段落/相似句式中的因果复句结构\n2. 对比结论引导词的一致性（特别是\"因此\"与\"从而\"的混用）\n3. 验证上下文是否存在统一表达范例（如参考句中的\"因此\"标准用法）\n4. 判断是否属于同一逻辑场景的重复说明（如规则说明+正例说明的组合场景）\n\n示例特征组合：\n[因果句式] ∧ [相同语义结构] ∧ ([因此] ⊕ [从而]) ∧ [存在已确立的标准表达]"
    },
    {
      "defect_id": 412848,
      "sentence": "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可以用于多个并发实例间的状态共享或者数据共享。",
      "reference_sentence": "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可以用于多个并发实例间的状态共享或者数据共享。",
      "line_num": 3,
      "context": "{\"1\":\"# SharedArrayBuffer对象\",\"2\":\"\",\"3\":\"SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可以用于多个并发实例间的状态共享或者数据共享。通信过程如下图所示：\",\"4\":\"\",\"5\":\"![sharedarraybufer](figures/sharedarraybufer.png)\",\"6\":\"\",\"7\":\"\",\"8\":\"## 使用示例\"}",
      "修改建议": "使用了“状态共享”和“数据共享”两个不同的词汇描述同一概念。",
      "更改后示例": "SharedArrayBuffer内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。支持跨并发实例间共享Native内存，但是对共享Native内存的访问及修改需要采用Atomics类，防止数据竞争。SharedArrayBuffer可以用于多个并发实例间的数据共享。",
      "触发条件": "同一段落/上下文中出现多个不同术语指代同一概念，且未明确说明其等价性或差异性。\n\n识别模式：\n1. 检测相邻句子或同一段落中是否存在多个近义词/不同表述（如\"状态共享\"和\"数据共享\"）\n2. 验证这些术语是否指向同一技术概念（通过语义分析及上下文验证）\n3. 检查文档中是否未对这些术语进行明确定义或区分说明"
    },
    {
      "defect_id": 412881,
      "sentence": "Sendable对象的布局及原型链不可变，而非Sendable对象可以通过特殊方式修改布局，因此不允许互相继承。",
      "reference_sentence": "Sendable对象的布局和原型链不可变，而非Sendable对象可以通过特殊方式修改布局。因此，不允许互相继承。",
      "line_num": 46,
      "context": "{\"41\":\"```\",\"42\":\"\",\"43\":\"\",\"44\":\"### 非Sendable类必须继承自非Sendable类\",\"45\":\"\",\"46\":\"Sendable对象的布局及原型链不可变，而非Sendable对象可以通过特殊方式修改布局，因此不允许互相继承。\",\"47\":\"\",\"48\":\"**正例：**\",\"49\":\"\",\"50\":\"```ts\",\"51\":\"class A {\"}",
      "修改建议": "句式不一致，前文使用了‘和’，后文使用了‘及’。",
      "更改后示例": "Sendable对象的布局和原型链不可变，而非Sendable对象可以通过特殊方式修改布局，因此不允许互相继承。",
      "触发条件": "同一句子或相邻上下文中存在相同语义的连词（如\"和/及/与\"）混用，或在重复性语法结构中使用了不一致的连接词。  \n\n识别模式：  \n1. 检测并列结构中连接词的一致性（如\"布局和原型链\"与\"布局及原型链\"）  \n2. 对比重复句式中的关联词使用（如因果句前后段使用的连接词是否统一）  \n3. 验证用户反馈中明确指出的术语/连接词不一致问题"
    },
    {
      "defect_id": 411002,
      "sentence": "以JS对象为例，其在并发任务间的通信采用了标准的Structured Clone算法（序列化和反序列化）。该算法通过序列化将JS对象转换为与引擎无关的数据（如字符串或内存块），在另一个并发实例中通过反序列化还原成与原JS对象内容一致的新对象。",
      "reference_sentence": "以JS对象为例，其在并发任务间的通信采用了标准的Structured Clone算法（序列化和反序列化）。该算法通过序列化将JS对象转换为与引擎无关的数据（如字符串或内存块），在另一个并发实例中通过反序列化还原成与原JS对象内容一致的新对象。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"线程间通信指的是并发多线程间存在的数据交换行为。由于ArkTS语言兼容TS/JS，其运行时的实现与其它所有的JS引擎一样，都是基于Actor内存隔离的并发模型提供并发能力。\",\"4\":\"\",\"5\":\"在ArkTS线程间通信中，不同数据对象的行为存在差异。例如，普通JS对象、ArrayBuffer对象和SharedArrayBuffer对象在跨线程时的行为不一致，包括序列化和反序列化、数据转移和数据共享等操作。\",\"6\":\"\",\"7\":\"以JS对象为例，其在并发任务间的通信采用了标准的Structured Clone算法（序列化和反序列化）。该算法通过序列化将JS对象转换为与引擎无关的数据（如字符串或内存块），在另一个并发实例中通过反序列化还原成与原JS对象内容一致的新对象。因此，需要进行深拷贝，效率较低。除了支持JS标准的序列化和反序列化能力，还支持绑定Native的JS对象的传输，以及[Sendable对象](arkts-sendable.md)的共享能力。\",\"8\":\"\",\"9\":\"ArkTS目前主要提供两种并发能力支持线程间通信：TaskPool和Worker。\",\"10\":\"\",\"11\":\"- Worker是Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。\",\"12\":\"\"}",
      "修改建议": "使用了“并发任务”和“并发实例”两个不同的术语描述同一概念",
      "更改后示例": "以JS对象为例，其在并发任务间的通信采用了标准的Structured Clone算法（序列化和反序列化）。该算法通过序列化将JS对象转换为与引擎无关的数据（如字符串或内存块），在另一个并发任务中通过反序列化还原成与原JS对象内容一致的新对象。",
      "触发条件": "在同一段落或邻近上下文中，对同一技术概念使用两个及以上不同术语（如\"并发任务\"和\"并发实例\"），且这些术语在文档其他部分未建立等价关系说明时。\n\n识别模式：\n1. 通过NLP技术检测同一语义范围内(3-5句内)出现的近义词组\n2. 结合文档术语表验证是否属于未定义的等价术语\n3. 特别关注带有相同限定词（如\"并发-XX\"结构）但核心词不同的表达形式\n4. 检查问题位置是否处于需要精确术语定义的技术说明段落"
    },
    {
      "defect_id": 412915,
      "sentence": "除了Object类型，非Sendable类型不能强转成Sendable类型。非Sendable类型通过as强转成Sendable类型后，实际数据仍为非Sendable类型，会导致错误使用。Sendable类型在不违反Sendable规则的前提下，需要和非Sendable类型行为兼容，因此Sendable类型可以as强转成非Sendable类型。",
      "reference_sentence": "除了Object类型，非Sendable类型不能强转成Sendable类型。非Sendable类型通过as强转成Sendable类型后，实际数据仍为非Sendable类型，会导致错误使用。Sendable类型在不违反Sendable规则的前提下，需要和非Sendable类型行为兼容，因此Sendable类型可以as强转成非Sendable类型。",
      "line_num": 391,
      "context": "{\"386\":\"\",\"387\":\"## 类型转换规则\",\"388\":\"\",\"389\":\"### 禁止非Sendable类型强制转换为Sendable\",\"390\":\"\",\"391\":\"除了Object类型，非Sendable类型不能强转成Sendable类型。非Sendable类型通过as强转成Sendable类型后，实际数据仍为非Sendable类型，会导致错误使用。Sendable类型在不违反Sendable规则的前提下，需要和非Sendable类型行为兼容，因此Sendable类型可以as强转成非Sendable类型。\",\"392\":\"\",\"393\":\"**正例：**\",\"394\":\"\",\"395\":\"```ts\",\"396\":\"class A {\"}",
      "修改建议": "句子中的“强转”与“as强转”用词不一致，应统一使用“as强转”",
      "更改后示例": "除了Object类型，非Sendable类型不能as强转成Sendable类型。非Sendable类型通过as强转成Sendable类型后，实际数据仍为非Sendable类型，会导致错误使用。Sendable类型在不违反Sendable规则的前提下，需要和非Sendable类型行为兼容，因此Sendable类型可以as强转成非Sendable类型。",
      "触发条件": "同一术语在相邻或同一段落中出现\"全称与简称混用\"或\"修饰词不一致\"（如\"强转\"与\"as强转\"），且上下文存在至少两处相同概念的不同表达形式时触发。识别模式：检测技术文档中特定技术动词/名词是否同时存在带修饰词（如\"as强转\"）和无修饰词（如\"强转\"）的两种形态，且间隔不超过3个句子。"
    },
    {
      "defect_id": 411031,
      "sentence": "普通类实例对象跨线程通过拷贝形式传递，只能传递数据，类实例上的方法会丢失。",
      "reference_sentence": "普通对象跨线程时通过拷贝形式传递，两个线程的对象内容一致，但是指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"![deep_copy](figures/deep_copy.png)\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 普通类实例对象跨线程通过拷贝形式传递，只能传递数据，类实例上的方法会丢失。可以使用[@Sendable装饰器](arkts-sendable.md#sendable装饰器)标识为Sendable类，类实例对象跨线程传递后，可携带类方法。\",\"10\":\"\",\"11\":\"## 使用示例\",\"12\":\"\",\"13\":\"此处提供了一个传递普通对象的示例，具体实现如下：\",\"14\":\"\"}",
      "修改建议": "混用了“普通对象”和“普通类实例对象”描述同一概念",
      "更改后示例": "普通对象跨线程通过拷贝形式传递，只能传递数据，类实例上的方法会丢失。",
      "触发条件": "同一文档中混用多个不同术语指代同一技术概念（如\"普通对象\"和\"普通类实例对象\"），且存在已确立的标准术语（如参考句中的\"普通对象\"）时触发。识别模式为检测到相邻段落/同一技术点描述中，对同一实体使用了超过1种命名表达方式。"
    },
    {
      "defect_id": 411003,
      "sentence": "TaskPool提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。",
      "reference_sentence": "TaskPool提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"ArkTS目前主要提供两种并发能力支持线程间通信：TaskPool和Worker。\",\"10\":\"\",\"11\":\"- Worker是Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。\",\"12\":\"\",\"13\":\"- TaskPool提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。\",\"14\":\"\",\"15\":\"基于ArkTS提供的TaskPool和Worker并发接口，支持多种线程间通信能力，可以满足开发者的不同[线程间通信场景](independent-time-consuming-task.md)。如独立的耗时任务、多个耗时任务、TaskPool线程与宿主线程通信、Worker线程与宿主线程的异步通信、Worker同步调用宿主线程的接口等。同时，基于[Node-API](../napi/napi-introduction.md)提供的机制，C++线程可以跨线程调用ArkTS接口。\",\"16\":\"\",\"17\":\"图1 序列化反序列化原理图\",\"18\":\"\"}",
      "修改建议": "使用了“并发实例”和“并发任务”两个不同的术语描述同一概念",
      "更改后示例": "TaskPool提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发任务的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。",
      "触发条件": "同一文档中出现两个及以上不同术语指代同一核心概念，且上下文未明确说明术语等价性时触发。\n\n识别模式：\n1. 术语冲突检测：通过语义分析识别相邻段落中具有相同指代功能的专业术语（如\"并发实例\"与\"并发任务\"）\n2. 上下文一致性验证：检查问题术语是否与文档其他部分（如前置定义段落）的标准化术语（如\"并发任务\"）存在表述偏差\n3. 概念重复判定：确认不同术语描述的技术行为/机制在功能层面具有完全等价性（如都指代TaskPool中的可执行单元）"
    },
    {
      "defect_id": 411063,
      "sentence": "TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。",
      "reference_sentence": "在TaskPool中，传递ArrayBuffer数据时默认使用转移方式，原线程将无法再使用已传输给子线程的ArrayBuffer。在上文示例的基础上去除task.setTransferList接口调用，即在createImageTask的第二个参数传入true，就可以实现转移方式的传输。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"以下将通过案例分别介绍拷贝和转移两种方式，实现图片跨ArkTS线程传输。\",\"16\":\"\",\"17\":\"## ArrayBuffer拷贝传输方式\",\"18\":\"\",\"19\":\"在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。\",\"20\":\"\",\"21\":\"首先，实现一个处理ArrayBuffer的接口，该接口在Task中执行。\",\"22\":\"\",\"23\":\"然后，通过拷贝方式将ArrayBuffer数据传递到Task中，并处理。\",\"24\":\"\"}",
      "修改建议": "前后文对`TaskPool`传递ArrayBuffer数据时默认方式的描述不一致，前文称默认使用转移方式，后文也应保持一致。",
      "更改后示例": "在TaskPool中，传递ArrayBuffer数据时默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。",
      "触发条件": "同一术语或概念在相邻段落/同一主题下首次引入时句式结构不一致（如“在ArkTS中，TaskPool...” vs 直接使用“TaskPool...”），且存在前后默认行为描述需要保持统一的上下文。\n\n识别模式：\n1. 检测相邻段落中同一核心术语（如TaskPool）的引入句式差异\n2. 对比关键操作描述（如\"默认使用转移方式\"）在上下文中的表达一致性\n3. 验证是否存在同一技术点需要保持统一表达形式的语境（如跨线程数据传输机制说明）"
    },
    {
      "defect_id": 410716,
      "sentence": "不建议在父Worker发起销毁操作的执行阶段创建子Worker。在创建子Worker线程之前，需确保父Worker线程始终处于存活状态，不建议在不确定父Worker是否发起销毁操作的情况下创建子Worker。",
      "reference_sentence": "如果销毁父Worker时未能终止其子Worker的运行，可能会导致不可预期的结果。因此需确保子Worker的生命周期在父Worker生命周期范围内，销毁父Worker前，先销毁所有子Worker。",
      "line_num": 516,
      "context": "{\"511\":\"  }, 1000);\",\"512\":\"}\",\"513\":\"```\",\"514\":\"<!-- @[not_recommended_example](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/entry/src/main/ets/notrecommendedoneworker/childworker.ets) -->\",\"515\":\"\",\"516\":\"不建议在父Worker发起销毁操作的执行阶段创建子Worker。在创建子Worker线程之前，需确保父Worker线程始终处于存活状态，不建议在不确定父Worker是否发起销毁操作的情况下创建子Worker。\",\"517\":\"\",\"518\":\"```ts\",\"519\":\"// main thread\",\"520\":\"import { worker, MessageEvents, ErrorEvent } from '@kit.ArkTS';\",\"521\":\"\"}",
      "修改建议": "前后描述矛盾，前文强调销毁父Worker前先销毁子Worker，而此处描述在父Worker发起销毁操作时创建子Worker。",
      "更改后示例": "不建议在父Worker发起销毁操作的执行阶段创建子Worker。在创建子Worker线程之前，需确保父Worker线程始终处于存活状态，建议在确定父Worker未发起销毁操作的情况下创建子Worker。",
      "触发条件": "当文档段落中连续出现双重否定建议（如\"不建议在不确定...情况下创建\"）导致语义矛盾，且与上下文生命周期管理要求（子Worker必须在父Worker存活期创建）产生逻辑冲突时触发。\n\n识别模式：1) 同一建议段落内存在\"不建议A\"与\"不建议非A\"的句式结构 2) 否定建议与上下文Worker生命周期管理规则形成矛盾（如允许在父Worker销毁阶段创建子Worker）3) 存在\"不确定...是否...\"的模糊表述与系统强约束要求冲突。"
    },
    {
      "defect_id": 412893,
      "sentence": "Sendable数据不能持有非Sendable数据，因此泛型类中的Sendable数据的模版类型必须是Sendable类型。",
      "reference_sentence": "Sendable数据不能持有非Sendable数据，因此Sendable类或接口的成员变量必须是[Sendable支持的数据类型](arkts-sendable.md#sendable支持的数据类型)。",
      "line_num": 200,
      "context": "{\"195\":\"\",\"196\":\"## 泛型规则\",\"197\":\"\",\"198\":\"### 泛型类中的Sendable类、SendableLruCache、collections.Array、collections.Map和collections.Set的模板类型必须是Sendable类型\",\"199\":\"\",\"200\":\"Sendable数据不能持有非Sendable数据，因此泛型类中的Sendable数据的模版类型必须是Sendable类型。\",\"201\":\"\",\"202\":\"**正例：**\",\"203\":\"\",\"204\":\"```ts\",\"205\":\"import { collections } from '@kit.ArkTS';\"}",
      "修改建议": "前后描述不一致，'成员变量'与'泛型数据的模版类型'不一致",
      "更改后示例": "Sendable数据不能持有非Sendable数据，因此泛型类中的Sendable数据的成员变量必须是Sendable类型。",
      "触发条件": "当文档中同一概念在相邻段落或规则描述中使用不同术语（如\"模版类型\"与\"成员变量\"），且与上下文已定义的规范术语（如参考句中的\"成员变量\"）产生逻辑矛盾时触发。"
    },
    {
      "defect_id": 410640,
      "sentence": "创建Worker的线程称为宿主线程（不局限于主线程，Worker线程也支持创建Worker子线程）。Worker子线程（或Actor线程、工作线程）是Worker自身运行的线程。",
      "reference_sentence": "创建Worker的线程称为宿主线程（不局限于主线程，Worker线程也支持创建Worker子线程）。Worker子线程是Worker自身运行的线程。",
      "line_num": 12,
      "context": "{\"7\":\"\",\"8\":\"**图1** Worker运作机制示意图\",\"9\":\"\",\"10\":\"![worker](figures/worker.png)\",\"11\":\"\",\"12\":\"创建Worker的线程称为宿主线程（不局限于主线程，Worker线程也支持创建Worker子线程）。Worker子线程（或Actor线程、工作线程）是Worker自身运行的线程。每个Worker子线程和宿主线程拥有独立的实例，包含独立执行环境、对象、代码段等。因此，启动每个Worker存在一定的内存开销，需要限制Worker子线程的数量。Worker子线程和宿主线程通过消息传递机制通信，利用序列化机制完成命令和数据的交互。\",\"13\":\"\",\"14\":\"\",\"15\":\"## Worker注意事项\",\"16\":\"\",\"17\":\"- 创建Worker时，提供手动和自动两种创建方式，推荐使用自动创建方式。手动创建Worker线程目录及文件时，需同步进行相关配置，具体要求请参阅[创建Worker的注意事项](#创建worker的注意事项)。\"}",
      "修改建议": "混用了“工作线程”和“Worker子线程”两个术语，建议统一使用“Worker子线程”。",
      "更改后示例": "创建Worker的线程称为宿主线程（不局限于主线程，Worker线程也支持创建Worker子线程）。Worker子线程是Worker自身运行的线程。",
      "触发条件": "同一概念在相邻或同一段落中混用多个不同术语（如别名、同义词），且未明确说明其等价性时触发。\n\n识别模式：检查括号内列举的多个术语（如“Worker子线程（或Actor线程、工作线程）”）是否在后续描述中未保持统一，或同一段落出现多个等价术语（如“Worker子线程”与“工作线程”交替出现）。"
    },
    {
      "defect_id": 417305,
      "sentence": "CommonJS与ES Module互相引用支持规格如下表所示，导入导出语法遵循各自模块的规范写法。",
      "reference_sentence": "CommonJS模块是JavaScript社区2009年提出的标准，首先在Node.js采用部分标准并实现。",
      "line_num": 50,
      "context": "{\"45\":\"> CommonJS模块仅适用于第三方包的导出，不支持在工程中创建和使用。\",\"46\":\"\",\"47\":\"\",\"48\":\"### CommonJS与ES Module支持规格\",\"49\":\"\",\"50\":\"CommonJS与ES Module互相引用支持规格如下表所示，导入导出语法遵循各自模块的规范写法。\",\"51\":\"| 互相引用关系 | ES Module 导出 | CommonJS导出 |\",\"52\":\"| -------- | -------- | -------- |\",\"53\":\"| **ES Module 导入** | 支持 | 支持 |\",\"54\":\"| **CommonJS导入** | 不支持 | 支持 |\",\"55\":\"\"}",
      "修改建议": "用词不一致，前文使用了'标准'，此处使用了'规格'",
      "更改后示例": "CommonJS与ES Module互相引用支持标准如下表所示，导入导出语法遵循各自模块的规范写法。",
      "触发条件": "同一文档中出现对同一技术概念的两种不同术语表述（如\"标准\"和\"规格\"），且该术语在上下文或参考句中有明确统一表述时。识别模式：当检测到核心技术名词（如模块规范）存在同义词替换风险，且该名词在相邻段落或技术定义句（如第45行）中已有标准化表述时触发。"
    },
    {
      "defect_id": 413009,
      "sentence": "1. 在TaskPool或Worker中使用类方法/Sendable函数。",
      "reference_sentence": "无",
      "line_num": 126,
      "context": "{\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\",\"128\":\"**装饰器修饰Class使用示例：**\",\"129\":\"\",\"130\":\"```ts\",\"131\":\"@Sendable\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "1. 在TaskPool或Worker中使用类方法和Sendable函数。",
      "触发条件": "当并列项使用不同连接符（如斜杠/与\"和\"）导致句式结构不一致，或描述建议时未保持统一祈使句结构。"
    },
    {
      "defect_id": 412975,
      "sentence": "默认情况下，Sendable数据在ArkTS并发实例间（包括UI主线程、TaskPool线程、Worker线程）传递的行为是引用传递。同时，ArkTS也支持Sendable数据在这些实例间拷贝传递。",
      "reference_sentence": "默认情况下，Sendable数据在ArkTS并发实例间（包括UI主线程、TaskPool线程、Worker线程）传递的行为是引用传递。同时，ArkTS也支持Sendable数据在这些实例间拷贝传递。",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"### Sendable协议\",\"20\":\"\",\"21\":\"Sendable协议定义了ArkTS的可共享对象体系及其规格约束。符合Sendable协议的数据（以下简称Sendable对象）可以在ArkTS并发实例间传递。\",\"22\":\"\",\"23\":\"默认情况下，Sendable数据在ArkTS并发实例间（包括UI主线程、TaskPool线程、Worker线程）传递的行为是引用传递。同时，ArkTS也支持Sendable数据在这些实例间拷贝传递。\",\"24\":\"\",\"25\":\"### ISendable\",\"26\":\"\",\"27\":\"在ArkTS语言基础库[@arkts.lang](../reference/apis-arkts/js-apis-arkts-lang.md)中引入了interface ISendable，没有任何必须的方法或属性。ISendable是所有Sendable类型（除了null和undefined）的父类型。ISendable主要用在开发者自定义Sendable数据结构的场景中。类装饰器[@Sendable装饰器](#sendable装饰器)是implement ISendable的语法糖。\",\"28\":\"\"}",
      "修改建议": "混用了'引用传递'与'拷贝传递'，应统一使用'引用传递'或'拷贝传递'。",
      "更改后示例": "默认情况下，Sendable数据在ArkTS并发实例间（包括UI主线程、TaskPool线程、Worker线程）传递的行为是引用传递。同时，ArkTS也支持Sendable数据在这些实例间复制传递。",
      "触发条件": "当同一文档中相邻或相近上下文出现同概念但使用不同术语（如\"拷贝传递\"与\"复制传递\"），且术语未被明确定义为不同技术含义时触发。识别模式为检测同一段落内对同一技术行为存在近义词交替使用（如\"拷贝\"与\"复制\"）且缺乏语义区分说明。"
    },
    {
      "defect_id": 412973,
      "sentence": "在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低并发通信开销。",
      "reference_sentence": "在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低并发通信开销。",
      "line_num": 4,
      "context": "{\"1\":\"# Sendable对象简介\",\"2\":\"\",\"3\":\"\",\"4\":\"在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低并发通信开销。但开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中未得到解决。\",\"5\":\"\",\"6\":\"ArkTS提供了Sendable对象类型，在并发通信时支持通过引用传递来解决上述问题。\",\"7\":\"\",\"8\":\"Sendable对象为可共享的，其跨线程前后指向同一个JS对象。如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。通信过程如下图所示：\",\"9\":\"\"}",
      "修改建议": "混用了'转移'与'共享'，应统一使用'转移'或'共享'。",
      "更改后示例": "在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移来降低并发通信开销。",
      "触发条件": "同一语境下出现多个同类型但互相替代的术语（如\"转移\"与\"共享\"），且上下文未明确区分其差异时；或同一技术概念存在两种及以上不一致的表达形式时。"
    },
    {
      "defect_id": 413003,
      "sentence": "仅支持在Stage模型的.ets文件中使用。",
      "reference_sentence": "无",
      "line_num": 120,
      "context": "{\"115\":\"声明并校验Sendable class以及Sendable function。\",\"116\":\"\",\"117\":\"| \\\\@Sendable装饰器 | 说明 |\",\"118\":\"| -------- | -------- |\",\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "仅在Stage模型的.ets文件中使用。",
      "触发条件": "当文档中出现描述功能限制或使用场景的陈述句式（如\"仅支持...\"），但上下文要求统一使用祈使句式（如\"仅在...\"）时触发。通过检测\"支持\"类动词与\"在\"类介词的结构差异进行识别。"
    },
    {
      "defect_id": 413005,
      "sentence": "Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。",
      "reference_sentence": "无",
      "line_num": 122,
      "context": "{\"117\":\"| \\\\@Sendable装饰器 | 说明 |\",\"118\":\"| -------- | -------- |\",\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "Sendable class只能继承Sendable class，普通Class不可继承Sendable class。",
      "触发条件": "同一结构内的并列规则描述存在句式不一致（如混合使用\"不可\"与\"不可以\"）或未统一使用祈使句结构时触发。\n\n识别模式：\n1. 检测同一语义层级下的并列短句（如表格条目、项目符号）\n2. 比对动词短语结构（\"不可\" vs \"不可以\"）、助词使用（\"只能\"需对应\"不可\"）及句式对称性\n3. 发现存在冗余语气词（如\"可以\"）破坏平行结构时判定违规"
    },
    {
      "defect_id": 413007,
      "sentence": "1. 成员属性必须显式初始化，不能使用感叹号。",
      "reference_sentence": "无",
      "line_num": 124,
      "context": "{\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\",\"128\":\"**装饰器修饰Class使用示例：**\",\"129\":\"\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "1. 成员属性显式初始化，不能使用感叹号。",
      "触发条件": "当文档条目中混合使用陈述句与祈使句结构，或出现\"必须\"\"应当\"等非必要助动词时触发。\n\n识别模式：\n1. 语法结构检测：识别句子是否包含隐性主语（如\"必须\"隐含主语），而非直接以动词开头的祈使句式\n2. 助动词筛查：检测\"必须/应当/需要\"等强制性助动词的存在\n3. 上下文对比：同一列表项中其他条目均采用无主语的祈使句结构时，差异项触发规则"
    },
    {
      "defect_id": 413004,
      "sentence": "仅支持装饰普通function和Async function类型。",
      "reference_sentence": "无",
      "line_num": 121,
      "context": "{\"116\":\"\",\"117\":\"| \\\\@Sendable装饰器 | 说明 |\",\"118\":\"| -------- | -------- |\",\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\",\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "仅装饰普通function和Async function类型。",
      "触发条件": "当文档中的说明性语句在相同语境下出现句式结构不一致（如陈述句与祈使句混用），且存在冗余动词（如\"支持\"）破坏动作描述的统一性时触发。\n\n识别模式：\n1. 检测技术文档中连续表格条目或并列说明项\n2. 对比相邻条目动词使用模式，识别出包含冗余辅助动词（如\"支持\"、\"可以\"）的陈述句式\n3. 验证上下文是否采用统一祈使句式（直接以动作动词开头，如\"允许/禁止/使用\"）\n4. 当存在句式差异且影响表述统一性时，触发修正建议"
    },
    {
      "defect_id": 412974,
      "sentence": "如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。",
      "reference_sentence": "如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。",
      "line_num": 8,
      "context": "{\"3\":\"\",\"4\":\"在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低并发通信开销。但开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中未得到解决。\",\"5\":\"\",\"6\":\"ArkTS提供了Sendable对象类型，在并发通信时支持通过引用传递来解决上述问题。\",\"7\":\"\",\"8\":\"Sendable对象为可共享的，其跨线程前后指向同一个JS对象。如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。通信过程如下图所示：\",\"9\":\"\",\"10\":\"![sendable](figures/sendable.png)\",\"11\":\"\",\"12\":\"与其它ArkTS数据对象不同，符合Sendable协议的数据对象在运行时应为类型固定的对象。\",\"13\":\"\"}",
      "修改建议": "混用了'直接共享'与'考虑线程安全性'，应统一表述。",
      "更改后示例": "如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要确保线程安全性。",
      "触发条件": "当同一段落中出现结构相似的并列句式时，若相邻分句的动词短语存在情态动词(如\"需要\"/\"可以\")与核心动词(如\"共享\"/\"确保\")的双重不匹配，且上下文存在明确的技术规范要求时触发。\n\n识别模式：\n1. 语法结构匹配：通过分号/句号分隔的相邻句子具有相同假设条件结构(\"如果...则...\")\n2. 动词短语异常：前句使用\"可以+动词短语\"，后句却使用\"需要+名词短语\"的不对称结构\n3. 语义关联性：分句讨论同一技术主题的不同实现场景(JS/Native)，存在表达逻辑的强关联性\n4. 规范要求检测：上下文存在技术规范类表述(如\"应为类型固定的对象\")，暗示需要严格统一表达"
    },
    {
      "defect_id": 417356,
      "sentence": "应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替[静态导入](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态导入的场景：",
      "reference_sentence": "应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替[静态导入](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态导入的场景：",
      "line_num": 6,
      "context": "{\"1\":\"# 动态加载\",\"2\":\"\",\"3\":\"动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块间只有变量动态import时还可以进行模块解耦。\",\"4\":\"\",\"5\":\"## 技术适用场景介绍\",\"6\":\"应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替[静态导入](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态导入的场景：\",\"7\":\"\",\"8\":\"* 当静态导入的模块明显降低了代码的加载速度且被使用的可能性低，或者并不需要马上使用它。\",\"9\":\"* 当静态导入的模块明显占用了大量的系统内存且被使用的可能性低。\",\"10\":\"* 当被导入的模块，在加载时并不存在，需要异步获取。\",\"11\":\"* 当被导入的模块说明符，需要动态构建。静态导入只能使用静态说明符。\"}",
      "修改建议": "“动态导入”与“动态import”混用，建议统一使用“动态import”。",
      "更改后示例": "应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态import代替[静态导入](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态import的场景：",
      "触发条件": "同一技术术语在相邻段落或同一技术说明中混用中英文表达形式（如\"动态导入\"与\"动态import\"交替出现），且上下文已存在明确术语使用先例（如前置说明已使用\"动态import\"）。"
    },
    {
      "defect_id": 417355,
      "sentence": "动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块间只有变量动态import时还可以进行模块解耦。",
      "reference_sentence": "动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块间只有变量动态import时还可以进行模块解耦。",
      "line_num": 3,
      "context": "{\"1\":\"# 动态加载\",\"2\":\"\",\"3\":\"动态import支持条件延迟加载，支持部分反射功能，可以提升页面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块间只有变量动态import时还可以进行模块解耦。\",\"4\":\"\",\"5\":\"## 技术适用场景介绍\",\"6\":\"应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替[静态导入](../quick-start/introduction-to-arkts.md#导入)。下面是可能会需要动态导入的场景：\",\"7\":\"\",\"8\":\"* 当静态导入的模块明显降低了代码的加载速度且被使用的可能性低，或者并不需要马上使用它。\"}",
      "修改建议": "“页面”与“界面”混用，建议统一使用“界面”。",
      "更改后示例": "动态import支持条件延迟加载，支持部分反射功能，可以提升界面的加载速度；动态import支持加载HSP模块/HAR模块/OHPM包/Native库等，并且HAR模块间只有变量动态import时还可以进行模块解耦。",
      "触发条件": "同一文档中针对同一概念或实体使用多个不同术语（如\"页面\"与\"界面\"混用），且存在已明确的统一用词规范时触发。识别模式需检测相邻段落/句子中同一语义实体的术语变异现象。"
    },
    {
      "defect_id": 412984,
      "sentence": "2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。",
      "reference_sentence": "Sendable class需同时满足以下两个规则：1. 当且仅当被标注了[@Sendable装饰器](#sendable装饰器)。2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"Sendable interface需同时满足以下两个规则：\",\"60\":\"\",\"61\":\"1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。\",\"62\":\"\",\"63\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"64\":\"\",\"65\":\"### Sendable支持的数据类型\",\"66\":\"\",\"67\":\"- ArkTS基本数据类型：boolean、number、string、bigint、null、undefined。\",\"68\":\"\"}",
      "修改建议": "与前文的表述不一致，应保持一致。",
      "更改后示例": "2. 需满足Sendable约束，具体可参考[Sendable使用规则](sendable-constraints.md)。",
      "触发条件": "当文档中存在多个结构/功能相似的条目时，若其中某个条目出现与前文相同语义但不同表述的动词短语（如\"可查\"与\"可参考\"）或连接词（如\"详情\"与\"具体\"），且上下文存在平行编号列表结构（如规则1/规则2）。"
    },
    {
      "defect_id": 417367,
      "sentence": "本地模块在依赖方的dependencies中配置的别名建议与moduleName以及packageName三者一致。moduleName指的是被依赖的HSP/HAR的module.json5中配置的名字，packageName指的是被依赖的HSP/HAR的oh-package.json5中配置的名字。",
      "reference_sentence": "本地模块在依赖方的dependencies中配置的别名建议与moduleName以及packageName三者一致。moduleName指的是被依赖的HSP/HAR的module.json5中配置的名字，packageName指的是被依赖的HSP/HAR的oh-package.json5中配置的名字。",
      "line_num": 92,
      "context": "{\"87\":\"| 模块Native库   | 动态import libNativeLibrary.so | -                                                        |\",\"88\":\"\",\"89\":\">**说明：**\",\"90\":\"> \",\"91\":\"> 1.当前所有import中使用的模块名是依赖方oh-package.json5的dependencies中的别名。\",\"92\":\"> 2.本地模块在依赖方的dependencies中配置的别名建议与moduleName以及packageName三者一致。moduleName指的是被依赖的HSP/HAR的module.json5中配置的名字，packageName指的是被依赖的HSP/HAR的oh-package.json5中配置的名字。\",\"93\":\"> 3.import一个模块名，实际的行为是import该模块的入口文件，一般为Index.ets/ts。\",\"94\":\"\",\"95\":\"## 动态import实现中的关键点\",\"96\":\"\",\"97\":\"### 动态import常量表达式\"}",
      "修改建议": "使用了不同的词“别名”和“别称”，建议统一。",
      "更改后示例": "本地模块在依赖方的dependencies中配置的别称建议与moduleName以及packageName三者一致。moduleName指的是被依赖的HSP/HAR的module.json5中配置的名字，packageName指的是被依赖的HSP/HAR的oh-package.json5中配置的名字。",
      "触发条件": "同一文档或上下文中，同一概念或术语被不一致的词汇（如“别名”与“别称”）交替使用，且存在明确关联的参考标准（如前后文已定义术语或技术规范要求）。  \n\n识别模式：  \n1. **术语冲突检测**：在相邻句子或同一技术描述中，出现同义词或近义词（如“别名”与“别称”）指代同一技术概念。  \n2. **上下文关联性**：需结合问题上下文（如参考句子中已统一使用“别名”）验证术语是否违背既定表达规范。"
    },
    {
      "defect_id": 413010,
      "sentence": "2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。",
      "reference_sentence": "无",
      "line_num": 126,
      "context": "{\"121\":\"| 装饰的函数类型限制 | 仅支持装饰普通function和Async function类型。 |\",\"122\":\"| 装饰的类继承关系限制 | Sendable class只能继承Sendable class，普通Class不可以继承Sendable class。 |\",\"123\":\"| 装饰的对象内的属性类型限制 | 1. 支持string、number、boolean、bigint、null、undefined、Sendable class、collections容器集、ArkTSUtils.locks.AsyncLock、ArkTSUtils.SendableLruCache以及自定义的Sendable函数类型。<br/>2. 禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。<br/>3. 不支持通过\\\\#定义私有属性，需用private。<br/>4. 不支持计算属性。 |\",\"124\":\"| 装饰的对象内的属性的其他限制 | 1. 成员属性必须显式初始化，不能使用感叹号。<br/>2. 不支持增加或删除属性，允许修改属性，修改前后属性的类型必须一致，不支持修改方法。|\",\"125\":\"| 装饰的函数或类对象内的方法参数限制 | 允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。 |\",\"126\":\"| 适用场景 | 1. 在TaskPool或Worker中使用类方法/Sendable函数。<br/>2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据改造后传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。 |\",\"127\":\"\",\"128\":\"**装饰器修饰Class使用示例：**\",\"129\":\"\",\"130\":\"```ts\",\"131\":\"@Sendable\"}",
      "修改建议": "句式不一致，不符合统一使用祈使句描述动作的规则。",
      "更改后示例": "2. 传输对象数据量较大的使用场景。序列化耗时会随着数据量增大而增大，使用Sendable对数据进行改造后，传输100KB数据时效率提升约20倍，传输1M数据时效率提升约100倍。",
      "触发条件": "同一列表项或上下文中存在多个动作描述，但部分句子的动作与结果之间缺少逗号分隔，导致祈使句结构不统一。  \n\n识别模式：检查连续动作描述中是否存在“后”字衔接却未使用逗号的情况（如“改造后传输”vs“改造后，传输”），并对比上下文条目是否采用统一逗号分隔结构。"
    },
    {
      "defect_id": 417381,
      "sentence": "但是，如果是变量动态import，该变量值可能需要进行运算或外部传入才能得到，在编译态无法解析其内容，也就无法加入编译。",
      "reference_sentence": "在编译期，静态import和常量动态import可以被打包工具rollup及其插件识别解析，加入依赖树中，参与编译流程，最终生成方舟字节码。",
      "line_num": 294,
      "context": "{\"289\":\"  ```\",\"290\":\"\",\"291\":\"### 动态import变量表达式\",\"292\":\"\",\"293\":\"DevEco Studio中模块间的依赖关系通过oh-package.json5中的dependencies进行配置。dependencies列表中所有模块默认都会进行安装（本地模块）或下载（远程模块），但是不会默认参与编译。HAP/HSP编译时会以入口文件（一般为Index.ets/ts）开始搜索依赖关系，搜索到的模块或文件才会加入编译。\",\"294\":\"在编译期，静态import和常量动态import可以被打包工具rollup及其插件识别解析，加入依赖树中，参与编译流程，最终生成方舟字节码。但是，如果是变量动态import，该变量值可能需要进行运算或外部传入才能得到，在编译态无法解析其内容，也就无法加入编译。为了将这部分模块/文件加入编译，还需要额外增加一个runtimeOnly的buildOption配置，用于配置动态import的变量实际的模块名或文件路径。\",\"295\":\"\",\"296\":\"**1. runtimeOnly字段schema配置格式**\",\"297\":\"\",\"298\":\"在HAP/HSP/HAR的build-profile.json5中的buildOption中增加runtimeOnly配置项，仅在通过变量动态import时配置，静态import和常量动态import无需配置；并且，通过变量动态import加载API时也无需配置runtimeOnly。如下实例说明如何配置通过变量动态import其他模块，以及变量动态import本模块自己的单文件：\",\"299\":\"\"}",
      "修改建议": "原文中使用了'加入编译'和'参与编译'两个不同的词汇描述同一操作（加入编译流程）。应统一用词以保持一致性。",
      "更改后示例": "但是，如果是变量动态import，该变量值可能需要进行运算或外部传入才能得到，在编译态无法解析其内容，也就无法加入编译流程。",
      "触发条件": "同一文档中出现多个不同术语描述同一操作（如\"加入编译\"和\"参与编译\"），且这些术语在相邻段落或同一概念上下文中交替出现时。"
    },
    {
      "defect_id": 417674,
      "sentence": "在native模块的index.d.ts文件中导出，在文件内直接导入。",
      "reference_sentence": "在native模块的index.d.ts文件中导出，在文件内直接导入。",
      "line_num": 6,
      "context": "{\"1\":\"# 静态方式加载native模块\",\"2\":\"\",\"3\":\"在ES6(ECMAScript6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义语法规则。为支持开发者使用该功能导入native模块（so）导出的内容，ArkTS进行了相关适配，并提供了以下几种支持写法。\",\"4\":\"\",\"5\":\"## 直接导入\",\"6\":\"在native模块的index.d.ts文件中导出，在文件内直接导入。\",\"7\":\"\",\"8\":\"### 具名导入\",\"9\":\"```ts\",\"10\":\"// libentry.so对应的index.d.ts\",\"11\":\"export const add: (a: number, b: number) => number;\"}",
      "修改建议": "句子本身没有问题，但为了统一句式，建议使用祈使句",
      "更改后示例": "在native模块的index.d.ts文件中导出，并在文件内直接导入。",
      "触发条件": "当文档中的指导性句子包含多个并列动作描述但句式结构不一致（如部分分句为祈使句而其他分句为陈述句），且上下文要求统一使用祈使句时触发。识别模式需检测同一句子内是否存在连词（如“并”）连接的动词短语结构不对称，或分句间语气不匹配的情况。"
    },
    {
      "defect_id": 417473,
      "sentence": "- 使用lazy特性导致模块未执行，从而引发bug。",
      "reference_sentence": "- 使用延迟加载特性导致模块未执行，从而引发bug。",
      "line_num": 217,
      "context": "{\"212\":\"\",\"213\":\"### 开发者应评估使用延迟加载可能产生的影响\",\"214\":\"\",\"215\":\"- 不依赖该模块执行的副作用（如初始化全局变量，挂载globalThis等）。可参考：[模块加载副作用及优化](./arkts-module-side-effects.md)。\",\"216\":\"- 使用导出对象时，触发延迟加载的耗时导致对应特性的功能劣化。\",\"217\":\"- 使用lazy特性导致模块未执行，从而引发bug。\",\"218\":\"\",\"219\":\"## 可延迟加载文件检测\",\"220\":\"\",\"221\":\"本工具用于应用开发时本地检测冷启动文件加载情况，可打印应用启动后固定时间段内使用和未使用的文件名，帮助开发者筛选可延迟加载的文件。  \",\"222\":\"\"}",
      "修改建议": "混用了“lazy特性”和“延迟加载特性”术语",
      "更改后示例": "- 使用延迟加载特性导致模块未执行，从而引发bug。",
      "触发条件": "同一文档中对同一技术概念使用了不同术语（如中英文混用或同义词交替），且上下文已存在统一的标准术语。  \n\n识别模式：  \n1. 检测相邻段落或同一列表中是否已明确使用某一标准术语（如“延迟加载”）。  \n2. 对比问题句中的术语（如“lazy特性”）与标准术语是否指向同一技术点但表达不一致。"
    },
    {
      "defect_id": 417673,
      "sentence": "在ES6(ECMAScript6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义语法规则。",
      "reference_sentence": "在ES6(ECMAScript 6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义的语法规则。",
      "line_num": 3,
      "context": "{\"1\":\"# 静态方式加载native模块\",\"2\":\"\",\"3\":\"在ES6(ECMAScript6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义语法规则。为支持开发者使用该功能导入native模块（so）导出的内容，ArkTS进行了相关适配，并提供了以下几种支持写法。\",\"4\":\"\",\"5\":\"## 直接导入\",\"6\":\"在native模块的index.d.ts文件中导出，在文件内直接导入。\",\"7\":\"\",\"8\":\"### 具名导入\"}",
      "修改建议": "ECMAScript6.0 和 ECMAScript 6.0 用词不一致",
      "更改后示例": "在ES6(ECMAScript 6.0)模块设计中，使用import语法加载其他文件导出的内容是ECMA规范所定义的语法规则。",
      "触发条件": "同一术语在文档中存在不一致的版本号格式（如“ECMAScript6.0”与“ECMAScript 6.0”），或同一概念出现多种拼写变体（如缩写与全称混用未统一）。通过检测术语中的数字空格、大小写、连字符等格式差异，结合上下文重复出现的同一术语进行对比识别。"
    },
    {
      "defect_id": 417527,
      "sentence": "在Index文件执行时，B文件的导出函数func被顶层执行，因此B文件的导出是无法优化的，在工具侧就会显示used。但是A文件的导出变量a在Index文件的myFunc函数被调用时才使用，如果冷启动阶段，没有其他文件调用myFunc函数，那么B文件在工具侧就会显示unused，即可以延迟加载。",
      "reference_sentence": "在Index文件执行时，B文件的导出函数func被顶层执行，因此B文件的导出是无法优化的，在工具侧就会显示used。但是A文件的导出变量a在Index文件的myFunc函数被调用时才使用，如果冷启动阶段没有其他文件调用myFunc函数，那么A文件在工具侧就会显示unused，即可以延迟加载。",
      "line_num": 281,
      "context": "{\"276\":\"\",\"277\":\"### 检测原理\",\"278\":\"\",\"279\":\"如下例所示，A文件，B文件，同时被Index文件依赖，那么A、B会随着Index文件的加载被直接加载执行。  \",\"280\":\"A文件执行过程完成了变量定义赋值并进行导出，对应A文件的耗时。B文件定义了一个函数并导出，对应B文件的耗时。  \",\"281\":\"在Index文件执行时，B文件的导出函数func被顶层执行，因此B文件的导出是无法优化的，在工具侧就会显示used。但是A文件的导出变量a在Index文件的myFunc函数被调用时才使用，如果冷启动阶段，没有其他文件调用myFunc函数，那么B文件在工具侧就会显示unused，即可以延迟加载。\",\"282\":\"\",\"283\":\" ```ts\",\"284\":\"// Index.ets\",\"285\":\"import { a } from './A';\",\"286\":\"import { func } from './B';\"}",
      "修改建议": "句子中的“B文件”与“那么B文件”不一致，且标点符号不一致",
      "更改后示例": "在Index文件执行时，B文件的导出函数func被顶层执行，因此B文件的导出是无法优化的，在工具侧就会显示used。但是A文件的导出变量a在Index文件的myFunc函数被调用时才使用，如果冷启动阶段没有其他文件调用myFunc函数，那么A文件在工具侧就会显示unused，即可以延迟加载。",
      "触发条件": "当同一段落内存在多个被讨论实体（如A、B文件）时，后续描述出现实体引用错位（如将A文件行为误标为B文件），或相邻句子间标点符号用法（如逗号位置）存在不一致。"
    },
    {
      "defect_id": 418793,
      "sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "reference_sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "line_num": 185,
      "context": "{\"180\":\"| 原生API方法 | ArkTS容器集方法 | 是否有行为差异 | 在ArkTS容器中的差异表现 |\",\"181\":\"| -------- | -------- | -------- | -------- |\",\"182\":\"| readonly size: number | readonly size: number | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"183\":\"| clear(): void | clear(): void | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"184\":\"| delete(key: K): boolean | delete(key: K): boolean | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"185\":\"| forEach(callbackfn: (value: V, key: K, map: Map&lt;K, V&gt;) =&gt; void, thisArg?: any): void | forEach(callbackFn: (value: V, key: K, map: Map&lt;K, V&gt;) =&gt; void): void | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。 |\",\"186\":\"| get(key: K): V \\\\| undefined | get(key: K): V \\\\| undefined | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"187\":\"| has(key: K): boolean | has(key: K): boolean | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"188\":\"| set(key: K, value: V): this | set(key: K, value: V): Map&lt;K, V&gt; | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"189\":\"| entries(): IterableIterator&lt;[K, V]&gt; | entries(): IterableIterator&lt;[K, V]&gt; | 否 | / |\",\"190\":\"| keys(): IterableIterator&lt;K&gt; | keys(): IterableIterator&lt;K&gt; | 否 | / |\"}",
      "修改建议": "前后描述不一致，应使用一致的描述方式",
      "更改后示例": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "触发条件": "同一上下文或相邻条目中存在结构相似但标点使用（如逗号缺失）或连接词（如\"因此\"）不一致的描述，导致表述模式不统一。"
    },
    {
      "defect_id": 418633,
      "sentence": "阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）",
      "reference_sentence": "异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题",
      "line_num": 5,
      "context": "{\"1\":\"# 异步锁\",\"2\":\"\",\"3\":\"为了解决多线程并发实例间的数据竞争问题，ArkTS引入了异步锁能力。异步锁可能会被类对象持有，因此为了更方便地在并发实例间获取同一个异步锁对象，[AsyncLock对象](../reference/apis-arkts/js-apis-arkts-utils.md#asynclock)支持跨线程引用传递。\",\"4\":\"\",\"5\":\"由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）。同时，异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题。\",\"6\":\"\",\"7\":\"更多异步锁相关接口，请参见[异步锁ArkTSUtils.locks](../reference/apis-arkts/js-apis-arkts-utils.md#arktsutilslocks)。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\"}",
      "修改建议": "混用了“死锁”和“同步问题”两个术语，应该使用一致的术语来描述相同的概念",
      "更改后示例": "阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）。同时，异步锁还可以用于保证单线程内的异步任务时序一致性，防止死锁问题。",
      "触发条件": "同一上下文或相邻段落中，对相同概念或问题类型使用不一致的术语描述（如\"死锁\"与\"同步问题\"混用），且术语存在语义重叠或因果关系关联。\n\n识别模式：\n1. 定位具有逻辑关联的相邻句子（如因果句、并列句）\n2. 检测关键问题描述术语（如\"死锁\"）是否在后续说明中被替换为其他术语（如\"同步问题\"）\n3. 验证替换术语是否属于同一问题域且存在概念交叉（如死锁属于同步问题的子类）\n4. 检查是否存在术语混用导致的表意模糊或逻辑断裂（如用上位概念替换下位概念）"
    },
    {
      "defect_id": 417542,
      "sentence": "在冷启动阶段，导出内容没有被其他文件使用的文件，代表可以延迟加载。",
      "reference_sentence": "在冷启动阶段，导出内容没有被其他文件使用的文件称为used file。",
      "line_num": 395,
      "context": "{\"390\":\"    parentModule 1: EntryPoint\",\"391\":\"    ```\",\"392\":\"\",\"393\":\"### 未被使用文件\",\"394\":\"\",\"395\":\"在冷启动阶段，导出内容没有被其他文件使用的文件，代表可以延迟加载。  \",\"396\":\"场景与被使用文件场景一致，但未被使用文件没有变量被使用信息。\",\"397\":\"\",\"398\":\"- 场景：文件被这些父文件引用，但是变量没有被使用到。可在引入未使用文件处（父文件）使用延迟加载方式加载该文件。\",\"399\":\"\",\"400\":\"    ```text\"}",
      "修改建议": "用词不一致，'used file'和'可以延迟加载'混用。",
      "更改后示例": "在冷启动阶段，导出内容没有被其他文件使用的文件称为未使用的文件，代表可以延迟加载。",
      "触发条件": "当同一概念在相邻语句中出现术语混用（如定义性表述与特征性描述交替使用），且上下文存在已明确定义的专用术语时。识别模式为检查核心概念是否在首次定义后出现非等效替换（如用\"可以延迟加载\"替代已定义的\"未使用的文件\"），且替换导致逻辑链条断裂。"
    },
    {
      "defect_id": 418732,
      "sentence": "ASON.parse默认生成的对象为Sendable对象，布局不可变，不支持增删属性。如果需要支持返回对象的布局可变，可以指定返回类型为MAP，此时会全部返回[collections.Map](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsmap)对象，支持增删属性。",
      "reference_sentence": "ASON.parse默认生成的对象为Sendable对象，布局不可变，不支持增删属性。如果需要支持返回对象的布局可变，可以指定返回类型为Map，此时会全部返回[collections.Map](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsmap)对象，支持增删属性。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"ASON.stringify方法还支持将Map和Set对象转换为字符串，可转换的Map和Set类型包括：Map、Set、[collections.Map](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsmap)、[collections.Set](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsset)、[HashMap](../reference/apis-arkts/js-apis-hashmap.md#hashmap)、[HashSet](../reference/apis-arkts/js-apis-hashset.md#hashset)。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> ASON.parse默认生成的对象为Sendable对象，布局不可变，不支持增删属性。如果需要支持返回对象的布局可变，可以指定返回类型为MAP，此时会全部返回[collections.Map](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsmap)对象，支持增删属性。\",\"10\":\"\",\"11\":\"## 使用示例\",\"12\":\"\",\"13\":\"使用ASON提供的接口，对[Sendable对象](arkts-sendable.md)进行序列化、反序列化。\",\"14\":\"\"}",
      "修改建议": "混用了`MAP`和`Map`，术语大小写不一致",
      "更改后示例": "ASON.parse默认生成的对象为Sendable对象，布局不可变，不支持增删属性。如果需要支持返回对象的布局可变，可以指定返回类型为Map，此时会全部返回[collections.Map](../reference/apis-arkts/js-apis-arkts-collections.md#collectionsmap)对象，支持增删属性。",
      "触发条件": "当同一术语在相邻段落或上下文中存在大小写不一致（如MAP与Map混用），且参考文档已确立特定大小写形式（如Map）时触发。识别模式需检测代码术语在文档中的拼写一致性，对比上下文及API引用中的标准形式。"
    },
    {
      "defect_id": 418651,
      "sentence": "ArkTS引入了异步等待通知能力，以解决多线程任务时序控制问题。异步等待通知[ConditionVariable](../reference/apis-arkts/js-apis-arkts-utils.md#conditionvariable18)对象支持跨线程引用传递。",
      "reference_sentence": "由于ArkTS语言支持异步操作，现在增加了异步任务的等待和被唤醒功能。当收到唤醒通知或等待超时后，异步任务将继续执行。",
      "line_num": 3,
      "context": "{\"1\":\"# 异步等待\",\"2\":\"\",\"3\":\"ArkTS引入了异步等待通知能力，以解决多线程任务时序控制问题。异步等待通知[ConditionVariable](../reference/apis-arkts/js-apis-arkts-utils.md#conditionvariable18)对象支持跨线程引用传递。\",\"4\":\"\",\"5\":\"由于ArkTS语言支持异步操作，现在增加了异步任务的等待和被唤醒功能。当收到唤醒通知或等待超时后，异步任务将继续执行。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\"}",
      "修改建议": "混用了'异步等待通知'和'异步任务的等待和被唤醒'概念",
      "更改后示例": "ArkTS引入了异步任务的等待和被唤醒能力，以解决多线程任务时序控制问题。异步任务的等待和被唤醒[ConditionVariable](../reference/apis-arkts/js-apis-arkts-utils.md#conditionvariable18)对象支持跨线程引用传递。",
      "触发条件": "同一技术概念在相邻段落或同一文档中使用了两种以上不同表述，且存在已明确定义的参考术语（如上下文中的\"异步任务的等待和被唤醒\"）时触发。具体表现为核心术语结构不一致（如\"异步等待通知\" vs \"异步任务的等待和被唤醒\"），且关联相同技术对象（如ConditionVariable）。"
    },
    {
      "defect_id": 418634,
      "sentence": "使用异步锁的方法需标记为async，调用时需用await修饰，以确保时序正确",
      "reference_sentence": "异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"更多异步锁相关接口，请参见[异步锁ArkTSUtils.locks](../reference/apis-arkts/js-apis-arkts-utils.md#arktsutilslocks)。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> 使用异步锁的方法需标记为async，调用时需用await修饰，以确保时序正确。\",\"12\":\"\",\"13\":\"## 使用示例\",\"14\":\"\",\"15\":\"为了防止[@Sendable共享对象](arkts-sendable.md)在不同线程修改共享变量导致的竞争问题，可以使用异步锁保护数据。示例如下：\",\"16\":\"\"}",
      "修改建议": "混用了“时序正确”和“时序一致性”两个术语，应该使用一致的术语来描述相同的概念",
      "更改后示例": "使用异步锁的方法需标记为async，调用时需用await修饰，以确保时序一致性。",
      "触发条件": "同一文档或上下文中，针对同一技术概念（如\"时序一致性\"）出现多个不同术语表述（如\"时序正确\"和\"时序一致性\"混用）时触发。\n\n识别模式：\n1. 通过NLP检测同段落/章节内描述同一技术概念的术语变体\n2. 对比文档已有规范术语（如参考句中的\"时序一致性\"）与当前用词的一致性\n3. 识别近义词/相似概念短语（如\"正确\"与\"一致性\"）在相同上下文中的混用情况"
    },
    {
      "defect_id": 418745,
      "sentence": "ArkTS提供了Sendable数据相关的共享容器集，接口行为与原生API存在部分差异，具体可见下文对比。",
      "reference_sentence": "功能与Ecmascript262规范定义的容器类似，但仍然有部分差异，具体可见[共享容器与原生API方法的行为差异对比](#共享容器与原生API方法的行为差异对比)。",
      "line_num": 64,
      "context": "{\"59\":\"```\",\"60\":\"<!-- @[example_use](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationObjects/SendableObject/SendableObjectRelated/entry/src/main/ets/managers/ArktsCollectionsIntroduction.ets) -->\",\"61\":\"\",\"62\":\"## 共享容器与原生API方法的行为差异对比\",\"63\":\"\",\"64\":\"ArkTS提供了Sendable数据相关的共享容器集，接口行为与原生API存在部分差异，具体可见下文对比。\",\"65\":\"\",\"66\":\"> **说明：**\",\"67\":\">\",\"68\":\"> ArkTS共享容器的类型与Ecmascript262规范定义的原生容器的类型不同，因此使用原生容器Array的isArray()方法判断collections.Array实例对象会返回false。\",\"69\":\">\"}",
      "修改建议": "原文中使用了“原生API方法”，但在问题句子中混用了“原生API”，大小写不一致。",
      "更改后示例": "ArkTS提供了Sendable数据相关的共享容器集，接口行为与原生API方法存在部分差异，具体可见下文对比。",
      "触发条件": "同一术语在文档中存在不一致的表达形式（如“原生API”与“原生API方法”混用），且上下文已明确其标准形式（如标题或参考句中的固定表述）。需通过术语完整性（如是否包含后缀词）或格式（如大小写）匹配上下文进行识别。"
    },
    {
      "defect_id": 418794,
      "sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "reference_sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "line_num": 202,
      "context": "{\"197\":\"| -------- | -------- | -------- | -------- |\",\"198\":\"| readonly size: number | readonly size: number | 是 | Sendable类和接口中不允许使用计算属性名称(arkts-sendable-compated-prop-name)。 |\",\"199\":\"| add(value: T): this | add(value: T): Set&lt;T&gt; | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"200\":\"| clear(): void | clear(): void | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"201\":\"| delete(value: T): boolean | delete(value: T): boolean | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"202\":\"| forEach(callbackfn: (value: T, value2: T, set: Set&lt;T&gt;) =&gt; void, thisArg?: any): void | forEach(callbackFn: (value: T, value2: T, set: Set&lt;T&gt;) =&gt; void): void | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。 |\",\"203\":\"| has(value: T): boolean | has(value: T): boolean | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"204\":\"| entries(): IterableIterator&lt;[T, T]&gt; | entries(): IterableIterator&lt;[T, T]&gt; | 否 | / |\",\"205\":\"| keys(): IterableIterator&lt;T&gt; | keys(): IterableIterator&lt;T&gt; | 否 | / |\",\"206\":\"| values(): IterableIterator&lt;T&gt; | values(): IterableIterator&lt;T&gt; | 是 | Sendable类和接口中不允许使用计算属性名称(arkts-sendable-compated-prop-name)。 |\",\"207\":\"| new &lt;T = any&gt;(values?: readonly T[] \\\\| null): Set&lt;T&gt; | constructor(values?: readonly T[] \\\\| null) | 是 | 构造时传入的数据必须是Sendable类型，否则编译会报错。 |\"}",
      "修改建议": "前后描述不一致，应使用一致的描述方式",
      "更改后示例": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。",
      "触发条件": "当同一文档中存在多个相同类型的警告或说明语句，但标点使用或句式结构不一致时；或当相邻条目使用相同语义表达但存在语法结构差异时。\n\n识别模式：通过对比上下文相似功能的描述语句，检查是否存在标点缺失（如缺少逗号分隔结果状语）、句式不统一（如\"因此\"与\"所以\"混用）、逻辑连接词缺失等问题，重点检测重复出现的固定表达模式是否保持完全一致。"
    },
    {
      "defect_id": 418785,
      "sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。",
      "reference_sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。",
      "line_num": 159,
      "context": "{\"154\":\"| set(array: ArrayLike&lt;number&gt;, offset?: number): void | set(array: ArrayLike&lt;number&gt;, offset?: number): void | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"155\":\"| slice(start?: number, end?: number): Int8Array | slice(start?: number, end?: number): Int8Array | 否 | / |\",\"156\":\"| some(predicate: (value: number, index: number, array: Int8Array) =&gt; unknown, thisArg?: any): boolean | some(predicate: TypedArrayPredicateFn&lt;number, Int8Array&gt;): boolean | 是 | ArkTS不支持this，因此不支持thisArg参数。 |\",\"157\":\"| sort(compareFn?: (a: number, b: number) =&gt; number): this | sort(compareFn?: TypedArrayCompareFn&lt;number&gt;): Int8Array | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. 继承场景下，无法获得实际类型的返回值。 |\",\"158\":\"| subarray(begin?: number, end?: number): Int8Array | subarray(begin?: number, end?: number): Int8Array | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"159\":\"| [index: number]: number | [index: number]: number | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"160\":\"| entries(): IterableIterator&lt;[number, number]&gt; | entries(): IterableIterator&lt;[number, number]&gt; | 否 | / |\",\"161\":\"| keys(): IterableIterator&lt;number&gt; | keys(): IterableIterator&lt;number&gt; | 否 | / |\",\"162\":\"| values(): IterableIterator&lt;number&gt; | values(): IterableIterator&lt;number&gt; | 否 | / |\",\"163\":\"| includes(searchElement: number, fromIndex?: number): boolean | includes(searchElement: number, fromIndex?: number): boolean | 否 | / |\",\"164\":\"| at(index: number): number \\\\| undefined | at(index: number): number \\\\| undefined | 否 | / |\"}",
      "修改建议": "缺少逗号，导致句子不流畅。",
      "更改后示例": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。",
      "触发条件": "当复合句中\"否则\"作为结果分句的连词出现，且其前缺少必要逗号分隔时；或当技术文档中出现\"不允许...操作否则...\"的固定表述结构时。\n\n识别模式：1.检测\"否则\"前是否存在逗号缺失 2.识别\"不允许...操作\"与\"否则会...\"之间的逻辑承接关系 3.匹配技术规范中常见的操作限制+异常结果表达句式"
    },
    {
      "defect_id": 417400,
      "sentence": "变量动态import加载API时无需配置runtimeOnly。",
      "reference_sentence": "通过变量动态import加载API时也无需配置runtimeOnly。",
      "line_num": 537,
      "context": "{\"532\":\"  packageName = '@ohos.matrix4';\",\"533\":\"  import(packageName).then((ns:ESObject) => { ns.default.identity(); });\",\"534\":\"  packageName = '@ohos.hilog';\",\"535\":\"  import(packageName).then((ns:ESObject) => { ns.default.info(0x0000, 'testTag', '%{public}s', 'DynamicImport @ohos.hilog.'); });\",\"536\":\"  ```\",\"537\":\"变量动态import加载API时无需配置runtimeOnly。\",\"538\":\"\",\"539\":\"### HAR模块间动态import依赖解耦\",\"540\":\"当应用包含多个HAR包，且HAR包之间依赖关系比较复杂。在DevEco Studio中配置依赖关系时，可能会形成循环依赖。这时，如果HAR之间的依赖关系中仅有变量动态import，可以将HAR包之间直接依赖关系转移到HAP/HSP中配置，HAR包之间无需配置依赖关系，从而达到HAR包间依赖解耦的目的。如下示意图：\",\"541\":\"\",\"542\":\"![变量动态import HAR包形成循环依赖](figures/dynamicimport1.png)\"}",
      "修改建议": "前后文不一致，前文提到通过变量动态import加载API时也无需配置runtimeOnly，而此处省略了“通过”一词。",
      "更改后示例": "通过变量动态import加载API时无需配置runtimeOnly。",
      "触发条件": "当当前句子与同一文档中先前出现的相同主题句子在关键介词、动词或句式结构上存在不一致（如省略\"通过\"等连接词），且该差异导致上下文表达逻辑不连贯时触发。\n\n识别模式：\n1. 检测相邻段落或相同章节中是否存在同主题的参考句式（如\"通过变量动态import...\"）；\n2. 对比当前句子是否缺失参考句式中的关键连接词或修饰语；\n3. 验证缺失元素是否影响技术描述的准确性或造成理解歧义。"
    },
    {
      "defect_id": 418779,
      "sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。",
      "reference_sentence": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。",
      "line_num": 140,
      "context": "{\"135\":\"| readonly buffer: ArrayBufferLike | readonly buffer: ArrayBuffer | 否 | / |\",\"136\":\"| readonly byteLength: number | readonly byteLength: number | 否 | / |\",\"137\":\"| readonly byteOffset: number | readonly byteOffset: number | 否 | / |\",\"138\":\"| readonly length: number | readonly length: number | 否 | / |\",\"139\":\"| readonly BYTES_PER_ELEMENT: number | static readonly BYTES_PER_ELEMENT: number | 否 | / |\",\"140\":\"| copyWithin(target: number, start: number, end?: number): this | copyWithin(target: number, start: number, end?: number): Int8Array | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"141\":\"| every(predicate: (value: number, index: number, array: Int8Array) =&gt; unknown, thisArg?: any): boolean | every(predicate: TypedArrayPredicateFn&lt;number, Int8Array&gt;): boolean | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。 |\",\"142\":\"| fill(value: number, start?: number, end?: number): this | fill(value: number, start?: number, end?: number): Int8Array | 是 | 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。 |\",\"143\":\"| filter(predicate: (value: number, index: number, array: Int8Array) =&gt; any, thisArg?: any): Int8Array | filter(predicate: TypedArrayPredicateFn&lt;number, Int8Array&gt;): Int8Array | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。 |\",\"144\":\"| find(predicate: (value: number, index: number, obj: Int8Array) =&gt; boolean, thisArg?: any): number \\\\| undefined | find(predicate: TypedArrayPredicateFn&lt;number, Int8Array&gt;): number \\\\| undefined | 是 | 1. 不允许在遍历、访问过程中进行元素的增、删、改操作否则会抛出异常。<br/>2. ArkTS不支持this，因此不支持thisArg参数。 |\",\"145\":\"| findIndex(predicate: (value: number, index: number, obj: Int8Array) =&gt; boolean, thisArg?: any): number | findIndex(predicate: TypedArrayPredicateFn&lt;number, Int8Array&gt;): number | 是 | ArkTS不支持this，因此不支持thisArg参数。 |\"}",
      "修改建议": "缺少逗号，导致句子不流畅。",
      "更改后示例": "1. 不允许在遍历、访问过程中进行元素的增、删、改操作，否则会抛出异常。",
      "触发条件": "当复合句中存在因果/条件关系连接词（如\"否则\"）且其前缺少必要逗号时，或同一句式结构在文档中重复出现但标点使用不一致时。  \n\n识别模式：检测\"否则/因此/所以\"等连接词前是否缺少逗号分隔，对比上下文相似句式标点使用是否统一。"
    },
    {
      "defect_id": 417526,
      "sentence": "如下例所示，A文件，B文件，同时被Index文件依赖，那么A、B会随着Index文件的加载被直接加载执行。",
      "reference_sentence": "如下例所示，A文件和B文件同时被Index文件依赖，那么A、B会随着Index文件的加载被直接加载执行。",
      "line_num": 279,
      "context": "{\"274\":\"子线程文件名：data/app/el2/100/base/com.example.myapplication/files/com.example.myapplication_18089_redundant_file.txt  \",\"275\":\"![deferrable-tool-file](figures/deferrable-tool-file.png)\",\"276\":\"\",\"277\":\"### 检测原理\",\"278\":\"\",\"279\":\"如下例所示，A文件，B文件，同时被Index文件依赖，那么A、B会随着Index文件的加载被直接加载执行。  \",\"280\":\"A文件执行过程完成了变量定义赋值并进行导出，对应A文件的耗时。B文件定义了一个函数并导出，对应B文件的耗时。  \",\"281\":\"在Index文件执行时，B文件的导出函数func被顶层执行，因此B文件的导出是无法优化的，在工具侧就会显示used。但是A文件的导出变量a在Index文件的myFunc函数被调用时才使用，如果冷启动阶段，没有其他文件调用myFunc函数，那么B文件在工具侧就会显示unused，即可以延迟加载。\",\"282\":\"\",\"283\":\" ```ts\",\"284\":\"// Index.ets\"}",
      "修改建议": "使用了不同的标点符号和连接词，影响句子的一致性",
      "更改后示例": "如下例所示，A文件和B文件同时被Index文件依赖，那么A、B会随着Index文件的加载被直接加载执行。",
      "触发条件": "当同一句子或相邻上下文中出现同类元素列举时，存在连接词（如\"和\"/\"或\"）与标点符号（如逗号/顿号）混用的情况，或同一语义结构出现表达方式不一致时。\n\n识别模式：\n1. 检测并列结构中连接符号的连续性：如原句\"A文件，B文件，同时被...\"使用逗号分隔+无连接词，而参考句\"A文件和B文件同时被...\"使用\"和\"连接\n2. 对比相邻句子的表达范式：如后文\"对应A文件的耗时。B文件定义了...\"保持单数表达，需确保前文列举结构与其保持标点一致性\n3. 识别冗余标点：原句在\"同时被\"前插入多余逗号，破坏\"主语+状语\"结构的连贯性"
    },
    {
      "defect_id": 419010,
      "sentence": "2. 在意图中使用实体。例如，原先定义的entry类型意图如下：",
      "reference_sentence": "2. 在意图中使用实体。例如，原先定义的entry类型意图如下：",
      "line_num": 61,
      "context": "{\"56\":\"  city?: string = '';\",\"57\":\"  name: string = '';\",\"58\":\"}\",\"59\":\"```\",\"60\":\"\",\"61\":\"2. 在意图中使用实体。例如，原先定义的entry类型意图如下：\",\"62\":\"\",\"63\":\"```ts\",\"64\":\"import { insightIntent, InsightIntentEntry, InsightIntentEntryExecutor } from '@kit.AbilityKit';\",\"65\":\"import { hilog } from '@kit.PerformanceAnalysisKit';\",\"66\":\"\"}",
      "修改建议": "术语 '实体' 和 '意图实体' 混用",
      "更改后示例": "2. 在意图中使用意图实体。例如，原先定义的entry类型意图如下：",
      "触发条件": "当同一术语在文档中存在两种及以上表述形式（如\"实体\"和\"意图实体\"），且这些表述出现在相同语义场景（如意图定义上下文）时触发。识别模式需检测相邻段落/代码示例中是否已建立特定术语规范（如\"意图实体\"），并与当前表述形成概念冲突。"
    },
    {
      "defect_id": 419976,
      "sentence": "开启混淆后，需要根据不同的混淆规则去配置白名单。白名单的配置方式可以参考[保留选项](source-obfuscation.md#保留选项)。",
      "reference_sentence": "开发者还可以使用`#`在混淆规则文件中进行注释，每行以`#`开头的文本会被当做是注释。",
      "line_num": 50,
      "context": "{\"45\":\"    >\",\"46\":\"    > 1. 在DevEco Studio5.0.3.600之前，新建工程的默认设置是开启代码混淆，自动对API 10及更高版本的Stage模型进行混淆。\",\"47\":\"    > 2. 在DevEco Studio5.0.3.600及之后，新建工程的默认设置为关闭代码混淆。若需开启混淆，需将模块的`build-profile.json5`文件的`ruleOptions.enable`字段设置为true。同时混淆规则配置文件`obfuscation-rules.txt`默认开启了四项推荐的混淆选项：`-enable-property-obfuscation`、`-enable-toplevel-obfuscation`、`-enable-filename-obfuscation`和`-enable-export-obfuscation`，开发者可以根据需要进一步修改混淆配置。\",\"48\":\"\",\"49\":\"* 配置混淆保留选项\",\"50\":\"    开启混淆后，需要根据不同的混淆规则去配置白名单。白名单的配置方式可以参考[保留选项](source-obfuscation.md#保留选项)。推荐[通过混淆助手配置保留选项](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-build-obfuscation#section19439175917123)。\",\"51\":\"\",\"52\":\"* 指定release编译  \",\"53\":\"    源码混淆仅支持release编译，不支持debug编译。开启混淆开关后，release编译会进行混淆，debug编译则不会。开发者可参考[指定构建模式](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hvigor-compilation-options-customizing-guide#section192461528194916)查看和修改构建模式。\",\"54\":\"\",\"55\":\"    > **注意：**\"}",
      "修改建议": "混用了'白名单'和'保留选项'，建议全文统一使用'保留选项'。",
      "更改后示例": "开启混淆后，需要根据不同的混淆规则去配置保留选项。保留选项的配置方式可以参考[保留选项](source-obfuscation.md#保留选项)。",
      "触发条件": "同一技术概念在相邻段落或关联语句中出现多个不同术语表述，且存在官方推荐/已定义的统一术语时触发。\n\n识别模式：\n1. 上下文存在\"术语A→推荐术语B\"的映射关系（如问题段落中\"白名单\"与参考链接锚文本\"保留选项\"形成冲突）\n2. 同一语义概念出现≥2种不同表述（如\"白名单\"与\"保留选项\"指代相同配置机制）\n3. 存在明确的术语定义依据（如文档其他章节已明确定义\"保留选项\"为官方术语）"
    },
    {
      "defect_id": 423791,
      "sentence": "设置copyOptions为CopyOptions.InApp或者CopyOptions.LocalDevice时：",
      "reference_sentence": "copyOption(value: CopyOptions)",
      "line_num": 419,
      "context": "{\"414\":\"\",\"415\":\"copyOption(value: CopyOptions)\",\"416\":\"\",\"417\":\"设置组件是否支持文本可复制粘贴。\",\"418\":\"\",\"419\":\"设置copyOptions为CopyOptions.InApp或者CopyOptions.LocalDevice时：\",\"420\":\"\",\"421\":\"- 长按文本，会弹出文本选择菜单，可选中文本并进行复制、全选操作。\",\"422\":\"\",\"423\":\"- 此时默认使能长按选中文本可拖拽，通过设置[draggable](#draggable9)为false，可取消长按选中文本拖拽。\",\"424\":\"\"}",
      "修改建议": "混用了`copyOptions`和`copyOption`概念",
      "更改后示例": "设置copyOption为CopyOptions.InApp或者CopyOptions.LocalDevice时：",
      "触发条件": "同一术语在文档中存在单复数不一致（如copyOption与copyOptions）或同一概念的不同拼写形式（如驼峰式/全大写混用），且上下文存在明确定义的参数名称（如copyOption(value: CopyOptions)）。"
    },
    {
      "defect_id": 428455,
      "sentence": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。",
      "reference_sentence": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；",
      "line_num": 3833,
      "context": "{\"3828\":\"| NODE_CHECKBOX_NAME  | CheckBox名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框名称。<br/>**起始版本：** 15 |\",\"3829\":\"| NODE_CHECKBOX_GROUP  | CheckBox多选框所属群组的名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框所属群组的名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框所属群组的名称。<br/>**起始版本：** 15 |\",\"3830\":\"| NODE_XCOMPONENT_ID  | XComponent组件ID属性，支持属性设置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。 |\",\"3831\":\"| NODE_XCOMPONENT_TYPE  | XComponent的类型，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)，默认值为ARKUI_XCOMPONENT_TYPE_SURFACE；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)。 |\",\"3832\":\"| NODE_XCOMPONENT_SURFACE_SIZE  | 设置XComponent的宽高，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px； |\",\"3833\":\"| NODE_XCOMPONENT_SURFACE_RECT | 设置XComponent组件持有Surface的显示区域，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>**起始版本**：18 |\",\"3834\":\"| NODE_XCOMPONENT_ENABLE_ANALYZER | 设置是否为XComponent组件使能AI分析，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>**起始版本**：18 |\",\"3835\":\"| NODE_DATE_PICKER_LUNAR  | 设置日期选择器组件的日期是否显示农历，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历，默认值false。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历。 |\",\"3836\":\"| NODE_DATE_PICKER_START  | 设置日期选择器组件选择器的起始日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"1970-1-1\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3837\":\"| NODE_DATE_PICKER_END  | 设置日期选择器组件选择器的结束日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2100-12-31\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3838\":\"| NODE_DATE_PICKER_SELECTED  | 设置日期选择器组件选中项的日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2024-01-22\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。 |\"}",
      "修改建议": "混用了'XComponent组件'和'XComponent'概念",
      "更改后示例": "属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent左上角的x轴坐标，单位为px。",
      "触发条件": "同一技术文档中针对同一技术组件出现\"组件名称\"和\"组件名称+组件\"两种表述形式，且相邻条目存在相同术语的完整/简写混用情况。\n\n识别模式：\n1. 当检测到特定组件名称(如XComponent)在相邻条目中同时存在带/不带\"组件\"后缀的表述时\n2. 当同一属性描述场景(如坐标说明)出现术语完整形式与简写形式交替使用时\n3. 当参考句例(如宽高描述)已建立无\"组件\"后缀的表述惯例时"
    },
    {
      "defect_id": 419812,
      "sentence": "如果宿主线程需要所有任务执行完毕的数据，可以通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。",
      "reference_sentence": "如果宿主线程需要所有任务执行完毕的数据，可以通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。",
      "line_num": 3,
      "context": "{\"1\":\"# 使用TaskPool执行多个耗时任务\",\"2\":\"\",\"3\":\"多个任务同时执行时，由于任务复杂度不同，执行时间和返回数据的时间也会不同。如果宿主线程需要所有任务执行完毕的数据，可以通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。\",\"4\":\"\",\"5\":\"除此以外，如果需要处理的数据量较大，例如一个列表中有10000条数据，将这些数据放在一个Task中处理会非常耗时。那么就可以将原始数据拆分成多个子列表，为每个子列表分配一个独立的Task执行，等待全部Task执行完成后合并结果形成完整的数据，这样可以节省处理时间，提升用户体验。\",\"6\":\"\",\"7\":\"下面以多个任务进行图片加载为例进行说明。\",\"8\":\"\"}",
      "修改建议": "句式不一致，应使用祈使句",
      "更改后示例": "如果宿主线程需要所有任务执行完毕的数据，请通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。",
      "触发条件": "当文档中出现条件句（如“如果...”）后接建议性操作，但未使用祈使句（如“请...”）而采用“可以”等非指令性表达时触发。  \n识别模式：检测“如果...”条件分句后的主句是否包含“可以/应当”等非祈使动词，且上下文为操作指导场景。"
    },
    {
      "defect_id": 425736,
      "sentence": "组件文职、尺寸、样式或绘制内容随时间变化的效果。",
      "reference_sentence": "组件位置、尺寸、样式或绘制内容随时间变化的效果。",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- 自定义封装：将多个基础组件组合成具有特定功能的复合组件。\",\"10\":\"- 自定义布局：在对多个组件进行组合的过程中，各个组件的位置、尺寸都应该是符合业务场景，因此开发者需要对各个子组件进行自定义的排布。\",\"11\":\"- 自定义绘制：通过组合各类组件，还能达成各种绘制效果的高级组件。\",\"12\":\"- 自定义动画：组合的各类组件可以通过不同的方式定义动画，实现组件文职、尺寸、样式或绘制内容随时间变化的效果。\",\"13\":\"\",\"14\":\"\",\"15\":\"## 自定义组合的典型场景\",\"16\":\"|    场景      | 说明     |\",\"17\":\"|---------------|-----------------------------------------|\"}",
      "修改建议": "用词不一致，'文职'应改为'位置'。",
      "更改后示例": "组件位置、尺寸、样式或绘制内容随时间变化的效果。",
      "触发条件": "当文档中存在与上下文或已定义术语不一致的用词（如\"文职\"与上下文\"位置\"冲突），或出现同音/形近错别字时触发。识别模式需检测同一文档内是否存在相同语义但不同表述的词汇（如对比第12行\"文职\"与第10行\"位置\"），并验证是否为拼写错误或术语偏差。"
    },
    {
      "defect_id": 425737,
      "sentence": "如果高级组件的UI效果是非常复杂或者定制化的，例如存在图像或是文本等内容，可通过[Canvas](arkts-drawing-customization-on-canvas.md)组件实现更自由的自定义绘制效果，其接口和W3C标准的Canvas接口相近，适用于移植基于W3C标准的Canvas的绘制库。",
      "reference_sentence": "如果高级组件的UI效果是非常复杂或者定制化的，例如存在图像或文本等内容，可通过[Canvas](arkts-drawing-customization-on-canvas.md)组件实现更自由的自定义绘制效果，其接口和W3C标准的Canvas接口相近，适用于移植基于W3C标准的Canvas的绘制库。",
      "line_num": 23,
      "context": "{\"18\":\"| 使用@Component装饰器构建自定义组件   | 自定义封装的代表性方法是[@Component](../ui/state-management/arkts-create-custom-components.md#component)装饰器，可以通过将已有的自定义组件和基础组件进行组装，构成新的自定义组件。通常用于有内部成员方法、状态变量的部件，例如：视频列表里面的每一个视频卡片，卡片内部有自己的视频组件、文本组件、点击事件、跳转链接等等。 |\",\"19\":\"| 使用@Builder装饰器构建可复用的UI结构   |   相比于[@Component](../ui/state-management/arkts-create-custom-components.md#component)装饰器，[@Builder](../ui/state-management/arkts-builder.md)装饰器更加轻量级，可以将纯粹的UI结构风封装成方法，在各个自定义组件的build方法中进行调用，达成UI结构复用的目的。相当于将[@Component](../ui/state-management/arkts-create-custom-components.md#component)里面的build部分单抽出来，本身不包含状态变量。  |\",\"20\":\"| 使用Stack容器对子组件进行自定义布局   | 对于子组件明确、结构相对简单的布局场景，可以使用层叠布局，通过[Stack](./arkts-layout-development-stack-layout.md)容器，结合[尺寸](../reference/apis-arkui/arkui-ts/ts-universal-attributes-size.md)和[位置](../reference/apis-arkui/arkui-ts/ts-universal-attributes-location.md)的通用属性，来控制子组件的布局。[Stack](./arkts-layout-development-stack-layout.md)组件中的子元素依次入栈，通过顺序来控制遮盖效果，具有较强的页面层叠能力，常用于实现卡片层叠等效果。  |\",\"21\":\"| 结合自定义组件的布局生命周期回调方法进行自定义布局     |  对于子组件组成是动态的场景，可结合布局生命周期回调方法实现[自定义组件的自定义布局](../ui/state-management/arkts-page-custom-components-layout.md)，随子组件的动态变化，动态调整子组件的尺寸和位置，形成特定的布局算法。  |\",\"22\":\"| 组合基础图形实现自定义绘制效果|如果高级组件的UI效果是较为规则化的，例如：矩形、圆形、多边形等基础的图形，以及基础图形组合成的自定义图形，可通过基础的[图形类组件](arkts-geometric-shape-drawing.md)（[Rect](../reference/apis-arkui/arkui-ts/ts-drawing-components-rect.md)、[Path](../reference/apis-arkui/arkui-ts/ts-drawing-components-path.md)、[Circle](../reference/apis-arkui/arkui-ts/ts-drawing-components-circle.md)、[Ellipse](../reference/apis-arkui/arkui-ts/ts-drawing-components-ellipse.md)、[Polyline](../reference/apis-arkui/arkui-ts/ts-drawing-components-polyline.md)、[Polygon](../reference/apis-arkui/arkui-ts/ts-drawing-components-polygon.md)）组合完成。 |\",\"23\":\"| 使用Canvas组件实现高自由度的自定义绘制|如果高级组件的UI效果是非常复杂或者定制化的，例如存在图像或是文本等内容，可通过[Canvas](arkts-drawing-customization-on-canvas.md)组件实现更自由的自定义绘制效果，其接口和W3C标准的Canvas接口相近，适用于移植基于W3C标准的Canvas的绘制库。 |\",\"24\":\"| 通过属性动画能力实现动画效果|可动画属性在[animation](./arkts-attribute-animation-apis.md)属性前调用，改变该属性的值，可以使`animation`属性的动画效果生效，比如`height`、`width`、`backgroundColor`等。[属性动画](./arkts-attribute-animation-apis.md)是最基础易懂的动画，针对不同的场景，根据需要做动画的属性的数量、动画参数的异同、动画的阶段数量，可以使用不同的动画接口完成对应的效果。 |\",\"25\":\"| 通过@AnimatableExtend装饰器实现动画效果|不可动画属性无法通过[属性动画](./arkts-attribute-animation-apis.md)实现动画效果。可通过[@AnimatableExtend](../ui/state-management/arkts-animatable-extend.md)装饰器实现动画效果，如果该属性是number类型，那只要将该属性放置在用`@AnimatableExtend`全局定义的方法里面，就可以将其转变为一个可接受`animation`控制的可动画属性；而对于非number类型的属性，可通过实现[AnimatableArithmetic](../ui/state-management/arkts-animatable-extend.md)的子类，实现`plus`、`subtract`、`multiply`、`equals`方法，然后就可以使用`@AnimatableExtend`装饰器实现动画效果。 |\",\"26\":\"| 通过@ohos.animator动画接口实现动画效果|更加灵活的是帧动画，通过[@ohos.animator](../reference/apis-arkui/js-apis-animator.md)动画接口实现逐帧方法回调，在回调中对节点的属性进行修改，或者结合自定义绘制的能力来调整绘制内容，可以实现帧动画的效果。 |\",\"27\":\"\"}",
      "修改建议": "用词不一致，'和'应改为'或'。",
      "更改后示例": "如果高级组件的UI效果是非常复杂或者定制化的，例如存在图像或文本等内容，可通过[Canvas](arkts-drawing-customization-on-canvas.md)组件实现更自由的自定义绘制效果，其接口和W3C标准的Canvas接口相近，适用于移植基于W3C标准的Canvas的绘制库。",
      "触发条件": "当同一文档中存在相同语义的并列结构使用不同连接词（如\"或\"与\"或是\"混用），且在上下文对比中发现同类句式存在用词规范时。  \n识别模式：检测并列连词结构（如\"X或(是)Y\"），对比同一文档中其他相似句式（如参考句的\"图像或文本\"），发现连接词形态不一致即触发规则。"
    },
    {
      "defect_id": 428454,
      "sentence": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。",
      "reference_sentence": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；",
      "line_num": 3833,
      "context": "{\"3828\":\"| NODE_CHECKBOX_NAME  | CheckBox名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框名称。<br/>**起始版本：** 15 |\",\"3829\":\"| NODE_CHECKBOX_GROUP  | CheckBox多选框所属群组的名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框所属群组的名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框所属群组的名称。<br/>**起始版本：** 15 |\",\"3830\":\"| NODE_XCOMPONENT_ID  | XComponent组件ID属性，支持属性设置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。 |\",\"3831\":\"| NODE_XCOMPONENT_TYPE  | XComponent的类型，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)，默认值为ARKUI_XCOMPONENT_TYPE_SURFACE；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)。 |\",\"3832\":\"| NODE_XCOMPONENT_SURFACE_SIZE  | 设置XComponent的宽高，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px； |\",\"3833\":\"| NODE_XCOMPONENT_SURFACE_RECT | 设置XComponent组件持有Surface的显示区域，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>**起始版本**：18 |\",\"3834\":\"| NODE_XCOMPONENT_ENABLE_ANALYZER | 设置是否为XComponent组件使能AI分析，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>**起始版本**：18 |\",\"3835\":\"| NODE_DATE_PICKER_LUNAR  | 设置日期选择器组件的日期是否显示农历，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历，默认值false。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历。 |\",\"3836\":\"| NODE_DATE_PICKER_START  | 设置日期选择器组件选择器的起始日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"1970-1-1\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3837\":\"| NODE_DATE_PICKER_END  | 设置日期选择器组件选择器的结束日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2100-12-31\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3838\":\"| NODE_DATE_PICKER_SELECTED  | 设置日期选择器组件选中项的日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2024-01-22\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。 |\"}",
      "修改建议": "混用了'XComponent组件'和'XComponent'概念",
      "更改后示例": "属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent左上角的x轴坐标，单位为px。",
      "触发条件": "同一技术文档中，针对同一组件/概念的术语表述存在\"全称+修饰词\"与\"简称\"混用（如\"XComponent组件\"与\"XComponent\"交替出现），且上下文存在明确的一致性参照（如相邻条目统一使用简称）。"
    },
    {
      "defect_id": 425838,
      "sentence": "最后，在宿主线程通过onReceiveData()接口接收消息。",
      "reference_sentence": "最后，在宿主线程通过onReceiveData()接口接收消息。",
      "line_num": 60,
      "context": "{\"55\":\"     return iconItemSourceList;\",\"56\":\"   }\",\"57\":\"   ```\",\"58\":\"   <!-- @[implement_child_thread_task](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationScenario/entry/src/main/ets/managers/TaskSendDataUsage.ets) -->\",\"59\":\"\",\"60\":\"3. 最后，在宿主线程通过onReceiveData()接口接收消息。\",\"61\":\"   这样宿主线程就可以通过notice()接口接收到Task发送的数据。\",\"62\":\"\",\"63\":\"   ```ts\",\"64\":\"   // TaskSendDataUsage.ets\",\"65\":\"   @Entry\"}",
      "修改建议": "句式一致，但建议使用祈使句描述动作。",
      "更改后示例": "在宿主线程通过onReceiveData()接口接收消息。",
      "触发条件": "当步骤描述性语句中出现冗余的顺序性词汇（如\"最后\"），且上下文同类语句均采用无连接词的祈使句式时触发；当技术操作说明中存在与上下文指令风格不匹配的时间状语结构时触发。\n\n识别模式：\n1. 定位步骤说明段（通过数字编号/项目符号识别）\n2. 检测存在\"首先/其次/最后\"等序列词但上下文无对应序列结构\n3. 验证语句功能属性（操作指令 vs 流程说明）\n4. 比对相邻语句结构特征（是否均采用零连接词祈使句）"
    },
    {
      "defect_id": 419011,
      "sentence": "意图中使用实体 `ArtistClassDef` 示例：",
      "reference_sentence": "意图中使用实体 `ArtistClassDef` 示例：",
      "line_num": 122,
      "context": "{\"117\":\"    return Promise.resolve(result);\",\"118\":\"  }\",\"119\":\"}\",\"120\":\"```\",\"121\":\"\",\"122\":\"意图中使用实体 `ArtistClassDef` 示例：\",\"123\":\"\",\"124\":\"```ts\",\"125\":\"import { insightIntent, InsightIntentEntry, InsightIntentEntryExecutor, InsightIntentEntity } from '@kit.AbilityKit';\",\"126\":\"import { hilog } from '@kit.PerformanceAnalysisKit';\",\"127\":\"\"}",
      "修改建议": "术语 '实体' 和 '意图实体' 混用",
      "更改后示例": "意图中使用意图实体 `ArtistClassDef` 示例：",
      "触发条件": "同一文档中混合使用术语的完整形式（如“意图实体”）与省略修饰词的不完整形式（如“实体”），且上下文存在明确关联的代码或术语定义（如代码中引用`InsightIntentEntity`类）。  \n识别模式：检测相邻段落或代码中是否同时出现完整术语与简化术语，且简化形式可能导致歧义或与已定义术语冲突（如实体类型需区分意图实体、系统实体等子类）。"
    },
    {
      "defect_id": 426054,
      "sentence": "2. 这里的宿主线程是UI主线程，在宿主线程中创建Worker对象，当点击Button时调用postMessage方法向Worker线程发送消息，通过Worker的onmessage方法接收Worker线程返回的数据。",
      "reference_sentence": "2. 这里的宿主线程是UI主线程，在宿主线程中创建Worker对象，当点击Button时调用postMessage方法向Worker线程发送消息，通过Worker的onmessage方法接收Worker线程返回的数据。",
      "line_num": 26,
      "context": "{\"21\":\"     }\",\"22\":\"   }\",\"23\":\"   ```\",\"24\":\"   <!-- @[create_worker_execute_multi_task](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationScenario/entry/src/main/ets/workers/Worker.ets) -->\",\"25\":\"\",\"26\":\"2. 这里的宿主线程是UI主线程，在宿主线程中创建Worker对象，当点击Button时调用postMessage方法向Worker线程发送消息，通过Worker的onmessage方法接收Worker线程返回的数据。\",\"27\":\"\",\"28\":\"   ```ts\",\"29\":\"   // Index.ets\",\"30\":\"   import { worker } from '@kit.ArkTS';\",\"31\":\"   import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "宿主线程 与 主线程 混用，建议统一使用 主线程",
      "更改后示例": "2. 这里的主线程是UI主线程，在主线程中创建Worker对象，当点击Button时调用postMessage方法向Worker线程发送消息，通过Worker的onmessage方法接收Worker线程返回的数据。",
      "触发条件": "同一文档中针对同一技术概念出现多个不同术语表述（如\"宿主线程\"和\"主线程\"交替使用），且未在首次出现时明确声明其等价关系。\n\n识别模式：\n1. 通过上下文语义分析识别同指实体（如通过\"UI主线程\"与\"宿主线程\"的上下文关联判断指代同一线程）\n2. 检测相邻段落或同一技术场景中是否存在多个术语混用现象\n3. 验证术语是否与官方技术文档或行业标准命名存在偏差"
    },
    {
      "defect_id": 428453,
      "sentence": "设置是否为XComponent组件使能AI分析，支持属性设置和获取接口。",
      "reference_sentence": "设置XComponent的宽高，支持属性设置和获取接口。",
      "line_num": 3834,
      "context": "{\"3829\":\"| NODE_CHECKBOX_GROUP  | CheckBox多选框所属群组的名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框所属群组的名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框所属群组的名称。<br/>**起始版本：** 15 |\",\"3830\":\"| NODE_XCOMPONENT_ID  | XComponent组件ID属性，支持属性设置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。 |\",\"3831\":\"| NODE_XCOMPONENT_TYPE  | XComponent的类型，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)，默认值为ARKUI_XCOMPONENT_TYPE_SURFACE；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)。 |\",\"3832\":\"| NODE_XCOMPONENT_SURFACE_SIZE  | 设置XComponent的宽高，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px； |\",\"3833\":\"| NODE_XCOMPONENT_SURFACE_RECT | 设置XComponent组件持有Surface的显示区域，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>**起始版本**：18 |\",\"3834\":\"| NODE_XCOMPONENT_ENABLE_ANALYZER | 设置是否为XComponent组件使能AI分析，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>**起始版本**：18 |\",\"3835\":\"| NODE_DATE_PICKER_LUNAR  | 设置日期选择器组件的日期是否显示农历，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历，默认值false。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历。 |\",\"3836\":\"| NODE_DATE_PICKER_START  | 设置日期选择器组件选择器的起始日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"1970-1-1\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3837\":\"| NODE_DATE_PICKER_END  | 设置日期选择器组件选择器的结束日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2100-12-31\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3838\":\"| NODE_DATE_PICKER_SELECTED  | 设置日期选择器组件选中项的日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2024-01-22\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。 |\",\"3839\":\"| NODE_DATE_PICKER_DISAPPEAR_TEXT_STYLE  | 设置日期选择器组件的所有选项中最上和最下两个选项的文本颜色、字号、字体粗细，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 入参5个，格式为字符串，以 ';' 分割：<br/>入参1： 文本颜色，::argb类型<br/>入参2： 文本大小，数字类型，单位fp<br/>入参3： 文本粗细，字符串枚举(\\\"bold\\\", \\\"normal\\\", \\\"bolder\\\", \\\"lighter\\\", \\\"medium\\\", \\\"regular\\\")<br/>入参4： 文本字体列表，使用 ',' 进行分割<br/>入参5： 文本样式，字符串枚举(\\\"normal\\\", \\\"italic\\\")<br/>如 \\\"\\\\#ff182431;14;normal;Arial,HarmonyOS Sans;normal\\\" 。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 参数5个，格式为字符串，以 ';' 分割：<br/>参数1： 文本颜色，::argb类型<br/>参数2： 文本大小，数字类型，单位fp<br/>参数3： 文本粗细，字符串枚举(\\\"bold\\\", \\\"normal\\\", \\\"bolder\\\", \\\"lighter\\\", \\\"medium\\\", \\\"regular\\\")<br/>参数4： 文本字体列表，使用 ',' 进行分割<br/>参数5： 文本样式，字符串枚举(\\\"normal\\\", \\\"italic\\\")<br/>如 \\\"\\\\#ff182431;14;normal;Arial,HarmonyOS Sans;normal\\\" 。 |\"}",
      "修改建议": "混用了'XComponent组件'和'XComponent'概念",
      "更改后示例": "设置是否为XComponent使能AI分析，支持属性设置和获取接口。",
      "触发条件": "同一术语在相邻或相关条目中存在冗余修饰词（如\"组件\"）与无修饰词混用，且上下文已明确指代组件类型时。\n\n具体表现为：当技术文档中同一组件名称出现\"全称+类别词\"（如XComponent组件）和\"简称\"（如XComponent）两种形式混用，且上下文已通过属性/接口说明明确指向组件操作时，触发一致性校验。"
    },
    {
      "defect_id": 425735,
      "sentence": "组件组合的过程中可以布局容器和通用布局属性来对子组件进行自定义的位置排布，可以使用Canvas组件完成纯自绘，也可以使用Shape类组件，通过形状的组合，构建几何图形，实现带交互的图形动画。动画模块可针对不同类型的属性，实现灵活的动画效果。",
      "reference_sentence": "组件组合的过程中可以使用布局容器和通用布局属性来对子组件进行自定义的位置排布，可以使用Canvas组件完成纯自绘，也可以使用Shape类组件，通过形状的组合，构建几何图形，实现带交互的图形动画。动画模块可针对不同类型的属性，实现灵活的动画效果。",
      "line_num": 5,
      "context": "{\"1\":\"# 自定义组合\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"\",\"5\":\"自定义组合提供组件粒度的自定义能力，开发者可通过自定义组件组合已有组件来构建特定的符合业务逻辑的高级组件。组件组合的过程中可以布局容器和通用布局属性来对子组件进行自定义的位置排布，可以使用Canvas组件完成纯自绘，也可以使用Shape类组件，通过形状的组合，构建几何图形，实现带交互的图形动画。动画模块可针对不同类型的属性，实现灵活的动画效果。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- 自定义封装：将多个基础组件组合成具有特定功能的复合组件。\",\"10\":\"- 自定义布局：在对多个组件进行组合的过程中，各个组件的位置、尺寸都应该是符合业务场景，因此开发者需要对各个子组件进行自定义的排布。\"}",
      "修改建议": "句式不一致，建议使用一致的句式描述动作。",
      "更改后示例": "组件组合的过程中可以使用布局容器和通用布局属性来对子组件进行自定义的位置排布，可以使用Canvas组件完成纯自绘，也可以使用Shape类组件，通过形状的组合，构建几何图形，实现带交互的图形动画。动画模块可针对不同类型的属性，实现灵活的动画效果。",
      "触发条件": "同一段落或上下文中存在多个并列动作描述时，出现句式结构不一致（如部分分句缺失助动词或宾语），导致表达连贯性受损。\n\n识别模式：\n1. 检查连续使用相同引导词（如\"可以\"）的句子/分句，观察其后动词结构是否统一（如\"可以使用X\" vs \"可以X\"）\n2. 分析并列关系的内容项，验证动作描述是否保持相同语法模式（主谓宾结构完整性、助动词使用一致性）\n3. 特别注意同一语义层次的多项说明（如组件使用方式列举），要求各条目保持平行结构"
    },
    {
      "defect_id": 425839,
      "sentence": "这样宿主线程就可以通过notice()接口接收到Task发送的数据。",
      "reference_sentence": "这样宿主线程就可以通过notice()接口接收到Task发送的数据。",
      "line_num": 61,
      "context": "{\"56\":\"   }\",\"57\":\"   ```\",\"58\":\"   <!-- @[implement_child_thread_task](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationScenario/entry/src/main/ets/managers/TaskSendDataUsage.ets) -->\",\"59\":\"\",\"60\":\"3. 最后，在宿主线程通过onReceiveData()接口接收消息。\",\"61\":\"   这样宿主线程就可以通过notice()接口接收到Task发送的数据。\",\"62\":\"\",\"63\":\"   ```ts\",\"64\":\"   // TaskSendDataUsage.ets\",\"65\":\"   @Entry\",\"66\":\"   @Component\"}",
      "修改建议": "句式一致，但建议使用祈使句描述动作。",
      "更改后示例": "通过notice()接口接收Task发送的数据。",
      "触发条件": "当文档中的操作步骤或指南性内容出现混合句式（如陈述句与祈使句混用），且当前句子在步骤流程中需保持动作描述的祈使句结构时触发。\n\n识别模式：\n1. 上下文定位：句子位于操作步骤列表或明确的指南性段落（如上下文中的步骤3、步骤61）。\n2. 句式冲突检测：当前句子使用\"可以/就能+动词\"的陈述结构（如\"就可以接收到\"），而相邻步骤使用无主语的动词短语（如\"通过...接收\"）的祈使句式。"
    },
    {
      "defect_id": 425837,
      "sentence": "然后，在需要执行的Task中，添加sendData()接口将消息发送给宿主线程。",
      "reference_sentence": "然后，在需要执行的Task中，添加sendData()接口将消息发送给宿主线程。",
      "line_num": 17,
      "context": "{\"12\":\"     console.info(\\\"子线程任务已执行完，共加载图片: \\\", data);\",\"13\":\"   }\",\"14\":\"   ```\",\"15\":\"   <!-- @[receive_task_message](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationScenario/entry/src/main/ets/managers/TaskSendDataUsage.ets) -->\",\"16\":\"\",\"17\":\"2. 然后，在需要执行的Task中，添加sendData()接口将消息发送给宿主线程。\",\"18\":\"\",\"19\":\"   ```ts\",\"20\":\"   // IconItemSource.ets\",\"21\":\"   export class IconItemSource {\",\"22\":\"     image: string | Resource = '';\"}",
      "修改建议": "句式一致，但建议使用祈使句描述动作。",
      "更改后示例": "在需要执行的Task中，添加sendData()接口将消息发送给宿主线程。",
      "触发条件": "当文档中的步骤描述包含不必要的顺序连接词（如“然后”），导致句式与上下文其他步骤不一致，且不符合技术文档中祈使句的规范要求时触发。\n\n识别模式：检查步骤描述是否以时间/顺序副词开头，且同一文档中的其他步骤未使用类似结构，同时该句子的核心动作为用户需执行的操作（需转换为无主语的祈使句）。"
    },
    {
      "defect_id": 428452,
      "sentence": "设置XComponent组件持有Surface的显示区域，支持属性设置和获取接口。",
      "reference_sentence": "设置XComponent的宽高，支持属性设置和获取接口。",
      "line_num": 3833,
      "context": "{\"3828\":\"| NODE_CHECKBOX_NAME  | CheckBox名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框名称。<br/>**起始版本：** 15 |\",\"3829\":\"| NODE_CHECKBOX_GROUP  | CheckBox多选框所属群组的名称设置, 支持属性设置，属性重置和属性获取。<br/>属性设置方法[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)参数格式：<br/>.string：多选框所属群组的名称。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string：多选框所属群组的名称。<br/>**起始版本：** 15 |\",\"3830\":\"| NODE_XCOMPONENT_ID  | XComponent组件ID属性，支持属性设置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string: ID的内容。 |\",\"3831\":\"| NODE_XCOMPONENT_TYPE  | XComponent的类型，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)，默认值为ARKUI_XCOMPONENT_TYPE_SURFACE；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：字体样式[ArkUI_XComponentType](#arkui_xcomponenttype)。 |\",\"3832\":\"| NODE_XCOMPONENT_SURFACE_SIZE  | 设置XComponent的宽高，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px；<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].u32：宽数值，单位为px；<br/>.value[1].u32：高数值，单位为px； |\",\"3833\":\"| NODE_XCOMPONENT_SURFACE_RECT | 设置XComponent组件持有Surface的显示区域，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：Surface显示区域相对于XComponent组件左上角的x轴坐标，单位为px。<br/>.value[1].i32：Surface显示区域相对于XComponent组件左上角的y轴坐标，单位为px。<br/>.value[2].i32：Surface显示区域的宽度，单位为px。<br/>.value[3].i32：Surface显示区域的高度，单位为px。<br/>**起始版本**：18 |\",\"3834\":\"| NODE_XCOMPONENT_ENABLE_ANALYZER | 设置是否为XComponent组件使能AI分析，支持属性设置和获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32：是否启用图像分析功能。<br/>**起始版本**：18 |\",\"3835\":\"| NODE_DATE_PICKER_LUNAR  | 设置日期选择器组件的日期是否显示农历，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历，默认值false。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.value[0].i32： 是否显示农历。 |\",\"3836\":\"| NODE_DATE_PICKER_START  | 设置日期选择器组件选择器的起始日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"1970-1-1\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3837\":\"| NODE_DATE_PICKER_END  | 设置日期选择器组件选择器的结束日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2100-12-31\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。<br/>**起始版本：** 18 |\",\"3838\":\"| NODE_DATE_PICKER_SELECTED  | 设置日期选择器组件选中项的日期，支持属性设置，属性重置和属性获取接口。<br/>属性设置方法参数[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期，默认值\\\"2024-01-22\\\"。<br/>属性获取方法返回值[ArkUI_AttributeItem](_ark_u_i___attribute_item.md)格式：<br/>.string： 日期。 |\"}",
      "修改建议": "混用了'XComponent组件'和'XComponent'概念",
      "更改后示例": "设置XComponent持有Surface的显示区域，支持属性设置和获取接口。",
      "触发条件": "当同一技术组件名称在相邻条目中同时存在带/不带\"组件\"后缀的表述时（如\"XComponent组件\"和\"XComponent\"混用），且上下文存在明确指代关系时触发。\n\n识别模式：\n1. 检测技术名词是否在相邻条目中存在冗余修饰词差异（如NODE_XCOMPONENT_SURFACE_RECT使用\"XComponent组件\"而NODE_XCOMPONENT_SURFACE_SIZE使用\"XComponent\"）\n2. 验证修饰词是否改变核心概念（\"组件\"后缀未增加新信息，仅重复指代同一实体）\n3. 检查参考条目用词模式（如3832行参考句使用规范简称）作为修正依据"
    },
    {
      "defect_id": 428742,
      "sentence": "多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保销毁父Worker前先销毁所有子Worker。",
      "reference_sentence": "多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保销毁父Worker前先销毁所有子Worker。",
      "line_num": 3,
      "context": "{\"1\":\"# 多级Worker间高性能消息通信\",\"2\":\"\",\"3\":\"多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保销毁父Worker前先销毁所有子Worker。\",\"4\":\"\",\"5\":\"本文介绍如何在多级Worker间实现高性能消息通信，高性能消息通信的关键在于[Sendable对象](arkts-sendable.md)，结合Worker的[postMessageWithSharedSendable接口](../reference/apis-arkts/js-apis-worker.md#postmessagewithsharedsendable12)，可以实现线程间高性能的对象传递。以数据克隆场景为例，假设有三个Worker，一个父Worker和两个子Worker，父Worker负责创建子Worker，并向子Worker发送数据克隆任务，子Worker负责接收任务并执行数据克隆操作，完成后将克隆结果返回给父Worker。\",\"6\":\"\",\"7\":\"1. 准备一个Sendable类CopyEntry，用于封装克隆任务数据。\",\"8\":\"   \"}",
      "修改建议": "混用了'销毁'和'关闭'",
      "更改后示例": "多级[Worker](worker-introduction.md)（即通过父Worker创建子Worker的机制形成层级线程关系）间通信是一种常见的需求，由于Worker线程生命周期由用户自行管理，因此需要注意多级Worker生命周期的正确管理，建议开发者确保关闭父Worker前先关闭所有子Worker。",
      "触发条件": "同一技术概念在相邻上下文或同一段落中出现多个不同的术语（如\"销毁\"与\"关闭\"混用），且未通过明确定义区分其语义差异时触发。\n\n识别模式：\n1. 检测同一技术实体（如Worker）生命周期操作相关的动词/名词\n2. 对比当前句子与上下文/参考文档中该操作的标准术语（如\"关闭\"）\n3. 发现存在语义相同但用词不一致的情况（如\"销毁\"与\"关闭\"交替使用）\n4. 确认未在文档中明确定义不同术语的特殊含义差异"
    },
    {
      "defect_id": 430237,
      "sentence": "当任务不需要长时间（3分钟）占据后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。",
      "reference_sentence": "当任务不需要长时间（3分钟）占据后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。",
      "line_num": 10,
      "context": "{\"5\":\"\",\"6\":\"\",\"7\":\"基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。\",\"8\":\"\",\"9\":\"\",\"10\":\"当任务不需要长时间（3分钟）占据后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。\",\"11\":\"\",\"12\":\"接下来将分别以图像直方图处理和后台长时间模型预测任务为例进行说明。\",\"13\":\"\",\"14\":\"\",\"15\":\"## 使用TaskPool进行图像直方图处理\"}",
      "修改建议": "原文中使用了‘占据’，建议统一使用‘占据’或‘占用’。",
      "更改后示例": "当任务不需要长时间（3分钟）占用后台线程，而是一个个独立的任务时，推荐使用TaskPool，反之推荐使用Worker。",
      "触发条件": "同一文档中存在多个同义词/近义词（如\"占据\"和\"占用\"）用于描述同一技术场景，且未保持统一表述时触发；或当特定术语（如\"占用\"）已在参考句/上下文中确立为规范用词时出现替代词汇。"
    },
    {
      "defect_id": 428571,
      "sentence": "Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "reference_sentence": "Multi-Category Security (MCS) 是 SELinux 强制访问控制的一种模式，通过类别 (Category) 划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux支持MCS\",\"2\":\"\",\"3\":\"## MCS背景介绍\",\"4\":\"\",\"5\":\"Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。\",\"6\":\"\",\"7\":\"## MCS开关配置\",\"8\":\"当前MCS默认为开启状态，需要关闭MCS时，可在selinux_adapter部件里配置selinux_adapter_mcs_enable=false。\",\"9\":\"\",\"10\":\"## MCS安全级别配置\"}",
      "修改建议": "括号内的英文缩写和全称应与上文保持一致，首字母大写。",
      "更改后示例": "Multi-Category Security (MCS) 是 SELinux 强制访问控制的一种模式，通过类别 (Category) 划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "触发条件": "当括号内英文术语的格式（首字母大小写/空格）与上文首次定义不一致，或同一术语在后续出现时未保持统一格式时触发。\n\n识别模式：\n1. 检查括号内英文是否与上文首次出现时的格式匹配（如\"MCS\"应保持首字母大写，且与全称间保留空格）\n2. 验证术语首次定义时是否采用\"全称 (缩写)\"的标准格式（如问题上下文中第5行首次定义时缺少空格，而参考句子修正后添加了空格）"
    },
    {
      "defect_id": 430240,
      "sentence": "1. DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。",
      "reference_sentence": "1. DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。",
      "line_num": 79,
      "context": "{\"74\":\"\",\"75\":\"## 使用Worker进行长时间数据分析\",\"76\":\"\",\"77\":\"本文通过某地区提供的房价数据训练一个简易的房价预测模型，该模型支持通过输入房屋面积和房间数量去预测该区域的房价，模型需要长时间运行，房价预测需要使用前面的模型运行结果，因此需要使用Worker。\",\"78\":\"\",\"79\":\"1. DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。\",\"80\":\"\",\"81\":\"   ![newWorker](figures/newWorker.png)\",\"82\":\"\",\"83\":\"2. 在宿主线程中通过调用ThreadWorker的[constructor()](../reference/apis-arkts/js-apis-worker.md#constructor9)方法创建Worker对象。\",\"84\":\"\"}",
      "修改建议": "原文中使用了‘新建一个Worker线程’，建议统一使用‘新建一个Worker线程’或‘创建一个Worker线程’。",
      "更改后示例": "1. DevEco Studio提供了Worker创建的模板，创建一个Worker线程，例如命名为“MyWorker”。",
      "触发条件": "同一操作在相邻或相近上下文中使用不同动词（如\"新建\"/\"创建\"），且存在已定义的统一术语或前文已明确使用某一固定表达时触发。  \n\n识别模式：  \n1. 检测同一操作描述中出现的近义动词（如创建/新建/生成）  \n2. 验证上下文是否存在已确立的规范用词（如后文出现\"创建Worker对象\"）  \n3. 判断动词差异是否会导致同一概念产生歧义（如线程创建流程的统一性要求）"
    },
    {
      "defect_id": 434496,
      "sentence": "除非在对象生命周期管理中有特殊要求，一般不在此 callback 中创建 handle 或者 callback scope。",
      "reference_sentence": "除非在对象生命周期管理中有特殊要求，一般不在此 callback 中创建 handle 或者 callback scope。",
      "line_num": 277,
      "context": "{\"272\":\"\",\"273\":\"JSVM-API包含以下回调类型：\",\"274\":\"\",\"275\":\"**JSVM_CallbackStruct**\",\"276\":\"\",\"277\":\"用户提供的 Native callback 的回调函数指针和数据，JSVM_CallbackStruct 将通过 JSVM-API 暴露给 JavaScript。例如，可以使用 OH_JSVM_CreateFunction 接口创建绑定到 Native callback 的 JS 函数，其中 Native callback 就是通过 JSVM_CallbackStruct 结构定义。除非在对象生命周期管理中有特殊要求，一般不在此 callback 中创建 handle 或者 callback scope。\",\"278\":\"\",\"279\":\"```c++\",\"280\":\"typedef struct {\",\"281\":\"  JSVM_Value(*callback)(JSVM_Env env, JSVM_CallbackInfo info);\",\"282\":\"  void* data;\"}",
      "修改建议": "用词不一致，'handle'应改为'句柄'以保持一致性。",
      "更改后示例": "除非在对象生命周期管理中有特殊要求，一般不在此 callback 中创建句柄或者 callback scope。",
      "触发条件": "同一技术术语在中文文档中同时存在英文原词和中文译词混用的情况（如\"handle\"和\"句柄\"交替出现），且上下文已存在该术语的既定中文译法（如参考句子中已使用\"callback scope\"但未翻译）。"
    },
    {
      "defect_id": 434499,
      "sentence": "JSVM 不保证是否执行该回调函数，也不保证执行该回调函数的时机，**开发者不应依赖于该回调的执行时机**。",
      "reference_sentence": "JSVM 不保证是否执行该回调函数，也不保证执行该回调函数的时机，**开发者不应依赖于该回调的执行时机**。",
      "line_num": 302,
      "context": "{\"297\":\"\",\"298\":\"用户定义的 Native callback，第一个参数类型是 JSVM_Env，第二个参数类型是 JSVM_CallbackInfo。JSVM_CallbackInfo 表示从 JS 侧调用到 Native 侧时携带的调用信息，如参数列表。在实现 Native callback 时，一般使用 OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。\",\"299\":\"\",\"300\":\"**JSVM_Finalize**\",\"301\":\"\",\"302\":\"函数指针，用于传入OH_JSVM_SetInstanceData、OH_JSVM_CreateExternal、OH_JSVM_Wrap等接口。JSVM_Finalize在对象被回收后会被调用，可用于在JavaScript对象被垃圾回收时释放Native对象。JSVM 不保证是否执行该回调函数，也不保证执行该回调函数的时机，**开发者不应依赖于该回调的执行时机**。\",\"303\":\"\",\"304\":\"写法如下：\",\"305\":\"\",\"306\":\"```c++\",\"307\":\"typedef void (*JSVM_Finalize)(JSVM_Env env, void* finalizeData, void* finalizeHint);\"}",
      "修改建议": "用词不一致，'执行该回调函数的时机'应改为'执行回调函数的时机'以保持一致性。",
      "更改后示例": "JSVM 不保证是否执行该回调函数，也不保证执行回调函数的时机，**开发者不应依赖于该回调的执行时机**。",
      "触发条件": "同一段落或相邻句子中出现重复结构但用词不一致的短语（如\"执行该回调函数的时机\"与\"该回调的执行时机\"），且存在冗余指示词（如\"该\"）导致表达不对称时。"
    },
    {
      "defect_id": 434574,
      "sentence": "在调用JSVM-API接口时，底层VM堆中的对象可能会作为JSVM_Values返回句柄。这些句柄必须在Native方法退出或主动释放掉前，使其关联的对象处于“活动”状态，防止被引擎回收掉。",
      "reference_sentence": "创建及销毁JavaScript引擎实例，包含创建及销毁JS执行上下文环境",
      "line_num": 888,
      "context": "{\"883\":\"}\",\"884\":\"```\",\"885\":\"\",\"886\":\"### 对象生命周期管理\",\"887\":\"\",\"888\":\"在调用JSVM-API接口时，底层VM堆中的对象可能会作为JSVM_Values返回句柄。这些句柄必须在Native方法退出或主动释放掉前，使其关联的对象处于“活动”状态，防止被引擎回收掉。\",\"889\":\"\",\"890\":\"当对象句柄被返回时，它们与一个“scope”相关联。默认作用域的生命周期与本机方法调用的生命周期相关联，这些句柄及关联的对象将在Native方法的生命周期内保持活动状态。\",\"891\":\"\",\"892\":\"然而，在许多情况下，句柄必须保持有效的时间范围并不与Native方法的生命周期相同。下面将介绍可用于更改句柄的生命周期的JSVM-API方法。\",\"893\":\"\"}",
      "修改建议": "用词不一致，'退出'与'销毁'混用",
      "更改后示例": "在调用JSVM-API接口时，底层VM堆中的对象可能会作为JSVM_Values返回句柄。这些句柄必须在Native方法销毁或主动释放掉前，使其关联的对象处于“活动”状态，防止被引擎回收掉。",
      "触发条件": "同一上下文或技术场景中，对同一操作或状态使用了多个不一致的动词术语（如\"退出/销毁\"），且存在与参考文档术语（如\"销毁\"）冲突的情况。通过检测相邻段落/技术描述中关键动词的术语一致性，识别同一语义下存在多词混用即可触发。"
    },
    {
      "defect_id": 434495,
      "sentence": "JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。",
      "reference_sentence": "JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。",
      "line_num": 269,
      "context": "{\"264\":\"\",\"265\":\"- 存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。\",\"266\":\"\",\"267\":\"- 比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。\",\"268\":\"\",\"269\":\"- JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。\",\"270\":\"\",\"271\":\"### 回调类型\",\"272\":\"\",\"273\":\"JSVM-API包含以下回调类型：\",\"274\":\"\"}",
      "修改建议": "用词不一致，'类型标记'应改为'类型标签'以保持一致性。",
      "更改后示例": "JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标签相对应的Native类型。",
      "触发条件": "当文档中同一技术术语存在多种中文译法（如\"类型标记\"与\"类型标签\"混用），且上下文存在明确的标准术语（如参考句中的\"类型标签\"）时触发；或当名词性术语与动词性表述（如\"标记JavaScript对象\"中的动词用法）产生词性不一致时触发。\n\n识别模式：通过术语一致性检查，识别同一概念在名词形式上的变异表达（如\"标记/标签\"），并对比上下文语境中的标准术语使用（如问题上下文265行动词\"标记\"与269行名词\"类型标签\"的对应关系），当检测到名词性术语与既定标准形式不符时触发修复。"
    },
    {
      "defect_id": 434493,
      "sentence": "存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。",
      "reference_sentence": "存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。",
      "line_num": 265,
      "context": "{\"260\":\"    uint64_t lower;\",\"261\":\"    uint64_t upper;\",\"262\":\"} JSVM_TypeTag;\",\"263\":\"```\",\"264\":\"\",\"265\":\"- 存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。\",\"266\":\"\",\"267\":\"- 比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。\",\"268\":\"\",\"269\":\"- JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。\",\"270\":\"\"}",
      "修改建议": "用词不一致，'标记JavaScript对象'应改为'标识JavaScript对象'以保持一致性。",
      "更改后示例": "存储了两个无符号64位整数的128位值，用它来标识JavaScript对象，确保它们属于某种类型。",
      "触发条件": "同一文档中对同一技术概念存在多个不一致的术语表述（如\"标记\"与\"标识\"混用），且上下文已存在明确的标准术语（如参考句中的\"标识\"或API命名隐含的术语倾向）。  \n\n识别模式：  \n1. **术语冲突检测**：在邻近段落或技术上下文中（如代码注释/API名称）存在重复出现的标准术语（例如\"标识\"对应英文\"identify\"的常见技术翻译）；  \n2. **功能一致性验证**：当动词选择影响技术语义准确性时（如\"标记\"（mark）偏向可视化标签，而\"标识\"（identify）强调唯一性验证），需强制对齐到上下文更精确的术语。"
    },
    {
      "defect_id": 434497,
      "sentence": "JSVM_CallbackStruct 指针类型的类型别名。",
      "reference_sentence": "JSVM_Callback",
      "line_num": 288,
      "context": "{\"283\":\"} JSVM_CallbackStruct;\",\"284\":\"```\",\"285\":\"\",\"286\":\"**JSVM_Callback**\",\"287\":\"\",\"288\":\"JSVM_CallbackStruct 指针类型的类型别名。\",\"289\":\"\",\"290\":\"定义如下:\",\"291\":\"\",\"292\":\"```c++\",\"293\":\"typedef JSVM_CallbackStruct* JSVM_Callback;\"}",
      "修改建议": "用词不一致，'类型别名'应改为'别名'以保持一致性。",
      "更改后示例": "JSVM_CallbackStruct 指针类型的别名。",
      "触发条件": "当文档中同一概念存在多个同义表述（如\"别名\"和\"类型别名\"）且上下文已确立标准术语时，或出现冗余限定词（如\"类型\"）破坏术语统一性时触发。  \n\n识别模式：通过对比相邻段落/代码注释中的术语使用（如参考句子typedef明确定义为\"别名\"），检测当前句子是否使用非常规复合词（如\"类型别名\"）或添加非必要修饰成分。"
    },
    {
      "defect_id": 434500,
      "sentence": "当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。",
      "reference_sentence": "当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。",
      "line_num": 312,
      "context": "{\"307\":\"typedef void (*JSVM_Finalize)(JSVM_Env env, void* finalizeData, void* finalizeHint);\",\"308\":\"```\",\"309\":\"\",\"310\":\"**JSVM_PropertyHandlerConfigurationStruct**\",\"311\":\"\",\"312\":\"当执行对象的getter、setter、deleter和enumerator作时，对应的的回调将会触发。\",\"313\":\"\",\"314\":\"```c++\",\"315\":\"typedef struct {\",\"316\":\"    JSVM_Value(JSVM_CDECL* genericNamedPropertyGetterCallback)(JSVM_Env env,\",\"317\":\"                                                               JSVM_Value name,\"}",
      "修改建议": "用词不一致，'执行对象的getter、setter、deleter和enumerator作'应改为'执行对象的getter、setter、deleter和enumerator操作'以保持一致性。",
      "更改后示例": "当执行对象的getter、setter、deleter和enumerator操作时，对应的回调将会触发。",
      "触发条件": "当并列术语结构中出现用词不一致（如\"作\"与\"操作\"混用）或术语后缀不统一时，应触发语言表达一致性规则。\n\n识别模式：\n1. 检测并列结构中的术语序列（如\"getter、setter、deleter和enumerator\"）\n2. 匹配术语后接的动词/名词是否统一（如\"作\"与\"操作\"的简全称混用）\n3. 验证术语搭配是否符合技术文档惯用表达（如编程领域常用\"操作\"对应operation）"
    },
    {
      "defect_id": 434494,
      "sentence": "比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。",
      "reference_sentence": "比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。",
      "line_num": 267,
      "context": "{\"262\":\"} JSVM_TypeTag;\",\"263\":\"```\",\"264\":\"\",\"265\":\"- 存储了两个无符号64位整数的128位值，用它来标记JavaScript对象，确保它们属于某种类型。\",\"266\":\"\",\"267\":\"- 比OH_JSVM_Instanceof更强的类型检查，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。\",\"268\":\"\",\"269\":\"- JSVM_TypeTag 在与 OH_JSVM_Wrap 结合使用时最有用，因为它确保从包装对象检索的指针可以安全地转换为与先前应用于JavaScript对象的类型标记相对应的Native类型。\",\"270\":\"\",\"271\":\"### 回调类型\",\"272\":\"\"}",
      "修改建议": "用词不一致，'更强的类型检查'应改为'更强的类型验证'以保持一致性。",
      "更改后示例": "比OH_JSVM_Instanceof更强的类型验证，如果对象的原型被操纵，OH_JSVM_Instanceof可能会报告误报。",
      "触发条件": "同一技术术语在相邻或相关语境中出现用词不一致（如\"检查\"与\"验证\"混用），且上下文未体现语义差异时；同一功能描述在相近段落中采用不同动词/名词搭配（如\"类型检查\"与\"类型验证\"交替出现）时。"
    },
    {
      "defect_id": 434614,
      "sentence": "创建指定长度的数组。",
      "reference_sentence": "创建指定长度的 JavaScript 数组对象",
      "line_num": 1012,
      "context": "{\"1007\":\"|OH_JSVM_CreateMap | 创建一个新的 JavaScript Map对象 |\",\"1008\":\"|OH_JSVM_CreateRegExp | 根据输入的字符串创建一个JavaScript 正则对象 |\",\"1009\":\"|OH_JSVM_CreateSet | 创建一个新的 JavaScript Set对象 |\",\"1010\":\"\",\"1011\":\"场景示例:\",\"1012\":\"创建指定长度的数组。\",\"1013\":\"\",\"1014\":\"```c++\",\"1015\":\"size_t arrayLength = 2;\",\"1016\":\"JSVM_Value arr;\",\"1017\":\"\"}",
      "修改建议": "用词不一致，需使用统一的句式。",
      "更改后示例": "创建指定长度的JavaScript数组。",
      "触发条件": "同一上下文中的相似句式存在技术栈名称（如JavaScript）或对象类型（如数组、Map）描述不一致时触发。\n\n识别模式：检查文档中邻近条目是否采用“创建...JavaScript [类型]对象”的统一结构，若当前句子缺失技术栈标识符（JavaScript）或对象类型描述不完整（如仅用\"数组\"而非\"数组对象\"），则判定为用词不一致。"
    },
    {
      "defect_id": 434611,
      "sentence": "通过handlescope保护在scope范围内创建的对象在该范围内不被回收。",
      "reference_sentence": "通过OH_JSVM_OpenHandleScope打开一个新的scope，在关闭该scope之前创建的对象在scope范围内不会被GC回收。",
      "line_num": 911,
      "context": "{\"906\":\"| OH_JSVM_GetReferenceValue| 返回由 OH_JSVM_CreateReference 创建的引用的对象 |\",\"907\":\"| OH_JSVM_RetainScript | 持久化保存一个 JSVM_Script, 使其能够跨过当前 scope 使用 |\",\"908\":\"| OH_JSVM_ReleaseScript | 释放持久化保存过的 JSVM_Script，释放之后 JSVM_Script 不再可用，应当置为空 |\",\"909\":\"\",\"910\":\"场景示例：\",\"911\":\"通过handlescope保护在scope范围内创建的对象在该范围内不被回收。\",\"912\":\"\",\"913\":\"```c++\",\"914\":\"JSVM_HandleScope scope;\",\"915\":\"OH_JSVM_OpenHandleScope(env, &scope);\",\"916\":\"JSVM_Value obj = nullptr;\"}",
      "修改建议": "混用了`handlescope`和`OH_JSVM_OpenHandleScope`概念。",
      "更改后示例": "通过OH_JSVM_OpenHandleScope保护在scope范围内创建的对象在该范围内不被回收。",
      "触发条件": "当文档中同一技术概念存在多个术语变体（如\"handlescope\"与\"OH_JSVM_OpenHandleScope\"），且与上下文代码示例/API命名规范不一致时触发。\n\n识别模式：\n1. 技术术语存在非标准缩写（如将\"OH_JSVM_OpenHandleScope\"简写为\"handlescope\"）\n2. 同一功能描述出现跨层命名（框架级概念与具体API名称混用）\n3. 与相邻代码示例中的函数命名存在明显语义断层（如文本描述术语无法对应代码中的实际调用）"
    },
    {
      "defect_id": 434615,
      "sentence": "创建typedarray，以Int32Array为例：\r",
      "reference_sentence": "在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型",
      "line_num": 1027,
      "context": "{\"1022\":\"    OH_JSVM_CreateUint32(env, i * 2, &element);\",\"1023\":\"    OH_JSVM_SetElement(env, arr, i, element);\",\"1024\":\"}\",\"1025\":\"```\",\"1026\":\"\",\"1027\":\"创建typedarray，以Int32Array为例：\",\"1028\":\"\",\"1029\":\"```c++\",\"1030\":\"JSVM_Value arrayBuffer = nullptr;\",\"1031\":\"void *arrayBufferPtr = nullptr;\",\"1032\":\"size_t arrayBufferSize = 16;\"}",
      "修改建议": "用词不一致，需使用统一的句式。",
      "更改后示例": "创建TypedArray，以Int32Array为例：",
      "触发条件": "当文档中同一技术术语存在大小写不一致（如\"typedarray\"与\"TypedArray\"混用），且上下文存在该术语的规范写法（如参考句中的\"TypedArray\"）时触发。\n\n识别模式：\n1. 检测到技术术语在相邻段落/代码注释中存在不同大小写形式（如驼峰式与全小写混用）\n2. 通过术语对照发现与参考句/文档规范写法（如首字母大写）不匹配\n3. 术语位于代码示例说明等需要严格保持专业术语规范的上下文位置"
    },
    {
      "defect_id": 434575,
      "sentence": "默认作用域的生命周期与本机方法调用的生命周期相关联，这些句柄及关联的对象将在Native方法的生命周期内保持活动状态。",
      "reference_sentence": "创建及销毁JavaScript引擎实例，包含创建及销毁JS执行上下文环境",
      "line_num": 890,
      "context": "{\"885\":\"\",\"886\":\"### 对象生命周期管理\",\"887\":\"\",\"888\":\"在调用JSVM-API接口时，底层VM堆中的对象可能会作为JSVM_Values返回句柄。这些句柄必须在Native方法退出或主动释放掉前，使其关联的对象处于“活动”状态，防止被引擎回收掉。\",\"889\":\"\",\"890\":\"当对象句柄被返回时，它们与一个“scope”相关联。默认作用域的生命周期与本机方法调用的生命周期相关联，这些句柄及关联的对象将在Native方法的生命周期内保持活动状态。\",\"891\":\"\",\"892\":\"然而，在许多情况下，句柄必须保持有效的时间范围并不与Native方法的生命周期相同。下面将介绍可用于更改句柄的生命周期的JSVM-API方法。\",\"893\":\"\",\"894\":\"#### 对象生命周期管理接口说明\",\"895\":\"| 接口 | 功能说明 |\"}",
      "修改建议": "用词不一致，'本机方法'与'Native方法'混用",
      "更改后示例": "默认作用域的生命周期与Native方法调用的生命周期相关联，这些句柄及关联的对象将在Native方法的生命周期内保持活动状态。",
      "触发条件": "同一术语在相邻或同一段落中出现中文译名不一致（如\"本机方法\"与\"Native方法\"混用），或中英文形式与文档既定表达冲突时触发。\n\n识别模式：\n1. **术语变体共存**：同一核心概念存在两种及以上表达形式（如中文直译\"本机方法\"与保留英文\"Native方法\"）\n2. **邻近冲突**：不一致表达出现在同一段落/相邻句子中（如问题句与上下文出现\"Native方法\"但本句使用\"本机方法\"）\n3. **文档惯例偏离**：与文档高频使用形式相悖（如上下文已确立\"Native方法\"为首选表达）"
    },
    {
      "defect_id": 434531,
      "sentence": "编译及执行JS代码(创建vm，注册function，执行js，销毁vm)。",
      "reference_sentence": "编译及执行JS代码。\r",
      "line_num": 568,
      "context": "{\"563\":\"| OH_JSVM_CompileScriptWithOptions | 通用的编译接口，通过传入 option 数组完成前面的 compile 接口全部功能，同时支持后续选项扩展 |\",\"564\":\"| OH_JSVM_CreateCodeCache         | 为编译脚本创建code cache                                                                  |\",\"565\":\"| OH_JSVM_RunScript               | 执行编译脚本                                                                             |\",\"566\":\"\",\"567\":\"场景示例：\",\"568\":\"编译及执行JS代码(创建vm，注册function，执行js，销毁vm)。\",\"569\":\"\",\"570\":\"cpp 部分代码\",\"571\":\"\",\"572\":\"```c++\",\"573\":\"#include <cstring>\"}",
      "修改建议": "在同一段落中，'创建vm'与'创建 VM 实例'混用，建议统一用词。",
      "更改后示例": "编译及执行 JS 代码（创建 VM 实例，注册函数，执行 JS，销毁 VM 实例）",
      "触发条件": "同一段落或相邻上下文中存在同一术语的缩写/全称混用（如\"vm\"与\"VM 实例\"），且存在并列结构的短语列表时。\n\n识别模式：\n1. 检测相邻句子/括号内并列短语的术语形态（如\"vm\"为缩写，\"VM 实例\"为全称）\n2. 验证上下文是否已存在该术语的标准表达形式（如参考句子中的\"JS\"大写统一）\n3. 当缩略语未保持首字母大写规范（如vm应写作VM）或缺失必要修饰词（如\"实例\"）时触发"
    },
    {
      "defect_id": 434530,
      "sentence": "创建及销毁JavaScript引擎实例，包含创建及销毁JS执行上下文环境",
      "reference_sentence": "创建 VM 实例",
      "line_num": 453,
      "context": "{\"448\":\"调用 LowGCFrequencyInit 接口进行 VM 平台初始化执行 JavaScript 脚本，相比调用 NormalInit 接口所触发的 GC 频次更低。调用 LowMemoryInit 接口进行 VM 平台初始化执行 JavaScript 脚本，相比调用 NormalInit 接口所占用内存更少。\",\"449\":\"\",\"450\":\"##### 创建 VM 实例\",\"451\":\"\",\"452\":\"场景示例:\",\"453\":\"创建及销毁JavaScript引擎实例，包含创建及销毁JS执行上下文环境\",\"454\":\"```c++\",\"455\":\"bool VM_INIT = false;\",\"456\":\"\",\"457\":\"static JSVM_Value ConsoleInfo(JSVM_Env env, JSVM_CallbackInfo info) {\",\"458\":\"    size_t argc = 1;\"}",
      "修改建议": "在同一段落中，'创建及销毁'与'创建'混用，建议统一用词。",
      "更改后示例": "创建及销毁 JavaScript 引擎实例，包含创建及销毁 JS 执行上下文环境",
      "触发条件": "同一段落或邻近上下文中存在重复动作描述但动词短语结构不一致（如“创建及销毁”与“创建”混用），且未通过技术术语缩写或上下文明确区分语义差异。\n\n识别模式：\n1. **动作重复性**：检测同一段落内对同一技术动作（如创建/销毁）的多次描述；\n2. **短语结构对比**：识别动词短语结构差异（如双动作联合结构“创建及销毁” vs 单动作“创建”）；\n3. **语义等价性**：通过上下文判断不同短语是否指向相同技术操作，且无明确理由需要差异化表达。"
    },
    {
      "defect_id": 434498,
      "sentence": "OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。",
      "reference_sentence": "OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。",
      "line_num": 298,
      "context": "{\"293\":\"typedef JSVM_CallbackStruct* JSVM_Callback;\",\"294\":\"```\",\"295\":\"\",\"296\":\"**JSVM_CallbackInfo**\",\"297\":\"\",\"298\":\"用户定义的 Native callback，第一个参数类型是 JSVM_Env，第二个参数类型是 JSVM_CallbackInfo。JSVM_CallbackInfo 表示从 JS 侧调用到 Native 侧时携带的调用信息，如参数列表。在实现 Native callback 时，一般使用 OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。\",\"299\":\"\",\"300\":\"**JSVM_Finalize**\",\"301\":\"\",\"302\":\"函数指针，用于传入OH_JSVM_SetInstanceData、OH_JSVM_CreateExternal、OH_JSVM_Wrap等接口。JSVM_Finalize在对象被回收后会被调用，可用于在JavaScript对象被垃圾回收时释放Native对象。JSVM 不保证是否执行该回调函数，也不保证执行该回调函数的时机，**开发者不应依赖于该回调的执行时机**。\",\"303\":\"\"}",
      "修改建议": "用词不一致，'提取调用信息'应改为'获取调用信息'以保持一致性。",
      "更改后示例": "OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中获取调用信息。",
      "触发条件": "当技术文档中描述接口功能的动词（如\"获取\"）与接口名称中的核心动词（如\"Get\"）存在中英文对应关系，但实际描述使用了其他同义词（如\"提取\"）时触发；或同一上下文中相同操作使用不同动词表述时触发。\n\n识别模式：\n1. 接口名称包含明确动作动词（如Get/Set/Create）\n2. 功能描述中使用与接口名称动词不一致的中文对应词（如接口名用Get但描述用\"提取\"）\n3. 相邻段落存在相同操作的标准表述（如参考句子中的\"提取\"与修复后的\"获取\"形成冲突）\n4. 技术术语存在明确的中英文对应规范（如Get=获取，Set=设置）"
    },
    {
      "defect_id": 434527,
      "sentence": "场景示例：\r常规模式下初始化 VM 平台",
      "reference_sentence": "场景示例：\r初始化低内存占用的 VM 平台",
      "line_num": 395,
      "context": "{\"390\":\"JSVM 提供了多种配置选项，允许开发者在执行 `OH_JSVM_Init` 时灵活配置其行为。可以通过 `OH_JSVM_GetVMInfo` 接口获取当前 JSVM 版本所对应的 V8 引擎版本。JSVM 中可支持的选项范围与对应的 V8 引擎版本可支持的选项范围保持一致。`OH_JSVM_GetVMInfo` 接口的使用参考[使用JSVM-API接口获取JSVM API的版本号](use-jsvm-about-version.md)。\",\"391\":\"\",\"392\":\"**注意：** 建议开发者在非必要情况下，仅使用 JSVM 内部的默认配置选项。\",\"393\":\"\",\"394\":\"场景示例：\",\"395\":\"常规模式下初始化 VM 平台\",\"396\":\"```c++\",\"397\":\"static void NormalInit(bool &vmInit) {\",\"398\":\"    if (!vmInit) {\",\"399\":\"        // JSVM only need init once\",\"400\":\"        JSVM_InitOptions initOptions;\"}",
      "修改建议": "在同一段落中，'初始化'与'创建'混用，建议统一用词。",
      "更改后示例": "场景示例：\r创建常规模式下的 VM 平台",
      "触发条件": "同一段落或邻近上下文中出现对同一操作使用多个不同动词（如\"初始化\"和\"创建\"），且存在已统一使用的标准术语时。\n\n识别模式：\n1. 检测3-5句范围内出现描述相同操作但使用不同动词\n2. 对比文档其他部分(如参考句中的\"初始化\")确认标准用词\n3. 当非标准用词与上下文已建立的术语不匹配时触发修复"
    },
    {
      "defect_id": 434648,
      "sentence": "根据 UTF-8 编码的C字符串创建一个 JavaScript 字符串，以及获取给定 JavaScript 字符串的 UTF-8 编码C字符串。",
      "reference_sentence": "根据 UTF-8 编码的 C 字符串创建一个 JavaScript 字符串，以及获取给定 JavaScript 字符串的 UTF-8 编码 C 字符串。",
      "line_num": 1160,
      "context": "{\"1155\":\"void *tmpArrayBufferPtr = nullptr;\",\"1156\":\"size_t arrayBufferLength = 0;\",\"1157\":\"OH_JSVM_GetArraybufferInfo(env, retArrayBuffer, &tmpArrayBufferPtr, &arrayBufferLength);\",\"1158\":\"```\",\"1159\":\"\",\"1160\":\"根据 UTF-8 编码的C字符串创建一个 JavaScript 字符串，以及获取给定 JavaScript 字符串的 UTF-8 编码C字符串。\",\"1161\":\"\",\"1162\":\"```c++\",\"1163\":\"const char *testStringStr = \\\"testString\\\";\",\"1164\":\"JSVM_Value testString = nullptr;\",\"1165\":\"OH_JSVM_CreateStringUtf8(env, testStringStr, strlen(testStringStr), &testString);\"}",
      "修改建议": "混用了`C字符串`和`C 字符串`概念",
      "更改后示例": "根据 UTF-8 编码的 C 字符串创建一个 JavaScript 字符串，以及获取给定 JavaScript 字符串的 UTF-8 编码 C 字符串。",
      "触发条件": "同一术语在相邻或相近上下文中出现格式变体（如\"C字符串\"与\"C 字符串\"），且存在空格/连字符等符号使用不一致时触发。\n\n识别模式：通过正则表达式匹配\"([A-Za-z]+)[\\s-]?(字符串|编码)\"类结构，检测相邻段落中相同术语组合是否保持统一间隔格式（如\"C 字符串\"应统一空格），特别关注技术名词与普通名词的组合形态一致性。"
    },
    {
      "defect_id": 434704,
      "sentence": "判断两个JS值类型是否严格相同：先比较操作数类型，操作数类型不同就是不相等，操作数类型相同时，比较值是否相等，相等才返回true。",
      "reference_sentence": "判断两个 JSVM_Value 对象是否严格相等",
      "line_num": 1250,
      "context": "{\"1245\":\"OH_JSVM_GetBoolean(env, false, &boolValue);\",\"1246\":\"JSVM_Value bigIntValue;\",\"1247\":\"OH_JSVM_CoerceToBigInt(env, boolValue, &bigIntValue);\",\"1248\":\"```\",\"1249\":\"\",\"1250\":\"判断两个JS值类型是否严格相同：先比较操作数类型，操作数类型不同就是不相等，操作数类型相同时，比较值是否相等，相等才返回true。\",\"1251\":\"\",\"1252\":\"```c++\",\"1253\":\"JSVM_Value value = nullptr;\",\"1254\":\"JSVM_Value value1 = nullptr;\",\"1255\":\"OH_JSVM_CreateArray(env, &value);\"}",
      "修改建议": "混用了'JS值'和'JSVM_Value'术语",
      "更改后示例": "判断两个JSVM_Value对象类型是否严格相同：先比较操作数类型，操作数类型不同就是不相等，操作数类型相同时，比较值是否相等，相等才返回true。",
      "触发条件": "同一文档中针对相同技术概念出现多个不一致的命名术语（如\"JS值\"与\"JSVM_Value\"混用），且上下文存在已明确定义的标准术语（如代码示例中的JSVM_Value类型高频出现）。"
    },
    {
      "defect_id": 434651,
      "sentence": "|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |",
      "reference_sentence": "|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 DataView 类型对象 |",
      "line_num": 1194,
      "context": "{\"1189\":\"|OH_JSVM_Instanceof | 判断一个对象是否是某个构造函数的实例 |\",\"1190\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1191\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1192\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1193\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1194\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1195\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1196\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1197\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1198\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1199\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\"}",
      "修改建议": "混用了`Dataview`和`DataView`概念",
      "更改后示例": "|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 DataView 类型对象 |",
      "触发条件": "文档中出现同一技术术语存在大小写不一致（如DataView/Dataview）或与官方命名规范不符的拼写变体，且上下文存在正确拼写参考时。\n\n识别模式：通过对比相邻条目中的术语格式（如ArrayBuffer vs Arraybuffer）及标准技术名称（如JavaScript中的DataView类型），检测到非常规大小写组合或拼写错误时触发规则。"
    },
    {
      "defect_id": 434703,
      "sentence": "将boolean类型转换为bigint类型",
      "reference_sentence": "将目标值转换为 BigInt 类型对象",
      "line_num": 1241,
      "context": "{\"1236\":\"\",\"1237\":\"OH_JSVM_GetValueStringUtf8(env, stringValue, buffer, bufferSize, &copied);\",\"1238\":\"// buffer:\\\"123\\\";\",\"1239\":\"```\",\"1240\":\"\",\"1241\":\"将boolean类型转换为bigint类型\",\"1242\":\"\",\"1243\":\"```c++\",\"1244\":\"JSVM_Value boolValue;\",\"1245\":\"OH_JSVM_GetBoolean(env, false, &boolValue);\",\"1246\":\"JSVM_Value bigIntValue;\"}",
      "修改建议": "混用了'boolean'和'BigInt'术语",
      "更改后示例": "将boolean类型转换为BigInt类型",
      "触发条件": "同一术语在相邻上下文中存在不一致的大小写形式（如\"bigint\"与\"BigInt\"），且该术语在代码/规范中有明确的大小写标准（如参考句使用\"BigInt\"）。"
    },
    {
      "defect_id": 434650,
      "sentence": "|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |",
      "reference_sentence": "|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 TypedArray 类型对象 |",
      "line_num": 1193,
      "context": "{\"1188\":\"|OH_JSVM_Typeof | 返回 JavaScript 对象的类型 |\",\"1189\":\"|OH_JSVM_Instanceof | 判断一个对象是否是某个构造函数的实例 |\",\"1190\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1191\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1192\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1193\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1194\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1195\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1196\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1197\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1198\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\"}",
      "修改建议": "混用了`Typedarray`和`TypedArray`概念",
      "更改后示例": "|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 TypedArray 类型对象 |",
      "触发条件": "当文档中同一技术术语出现大小写不一致（如驼峰命名错误）且存在正确拼写的参考实例时触发；或当术语拼写与上下文已确立的标准形式（如ArrayBuffer/TypedArray）不匹配时触发。\n\n识别模式：\n1. 检测专有名词的标准驼峰结构（如TypedArray应为T大写A大写）\n2. 对比相邻条目的一致性（如Arraybuffer→ArrayBuffer，Dataview→DataView的修正模式）\n3. 匹配JavaScript原生对象的标准名称（如TypedArray是ECMAScript规范术语）"
    },
    {
      "defect_id": 434706,
      "sentence": "判断JS值是否为map类型",
      "reference_sentence": "此API检查传入的值是否为Map",
      "line_num": 1293,
      "context": "{\"1288\":\"OH_JSVM_CreateFunction(env, \\\"func\\\", JSVM_AUTO_LENGTH, &param, &value);\",\"1289\":\"bool isConstructor = false;\",\"1290\":\"OH_JSVM_IsConstructor(env, value, &isConstructor); // 这里isConstructor的值是true\",\"1291\":\"```\",\"1292\":\"\",\"1293\":\"判断JS值是否为map类型\",\"1294\":\"\",\"1295\":\"```c++\",\"1296\":\"JSVM_Value value = nullptr;\",\"1297\":\"OH_JSVM_CreateMap(env, &value);\",\"1298\":\"bool isMap = false;\"}",
      "修改建议": "混用了'map'和'Map'术语",
      "更改后示例": "判断JS值是否为Map类型",
      "触发条件": "同一技术术语在文档中出现大小写不一致（如\"map\"与\"Map\"混用），且上下文存在明确的大写规范（如代码示例/类型系统要求首字母大写的特定数据结构名称）。"
    },
    {
      "defect_id": 434705,
      "sentence": "判断两个JS值类型是否宽松相同：判断两个操作数的类型是否相同，若不相同，且可以转换为相同的数据类型，转换为相同的数据类型后，值做严格相等比较，其他的都返回false。",
      "reference_sentence": "判断两个 JSVM_Value 对象是否宽松相等",
      "line_num": 1262,
      "context": "{\"1257\":\"OH_JSVM_CreateInt32(env, 10, &value1);\",\"1258\":\"bool isArray = true;\",\"1259\":\"OH_JSVM_StrictEquals(env, value, value, &isArray);\",\"1260\":\"```\",\"1261\":\"\",\"1262\":\"判断两个JS值类型是否宽松相同：判断两个操作数的类型是否相同，若不相同，且可以转换为相同的数据类型，转换为相同的数据类型后，值做严格相等比较，其他的都返回false。\",\"1263\":\"\",\"1264\":\"```c++\",\"1265\":\"JSVM_HandleScope handleScope;\",\"1266\":\"OH_JSVM_OpenHandleScope(env, &handleScope);\",\"1267\":\"const char testStr[] = \\\"1\\\";\"}",
      "修改建议": "混用了'JS值'和'JSVM_Value'术语",
      "更改后示例": "判断两个JSVM_Value对象类型是否宽松相同：判断两个操作数的类型是否相同，若不相同，且可以转换为相同的数据类型，转换为相同的数据类型后，值做严格相等比较，其他的都返回false。",
      "触发条件": "文档中同一技术概念出现多个不一致术语表述（如\"JS值\"与\"JSVM_Value\"混用），或技术术语与代码实现中的实际类型/对象名称（如JSVM_Value）不匹配时触发。\n\n识别模式：\n1. 术语对比：检测核心技术名词（如JSVM_Value）在段落中是否被其他同义表述（如JS值）替代\n2. 代码一致性验证：当文档描述涉及具体API/代码片段时，检查术语是否与相邻代码示例中的类型声明/函数参数（如JSVM_HandleScope）保持严格一致"
    },
    {
      "defect_id": 434701,
      "sentence": "判断JS值是否为数组类型",
      "reference_sentence": "判断一个 JavaScript 对象是否为 Array 类型对象",
      "line_num": 1215,
      "context": "{\"1210\":\"|OH_JSVM_Equals | 判断两个 JSVM_Value 对象是否宽松相等 |\",\"1211\":\"|OH_JSVM_DetachArraybuffer | 调用 ArrayBuffer 对象的Detach操作 |\",\"1212\":\"|OH_JSVM_IsDetachedArraybuffer | 检查给定的 ArrayBuffer 是否已被分离(detached) |\",\"1213\":\"\",\"1214\":\"场景示例:\",\"1215\":\"判断JS值是否为数组类型\",\"1216\":\"\",\"1217\":\"```c++\",\"1218\":\"JSVM_Value array = nullptr;\",\"1219\":\"OH_JSVM_CreateArray(env, &array);\",\"1220\":\"bool isArray = false;\"}",
      "修改建议": "混用了'数组'和'Array'术语",
      "更改后示例": "判断JS值是否为Array类型",
      "触发条件": "同一技术术语在文档中存在中英文混用（如\"数组\"与\"Array\"），且上下文/参考示例已确立统一英文术语（如邻近条目使用\"ArrayBuffer\"、\"Array 类型对象\"）时触发。"
    },
    {
      "defect_id": 434744,
      "sentence": "对象绑定操作。",
      "reference_sentence": "对象绑定操作",
      "line_num": 1509,
      "context": "{\"1504\":\"|OH_JSVM_DefineClass| 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持。 |\",\"1505\":\"|OH_JSVM_Wrap| 在 JavaScript 对象中封装原生实例。稍后可以使用 OH_JSVM_Unwrap() 检索原生实例。 |\",\"1506\":\"|OH_JSVM_Unwrap | 使用 OH_JSVM_Wrap() 检索先前封装在 JavaScript 对象中的原生实例。 |\",\"1507\":\"|OH_JSVM_RemoveWrap | 检索先前封装在 JavaScript 对象中的原生实例并移除封装。 |\",\"1508\":\"|OH_JSVM_TypeTagObject | 将 type_tag 指针的值与 JavaScript 对象或外部对象相关联。 |\",\"1509\":\"|OH_JSVM_CheckObjectTypeTag | 检查给定的类型标签是否与对象上的类型标签匹配。 |\",\"1510\":\"|OH_JSVM_AddFinalizer | 为对象添加 JSVM_Finalize 回调，以便在 JavaScript 对象被垃圾回收时调用来释放原生对象。 |\",\"1511\":\"|OH_JSVM_DefineClassWithPropertyHandler | 定义一个具有给定类名、构造函数、属性和回调处理程序的JavaScript类，并作为函数回调进行调用。属性操作包括getter、setter、deleter、enumerator等。 |\",\"1512\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"1513\":\"\",\"1514\":\"场景示例：\"}",
      "修改建议": "混用了'对象绑定操作'和'对象绑定操作。'，应保持一致",
      "更改后示例": "对象绑定操作",
      "触发条件": "同一文档块内相邻条目存在标点符号不一致（如句号使用差异），或当前句子与参考句子的标点格式（如末尾是否含句号）不匹配时触发。\n\n识别模式：\n1. 检查上下文相邻条目（如问题上下文中的1504-1512条目）是否采用统一的无句号结尾格式\n2. 对比当前句子与参考句子（如\"对象绑定操作\"）的标点使用一致性\n3. 发现同一术语在相邻位置存在冗余标点（如问题句多出句号）时标记异常"
    },
    {
      "defect_id": 434743,
      "sentence": "创建Function:",
      "reference_sentence": "创建JavaScript函数操作",
      "line_num": 1481,
      "context": "{\"1476\":\"    JSVM_CALL(env, OH_JSVM_CallFunction(env, global, args[0], 0, nullptr, &ret));\",\"1477\":\"    return ret;\",\"1478\":\"}\",\"1479\":\"```\",\"1480\":\"\",\"1481\":\"创建Function:\",\"1482\":\"\",\"1483\":\"```c++\",\"1484\":\"JSVM_Value script;\",\"1485\":\"OH_JSVM_CreateStringUtf8(env, \\\"return a + b;\\\", JSVM_AUTO_LENGTH, &script);\",\"1486\":\"JSVM_Value param1;\"}",
      "修改建议": "混用了'创建'和'创建Function:'，应保持一致",
      "更改后示例": "创建JavaScript函数:",
      "触发条件": "同一功能描述中混用中英文术语（如\"Function\"与\"函数\"）或出现术语全称/简称不一致（如\"JavaScript函数\"与\"Function\"），且上下文存在明确对应操作类型（如JavaScript函数创建）时触发。"
    },
    {
      "defect_id": 435373,
      "sentence": "2. 创建任务[Task](../reference/apis-arkts/js-apis-taskpool.md#task)，通过[execute()](../reference/apis-arkts/js-apis-taskpool.md#taskpoolexecute-1)接口执行该任务。",
      "reference_sentence": "2. 创建任务[Task](../reference/apis-arkts/js-apis-taskpool.md#task)，通过[execute()](../reference/apis-arkts/js-apis-taskpool.md#taskpoolexecute-1)接口执行该任务。",
      "line_num": 28,
      "context": "{\"23\":\">\",\"24\":\"> 由于[Actor模型](multi-thread-concurrency-overview.md#actor模型)不同线程间内存隔离的特性，普通单例无法在不同线程间使用。可以通过共享模块导出单例解决该问题。\",\"25\":\"\",\"26\":\"1. 定义并发函数，实现业务逻辑。\",\"27\":\"\",\"28\":\"2. 创建任务[Task](../reference/apis-arkts/js-apis-taskpool.md#task)，通过[execute()](../reference/apis-arkts/js-apis-taskpool.md#taskpoolexecute-1)接口执行该任务。\",\"29\":\"\",\"30\":\"3. 对任务返回的结果进行操作。\",\"31\":\"\",\"32\":\"如下示例中业务使用TaskPool调用相关同步方法的代码，首先定义并发函数taskpoolFunc，需要注意必须使用[@Concurrent装饰器](taskpool-introduction.md#concurrent装饰器)装饰该函数；其次定义函数mainFunc，该函数功能为创建任务，执行任务并处理任务返回的结果。\",\"33\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "创建任务[Task](../reference/apis-arkts/js-apis-taskpool.md#task)，通过[execute()](../reference/apis-arkts/js-apis-taskpool.md#taskpoolexecute-1)接口执行该任务。",
      "触发条件": "当同一列表项中存在混合使用祈使句（动词开头）与非祈使句（介词/连词开头）结构，且上下文步骤序列采用统一祈使句式时触发。\n\n识别模式：\n1. 检查句首结构：若步骤项前半句为动词开头的祈使句（如\"创建任务\"），后半句却出现介词/连词引导的非祈使结构（如\"通过...执行\"缺少主语）\n2. 对比上下文：当相邻步骤项（如示例中的步骤1/3）均保持\"动词短语+补充说明\"的对称结构时，混合句式会破坏一致性"
    },
    {
      "defect_id": 434702,
      "sentence": "将int32类型转换为string类型",
      "reference_sentence": "将目标值转换为 String 类型对象",
      "line_num": 1224,
      "context": "{\"1219\":\"OH_JSVM_CreateArray(env, &array);\",\"1220\":\"bool isArray = false;\",\"1221\":\"OH_JSVM_IsArray(env, array, &isArray);\",\"1222\":\"```\",\"1223\":\"\",\"1224\":\"将int32类型转换为string类型\",\"1225\":\"\",\"1226\":\"```c++\",\"1227\":\"int32_t num = 123;\",\"1228\":\"JSVM_Value intValue;\",\"1229\":\"OH_JSVM_CreateInt32(env, num, &intValue);\"}",
      "修改建议": "混用了'int32'和'String'术语",
      "更改后示例": "将int32类型转换为String类型",
      "触发条件": "当同一技术术语在相邻上下文中出现大小写不一致（如\"string\"与\"String\"）或框架命名风格冲突（如基础类型与框架对象类型混用）时触发。"
    },
    {
      "defect_id": 434646,
      "sentence": "创建64位的BigInt，并获取64位int值。",
      "reference_sentence": "创建64位的 BigInt，并获取64位 Int64 值。",
      "line_num": 1115,
      "context": "{\"1110\":\"|OH_JSVM_GetGlobal | 返回当前环境中的全局 global 对象 |\",\"1111\":\"|OH_JSVM_GetNull | 返回 JavaScript null 对象 |\",\"1112\":\"|OH_JSVM_GetUndefined | 返回 JavaScript Undefined 对象 |\",\"1113\":\"\",\"1114\":\"场景示例：\",\"1115\":\"创建64位的BigInt，并获取64位int值。\",\"1116\":\"\",\"1117\":\"```c++\",\"1118\":\"int64_t testValue = INT64_MAX;\",\"1119\":\"JSVM_Value result = nullptr;\",\"1120\":\"OH_JSVM_CreateBigintInt64(env, testValue, &result);\"}",
      "修改建议": "混用了`int`和`Int64`概念",
      "更改后示例": "创建64位的 BigInt，并获取64位 Int64 值。",
      "触发条件": "同一技术概念在相邻语句中使用了不一致的术语（如`int`与`Int64`混用），且上下文存在明确对应的规范术语（如代码示例中的`int64_t`）。\n\n识别模式：\n1. 检测相邻句子/短语中同一技术实体的不同表述形式（如基础类型`int`与具体类型`Int64`）\n2. 匹配代码上下文中的实际类型声明（如`int64_t`）作为术语规范依据\n3. 验证术语是否符合项目命名规范（如首字母大写的`Int64`对应C++的`int64_t`类型）"
    },
    {
      "defect_id": 435372,
      "sentence": "1. 定义并发函数，实现业务逻辑。",
      "reference_sentence": "1. 定义并发函数，实现业务逻辑。",
      "line_num": 26,
      "context": "{\"21\":\"\",\"22\":\"> **说明：**\",\"23\":\">\",\"24\":\"> 由于[Actor模型](multi-thread-concurrency-overview.md#actor模型)不同线程间内存隔离的特性，普通单例无法在不同线程间使用。可以通过共享模块导出单例解决该问题。\",\"25\":\"\",\"26\":\"1. 定义并发函数，实现业务逻辑。\",\"27\":\"\",\"28\":\"2. 创建任务[Task](../reference/apis-arkts/js-apis-taskpool.md#task)，通过[execute()](../reference/apis-arkts/js-apis-taskpool.md#taskpoolexecute-1)接口执行该任务。\",\"29\":\"\",\"30\":\"3. 对任务返回的结果进行操作。\",\"31\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "定义并发函数，实现业务逻辑。",
      "触发条件": "同一列表或连续步骤中的句子存在句式不统一（如祈使句与陈述句混用），或动词短语结构不一致（如单动作/双动作描述差异）。通过检测相邻编号项是否采用相同语法结构（如\"动词+宾语\"句式）及标点模式（如逗号分隔动作）进行识别。"
    },
    {
      "defect_id": 434745,
      "sentence": "对象绑定操作。",
      "reference_sentence": "对象绑定操作",
      "line_num": 1515,
      "context": "{\"1510\":\"|OH_JSVM_AddFinalizer | 为对象添加 JSVM_Finalize 回调，以便在 JavaScript 对象被垃圾回收时调用来释放原生对象。 |\",\"1511\":\"|OH_JSVM_DefineClassWithPropertyHandler | 定义一个具有给定类名、构造函数、属性和回调处理程序的JavaScript类，并作为函数回调进行调用。属性操作包括getter、setter、deleter、enumerator等。 |\",\"1512\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"1513\":\"\",\"1514\":\"场景示例：\",\"1515\":\"对象绑定操作。\",\"1516\":\"\",\"1517\":\"```c++\",\"1518\":\"static int aa = 0; \",\"1519\":\"\",\"1520\":\"static JSVM_Value AssertEqual(JSVM_Env env, JSVM_CallbackInfo info)\"}",
      "修改建议": "混用了'对象绑定操作'和'对象绑定操作。'，应保持一致",
      "更改后示例": "对象绑定操作",
      "触发条件": "同一文档中相邻或结构相似的条目在标点符号使用（如句号结尾）上存在不一致，且上下文存在明确的一致性表达范式时触发。\n\n识别模式：\n1. 对比相邻条目（如表格项、列表项）的结尾符号，检测是否出现部分条目冗余标点（如句号）而其他条目缺失；\n2. 检查同一术语/短语在相同上下文位置（如标题、表格单元格）是否出现标点变体（如\"操作\"与\"操作。\"）；\n3. 验证是否存在可追溯的参考基准（如上下文中90%同类条目无句号结尾）。"
    },
    {
      "defect_id": 434741,
      "sentence": "创建JavaScript函数操作",
      "reference_sentence": "场景示例: 创建JavaScript函数操作",
      "line_num": 1434,
      "context": "{\"1429\":\"|OH_JSVM_GetNewTarget | 获取构造函数调用的new.target |\",\"1430\":\"|OH_JSVM_NewInstance | 通过给定的构造函数，构建一个实例 |\",\"1431\":\"|OH_JSVM_CreateFunctionWithScript | 根据传入的函数体和函数参数列表，创建一个新的 JavaScript Function对象 |\",\"1432\":\"\",\"1433\":\"场景示例:\",\"1434\":\"创建JavaScript函数操作\",\"1435\":\"\",\"1436\":\"```c++\",\"1437\":\"JSVM_Value SayHello(JSVM_Env env, JSVM_CallbackInfo info)\",\"1438\":\"{\",\"1439\":\"    printf(\\\"Hello\\\\n\\\");\"}",
      "修改建议": "混用了'创建'和'场景示例：创建'，应保持一致",
      "更改后示例": "场景示例: 创建JavaScript函数操作",
      "触发条件": "当同一层级/结构的标题与内容条目中，动词或关键术语未保持严格一致（如标题使用\"场景示例: 创建\"，内容条目却仅用\"创建\"而未重复完整前缀结构），或相邻条目间动词短语模式不匹配时触发。"
    },
    {
      "defect_id": 434647,
      "sentence": "创建一个Int32Array，并获取其长度，byteoffset等信息。",
      "reference_sentence": "创建一个 Int32Array，并获取其长度、byteOffset 等信息。",
      "line_num": 1126,
      "context": "{\"1121\":\"int64_t resultValue = 0;\",\"1122\":\"bool flag = false;\",\"1123\":\"OH_JSVM_GetValueBigintInt64(env, result, &resultValue, &flag);\",\"1124\":\"```\",\"1125\":\"\",\"1126\":\"创建一个Int32Array，并获取其长度，byteoffset等信息。\",\"1127\":\"\",\"1128\":\"```c++\",\"1129\":\"JSVM_Value arrayBuffer = nullptr;\",\"1130\":\"void *arrayBufferPtr = nullptr;\",\"1131\":\"size_t arrayBufferSize = 16;\"}",
      "修改建议": "混用了`byteoffset`和`byteOffset`概念",
      "更改后示例": "创建一个 Int32Array，并获取其长度、byteOffset 等信息。",
      "触发条件": "文本中存在技术术语或API名称的大小写形式与官方文档或上下文标准不一致（如`byteoffset`未使用驼峰式`byteOffset`），或同一术语在文档中出现多种拼写形式时触发。\n\n识别模式：\n1. 检测到技术名词（如Int32Array、byteOffset）未遵循驼峰命名规范\n2. 同一术语在相邻段落/代码注释中出现不一致的大小写形式（如`byteoffset`与`byteOffset`共存）\n3. 术语在代码示例中的正确形式（如JSVM_Value）与文本描述中的形式（如int32array）存在格式差异"
    },
    {
      "defect_id": 434649,
      "sentence": "|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |",
      "reference_sentence": "|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象 |",
      "line_num": 1191,
      "context": "{\"1186\":\"|OH_JSVM_CoerceToString | 将目标值转换为 String 类型对象 |\",\"1187\":\"|OH_JSVM_CoerceToBigInt | 将目标值转换为 BigInt 类型对象 |\",\"1188\":\"|OH_JSVM_Typeof | 返回 JavaScript 对象的类型 |\",\"1189\":\"|OH_JSVM_Instanceof | 判断一个对象是否是某个构造函数的实例 |\",\"1190\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1191\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1192\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1193\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1194\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1195\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1196\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\"}",
      "修改建议": "混用了`Arraybuffer`和`ArrayBuffer`概念",
      "更改后示例": "|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象 |",
      "触发条件": "文档中出现同一技术术语存在大小写不一致（如Arraybuffer与ArrayBuffer混用）或术语拼写与标准命名规范不符时。\n\n识别模式：\n1. 通过驼峰格式校验识别术语规范性（如ArrayBuffer应为标准名称）\n2. 对比上下文相邻条目保持的命名风格（如前后条目均使用首字母大写的Array/Date类型）\n3. 匹配编程语言原生对象的标准命名（如JavaScript中实际存在ArrayBuffer类型）"
    },
    {
      "defect_id": 434707,
      "sentence": "JS对象属性的增删获取和判断",
      "reference_sentence": "JS对象属性的增加、删除、获取和判断",
      "line_num": 1353,
      "context": "{\"1348\":\"|OH_JSVM_ObjectSeal | 密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。 |\",\"1349\":\"|OH_JSVM_ObjectSetPrototypeOf | 为给定对象设置一个原型。 |\",\"1350\":\"|OH_JSVM_ObjectGetPrototypeOf | 获取给定JavaScript对象的原型。 |\",\"1351\":\"\",\"1352\":\"场景示例:\",\"1353\":\"JS对象属性的增删获取和判断\",\"1354\":\"\",\"1355\":\"```c++\",\"1356\":\"// 创建一个空对象\",\"1357\":\"JSVM_Value myObject = nullptr;\",\"1358\":\"OH_JSVM_CreateObject(env, &myObject);\"}",
      "修改建议": "混用了'增删'和'增加、删除'术语",
      "更改后示例": "JS对象属性的增加、删除、获取和判断",
      "触发条件": "同一术语在相邻上下文出现缩略与全称混用（如\"增删\"与\"增加、删除\"），或并列结构中存在术语结构不一致（动词/名词混用）\n\n识别模式：\n1. 检测相邻段落/标题中相同语义的术语表达形式（如\"增删\"与\"增加、删除\"）\n2. 分析并列短语的语法结构一致性（如动宾结构\"增加、删除、获取\"应与\"判断\"保持统一）"
    },
    {
      "defect_id": 437346,
      "sentence": "4. 调用[cmsGenerator.doFinal](../../reference/apis-device-certificate-kit/js-apis-cert.md#dofinal18)获取Cms最终签名数据。",
      "reference_sentence": "4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"3. 调用[cmsGenerator.addSigner](../../reference/apis-device-certificate-kit/js-apis-cert.md#addsigner18)添加签名者信息。\",\"16\":\"\",\"17\":\"4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。\",\"18\":\"\",\"19\":\"4. 调用[cmsGenerator.doFinal](../../reference/apis-device-certificate-kit/js-apis-cert.md#dofinal18)获取Cms最终签名数据。\",\"20\":\"\",\"21\":\"- 异步方法示例：\",\"22\":\"\",\"23\":\"```ts\",\"24\":\"import { cert } from '@kit.DeviceCertificateKit';\"}",
      "修改建议": "步骤编号重复，前文已使用'4. 调用[cmsGenerator.addCert]'，此处应为'5. 调用[cmsGenerator.doFinal]'。",
      "更改后示例": "5. 调用[cmsGenerator.doFinal](../../reference/apis-device-certificate-kit/js-apis-cert.md#dofinal18)获取Cms最终签名数据。",
      "触发条件": "当检测到文档中连续步骤的编号重复（如两个步骤同为\"4.\"）或编号顺序断裂（如前序步骤为4，后续步骤未递增为5）时，触发语言表达一致性规则。"
    },
    {
      "defect_id": 434746,
      "sentence": "对象绑定及监听拦截属性操作。",
      "reference_sentence": "对象绑定及监听拦截属性操作",
      "line_num": 1592,
      "context": "{\"1587\":\"    return nullptr;\",\"1588\":\"}\",\"1589\":\"```\",\"1590\":\"\",\"1591\":\"场景示例：\",\"1592\":\"对象绑定及监听拦截属性操作。\",\"1593\":\"\",\"1594\":\"```c++\",\"1595\":\"static int aa = 0;\",\"1596\":\"static JSVM_Value hello(JSVM_Env env, JSVM_CallbackInfo info) {\",\"1597\":\"    JSVM_Value output;\"}",
      "修改建议": "混用了'对象绑定及监听拦截属性操作'和'对象绑定及监听拦截属性操作。'，应保持一致",
      "更改后示例": "对象绑定及监听拦截属性操作",
      "触发条件": "当同一文档中相邻条目或重复内容存在标点符号不一致（如句号冗余/缺失）时触发，且问题句与参考句在上下文结构（如列表项、示例标题）中具有相同语法地位。"
    },
    {
      "defect_id": 437508,
      "sentence": "定期采集传感器数据",
      "reference_sentence": "典型场景中的'定期采集传感器数据'",
      "line_num": 10,
      "context": "{\"5\":\"典型的长时任务场景如下所示：\",\"6\":\"\",\"7\":\"\",\"8\":\"| 常见业务场景 | 具体业务描述 | \",\"9\":\"| -------- | -------- |\",\"10\":\"| 定期采集传感器数据 | 周期性采集一些传感器信息（例如位置信息、速度传感器等），应用需要长时间不间断的运行。 | \",\"11\":\"| 监听Socket端口信息 | 长时间监听Socket数据，不定时需要响应处理。 | \",\"12\":\"\",\"13\":\"上述业务场景均为独立的长时任务，任务执行周期长，与外部交互简单。分发到后台线程后，这些任务需要不定期响应以获取结果。这些类型的任务使用TaskPool可以简化开发工作量，避免管理复杂的生命周期，避免线程泛滥。开发者只需要将上述独立的长时任务放入TaskPool队列，再等待结果即可。\"}",
      "修改建议": "混用了'定期采集'和'周期性采集'描述同一场景",
      "更改后示例": "周期性采集传感器数据",
      "触发条件": "同一上下文或相邻内容中，对同一概念或操作使用了不同的术语或表达方式（如“定期”与“周期性”混用），且存在明确参考句或用户反馈指出术语冲突。\n\n识别模式：\n1. **邻近语义冲突**：在相同表格/段落内，若关键动作（如“采集”）的修饰词（如“定期”/“周期性”）出现不一致，且指向同一业务场景。\n2. **用户标注反馈**：当问题描述中明确标注“混用XX和XX描述同一场景”时，直接触发规则匹配。"
    },
    {
      "defect_id": 434747,
      "sentence": "获取当前版本信息。",
      "reference_sentence": "获取当前版本信息",
      "line_num": 2002,
      "context": "{\"1997\":\"\",\"1998\":\"### 版本管理\",\"1999\":\"\",\"2000\":\"#### 场景介绍\",\"2001\":\"\",\"2002\":\"获取当前版本信息。\",\"2003\":\"\",\"2004\":\"#### 接口说明\",\"2005\":\"| 接口 | 功能说明 |\",\"2006\":\"| -------- | -------- |\",\"2007\":\"|OH_JSVM_GetVersion| 返回JSVM运行时支持的最高JSVM API版本 |\"}",
      "修改建议": "混用了'获取当前版本信息'和'获取当前版本信息。'，应保持一致",
      "更改后示例": "获取当前版本信息",
      "触发条件": "同一文档中相邻或相近位置出现相同/相似语句时存在标点符号（如句号）、空格或大小写格式不一致。  \n\n识别模式：  \n1. 上下文重复语句对比：检查问题句与参考句是否在相同功能描述场景下重复出现（如本例\"获取当前版本信息\"在场景介绍和接口说明模块重复使用）  \n2. 标点特征异常：识别语句结尾是否出现非常规标点（技术文档说明项通常不加句号），并通过相邻条目验证格式标准（如本例参考句无句号）"
    },
    {
      "defect_id": 435464,
      "sentence": "调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。",
      "reference_sentence": "调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。",
      "line_num": 393,
      "context": "{\"388\":\"\",\"389\":\"    ```\",\"390\":\"\",\"391\":\"## 上下文绑定对象\",\"392\":\"\",\"393\":\"**【规则】**：调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的函数名。调用JSVM-API生成的类、对象同理。\",\"394\":\"\",\"395\":\"**示例**：\",\"396\":\"\",\"397\":\"```\",\"398\":\"JSVM_Value JSFunc = nullptr;\"}",
      "修改建议": "原文中使用了“函数名”和“函数名”两个不同的词汇来描述同一个概念，应保持用词一致。",
      "更改后示例": "调用JSVM-API生成的JS函数、对象需绑定到上下文中才能从JS侧访问，`OH_JSVM_CreateFunction`接口中的`const char *`参数为创建函数的属性`name`，不代表上下文中指向该函数的名称。",
      "触发条件": "同一技术概念在相邻语句或同一段落中出现两种及以上不同表述形式（如\"函数名\"与\"名称\"交替使用），且指代对象完全相同时触发。识别模式需检测同一语义单元内是否存在同义词/近义词混用，特别是涉及API参数名、技术术语等关键元素时。"
    },
    {
      "defect_id": 435447,
      "sentence": "4. `OH_JSVM_AcquireLock`后需调用`OH_JSVM_OpenHandleScope`让引擎实例进入线程；`OH_JSVM_ReleaseLock`后需调用`OH_JSVM_ReleaseLock`让引擎实例退出线程；",
      "reference_sentence": "4. `OH_JSVM_AcquireLock`后需调用`OH_JSVM_OpenHandleScope`让引擎实例进入线程；`OH_JSVM_ReleaseLock`后需调用`OH_JSVM_ReleaseLock`让引擎实例退出线程；",
      "line_num": 112,
      "context": "{\"107\":\"**注意事项**：\",\"108\":\"\",\"109\":\"1. `OH_JSVM_IsLocked`的结果为**当前线程**是否持有引擎实例的锁，无需设置循环等待其他线程释放锁；\",\"110\":\"2. `OH_JSVM_AcquireLock`在同一线程中嵌套使用不会造成死锁；\",\"111\":\"3. 使用`OH_JSVM_ReleaseLock`时需判断是否在最外层，避免同一线程中嵌套使用`OH_JSVM_AcquireLock`的场景下内层释放了整个线程的锁；\",\"112\":\"4. `OH_JSVM_AcquireLock`后需调用`OH_JSVM_OpenHandleScope`让引擎实例进入线程；`OH_JSVM_ReleaseLock`后需调用`OH_JSVM_ReleaseLock`让引擎实例退出线程；\",\"113\":\"5. 不同线程禁止嵌套使用引擎实例，如需临时切换线程使用引擎实例，请确保`JSVM_Value`已保存为`JSVM_Ref`，释放锁后对`JSVM_Value`将不可访问；\",\"114\":\"6. 需注意资源获取的顺序为：锁 -> VMScope -> EnvScope -> HandleScope，释放资源的顺序正好相反，错误的顺序可能导致程序崩溃。\",\"115\":\"\",\"116\":\"**C++使用封装**：\",\"117\":\"\"}",
      "修改建议": "句子中重复使用了`OH_JSVM_ReleaseLock`，导致逻辑错误。",
      "更改后示例": "4. `OH_JSVM_AcquireLock`后需调用`OH_JSVM_OpenHandleScope`让引擎实例进入线程；`OH_JSVM_ReleaseLock`后需调用`OH_JSVM_CloseHandleScope`让引擎实例退出线程；",
      "触发条件": "相邻对称结构中出现相同API名称重复使用，且上下文存在成对操作规范时。当检测到\"X后需调用Y...X后需调用X\"这类对称句式中的重复术语破坏配对关系时触发。\n\n识别模式：\n1. 结构特征：分号/句号分隔的对称操作说明（\"操作A后调用B；操作C后调用D\"）\n2. 术语异常：后半部分重复使用前半段的API名称（特别是释放类操作），而非使用语义对应的配对API\n3. 上下文线索：文档中存在明确的资源获取/释放配对规范（如注意事项第6条提到的资源顺序）"
    },
    {
      "defect_id": 434845,
      "sentence": "检查传入的值是否可调用",
      "reference_sentence": "检查传入的值是否可调用。",
      "line_num": 2219,
      "context": "{\"2214\":\"| 接口 | 功能说明 |\",\"2215\":\"| -------- | -------- |\",\"2216\":\"|OH_JSVM_IsCallable| 检查传入的值是否可调用 |\",\"2217\":\"\",\"2218\":\"场景示例：\",\"2219\":\"检查传入的值是否可调用\",\"2220\":\"\",\"2221\":\"```c++\",\"2222\":\"static JSVM_Value NapiIsCallable(JSVM_Env env, JSVM_CallbackInfo info) {\",\"2223\":\"    JSVM_Value value, rst;\",\"2224\":\"    size_t argc = 1;\"}",
      "修改建议": "混用了'检查传入的值是否可调用'和'检查传入的值是否可调用。'两种表述方式，需保持一致。",
      "更改后示例": "检查传入的值是否可调用。",
      "触发条件": "同一文档中出现相同/相似功能描述语句但标点符号不一致（如句末存在/缺失终止标点），且在相邻上下文重复出现形成对比。 \n\n具体识别模式：\n1. 文本匹配：在±3行范围内存在高度相似语句（字符重复率>90%）\n2. 标点差异：匹配语句存在唯一差异为终止标点（如\"。\"与无标点）\n3. 功能描述：语句包含\"检查/验证/判断\"等指令动词，且描述对象为API功能特性"
    },
    {
      "defect_id": 435643,
      "sentence": "1. Q：`OH_JSVM_GetCbInfo`的无法获取JS函数参数",
      "reference_sentence": "",
      "line_num": 85,
      "context": "{\"80\":\"\",\"81\":\"   A：检查HandleScope的使用是否正确，见[生命周期管理](jsvm-guidelines.md#生命周期管理)\",\"82\":\"\",\"83\":\"## JSVM-API执行失败类\",\"84\":\"\",\"85\":\"1. Q：`OH_JSVM_GetCbInfo`的无法获取JS函数参数\",\"86\":\"\",\"87\":\"   A：检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)\",\"88\":\"\",\"89\":\"2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`\",\"90\":\"\"}",
      "修改建议": "句子中使用了“的”连接动词“无法获取”，应改为“无法获取JS函数参数”",
      "更改后示例": "1. Q：`OH_JSVM_GetCbInfo`无法获取JS函数参数",
      "触发条件": "当句子中出现\"的\"字直接连接动词短语（如\"的无法获取\"）导致语法冗余，且该结构出现在问题描述或问答句式开头时触发。\n\n识别模式：通过正则表达式匹配\"的\\s*[无法|不能|会|可能]+[动词]\"结构（示例：`的无法获取`），并结合上下文判断是否属于技术问题描述场景（如FAQ中的\"Q：\"开头句式）。"
    },
    {
      "defect_id": 435578,
      "sentence": "A：`SetReturnValue`用于设置js函数的返回值，在js完成注入的native函数调用后触发。需检查native函数的返回值是否正确，如返回值（类型`JSVM_Value`）是否未初始化就直接返回。",
      "reference_sentence": "A：`SetReturnValue`用于设置js函数的返回值，在js完成注入的native函数调用后触发。需检查native函数的返回值是否正确，如返回值（类型`JSVM_Value`）是否未初始化就直接返回。",
      "line_num": 41,
      "context": "{\"36\":\"   #22 pc 00000000014334e8 /system/lib64/ndk/libjsvm.so(v8::CallDepthScope<true>::~CallDepthScope()+248)\",\"37\":\"   #23 pc 00000000014330a4 /system/lib64/ndk/libjsvm.so(v8::Script::Run(v8::Local<v8::Context>, v8::Local<v8::Data>)+884)\",\"38\":\"   #24 pc 0000000000c5c2ac /system/lib64/ndk/libjsvm.so(OH_JSVM_RunScript+272)\",\"39\":\"   ```\",\"40\":\"\",\"41\":\"   A：`SetReturnValue`用于设置js函数的返回值，在js完成注入的native函数调用后触发。需检查native函数的返回值是否正确，如返回值（类型`JSVM_Value`）是否未初始化就直接返回。\",\"42\":\"\",\"43\":\"2. Q：js执行虚拟机初始化注入的native函数时程序崩溃\",\"44\":\"\",\"45\":\"   A：检查`JSVM_CallbackStruct`是否为栈上变量，跨函数使用时需保证`JSVM_CallbackStruct`生命周期 >`JSVM_Env`的生命周期\",\"46\":\"\"}",
      "修改建议": "原文中使用了“返回值（类型`JSVM_Value`）”，建议统一为“返回值（`JSVM_Value`）”",
      "更改后示例": "A：`SetReturnValue`用于设置js函数的返回值，在js完成注入的native函数调用后触发。需检查native函数的返回值是否正确，如返回值（`JSVM_Value`）是否未初始化就直接返回。",
      "触发条件": "当文档中括号内同时出现\"类型\"说明词和类型名称(如`(类型X)`或`(类型 X)`)时，且存在其他同类表述仅用`(X)`格式的情况。\n\n识别模式：\n1. 检测括号内\"类型\"关键词与代码块/类型名的组合结构\n2. 对比上下文是否存在相同类型参数的纯`(X)`表述\n3. 验证是否形成冗余的类型说明(如已通过代码块` `明确类型时)"
    },
    {
      "defect_id": 434848,
      "sentence": "在虚拟机内部启动任务队列的运行，检查队列中是否有微任务等待，任务队列可由外部事件循环执行。",
      "reference_sentence": "任务队列。",
      "line_num": 2490,
      "context": "{\"2485\":\"\",\"2486\":\"### 任务队列\",\"2487\":\"\",\"2488\":\"#### 场景介绍\",\"2489\":\"\",\"2490\":\"在虚拟机内部启动任务队列的运行，检查队列中是否有微任务等待，任务队列可由外部事件循环执行。\",\"2491\":\"\",\"2492\":\"#### 接口说明\",\"2493\":\"| 接口 | 功能说明 |\",\"2494\":\"| -------- | -------- |\",\"2495\":\"|OH_JSVM_PumpMessageLoop| 启动任务队列的运行 |\"}",
      "修改建议": "混用了'在虚拟机内部启动任务队列的运行，检查队列中是否有微任务等待，任务队列可由外部事件循环执行。'和'任务队列。'两种表述方式，需保持一致。",
      "更改后示例": "任务队列。",
      "触发条件": "同一术语在相邻段落或同一章节内出现全称/简称混用、动宾结构与名词短语混用，且上下文存在已定义的规范表述形式时触发。\n\n识别模式：\n1. 检查核心术语在标题（如\"### 任务队列\"）与正文描述（如\"任务队列的运行\"）的语法结构一致性\n2. 比对同一概念在定义性段落（接口说明表格）与场景描述中的表达形式是否统一\n3. 识别动词短语（\"启动...运行\"）与名词短语（\"任务队列\"）在指代同一概念时的混用情况"
    },
    {
      "defect_id": 435349,
      "sentence": "在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口",
      "reference_sentence": "此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"- ArkTS/JS侧：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。\",\"6\":\"\",\"7\":\"- Native侧：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。\",\"8\":\"\",\"9\":\"此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口，从而实现跨语言交互为例，呈现使用JSVM-API进行跨语言交互的流程。\",\"10\":\"\",\"11\":\"## 创建Native C++工程\",\"12\":\"\",\"13\":\"具体见[创建NDK工程](create-with-ndk.md)\",\"14\":\"\"}",
      "修改建议": "混用了`RunJsVm`和`runTest`，前后不一致",
      "更改后示例": "在ArkTS/JS侧实现runTest()接口、在Native侧实现runTest()接口",
      "触发条件": "在同一功能描述中出现接口/方法名的大小写不一致（如RunJsVm vs runTest）或命名规范冲突，且上下文存在明确统一术语的参照依据时触发。\n\n识别模式：通过对比相邻段落中相同功能模块的接口命名，检测驼峰式（RunJsVm）与下划线式（run_test）或全小写（runtest）的混合使用，结合参考句中的既定命名（如runTest）进行冲突判定。需同时满足命名逻辑关联性（如跨语言交互接口）和上下文邻近性（如问题句与参考句间隔≤3行）。"
    },
    {
      "defect_id": 435448,
      "sentence": "6. 需注意资源获取的顺序为：锁 -> VMScope -> EnvScope -> HandleScope，释放资源的顺序正好相反，错误的顺序可能导致程序崩溃。",
      "reference_sentence": "6. 需注意资源获取的顺序为：锁 -> VMScope -> EnvScope -> HandleScope，释放资源的顺序正好相反，错误的顺序可能导致程序崩溃。",
      "line_num": 114,
      "context": "{\"109\":\"1. `OH_JSVM_IsLocked`的结果为**当前线程**是否持有引擎实例的锁，无需设置循环等待其他线程释放锁；\",\"110\":\"2. `OH_JSVM_AcquireLock`在同一线程中嵌套使用不会造成死锁；\",\"111\":\"3. 使用`OH_JSVM_ReleaseLock`时需判断是否在最外层，避免同一线程中嵌套使用`OH_JSVM_AcquireLock`的场景下内层释放了整个线程的锁；\",\"112\":\"4. `OH_JSVM_AcquireLock`后需调用`OH_JSVM_OpenHandleScope`让引擎实例进入线程；`OH_JSVM_ReleaseLock`后需调用`OH_JSVM_ReleaseLock`让引擎实例退出线程；\",\"113\":\"5. 不同线程禁止嵌套使用引擎实例，如需临时切换线程使用引擎实例，请确保`JSVM_Value`已保存为`JSVM_Ref`，释放锁后对`JSVM_Value`将不可访问；\",\"114\":\"6. 需注意资源获取的顺序为：锁 -> VMScope -> EnvScope -> HandleScope，释放资源的顺序正好相反，错误的顺序可能导致程序崩溃。\",\"115\":\"\",\"116\":\"**C++使用封装**：\",\"117\":\"\",\"118\":\"```\",\"119\":\"class LockWrapper {\"}",
      "修改建议": "句子中使用了“资源获取”和“释放资源”两个不同的词汇描述同一对象，容易引起混淆。",
      "更改后示例": "6. 需注意资源获取的顺序为：锁 -> VMScope -> EnvScope -> HandleScope，资源释放的顺序正好相反，错误的顺序可能导致程序崩溃。",
      "触发条件": "同一句子或相邻上下文中存在描述同一对象/过程的互补操作时，出现术语结构不一致（如\"资源获取\"与\"释放资源\"）或对称性破坏（如\"获取顺序\"与\"释放顺序\"未形成镜像表达）。  \n\n识别模式：  \n1. 检测成对出现的逆向操作描述（获取/释放、打开/关闭等）  \n2. 验证术语结构是否保持对称（名词+动词 vs 动词+名词）  \n3. 检查同一实体是否始终作为描述主体（资源获取顺序 vs 资源释放顺序）"
    },
    {
      "defect_id": 435819,
      "sentence": "修改微任务执行策略,通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。",
      "reference_sentence": "设置微任务执行策略",
      "line_num": 142,
      "context": "{\"137\":\"```\",\"138\":\"JSVM API TEST: Called with instance [object Object]\",\"139\":\"JSVM API TEST: Called Finally\",\"140\":\"```\",\"141\":\"### OH_JSVM_SetMicrotaskPolicy\",\"142\":\"修改微任务执行策略,通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。\",\"143\":\"\",\"144\":\"微任务策略：\",\"145\":\"- JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT ： 微任务在用户调用 OH_JSVM_PerformMicrotaskCheckpoint 后执行\",\"146\":\"- JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO： 微任务在 JS 调用栈为空时自动执行\",\"147\":\"\"}",
      "修改建议": "混用了'修改微任务执行策略'和'设置微任务执行策略'，建议保持一致性",
      "更改后示例": "设置微任务执行策略，通过该接口，用户可以将策略设置为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_EXPLICIT 或 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。默认模式下，微任务的执行策略为 JSVM_MicrotaskPolicy::JSVM_MICROTASK_AUTO。",
      "触发条件": "同一术语或短语在相邻段落或同一功能描述中，出现用词不一致（如\"修改\"与\"设置\"混用），且存在明确的参考表达（如标题/接口命名）时触发。\n\n识别模式：\n1. 核心动词/名词对比：检查同一功能描述中是否对同一操作混用近义词（如修改/设置/配置）\n2. 上下文锚定：当存在明确的术语参考源（如接口命名OH_JSVM_SetMicrotaskPolicy含\"Set\"），需与说明文本中的动词保持严格一致\n3. 邻近重复检测：在3-5个相邻段落范围内，同一技术概念的表达需保持完全一致"
    },
    {
      "defect_id": 435644,
      "sentence": "   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`",
      "reference_sentence": "",
      "line_num": 91,
      "context": "{\"86\":\"\",\"87\":\"   A：检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)\",\"88\":\"\",\"89\":\"2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`\",\"90\":\"\",\"91\":\"   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`\",\"92\":\"\",\"93\":\"3. Q：JS执行时无法找到 `OH_JSVM_DefineClass` 定义的类\",\"94\":\"\",\"95\":\"   A：检查是否将定义的类绑定到上下文中，见[上下文绑定对象](jsvm-guidelines.md#上下文绑定对象)\"}",
      "修改建议": "句子中使用了“如未本次产生的异常”，应改为“如果是本次产生的异常”",
      "更改后示例": "   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如果是本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`",
      "触发条件": "当文档中并列条件判断句式出现关联词不一致（如\"如果为\"与\"如未\"混用）或否定/肯定逻辑失衡时触发。\n\n识别模式需检测以下特征：\n1. 存在\"如果为...；如未...\"等并列条件句式\n2. 后置条件句出现否定词误用（如\"未\"替代\"是\"）\n3. 同一段落中前文已建立\"如果为...\"的条件表达规范"
    },
    {
      "defect_id": 436032,
      "sentence": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传参进行调用，或者直接在JSVM模块中创建一个JavaScript方法。",
      "reference_sentence": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传参进行调用，或者直接在JSVM模块中创建一个JavaScript函数。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行函数创建和调用\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"函数调用允许开发者从JSVM模块中调用JavaScript函数，并传参进行调用，或者直接在JSVM模块中创建一个JavaScript方法。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"函数是一种非常重要的编程概念，可以执行特定的任务或操作、提高代码的可读性、把复杂任务简化、提高代码复用性以及支持代码的组织与管理。每个函数负责不同的功能，实现代码的模块化和结构化，便于理解、维护和重用。\",\"10\":\"\"}",
      "修改建议": "混用了'方法'和'函数'概念",
      "更改后示例": "函数调用允许开发者从JSVM模块中调用JavaScript函数，并传参进行调用，或者直接在JSVM模块中创建一个JavaScript函数。",
      "触发条件": "当同一技术概念在邻近上下文中出现术语混用（如\"函数\"和\"方法\"），或与文档其他部分已定义的术语体系冲突时触发。\n\n识别模式：\n1. 检测同一段落/相邻段落内对同一技术实体的不同命名（如通过NLP识别近义词/同义词）\n2. 对比文档其他章节已建立的术语体系（如案例中\"基本概念\"章节明确定义了\"函数\"）\n3. 当技术术语存在严格定义时（如编程语言中\"函数\"与\"方法\"的区分），优先保持术语一致性"
    },
    {
      "defect_id": 435914,
      "sentence": "如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败后再执行编译。",
      "reference_sentence": "如果提供了缓存参数，先尝试将缓存反序列为 wasm module，反序列化失败后再执行编译。",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"## 接口说明\",\"17\":\"\",\"18\":\"| 接口                          | 功能说明                                                                                 |\",\"19\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"20\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败后再执行编译。 |\",\"21\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"22\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是wasm module。                                                             |\",\"23\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，会导致序列化失败。                    |\",\"24\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"25\":\"\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "如果提供了缓存参数，先尝试将缓存反序列为 wasm module，反序列化失败后再执行编译。",
      "触发条件": "同一术语存在中英文混用（如\"cache\"与\"缓存\"并存），且该术语在上下文相邻条目中存在已确定的标准译法（如其他接口统一使用\"缓存\"）。"
    },
    {
      "defect_id": 435912,
      "sentence": "通过`OH_JSVM_CompileWasmModule`可以将wasm字节码或wasm cache创建为wasm module。",
      "reference_sentence": "通过`OH_JSVM_CompileWasmModule`可以将wasm字节码或wasm 缓存创建为wasm module。",
      "line_num": 12,
      "context": "{\"7\":\"权限要求：WebAssembly相关接口需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"8\":\"运行限制：当前 JSVM 版本在坚盾守护模式下将禁用 WebAssembly 全部功能模块。开发者需针对此限制进行应用兼容性评估，具体技术规范详见[JSVM 坚盾守护模式](jsvm-secure-shield-mode.md)。\",\"9\":\"\",\"10\":\"## 基本概念\",\"11\":\"\",\"12\":\"- **wasm module**：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过`OH_JSVM_CompileWasmModule`可以将wasm字节码或wasm cache创建为wasm module。通过 `OH_JSVM_IsWasmModuleObject` 接口可以判断一个 JSVM_Value 是否是一个 wasm module。\",\"13\":\"- **wasm function**：表示 wasm module 中定义的函数，wasm function 在导出后被外部代码使用。`OH_JSVM_CompileWasmFunction` 接口提供了将 wasm function 编译为优化后的机器码的能力，方便开发者对指定 wasm function 提前编译和函数粒度的并行编译。\",\"14\":\"- **wasm cache**：对 wasm module 中的机器码进行序列化，生成的数据被称为 wasm cache。wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。\",\"15\":\"\",\"16\":\"## 接口说明\",\"17\":\"\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "通过`OH_JSVM_CompileWasmModule`可以将wasm字节码或wasm 缓存创建为wasm module。",
      "触发条件": "同一术语在文档中存在中英文混用（如\"cache\"与\"缓存\"交替出现），且该术语在文档其他位置已有明确定义或统一表达形式（如参考句中的\"wasm 缓存\"）。\n\n识别模式：\n1. 检测专业术语/技术名词是否出现非翻译一致性（如英文术语与中文译名混用）\n2. 交叉验证上下文是否已建立标准表达形式（如问题上下文第14行明确定义\"wasm cache\"，但第12行出现\"wasm 缓存\"）\n3. 特别关注同一段落内术语的重复出现形式是否统一（如问题句中的\"cache\"与参考句中的\"缓存\"形成冲突）"
    },
    {
      "defect_id": 436334,
      "sentence": "获取 Dataview 对象的信息。",
      "reference_sentence": "获取 Dataview 对象的信息。",
      "line_num": 552,
      "context": "{\"547\":\"JSVM GetTypedArrayInfo success, isArrayBuffer: 1\",\"548\":\"JSVM GetTypedArrayInfo success, byteOffset: 0\",\"549\":\"```\",\"550\":\"### OH_JSVM_GetDataviewInfo\",\"551\":\"\",\"552\":\"获取 Dataview 对象的信息。\",\"553\":\"\",\"554\":\"cpp部分代码：\",\"555\":\"\",\"556\":\"```cpp\",\"557\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少实际功能描述。",
      "更改后示例": "获取 Dataview 对象的信息。此接口用于获取数据视图对象的相关信息，如字节长度、字节偏移等。",
      "触发条件": "当接口描述仅包含基本功能名称而未列举具体参数、返回值或示例时，或与上下文同类条目存在句式结构差异（如缺少功能细节/参数说明）时触发。"
    },
    {
      "defect_id": 435913,
      "sentence": "wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "reference_sentence": "wasm 缓存的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "line_num": 14,
      "context": "{\"9\":\"\",\"10\":\"## 基本概念\",\"11\":\"\",\"12\":\"- **wasm module**：表示一个 WebAssembly 模块，(WebAssembly 简称为wasm)，通过`OH_JSVM_CompileWasmModule`可以将wasm字节码或wasm cache创建为wasm module。通过 `OH_JSVM_IsWasmModuleObject` 接口可以判断一个 JSVM_Value 是否是一个 wasm module。\",\"13\":\"- **wasm function**：表示 wasm module 中定义的函数，wasm function 在导出后被外部代码使用。`OH_JSVM_CompileWasmFunction` 接口提供了将 wasm function 编译为优化后的机器码的能力，方便开发者对指定 wasm function 提前编译和函数粒度的并行编译。\",\"14\":\"- **wasm cache**：对 wasm module 中的机器码进行序列化，生成的数据被称为 wasm cache。wasm cache 的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。\",\"15\":\"\",\"16\":\"## 接口说明\",\"17\":\"\",\"18\":\"| 接口                          | 功能说明                                                                                 |\",\"19\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "wasm 缓存的创建和释放接口分别为 `OH_JSVM_CreateWasmCache` 和 `OH_JSVM_ReleaseCache` (对应的 cacheType 为 `JSVM_CACHE_TYPE_WASM`)。",
      "触发条件": "同一术语在相邻上下文或同一文档中出现两种及以上不同表达形式（如中英文混用、同义词交替使用），且存在明确定义的规范术语版本。\n\n识别模式：\n1. 术语对照检测：当检测到同一技术概念存在中英文混用（如\"cache\"与\"缓存\"）或不同译名混用\n2. 上下文关联验证：在相邻段落/同条目描述中，该术语已存在规范表达形式（如参考句中的\"wasm 缓存\"）\n3. 定义一致性检查：该术语在文档概念定义部分（如上下文第14行）已明确使用特定表达形式"
    },
    {
      "defect_id": 436268,
      "sentence": "获取 Dataview 对象的信息",
      "reference_sentence": "使用JSVM-API接口进行数组相关开发时，在JSVM模块中可以调用相关接口直接操作和处理JavaScript中的数组。",
      "line_num": 28,
      "context": "{\"23\":\"|OH_JSVM_CreateArrayWithLength | 创建一个指定长度的 JavaScript 数组对象 |\",\"24\":\"|OH_JSVM_CreateTypedarray | 在现有的ArrayBuffer上创建JavaScript TypedArray对象，TypedArray对象提供类似数组的视图，每个元素具有相同的二进制标量数据类型。注意(length * size_of_element) + byte_offset 不得超过传入数组的大小（以字节为单位），否则会引发RangeError异常。|\",\"25\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象，DataView 对象在底层数据缓冲区上提供类似数组的视图，该 ArrayBuffer 允许有不同大小和类型的元素。要求 byte_length + byte_offset 小于或等于传入数组的字节大小，否则会引发 RangeError 异常。|\",\"26\":\"|OH_JSVM_GetArrayLength | 返回 Array 对象的长度 |\",\"27\":\"|OH_JSVM_GetTypedarrayInfo | 获取 TypedArray（类型化数组）对象的信息 |\",\"28\":\"|OH_JSVM_GetDataviewInfo | 获取 Dataview 对象的信息 |\",\"29\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"30\":\"|OH_JSVM_SetElement | 在给定对象的指定索引处设置元素 |\",\"31\":\"|OH_JSVM_GetElement | 获取给定对象指定索引处的元素 |\",\"32\":\"|OH_JSVM_HasElement | 若给定对象的指定索引处拥有属性，获取该元素 |\",\"33\":\"|OH_JSVM_DeleteElement | 尝试删除给定对象的指定索引处的元素 |\"}",
      "修改建议": "混用了'数组'和'Dataview'两个词",
      "更改后示例": "获取 DataView 对象的信息",
      "触发条件": "当同一技术术语在文档中存在大小写不一致（如\"Dataview\"与\"DataView\"）或与API接口命名规范冲突（如接口名含\"DataView\"但描述使用\"Dataview\"）时触发。\n\n识别模式：\n1. 术语形态匹配：通过正则表达式检测技术术语的驼峰/Pascal命名形态（如/[A-Za-z]+(View|Array)/）\n2. 上下文一致性校验：对比接口定义（如OH_JSVM_GetDataviewInfo）与描述文本中的术语使用\n3. 行业标准对齐：验证JavaScript标准术语（如DataView是ECMAScript规范命名）与文档表述的一致性"
    },
    {
      "defect_id": 436721,
      "sentence": "用于创建和使用虚拟机的起始快照。",
      "reference_sentence": "用于创建和使用虚拟机的启动快照。",
      "line_num": 23,
      "context": "{\"18\":\"|OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的起始快照，创建一个新的环境 |\",\"19\":\"## 使用示例\",\"20\":\"\",\"21\":\"### OH_JSVM_CreateSnapshot & OH_JSVM_CreateEnvFromSnapshot\",\"22\":\"\",\"23\":\"用于创建和使用虚拟机的启动快照。\",\"24\":\"\",\"25\":\"cpp部分代码：\",\"26\":\"\",\"27\":\"**注意事项**: 需要在OH_JSVM_Init的时候，将JSVM对外部的依赖注册到initOptions.externalReferences中。\",\"28\":\"```cpp\"}",
      "修改建议": "混用了“起始快照”和“启动快照”",
      "更改后示例": "用于创建和使用虚拟机的启动快照。",
      "触发条件": "同一文档中出现针对同一技术概念的多个中文术语变体（如\"起始快照\"与\"启动快照\"），且存在相邻上下文或参考句中的术语使用冲突时触发。\n\n识别模式：\n1. 通过术语抽取发现同一概念存在多词表达（如\"起始/启动\"+\"快照\"的组合差异）\n2. 在相邻段落（本案例中问题句与第18行）或参考句（第23行）中存在术语冲突\n3. 核心术语在文档既定表达体系（如参考句）中已有明确定义时仍出现偏差"
    },
    {
      "defect_id": 436359,
      "sentence": "若给定对象的指定索引处拥有属性，获取该元素。",
      "reference_sentence": "获取给定对象指定索引处的元素。",
      "line_num": 809,
      "context": "{\"804\":\"```\",\"805\":\"JSVM GetElement success\",\"806\":\"```\",\"807\":\"### OH_JSVM_HasElement\",\"808\":\"\",\"809\":\"若给定对象的指定索引处拥有属性，获取该元素。\",\"810\":\"\",\"811\":\"cpp部分代码：\",\"812\":\"\",\"813\":\"```cpp\",\"814\":\"// hello.cpp\"}",
      "修改建议": "描述获取元素时，用词不一致，'获取该元素'与'获取元素'应统一。",
      "更改后示例": "若给定对象的指定索引处拥有属性，获取元素。",
      "触发条件": "同一术语在相邻上下文中存在不一致表达（如“该元素”与“元素”混用），且冗余限定词（如“该”）未保持统一性时触发。\n\n识别模式：  \n1. 检测重复描述同一操作/对象时是否出现冗余限定词差异（如“该X”与“X”交替出现）；  \n2. 对比相邻语句或参考句式（如参数名/API名），验证核心术语是否需强制去限定词（如参考句仅用“元素”）。"
    },
    {
      "defect_id": 435916,
      "sentence": "释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "reference_sentence": "释放由 JSVM 接口生成的缓存。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "line_num": 24,
      "context": "{\"19\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"20\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败后再执行编译。 |\",\"21\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"22\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是wasm module。                                                             |\",\"23\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，会导致序列化失败。                    |\",\"24\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"25\":\"\",\"26\":\"## code cache 校验规格说明\",\"27\":\"| 规格        | 规格说明                                         |\",\"28\":\"| ---------- | ------------------------------------------------ |\",\"29\":\"| 完整性校验  | 由用户保证                                        |\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "释放由 JSVM 接口生成的缓存。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "触发条件": "同一术语在文档中存在中英文混用（如\"cache\"与\"缓存\"交替出现），且上下文存在明确的术语统一表达形式（如参考句或相邻段落已确立固定译法）。\n\n识别模式：\n1. 术语中英文变体共存：检测同一技术概念存在两种语言形式的表达（如 cache/缓存）\n2. 上下文一致性锚点：在相邻段落/参考句中发现该术语的固定译法（如问题上下文第23行出现\"wasm cache\"，但第26行标题使用\"code cache\"时未翻译，需根据具体上下文判断主译法）"
    },
    {
      "defect_id": 436720,
      "sentence": "OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的起始快照，创建一个新的环境",
      "reference_sentence": "OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的启动快照，创建一个新的环境",
      "line_num": 18,
      "context": "{\"13\":\"## 接口说明\",\"14\":\"\",\"15\":\"| 接口                       | 功能说明                       |\",\"16\":\"|----------------------------|-------------------------------|\",\"17\":\"| OH_JSVM_CreateSnapshot     | 用于创建虚拟机的启动快照        |\",\"18\":\"|OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的起始快照，创建一个新的环境 |\",\"19\":\"## 使用示例\",\"20\":\"\",\"21\":\"### OH_JSVM_CreateSnapshot & OH_JSVM_CreateEnvFromSnapshot\",\"22\":\"\",\"23\":\"用于创建和使用虚拟机的启动快照。\"}",
      "修改建议": "混用了“起始快照”和“启动快照”",
      "更改后示例": "OH_JSVM_CreateEnvFromSnapshot| 基于虚拟机的启动快照，创建一个新的环境",
      "触发条件": "同一文档中存在相同技术术语的不一致表达（如\"起始快照\"与\"启动快照\"），且上下文存在明确的标准术语引用（如其他接口说明已确立\"启动快照\"为规范表述）。\n\n识别模式：\n1. 术语变异检测：识别同一概念的不同表达形式（如近义词\"起始/启动\"）\n2. 上下文对齐验证：比对文档中其他相关位置（如相邻接口说明、使用示例）的术语使用\n3. 标准术语库匹配：当存在已确立的标准术语（如参考句中的\"启动快照\"）时，检测非标准表述"
    },
    {
      "defect_id": 436357,
      "sentence": "判断一个 JavaScript 对象是否为 Dataview类型对象。",
      "reference_sentence": "判断一个 JavaScript 对象是否为 Array 类型对象。",
      "line_num": 919,
      "context": "{\"914\":\"```\",\"915\":\"JSVM DeleteElement: 1\",\"916\":\"```\",\"917\":\"### OH_JSVM_IsDataview\",\"918\":\"\",\"919\":\"判断一个 JavaScript 对象是否为 Dataview类型对象。\",\"920\":\"\",\"921\":\"cpp部分代码：\",\"922\":\"\",\"923\":\"```cpp\",\"924\":\"// hello.cpp\"}",
      "修改建议": "Dataview类型对象与Array 类型对象在描述对象类型时，用词不一致，应统一为'类型对象'。",
      "更改后示例": "判断一个 JavaScript 对象是否为 Dataview 类型对象。",
      "触发条件": "检测到类型名称与\"类型对象\"连用且中间缺少空格（如\"X类型对象\"），且存在同文档中其他规范表达（如\"Y 类型对象\"）形成不一致时触发。\n\n识别模式：\n1. 匹配中文段落中\"X类型对象\"结构（X为任意类型名称）\n2. 检查上下文是否存在相同语义但含空格的规范表达（如参考句中的\"Array 类型对象\"）\n3. 当同一文档出现\"X类型对象\"和\"Y 类型对象\"两种格式时，判定为不一致需修复"
    },
    {
      "defect_id": 436520,
      "sentence": "判断一个JavaScript对象是否为Arraybuffer类型对象。",
      "reference_sentence": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象。",
      "line_num": 79,
      "context": "{\"74\":\"```\",\"75\":\"<!-- @[oh_jsvm_get_arraybuffer_info](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmAboutArraybuffer/getarraybufferinfo/src/main/cpp/hello.cpp) -->\",\"76\":\"\",\"77\":\"### OH_JSVM_IsArraybuffer\",\"78\":\"\",\"79\":\"判断一个JavaScript对象是否为Arraybuffer类型对象。\",\"80\":\"\",\"81\":\"cpp部分代码：\",\"82\":\"\",\"83\":\"```cpp\",\"84\":\"// hello.cpp\"}",
      "修改建议": "混用了 'Arraybuffer' 和 'ArrayBuffer'，大小写不一致。",
      "更改后示例": "判断一个 JavaScript 对象是否为 ArrayBuffer 类型对象。",
      "触发条件": "文档中同一技术术语存在大小写混用（如Arraybuffer/ArrayBuffer），或与官方API名称（ArrayBuffer）的大小写规范不一致。"
    },
    {
      "defect_id": 435911,
      "sentence": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。",
      "reference_sentence": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly 缓存序列化和反序列化的能力。",
      "line_num": 6,
      "context": "{\"1\":\"# 使用JSVM-API接口进行WebAssembly模块相关开发\",\"2\":\"\",\"3\":\"\",\"4\":\"## 简介\",\"5\":\"\",\"6\":\"JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。\",\"7\":\"权限要求：WebAssembly相关接口需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"8\":\"运行限制：当前 JSVM 版本在坚盾守护模式下将禁用 WebAssembly 全部功能模块。开发者需针对此限制进行应用兼容性评估，具体技术规范详见[JSVM 坚盾守护模式](jsvm-secure-shield-mode.md)。\",\"9\":\"\",\"10\":\"## 基本概念\",\"11\":\"\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly 缓存序列化和反序列化的能力。",
      "触发条件": "当同一术语在相邻或同一上下文中出现中英文混用（如\"cache\"和\"缓存\"），或同一术语在文档范围内存在不一致表达形式时触发。\n\n识别模式：\n1. 检测并列结构中的术语一致性（如列表项、排比句中的术语需保持统一）\n2. 对比上下文术语使用历史（若同一段落/章节已出现中文译词，后续应延续使用）\n3. 识别特殊名词的首次定义与后续引用是否匹配（首现原则优先）\n4. 捕捉中英文术语混合现象（如\"WebAssembly cache\"应统一为\"WebAssembly 缓存\"）"
    },
    {
      "defect_id": 436329,
      "sentence": "创建一个指定长度的 JavaScript 数组对象。",
      "reference_sentence": "创建一个新的 JavaScript 数组对象",
      "line_num": 97,
      "context": "{\"92\":\"```\",\"93\":\"JSVM CreateArray success\",\"94\":\"```\",\"95\":\"### OH_JSVM_CreateArrayWithLength\",\"96\":\"\",\"97\":\"创建一个指定长度的 JavaScript 数组对象。\",\"98\":\"\",\"99\":\"cpp部分代码：\",\"100\":\"\",\"101\":\"```cpp\",\"102\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少实际功能描述。",
      "更改后示例": "创建一个指定长度的 JavaScript 数组对象。此接口用于在JSVM模块中生成一个指定长度的数组对象。",
      "触发条件": "当接口描述语句仅包含\"创建...\"基础句式但缺少\"用于...\"功能场景说明，或与相邻接口描述的\"接口用途+功能说明\"双要素结构存在句式差异时触发。\n\n识别模式：通过检测句子是否同时包含动作动词（如创建/生成）和功能场景介词结构（如\"用于...中\"），当发现同类接口描述存在单要素（仅动作）与双要素（动作+用途）混用时，即可判定为语言表达不一致问题。"
    },
    {
      "defect_id": 436270,
      "sentence": "判断一个 JavaScript 对象是否为 Dataview 类型对象",
      "reference_sentence": "使用JSVM-API接口进行数组相关开发时，在JSVM模块中可以调用相关接口直接操作和处理JavaScript中的数组。",
      "line_num": 34,
      "context": "{\"29\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"30\":\"|OH_JSVM_SetElement | 在给定对象的指定索引处设置元素 |\",\"31\":\"|OH_JSVM_GetElement | 获取给定对象指定索引处的元素 |\",\"32\":\"|OH_JSVM_HasElement | 若给定对象的指定索引处拥有属性，获取该元素 |\",\"33\":\"|OH_JSVM_DeleteElement | 尝试删除给定对象的指定索引处的元素 |\",\"34\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"35\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"36\":\"\",\"37\":\"## 使用示例\",\"38\":\"\",\"39\":\"JSVM-API 接口开发流程参考[使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应 C++ 相关代码进行展示。\"}",
      "修改建议": "混用了'数组'和'Dataview 类型对象'两个词",
      "更改后示例": "判断一个 JavaScript 对象是否为 DataView 类型对象",
      "触发条件": "当文档中同一技术术语存在大小写不一致（如\"Dataview\"与标准名称\"DataView\"）或与上下文接口命名（如OH_JSVM_IsDataview）产生术语歧义时触发。\n\n识别模式：\n1. 术语形态匹配：检测技术名词是否与上下文接口名/参考句中的标准术语存在拼写差异（如驼峰命名缺失、大小写错误）\n2. 语义冲突识别：当同一段落出现多个相似术语（如\"数组\"和\"Dataview类型对象\"）且未明确区分技术定义时触发。"
    },
    {
      "defect_id": 435915,
      "sentence": "将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，会导致序列化失败。",
      "reference_sentence": "将 wasm module 中的机器码序列化为 wasm 缓存，如果 wasm module 不包含机器码，会导致序列化失败。",
      "line_num": 23,
      "context": "{\"18\":\"| 接口                          | 功能说明                                                                                 |\",\"19\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"20\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败后再执行编译。 |\",\"21\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"22\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是wasm module。                                                             |\",\"23\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，会导致序列化失败。                    |\",\"24\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"25\":\"\",\"26\":\"## code cache 校验规格说明\",\"27\":\"| 规格        | 规格说明                                         |\",\"28\":\"| ---------- | ------------------------------------------------ |\"}",
      "修改建议": "混用了 'cache' 和 '缓存' 术语。",
      "更改后示例": "将 wasm module 中的机器码序列化为 wasm 缓存，如果 wasm module 不包含机器码，会导致序列化失败。",
      "触发条件": "同一技术术语在中文语境中出现中英文混用（如\"cache\"和\"缓存\"交替出现），且上下文存在对应规范译法时。\n\n识别模式：\n1. 通过术语对照表检测中英文术语映射关系（如\"cache→缓存\"）\n2. 扫描相邻段落/表格中同一概念的表达形式\n3. 验证技术名词在接口定义与说明文本中的一致性（如接口名\"CreateWasmCache\"对应中文应统一使用\"缓存\"）\n4. 检查标点符号后的术语使用（如问题句末尾\"失败。\"后接英文术语需修正）"
    },
    {
      "defect_id": 436264,
      "sentence": "在现有的ArrayBuffer上创建JavaScript TypedArray对象，TypedArray对象提供类似数组的视图，每个元素具有相同的二进制标量数据类型。注意(length * size_of_element) + byte_offset 不得超过传入数组的大小（以字节为单位），否则会引发RangeError异常。",
      "reference_sentence": "使用JSVM-API接口进行数组相关开发时，在JSVM模块中可以调用相关接口直接操作和处理JavaScript中的数组。",
      "line_num": 24,
      "context": "{\"19\":\"\",\"20\":\"| 接口                         | 功能说明                                   |\",\"21\":\"| ---------------------------- | ------------------------------------------ |\",\"22\":\"|OH_JSVM_CreateArray | 创建一个新的 JavaScript 数组对象 |\",\"23\":\"|OH_JSVM_CreateArrayWithLength | 创建一个指定长度的 JavaScript 数组对象 |\",\"24\":\"|OH_JSVM_CreateTypedarray | 在现有的ArrayBuffer上创建JavaScript TypedArray对象，TypedArray对象提供类似数组的视图，每个元素具有相同的二进制标量数据类型。注意(length * size_of_element) + byte_offset 不得超过传入数组的大小（以字节为单位），否则会引发RangeError异常。|\",\"25\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象，DataView 对象在底层数据缓冲区上提供类似数组的视图，该 ArrayBuffer 允许有不同大小和类型的元素。要求 byte_length + byte_offset 小于或等于传入数组的字节大小，否则会引发 RangeError 异常。|\",\"26\":\"|OH_JSVM_GetArrayLength | 返回 Array 对象的长度 |\",\"27\":\"|OH_JSVM_GetTypedarrayInfo | 获取 TypedArray（类型化数组）对象的信息 |\",\"28\":\"|OH_JSVM_GetDataviewInfo | 获取 Dataview 对象的信息 |\",\"29\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\"}",
      "修改建议": "混用了'数组'和'类数组'两个词",
      "更改后示例": "在现有的ArrayBuffer上创建JavaScript TypedArray对象，TypedArray对象提供类似类数组的视图，每个元素具有相同的二进制标量数据类型。注意(length * size_of_element) + byte_offset 不得超过传入数组的大小（以字节为单位），否则会引发RangeError异常。",
      "触发条件": "当同一技术术语在相邻接口描述或同一功能模块中出现不一致的表达形式（如\"数组\"与\"类数组\"混用），且上下文存在已确立的标准术语（如参考句子中的\"类数组\"）时触发。\n\n识别模式：\n1. 术语变异检测：在相邻接口表格描述中识别同一技术概念的不同表达（如问题句\"数组\" vs 参考句\"类数组\"）\n2. 上下文一致性验证：检查当前接口描述与同类型接口的标准化表述是否匹配（如OH_JSVM_CreateDataview已使用\"类似数组的视图\"）\n3. 跨模块术语对齐：对比问题段落与参考段落中核心概念的命名一致性（如数组操作接口群的术语统一性）"
    },
    {
      "defect_id": 436262,
      "sentence": "JavaScript中的TypedArray是一种类数组数据视图，用于描述二进制数据。它可以视为指定元素类型的数组，TypedArray没有直接构造器，但是可以通过其子类构造器构造创建。子类包括：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array等。",
      "reference_sentence": "使用JSVM-API接口进行数组相关开发时，在JSVM模块中可以调用相关接口直接操作和处理JavaScript中的数组。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"使用JSVM-API接口进行数组（array）相关开发时，涉及的基本概念主要包括数组的创建、访问、修改、遍历以及与数组相关的操作。这些概念对于理解在JSVM模块中与JavaScript数组交互非常重要。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **数组的创建**：若在JSVM模块中需要创建新的JavaScript数组时，可以使用提供的OH_JSVM_CreateArray接口创建数组，将传递给JavaScript层。\",\"12\":\"- **数组相关操作**：在JSVM模块中通过对应的接口获取JavaScript数组的长度、检索指定索引处的元素、设置指定索引的元素值，从而实现JSVM模块与JavaScript数组的交互。\",\"13\":\"- **TypedArray**：JavaScript中的TypedArray是一种类数组数据视图，用于描述二进制数据。它可以视为指定元素类型的数组，TypedArray没有直接构造器，但是可以通过其子类构造器构造创建。子类包括：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array等。\",\"14\":\"- **ArrayBuffer**：ArrayBuffer 是固定长度的二进制数据缓冲区。\",\"15\":\"- **DataView**：DataView 是 JavaScript 中的一种视图，是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。\",\"16\":\"\",\"17\":\"\",\"18\":\"## 接口说明\"}",
      "修改建议": "混用了'数组'和'类数组数据视图'两个词",
      "更改后示例": "JavaScript中的TypedArray是一种类数组数据视图，用于描述二进制数据。它可以视为指定元素类型的类数组数据视图，TypedArray没有直接构造器，但是可以通过其子类构造器构造创建。子类包括：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array等。",
      "触发条件": "同一段落或相邻上下文中出现对同一技术概念使用不同术语表达（如\"数组\"与\"类数组数据视图\"混用），且文档中已存在明确定义的规范术语时。\n\n识别模式：\n1. 术语重复检测：在3-5句范围内检测同一技术概念的多种表达形式（如\"数组\"与\"类数组数据视图\"）\n2. 上下文验证：检查问题术语是否与上下文中的参考术语（如问题段落中的\"类数组数据视图\"）或已定义术语（如其他段落中的\"数组\"规范用法）存在冲突\n3. 技术准确性判断：当替代术语可能引发概念混淆时（如将视图对象与真实数组混为一谈），即使语义相近也应触发规则"
    },
    {
      "defect_id": 436328,
      "sentence": "创建一个新的 JavaScript 数组对象。",
      "reference_sentence": "创建一个新的 JavaScript 数组对象",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"JSVM-API 接口开发流程参考[使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应 C++ 相关代码进行展示。\",\"40\":\"\",\"41\":\"### OH_JSVM_CreateArray\",\"42\":\"\",\"43\":\"创建一个新的 JavaScript 数组对象。\",\"44\":\"\",\"45\":\"cpp部分代码：\",\"46\":\"\",\"47\":\"```cpp\",\"48\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少实际功能描述。",
      "更改后示例": "创建一个新的 JavaScript 数组对象。此接口用于在JSVM模块中生成一个新的数组对象。",
      "触发条件": "接口/方法描述仅包含对象名称未说明功能用途，或与相邻接口描述存在句式结构差异时触发。  \n\n识别模式：1) 检查描述是否缺少\"用于...\"的功能说明 2) 对比同文档其他接口描述结构（如\"生成...\"动词使用）是否一致"
    },
    {
      "defect_id": 436333,
      "sentence": "获取 TypedArray（类型化数组）对象的信息。",
      "reference_sentence": "获取 Dataview 对象的信息。",
      "line_num": 434,
      "context": "{\"429\":\"```\",\"430\":\"JSVM length: 6\",\"431\":\"```\",\"432\":\"### OH_JSVM_GetTypedarrayInfo\",\"433\":\"\",\"434\":\"获取 TypedArray（类型化数组）对象的信息。\",\"435\":\"\",\"436\":\"cpp部分代码：\",\"437\":\"\",\"438\":\"```cpp\",\"439\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少实际功能描述。",
      "更改后示例": "获取 TypedArray（类型化数组）对象的信息。此接口用于获取类型化数组对象的相关信息，如长度、元素类型等。",
      "触发条件": "当接口/方法描述句仅包含“获取...对象的信息”而未明确列举具体信息类型（如长度、元素类型等），且同一文档中其他同类条目存在功能细节补充时。"
    },
    {
      "defect_id": 436271,
      "sentence": "判断一个 JavaScript 对象是否为 Typedarray 类型对象",
      "reference_sentence": "使用JSVM-API接口进行数组相关开发时，在JSVM模块中可以调用相关接口直接操作和处理JavaScript中的数组。",
      "line_num": 35,
      "context": "{\"30\":\"|OH_JSVM_SetElement | 在给定对象的指定索引处设置元素 |\",\"31\":\"|OH_JSVM_GetElement | 获取给定对象指定索引处的元素 |\",\"32\":\"|OH_JSVM_HasElement | 若给定对象的指定索引处拥有属性，获取该元素 |\",\"33\":\"|OH_JSVM_DeleteElement | 尝试删除给定对象的指定索引处的元素 |\",\"34\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"35\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"36\":\"\",\"37\":\"## 使用示例\",\"38\":\"\",\"39\":\"JSVM-API 接口开发流程参考[使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应 C++ 相关代码进行展示。\",\"40\":\"\"}",
      "修改建议": "混用了'数组'和'Typedarray 类型对象'两个词",
      "更改后示例": "判断一个 JavaScript 对象是否为 TypedArray 类型对象",
      "触发条件": "同一技术术语在文档中存在拼写/大小写不一致（如TypedArray与Typedarray混用），或与官方API命名规范不符（如接口名IsTypedarray对应的术语应为TypedArray）时触发。\n\n识别模式：\n1. 术语形态对比：检查核心技术名词（如TypedArray/Dataview）是否与ECMA规范或接口命名（如OH_JSVM_IsTypedarray）保持严格一致\n2. 上下文一致性：当相邻条目（如IsDataview与IsTypedarray）采用相同命名结构时，需保持术语后缀（View/Array）的大小写统一性\n3. 概念对应验证：若描述中同时出现基础概念（数组）与衍生概念（TypedArray），需确保术语边界清晰不混用"
    },
    {
      "defect_id": 437742,
      "sentence": "   - 注销：发送取消传感器监听的事件，并结束长时任务。",
      "reference_sentence": "   - 注册：发起长时任务，并通过emitter接收监听数据。",
      "line_num": 35,
      "context": "{\"30\":\"   }\",\"31\":\"   ```\",\"32\":\"\",\"33\":\"3. 宿主线程定义注册及销毁的行为。\",\"34\":\"   - 注册：发起长时任务，并通过emitter接收监听数据。\",\"35\":\"   - 销毁：发送取消传感器监听的事件，并结束长时任务。\",\"36\":\"\",\"37\":\"   ```ts\",\"38\":\"   // Index.ets\",\"39\":\"   @Entry\",\"40\":\"   @Component\"}",
      "修改建议": "混用了'注销'与'销毁'的概念，应保持用词一致",
      "更改后示例": "   - 销毁：发送取消传感器监听的事件，并结束长时任务。",
      "触发条件": "同一上下文或相邻条目中存在描述相似操作但使用不一致术语（如\"注销\"与\"销毁\"），且存在明确参考基准（如配对动词\"注册-销毁\"）时触发。"
    },
    {
      "defect_id": 436332,
      "sentence": "返回 Array 对象的长度。",
      "reference_sentence": "返回 Array 对象的长度",
      "line_num": 373,
      "context": "{\"368\":\"JSVM CreateDataView success, isArraybuffer: 1\",\"369\":\"JSVM CreateDataView success, returnOffset: 4\",\"370\":\"```\",\"371\":\"### OH_JSVM_GetArrayLength\",\"372\":\"\",\"373\":\"返回 Array 对象的长度。\",\"374\":\"\",\"375\":\"cpp部分代码：\",\"376\":\"\",\"377\":\"```cpp\",\"378\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少实际功能描述。",
      "更改后示例": "返回 Array 对象的长度。此接口用于获取JavaScript数组对象的长度。",
      "触发条件": "当文档条目仅包含返回值说明但缺少功能/用途描述，且同一文档中存在同类条目包含完整\"返回值+功能说明\"句式结构时触发。识别模式需检测是否存在单一句式（仅返回值或仅功能）与上下文同类条目形成结构不匹配，特别是当动词短语后未接用途说明时。"
    },
    {
      "defect_id": 437985,
      "sentence": "5. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "reference_sentence": "5. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"2. 调用[cert.createCmsGenerator](../../reference/apis-device-certificate-kit/js-apis-cert.md#certcreatecmsgenerator18)创建cmsGenerator对象，并返回结果。\",\"14\":\"\",\"15\":\"3. 调用[cmsGenerator.addSigner](../../reference/apis-device-certificate-kit/js-apis-cert.md#addsigner18)添加签名者信息。\",\"16\":\"\",\"17\":\"5. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。\",\"18\":\"\",\"19\":\"5. 调用[cmsGenerator.doFinal](../../reference/apis-device-certificate-kit/js-apis-cert.md#dofinal18)获取Cms最终签名数据。\",\"20\":\"\",\"21\":\"- 异步方法示例：\",\"22\":\"\"}",
      "修改建议": "前文称'第3步'，后文称'第5步'，存在前后矛盾。",
      "更改后示例": "4. 调用[cmsGenerator.addCert](../../reference/apis-device-certificate-kit/js-apis-cert.md#addcert18)添加证书。",
      "触发条件": "当文档中连续步骤的编号出现非递增顺序（如3→5）或重复序号（如两个步骤5），且与上下文步骤引用存在矛盾时触发。\n\n识别模式：通过检查步骤列表的序号连续性（如3之后应为4）、检测重复的步骤编号（如出现两次\"5.\"），并比对上下文中的步骤引用（如修复理由中提到的前文称\"第3步\"与当前步骤5的矛盾）。"
    },
    {
      "defect_id": 438533,
      "sentence": "普通类实例对象的属性可持有Sendable类实例对象。",
      "reference_sentence": "## 复杂类实例对象使用Sendable进行大容量数据库操作",
      "line_num": 317,
      "context": "{\"312\":\"   ```\",\"313\":\"   <!-- @[operate_child_thread_data](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ApplicationMultithreadingDevelopment/PracticalCases/entry/src/main/ets/managers/UsingTaskPool.ets) -->\",\"314\":\"\",\"315\":\"## 复杂类实例对象使用Sendable进行大容量数据库操作\",\"316\":\"\",\"317\":\"普通类实例对象的属性可持有Sendable类实例对象。\",\"318\":\"\",\"319\":\"对于复杂的普通类实例对象，可以先将相应数据库数据字段封装为Sendable类实例对象，再由普通类实例对象持有，从而降低跨线程开销。\",\"320\":\"\",\"321\":\"1. 定义数据库中的数据格式，可采用Sendable，减少跨线程耗时。\",\"322\":\"\"}",
      "修改建议": "混用了“普通类实例对象”和“复杂类实例对象”描述同一概念。",
      "更改后示例": "复杂类实例对象的属性可持有Sendable类实例对象。",
      "触发条件": "同一文档相邻段落中出现对同一概念使用不同术语描述（如\"普通类实例对象\"与\"复杂类实例对象\"），且上下文存在明确的标准术语参照（如章节标题已确立\"复杂类实例对象\"为规范表述）。"
    },
    {
      "defect_id": 438493,
      "sentence": "2. UI主线程调用子任务，完成数据库的增删改查等操作。",
      "reference_sentence": "2. UI主线程发起，在子线程进行数据的增删改查等操作。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"通过ArkTS提供的TaskPool能力，可以将数据库操作任务移到子线程中，实现如下。\",\"8\":\"\",\"9\":\"1. 创建多个子任务，支持数据库的创建、插入、查询和清除等操作。\",\"10\":\"\",\"11\":\"2. UI主线程调用子任务，完成数据库的增删改查等操作。\",\"12\":\"\",\"13\":\"```ts\",\"14\":\"// Index.ets\",\"15\":\"import { relationalStore, ValuesBucket } from '@kit.ArkData';\",\"16\":\"import { taskpool } from '@kit.ArkTS';\"}",
      "修改建议": "描述了相同的动作，但用词不一致，'调用子任务'与'发起'混用。",
      "更改后示例": "2. UI主线程发起，在子线程完成数据库的增删改查等操作。",
      "触发条件": "同一段落或相邻句子中出现对相同动作使用不同动词描述（如\"调用\"与\"发起\"混用），且上下文存在更一致的替代词（如参考句中的\"发起\"与\"进行\"搭配模式）时触发。"
    },
    {
      "defect_id": 438351,
      "sentence": "1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。",
      "reference_sentence": "1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"提供使用Worker进行常驻任务的开发指导。Worker将持续执行任务，直到宿主线程发送终止指令。\",\"4\":\"\",\"5\":\"开发过程和示例如下：\",\"6\":\"\",\"7\":\"1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，点击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。\",\"8\":\"\",\"9\":\"   此外，还支持手动创建Worker文件，具体方式和相关注意事项请参见[创建Worker的注意事项](worker-introduction.md#创建worker的注意事项)。\",\"10\":\"\",\"11\":\"2. 导入Worker模块。\",\"12\":\"\"}",
      "修改建议": "无问题，用词一致",
      "更改后示例": "1. DevEco Studio支持一键生成Worker，在对应的{moduleName}目录下任意位置，单击鼠标右键 &gt; New &gt; Worker，即可自动生成Worker的模板文件及配置信息。本文以创建“Worker”为例。",
      "触发条件": "当同一文档中相同操作描述存在动词不一致（如\"点击\"与\"单击\"混用）时，且上下文已建立统一术语规范（如技术文档要求使用\"单击\"描述鼠标操作）。识别模式：检测描述用户界面操作的同义动词（点击/单击、选择/勾选等）是否与上下文既定术语冲突。"
    },
    {
      "defect_id": 438495,
      "sentence": "2. UI主线程发起，在子线程进行数据的增删改查等操作。",
      "reference_sentence": "2. UI主线程调用子任务，完成数据库的增删改查等操作。",
      "line_num": 175,
      "context": "{\"170\":\"     }\",\"171\":\"   }\",\"172\":\"   ```\",\"173\":\"   <!-- @[define_data_format](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ApplicationMultithreadingDevelopment/PracticalCases/entry/src/main/ets/managers/SharedValuesBucket.ets) -->\",\"174\":\"\",\"175\":\"2. UI主线程发起，在子线程进行数据的增删改查等操作。\",\"176\":\"\",\"177\":\"   ```ts\",\"178\":\"   // Index.ets\",\"179\":\"   import { relationalStore, ValuesBucket } from '@kit.ArkData';\",\"180\":\"   import { collections, taskpool } from '@kit.ArkTS';\"}",
      "修改建议": "描述了相同的动作，但用词不一致，'发起'与'调用子任务'混用。",
      "更改后示例": "2. UI主线程发起，在子线程完成数据的增删改查等操作。",
      "触发条件": "同一动作链中动词描述不一致（如\"发起\"与\"进行\"混用），且上下文存在相同动作的标准表达（如\"调用...完成\"）时触发。"
    },
    {
      "defect_id": 438096,
      "sentence": "常驻任务是指相比于短时任务，时间更长的任务，可能跟UI主线程生命周期一致。相比于长时任务，常驻任务更倾向于跟线程绑定的任务，单次运行时间更长（比如超过3分钟）。",
      "reference_sentence": "在应用业务实现过程中，对于耗时较长（超过3分钟）且并发量不大的常驻任务场景，建议使用Worker在后台线程中执行这些耗时操作，从而避免阻塞UI主线程，防止出现丢帧、卡顿等影响用户体验的问题。",
      "line_num": 5,
      "context": "{\"1\":\"# 常驻任务并发场景简介\",\"2\":\"\",\"3\":\"在应用业务实现过程中，对于耗时较长（超过3分钟）且并发量不大的常驻任务场景，建议使用Worker在后台线程中执行这些耗时操作，从而避免阻塞UI主线程，防止出现丢帧、卡顿等影响用户体验的问题。\",\"4\":\"\",\"5\":\"常驻任务是指相比于短时任务，时间更长的任务，可能跟UI主线程生命周期一致。相比于长时任务，常驻任务更倾向于跟线程绑定的任务，单次运行时间更长（比如超过3分钟）。\",\"6\":\"\",\"7\":\"对应常驻任务，较为常见的业务场景如下：\",\"8\":\"\",\"9\":\"| 常见业务场景 | 具体业务描述 |\",\"10\":\"| -------- | -------- |\"}",
      "修改建议": "前后文对“常驻任务”和“长时任务”定义不一致，容易造成混淆。",
      "更改后示例": "常驻任务是指时间较长的任务，可能跟UI主线程生命周期一致。相比于短时任务，常驻任务更倾向于跟线程绑定的任务，单次运行时间更长（比如超过3分钟）。",
      "触发条件": "当同一术语在相邻段落或同一章节中存在多个矛盾性对比对象（如\"短时任务\"和\"长时任务\"交替出现），且缺乏明确概念区分时触发。\n\n识别模式：\n1. 术语对比冲突：通过检测\"相比于X，Y...\"的句式结构，识别同一术语(Y)前后使用不同对比对象(X)的情况\n2. 上下文矛盾：结合术语定义上下文（如问题段落前的参考句已明确\"常驻任务=耗时较长\"），当后续描述出现新的未定义对比术语（如\"长时任务\"）时判定冲突"
    },
    {
      "defect_id": 437721,
      "sentence": "检查wantList队列个数，是否已超过上限。",
      "reference_sentence": "检查wantList内的元素个数，是否已超过上限。",
      "line_num": 1122,
      "context": "{\"1117\":\"\",\"1118\":\"wantList内的元素个数超出4个。\",\"1119\":\"\",\"1120\":\"**处理步骤**\",\"1121\":\"\",\"1122\":\"检查wantList队列个数，是否已超过上限。\",\"1123\":\"\",\"1124\":\"## 16000121 待启动的目标组件类型不是UIAbility\",\"1125\":\"\",\"1126\":\"**错误信息**\",\"1127\":\"\"}",
      "修改建议": "混用了'队列'与'元素个数'，建议使用'元素个数'保持一致",
      "更改后示例": "检查wantList内的元素个数，是否已超过上限。",
      "触发条件": "同一上下文中对同一概念混用不同术语（如“队列个数”与“元素个数”），且存在已确定的统一表达形式（如上下文其他位置明确使用“元素个数”）。"
    },
    {
      "defect_id": 438534,
      "sentence": "对于复杂的普通类实例对象，可以先将相应数据库数据字段封装为Sendable类实例对象，再由普通类实例对象持有，从而降低跨线程开销。",
      "reference_sentence": "## 复杂类实例对象使用Sendable进行大容量数据库操作",
      "line_num": 319,
      "context": "{\"314\":\"\",\"315\":\"## 复杂类实例对象使用Sendable进行大容量数据库操作\",\"316\":\"\",\"317\":\"普通类实例对象的属性可持有Sendable类实例对象。\",\"318\":\"\",\"319\":\"对于复杂的普通类实例对象，可以先将相应数据库数据字段封装为Sendable类实例对象，再由普通类实例对象持有，从而降低跨线程开销。\",\"320\":\"\",\"321\":\"1. 定义数据库中的数据格式，可采用Sendable，减少跨线程耗时。\",\"322\":\"\",\"323\":\"   ```ts\",\"324\":\"   // SharedValuesBucket.ets\"}",
      "修改建议": "混用了“复杂的普通类实例对象”和“复杂类实例对象”描述同一概念。",
      "更改后示例": "对于复杂的类实例对象，可以先将相应数据库数据字段封装为Sendable类实例对象，再由类实例对象持有，从而降低跨线程开销。",
      "触发条件": "同一术语在相邻上下文中出现冗余修饰词差异（如\"普通类实例对象\"与\"类实例对象\"）或同一概念存在两种及以上表述形式时触发。\n\n识别模式：\n1. 检测相邻段落/句子中核心术语的修饰词一致性（如\"复杂(的)类实例对象\"）\n2. 对比当前术语与文档既有表述（如参考句中的\"复杂类实例对象\"）\n3. 识别冗余限定词（如\"普通\"在上下文未定义具体差异时属于冗余修饰）\n4. 验证术语是否指向同一技术概念（通过属性持有关系、功能描述等上下文验证）"
    },
    {
      "defect_id": 438494,
      "sentence": "1. 定义数据库中的数据格式，可以使用Sendable，以减少跨线程操作的耗时。",
      "reference_sentence": "1. 创建多个子任务，支持数据库的创建、插入、查询和清除等操作。",
      "line_num": 147,
      "context": "{\"142\":\"\",\"143\":\"## 使用Sendable进行大容量数据库操作\",\"144\":\"\",\"145\":\"由于数据库数据跨线程传递存在耗时，数据量较大时会占用UI主线程。推荐使用Sendable封装数据库数据，以降低跨线程开销。\",\"146\":\"\",\"147\":\"1. 定义数据库中的数据格式，可以使用Sendable，以减少跨线程操作的耗时。\",\"148\":\"\",\"149\":\"   ```ts\",\"150\":\"   // SharedValuesBucket.ets\",\"151\":\"   export interface IValueBucket {\",\"152\":\"     id: number\"}",
      "修改建议": "描述了相同的场景，但用词不一致，'定义'与'创建'混用。",
      "更改后示例": "1. 创建数据库中的数据格式，可以使用Sendable，以减少跨线程操作的耗时。",
      "触发条件": "当同一上下文或相邻段落中出现相同功能描述但使用不同动词(如\"定义\"与\"创建\")，且存在已确定的参考术语(如\"创建\")时触发。\n\n识别模式：\n1. 动词不一致检测：识别描述相同操作时使用的不同动作动词(如定义/创建/设置)\n2. 上下文锚定匹配：检查当前段落是否包含已确定的参考术语(如\"创建数据库\"中的\"创建\")\n3. 语义等价判断：通过句法分析确认不同动词描述的是同一操作场景(如数据格式初始化)\n4. 邻近段落对比：在3个相邻段落范围内检测术语使用一致性"
    },
    {
      "defect_id": 440265,
      "sentence": "DevEco Studio为开发者提供了UI界面预览功能，可以查看UI界面效果，方便开发者随时调整界面UI布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "line_num": 3,
      "context": "{\"1\":\"# UI预览\",\"2\":\"\",\"3\":\"DevEco Studio为开发者提供了UI界面预览功能，可以查看UI界面效果，方便开发者随时调整界面UI布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。\",\"4\":\"\",\"5\":\"![ide_previewer_001](figures/ide_previewer_001.png)\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\"}",
      "修改建议": "混用了“UI界面预览”和“UI预览”",
      "更改后示例": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "触发条件": "同一术语在相邻上下文或标题与正文中存在不一致的表达形式（如\"UI界面预览\"与\"UI预览\"混用），或同一概念重复出现时使用不同缩略/完整形态。  \n\n识别模式：  \n1. 术语冗余检测：检查核心术语是否包含可省略的限定词（如\"界面\"在\"UI界面预览\"中与标题\"UI预览\"冲突）  \n2. 上下文一致性验证：比对当前术语与标题术语、前文已定义术语是否匹配（如问题段落所在章节标题为\"UI预览\"）  \n3. 相邻重复检测：同一段落中连续出现同一概念的不同表达形式（如\"UI界面效果\"与后续\"UI效果\"不统一）"
    },
    {
      "defect_id": 438536,
      "sentence": "2. 定义普通类实例对象，持有Sendable类实例对象。",
      "reference_sentence": "## 复杂类实例对象使用Sendable进行大容量数据库操作",
      "line_num": 348,
      "context": "{\"343\":\"       this.salary = v.salary;\",\"344\":\"     }\",\"345\":\"   }\",\"346\":\"   ```\",\"347\":\"\",\"348\":\"2. 定义普通类实例对象，持有Sendable类实例对象。\",\"349\":\"\",\"350\":\"   ```ts\",\"351\":\"   // Material.ets\",\"352\":\"   import { SharedValuesBucket } from './SharedValuesBucket';\",\"353\":\"   import { collections } from '@kit.ArkTS';\"}",
      "修改建议": "混用了“普通类实例对象”和“复杂类实例对象”描述同一概念。",
      "更改后示例": "2. 定义复杂类实例对象，持有Sendable类实例对象。",
      "触发条件": "同一文档中出现对同一技术概念使用多个不同术语（如\"普通类实例对象\"与\"复杂类实例对象\"），且上下文存在明确的标准术语参照（如参考句子中的\"复杂类实例对象\"）。\n\n识别模式：\n1. 术语冲突检测：在相邻段落或同一章节内，发现描述同一技术实体的不同命名形式\n2. 参考对齐验证：通过文档其他部分的标准化表述（如标题、代码注释或前文定义）确认正确术语形式\n3. 语义等价判断：结合代码上下文（如类名SharedValuesBucket）验证不同术语指向同一技术概念"
    },
    {
      "defect_id": 439582,
      "sentence": "组件提供方",
      "reference_sentence": "无",
      "line_num": 101,
      "context": "{\"96\":\"    Image($r('app.media.startIcon'))\",\"97\":\"    Text('test')\",\"98\":\"  }\",\"99\":\"}\",\"100\":\"```\",\"101\":\"**组件提供方**\",\"102\":\"\",\"103\":\"原子化服务提供方有两个文件需要修改\",\"104\":\"- 提供方入口文件/src/main/ets/entryability/EntryAbility.ets\",\"105\":\"```ts\",\"106\":\"import { AbilityConstant, Want } from '@kit.AbilityKit';\"}",
      "修改建议": "混用了'组件提供方'与'提供方'，建议统一使用'提供方'。",
      "更改后示例": "提供方",
      "触发条件": "同一文档或相邻上下文中出现同一术语的不同变体（如全称与简称、带修饰词与无修饰词），且未明确区分不同含义。例如，术语\"组件提供方\"与\"提供方\"在相同技术语境下交替使用，且未通过注释/定义说明二者差异时触发。"
    },
    {
      "defect_id": 438535,
      "sentence": "1. 定义数据库中的数据格式，可采用Sendable，减少跨线程耗时。",
      "reference_sentence": "## 复杂类实例对象使用Sendable进行大容量数据库操作",
      "line_num": 321,
      "context": "{\"316\":\"\",\"317\":\"普通类实例对象的属性可持有Sendable类实例对象。\",\"318\":\"\",\"319\":\"对于复杂的普通类实例对象，可以先将相应数据库数据字段封装为Sendable类实例对象，再由普通类实例对象持有，从而降低跨线程开销。\",\"320\":\"\",\"321\":\"1. 定义数据库中的数据格式，可采用Sendable，减少跨线程耗时。\",\"322\":\"\",\"323\":\"   ```ts\",\"324\":\"   // SharedValuesBucket.ets\",\"325\":\"   export interface IValueBucket {\",\"326\":\"     id: number;\"}",
      "修改建议": "混用了“可采用Sendable”和“采用Sendable”描述同一操作。",
      "更改后示例": "1. 定义数据库中的数据格式，采用Sendable，减少跨线程耗时。",
      "触发条件": "同一上下文或相邻段落中对同一操作或对象存在\"可+动词\"与纯动词结构混用（如\"可采用\"与\"采用\"交替出现），且未保持统一表达方式时触发。  \n\n识别模式：  \n1. 在3-5个相邻句子范围内检测描述同一技术动作的动词短语变体  \n2. 当出现\"可+动词\"结构（如可采用）与直接动词结构（如采用）指代同一操作时  \n3. 特别关注步骤说明、技术建议等需要保持句式统一的关键说明段落"
    },
    {
      "defect_id": 439436,
      "sentence": "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项业务，可以采用共享模块来实现。",
      "reference_sentence": "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项业务，可以采用共享模块来实现。",
      "line_num": 3,
      "context": "{\"1\":\"# 全局配置项功能场景\",\"2\":\"\",\"3\":\"对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项业务，可以采用共享模块来实现。\",\"4\":\"\",\"5\":\"以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的业务功能，具体步骤如下。\",\"6\":\"\",\"7\":\"1. 编写全局配置文件。\",\"8\":\"\"}",
      "修改建议": "句子中使用了'业务'一词，建议使用'功能'保持一致。",
      "更改后示例": "对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项功能，可以采用共享模块来实现。",
      "触发条件": "当同一概念在相邻上下文或标题中存在多个不同术语表述（如\"功能\"与\"业务\"混用），且与文档已建立的术语体系（如标题定义）产生冲突时触发。\n\n识别模式：\n1. 核心概念匹配：检查名词性术语是否与所在章节标题（如\"全局配置项功能场景\"）或前文定义的关键术语（如\"功能\"）保持一致\n2. 邻近语境对比：在3-5句范围内检测同一概念的表述一致性（如本段第3句的\"业务\"与第5句的\"业务功能\"形成干扰）\n3. 功能属性判断：区分抽象业务场景（如\"下载业务\"）与具体技术功能（如\"配置项功能\"）的适用语境"
    },
    {
      "defect_id": 439437,
      "sentence": "以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的业务功能，具体步骤如下。",
      "reference_sentence": "以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的业务功能，具体步骤如下。",
      "line_num": 5,
      "context": "{\"1\":\"# 全局配置项功能场景\",\"2\":\"\",\"3\":\"对于需要使用进程单例的场景，例如不同并发实例间需要数据保持一致的全局配置项业务，可以采用共享模块来实现。\",\"4\":\"\",\"5\":\"以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的业务功能，具体步骤如下。\",\"6\":\"\",\"7\":\"1. 编写全局配置文件。\",\"8\":\"\",\"9\":\"   ```ts\",\"10\":\"   // Config.ets\"}",
      "修改建议": "句子中使用了'业务功能'一词，建议使用'功能'保持一致。",
      "更改后示例": "以下示例展示了只有在Wi-Fi打开且用户登录的情况下才能进行下载的功能，具体步骤如下。",
      "触发条件": "当文档中同一概念出现多个术语变体（如\"业务功能\"与\"功能\"混用），且上下文已存在明确的标准术语（如\"功能\"）时触发；或当复合术语中的限定词（如\"业务\"）在邻近上下文中已通过其他方式明确传达时触发。\n\n识别模式：\n1. 术语交叉验证：在相邻段落（3句范围内）检测到同一概念的不同表达形式（如第3段\"全局配置项业务\"已明确业务属性，第5段\"业务功能\"中的\"业务\"成为冗余限定）\n2. 术语密度分析：当复合术语中的限定词（如\"业务\"）在200字符范围内未出现必要性支撑内容时，判定为冗余限定\n3. 一致性映射：通过文档术语表或高频词统计（如全文档\"功能\"出现23次，\"业务功能\"仅出现1次），识别偏离标准表述的情况"
    },
    {
      "defect_id": 439583,
      "sentence": "原子化服务提供方有两个文件需要修改",
      "reference_sentence": "无",
      "line_num": 103,
      "context": "{\"98\":\"  }\",\"99\":\"}\",\"100\":\"```\",\"101\":\"**组件提供方**\",\"102\":\"\",\"103\":\"原子化服务提供方有两个文件需要修改\",\"104\":\"- 提供方入口文件/src/main/ets/entryability/EntryAbility.ets\",\"105\":\"```ts\",\"106\":\"import { AbilityConstant, Want } from '@kit.AbilityKit';\",\"107\":\"import { hilog } from '@kit.PerformanceAnalysisKit';\",\"108\":\"import { window } from '@kit.ArkUI';\"}",
      "修改建议": "混用了'提供方'与'原子化服务提供方'，建议统一使用'提供方'。",
      "更改后示例": "提供方有两个文件需要修改",
      "触发条件": "同一术语在邻近上下文中存在冗余变体（如全称与简称混用），且无明确理由需保留不同形式时触发。识别模式为检查相邻段落或同一概念是否已使用更简洁/标准术语，并比对当前表述是否冗余或偏离。"
    },
    {
      "defect_id": 436358,
      "sentence": "判断一个 JavaScript 对象是否为 Typedarray 类型对象。",
      "reference_sentence": "判断一个 JavaScript 对象是否为 Array 类型对象。",
      "line_num": 969,
      "context": "{\"964\":\"```\",\"965\":\"JSVM IsDataView: 1\",\"966\":\"```\",\"967\":\"### OH_JSVM_IsTypedarray\",\"968\":\"\",\"969\":\"判断一个 JavaScript 对象是否为 Typedarray 类型对象。\",\"970\":\"\",\"971\":\"cpp部分代码：\",\"972\":\"\",\"973\":\"```cpp\",\"974\":\"// hello.cpp\"}",
      "修改建议": "Typedarray 类型对象与Array 类型对象在描述对象类型时，用词不一致，应统一为'类型对象'。",
      "更改后示例": "判断一个 JavaScript 对象是否为 TypedArray 类型对象。",
      "触发条件": "当同一文档中出现类型名称拼写不一致（如\"Typedarray\"与\"TypedArray\"）且类型描述结构不统一（如\"类型对象\"短语使用不连贯）时触发。\n\n识别模式：\n1. 检测类型名称是否符合标准技术术语（如JavaScript规范中的\"TypedArray\"）\n2. 对比上下文同类表述（如\"Array 类型对象\"与\"Typedarray 类型对象\"）\n3. 验证\"类型对象\"固定短语的完整性（排除缺失\"类型\"或\"对象\"的情况）"
    },
    {
      "defect_id": 440266,
      "sentence": "1.启动方式：选中当前需要预览的ets页面，点击右边侧边栏Previewer按钮，即可启动页面预览。",
      "reference_sentence": "1. 启动方式：选中当前需要预览的ets页面，单击右边侧边栏Previewer按钮，即可启动页面预览。",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"## 页面预览\",\"12\":\"\",\"13\":\"ArkTS应用/元服务均支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现，可以查看当前UI界面效果。\",\"14\":\"\",\"15\":\"1.启动方式：选中当前需要预览的ets页面，点击右边侧边栏Previewer按钮，即可启动页面预览。\",\"16\":\"\",\"17\":\"2.热加载：在启动页面预览的前提下，如果添加/删除/修改了UI组件，只需要通过Ctrl+S进行保存，预览器也会同步刷新预览效果，无需重新启动预览。\",\"18\":\"\",\"19\":\"3.路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。\",\"20\":\"\"}",
      "修改建议": "混用了“点击”和“单击”",
      "更改后示例": "1. 启动方式：选中当前需要预览的ets页面，单击右边侧边栏Previewer按钮，即可启动页面预览。",
      "触发条件": "同一操作描述在相邻上下文中出现动词不一致（如\"点击\"与\"单击\"混用），且存在已明确定义的统一表达形式（如参考句中的\"单击\"）。"
    },
    {
      "defect_id": 441433,
      "sentence": "组件组件预览默认的预览设备为Phone。可以通过设置@Preview的参数，指定预览设备的相关属性，如不同设备、不同屏幕形状等。若不设置@Preview的参数，默认的设备属性如下：",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "line_num": 98,
      "context": "{\"93\":\"```\",\"94\":\"\",\"95\":\"效果如下：\",\"96\":\"![ide_previewer_005](figures/ide_previewer_005.png)\",\"97\":\"\",\"98\":\"组件组件预览默认的预览设备为Phone。可以通过设置@Preview的参数，指定预览设备的相关属性，如不同设备、不同屏幕形状等。若不设置@Preview的参数，默认的设备属性如下：\",\"99\":\"\",\"100\":\"```ts\",\"101\":\"@Preview({\",\"102\":\"  title: 'Component1',  //预览组件的名称\",\"103\":\"  deviceType: 'phone',  //指定当前组件预览渲染的设备类型，默认为Phone\"}",
      "修改建议": "重复使用了“组件”",
      "更改后示例": "组件预览默认的预览设备为Phone。可以通过设置@Preview的参数，指定预览设备的相关属性，如不同设备、不同屏幕形状等。若不设置@Preview的参数，默认的设备属性如下：",
      "触发条件": "检测到相邻词语重复冗余（如\"组件组件\"），且上下文存在正确单次使用该术语的参考依据（如\"组件预览\"）。"
    },
    {
      "defect_id": 441103,
      "sentence": "napi_value不是多线程安全的，不能直接在多线程之间共享。",
      "reference_sentence": "为了支持此类场景，C++线程需具备创建调用ArkTS的能力，并对Sendable对象进行多线程共享和操作。",
      "line_num": 82,
      "context": "{\"77\":\"\",\"78\":\"主要步骤包括：创建执行环境、加载模块、查找并调用模块函数（也可以直接通过Node-API接口创建Sendable对象），最后销毁执行环境。关于第二步加载模块的详细信息，请参见[使用Node-API接口进行模块加载](../napi/use-napi-load-module-with-info.md)。关于第三步查找并调用函数及更多Node-API接口能力，请参见[Node-API](../reference/native-lib/napi.md#node-api)。\",\"79\":\"\",\"80\":\"## 在C++线程之间操作Sendable共享对象\",\"81\":\"\",\"82\":\"实现在C++调用ArkTS能力后，需要通过序列化和反序列化跨线程传递。napi_value不是多线程安全的，不能直接在多线程之间共享。\",\"83\":\"\",\"84\":\"下面代码例子说明了如何序列化和反序列化传递对象，注意因为Sendable共享对象是引用传递，所以序列化不会产生另外一份拷贝数据，而是直接传递对象引用到反序列化线程，所以在性能上相比非Sendable对象的序列化和反序列化更为高效。\",\"85\":\"\",\"86\":\"ArkTS文件定义。\",\"87\":\"\"}",
      "修改建议": "混用了'共享'与'操作'的顺序",
      "更改后示例": "napi_value不是多线程安全的，不能直接在多线程之间操作和共享。",
      "触发条件": "当同一上下文或相邻段落中，对同一组动作术语（如\"共享和操作\"）存在顺序不一致的表达，且与文档其他部分已确立的固定术语顺序（如\"共享和操作\"）产生矛盾时触发。"
    },
    {
      "defect_id": 440267,
      "sentence": "在使用页面预览的基础下，提供了极速预览和inspector双向预览两大特性能力，接下来针对两大特性能力进行详细说明。",
      "reference_sentence": "在使用页面预览的基础上，提供了极速预览和inspector双向预览两大特性，接下来针对两大特性进行详细说明。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"2.热加载：在启动页面预览的前提下，如果添加/删除/修改了UI组件，只需要通过Ctrl+S进行保存，预览器也会同步刷新预览效果，无需重新启动预览。\",\"18\":\"\",\"19\":\"3.路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。\",\"20\":\"\",\"21\":\"在使用页面预览的基础下，提供了极速预览和inspector双向预览两大特性能力，接下来针对两大特性能力进行详细说明。\",\"22\":\"\",\"23\":\"### 极速预览\",\"24\":\"\",\"25\":\"支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览功能。\",\"26\":\"\"}",
      "修改建议": "混用了“基础下”和“基础上”，以及“特性能力”和“特性”",
      "更改后示例": "在使用页面预览的基础上，提供了极速预览和inspector双向预览两大特性，接下来针对两大特性进行详细说明。",
      "触发条件": "同一上下文出现同一概念的不同表达形式（如\"基础下\"与\"基础上\"）或冗余复合名词（如\"特性能力\"与\"特性\"），且相邻句子存在重复术语时触发。\n\n识别模式：\n1. 检测介词结构一致性：通过NLP工具识别\"基础+X\"类短语，比对上下文使用的固定搭配（如参考句中的\"基础上\"）\n2. 识别冗余名词组合：当技术术语后接通用名词（如\"特性能力\"）时，检查该组合是否在上下文存在简化形式（如单用\"特性\"）\n3. 跨句术语对比：当相邻句子重复出现相同核心词（如两次\"特性能力\"）时，自动标记可能冗余的复合表达"
    },
    {
      "defect_id": 440268,
      "sentence": "支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览功能。",
      "reference_sentence": "支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览。",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"在使用页面预览的基础下，提供了极速预览和inspector双向预览两大特性能力，接下来针对两大特性能力进行详细说明。\",\"22\":\"\",\"23\":\"### 极速预览\",\"24\":\"\",\"25\":\"支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览功能。\",\"26\":\"\",\"27\":\"> **说明：**\",\"28\":\">\",\"29\":\"> 部分应用场景不支持极速预览：\",\"30\":\"> 1.当前页面不显示的组件。\"}",
      "修改建议": "混用了“关闭极速预览功能”和“关闭极速预览”",
      "更改后示例": "支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览。",
      "触发条件": "当同一术语在文档中同时存在带限定词（如\"功能\"）和不带限定词两种表述形式时；或同一概念在相邻语句中出现不同词长表述时。\n\n识别模式：\n1. 检测相邻/上下文语句中核心术语的一致性（如\"极速预览\"与\"极速预览功能\"）\n2. 对比操作动词与受控对象的匹配关系（\"关闭\"应直接作用于功能名称本身，而非名称+\"功能\"）\n3. 验证同一段落内术语表述的稳定性（前文已建立\"极速预览\"作为标准术语）"
    },
    {
      "defect_id": 440827,
      "sentence": "当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。",
      "reference_sentence": "无",
      "line_num": 3,
      "context": "{\"1\":\"# ArkUI数据更新场景\",\"2\":\"\",\"3\":\"当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。\",\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。\",\"7\":\"- 从子线程获取数据，然后整体替换UI线程的可观察数据。\",\"8\":\"- 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。\"}",
      "修改建议": "使用了'标注'和'装饰器'两个不同的词汇来描述同一概念。",
      "更改后示例": "当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的装饰器[\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。",
      "触发条件": "同一技术概念在相邻表述中使用了不同术语（如\"标注\"和\"装饰器\"），且存在明确的官方命名规范（如装饰器作为ArkUI正式术语）。 \n\n识别模式：当文本中同一技术元素出现两个及以上不同称谓（如术语与近义词/非官方表述混用），且上下文明确指向同一实体时触发。需通过术语库比对确认存在应统一的技术专有名词。"
    },
    {
      "defect_id": 440828,
      "sentence": "makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。",
      "reference_sentence": "无",
      "line_num": 6,
      "context": "{\"1\":\"# ArkUI数据更新场景\",\"2\":\"\",\"3\":\"当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。\",\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。\",\"7\":\"- 从子线程获取数据，然后整体替换UI线程的可观察数据。\",\"8\":\"- 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。\",\"9\":\"- 将数据从UI主线程传递回子线程时，只传递不可观察的数据。makeObserved的返回值不能直接传给子线程。\",\"10\":\"\",\"11\":\"```ts\"}",
      "修改建议": "使用了'触发'和'刷新'两个不同的词汇来描述同一概念。",
      "更改后示例": "makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI更新。",
      "触发条件": "同一上下文或相邻句子中重复提及同一功能/行为时，出现术语不统一（如\"刷新\"与\"更新\"交替使用）。 \n\n识别模式：\n1. 在相邻句子或同一段落中，检测描述同一操作/效果的关键动词是否出现不一致\n2. 通过词向量相似度分析，确认\"刷新/更新\"等近义词是否指向同一技术概念\n3. 结合技术文档上下文，验证是否要求严格术语统一（如UI更新在ArkUI框架中的固定表述）"
    },
    {
      "defect_id": 441427,
      "sentence": "3. 路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"1. 启动方式：选中当前需要预览的ets页面，单击右边侧边栏Previewer按钮，即可启动页面预览。\",\"16\":\"\",\"17\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"18\":\"\",\"19\":\"3. 路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。\",\"20\":\"\",\"21\":\"在使用页面预览的基础上，提供了极速预览和inspector双向预览两大特性，接下来针对两大特性进行详细说明。\",\"22\":\"\",\"23\":\"### 极速预览\",\"24\":\"\"}",
      "修改建议": "混用了“页面”和“界面”",
      "更改后示例": "3. 路由能力：支持通过路由能力，进行界面切换，查看其它界面预览效果。",
      "触发条件": "同一文档或相邻上下文中，同一技术概念存在多个不同术语表述（如\"页面\"与\"界面\"混用），且上下文存在明确统一术语的参照依据（如参考句中的\"界面布局\"定义或问题上下文中的\"页面预览\"高频使用）。"
    },
    {
      "defect_id": 443443,
      "sentence": "2. 封装一个瀑布流数据源，用于瀑布流组件加载数据。",
      "reference_sentence": "2. 封装一个瀑布流数据源，用于瀑布流组件加载数据。",
      "line_num": 36,
      "context": "{\"31\":\"      taskpool.execute(task);\",\"32\":\"    }\",\"33\":\"    ```\",\"34\":\"    <!-- @[query_database_return_main_thread](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ApplicationMultithreadingDevelopment/PracticalCases/entry/src/main/ets/managers/Mock.ets) -->\",\"35\":\"\",\"36\":\"2. 封装一个瀑布流数据源，用于瀑布流组件加载数据。\",\"37\":\"\",\"38\":\"    ```ts\",\"39\":\"    // WaterFlowDataSource.ets\",\"40\":\"\",\"41\":\"    // 实现IDataSource接口的对象，用于瀑布流组件加载数据\"}",
      "修改建议": "用词不一致，'瀑布流'应改为'瀑布流组件'",
      "更改后示例": "2. 封装一个瀑布流组件数据源，用于瀑布流组件加载数据。",
      "触发条件": "同一句子或相邻上下文中出现同一概念的不同术语表达（如\"瀑布流\"与\"瀑布流组件\"），且存在前后修饰成分差异（如前者无修饰词而后者带\"组件\"限定词）时触发。"
    },
    {
      "defect_id": 441428,
      "sentence": "1.选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"支持ets文件与预览器的双向预览。使用时，单击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。\",\"43\":\"\",\"44\":\"开启开启双向预览功能后，支持代码编辑器、UI界面和组件树之间的联动：\",\"45\":\"\",\"46\":\"1.选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。\",\"47\":\"\",\"48\":\"2. 选中布局文件中的代码块，UI界面将高亮显示，组件树上的组件节点将呈现被选中的状态。\",\"49\":\"\",\"50\":\"3. 选中组件树中的组件，对应的代码块和UI界面将高亮显示。\",\"51\":\"\"}",
      "修改建议": "混用了“界面”和“页面”",
      "更改后示例": "1. 选中预览器界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。",
      "触发条件": "当同一文档或邻近上下文中出现同一概念存在多个术语变体（如\"UI界面\"与\"页面\"混用），且存在明确的参考标准（如参考句中已确立\"界面\"为统一术语）时触发。\n\n识别模式：\n1. 通过邻近段落检测术语冲突（如问题句的\"UI界面\"与上下文第42行的\"预览器界面\"不一致）\n2. 匹配预定义术语对照表（根据参考句建立的\"界面布局/页面预览\"语义区分，识别出组件场景应统一使用\"界面\"）\n3. 定位冗余修饰词（识别\"UI界面\"中\"UI\"与\"界面\"存在语义重复，需与上下文保持最小化表达）"
    },
    {
      "defect_id": 441141,
      "sentence": "1. 在入口main函数所在的UI主线程中创建ArkTS运行环境，并发起一个C++子线程创建Sendable对象，保存到result中，然后将result引用的Sendable对象序列化到全局序列化数据serializationData中。",
      "reference_sentence": "UI主线程发起调用。",
      "line_num": 255,
      "context": "{\"250\":\"```\",\"251\":\"<!-- @[main_thread_init_call](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ApplicationMultithreadingDevelopment/NativeInterthreadShared/entry/src/main/ets/pages/Index.ets) -->\",\"252\":\"\",\"253\":\"整个过程主要包括的逻辑实现为：\",\"254\":\"\",\"255\":\"1. 在入口main函数所在的UI主线程中创建ArkTS运行环境，并发起一个C++子线程创建Sendable对象，保存到result中，然后将result引用的Sendable对象序列化到全局序列化数据serializationData中。\",\"256\":\"\",\"257\":\"2. 当这些流程完成后，发起另外一个C++子线程，并在这个新的线程中创建ArkTS运行环境。然后再通过反序列化接口从serializationData中反序列化出UI主线程创建的Sendable对象，并保存到result中，从而实现了Sendable对象的跨C++线程传递。反序列化完成后，需要销毁反序列化数据避免内存泄露。这时UI主线程和子线程都同时持有这个Sendable共享对象，即可通过Node-API进行对象操作，比如读写或者传递到ArkTS层等。\",\"258\":\"\",\"259\":\"   > **说明：**\",\"260\":\"   >\"}",
      "修改建议": "混用了“UI主线程”和“入口main函数所在的UI主线程”描述同一事物，容易造成混淆。",
      "更改后示例": "1. 在UI主线程中创建ArkTS运行环境，并发起一个C++子线程创建Sendable对象，保存到result中，然后将result引用的Sendable对象序列化到全局序列化数据serializationData中。",
      "触发条件": "同一术语在相邻上下文或同一段落中存在冗余修饰（如“入口main函数所在的UI主线程”与“UI主线程”）或不同表述形式时触发。\n\n识别模式：\n1. 检测同一语义概念是否出现不同长度的修饰词（如全称/简称）\n2. 验证相邻句子/段落中是否存在对同一实体的差异化描述（如问题句中的长修饰与参考句的简洁表达冲突）\n3. 检查技术文档中是否已存在标准术语（如参考句确立的\"UI主线程\"应作为基准表述）"
    },
    {
      "defect_id": 443442,
      "sentence": "此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。",
      "reference_sentence": "此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。",
      "line_num": 3,
      "context": "{\"1\":\"# ArkUI瀑布流渲染场景\",\"2\":\"\",\"3\":\"此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。UI线程查询数据库数据，并将数据渲染到瀑布流组件，数据过大时会导致UI线程长时间等待，影响用户体验。因此，我们可以将数据查询操作放到子线程中，并通过TaskPool的接口返回数据给UI线程。\",\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- 模拟子线程[读取数据库数据](batch-database-operations-guide.md)并返回给UI线程。\",\"7\":\"- UI线程感知到数据更新，将子线程返回的数据渲染到瀑布流组件。\",\"8\":\"\"}",
      "修改建议": "用词不一致，'瀑布流'应改为'瀑布流组件'",
      "更改后示例": "此处提供使用任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)提升[WaterFlow瀑布流组件](../reference/apis-arkui/arkui-ts/ts-container-waterflow.md)渲染性能的开发指导。",
      "触发条件": "当链接文本中的组件名称与上下文中的正式命名存在修饰词缺失（如缺少\"组件\"等类型词），且同一上下文中存在完整命名形式时触发。  \n\n识别模式：  \n1. 检查方括号链接中的显示文本是否与上下文组件命名存在词形差异  \n2. 验证同一段落/章节是否已使用包含类型词的完整命名（如\"瀑布流组件\"）  \n3. 对比链接文本与完整命名是否仅差类型修饰词（如\"组件\"）且语义等价  \n4. 确认修饰词缺失可能造成术语不统一（如单独使用\"瀑布流\"可能指布局方式而非具体组件）"
    },
    {
      "defect_id": 441956,
      "sentence": "由于处理过程是个频繁耗时任务，如果相机采集过快，就丢弃之前的采集数据，缓存最新的一帧数据处理。",
      "reference_sentence": "无",
      "line_num": 4,
      "context": "{\"1\":\"# TaskPool指定任务并发度场景\",\"2\":\"\",\"3\":\"此处提供使用TaskPool创建[异步队列](../reference/apis-arkts/js-apis-taskpool.md#asyncrunner18)的开发指导，以相机预览流采集数据处理的功能为例。\",\"4\":\"由于处理过程是个频繁耗时任务，如果相机采集过快，就丢弃之前的采集数据，缓存最新的一帧数据处理。\",\"5\":\"\",\"6\":\"1. 导入需要用到的模块。\",\"7\":\"\",\"8\":\"   ```ts\",\"9\":\"   // Index.ets\"}",
      "修改建议": "‘丢弃’与‘缓存’用词不一致，建议统一为‘丢弃’。",
      "更改后示例": "由于处理过程是个频繁耗时任务，如果相机采集过快，就丢弃之前的采集数据，保留最新的一帧数据处理。",
      "触发条件": "同一句子或相邻上下文中存在语义相关但用词不一致的动词（如相反/互补动作），且未保持逻辑对应关系时触发。\n\n识别模式：\n1. 定位逻辑关联词对（如\"丢弃-保留\"等对立动作）\n2. 检测是否使用非对称词汇组合（如\"丢弃-缓存\"）\n3. 验证是否存在语义冲突或表达歧义（如\"丢弃数据\"后\"缓存数据\"产生矛盾）"
    },
    {
      "defect_id": 444423,
      "sentence": "是否启用循环模式。<br/>当isLoop的值为undefined时，默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。",
      "reference_sentence": "是否启用循环模式。<br/>默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。",
      "line_num": 267,
      "context": "{\"262\":\"\",\"263\":\"**参数：**\",\"264\":\"\",\"265\":\"| 参数名 | 类型    | 必填 | 说明                                                         |\",\"266\":\"| ------ | ------- | ---- | ------------------------------------------------------------ |\",\"267\":\"| isLoop  | [Optional](ts-universal-attributes-custom-property.md#optional12)\\\\<boolean> | 是   | 是否启用循环模式。<br/>当isLoop的值为undefined时，默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。 |\",\"268\":\"\",\"269\":\"### dateTimeOptions<sup>12+</sup>\",\"270\":\"\",\"271\":\"dateTimeOptions(value: DateTimeOptions)\",\"272\":\"\"}",
      "修改建议": "前后描述不一致，前文没有提到isLoop的值为undefined时的默认值",
      "更改后示例": "是否启用循环模式。<br/>默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。",
      "触发条件": "当默认值描述同时存在条件性语句（如\"当参数为undefined时\"）和直接声明形式，且前文未明确参数可选性时触发；或当参数类型已明确为可选类型（如Optional<boolean>）时仍添加冗余的条件性默认值说明时触发。\n\n识别模式：\n1. 检测参数类型声明是否包含可选标识（如Optional<T>）\n2. 匹配\"当...时，默认值\"的条件句式结构\n3. 验证前文是否已明确参数可选性/默认值应用条件\n4. 检查是否存在语义重复（参数可选性隐含undefined情况）\n5. 对比默认值声明形式是否统一（应保持纯声明式\"默认值：X\"）"
    },
    {
      "defect_id": 444482,
      "sentence": "设置为true后，其是否生效取决于系统的硬件支持情况。",
      "reference_sentence": "设置是否支持触控反馈。",
      "line_num": 313,
      "context": "{\"308\":\"\",\"309\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"310\":\"\",\"311\":\"| 参数名 | 类型                                          | 必填  | 说明                                                                                  |\",\"312\":\"| ------ | --------------------------------------------- |-----|-------------------------------------------------------------------------------------|\",\"313\":\"| enable  | boolean | 是   | 是否支持触控反馈。<br/>默认值：true<br/>true表示开启触控反馈，false表示不开启触控反馈。<br/>设置为true后，其是否生效取决于系统的硬件支持情况。 |\",\"314\":\"\",\"315\":\"### enableHapticFeedback<sup>18+</sup>\",\"316\":\"\",\"317\":\"enableHapticFeedback(enable: Optional\\\\<boolean>)\",\"318\":\"\"}",
      "修改建议": "句式不一致，前文使用了祈使句，后文应保持一致。",
      "更改后示例": "设置为true后，其是否生效取决于系统硬件支持情况。",
      "触发条件": "同一参数说明或相邻上下文中存在句式结构不一致（如祈使句与陈述句混用）或冗余助词（如不必要的“的”）。识别模式为检查技术文档中相近位置的同类描述是否保持名词短语结构统一性（如“系统硬件支持情况”vs“系统的硬件支持情况”）。"
    },
    {
      "defect_id": 441431,
      "sentence": "4. 在预览界面，可以通过组件的属性面板修改可修改的属性或样式。预览界面的修改会自动同步到代码编辑器中，并实时刷新UI界面。同样地，代码编辑器中的源码修改也会实时刷新UI界面，并更新组件树信息及组件属性。",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，可以查看UI效果，方便开发者随时调整界面布局。预览支持页面预览和组件预览,下图中左侧图标![ide_previewer_002](figures/ide_previewer_002.png)为页面预览，右侧图标![ide_previewer_003](figures/ide_previewer_003.png)为组件预览。",
      "line_num": 52,
      "context": "{\"47\":\"\",\"48\":\"2. 选中布局文件中的代码块，UI界面将高亮显示，组件树上的组件节点将呈现被选中的状态。\",\"49\":\"\",\"50\":\"3. 选中组件树中的组件，对应的代码块和UI界面将高亮显示。\",\"51\":\"\",\"52\":\"4. 在预览界面，可以通过组件的属性面板修改可修改的属性或样式。预览界面的修改会自动同步到代码编辑器中，并实时刷新UI界面。同样地，代码编辑器中的源码修改也会实时刷新UI界面，并更新组件树信息及组件属性。\",\"53\":\"\",\"54\":\"效果如下：\",\"55\":\"![ide_previewer_002](figures/ide_previewer_002.gif)\",\"56\":\"\",\"57\":\"## 组件预览\"}",
      "修改建议": "混用了“界面”和“页面”",
      "更改后示例": "4. 在预览界面，可以通过组件的属性面板修改可修改的属性或样式。预览界面的修改会自动同步到代码编辑器中，并实时刷新界面。同样地，代码编辑器中的源码修改也会实时刷新界面，并更新组件树信息及组件属性。",
      "触发条件": "同一文档中同一概念存在多个术语变体（如\"界面\"与\"页面\"混用），且上下文存在明确统一的术语标准（如参考句使用\"界面\"指代UI元素，用\"页面\"特指预览类型）。\n\n识别模式：\n1. 检测相邻段落/句子中相同语义单元使用不同名词（如\"UI界面\"与\"界面\"交替出现）\n2. 匹配参考内容中的术语映射关系（如问题句的\"页面\"与参考句\"页面预览\"存在语义冲突）\n3. 验证上下文术语链一致性（如问题上下文48/50行均使用\"UI界面\"，而修复后统一降级为\"界面\"）"
    },
    {
      "defect_id": 443011,
      "sentence": "// 页面消失恢复系统服务菜单",
      "reference_sentence": "// 页面消失时恢复系统服务菜单项",
      "line_num": 285,
      "context": "{\"280\":\"      // 禁用搜索和翻译菜单项\",\"281\":\"      TextMenuController.disableMenuItems([TextMenuItemId.SEARCH, TextMenuItemId.TRANSLATE])\",\"282\":\"    }\",\"283\":\"  \",\"284\":\"    aboutToDisappear(): void {\",\"285\":\"      // 页面消失恢复系统服务菜单\",\"286\":\"      TextMenuController.disableMenuItems([])\",\"287\":\"    }\",\"288\":\"  \",\"289\":\"    build() {\",\"290\":\"      Row() {\"}",
      "修改建议": "混用了`恢复系统服务菜单`和`恢复系统服务菜单项`，描述不一致。",
      "更改后示例": "// 页面消失时恢复系统服务菜单项",
      "触发条件": "同一上下文或相邻代码位置中存在对同一概念使用不同术语描述的情况（如\"菜单\"与\"菜单项\"混用），且存在已确立的标准表达形式（如参考句子中的规范用法）。\n\n识别模式：\n1. 相邻注释/代码中检测到相同语义概念的关键术语差异（如\"菜单\"与\"菜单项\"）\n2. 在相同功能上下文中发现动词短语结构不一致（如\"恢复系统服务菜单\" vs \"禁用...菜单项\"）\n3. 存在明确的标准表达参照（如其他代码位置已统一使用带\"项\"的完整表述）"
    },
    {
      "defect_id": 444396,
      "sentence": "| value  | boolean | 是   | 是否启用循环模式。<br/>默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。 |",
      "reference_sentence": "| 参数名 | 类型    | 必填 | 说明                                                         |",
      "line_num": 251,
      "context": "{\"246\":\"\",\"247\":\"**参数：**\",\"248\":\"\",\"249\":\"| 参数名 | 类型    | 必填 | 说明                                                         |\",\"250\":\"| ------ | ------- | ---- | ------------------------------------------------------------ |\",\"251\":\"| value  | boolean | 是   | 是否启用循环模式。<br/>默认值：true<br/>true表示启用循环模式，false表示不启用循环模式。 |\",\"252\":\"\",\"253\":\"### loop<sup>18+</sup>\",\"254\":\"\",\"255\":\"loop(isLoop: Optional\\\\<boolean>)\",\"256\":\"\"}",
      "修改建议": "默认值描述前后不一致，前文使用了'默认值'，后文使用了'true'和'false'的具体描述",
      "更改后示例": "| value  | boolean | 是   | 是否启用循环模式。<br/>默认值：true<br/>启用循环模式表示true，不启用循环模式表示false。 |",
      "触发条件": "当默认值描述与布尔值解释存在结构倒置（\"值→状态\"与\"状态→值\"混合表述），且同一参数说明段内出现两种不同表达模式时触发。\n\n识别模式：\n1. 检测到\"默认值：X\"的声明式描述\n2. 后续存在\"X表示状态A，Y表示状态B\"的解释结构\n3. 两种表述存在语义方向冲突（默认值描述为值→状态，解释语句应为状态→值）\n4. 同一参数说明字段内同时存在这两种矛盾表述模式"
    },
    {
      "defect_id": 446978,
      "sentence": "1. 创建SendableLruCache实例对象，并根据业务需求预设最大容量。",
      "reference_sentence": "1. 创建SendableLruCache实例，并根据业务需求预设最大容量。",
      "line_num": 10,
      "context": "{\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 使用SendableLruCache实例对象时需加锁，避免多线程同时操作导致数据不一致。\",\"8\":\"> 存放到SendableLruCache实例中的对象应为Sendable对象。\",\"9\":\"\",\"10\":\"1. 创建SendableLruCache实例对象，并根据业务需求预设最大容量。<br/>\",\"11\":\"   此例设置SendableLruCache实例的最大容量为4，用SendableClass类来管理，并导出SendableClass类实例对象。\",\"12\":\"\",\"13\":\"   ```ts\",\"14\":\"   // LruCache.ets\",\"15\":\"\"}",
      "修改建议": "使用了'实例对象'和'实例'两个不同的术语描述同一事物。",
      "更改后示例": "1. 创建SendableLruCache实例，并根据业务需求预设最大容量。",
      "触发条件": "同一文档中针对同一技术概念出现两种及以上不同术语表述（如\"实例\"与\"实例对象\"），且在相邻段落或关联语句中重复出现时触发。\n\n识别模式：\n1. 检测相邻3-5个段落内是否存在同一核心名词的修饰词增减（如\"实例\"与\"实例对象\"）\n2. 验证不同表述是否指向同一技术实体（通过上下文语义分析确认指代对象一致性）"
    },
    {
      "defect_id": 446979,
      "sentence": "2. 在Index.ets页面同目录下创建4个图书页面，每个页面显示相应的图书信息，并将每个页面的路径注册到`src/main/resources/base/profile/main_pages.json`文件中。",
      "reference_sentence": "2. 在Index.ets页面同目录下创建4个图书页面，每个页面显示相应的图书信息，并将每个页面的路径注册到`main_pages.json`文件中。",
      "line_num": 58,
      "context": "{\"53\":\"   }\",\"54\":\"\",\"55\":\"   export let lruCache = new SendableClass();\",\"56\":\"   ```\",\"57\":\"\",\"58\":\"2. 在Index.ets页面同目录下创建4个图书页面，每个页面显示相应的图书信息，并将每个页面的路径注册到`src/main/resources/base/profile/main_pages.json`文件中。\",\"59\":\"\",\"60\":\"   ```ts\",\"61\":\"   // Book1.ets\",\"62\":\"\",\"63\":\"   @Entry\"}",
      "修改建议": "使用了'`src/main/resources/base/profile/main_pages.json`'和'`main_pages.json`'两个不同的路径描述同一文件。",
      "更改后示例": "2. 在Index.ets页面同目录下创建4个图书页面，每个页面显示相应的图书信息，并将每个页面的路径注册到`main_pages.json`文件中。",
      "触发条件": "当文档中同一文件路径或专业术语存在两种及以上不同表述形式（如完整路径与简写路径混用），且出现在同一上下文或相邻段落时触发。\n\n识别模式：检查技术文档中重复出现的同一实体（如配置文件路径）是否保持完全一致的表述方式，特别关注带有路径符号`的专有名词是否在全文范围内保持统一，排除冗余前缀（如`src/main/resources/base/profile/`）与核心文件名（如`main_pages.json`）的混合使用情况。"
    },
    {
      "defect_id": 447524,
      "sentence": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。",
      "reference_sentence": "1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'侧边'和'侧边样式'，应保持术语一致",
      "更改后示例": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。",
      "触发条件": "当同一技术术语在文档不同位置存在冗余修饰词差异（如\"侧边\"与\"侧边样式\"），且该术语在参考规范中具有明确定义时触发。\n\n识别模式：\n1. 检测技术参数值（如SheetType.SIDE）与其解释性描述是否严格对应\n2. 对比上下文同类参数描述（如\"底部/居中/跟手\"均未附加\"样式\"），发现异常冗余修饰词\n3. 验证术语是否与API定义或参考条款（如枚举说明）存在形式差异"
    },
    {
      "defect_id": 447438,
      "sentence": "单击右侧侧边栏的Previewer按钮，启动页面预览。",
      "reference_sentence": "DevEco Studio为开发者提供了UI预览功能，方便查看UI效果并随时调整界面布局。",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"## 页面预览\",\"14\":\"\",\"15\":\"ArkTS应用/元服务均支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现，可以查看当前UI界面效果。\",\"16\":\"\",\"17\":\"1. 选中需要预览的ets页面，单击右侧侧边栏的Previewer按钮，启动页面预览。\",\"18\":\"\",\"19\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"20\":\"\",\"21\":\"3. 路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。\",\"22\":\"\"}",
      "修改建议": "混用了'单击'和'点击'，应保持用词一致。",
      "更改后示例": "点击右侧侧边栏的Previewer按钮，启动页面预览。",
      "触发条件": "同一操作描述在相邻段落或功能说明中混用\"单击/点击\"等近义动词，且上下文存在明确统一用词倾向（如参考句使用\"查看\"而非\"查看/浏览\"混用）。通过NLP动词抽取+同义词库比对，检测到相同操作场景存在非必要动词替换时触发。"
    },
    {
      "defect_id": 447525,
      "sentence": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。",
      "reference_sentence": "1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'全屏'和'全屏样式'，应保持术语一致",
      "更改后示例": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER。",
      "触发条件": "当同一术语在相邻或相关说明中出现不一致的修饰词（如\"全屏\"与\"全屏样式\"混用），且参考句子中存在明确的标准化表述时触发。\n\n识别模式：\n1. 核心术语重复出现但存在修饰差异（如基础术语\"全屏\" vs 扩展术语\"全屏样式\"）\n2. 上下文存在明确的标准用法（参考句连续3次使用\"全屏\"未加\"样式\"修饰）\n3. 术语差异出现在同一功能说明场景中（均描述SheetType类型设置）"
    },
    {
      "defect_id": 444586,
      "sentence": "在12小时制时，设置上午和下午的标识是否会根据小时数自动切换。<br/>默认值：false<br/>false表示不开启自动切换，true表示开启自动切换。<br/>设置为true时，仅在loop参数同时为true时生效。",
      "reference_sentence": "在设置12小时制时，上午和下午的标识会根据小时数自动切换。",
      "line_num": 352,
      "context": "{\"347\":\"\",\"348\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"349\":\"\",\"350\":\"| 参数名 | 类型                                          | 必填  | 说明                                                                                  |\",\"351\":\"| ------ | --------------------------------------------- |-----|-------------------------------------------------------------------------------------|\",\"352\":\"| enable  | boolean | 是   | 在12小时制时，设置上午和下午的标识是否会根据小时数自动切换。<br/>默认值：false<br/>false表示不开启自动切换，true表示开启自动切换。<br/>设置为true时，仅在loop参数同时为true时生效。|\",\"353\":\"\",\"354\":\"### digitalCrownSensitivity<sup>18+</sup>\",\"355\":\"digitalCrownSensitivity(sensitivity: Optional\\\\<CrownSensitivity>)\",\"356\":\"\",\"357\":\"设置表冠灵敏度。\"}",
      "修改建议": "前后描述不一致，前文使用了'设置12小时制时'，后文使用了'在12小时制时'，且前文使用了'会'，后文使用了'是否'。",
      "更改后示例": "在设置12小时制时，设置上午和下午的标识是否会根据小时数自动切换。<br/>默认值：false<br/>false表示不开启自动切换，true表示开启自动切换。<br/>设置为true时，仅在loop参数同时为true时生效。",
      "触发条件": "当同一上下文中的相邻语句存在关键术语不一致（如\"设置12小时制时\"与\"在12小时制时\"）或动词结构矛盾（如肯定式\"会\"与疑问式\"是否\"）时触发。\n\n识别模式：\n1. 对比参数说明与默认值/生效条件描述中的动词短语一致性（如\"设置...会\" vs \"是否\"）\n2. 检查同一功能描述中关键介词短语的重复性（如\"设置12小时制时\"应保持完整动词结构）\n3. 发现同一段落内存在相同语义但不同表达方式（如动词短语与名词短语混用）"
    },
    {
      "defect_id": 447562,
      "sentence": "1. 半模态全屏样式显示页面效果为，没有边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。",
      "reference_sentence": "无",
      "line_num": 161,
      "context": "{\"156\":\"| placementOnTarget | 只支持气泡样式。|\",\"157\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"158\":\"\",\"159\":\"**半模态全屏弹窗样式：**\",\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为，没有边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。\",\"162\":\"\",\"163\":\"2. 半模态不支持设置安全区，全屏样式默认在安全区内布局。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，默认效果不显示蒙层。\",\"166\":\"\"}",
      "修改建议": "描述不一致，建议统一使用'无'或'不支持'来描述不支持的功能",
      "更改后示例": "1. 半模态全屏样式显示页面效果为，不支持边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。",
      "触发条件": "当文档中描述系统/功能不支持某特性时，若存在\"没有\"等否定性描述词汇，且上下文存在\"不支持\"或\"无\"等统一否定表达模式时触发。\n\n识别模式：\n1. 检测否定性描述词汇(如：没有、不包含、缺少)\n2. 对比上下文否定表达方式(如：| showInSubWindow | 不支持... |)\n3. 当否定用词与上下文既定模式不一致时，建议统一为\"不支持\"或\"无\""
    },
    {
      "defect_id": 447563,
      "sentence": "3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，默认效果不显示蒙层。",
      "reference_sentence": "无",
      "line_num": 165,
      "context": "{\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为，没有边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。\",\"162\":\"\",\"163\":\"2. 半模态不支持设置安全区，全屏样式默认在安全区内布局。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，默认效果不显示蒙层。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效[ModalTransition](ts-types.md#modaltransition10)转场方式 ，默认值为ModalTransition.DEFAULT，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 无多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。\",\"170\":\"\"}",
      "修改建议": "描述不一致，建议统一使用'不支持'来描述不支持的功能",
      "更改后示例": "3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，默认效果不显示蒙层，不支持自定义蒙层。",
      "触发条件": "当文档中多个否定性描述存在不同否定表达方式时，或当前句子否定功能未使用与其他条目一致的否定词汇（如\"不支持\"）时触发。\n\n识别模式：\n1. 上下文存在同类否定描述（如\"不支持设置安全区\"、\"不支持自定义转场\"）\n2. 当前句子使用非统一否定词（如\"不显示\"）描述功能限制\n3. 语义涉及功能限制/缺失但未采用既定否定表达范式"
    },
    {
      "defect_id": 447474,
      "sentence": "由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，因此无法在子线程中取消任务。从 API version 18 开始，Task新增了[任务ID](../reference/apis-arkts/js-apis-taskpool.md#属性)属性，支持通过任务ID在子线程中取消任务。",
      "reference_sentence": "由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，因此无法在子线程中取消任务。从 API version 18 开始，Task新增了[任务ID](../reference/apis-arkts/js-apis-taskpool.md#属性)属性，支持通过任务ID在子线程中取消任务。",
      "line_num": 3,
      "context": "{\"1\":\"# 多线程取消TaskPool任务场景\",\"2\":\"\",\"3\":\"由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，因此无法在子线程中取消任务。从 API version 18 开始，Task新增了[任务ID](../reference/apis-arkts/js-apis-taskpool.md#属性)属性，支持通过任务ID在子线程中取消任务。以下示例提供多线程取消已提交给TaskPool中的任务开发指导，开发者可将已创建任务的任务ID存储在[Sendable对象](./arkts-sendable.md)中，需要取消任务时，通过Sendable对象来多线程取消任务。\",\"4\":\"\",\"5\":\"1. 定义一个Sendable类，在类属性中存储任务ID。\",\"6\":\"\",\"7\":\"   ```ts\",\"8\":\"   // Mock.ets\"}",
      "修改建议": "前后描述中使用了不同的词汇来描述同一事物：'任务ID'和'任务ID'。",
      "更改后示例": "由于任务池[TaskPool](../reference/apis-arkts/js-apis-taskpool.md)的任务对象[Task](../reference/apis-arkts/js-apis-taskpool.md#task)不支持跨线程传递，因此无法在子线程中取消任务。从 API version 18 开始，Task新增了任务ID属性，支持通过任务ID在子线程中取消任务。",
      "触发条件": "同一技术术语在相邻句子或同一上下文中多次出现时，存在格式差异（如带/不带超链接标记、中英文混杂）或命名不一致（如\"任务ID\"与\"任务标识符\"混用）。 \n\n识别模式：\n1. 术语重复检测：在3句范围内出现重复技术名词\n2. 格式差异识别：检测方括号[]、超链接标记、中文/英文括号等格式特征是否统一\n3. 命名一致性验证：通过词干匹配（如\"ID/标识符\"）识别同义词混用\n4. 上下文锚定：确保技术术语与当前段落主题（如TaskPool API）强相关"
    },
    {
      "defect_id": 447708,
      "sentence": "从API版本12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 12开始，底部弹窗横屏时该属性设置生效。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口宽度下支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp ≤ 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中。<br/>3. 宽度 ≥ 840vp：底部、居中、跟手、侧边、全屏。默认跟手。<br/>4. 从API版本20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。<br/>5. 从API版本20开始，preferType支持设置为SheetType.CONTENT_COVER。<br/>**原子化服务API：** 从API版本12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'API版本'和'API version'，应保持一致。",
      "更改后示例": "从API version 12开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一文档中同一术语存在中文与英文混用形式（如\"API版本\"和\"API version\"），且上下文已存在明确统一表达形式时。\n\n识别模式：\n1. 术语匹配：检测包含\"API\"的复合词（如\"API版本\"/\"API version\"）是否存在中文与英文拼写混合\n2. 上下文验证：检查问题位置前后3-5行内是否存在同一术语的标准表达形式（如参考句子中的\"API version\"）\n3. 版本号关联：当术语与版本号直接连接时（如\"API版本12\" vs \"API version 12\"），需额外检查空格一致性"
    },
    {
      "defect_id": 449957,
      "sentence": "本文档提供了场景类型互动卡片的开发指导，包括卡片非激活态和激活态UI界面开发、卡片配置文件开发。",
      "reference_sentence": "本文档提供了场景动效类型互动卡片的开发指导，包括卡片非激活态和激活态UI界面开发、卡片配置文件开发。",
      "line_num": 3,
      "context": "{\"1\":\"# 场景动效类型互动卡片开发指导\",\"2\":\"\",\"3\":\"本文档提供了场景类型互动卡片的开发指导，包括卡片非激活态和激活态UI界面开发、卡片配置文件开发。\",\"4\":\"\",\"5\":\"## 接口说明\",\"6\":\"\",\"7\":\"场景动效类型互动卡片关键接口如下表所示。\",\"8\":\"\"}",
      "修改建议": "混用了“场景类型”和“场景动效类型”概念",
      "更改后示例": "本文档提供了场景动效类型互动卡片的开发指导，包括卡片非激活态和激活态UI界面开发、卡片配置文件开发。",
      "触发条件": "当同一概念在邻近上下文中存在两种及以上不同术语表达（如\"场景类型\"与\"场景动效类型\"），且文档标题/核心段落已明确使用规范术语时触发。\n\n识别模式：\n1. 定位核心术语的首次定义位置（如标题\"场景动效类型\"）\n2. 检测后续文本中是否出现缩略/简化的非规范表达（如正文中的\"场景类型\"）\n3. 验证术语差异是否导致概念歧义（如\"类型\"范围明显大于\"动效类型\"）\n4. 检查术语使用间隔距离（本例在标题与第一段间即出现偏差）"
    },
    {
      "defect_id": 447684,
      "sentence": "使用napi时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者napi接口使用不当导致。",
      "reference_sentence": "使用napi时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者napi接口使用不当导致。",
      "line_num": 20,
      "context": "{\"15\":\"#03 pc 002eac5d /system/lib/platformsdk/libark_jsruntime.so\",\"16\":\"#04 pc 00428d0f /system/lib/platformsdk/libark_jsruntime.so\",\"17\":\"```\",\"18\":\"\",\"19\":\"- 定位问题：  \",\"20\":\"使用napi时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者napi接口使用不当导致。   \",\"21\":\"- 以下定位问题的思路，可作为参考：   \",\"22\":\"1. 排查是否存在多线程安全问题（概率较大）   \",\"23\":\"IDE中提供了相关开关，开启开关后，重新编译打包并运行，看看崩溃栈是不是符合下面这个文档的描述，如果是，那就是在使用napi时，存在多线程安全问题。   \",\"24\":\"[常见多线程安全问题](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section19357830121120)  \",\"25\":\"IDE开关：   \"}",
      "修改建议": "混用了`napi`和`NAPI`概念",
      "更改后示例": "使用NAPI时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者NAPI接口使用不当导致。",
      "触发条件": "同一术语在相邻上下文或同一段落中出现大小写不一致（如napi与NAPI混用），且涉及技术接口/专有名词时。"
    },
    {
      "defect_id": 447685,
      "sentence": "2. 使用napi接口时入参非法导致。",
      "reference_sentence": "使用napi时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者napi接口使用不当导致。",
      "line_num": 27,
      "context": "{\"22\":\"1. 排查是否存在多线程安全问题（概率较大）   \",\"23\":\"IDE中提供了相关开关，开启开关后，重新编译打包并运行，看看崩溃栈是不是符合下面这个文档的描述，如果是，那就是在使用napi时，存在多线程安全问题。   \",\"24\":\"[常见多线程安全问题](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section19357830121120)  \",\"25\":\"IDE开关：   \",\"26\":\"![IDE多线程开关](figures/zh_cn_image_20-25-06-40-15-09.png)   \",\"27\":\"2. 使用napi接口时入参非法导致。   \",\"28\":\"- 这种情况一般是崩溃栈上的so会很浅，so调用了某个具体的napi接口，比如调用了napi_call_function之类的接口，然后napi又调到了libark_jsruntime的so，然后直接崩溃在libark_jsruntime里面。  \",\"29\":\"示例栈结构如下。  \",\"30\":\"```sh\",\"31\":\"#01 /system/lib/platformsdk/libark_jsruntime.so\",\"32\":\"#02 /system/lib/platformsdk/libark_jsruntime.so\"}",
      "修改建议": "混用了`napi`和`NAPI`概念",
      "更改后示例": "2. 使用NAPI接口时入参非法导致。",
      "触发条件": "同一术语在文档中出现大小写不一致（如napi/NAPI混用），且存在已确立的标准拼写形式（如参考句中的小写形式napi）时触发。识别模式需检测术语变体（全大写/全小写/驼峰）是否与上下文高频形式或官方规范冲突。"
    },
    {
      "defect_id": 447564,
      "sentence": "5. 无多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。",
      "reference_sentence": "无",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，默认效果不显示蒙层。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效[ModalTransition](ts-types.md#modaltransition10)转场方式 ，默认值为ModalTransition.DEFAULT，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 无多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。\",\"170\":\"\",\"171\":\"6. 不支持上下滑动，仅支持侧滑返回。\",\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认全屏。\",\"174\":\"\"}",
      "修改建议": "描述不一致，建议统一使用'不支持'来描述不支持的功能",
      "更改后示例": "5. 不支持多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。",
      "触发条件": "同一文档或相邻条目中对同类功能的否定描述使用了不一致的否定词（如\"无\"与\"不支持\"），且上下文中存在统一的否定表达模式（如其他条目均使用\"不支持\"）。"
    },
    {
      "defect_id": 449974,
      "sentence": "互动卡片可以通过调用[formProvided.getFormRect](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formprovidergetformrect20)接口获取卡片尺寸和在窗口内的位置信息。",
      "reference_sentence": "互动卡片通过调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发动效",
      "line_num": 273,
      "context": "{\"268\":\"\",\"269\":\"### 互动卡片动效实现\",\"270\":\"\",\"271\":\"1. 触发互动卡片动效\",\"272\":\"\",\"273\":\"互动卡片通过调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口触发动效，调用时需要明确：（1）动效申请范围。（2）动效持续时间。（3）是否使用系统提供的默认切换动效。具体可参考[formInfo.OverflowInfo](../reference/apis-form-kit/js-apis-app-form-formInfo.md#overflowinfo20)。其中，互动卡片可以通过调用[formProvided.getFormRect](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formprovidergetformrect20)接口获取卡片尺寸和在窗口内的位置信息。卡片提供方以此计算动效申请范围，单位为vp。计算规则具体请参考[互动卡片请求参数约束](arkts-ui-liveform-sceneanimation-overview.md#请求参数约束)。\",\"274\":\"\",\"275\":\"```ts\",\"276\":\"// entry/src/main/ets/entryformability/EntryFormAbility.ets\",\"277\":\"import {\",\"278\":\"  formInfo,\"}",
      "修改建议": "混用了“formProvided”和“formProvider”",
      "更改后示例": "互动卡片可以通过调用[formProvider.getFormRect](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formprovidergetformrect20)接口获取卡片尺寸和在窗口内的位置信息。",
      "触发条件": "当同一接口/变量名称在文档中出现拼写不一致（如大小写错误、多余/缺失字符），且与上下文或官方API定义冲突时触发。具体表现为代码标识符存在同源异形词（如formProvided与formProvider）且存在正确用法的上下文参照（如参考句子中的formProvider.requestOverflow）。"
    },
    {
      "defect_id": 449869,
      "sentence": "针对系统应用，场景动效类型互动卡片提供了**手势禁用配置**和**卡片长时激活**两个扩展能力。",
      "reference_sentence": "针对系统应用，场景动效类型互动卡片提供了**手势禁用配置**和**卡片长时激活**两个扩展能力。",
      "line_num": 3,
      "context": "{\"1\":\"# 场景动效类型互动卡片开发指导（系统应用）\",\"2\":\"\",\"3\":\"场景动效类型互动卡片基础开发指导，可以参考文档[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。针对系统应用，场景动效类型互动卡片提供了**手势禁用配置**和**卡片长时激活**两个扩展能力。\",\"4\":\"\",\"5\":\"## 接口说明\",\"6\":\"\",\"7\":\"场景动效类型互动卡片开发关键接口如下表所示。\",\"8\":\"\"}",
      "修改建议": "“长时激活”与“长时间保持激活态”表意不一致，建议统一。",
      "更改后示例": "针对系统应用，场景动效类型互动卡片提供了**手势禁用配置**和**卡片长时间保持激活态**两个扩展能力。",
      "触发条件": "当同一段落或相邻上下文中存在同一概念的简写与完整表达混用（如\"长时激活\"与\"长时间保持激活态\"），且该文档已存在明确的规范术语时触发。\n\n识别模式：\n1. 检测相邻并列项中术语结构差异（如\"手势禁用配置\"为动宾结构，\"长时激活\"为偏正结构）\n2. 匹配文档历史术语库（如上下文已出现\"长时间保持激活态\"规范表达）\n3. 对比并列项之间的语法对称性（如两个扩展能力应保持相同语法结构）"
    },
    {
      "defect_id": 447565,
      "sentence": "9. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。",
      "reference_sentence": "无",
      "line_num": 179,
      "context": "{\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，如showInSubWindow = true、mode = SheetMode.EMBEDDED。侧边弹窗的层级同SheetMode.OVERLAY，只支持在当前UIContext内顶层显示，在所有页面之上。和弹窗类组件显示在一个层级。\",\"176\":\"\",\"177\":\"9. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。\",\"178\":\"\",\"179\":\"\",\"180\":\"**全屏弹窗样式不支持的接口**\",\"181\":\"| 名称             | 说明              |\",\"182\":\"| --------------- |  --------------- |\",\"183\":\"| height          | 高度只支持全屏高度。 |\",\"184\":\"| width           | 宽度只支持全屏宽度。 |\"}",
      "修改建议": "描述不一致，建议统一使用'不支持'来描述不支持的功能",
      "更改后示例": "9. 不支持避让软键盘能力，需自定义避让。也不支持悬停态避让能力。",
      "触发条件": "当同一文档相邻条目或同类功能描述中，存在否定词（如\"无\"与\"不支持\"）混用，且上下文已建立统一否定表达模式（如\"不支持\"）时触发。具体表现为列表项/表格项间使用不同否定动词描述同类功能限制。"
    },
    {
      "defect_id": 447707,
      "sentence": "从API版本20开始，preferType支持设置为SheetType.CONTENT_COVER。",
      "reference_sentence": "从API version 12开始，底部弹窗横屏时该属性设置生效。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口宽度下支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp ≤ 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中。<br/>3. 宽度 ≥ 840vp：底部、居中、跟手、侧边、全屏。默认跟手。<br/>4. 从API版本20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。<br/>5. 从API版本20开始，preferType支持设置为SheetType.CONTENT_COVER。<br/>**原子化服务API：** 从API版本12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'API版本'和'API version'，应保持一致。",
      "更改后示例": "从API version 20开始，preferType支持设置为SheetType.CONTENT_COVER。",
      "触发条件": "同一术语在文档中出现中英文混用形式（如\"API版本\"和\"API version\"），且相邻上下文存在该术语的标准表达形式（如\"API version 12\"）。  \n\n识别模式：  \n1. 术语中存在可替换的中英文关键字段（如\"版本\"/\"version\"）  \n2. 在相同文档段落或相邻条目中存在该术语的标准表达形式（通过上下文对比可识别）  \n3. 混用形式与标准形式出现在同一功能模块说明中（如都用于描述API版本迭代特性）"
    },
    {
      "defect_id": 449871,
      "sentence": "此外，卡片通过formProvider.activateSceneAnimation进入激活态后，卡片动效渲染区域和卡片自身渲染区域等大，且不支持调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口请求动效。",
      "reference_sentence": "此外，卡片通过formProvider.activateSceneAnimation进入激活态后，卡片动效渲染区域和卡片自身渲染区域等大，且不支持调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口请求动效。",
      "line_num": 44,
      "context": "{\"39\":\"```\",\"40\":\"\",\"41\":\"## 卡片长时激活\",\"42\":\"\",\"43\":\"针对系统应用，支持卡片提供方通过接口控制卡片状态切换，不对激活态保持时间做强限制，即卡片可以长时间保持激活态。卡片进入/退出激活态操作由[formProvider.activateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#activatesceneanimation20)和[formProvider.deactivateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#deactivatesceneanimation20)接口控制。\",\"44\":\"此外，卡片通过formProvider.activateSceneAnimation进入激活态后，卡片动效渲染区域和卡片自身渲染区域等大，且不支持调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口请求动效。\",\"45\":\"\",\"46\":\"### 开发流程\",\"47\":\"1. 导入模块\",\"48\":\"\",\"49\":\"```ts\"}",
      "修改建议": "“进入激活态”与“切换到激活态”表意不一致，建议统一。",
      "更改后示例": "此外，卡片通过formProvider.activateSceneAnimation切换到激活态后，卡片动效渲染区域和卡片自身渲染区域等大，且不支持调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口请求动效。",
      "触发条件": "同一文档中对同一操作或状态变化存在不一致的动词描述（如“进入”与“切换到”），且上下文存在相同语义的参考表达（如“切换到激活态”在接口描述中已高频出现）。"
    },
    {
      "defect_id": 447688,
      "sentence": "上面提到，c++线程都是抛任务到ts线程，进而执行ts方法。关于线程安全，可参考napi线程安全文档，相关能力是有的。",
      "reference_sentence": "使用napi时如果出现高概率闪退，崩溃栈顶在系统库libark_jsruntime.so，一般是开发者napi接口使用不当导致。",
      "line_num": 48,
      "context": "{\"43\":\"- 现有个场景，ArkTS中有个类方法，对这个方法创建了napi_ref引用，现想在c++线程池中并发的调用ArkTS方法，请问  \",\"44\":\"1. 可以在c++创建的线程池中调用napi_ref缓存的ArkTS类方法吗？  \",\"45\":\"只能在c++线程中将ArkTS任务抛回ts线程，这时候并不是同步调用，而是一个抛任务的动作。  \",\"46\":\"需要注意的是，这个ArkTS方法真正的执行动作只能在ts线程中完成，即，只能方法运行在创建的ts线程上。  \",\"47\":\"2. 回调到ArkTS要怎么确保线程安全？  \",\"48\":\"上面提到，c++线程都是抛任务到ts线程，进而执行ts方法。关于线程安全，可参考napi线程安全文档，相关能力是有的。  \",\"49\":\"[使用Node-API接口进行线程安全开发](use-napi-thread-safety.md)  \",\"50\":\"另外，开发过程中也可以打开多线程安全检查开关，这个开关可以拦截多线程安全问题。  \",\"51\":\"[方舟多线程检测](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section75786272088)   \",\"52\":\"\",\"53\":\"## napi_value内容产生变化\"}",
      "修改建议": "混用了`napi`和`NAPI`概念",
      "更改后示例": "上面提到，c++线程都是抛任务到ts线程，进而执行ts方法。关于线程安全，可参考NAPI线程安全文档，相关能力是有的。",
      "触发条件": "当同一术语在文档中出现大小写不一致（如\"napi\"和\"NAPI\"）或不同拼写形式时触发，且该术语在上下文中有明确的统一格式参照（如参考句或文档标准用法）。\n\n识别模式：\n1. 检测相邻段落/同一文档中同一术语的拼写变体（如全大写、驼峰式、全小写）\n2. 匹配预定义术语标准表（如技术名词\"NAPI\"应保持全大写）\n3. 上下文存在同源术语的规范用法（如参考句中的\"napi\"与问题句中的\"NAPI\"形成冲突）"
    },
    {
      "defect_id": 449024,
      "sentence": "ArkTS卡片分为动态卡片、静态卡片、互动卡片三种类型。",
      "reference_sentence": "## ArkTS卡片类型ArkTS卡片分为动态卡片、静态卡片、互动卡片三种类型。",
      "line_num": 37,
      "context": "{\"32\":\"![WidgetRender](figures/WidgetRender.png)\",\"33\":\"\",\"34\":\"与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widgets.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一应用提供方的渲染实例运行在同一个ArkTS虚拟机运行环境中，不同应用提供方的渲染实例运行在不同的ArkTS虚拟机运行环境中，通过ArkTS虚拟机运行环境隔离不同应用提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同应用提供方的卡片globalThis对象是同一个，不同应用提供方的卡片globalThis对象是不同的。\",\"35\":\"\",\"36\":\"## ArkTS卡片类型\",\"37\":\"ArkTS卡片分为动态卡片、静态卡片、互动卡片三种类型。\",\"38\":\"\",\"39\":\"与动态卡片相比，静态卡片整体的运行框架和渲染流程和动态卡片是一致的。主要区别在于，卡片渲染服务将卡片内容渲染完毕后，卡片使用方会使用最后一帧渲染的数据作为静态图片显示，其次卡片渲染服务中的卡片实例会释放该卡片的所有运行资源以节省内存。因此频繁的刷新会导致静态卡片运行时资源不断的创建和销毁，增加卡片功耗。<br/>\",\"40\":\"\",\"41\":\"| 卡片类型 | 支持的能力 | 适用场景 | 优缺点 |\",\"42\":\"| ------- | ------ | ------- | ------- | \"}",
      "修改建议": "重复使用了“动态卡片”和“静态卡片”概念",
      "更改后示例": "ArkTS卡片分为动态卡片、静态卡片和互动卡片三种类型。",
      "触发条件": "当并列项列表中存在三个及以上元素且最后两个元素之间缺少连接词（如\"和\"）时触发，或同一文档中相同语义结构存在不一致连接词用法时触发。\n\n识别模式：\n1. 检测到\"顿号分隔+重复量词\"结构（如\"类型A、类型B、类型C三种类型\"）\n2. 验证末尾两个元素间是否存在缺失的连接词（对比文档中其他同类表达）\n3. 检查是否违反中文并列结构规范（三个及以上元素时，最后两个元素间应使用连接词）"
    },
    {
      "defect_id": 447706,
      "sentence": "从API版本20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。",
      "reference_sentence": "从API version 12开始，底部弹窗横屏时该属性设置生效。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口宽度下支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp ≤ 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中。<br/>3. 宽度 ≥ 840vp：底部、居中、跟手、侧边、全屏。默认跟手。<br/>4. 从API版本20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。<br/>5. 从API版本20开始，preferType支持设置为SheetType.CONTENT_COVER。<br/>**原子化服务API：** 从API版本12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'API版本'和'API version'，应保持一致。",
      "更改后示例": "从API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。",
      "触发条件": "同一技术术语在相邻段落或相同属性说明中存在中英文混用（如\"API版本\"与\"API version\"），且上下文已有明确统一写法（如参考句中的\"API version\"标准形式）。  \n\n识别模式：  \n1. 术语形态比对：检测同一术语是否出现\"中文词+英文词\"的混合变体（如\"版本\"与\"version\"）  \n2. 上下文关联性：当问题术语出现在已建立标准写法的技术属性说明区域（如表格参数说明、版本变更记录）时触发  \n3. 邻近重复验证：在相同段落或相邻行内存在该术语的标准写法（如问题上下文第54行多次使用\"API version\"）"
    },
    {
      "defect_id": 452841,
      "sentence": "formId | string | 是 | 卡片id标识。",
      "reference_sentence": "formId | string | 是 | 卡片标识。",
      "line_num": 613,
      "context": "{\"608\":\"\",\"609\":\"**参数：**\",\"610\":\"\",\"611\":\"| 参数名 | 类型                                                                 | 必填 | 说明        |\",\"612\":\"| ------ |--------------------------------------------------------------------| ---- |-----------|\",\"613\":\"| formId | string                                                             | 是 | 卡片id标识。|\",\"614\":\"| overflowInfo | [formInfo.OverflowInfo](js-apis-app-form-formInfo.md#overflowinfo20) | 是 | 动效请求参数信息。|\",\"615\":\"\",\"616\":\"**返回值：**\",\"617\":\"\",\"618\":\"| 类型 | 说明 |\"}",
      "修改建议": "混用了“卡片id标识”和“卡片标识”",
      "更改后示例": "formId | string | 是 | 卡片标识。",
      "触发条件": "同一参数说明中存在冗余修饰词（如\"id\"）导致术语不一致，或同一文档中相同概念使用不同表述（如\"卡片标识\"与\"卡片id标识\"）时触发。"
    },
    {
      "defect_id": 455093,
      "sentence": "开发者可通过调用tee_query_mspc_measure_report()查询MSPC度量报告。",
      "reference_sentence": "开发者可通过调用tee_query_ta_measure_report()查询TA调度报告。",
      "line_num": 121,
      "context": "{\"116\":\"\",\"117\":\"查询TA度量报告：\",\"118\":\"开发者可通过调用tee_query_ta_measure_report()查询TA调度报告。\",\"119\":\"\",\"120\":\"查询MSPC度量报告：\",\"121\":\"开发者可通过调用tee_query_mspc_measure_report()查询MSPC度量报告。\",\"122\":\"\",\"123\":\"## 多线程支持\",\"124\":\"\",\"125\":\"### 标准Posix接口\",\"126\":\"| 序号 | 接口名称                    |\"}",
      "修改建议": "句式不一致，建议统一使用祈使句描述动作",
      "更改后示例": "开发者可通过调用tee_query_mspc_measure_report()来查询MSPC度量报告",
      "触发条件": "当同一文档中存在多个描述\"通过调用函数实现操作\"的句式，且存在\"动词直连\"(查询)和\"连词引导\"(来查询)两种不同表达形式时。\n\n识别模式：\n1. 检测\"调用...查询\"结构是否在邻近段落存在平行句式\n2. 对比上下文参考句(如118行)的语法结构，识别是否缺少连接词\"来\"\n3. 验证目标句与参考句是否属于同一功能描述类别(查询报告)"
    },
    {
      "defect_id": 456374,
      "sentence": "与transition同时设置时，此属性不生效。",
      "reference_sentence": "半模态、全模态的公共配置接口。",
      "line_num": 106,
      "context": "{\"101\":\"半模态、全模态的公共配置接口。\",\"102\":\"\",\"103\":\"| 名称            | 类型                                       | 必填 | 说明                     |\",\"104\":\"| --------------- | ------------------------------------------ | ---- | ------------------------ |\",\"105\":\"| backgroundColor | [ResourceColor](ts-types.md#resourcecolor) | 否   | 半模态页面的背板颜色。<br />默认值：Color.White。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"106\":\"| modalTransition | [ModalTransition](ts-types.md#modaltransition10) | 否 | 半模态全屏样式页面、全屏模态的系统转场方式。<br/>默认值：ModalTransition.DEFAULT。<br/>**说明：**<br />与transition同时设置时，此属性不生效。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"107\":\"| onWillAppear<sup>12+</sup>        | () => void                                 | 否   | 半模态页面显示（动画开始前）回调函数。**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"108\":\"| onAppear        | () => void                                 | 否   | 半模态页面显示（动画结束后）回调函数。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"109\":\"| onWillDisappear<sup>12+</sup>     | () => void                                 | 否   | 半模态页面回退（动画开始前）回调函数。<br />**说明：**<br />不允许在onWillDisappear函数中修改状态变量，可能会导致组件行为不稳定。**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"110\":\"| onDisappear     | () => void                                 | 否   | 半模态页面回退（动画结束后）回调函数。<br />**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"111\":\"\"}",
      "修改建议": "句式不一致，应统一使用祈使句",
      "更改后示例": "不要与transition同时设置，否则此属性不生效。",
      "触发条件": "当同一文档章节中存在混合使用陈述句和祈使句的说明项时，且当前句子使用陈述句式而相邻/同类说明项均采用\"不要...否则...\"的祈使结构时。\n\n识别模式：\n1. 检测说明性文本中\"当...时\"的陈述句式\n2. 比对上下文其他说明项是否采用\"不要...否则...\"的祈使结构\n3. 验证当前句式与参考句式（如公共配置接口的祈使表达）存在表达方式冲突"
    },
    {
      "defect_id": 458125,
      "sentence": "如果需要跨包获取资源管理对象，可以参考[资源访问](../quick-start/resource-categories-and-access.md#资源访问)。",
      "reference_sentence": "通过Context属性可以获取当前应用、模块、UIAbility或ExtensionAbility的基本信息（例如资源管理对象、应用程序信息等）",
      "line_num": 255,
      "context": "{\"250\":\"\",\"251\":\"继承自[Context](../reference/apis-ability-kit/js-apis-inner-application-context.md)的不同类型Context，默认会继承父类的方法和属性，还会拥有自己独立的方法与属性。\",\"252\":\"\",\"253\":\"通过Context属性可以获取当前应用、模块、UIAbility或ExtensionAbility的基本信息（例如资源管理对象、应用程序信息等），下面以UIAbility的信息获取为例：\",\"254\":\"\",\"255\":\"如果需要跨包获取资源管理对象，可以参考[资源访问](../quick-start/resource-categories-and-access.md#资源访问)。\",\"256\":\"\",\"257\":\"  ```ts\",\"258\":\"  import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\",\"259\":\"\",\"260\":\"  export default class EntryAbility extends UIAbility {\"}",
      "修改建议": "术语不一致，'资源管理对象'应改为'资源对象'",
      "更改后示例": "如果需要跨包获取资源对象，可以参考[资源访问](../quick-start/resource-categories-and-access.md#资源访问)。",
      "触发条件": "当同一文档或关联上下文中出现对同一技术概念使用不同术语表述（如\"资源管理对象\"与\"资源对象\"），且存在已明确定义的规范术语时触发。识别模式需检测术语在参考段落（如问题上下文第253行）与当前语句中的命名差异，并验证文档其他位置（如被引用链接）是否统一使用规范术语。"
    },
    {
      "defect_id": 455313,
      "sentence": "关于dlopen时传入client库路径的/tafs/dcm_verifier_sdk.so的说明：1. /tafs/是服务client库文件在TEE中的挂载路径；2. dcm_verifier_sdk是manifest文件中gpd.ta.service_name",
      "reference_sentence": "关于dlopen时传入client库路径的/tafs/dcm_verifier_sdk.so的说明：1. /tafs/是服务client库文件在TEE中的挂载路径；2. dcm_verifier_sdk是manifest文件中gpd.ta.service_name",
      "line_num": 814,
      "context": "{\"809\":\"    dlclose(dcm_sdk_lib_handle); \",\"810\":\"    dcm_sdk_lib_handle = NULL; \",\"811\":\"    return ret; \",\"812\":\"}\",\"813\":\"```\",\"814\":\"关于dlopen时传入client库路径的/tafs/dcm_verifier_sdk.so的说明：1. /tafs/是服务client库文件在TEE中的挂载路径；2. dcm_verifier_sdk是manifest文件中gpd.ta.service_name\"}",
      "修改建议": "混用了'服务'和'server'，建议统一使用'server'",
      "更改后示例": "关于dlopen时传入client库路径的/tafs/dcm_verifier_sdk.so的说明：1. /tafs/是server client库文件在TEE中的挂载路径；2. dcm_verifier_sdk是manifest文件中gpd.ta.service_name",
      "触发条件": "同一术语在相邻上下文或同一段落中同时存在中文直译（如\"服务\"）和英文原生词（如\"server\"）两种表达形式，且指向同一技术概念时触发。\n\n识别模式：\n1. 术语对检测：通过建立中英技术术语映射表（如\"服务↔server\"），扫描相邻3-5句内是否存在同一概念的不同语言表达\n2. 语义一致性验证：结合上下文判断不同表达是否指向同一技术实体（如通过前后动词搭配、技术组件关系等验证\"服务client库\"与\"server client库\"的指代一致性）\n3. 位置特征识别：特别关注编号说明项（如\"1. xxx；2. xxx\"）、并列结构等易发区域，确保列表项间的术语使用保持统一"
    },
    {
      "defect_id": 455151,
      "sentence": "1.\t在TA中创建的thread不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。",
      "reference_sentence": "1.\t在TA中创建的thread不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。",
      "line_num": 172,
      "context": "{\"167\":\"| return| int            | -        | `EINVAL`：操作失败，a == NULL<br>`0`：成功                   |\",\"168\":\"\",\"169\":\"注：在TA调用pthread_create创建线程，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行跑创建的线程，用法见1.3.8.2 TA多线程限制。\",\"170\":\"\",\"171\":\"### TA多线程限制\",\"172\":\"1.\\t在TA中创建的thread不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。\",\"173\":\"2.\\t创建线程时，只有添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，才会为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang的现象。代码如下：\",\"174\":\"```c\",\"175\":\"#define TEESMP_THREAD_ATTR_CA_INHERIT      (-1U)  \",\"176\":\"#define TEESMP_THREAD_ATTR_TASK_ID_INHERIT (-1U)                                                          \",\"177\":\"#define TEESMP_THREAD_ATTR_HAS_SHADOW      0x1  \"}",
      "修改建议": "用词不一致，'thread'和'thread'混用。",
      "更改后示例": "1.\t在TA中创建的线程不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。",
      "触发条件": "同一术语在相邻上下文或同一文档中存在中英文混用（如\"thread\"与\"线程\"交替出现），或与参考句子的术语形式（如\"pthread_create创建线程\"中的中文表述）不一致时触发。\n\n识别模式：\n1. 术语形态差异检测：当英文专业词汇（如thread）与其中文翻译（线程）在相邻段落/同一章节混合出现\n2. 上下文对齐检查：比对问题句与参考句（如169行的\"创建线程\"）的术语使用一致性\n3. 标点符号辅助判断：英文术语未加引号或未按技术文档规范使用统一命名（如POSIX标准函数名应保持全小写）"
    },
    {
      "defect_id": 455312,
      "sentence": "服务中自己维护白名单控制TA的访问权限",
      "reference_sentence": "服务中自己维护白名单控制TA的访问权限",
      "line_num": 592,
      "context": "{\"587\":\"\",\"588\":\"−\\t获取ta uuid权限\",\"589\":\"仍在代码中静态配置，AC_DEFINE_SUBJ_BEG(get_uuid)中增加task的uuid。\",\"590\":\"\",\"591\":\"−\\tTA权限控制\",\"592\":\"服务中自己维护白名单控制TA的访问权限\",\"593\":\"\",\"594\":\"3.\\t独立服务client端开发\",\"595\":\"```c\",\"596\":\"#include \\\"securec.h\\\" \",\"597\":\"#include \\\"string.h\\\" \"}",
      "修改建议": "混用了'服务'和'server'，建议统一使用'server'",
      "更改后示例": "server中自己维护白名单控制TA的访问权限",
      "触发条件": "同一技术术语在文档中存在中英文混用（如\"服务\"和\"server\"），且上下文明确指向同一实体概念时触发。\n\n识别模式：\n1. 检测相邻段落/条目中出现同一概念的中英文双版本术语（如\"服务\"与\"server\"）\n2. 验证术语指代对象是否相同（通过上下文技术特征匹配，如本例中\"维护白名单控制TA\"的技术场景特征）\n3. 确认存在更优统一表达形式（如技术文档优先使用英文术语\"server\"）"
    },
    {
      "defect_id": 455152,
      "sentence": "2.\t创建线程时，只有添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，才会为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang的现象。代码如下：",
      "reference_sentence": "2.\t创建线程时，只有添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，才会为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang的现象。代码如下：",
      "line_num": 173,
      "context": "{\"168\":\"\",\"169\":\"注：在TA调用pthread_create创建线程，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行跑创建的线程，用法见1.3.8.2 TA多线程限制。\",\"170\":\"\",\"171\":\"### TA多线程限制\",\"172\":\"1.\\t在TA中创建的thread不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。\",\"173\":\"2.\\t创建线程时，只有添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，才会为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang的现象。代码如下：\",\"174\":\"```c\",\"175\":\"#define TEESMP_THREAD_ATTR_CA_INHERIT      (-1U)  \",\"176\":\"#define TEESMP_THREAD_ATTR_TASK_ID_INHERIT (-1U)                                                          \",\"177\":\"#define TEESMP_THREAD_ATTR_HAS_SHADOW      0x1  \",\"178\":\"pthread_attr_init(&attr);  \"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "2.\t创建线程时，添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang现象。代码如下：",
      "触发条件": "当操作步骤描述混合使用条件句（如\"只有...才会...\"）与祈使句，且上下文同类说明均采用祈使句时触发。\n\n识别模式：\n1. 检测到技术文档中的操作步骤包含条件关联词（如\"只有...才会\"）和结果性描述（如\"否则...\"）\n2. 对比上下文发现相邻条目（如编号列表中的其他条款）均使用祈使句式（动词开头结构）\n3. 存在句式冲突：当前条目使用\"条件-结果\"结构，而上下文条目使用\"动作-效果\"结构"
    },
    {
      "defect_id": 456426,
      "sentence": "2. 半模态不支持设置安全区，全屏样式默认布局在安全区内。",
      "reference_sentence": "无",
      "line_num": 163,
      "context": "{\"158\":\"\",\"159\":\"**半模态全屏弹窗样式：**\",\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为，不支持边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。\",\"162\":\"\",\"163\":\"2. 半模态不支持设置安全区，全屏样式默认布局在安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，因此默认没有蒙层效果。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效 [ModalTransition](ts-types.md#modaltransition10) 转场方式 ，默认值为 ModalTransition.DEFAULT，不支持自定义转场。\",\"168\":\"\"}",
      "修改建议": "描述不清晰，建议明确说明半模态全屏样式不支持设置安全区，但默认布局在安全区内",
      "更改后示例": "2. 半模态全屏样式不支持设置安全区，但默认布局在安全区内。",
      "触发条件": "当同一主题下的并列分句存在主语不一致（前分句使用大类术语，后分句使用具体样式术语），或关键功能描述未使用上下文已明确定义的标准术语（如\"半模态全屏样式\"）时触发。\n\n识别模式：\n1. 检查并列分句主语是否保持术语统一（如前半句主语应为\"半模态全屏样式\"而非大类\"半模态\"）\n2. 核对该段落已定义的标准术语（通过前文\"**半模态全屏弹窗样式：**\"标题及后续编号条目使用的完整术语）\n3. 检测是否存在因术语简写导致的功能主体模糊（如将\"半模态全屏样式\"简化为\"半模态\"造成技术概念混淆）"
    },
    {
      "defect_id": 459786,
      "sentence": "可参考线程安全函数来实现，napi_call_threadsafe_function可保证异步任务执行顺序, 需要注意的是这些异步任务会抛回到ArkTS线程顺序执行，如果是抛回到主线程，异步任务的执行时间过长可能导致应用冻结退出，所以不建议将长耗时的任务通过线程安全函数抛回到主线程执行。",
      "reference_sentence": "## 在大量需要调用ArkTS方法进行通信的场景如何保证异步任务的有序性",
      "line_num": 36,
      "context": "{\"31\":\"\",\"32\":\"## 在大量需要调用ArkTS方法进行通信的场景如何保证异步任务的有序性\",\"33\":\"\",\"34\":\"- 具体问题：在大量需要通过c++调用ArkTS方法进行通信的场景，如何保证异步任务的有序性？\",\"35\":\"- 参考方案：  \",\"36\":\"可参考线程安全函数来实现，napi_call_threadsafe_function可保证异步任务执行顺序, 需要注意的是这些异步任务会抛回到ArkTS线程顺序执行，如果是抛回到主线程，异步任务的执行时间过长可能导致应用冻结退出，所以不建议将长耗时的任务通过线程安全函数抛回到主线程执行。   \",\"37\":\"[使用Node-API接口进行线程安全开发](use-napi-thread-safety.md)\",\"38\":\"\",\"39\":\"此外，napi中常见的抛任务方法的差异如下：\",\"40\":\"\",\"41\":\"1. napi_async_work系列接口只能保证execute_cb在complete_cb之前执行，但无法保证不同async_work的时序。  \"}",
      "修改建议": "混用了`抛回`和`投递`，建议全文统一使用`投递`",
      "更改后示例": "可参考线程安全函数来实现，napi_call_threadsafe_function可保证异步任务执行顺序, 需要注意的是这些异步任务会投递到ArkTS线程顺序执行，如果是投递到主线程，异步任务的执行时间过长可能导致应用冻结退出，所以不建议将长耗时的任务通过线程安全函数投递到主线程执行。",
      "触发条件": "同一概念或操作在相邻句子或同一段落中使用了不一致的术语（如“抛回”与“投递”混用），且上下文存在需要保持专业术语统一性的场景。"
    },
    {
      "defect_id": 458254,
      "sentence": "通过合理使用不同级别的加密分区，可以有效提高应用数据的安全性。",
      "reference_sentence": "通过合理使用不同级别的加密分区，可以有效提升应用数据的安全性。",
      "line_num": 402,
      "context": "{\"397\":\"\",\"398\":\"### 获取和修改加密分区\",\"399\":\"\",\"400\":\"应用文件加密是一种保护数据安全的方法，可以使得文件在未经授权访问的情况下得到保护。在不同的场景下，应用需要不同程度的文件保护。\",\"401\":\"\",\"402\":\"在实际应用中，开发者需要根据不同场景的需求选择合适的加密分区，从而保护应用数据的安全。通过合理使用不同级别的加密分区，可以有效提高应用数据的安全性。关于不同分区的权限说明，详见[ContextConstant](../reference/apis-ability-kit/js-apis-app-ability-contextConstant.md)的[AreaMode](../reference/apis-ability-kit/js-apis-app-ability-contextConstant.md#areamode)。\",\"403\":\"\",\"404\":\"- EL1：对于私有文件，如闹铃、壁纸等，应用可以将这些文件放到设备级加密分区（EL1）中，以保证在用户输入密码前就可以被访问。\",\"405\":\"- EL2：对于更敏感的文件，如个人隐私信息等，应用可以将这些文件放到更高级别的加密分区（EL2）中，以保证更高的安全性。\",\"406\":\"- EL3：对于应用中的记录步数、文件下载、音乐播放，需要在锁屏时读写和创建新文件，放在（EL3）的加密分区比较合适。\",\"407\":\"- EL4：对于用户安全信息相关的文件，锁屏时不需要读写文件、也不能创建文件，放在（EL4）的加密分区更合适。\"}",
      "修改建议": "“提高”和“提升”用词不一致",
      "更改后示例": "通过合理使用不同级别的加密分区，可以有效提升应用数据的安全性。",
      "触发条件": "同一文档的相邻或相关段落中，存在表达相同语义但使用不同近义词（如“提高”与“提升”）的情况，且上下文存在明确统一用词标准时触发。\n\n识别模式：\n1. **语义重复检测**：识别相邻段落中表达相同动作/效果的动词（如安全增强动作）；\n2. **近义词对比**：通过词库匹配近义词组（如提高/提升、保护/保障）；\n3. **上下文锚定**：检查问题句所在段落是否已存在标准用词（如参考句中的\"提升\"）；\n4. **功能一致性验证**：确保术语与上下文技术描述逻辑连贯（如安全类文档倾向使用\"提升安全性\"而非\"提高安全性\"）。"
    },
    {
      "defect_id": 465025,
      "sentence": "Extension生命周期回调函数，划词SA在拉起划词扩展时调用，执行划词扩展初始化操作。",
      "reference_sentence": "Extension生命周期回调函数，划词SA在拉起划词扩展时调用，执行划词扩展初始化操作。",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"### onConnect\",\"25\":\"\",\"26\":\"onConnect(want: Want): rpc.RemoteObject\",\"27\":\"\",\"28\":\"Extension生命周期回调函数，划词SA在拉起划词扩展时调用，执行划词扩展初始化操作。\",\"29\":\"\",\"30\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"31\":\"\",\"32\":\"**参数：**\",\"33\":\"\"}",
      "修改建议": "术语 '划词SA' 应与上文保持一致，应使用 '划词服务' 而非 '划词SA'",
      "更改后示例": "Extension生命周期回调函数，划词服务在拉起划词扩展时调用，执行划词扩展初始化操作。",
      "触发条件": "当同一术语在文档中存在多个不一致的表达形式（如缩写与全称混用），且上下文已明确定义或使用统一术语时触发。"
    },
    {
      "defect_id": 462852,
      "sentence": "设置填充区域的颜色，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法，异常值按照默认值处理。与通用属性foregroundColor同时设置时，后设置的属性生效。",
      "reference_sentence": "设置填充区域的颜色，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法，异常值按照默认值处理。与通用属性foregroundColor同时设置时，后设置的属性生效。",
      "line_num": 89,
      "context": "{\"84\":\"\",\"85\":\"**参数：** \",\"86\":\"\",\"87\":\"| 参数名 | 类型                                       | 必填 | 说明                                   |\",\"88\":\"| ------ | ------------------------------------------ | ---- | -------------------------------------- |\",\"89\":\"| value  | [ResourceColor](ts-types.md#resourcecolor) | 是   | 填充区域颜色。<br/>默认值：Color.Black |\",\"90\":\"\",\"91\":\"### fillOpacity\",\"92\":\"\",\"93\":\"fillOpacity(value: number | string | Resource)\",\"94\":\"\"}",
      "修改建议": "前后句子中描述异常值处理的方式不一致，应统一为'异常值按照默认值处理'。",
      "更改后示例": "设置填充区域的颜色，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法。异常值按照默认值处理。与通用属性foregroundColor同时设置时，后设置的属性生效。",
      "触发条件": "当同一段落或相邻句子中出现对同一概念（如异常值处理）的重复描述，且表达方式存在用词/句式差异时触发；或当同一上下文存在冗余信息重复时触发。\n\n识别模式：\n1. **重复概念检测**：相邻句子/分句包含相同语义内容（如\"异常值按照默认值处理\"在问题句中被拆分描述）\n2. **表达差异识别**：通过比对句式结构（原句使用逗号连接复合句，修复后拆分为独立简单句）和术语一致性（如\"后设置的属性生效\"是否与上下文其他属性描述模式匹配）\n3. **冗余标记**：同一技术细节（如attributeModifier功能说明）在相邻位置重复出现时触发"
    },
    {
      "defect_id": 456428,
      "sentence": "5. 不支持多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。",
      "reference_sentence": "3. 底部弹窗样式可以在转场结束后向上滑动交互，但侧边弹窗样式不支持在转场结束后往左滑动交互，只支持往右滑动关闭。镜像场景则能力相反。",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，因此默认没有蒙层效果。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效 [ModalTransition](ts-types.md#modaltransition10) 转场方式 ，默认值为 ModalTransition.DEFAULT，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 不支持多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。\",\"170\":\"\",\"171\":\"6. 不支持上下滑动，仅支持侧滑。\",\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认为全屏。\",\"174\":\"\"}",
      "修改建议": "重复描述了不支持多挡位能力，建议合并或精简",
      "更改后示例": "5. 不支持多挡位能力，不支持detents、detentSelection和dragBar接口。",
      "触发条件": "同一项目符号内重复使用相同动词结构（如“不支持”），且存在可合并的同类项（如接口列表）时触发。"
    },
    {
      "defect_id": 459996,
      "sentence": "napi_call_threadsafe_function执行结果不符合预期",
      "reference_sentence": "napi_call_threadsafe_function执行顺序不符合预期",
      "line_num": 175,
      "context": "{\"170\":\"4. [napi_env禁止缓存的原因是什么](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-73)\",\"171\":\"\",\"172\":\"## napi_call_threadsafe_function执行顺序不符合预期\",\"173\":\"\",\"174\":\"- 问题描述：   \",\"175\":\"napi_call_threadsafe_function执行结果不符合预期  \",\"176\":\"原本期望的执行顺序是 a -> b -> c\",\"177\":\"posttask(a);  \",\"178\":\"posttask(b);  \",\"179\":\"posttask(c);  \",\"180\":\"但是实际的执行顺序是 b -> a -> c  \"}",
      "修改建议": "用词不一致，'执行结果'与'执行顺序'混用",
      "更改后示例": "napi_call_threadsafe_function执行顺序不符合预期",
      "触发条件": "同一技术概念在相邻句子或上下文中出现用词不一致（如\"执行结果\"与\"执行顺序\"混用），且上下文存在明确指向同一维度的描述（如执行顺序的具体示例）时触发。"
    },
    {
      "defect_id": 456425,
      "sentence": "1. 半模态全屏样式显示页面效果为，不支持边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。",
      "reference_sentence": "无",
      "line_num": 161,
      "context": "{\"156\":\"| placementOnTarget | 只支持气泡样式。|\",\"157\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"158\":\"\",\"159\":\"**半模态全屏弹窗样式：**\",\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为，不支持边框、阴影、标题栏、关闭按钮、圆角等内容的铺满全屏的页面。\",\"162\":\"\",\"163\":\"2. 半模态不支持设置安全区，全屏样式默认布局在安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是enableOutsideInteractive默认值为true，因此默认没有蒙层效果。\",\"166\":\"\"}",
      "修改建议": "描述不清晰，容易引起混淆，建议明确说明不支持的内容",
      "更改后示例": "1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。",
      "触发条件": "当句子中关键描述被标点或语序割裂导致主次信息混淆，或存在\"效果为，不支持...\"类矛盾结构时触发。\n\n识别模式：\n1. **结构断裂**：检测\"效果为/是\"等定义性短语后接逗号而非直接描述（如\"效果为，不支持...\"），导致核心信息未前置；\n2. **矛盾嵌套**：识别\"不支持...的铺满全屏页面\"类反向修饰结构，此类表达易使否定范围产生歧义；\n3. **信息堆砌**：当否定性说明与核心功能描述未通过句式分隔（如原句未用句号分隔核心功能与限制项）时触发。"
    },
    {
      "defect_id": 458259,
      "sentence": "每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增+1。当超过监听上限数量2^63-1时，会返回-1。",
      "reference_sentence": "每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增1。当超过监听上限数量2^63-1时，会返回-1。",
      "line_num": 532,
      "context": "{\"527\":\"\",\"528\":\"### 监听UIAbility生命周期变化\",\"529\":\"\",\"530\":\"开发者可以通过[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)监听UIAbility生命周期变化。当[UIAbility](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md)生命周期变化时，如UIAbility创建、切换至前台、切换至后台、销毁等情况，UIAbility会收到相应回调函数的通知，从而执行依赖UIAbility生命周期的方法，也可以统计指定页面停留时间和访问频率等信息。\",\"531\":\"\",\"532\":\"每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增+1。当超过监听上限数量2^63-1时，会返回-1。以[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)中的使用为例进行说明。\",\"533\":\"\",\"534\":\"```ts\",\"535\":\"import { AbilityConstant, AbilityLifecycleCallback, UIAbility, Want } from '@kit.AbilityKit';\",\"536\":\"import { hilog } from '@kit.PerformanceAnalysisKit';\",\"537\":\"import { window } from '@kit.ArkUI';\"}",
      "修改建议": "“自增+1”和“自增1”用词不一致",
      "更改后示例": "每次注册回调函数时，都会返回一个监听生命周期的ID，此ID会自增1。当超过监听上限数量2^63-1时，会返回-1。",
      "触发条件": "当同一段落或相邻句子中出现对同一数值增减行为的两种不同表达方式（如\"自增+1\"与\"自增1\"），且存在冗余符号（如\"+\"号）与简洁表达混合使用时。\n\n识别模式：\n1. 检测数值增减描述符（如\"自增/自减\"）后接的数值表达式是否包含冗余运算符（如\"+1\"中的+号）\n2. 对比上下文相同语义表达（如参考句中的\"自增1\"），发现同一技术参数存在两种不同表达形式\n3. 验证数值符号的语法必要性（如自增操作默认即为+1，+号属于冗余表达）"
    },
    {
      "defect_id": 455150,
      "sentence": "注：在TA调用pthread_create创建线程，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行跑创建的线程，用法见1.3.8.2 TA多线程限制。",
      "reference_sentence": "注：在TA调用pthread_create创建线程，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行跑创建的线程，用法见1.3.8.2 TA多线程限制。",
      "line_num": 169,
      "context": "{\"164\":\"| in    | int            | task_id  | 默认为 `TEESMP_THREAD_ATTR_TASK_ID_INHERIT`                 |\",\"165\":\"| in    | int            | shadow   | 默认为 `TEESMP_THREAD_ATTR_HAS_SHADOW`，可为该线程分配一个新核 |\",\"166\":\"| out   | pthread_attr_t*| a        | 线程属性                                                     |\",\"167\":\"| return| int            | -        | `EINVAL`：操作失败，a == NULL<br>`0`：成功                   |\",\"168\":\"\",\"169\":\"注：在TA调用pthread_create创建线程，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行跑创建的线程，用法见1.3.8.2 TA多线程限制。\",\"170\":\"\",\"171\":\"### TA多线程限制\",\"172\":\"1.\\t在TA中创建的thread不能使用所有的agent服务以及TEE_Wait。其中hm native和posix兼容的是可以使用的，但sleep例外（因为其内部是用TEE_wait实现的）。\",\"173\":\"2.\\t创建线程时，只有添加TEESMP_THREAD_ATTR_HAS_SHADOW属性，才会为本线程拉入一个新的核，提供新的计算能力，否则容易出现hang的现象。代码如下：\",\"174\":\"```c\"}",
      "修改建议": "句式不一致，建议使用祈使句。",
      "更改后示例": "在TA调用pthread_create创建线程时，建议调用pthread_attr_settee设置影子线程属性，让TEE拉入一个新的核，并行运行创建的线程。用法见1.3.8.2 TA多线程限制。",
      "触发条件": "文档注释中存在动词表述不一致（如\"跑\"与\"运行\"混用）或句式结构断裂（缺少时间状语引导词\"时\"、标点粘连），且上下文技术描述需保持术语统一性。  \n\n识别模式：  \n1. 动词匹配：检测非技术性动词（如口语化\"跑\"）与相邻技术术语（如\"调用\"\"设置\"）的冲突  \n2. 句式连贯性：验证条件状语从句是否完整（缺少\"时\"导致主从句逻辑断裂）  \n3. 标点规范：识别长句未通过句号分隔独立语义单元的现象（如操作建议与引用说明未拆分）"
    },
    {
      "defect_id": 458121,
      "sentence": "### 获取ExtensionAbilityContext（组件级的Context）",
      "reference_sentence": "### 获取基本信息",
      "line_num": 215,
      "context": "{\"210\":\"      }\",\"211\":\"    }\",\"212\":\"  }\",\"213\":\"  ```\",\"214\":\"\",\"215\":\"### 获取ExtensionAbilityContext（组件级的Context）\",\"216\":\"\",\"217\":\"获取特定场景[ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md)。以FormExtensionContext为例，表示卡片服务的上下文环境，继承自ExtensionContext，提供卡片服务相关的接口能力。\",\"218\":\"\",\"219\":\"```ts\",\"220\":\"import { FormExtensionAbility, formBindingData } from '@kit.FormKit';\"}",
      "修改建议": "标题格式不一致，建议统一使用同一格式",
      "更改后示例": "### 获取ExtensionAbilityContext (组件级的Context)",
      "触发条件": "标题中的标点符号（如括号）前后空格格式与上下文其他同级标题或既定规范不一致，例如括号前缺少统一约定的空格。  \n识别模式：检测标题内特殊符号（如`()`）的间距，并与上下文同类标题或参考范例进行格式比对，发现符号间距差异时触发修复。"
    },
    {
      "defect_id": 458258,
      "sentence": "当应用前后台切换时，可以收到相应回调函数的通知，从而执行一些依赖前后台的方法，或者进行应用切前后台频率等数据统计。",
      "reference_sentence": "当应用前后台切换时，可以收到相应回调函数的通知，从而执行一些依赖前后台的方法，或者进行应用前后台切换频率等数据统计。",
      "line_num": 496,
      "context": "{\"491\":\"}\",\"492\":\"```\",\"493\":\"\",\"494\":\"### 监听应用前后台变化\",\"495\":\"  \",\"496\":\"开发者可以使用[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)的相关能力，监听应用的前后台变化。当应用前后台切换时，可以收到相应回调函数的通知，从而执行一些依赖前后台的方法，或者进行应用切前后台频率等数据统计。\",\"497\":\"\",\"498\":\"以[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)中的使用为例进行说明。\",\"499\":\"\",\"500\":\"```ts\",\"501\":\"import { UIAbility, ApplicationStateChangeCallback } from '@kit.AbilityKit';\"}",
      "修改建议": "“切前后台”和“前后台切换”用词不一致",
      "更改后示例": "当应用前后台切换时，可以收到相应回调函数的通知，从而执行一些依赖前后台的方法，或者进行应用前后台切换频率等数据统计。",
      "触发条件": "同一概念在相邻或同一上下文中出现不一致的术语表达（如\"切前后台\"与\"前后台切换\"），且存在可替换的标准化表述时。"
    },
    {
      "defect_id": 459997,
      "sentence": "1. 是不是用的同一个napi_threadsafe_function，若使用不同实例，则无法保障与调用顺序一致；",
      "reference_sentence": "napi_call_threadsafe_function执行顺序不符合预期",
      "line_num": 183,
      "context": "{\"178\":\"posttask(b);  \",\"179\":\"posttask(c);  \",\"180\":\"但是实际的执行顺序是 b -> a -> c  \",\"181\":\"\",\"182\":\"- 排查方向：   \",\"183\":\"1. 是不是用的同一个napi_threadsafe_function，若使用不同实例，则无法保障与调用顺序一致；   \",\"184\":\"注：对于同一个napi_threadsafe_function来说，napi_call_threadsafe_function是保序的，接口内维护了一个队列，先调用就会先执行。   \",\"185\":\"注：不同实例是先创建，先执行，但是若使用不同实例，得保证对应关系。  \",\"186\":\"2. 是否能保证实际call的顺序是a -> b -> c；   \",\"187\":\"3. 使用了napi_call_threadsafe_function_with_priority，该接口是向主线程的事件循环中投递任务， 由于主线程存在不同优先级的队列， 不同的优先级的任务是无法保证时序的，同意优先级的任务，由于是在同一事件队列，可以保证时序。   \",\"188\":\"\"}",
      "修改建议": "用词不一致，'调用顺序'与'顺序'混用",
      "更改后示例": "1. 是否使用的是同一个napi_threadsafe_function，若使用不同实例，则无法保障执行顺序一致；",
      "触发条件": "同一技术文档中出现\"调用顺序\"与\"执行顺序\"等相似术语混用，且上下文存在明确参照标准（如参考句中的\"执行顺序\"）时。  \n\n识别模式：  \n1. 检测同一段落/相邻段落中关键术语的表述差异  \n2. 比对现有技术标准表述（如参考句中的\"napi_call_threadsafe_function执行顺序\"）  \n3. 当动词性短语（调用顺序）与名词性短语（执行顺序）指代同一技术概念时触发"
    },
    {
      "defect_id": 456429,
      "sentence": "9. 不支持避让软键盘能力，需自定义避让。也不支持悬停态避让能力。",
      "reference_sentence": "6. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。",
      "line_num": 177,
      "context": "{\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认为全屏。\",\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，如showInSubWindow = true、mode = SheetMode.EMBEDDED。全屏弹窗的层级同SheetMode.OVERLAY，只支持在当前UIContext内顶层显示，在所有页面之上。和弹窗类组件显示在一个层级。\",\"176\":\"\",\"177\":\"9. 不支持避让软键盘能力，需自定义避让。也不支持悬停态避让能力。\",\"178\":\"\",\"179\":\"\",\"180\":\"**全屏弹窗样式不支持的接口**\",\"181\":\"| 名称             | 说明              |\",\"182\":\"| --------------- |  --------------- |\"}",
      "修改建议": "重复描述了不支持避让软键盘和悬停态避让能力，建议合并或精简",
      "更改后示例": "9. 不支持避让软键盘和悬停态避让能力，需自定义避让。",
      "触发条件": "当同一段落中出现多个并列的否定描述（如\"不支持...也不支持...\"），且存在重复句式或语义重叠时；或当否定表达用词（如\"不支持\"/\"无\"）与上下文同类条目不一致时。"
    },
    {
      "defect_id": 459893,
      "sentence": "此外，亦可使用ArkTS数组作为数据载体，其具有良好的灵活性。",
      "reference_sentence": "比如通过napi_create_object，创建出一个ArkTS对象，用这个对象来承载返回的所有信息，number和string都可以通过napi_set_property/napi_set_named_property等属性设置的接口设置到这个对象上。native对象也可以通过napi_wrap接口和ArkTS对象进行绑定，后续在通过napi_unwrap取出来。",
      "line_num": 73,
      "context": "{\"68\":\"- 具体问题：如何在遵循N-API单一返回值约束的前提下，安全、高效地将多个返回值（包括结构化数据和指针信息）传递给ArkTS运行时环境，并确保数据类型的正确映射与内存管理的安全性？\",\"69\":\"- 参考实现：   \",\"70\":\"尽管napi_value接口仅支持单一返回值，但开发者可通过该返回值封装所需的全部信息。\",\"71\":\"\",\"72\":\"比如通过napi_create_object，创建出一个ArkTS对象，用这个对象来承载返回的所有信息，number和string都可以通过napi_set_property/napi_set_named_property等属性设置的接口设置到这个对象上。native对象也可以通过napi_wrap接口和ArkTS对象进行绑定，后续在通过napi_unwrap取出来。   \",\"73\":\"此外，亦可使用ArkTS数组作为数据载体，其具有良好的灵活性。    \",\"74\":\"- 参考文档：   \",\"75\":\"[使用Node-API接口进行object相关开发](use-napi-about-object.md)    \",\"76\":\"[使用Node-API接口进行array相关开发](use-napi-about-array.md)    \",\"77\":\"\",\"78\":\"## napi_get_uv_event_loop接口错误码说明\"}",
      "修改建议": "混用了'亦可'和'此外'，导致句式不一致。",
      "更改后示例": "此外，还可以使用ArkTS数组作为数据载体，其具有良好的灵活性。",
      "触发条件": "当同一段落或相邻句子中混用不同连接词（如\"此外\"与\"亦可\"），且上下文存在统一表达模式（如\"此外，还可以...\"结构）时触发。识别模式需检测：1) 连接词与上下文衔接方式不一致 2) 句式结构与前文同类表达存在明显语体差异。"
    },
    {
      "defect_id": 459896,
      "sentence": "3. napi层也提供了一个创建ts function的能力，即napi_create_function，可以直接在Native层中创建出来，这样，Native层自然就能拿到这个ts function",
      "reference_sentence": "如果想要在Native层调用ts层对象方法，则Native层需获取该TS Function对象。",
      "line_num": 136,
      "context": "{\"131\":\"- 参考方案：  \",\"132\":\"如果想要在Native层调用ts层对象方法，则Native层需获取该TS Function对象。  \",\"133\":\"获取的途径也有很多，比如：  \",\"134\":\"1. 通过传递的方式，ts层传给Native层，也就是问题描述的方案   \",\"135\":\"2. 可以把这个ts function通过属性设置方式绑定到Native层可访问的对象上，这样Native层通过这个对象也能拿到function进行调用   \",\"136\":\"3. napi层也提供了一个创建ts function的能力，即napi_create_function，可以直接在Native层中创建出来，这样，Native层自然就能拿到这个ts function   \",\"137\":\"\",\"138\":\"## 是否能调用ets的方法并获取到结果\",\"139\":\"\",\"140\":\"- 具体问题：在c++通过pthread或std::thread创建的线程，是否能调用ets的方法并获取到结果？\",\"141\":\"问题分析：   \"}",
      "修改建议": "混用了'function'和'TS Function对象'，导致用词不一致。",
      "更改后示例": "3. napi层也提供了一个创建TS Function对象的能力，即napi_create_function，可以直接在Native层中创建出来，这样，Native层自然就能拿到这个TS Function对象",
      "触发条件": "同一术语在相邻上下文中存在全称/简称混用（如\"TS Function对象\"与\"function\"交替出现）或命名格式不一致（如大小写不统一、是否带\"对象\"后缀），且文档中存在已明确定义的统一表达形式（如参考句中的\"TS Function对象\"）。"
    },
    {
      "defect_id": 459894,
      "sentence": "1. 通过传递的方式，ts层传给Native层，也就是问题描述的方案",
      "reference_sentence": "如果想要在Native层调用ts层对象方法，则Native层需获取该TS Function对象。",
      "line_num": 134,
      "context": "{\"129\":\"\",\"130\":\"- 具体问题：【NAPI】Native层调用ts层对象方法，必须传入一个function给Native层吗？\",\"131\":\"- 参考方案：  \",\"132\":\"如果想要在Native层调用ts层对象方法，则Native层需获取该TS Function对象。  \",\"133\":\"获取的途径也有很多，比如：  \",\"134\":\"1. 通过传递的方式，ts层传给Native层，也就是问题描述的方案   \",\"135\":\"2. 可以把这个ts function通过属性设置方式绑定到Native层可访问的对象上，这样Native层通过这个对象也能拿到function进行调用   \",\"136\":\"3. napi层也提供了一个创建ts function的能力，即napi_create_function，可以直接在Native层中创建出来，这样，Native层自然就能拿到这个ts function   \",\"137\":\"\",\"138\":\"## 是否能调用ets的方法并获取到结果\",\"139\":\"\"}",
      "修改建议": "混用了'传给'和'获取'，导致用词不一致。",
      "更改后示例": "1. 通过传递的方式，ts层将该TS Function对象传给Native层，也就是问题描述的方案",
      "触发条件": "同一上下文或相邻句子中，描述同一对象/动作的传递方向时，存在动词不一致（如“传给”与“获取”混用），且涉及同一逻辑主体（如TS Function对象）的双向交互场景。"
    },
    {
      "defect_id": 462854,
      "sentence": "设置边框间隙，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法。取值范围≥0，异常值按照默认值处理。",
      "reference_sentence": "设置边框间隙，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法。取值范围≥0，异常值按照默认值处理。",
      "line_num": 131,
      "context": "{\"126\":\"\",\"127\":\"### strokeDashArray\",\"128\":\"\",\"129\":\"strokeDashArray(value: Array&lt;any&gt;)\",\"130\":\"\",\"131\":\"设置边框间隙，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法。取值范围≥0，异常值按照默认值处理。\",\"132\":\"\",\"133\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"134\":\"\",\"135\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"136\":\"\"}",
      "修改建议": "前后句子中描述异常值处理的方式不一致，应统一为'异常值按照默认值处理'。",
      "更改后示例": "设置边框间隙，支持[attributeModifier](ts-universal-attributes-attribute-modifier.md#attributemodifier)动态设置属性方法。取值范围≥0。异常值按照默认值处理。",
      "触发条件": "当相邻分句或句子中存在重复性表述同一参数/功能的异常处理规则时，且出现标点符号（如逗号与句号）或连接词（如\"异常值\"与\"无效值\"）表达不一致的情况。  \n\n识别模式：  \n1. 检测同一段落内连续出现的参数约束描述（如\"取值范围≥0\"+\"异常值处理\"）  \n2. 对比分句间标点符号使用（如逗号分割与句号分割）  \n3. 验证关键术语重复性（如\"异常值按照默认值处理\"在相邻分句中的完整重复）"
    },
    {
      "defect_id": 465026,
      "sentence": "划词SA在断开划词扩展时调用。",
      "reference_sentence": "划词SA在断开划词扩展时调用。",
      "line_num": 73,
      "context": "{\"68\":\"\",\"69\":\"### onDisconnect\",\"70\":\"\",\"71\":\"onDisconnect(): void\",\"72\":\"\",\"73\":\"Extension生命周期回调函数，划词SA在断开划词扩展时调用。\",\"74\":\"\",\"75\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"76\":\"\",\"77\":\"**示例：**\",\"78\":\"\"}",
      "修改建议": "术语 '划词SA' 应与上文保持一致，应使用 '划词服务' 而非 '划词SA'",
      "更改后示例": "划词服务在断开划词扩展时调用。",
      "触发条件": "当同一术语在文档中存在全称与缩写混用（如\"划词服务\"与\"划词SA\"），且上下文已明确定义过标准术语时触发；或当同一概念出现两种及以上命名变体（如服务/模块/组件等后缀不一致）时触发。\n\n识别模式：\n1. 术语形态对比：检测相邻段落/句子中是否存在相同核心词（如\"划词\"）但后缀不同（如SA/服务）的命名\n2. 上下文锚定：通过问题上下文中的参考句子（如\"划词服务\"）建立标准术语，比对当前句子中的非常规缩写（如\"划词SA\"）\n3. 系统词库匹配：当检测到未注册的临时缩写（如SA未被定义为Service Abbreviation）时触发警报"
    },
    {
      "defect_id": 460001,
      "sentence": "多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。",
      "reference_sentence": "多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。",
      "line_num": 199,
      "context": "{\"194\":\"ArkTS/JS侧import xxx from libxxx.so后，使用xxx报错显示undefined/not callable或明确的Error message\",\"195\":\"1. 排查.cpp文件在注册模块时的模块名称与so的名称匹配一致。\",\"196\":\"   如模块名为entry，则so的名字为libentry.so，napi_module中nm_modname字段应为entry，大小写与模块名保持一致。\",\"197\":\"\",\"198\":\"2. 排查so是否加载成功。\",\"199\":\"   应用启动时过滤模块加载相关日志，重点搜索\\\"dlopen\\\"关键字，确认是否有相关报错信息；常见加载失败原因有权限不足、so文件不存在以及so已拉入黑名单等，可根据以下关键错误日志确认问题。其中，多线程场景(worker、taskpool等)下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。\",\"200\":\"\",\"201\":\"3. 排查依赖的so是否加载成功。\",\"202\":\"   确定所依赖的其它so是否打包到应用中以及是否有权限打开。常见加载失败原因有权限不足、so文件不存在等。\",\"203\":\"\",\"204\":\"4. 排查模块导入方式与so路径是否对应。\"}",
      "修改建议": "用词不一致，'多线程场景'与'多线程场景(worker、taskpool等)'混用",
      "更改后示例": "多线程场景（如worker、taskpool等）下优先检查模块实现中nm_modname是否与模块名一致，区分大小写。",
      "触发条件": "当文档中同一术语存在括号内示例说明与无括号说明的混用情况，或术语与示例的衔接方式（如\"如\"字引导）出现不一致时触发。具体表现为相邻段落或同一上下文中的术语呈现方式差异（如\"多线程场景\"与\"多线程场景(worker...)\"交替出现）。"
    },
    {
      "defect_id": 467020,
      "sentence": "定义BuilderNode内自定义组件的[@Consume](../../ui/state-management/arkts-provide-and-consume.md)是否和所在页面的[@Provide](../../ui/state-management/arkts-provide-and-consume.md)的状态互通。其中，true表示支持，false表示不支持。",
      "reference_sentence": "定义BuilderNode内自定义组件的[@Consume](../../ui/state-management/arkts-provide-and-consume.md)是否和所在页面的[@Provide](../../ui/state-management/arkts-provide-and-consume.md)的状态互通。其中，true表示支持，false表示不支持。",
      "line_num": 214,
      "context": "{\"209\":\"\",\"210\":\"| 名称          | 类型                                   | 必填 | 说明                                                         |\",\"211\":\"| ------------- | -------------------------------------- | ---- | ------------------------------------------------------------ |\",\"212\":\"| nestingBuilderSupported |boolean | 否   | 是否支持Builder嵌套Builder进行使用。其中，false表示Builder使用的入参一致，true表示Builder使用的入参不一致。默认值：false<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"213\":\"| localStorage<sup>20+</sup> |[LocalStorage](../../ui/state-management/arkts-localstorage.md) | 否   | 给当前builderNode设置localStorage，挂载在此builderNode下的自定义组件共享该localStorage，如果自定义组件构造函数同时也传入localStorage，优先使用构造函数中传入的localStorage。默认值：null<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"214\":\"| enableProvideConsumeCrossing<sup>20+</sup> |boolean | 否 | 定义BuilderNode内自定义组件的[@Consume](../../ui/state-management/arkts-provide-and-consume.md)是否和所在页面的[@Provide](../../ui/state-management/arkts-provide-and-consume.md)的状态互通。其中，true表示支持，false表示不支持。默认值：false<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"215\":\"\",\"216\":\"### InputEventType<sup>20+</sup>\",\"217\":\"\",\"218\":\"type InputEventType = TouchEvent | MouseEvent | AxisEvent\",\"219\":\"\"}",
      "修改建议": "术语`状态互通`表述模糊，建议使用更明确的表述。",
      "更改后示例": "定义BuilderNode内自定义组件的[@Consume](../../ui/state-management/arkts-provide-and-consume.md)是否与所在页面的[@Provide](../../ui/state-management/arkts-provide-and-consume.md)的状态进行交互。其中，true表示支持，false表示不支持。",
      "触发条件": "当技术文档中出现与上下文或技术领域术语体系不一致的模糊表述（如\"互通\"等非标准术语），且存在更明确的标准化表达（如\"交互\"）时触发。\n\n识别模式：\n1. 检测关键参数说明中涉及系统机制描述的动词短语（如状态XX、数据XX）\n2. 匹配非标准技术术语（如\"互通\"）与标准术语库（如\"交互\"）的冲突\n3. 结合参数命名特征（如enable*Crossing）验证表述准确性需求\n4. 检查相邻参数说明的表述一致性（对比localStorage参数说明的规范表述）"
    },
    {
      "defect_id": 467853,
      "sentence": "从API版本20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 20开始，该接口支持在原子化服务中使用。",
      "line_num": 214,
      "context": "{\"209\":\"\",\"210\":\"| 名称          | 类型                                   | 必填 | 说明                                                         |\",\"211\":\"| ------------- | -------------------------------------- | ---- | ------------------------------------------------------------ |\",\"212\":\"| nestingBuilderSupported |boolean | 否   | 是否支持Builder嵌套Builder进行使用。其中，false表示Builder使用的入参一致，true表示Builder使用的入参不一致。默认值：false<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"213\":\"| localStorage<sup>20+</sup> |[LocalStorage](../../ui/state-management/arkts-localstorage.md) | 否   | 给当前BuilderNode设置LocalStorage，挂载在此builderNode下的自定义组件共享该LocalStorage。如果自定义组件构造函数同时也传入LocalStorage，优先使用构造函数中传入的LocalStorage。默认值：null。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"214\":\"| enableProvideConsumeCrossing<sup>20+</sup> | boolean | 否 | 定义BuilderNode内自定义组件的@Consume是否与所在页面的@Provide状态互通。true表示支持，false表示不支持。默认值：false。<br/>**原子化服务API**：从API版本20开始，该接口支持在原子化服务中使用。|\",\"215\":\"\",\"216\":\"### InputEventType<sup>20+</sup>\",\"217\":\"\",\"218\":\"type InputEventType = TouchEvent | MouseEvent | AxisEvent\",\"219\":\"\"}",
      "修改建议": "混用了'版本'与'version'，应保持一致。",
      "更改后示例": "从API version 20开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一术语在相邻或相关上下文中出现中英文混合表述（如\"API版本\"与\"API version\"交替出现），且存在已确定的规范表达形式（如参考句子中的\"API version\"）。\n\n识别模式：\n1. 检测相邻段落或同类组件描述中同一术语的表述形式\n2. 对比当前句子与参考规范表达的一致性\n3. 定位中英文混合表述场景（如\"版本\"与\"version\"同时出现）\n4. 验证上下文是否存在已确立的标准表达范式（如文档其他部分统一使用\"API version\"）"
    },
    {
      "defect_id": 467987,
      "sentence": "数字翻牌动效。仅支持正整数。不支持选中，且[copyOption](../arkui-ts/ts-basic-components-text.md#copyoption9)属性不生效。不支持渐变色和Text跑马灯模式。Text有子组件或设置属性字符串时数字翻牌不生效。",
      "reference_sentence": "数字翻牌动效。仅支持正整数。不支持选中，且[copyOption](../arkui-ts/ts-basic-components-text.md#copyoption9)属性不生效。不支持渐变色和Text跑马灯模式。Text有子组件或设置属性字符串时数字翻牌不生效。",
      "line_num": 1070,
      "context": "{\"1065\":\"\",\"1066\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"1067\":\"\",\"1068\":\"## NumericTextTransition<sup>20+</sup>\",\"1069\":\"\",\"1070\":\"数字翻牌动效。仅支持正整数。不支持选中，且[copyOption](../arkui-ts/ts-basic-components-text.md#copyoption9)属性不生效。不支持渐变色和Text跑马灯模式。Text有子组件或设置属性字符串时数字翻牌不生效。\",\"1071\":\"\",\"1072\":\"NumericTextTransition继承自[ContentTransition](#contenttransition20)。\",\"1073\":\"\",\"1074\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"1075\":\"\"}",
      "修改建议": "无用词不一致问题，但存在句式不一致问题，建议统一使用祈使句描述动作。",
      "更改后示例": "数字翻牌动效。仅支持正整数。不支持选中，且[copyOption](../arkui-ts/ts-basic-components-text.md#copyoption9)属性不生效。不支持渐变色和文本跑马灯模式。文本有子组件或设置属性字符串时数字翻牌不生效。",
      "触发条件": "同一技术术语在文档中存在中英文混用（如\"Text\"与\"文本\"交替出现），或同一功能描述存在词汇/句式不一致（如\"跑马灯模式\"与\"文本跑马灯模式\"未统一）。识别模式需检测相邻句段中相同概念是否采用相同命名规范，并验证技术词汇是否遵循项目术语表。"
    },
    {
      "defect_id": 467996,
      "sentence": "| enableProvideConsumeCrossing<sup>20+</sup> | boolean | 否 | 定义BuilderNode内自定义组件的@Consume是否与所在页面的@Provide状态互通。true表示支持，false表示不支持。默认值：false。<br/>**原子化服务API**：从API version 20开始，该接口支持在原子化服务中使用。|",
      "reference_sentence": "| localStorage<sup>20+</sup> |[LocalStorage](../../ui/state-management/arkts-localstorage.md) | 否   | 给当前BuilderNode设置LocalStorage，挂载在此BuilderNode下的自定义组件共享该LocalStorage。如果自定义组件构造函数同时也传入LocalStorage，优先使用构造函数中传入的LocalStorage。默认值：null。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |",
      "line_num": 214,
      "context": "{\"209\":\"\",\"210\":\"| 名称          | 类型                                   | 必填 | 说明                                                         |\",\"211\":\"| ------------- | -------------------------------------- | ---- | ------------------------------------------------------------ |\",\"212\":\"| nestingBuilderSupported |boolean | 否   | 是否支持Builder嵌套Builder进行使用。其中，false表示Builder使用的入参一致，true表示Builder使用的入参不一致。默认值：false<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"213\":\"| localStorage<sup>20+</sup> |[LocalStorage](../../ui/state-management/arkts-localstorage.md) | 否   | 给当前BuilderNode设置LocalStorage，挂载在此BuilderNode下的自定义组件共享该LocalStorage。如果自定义组件构造函数同时也传入LocalStorage，优先使用构造函数中传入的LocalStorage。默认值：null。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"214\":\"| enableProvideConsumeCrossing<sup>20+</sup> | boolean | 否 | 定义BuilderNode内自定义组件的@Consume是否与所在页面的@Provide状态互通。true表示支持，false表示不支持。默认值：false。<br/>**原子化服务API**：从API version 20开始，该接口支持在原子化服务中使用。|\",\"215\":\"\",\"216\":\"### InputEventType<sup>20+</sup>\",\"217\":\"\",\"218\":\"type InputEventType = TouchEvent | MouseEvent | AxisEvent\",\"219\":\"\"}",
      "修改建议": "表意模糊、句式不一致。'**原子化服务API**'和'**原子化服务API：**'两种表述混用，且'**原子化服务API**'后未使用冒号。",
      "更改后示例": "| enableProvideConsumeCrossing<sup>20+</sup> | boolean | 否 | 定义BuilderNode内自定义组件的@Consume是否与所在页面的@Provide状态互通。true表示支持，false表示不支持。默认值：false。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|",
      "触发条件": "当同一文档中出现相同类型的注释标签（如**原子化服务API**）存在标点符号格式不一致（例如有无冒号混用）或句式结构不统一时触发。\n\n识别模式：\n1. 匹配文档中**加粗标签**后是否统一使用冒号（如**标签：** vs **标签**）\n2. 对比相邻条目或同类条目（如API说明块）的句式结构一致性，特别是特殊注释块的标点使用规范\n3. 检查上下文是否存在相同语义表达的不同格式（如\"原子化服务API**：\"与\"原子化服务API**\"共存）"
    },
    {
      "defect_id": 465257,
      "sentence": "**系统能力**：SystemCapability.SelectionInput.Selection",
      "reference_sentence": "**系统能力：** SystemCapability.SelectionInput.Selection",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"## PanelType\",\"30\":\"\",\"31\":\"划词面板类型枚举。\",\"32\":\"\",\"33\":\"**系统能力**：SystemCapability.SelectionInput.Selection\",\"34\":\"\",\"35\":\"| 名称          | 值   | 说明         |\",\"36\":\"| ------------- | ---- | ------------ |\",\"37\":\"| MENU_PANEL | 1    | 菜单面板类型。 |\",\"38\":\"| MAIN_PANEL | 2    | 主面板类型。 |\"}",
      "修改建议": "混用了'系统能力'和'系统能力**'，导致格式不一致",
      "更改后示例": "**系统能力：** SystemCapability.SelectionInput.Selection",
      "触发条件": "同一文档中存在相同标题或术语的格式不一致（如星号位置、标点符号间距），且相邻上下文存在已验证的标准格式实例时触发。具体表现为标题字段的Markdown粗体符号（**）未完整包裹\"标题+后缀符号\"组合（如**系统能力：** vs **系统能力**：）。"
    },
    {
      "defect_id": 467777,
      "sentence": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。",
      "reference_sentence": "3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'全屏'和'全屏样式'，应保持一致。",
      "更改后示例": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏。",
      "触发条件": "当同一术语或选项在相邻描述中存在冗余修饰词（如\"样式\"）与其他条目表述不一致，且上下文存在统一命名规范（如枚举值名称与说明文字对应）时触发。\n\n识别模式需检查：\n1. 同一属性/参数的多个选项描述是否保持\"枚举值名称\"与\"说明文字\"的严格对应（如SheetType.CONTENT_COVER对应\"全屏\"而非\"全屏样式\"）\n2. 相邻条目中相同语义表述是否出现多余修饰词（如参考句3使用\"全屏\"，而问题句5添加了冗余的\"样式\"后缀）"
    },
    {
      "defect_id": 469062,
      "sentence": "设置BuilderNode的BuildOptions中enableProvideConsumeCrossing为true，实现BuilderNode内部自定义组件的@Consume与所在自定义组件的@Provide数据互通。",
      "reference_sentence": "设置BuilderNode的BuildOptions中enableProvideConsumeCrossing为true，实现BuilderNode内部自定义组件的@Consume与所在自定义组件的@Provide数据互通。",
      "line_num": 1894,
      "context": "{\"1889\":\"\",\"1890\":\"![inheritFreezeOptions](figures/builderNode_inheritFreezeOptions.gif)\",\"1891\":\"\",\"1892\":\"### 示例7（BuilderNode支持内部@Consume接收外部的@Provide数据）\",\"1893\":\"\",\"1894\":\"设置BuilderNode的BuildOptions中enableProvideConsumeCrossing为true，实现BuilderNode内部自定义组件的@Consume与所在自定义组件的@Provide数据互通。\",\"1895\":\"\",\"1896\":\"```ts\",\"1897\":\"import { BuilderNode, NodeContent } from '@kit.ArkUI';\",\"1898\":\"\",\"1899\":\"@Component\"}",
      "修改建议": "句子中混用了'设置'和'实现'，建议使用一致的句式。",
      "更改后示例": "设置BuilderNode的BuildOptions中enableProvideConsumeCrossing为true，以实现BuilderNode内部自定义组件的@Consume与所在自定义组件的@Provide数据互通。",
      "触发条件": "当句子中存在多个表示动作或目的的动词短语，但句式结构不统一（如并列动作未通过\"以/以便/从而\"等连接词形成目的状语结构）时触发，尤其当动词短语间存在隐含逻辑关系却未显式关联时。  \n\n识别模式：检测连续动词短语是否采用相同语法结构（如\"设置...，实现...\"），若前项为动作、后项为目的但未使用\"以/以便/从而\"等连接词，则判定为句式断裂需补全关联词。"
    },
    {
      "defect_id": 467776,
      "sentence": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。",
      "reference_sentence": "3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边样式。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER全屏样式。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "混用了'侧边'和'侧边样式'，应保持一致。",
      "更改后示例": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE侧边。",
      "触发条件": "当同一参数/选项的多个描述项出现术语不一致（如\"侧边\"与\"侧边样式\"混用），或与邻近条目/参考句中的参数命名模式不匹配时触发。\n\n识别模式：\n1. 检查参数值描述是否与枚举值定义/相邻条目保持严格对应（如SheetType.SIDE枚举值应对应\"侧边\"而非\"侧边样式\"）\n2. 对比同一参数在不同上下文中的表达方式（如问题句中的\"侧边样式\"与参考句中的\"侧边\"形成矛盾）\n3. 验证技术术语是否冗余添加非必要后缀（如\"样式\"在参数值描述中属于冗余说明）"
    },
    {
      "defect_id": 469395,
      "sentence": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER（全屏）。",
      "reference_sentence": "3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE（侧边）。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER（全屏）。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "用词不一致，'全屏'与'SheetType.CONTENT_COVER'混用",
      "更改后示例": "5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER。",
      "触发条件": "当同一术语在括号内使用不同表述形式（如枚举值与中文释义混用），且上下文已存在明确对应的标准术语时。  \n\n识别模式：检查括号内容是否重复解释已定义的枚举值（如SheetType.CONTENT_COVER与\"全屏\"并存），并比对上下文是否统一使用单一表述（如参考句子仅用\"全屏\"作为选项）。"
    },
    {
      "defect_id": 469394,
      "sentence": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE（侧边）。",
      "reference_sentence": "3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。",
      "line_num": 56,
      "context": "{\"51\":\"\",\"52\":\"| 名称              | 类型                                       | 必填   | 说明              |\",\"53\":\"| --------------- | ---------------------------------------- | ---- | --------------- |\",\"54\":\"| height          | [SheetSize](#sheetsize枚举说明)&nbsp;\\\\|&nbsp;[Length](ts-types.md#length) | 否    | 半模态高度，默认是LARGE。<br/>**说明：**<br/>API version 12之前，底部弹窗横屏时该属性设置无效，高度为距离屏幕顶部8vp。<br/>API version 12开始，底部弹窗横屏时该属性设置生效，最大高度为距离屏幕顶部8vp。<br/>API version 14开始，底部弹窗横屏时，无状态栏则最大高度为距离屏幕顶部8vp，有状态栏则最大高度为距离状态栏8vp。<br/>底部弹窗时，当设置detents时，该属性设置无效。<br/>底部弹窗竖屏时，最大高度为距离状态栏8vp。<br />居中弹窗和跟手弹窗设置类型为SheetSize.LARGE和SheetSize.MEDIUM无效，显示默认高度560vp。居中弹窗和跟手弹窗最小高度为320vp，最大高度为窗口短边的90%。当使用Length设置的高度和使用SheetSize.FIT_CONTENT自适应的高度大于最大高度，则显示最大高度，小于最小高度，则显示最小高度。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"55\":\"| detents<sup>11+</sup> | [([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length)), ( [SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?, ([SheetSize](#sheetsize枚举说明) \\\\| [Length](ts-types.md#length))?] | 否 | 半模态页面的切换高度档位。<br/>**说明：**<br/>从API version 12开始，底部弹窗横屏时该属性设置生效。<br/>底部弹窗竖屏生效，元组中第一个高度为初始高度。<br />面板可跟手滑动切换档位，松手后是否滑动至目标档位有两个判断条件：速度和距离。速度超过阈值，则执行滑动至与手速方向一致的目标档位；速度小于阈值，则引入距离判断条件，当位移距离>当前位置与目标位置的1/2，滑动至与手速方向一致的目标档位，位移距离当前位置与目标位置的1/2，返回至当前档位。速度阈值：1000，距离阈值：50%。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"56\":\"| preferType<sup>11+</sup> | [SheetType](#sheettype11枚举说明) | 否 | 半模态页面的样式。<br/>**说明：**<br/>半模态在不同窗口所支持的显示类型：<br/>1. 宽度 < 600vp：底部、全屏。<br/>2. 600vp <= 宽度 < 840vp：底部、居中、跟手、侧边、全屏。默认居中样式。<br/>3. 宽度 >= 840vp：底部、居中、跟手、侧边、全屏。默认跟手样式。<br/>4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE（侧边）。<br/>5. API version 20开始，preferType支持设置为SheetType.CONTENT_COVER（全屏）。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"57\":\"| showClose<sup>11+</sup> | boolean \\\\| [Resource](ts-types.md#resource) | 否 | 是否显示关闭图标。<br/> 2in1设备默认无按钮底板。<br/> 默认值：true。<br/> true：显示关闭图标。<br/> false：不显示关闭图标。<br/>**说明：**<br/>Resource需要为boolean类型。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"58\":\"| dragBar         | boolean                                  | 否    | 是否显示控制条。<br/>**说明：**<br/>半模态面板的detents属性设置多个不同高度并且设置生效时，默认显示控制条。否则不显示控制条。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"59\":\"| blurStyle<sup>11+</sup> | [BlurStyle](ts-universal-attributes-background.md#blurstyle9) | 否 | 半模态面板的模糊背景。默认无模糊背景。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"60\":\"| maskColor | [ResourceColor](ts-types.md#resourcecolor) | 否 | 半模态页面的背景蒙层颜色。<br/> 默认值：Color.Gery。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"61\":\"| title<sup>11+</sup> | [SheetTitleOptions](#sheettitleoptions11) \\\\| [CustomBuilder](ts-types.md#custombuilder8) | 否 | 半模态面板的标题。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "用词不一致，'侧边'与'SheetType.SIDE'混用",
      "更改后示例": "4. API version 20开始，窗口宽度大于600vp时，preferType支持设置为SheetType.SIDE。",
      "触发条件": "同一术语在句子中同时出现代码枚举值和中文翻译注释，且上下文已存在明确对应关系时。\n\n识别模式：当检测到枚举类型(如SheetType.SIDE)与括号内的中文释义(如侧边)并存，且文档其他位置(如参考句子中的\"侧边\")已单独使用中文术语指代相同概念时，应触发该规则。典型特征为代码符号与自然语言解释冗余共存，破坏术语统一性。"
    },
    {
      "defect_id": 469737,
      "sentence": "全屏弹窗样式不支持的接口",
      "reference_sentence": "无",
      "line_num": 180,
      "context": "{\"175\":\"8. 不支持指定其他显示层级接口，例如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。\",\"176\":\"\",\"177\":\"9. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。\",\"178\":\"\",\"179\":\"\",\"180\":\"**全屏弹窗样式不支持的接口**\",\"181\":\"| 名称             | 说明              |\",\"182\":\"| --------------- |  --------------- |\",\"183\":\"| height          | 高度只支持全屏高度。 |\",\"184\":\"| width           | 宽度只支持全屏宽度。 |\",\"185\":\"| detents | 无挡位能力。|\"}",
      "修改建议": "标题中的'全屏弹窗'与表格中使用的'全屏弹窗'一致，但与'半模态全屏弹窗'不一致",
      "更改后示例": "半模态全屏弹窗样式不支持的接口",
      "触发条件": "当文档标题或关键术语与上下文、表格中的同一概念存在命名不一致（如缺少修饰词或使用不同简称），且存在更准确、完整的统一表达形式时触发。  \n\n识别模式：检查标题与相邻内容（如表格列、段落描述）是否使用相同术语结构，若发现标题中术语比上下文缺少必要限定词（如案例中缺失\"半模态\"），则判定为不一致需修复。"
    },
    {
      "defect_id": 470942,
      "sentence": "1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。",
      "reference_sentence": "3. 无避让软键盘能力，需自定义避让。也无悬停态避让能力。",
      "line_num": 161,
      "context": "{\"156\":\"| placementOnTarget | 只支持气泡样式。|\",\"157\":\"| showInSubWindow | 不支持指定显示层级。 |\",\"158\":\"\",\"159\":\"**半模态全屏弹窗样式：**\",\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。\",\"162\":\"\",\"163\":\"2. 半模态不支持安全区设置，全屏样式默认布局于安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。\",\"166\":\"\"}",
      "修改建议": "混用了'关闭按钮'和'showClose'，以及'圆角'和'radius'。",
      "更改后示例": "1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等。",
      "触发条件": "同一段落内存在混合使用中文术语与对应英文属性名的情况，或列举项结尾出现冗余总结词（如\"内容\"）导致句式不一致。  \n\n识别模式需检查：1) 技术文档中同一功能描述是否交替出现中英文术语（如\"关闭按钮\"与\"showClose\"） 2) 多项目列举结构是否在结尾添加了非常规总结词（如\"等内容\"），需与上下文其他同类句式保持平行结构。"
    },
    {
      "defect_id": 470946,
      "sentence": "8. 不支持指定其他显示层级接口，例如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。",
      "reference_sentence": "5. 不支持指定其他显示层级接口，如showInSubWindow = true、mode = SheetMode.EMBEDDED。侧边弹窗的层级同SheetMode.OVERLAY，只支持在当前UIContext内顶层显示，在所有页面之上。和弹窗类组件显示在一个层级。",
      "line_num": 175,
      "context": "{\"170\":\"\",\"171\":\"6. 不支持上下滑动，仅支持侧滑关闭。\",\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认为全屏。\",\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，例如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。\",\"176\":\"\",\"177\":\"9. 不支持避让软键盘，需自定义避让。\",\"178\":\"\",\"179\":\"\",\"180\":\"**半模态全屏弹窗样式不支持的接口**\"}",
      "修改建议": "混用了'例如'和'如'。",
      "更改后示例": "8. 不支持指定其他显示层级接口，如 `showInSubWindow = true`、`mode = SheetMode.EMBEDDED`。全屏弹窗的层级与 `SheetMode.OVERLAY` 相同，仅支持在当前 `UIContext` 内顶层显示，位于所有页面之上，与弹窗类组件显示在同一层级。",
      "触发条件": "同一文档或相邻条目中存在相同功能说明的列举结构时，混合使用不同引导词（如\"例如\"与\"如\"），且上下文存在统一用词范例（如参考句子的\"如\"用法）。\n\n识别模式：\n1. 检测列举结构中引导词的统一性（如/例如/譬如）\n2. 对比上下文相同功能模块的表述方式\n3. 验证相邻条目（如问题上下文中的条款5-9）是否存在统一用词范式\n4. 识别技术文档中代码示例前的引导词使用一致性"
    },
    {
      "defect_id": 470943,
      "sentence": "2. 半模态不支持安全区设置，全屏样式默认布局于安全区内。",
      "reference_sentence": "无",
      "line_num": 163,
      "context": "{\"158\":\"\",\"159\":\"**半模态全屏弹窗样式：**\",\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。\",\"162\":\"\",\"163\":\"2. 半模态不支持安全区设置，全屏样式默认布局于安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效 [ModalTransition](ts-types.md#modaltransition10) 转场方式 ，默认值为 `ModalTransition.DEFAULT`，不支持自定义转场。\",\"168\":\"\"}",
      "修改建议": "句子结构不一致，建议统一为祈使句。",
      "更改后示例": "2. 不支持安全区设置，全屏样式默认布局于安全区内。",
      "触发条件": "同一列表项中出现主语冗余导致句式不一致，或相邻条目使用不同语法结构时触发。识别模式为检查列表项是否包含可省略的重复主语，以及是否与上下文条目保持相同的\"支持/不支持\"开头的祈使句结构。"
    },
    {
      "defect_id": 470944,
      "sentence": "3. 全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。",
      "reference_sentence": "无",
      "line_num": 165,
      "context": "{\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。\",\"162\":\"\",\"163\":\"2. 半模态不支持安全区设置，全屏样式默认布局于安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效 [ModalTransition](ts-types.md#modaltransition10) 转场方式 ，默认值为 `ModalTransition.DEFAULT`，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 不支持挡位能力，不支持 `detents`、`detentSelection` 接口。\",\"170\":\"\"}",
      "修改建议": "句子结构不一致，建议统一为祈使句。",
      "更改后示例": "3. 支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。",
      "触发条件": "列表中存在主语+动词结构（如\"全屏样式支持\"）而其他条目使用祈使句（动词开头）时触发，或条目间存在冗余的主语描述导致句式不统一时触发。通过检测条目开头是否包含与上下文重复的主语名词，且相邻条目均采用无主语的祈使句式进行识别。"
    },
    {
      "defect_id": 476703,
      "sentence": "| string | Promise对象。以Promise形式返回的网络扩展属性。",
      "reference_sentence": "| Promise<string> | Promise对象。以Promise形式返回的网络扩展属性。",
      "line_num": 1925,
      "context": "{\"1920\":\"\",\"1921\":\"**返回值：**\",\"1922\":\"\",\"1923\":\"| 类型   | 说明                     |\",\"1924\":\"| ------ | ----------------------- |\",\"1925\":\"| string | Promise对象。以Promise形式返回的网络扩展属性。|\",\"1926\":\"\",\"1927\":\"\",\"1928\":\"**错误码：**\",\"1929\":\"\",\"1930\":\"以下错误码的详细介绍请参见[网络连接管理错误码](errorcode-net-connection.md)。\"}",
      "修改建议": "混用了`string`和`Promise<string>`类型",
      "更改后示例": "| string | 以同步方式返回的网络扩展属性。",
      "触发条件": "当表格列中类型声明（如`string`）与对应说明字段存在语义冲突（如出现\"Promise形式返回\"描述），或类型描述未正确反映异步/Promise特性时触发。"
    },
    {
      "defect_id": 475447,
      "sentence": "节点默认无法获焦、开发者通过focusable等属性方法设置节点无法获焦等。",
      "reference_sentence": "当前节点无法获得焦点。",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"当前节点无法获得焦点。\",\"16\":\"\",\"17\":\"**可能原因**\",\"18\":\"\",\"19\":\"节点默认无法获焦、开发者通过focusable等属性方法设置节点无法获焦等。\",\"20\":\"\",\"21\":\"**处理步骤**\",\"22\":\"\",\"23\":\"NA\",\"24\":\"\"}",
      "修改建议": "混用了'获焦'和'获得焦点'，应保持一致",
      "更改后示例": "节点默认无法获得焦点、开发者通过focusable等属性方法设置节点无法获得焦点等。",
      "触发条件": "同一术语在相邻或相关句子中存在全称/简称混用（如\"获焦\"与\"获得焦点\"），或在同一语义场景下出现两种及以上表达形式时触发。\n\n识别模式：\n1. 检测同一段落/上下文中的术语变体（通过词根匹配/同义词库识别，如\"获焦\"与\"获得焦点\"共享\"获\"+\"焦/焦点\"词素）\n2. 验证术语指代同一技术概念（结合上下文语义分析，如问题上下文中的焦点管理场景）\n3. 检查参考句子的权威表达形式（如案例中参考句明确使用\"获得焦点\"作为标准术语）"
    },
    {
      "defect_id": 476724,
      "sentence": "当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "reference_sentence": "当前没有已连接的网络时，获取的netHandle的netId为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "line_num": 1800,
      "context": "{\"1795\":\"import { connection } from '@kit.NetworkKit';\",\"1796\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"1797\":\"\",\"1798\":\"connection.getDefaultNet().then((netHandle: connection.NetHandle) => {\",\"1799\":\"  if (netHandle.netId == 0) {\",\"1800\":\"    // 当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。\",\"1801\":\"    return;\",\"1802\":\"  }\",\"1803\":\"  let netExtAttribute: string = \\\"xxx\\\";\",\"1804\":\"  connection.setNetExtAttribute(netHandle, netExtAttribute).then(() => {\",\"1805\":\"    console.log(\\\"setNetExtAttribute success\\\");\"}",
      "修改建议": "混用了`netHandler`和`netHandle`概念，且`netid`与`netId`大小写不一致",
      "更改后示例": "当前没有已连接的网络时，获取的netHandle的netId为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "触发条件": "同一技术术语在文档中出现多种拼写变体（如netHandle/netHandler）或同一单词存在大小写不一致（如netid/netId），且与代码上下文中的命名规范冲突时触发。\n\n识别模式：\n1. 术语一致性检测：通过对比代码库中的类/变量命名（如NetHandle类型、netHandle实例），识别文档中出现的异形词（如netHandler）\n2. 大小写规范检查：针对技术文档中出现的全小写技术术语（如netid），与代码中的驼峰命名（如netId）进行模式匹配"
    },
    {
      "defect_id": 476761,
      "sentence": "点击目录pages，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets；在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。",
      "reference_sentence": "使用一致的句式，不但使技术文档对外表现出一致的风格，也有助于用户在理解内容时，符合已经形成的思维惯性，理解起来更简单。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"1. 创建划词应用工程\",\"18\":\"\",\"19\":\"- 在DevEco Studio工程Module对应的ets目录下，右键选择“New > Directory”，新建一个目录，并命名为ServiceExtAbility。\",\"20\":\"\",\"21\":\"- 点击目录pages，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets；在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。目录如下：\",\"22\":\"\",\"23\":\"  ```\",\"24\":\"  /src/main/\",\"25\":\"  ├── ets/\",\"26\":\"  │   ├── pages\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "点击目录pages，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets。在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。",
      "触发条件": "同一段落或连续步骤中存在混合句式结构（如分号连接的复合句与独立祈使句并存），且上下文已建立祈使句规范模式时触发。\n\n识别模式：\n1. 句式混合检测：通过标点符号（分号/句号）识别复合句与独立句的交替使用\n2. 动词位置分析：检测步骤描述是否偏离\"动词开头\"的祈使句结构\n3. 上下文一致性验证：比对相邻条目（如问题上下文第19行）已建立的祈使句表达范式"
    },
    {
      "defect_id": 476725,
      "sentence": "当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "reference_sentence": "当前没有已连接的网络时，获取的netHandle的netId为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "line_num": 1894,
      "context": "{\"1889\":\"import { connection } from '@kit.NetworkKit';\",\"1890\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"1891\":\"\",\"1892\":\"connection.getDefaultNet().then((netHandle: connection.NetHandle) => {\",\"1893\":\"  if (netHandle.netId == 0) {\",\"1894\":\"    // 当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。\",\"1895\":\"    return;\",\"1896\":\"  }\",\"1897\":\"  connection.getNetExtAttribute(netHandle).then((netExtAttribute: string) => {\",\"1898\":\"    console.log(\\\"getNetExtAttribute: \\\" + netExtAttribute);\",\"1899\":\"  }).catch((error: BusinessError) => {\"}",
      "修改建议": "混用了`netHandler`和`netHandle`概念，且`netid`与`netId`大小写不一致",
      "更改后示例": "当前没有已连接的网络时，获取的netHandle的netId为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "触发条件": "同一技术术语在文档中出现拼写/大小写不一致（如netHandle与netHandler混用、netId与netid并存），或与代码变量命名存在冲突时触发。\n\n识别模式：\n1. 术语形态对比：检测相邻段落/注释中同一概念的不同拼写形态（如驼峰式netId与全小写netid）\n2. 代码上下文匹配：验证文档术语与代码变量命名的一致性（如代码声明netHandle但文档写netHandler）\n3. 同源词根冲突：识别具有相同词根但后缀不同的术语变体（如Handler/Handle结尾的术语混用）"
    },
    {
      "defect_id": 476814,
      "sentence": "  - [划词服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供划词配置同步接口，划词服务SA监听多模键鼠事件获取鼠标和触控板操作窗口和应用信息，DFX增强。",
      "reference_sentence": "无",
      "line_num": 31,
      "context": "{\"26\":\"- 数据文件处理：\",\"27\":\"  - [剪贴板](../reference/apis-basic-services-kit/js-apis-pasteboard.md)：提供内容复制粘贴能力，支持多种数据类型包括文本、HTML数据、URI、PixelMap等。\",\"28\":\"  - [压缩](../reference/apis-basic-services-kit/js-apis-zlib.md)：提供文件压缩解压缩的能力。\",\"29\":\"  - [打印](../reference/apis-basic-services-kit/js-apis-print.md)：提供基础文件打印的能力，比如传入文件进行打印、设置打印参数等。\",\"30\":\"  - [上传下载](../reference/apis-basic-services-kit/js-apis-request.md)：提供文件上传下载、后台传输代理的基础能力。\",\"31\":\"  - [划词服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供划词配置同步接口，划词服务SA监听多模键鼠事件获取鼠标和触控板操作窗口和应用信息，DFX增强。\",\"32\":\"\",\"33\":\"- 进程间/线程间通信：\",\"34\":\"  - [公共事件](../reference/apis-basic-services-kit/js-apis-commonEventManager.md)：提供进程间通信的能力，包括订阅、发布、退订公共事件等，相关开发指南请参考[公共事件简介](common-event/common-event-overview.md)。\",\"35\":\"  - [Emitter](../reference/apis-basic-services-kit/js-apis-emitter.md)：提供线程内通信的能力，包括订阅、发布、退订自定义事件等，相关开发指南请参考[使用Emitter进行线程间通信](common-event/itc-with-emitter.md)。\",\"36\":\"\"}",
      "修改建议": "使用了'划词服务'和'划词服务SA'两个不同的术语描述同一概念，不符合用词一致的规则。",
      "更改后示例": "  - [划词服务](../reference/apis-basic-services-kit/js-apis-selectionInput-selectionManager.md)：提供划词配置同步接口，划词服务监听多模键鼠事件获取鼠标和触控板操作窗口和应用信息，DFX增强。",
      "触发条件": "同一段落或邻近上下文中存在对同一概念使用多个不一致的术语指代（如\"划词服务\"和\"划词服务SA\"），且未通过注释明确说明术语差异时触发。\n\n识别模式：\n1. 术语重复检测：在相邻3-5个句子范围内，检测到同一核心名词存在词形变化（如添加/删除修饰词、缩写扩展等）\n2. 功能指向验证：通过上下文语义分析确认不同术语指向同一功能模块或技术实体\n3. 注释缺失判断：检查是否缺少必要的术语说明注释或括号补充解释\n4. 列表项一致性：在并列的列表结构中，检测条目主语是否保持统一的命名规范"
    },
    {
      "defect_id": 476822,
      "sentence": "        - 划词服务<!--compress-->",
      "reference_sentence": "        - 压缩与解压<!--compress-->",
      "line_num": 1321,
      "context": "{\"1316\":\"          - [使用剪贴板进行延迟复制粘贴](basic-services/pasteboard/pasteboard-time-lapse-copy-and-paste.md)\",\"1317\":\"        - 上传下载<!--upload-download-->\",\"1318\":\"          - [应用文件上传下载](basic-services/request/app-file-upload-download.md)\",\"1319\":\"        - 压缩与解压<!--compress-->\",\"1320\":\"          - [压缩与解压](basic-services/compress/deflate-and-inflate.md)\",\"1321\":\"        - 划词服务<!--compress-->\",\"1322\":\"          - [划词服务概述](basic-services/selectionIput/selection-services-intro.md)\",\"1323\":\"          - [实现一个划词应用](basic-services/selectionIput/selection-services-application-guide.md)\",\"1324\":\"      - Function Flow Runtime Kit（任务并发调度服务）<!--ffrt-kit-->\",\"1325\":\"        - [Function Flow Runtime Kit概述](ffrt/ffrt-overview.md)\",\"1326\":\"        - [Function Flow Runtime并发范式](ffrt/ffrt-concurrency-paradigm.md)\"}",
      "修改建议": "混用了'划词服务'和'压缩与解压'，但它们的注释都是`<!--compress-->`，导致混淆",
      "更改后示例": "        - 划词服务<!--selectionIput-->",
      "触发条件": "当同一注释标识符被重复用于不同功能模块，或注释标识符与对应内容项的语义关联性不匹配时触发。\n\n识别模式：\n1. 检查相邻条目中是否存在相同注释标签但对应不同内容项的情况（如示例中<!--compress-->同时出现在\"压缩与解压\"和\"划词服务\"）\n2. 验证注释标签与内容项的语义一致性（如\"划词服务\"应关联selectionInput而非compress）\n3. 对比上下文条目注释标签的使用规律（如上传下载模块正确使用<!--upload-download-->的对应关系）"
    },
    {
      "defect_id": 478161,
      "sentence": "neverallow可以阻止不合理的策略配置，因此可以作为安全防护手段，避免本业务的SELinux业务被恶意修改。",
      "reference_sentence": "neverallow可以阻止不合理的策略配置，因此可以作为安全防护手段，避免本业务的SELinux业务被恶意修改。",
      "line_num": 63,
      "context": "{\"58\":\"allowxperm init data_app_el1_file:dir ioctl { 0x6613 };\",\"59\":\"```\",\"60\":\"\",\"61\":\"## 使用neverallow对业务做安全防护\",\"62\":\"\",\"63\":\"neverallow可以阻止不合理的策略配置，因此可以作为安全防护手段，避免本业务的SELinux业务被恶意修改。\",\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件理论上只允许本进程读写，那么可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\"}",
      "修改建议": "混用了'策略'和'业务'，建议保持一致。",
      "更改后示例": "neverallow可以阻止不合理的SELinux策略配置，因此可以作为安全防护手段，避免本业务的SELinux策略被恶意修改。",
      "触发条件": "同一上下文或技术主题中，核心术语（如\"SELinux策略\"）与不准确替代词（如\"业务\"）混用，且涉及重复出现的专业概念时。识别模式为：检查相邻句子中是否对同一技术要素（策略配置）使用了不同表述（策略/业务），导致概念混淆。"
    },
    {
      "defect_id": 478392,
      "sentence": "为避免对文件系统恶意破环，OpenHarmony将部分镜像挂载为只读，如system.img、vendor.img，这些镜像内的文件在编译阶段就会被赋予SELinux标签。",
      "reference_sentence": "为避免对文件系统恶意破坏，OpenHarmony将部分镜像挂载为只读，如system.img、vendor.img，这些镜像内的文件在编译阶段就会被赋予SELinux标签。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 只读分区新增文件\",\"4\":\"\",\"5\":\"**适用场景**\",\"6\":\"\",\"7\":\"为避免对文件系统恶意破环，OpenHarmony将部分镜像挂载为只读，如system.img、vendor.img，这些镜像内的文件在编译阶段就会被赋予SELinux标签。\",\"8\":\"\",\"9\":\"**配置指导**\",\"10\":\"1. 在file_contexts中，建立文件绝对路径与文件标签的映射关系，可以使用正则表达式。\",\"11\":\"    ```text\",\"12\":\"    /system/lib(/.*)?    u:object_r:system_lib_file:s0\"}",
      "修改建议": "“破环”应为“破坏”",
      "更改后示例": "为避免对文件系统恶意破坏，OpenHarmony将部分镜像挂载为只读，如system.img、vendor.img，这些镜像内的文件在编译阶段就会被赋予SELinux标签。",
      "触发条件": "检测到文档中存在与标准术语/常用拼写不一致的词汇（如\"破环\"vs\"破坏\"），或同一文档内出现相同术语的不同拼写形式。\n\n识别模式：\n1. 通过文本匹配检查词汇是否符合技术词典/领域术语库\n2. 利用拼写检查算法识别形近字错误（如汉字偏旁部首错误组合）\n3. 对比上下文重复出现的同类术语（如问题上下文多次出现\"破坏\"）进行一致性验证"
    },
    {
      "defect_id": 478236,
      "sentence": "编译SELinux时会进行neverallow检查，当配置的策略不合理时，可能出现违反neverallow编译报错。",
      "reference_sentence": "编译SELinux时会进行neverallow检查，当配置的策略不合理时，可能出现违反neverallow编译报错。",
      "line_num": 6,
      "context": "{\"1\":\"# OpenHarmony SELinux常见问题\",\"2\":\"\",\"3\":\"## neverallow编译报错处理\",\"4\":\"**现象描述**\",\"5\":\"\",\"6\":\"编译SELinux时会进行neverallow检查，当配置的策略不合理时，可能出现违反neverallow编译报错。\",\"7\":\"\",\"8\":\"```\",\"9\":\"neverallow check failed at obj/base/security/selinux_adapter/updater/system.cil:3887 from ../../base/security/selinux_adapter/sepolicy/base/public/domain.te:96\",\"10\":\"  (neverallow domain dev_parameters_file (file (write)))\",\"11\":\"    <root>\"}",
      "修改建议": "重复使用了“违反neverallow编译报错”，建议使用更具体的描述。",
      "更改后示例": "编译SELinux时会进行neverallow检查，当配置的策略不合理时，可能出现编译错误。",
      "触发条件": "同一句子中重复使用相同术语或短语（如\"违反neverallow编译报错\"），且上下文已明确该术语所指代的具体错误类型时。识别模式为检测到相邻分句/短语存在包含重复核心关键词（如\"neverallow\"）的冗余表达结构。"
    },
    {
      "defect_id": 477971,
      "sentence": "1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。",
      "reference_sentence": "1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进制策略文件加载到内核。",
      "line_num": 19,
      "context": "{\"14\":\"3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。\",\"15\":\"4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。\",\"16\":\"\",\"17\":\"### 策略加载\",\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\",\"19\":\"1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。\",\"20\":\"2. 然后根据配置文件`/system/etc/selinux/config`中SELINUX字段的值设置运行模式，`SELINUX=enforcing`时，设置为强制模式，`SELINUX=permissive`时，设置为宽容模式。从OpenHarmony 3.2开始，OpenHarmony SELinux默认以强制模式运行。\",\"21\":\"\",\"22\":\"## contexts编译与加载\",\"23\":\"OpenHarmony SELinux contexts包括`file_contexts`、`hdf_service_contexts`、`service_contexts`、`parameter_contexts`、`sehap_contexts`。这些文件不随策略编译而编译，需要单独归档。总体流程如图：\",\"24\":\"\"}",
      "修改建议": "用词不一致，'二进程策略文件'应统一为'二进制策略文件'",
      "更改后示例": "1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进制策略文件加载到内核。",
      "触发条件": "当文档中已存在明确定义的标准术语（如\"二进制策略文件\"），且后续内容出现同音/形近词（如\"二进程策略文件\"）导致术语不一致时触发。\n\n识别模式：\n1. 通过上下文扫描预先定义的术语（如第14、15条已出现3次\"二进制策略文件\"）\n2. 检测后续文本中是否存在发音相近（如\"进程/jincheng\" vs \"进制/jinzhi\"）或字形相似（\"进程\"与\"进制\"共享\"进\"字）的替代词\n3. 结合语义分析验证替代词是否破坏技术准确性（\"进程\"属于操作系统概念，与策略文件类型无关）"
    },
    {
      "defect_id": 478730,
      "sentence": "以下示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。",
      "reference_sentence": "以下示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。",
      "line_num": 21,
      "context": "{\"16\":\"| [@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)       | 使用该装饰器装饰一个继承自[IntentEntity](../reference/apis-ability-kit/js-apis-app-ability-insightIntent.md#intententity20)的类，可将该类定义为意图实体，用于传递意图调用时所需的参数。 |\",\"17\":\"| [IntentEntityDecoratorInfo](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#intententitydecoratorinfo)       | 用于描述@InsightIntentEntity装饰器支持的参数。 |\",\"18\":\"\",\"19\":\"## 开发指导\",\"20\":\"\",\"21\":\"1. 定义意图实体。以下示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。\",\"22\":\"\",\"23\":\"    ```ts\",\"24\":\"    import { insightIntent, InsightIntentEntity } from '@kit.AbilityKit';\",\"25\":\"    \",\"26\":\"    @InsightIntentEntity({\"}",
      "修改建议": "术语'InsightIntentEntity'在文中始终使用一致的表述，符合规则。",
      "更改后示例": "以下示例使用@InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。",
      "触发条件": "当技术文档中首次定义或引用特定术语后，后续表述出现未保持完全一致的命名格式（如缺少必要符号/前缀）时触发。\n\n识别模式：通过对比上下文中的标准术语引用形式（如问题上下文第16行带@符号的[@InsightIntentEntity]），检测当前句子是否出现符号缺失（如\"InsightIntentEntity\"未加@）、大小写不一致或结构偏差等非标准化表述。"
    },
    {
      "defect_id": 479119,
      "sentence": "DevEco Studio下载网址：https://developer.huawei.com/consumer/cn/deveco-studio/",
      "reference_sentence": "DevEco Studio下载网址：https://developer.huawei.com/consumer/cn/deveco-studio/",
      "line_num": 117,
      "context": "{\"112\":\"\",\"113\":\"### 迁移前环境准备\",\"114\":\"\",\"115\":\"#### **DevEco Studio下载安装**\",\"116\":\"\",\"117\":\"DevEco Studio下载网址：https://developer.huawei.com/consumer/cn/deveco-studio/\",\"118\":\"\",\"119\":\"1、进入网址后，点击**立即下载**，如下图所示：\",\"120\":\"\",\"121\":\"![mig2](figures/mig2.png) \",\"122\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "从以下网址下载DevEco Studio：https://developer.huawei.com/consumer/cn/deveco-studio/",
      "触发条件": "当文档中操作步骤或指导性内容出现陈述句与祈使句混合使用时，且上下文存在统一句式规范（如步骤列表默认使用祈使句）。具体表现为：当前句子为\"名词短语+冒号\"结构描述操作，而相邻步骤使用动词开头的祈使句结构。"
    },
    {
      "defect_id": 479113,
      "sentence": "由于ArkTS1.2和ArkTS1.1存在差异，所以借助迁移工具提供检查语法差异和自动修复代码功能，帮助开发者完成迁移。",
      "reference_sentence": "由于ArkTS1.2和ArkTS1.1存在差异，所以借助迁移工具提供检查语法差异和自动修复代码功能，帮助开发者完成迁移。",
      "line_num": 5,
      "context": "{\"1\":\"# 迁移工具使用指导\",\"2\":\"\",\"3\":\"## 背景\",\"4\":\"\",\"5\":\"由于ArkTS1.2和ArkTS1.1存在差异，所以借助迁移工具提供检查语法差异和自动修复代码功能，帮助开发者完成迁移。\",\"6\":\"\",\"7\":\"## 工具地址:\",\"8\":\"\",\"9\":\"从日构建中下载 OpenHarmony_feature_20250328 分支的 SDK \",\"10\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "使用迁移工具检查语法差异并自动修复代码，帮助开发者完成迁移。",
      "触发条件": "在操作指导或步骤说明的上下文中，检测到因果复句结构（如\"由于...所以...\"）与相邻操作指令的祈使句式产生混合句式冲突时触发。\n\n识别模式：\n1. 语法特征：句子包含因果连词（如\"由于\"）和结果引导词（如\"所以\"）\n2. 语境特征：出现在操作指南章节（如\"## 工具地址:\"前的内容模块）\n3. 句式冲突：因果陈述句与相邻操作步骤的祈使句式（如\"从日构建中下载...\"）形成语体不一致\n4. 语义特征：后半句包含明确的用户操作指引（\"借助迁移工具提供...功能\"）"
    },
    {
      "defect_id": 479350,
      "sentence": "删除系统保留用户。",
      "reference_sentence": "删除系统保留帐号。",
      "line_num": 162,
      "context": "{\"157\":\"The specified account is restricted.\",\"158\":\"\",\"159\":\"**可能原因**\",\"160\":\"\",\"161\":\"该错误码表示操作的是受限账号，可能原因如下：\",\"162\":\"1. 删除系统保留用户。\",\"163\":\"2. 查询系统保留用户的约束源类型。\",\"164\":\"3. 创建id为0-100的账号。\",\"165\":\"\",\"166\":\"**处理步骤**\",\"167\":\"\"}",
      "修改建议": "混用了“用户”和“帐号”",
      "更改后示例": "删除系统保留帐号。",
      "触发条件": "同一上下文或相邻句子中混用多个术语指代同一概念（如“用户”与“帐号”），且存在已定义的参考术语（如“帐号”）时触发。"
    },
    {
      "defect_id": 479351,
      "sentence": "查询系统保留用户的约束源类型。",
      "reference_sentence": "查询系统保留帐号的约束源类型。",
      "line_num": 163,
      "context": "{\"158\":\"\",\"159\":\"**可能原因**\",\"160\":\"\",\"161\":\"该错误码表示操作的是受限账号，可能原因如下：\",\"162\":\"1. 删除系统保留用户。\",\"163\":\"2. 查询系统保留用户的约束源类型。\",\"164\":\"3. 创建id为0-100的账号。\",\"165\":\"\",\"166\":\"**处理步骤**\",\"167\":\"\",\"168\":\"指定id为系统保留用户，无法操作。\"}",
      "修改建议": "混用了“用户”和“帐号”",
      "更改后示例": "查询系统保留帐号的约束源类型。",
      "触发条件": "同一文档或上下文中，同一概念使用不一致的术语（如“用户”与“帐号”混用），或与预定义术语库（如参考句中的“帐号”）存在冲突时触发。\n\n识别模式：通过比对邻近句子（如问题上下文第162行“用户”与第164行“账号”）、关联操作描述（如“删除”与“创建”动作的受控对象），以及预定义术语标准（如参考句明确使用“帐号”），检测同质概念的多重表述差异。"
    },
    {
      "defect_id": 479471,
      "sentence": "该错误码表示提供了可信等级不支持，可能原因如下：",
      "reference_sentence": "该错误码表示提供了认证类型不支持，可能原因如下：",
      "line_num": 406,
      "context": "{\"401\":\"\",\"402\":\"The trust level is not supported.\",\"403\":\"\",\"404\":\"**可能原因**\",\"405\":\"\",\"406\":\"该错误码表示提供了可信等级不支持，可能原因如下：\",\"407\":\"传入系统不支持的可信等级。\",\"408\":\"\",\"409\":\"**处理步骤**\",\"410\":\"\",\"411\":\"请输入正确的可信等级。\"}",
      "修改建议": "混用了'可信等级'和'认证类型'概念",
      "更改后示例": "该错误码表示可信等级不支持，可能原因如下：",
      "触发条件": "同一上下文或相邻条目中混用多个相似术语（如“可信等级”和“认证类型”），且与参考句式/核心参数命名出现概念性表述冲突。  \n\n识别模式：  \n1. **术语对比**：当句子核心参数（如\"可信等级\"）与同系列错误码描述（如\"认证类型\"）、接口字段或用户指南定义的关键术语不一致时  \n2. **结构异常**：句式结构（如\"提供了X不支持\" vs \"X不支持\"）与上下文标准表达模式存在差异，且影响概念准确性时"
    },
    {
      "defect_id": 479473,
      "sentence": "该错误码表示提供了认证类型不支持，可能原因如下：",
      "reference_sentence": "该错误码表示认证类型不存在，可能原因如下：",
      "line_num": 421,
      "context": "{\"416\":\"\",\"417\":\"The authentication type is not supported.\",\"418\":\"\",\"419\":\"**可能原因**\",\"420\":\"\",\"421\":\"该错误码表示提供了认证类型不支持，可能原因如下：\",\"422\":\"传入系统不支持的认证类型。\",\"423\":\"\",\"424\":\"**处理步骤**\",\"425\":\"\",\"426\":\"请提供系统支持的认证类型。\"}",
      "修改建议": "混用了'提供了'和'不存在'，以及'认证类型'概念",
      "更改后示例": "该错误码表示认证类型不支持，可能原因如下：",
      "触发条件": "同一上下文或相邻条目中对同一概念使用不一致的动词/修饰结构（如\"提供了认证类型\"与\"认证类型不存在\"），或与参考句式存在关键成分偏差（如冗余动作描述\"提供了\"）。通过比对相邻错误码描述句式及核心名词短语结构（\"X不存在\"/\"X不支持\"）识别需修复的不匹配表达。"
    },
    {
      "defect_id": 479483,
      "sentence": "2. 修改密码或删除已有密码。",
      "reference_sentence": "1. 请重试或重启系统。",
      "line_num": 575,
      "context": "{\"570\":\"2. 用户已有对应类型的密码，不能再添加密码。\",\"571\":\"\",\"572\":\"**处理步骤**\",\"573\":\"\",\"574\":\"1. 请重试或重启系统。\",\"575\":\"2. 修改密码或删除已有密码。\",\"576\":\"\",\"577\":\"## 12300116 凭证复杂度验证失败\",\"578\":\"\",\"579\":\"**错误信息**\",\"580\":\"\"}",
      "修改建议": "句式不一致，应使用祈使句",
      "更改后示例": "请修改密码或删除已有密码。",
      "触发条件": "当同一列表项或相邻步骤中存在句式结构不一致（如祈使句与非祈使句混用）且上下文已建立统一表达模式（如\"请X或Y\"结构）时触发。\n\n识别模式：\n1. 检测并列结构中的动词短语是否缺失统一引导词（如\"请\"）\n2. 对比相邻条目句式（如步骤1使用完整祈使句，步骤2却省略引导词）\n3. 验证上下文是否已形成特定表达惯例（如错误处理步骤均以\"请\"开头）"
    },
    {
      "defect_id": 479481,
      "sentence": "2. 按照规范开发应用认证器。",
      "reference_sentence": "1. 请重试或重启系统。",
      "line_num": 559,
      "context": "{\"554\":\"2. 应用认证器不符合规范；\",\"555\":\"\",\"556\":\"**处理步骤**\",\"557\":\"\",\"558\":\"1. 请重试或重启系统。\",\"559\":\"2. 按照规范开发应用认证器。\",\"560\":\"\",\"561\":\"## 12300115 用户认证密码个数达到上限\",\"562\":\"\",\"563\":\"**错误信息**\",\"564\":\"\"}",
      "修改建议": "句式不一致，应使用祈使句",
      "更改后示例": "请按照规范开发应用认证器。",
      "触发条件": "同一列表或连续条目中存在句式不一致（如部分条目缺少祈使句标志词\"请\"），且上下文存在同类表达范式时触发。\n\n识别模式：\n1. 检测相邻条目是否采用相同语法结构（如\"请+动词\"开头的祈使句）\n2. 对比当前条目与同组条目是否存在语气词、助动词缺失\n3. 验证上下文是否存在明确的一致性参照标准（如参考句式的\"请+动词\"结构）"
    },
    {
      "defect_id": 482837,
      "sentence": "OEM厂商可以采用插件方式定制化域账号管理能力，系统提供了域账号插件注册和注销能能力。",
      "reference_sentence": "OEM厂商可以采用插件方式定制化域账号管理能力，系统提供了域账号插件注册和注销能力。",
      "line_num": 3,
      "context": "{\"1\":\"# 管理域账号插件（仅对系统应用开放）\",\"2\":\"\",\"3\":\"OEM厂商可以采用插件方式定制化域账号管理能力，系统提供了域账号插件注册和注销能能力。\",\"4\":\"\",\"5\":\"## 开发准备\",\"6\":\"\",\"7\":\"1. 申请权限，申请流程请参考：[申请应用权限](../../security/AccessToken/determine-application-mode.md#system_basic等级应用申请权限的方式)。\",\"8\":\"   - ohos.permission.MANAGE_LOCAL_ACCOUNTS\"}",
      "修改建议": "‘能能力’重复，应简化为‘能力’。",
      "更改后示例": "OEM厂商可以采用插件方式定制化域账号管理能力，系统提供了域账号插件注册和注销能力。",
      "触发条件": "检测到文本中存在相邻重复字符（如\"能能力\"中的\"能能\"），导致词语冗余或语义错误时触发。识别模式需定位到连续两个相同汉字构成的异常叠字结构，且该结构不符合目标词语的正确拼写规范。"
    },
    {
      "defect_id": 482884,
      "sentence": "1. 定义认证参数（以人脸认证为例），包括挑战值、认证类型、认证可性等级。",
      "reference_sentence": "1. 定义认证参数，包括挑战值、认证类型、认证可信等级。",
      "line_num": 197,
      "context": "{\"192\":\"\",\"193\":\"录入完生物识别凭据后，用户可以进行生物识别认证。类似PIN码认证，开发者可以使用[auth](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#auth8)接口完成此操作。\",\"194\":\"\",\"195\":\"具体开发实例如下：\",\"196\":\"\",\"197\":\"1. 定义认证参数（以人脸认证为例），包括挑战值、认证类型、认证可性等级。\",\"198\":\"\",\"199\":\"   ```ts\",\"200\":\"   let challenge: Uint8Array = new Uint8Array([1, 2, 3, 4, 5]);\",\"201\":\"   let authType: osAccount.AuthType = osAccount.AuthType.FACE;\",\"202\":\"   let authTrustLevel: osAccount.AuthTrustLevel = osAccount.AuthTrustLevel.ATL1;\"}",
      "修改建议": "混用了'认证可性等级'和'认证可信等级'的表述。",
      "更改后示例": "1. 定义认证参数（以人脸认证为例），包括挑战值、认证类型、认证可信等级。",
      "触发条件": "当同一术语在文档中出现不同表达形式（如\"认证可性等级\"与\"认证可信等级\"），且与上下文参数定义（如authTrustLevel）或参考句式（如\"认证可信等级\"）存在用词矛盾时触发。\n\n识别模式：通过对比术语构词逻辑（\"可性\"vs\"可信\"）、参数命名一致性（TrustLevel对应\"可信\"）、以及参考句式的标准表达，识别出非常规缩略词或异形词使用情况。"
    },
    {
      "defect_id": 483003,
      "sentence": "  | distributedInfo | [DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是 | 分布式账户信息。 |",
      "reference_sentence": "  | distributedInfo | [DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是 | 分布式账号信息。 |",
      "line_num": 189,
      "context": "{\"184\":\"**参数：**\",\"185\":\"\",\"186\":\"  | 参数名 | 类型 | 必填 | 说明 |\",\"187\":\"  | -------- | -------- | -------- | -------- |\",\"188\":\"  | localId | number | 是 | 系统账号ID。 |\",\"189\":\"  | distributedInfo | [DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是 | 分布式账户信息。 |\",\"190\":\"\",\"191\":\"**返回值：**\",\"192\":\"\",\"193\":\"  | 类型 | 说明 |\",\"194\":\"  | -------- | -------- |\"}",
      "修改建议": "用词不一致，应统一为'分布式账号信息'",
      "更改后示例": "  | distributedInfo | [DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是 | 分布式账号信息。 |",
      "触发条件": "当文档中同一技术术语存在\"账户/账号\"类同义词混用，且上下文已有明确统一用词标准时，检测到术语表达不一致的情况应触发规则。识别模式为匹配中文近义词对（如账户/账号）在相同语义场景下的非统一使用。"
    },
    {
      "defect_id": 483197,
      "sentence": "The account indicated by serialNumber dose not exist.",
      "reference_sentence": "The account indicated by serialNumber does not exist.",
      "line_num": 1547,
      "context": "{\"1542\":\"| 错误码ID | 错误信息               |\",\"1543\":\"| -------- | ------------------- |\",\"1544\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. |\",\"1545\":\"| 12300001 | The system service works abnormally. |\",\"1546\":\"| 12300002 | Invalid serialNumber. |\",\"1547\":\"| 12300003 | The account indicated by serialNumber dose not exist. |\",\"1548\":\"\",\"1549\":\"**示例：** 查询与SN码12345关联的系统账号的ID\",\"1550\":\"\",\"1551\":\"  ```ts\",\"1552\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "拼写错误，'dose'应为'does'。",
      "更改后示例": "The account indicated by serialNumber does not exist.",
      "触发条件": "检测到文档中存在拼写错误（如dose/does等同音异形词拼写错误），且错误出现在技术参数/错误码列表等需要严格术语规范的上下文中。\n\n识别模式：通过预定义的易混淆词汇对（常见拼写错误映射表）进行匹配，结合上下文特征（如表格内错误码描述、技术参数说明等格式化文本区域）进行双重验证。"
    },
    {
      "defect_id": 483301,
      "sentence": "回调函数，如果获取成功，err为null，data为域账号关联的系统账号ID；否则为错误对象。",
      "reference_sentence": "回调函数。当获取成功时，err为null，data为当前进程所属的系统账号ID；否则为错误对象。",
      "line_num": 2259,
      "context": "{\"2254\":\"**参数：**\",\"2255\":\"\",\"2256\":\"| 参数名     | 类型                                    | 必填 | 说明                                                                         |\",\"2257\":\"| ---------- | --------------------------------------- | ---- | --------------------------------------------------------------------------- |\",\"2258\":\"| domainInfo | [DomainAccountInfo](#domainaccountinfo8) | 是   | 域账号信息。                                                                |\",\"2259\":\"| callback   | AsyncCallback&lt;number&gt;             | 是   | 回调函数，如果获取成功，err为null，data为域账号关联的系统账号ID；否则为错误对象。 |\",\"2260\":\"\",\"2261\":\"**示例：**\",\"2262\":\"\",\"2263\":\"  ```ts\",\"2264\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "前后描述不一致，一个使用'如果获取成功'，另一个使用'当获取成功时'。",
      "更改后示例": "回调函数，当获取成功时，err为null，data为域账号关联的系统账号ID；否则为错误对象。",
      "触发条件": "同一语境下出现\"如果\"与\"当...时\"两种条件引导词混用，且存在文档内统一的表达范式（如参考句中的\"当...时\"结构）时触发。"
    },
    {
      "defect_id": 483242,
      "sentence": "> 从API version 7开始支持从API version 9开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9)。",
      "line_num": 1761,
      "context": "{\"1756\":\"\",\"1757\":\"判断指定系统账号是否处于激活状态。使用Promise异步回调。\",\"1758\":\"\",\"1759\":\"> **说明：**\",\"1760\":\">\",\"1761\":\"> 从API version 7开始支持从API version 9开始废弃。替代方法仅向系统应用开放。\",\"1762\":\"\",\"1763\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"1764\":\"\",\"1765\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1766\":\"\"}",
      "修改建议": "句子结构不一致，缺少逗号分隔，建议使用统一的句式结构。",
      "更改后示例": "> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。",
      "触发条件": "同一句子中存在多个相同句式结构（如\"从API version X开始...\"）的时间点说明，且缺乏标点分隔导致结构粘连时触发。通过识别重复的关键词模式（如连续出现\"开始支持\"和\"开始废弃\"）及缺失的逗号分隔符进行问题定位。"
    },
    {
      "defect_id": 483232,
      "sentence": "从API version 7开始支持从API version 9开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。",
      "line_num": 1725,
      "context": "{\"1720\":\"\",\"1721\":\"判断指定系统账号是否处于激活状态。使用callback异步回调。\",\"1722\":\"\",\"1723\":\"> **说明：**\",\"1724\":\">\",\"1725\":\"> 从API version 7开始支持从API version 9开始废弃。替代方法仅向系统应用开放。\",\"1726\":\"\",\"1727\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"1728\":\"\",\"1729\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1730\":\"\"}",
      "修改建议": "前后句子中缺少逗号，导致句子结构不一致。",
      "更改后示例": "从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。",
      "触发条件": "当相邻句子或短语使用相同语法结构（如“从API version X开始...”）但缺少标点分隔时，或同一语境下出现重复句式导致结构粘连时触发。识别模式为检测连续重复的\"时间状语+动作描述\"句式且无逗号分隔的情况。"
    },
    {
      "defect_id": 483263,
      "sentence": "返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。",
      "reference_sentence": "返回true表示指定账号已验证；返回false表示指定账号未验证。",
      "line_num": 1887,
      "context": "{\"1882\":\"\",\"1883\":\"**参数：**\",\"1884\":\"\",\"1885\":\"| 参数名   | 类型                         | 必填 | 说明                                                                   |\",\"1886\":\"| -------- | ---------------------------- | ---- | --------------------------------------------------------------------- |\",\"1887\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。 |\",\"1888\":\"\",\"1889\":\"**示例：**\",\"1890\":\"\",\"1891\":\"  ```ts\",\"1892\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "混用了'为'和'已'的表述。",
      "更改后示例": "返回true表示当前账号已验证为测试账号；返回false表示当前账号未验证为测试账号。",
      "触发条件": "当同一组正反描述中混用不同动词修饰词（如\"为\"与\"已\"）造成表述不对称，且上下文存在技术参数说明需要严格对应关系时触发。\n\n识别模式：\n1. 检测对仗结构（如true/false返回值说明）中是否出现\"为/非\"与\"已验证/未验证\"等不同修饰词混用\n2. 验证技术参数描述场景下，同一参数的正反状态说明是否采用统一时态/语态（如应保持\"已验证/未验证\"的完成时态一致性）"
    },
    {
      "defect_id": 483264,
      "sentence": "返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。",
      "reference_sentence": "返回true表示指定账号已验证；返回false表示指定账号未验证。",
      "line_num": 1919,
      "context": "{\"1914\":\"\",\"1915\":\"**返回值：**\",\"1916\":\"\",\"1917\":\"| 类型                   | 说明                                                                      |\",\"1918\":\"| ---------------------- | ------------------------------------------------------------------------ |\",\"1919\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。 |\",\"1920\":\"\",\"1921\":\"**示例：**\",\"1922\":\"\",\"1923\":\"  ```ts\",\"1924\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "混用了'为'和'已'的表述。",
      "更改后示例": "返回true表示当前账号已验证为测试账号；返回false表示当前账号未验证为测试账号。",
      "触发条件": "当文档中并列的肯定/否定描述存在动词短语结构不一致（如\"为测试账号\"/\"非测试账号\"混用状态修饰词），且同一上下文存在已验证/未验证等规范表述时触发。"
    },
    {
      "defect_id": 483289,
      "sentence": "获取当前进程所属的系统账号ID，使用Promise异步回调。",
      "reference_sentence": "获取当前进程所属的系统账号ID，使用callback异步回调。",
      "line_num": 2143,
      "context": "{\"2138\":\"\",\"2139\":\"### getOsAccountLocalIdFromProcess<sup>(deprecated)</sup>\",\"2140\":\"\",\"2141\":\"getOsAccountLocalIdFromProcess(): Promise&lt;number&gt;\",\"2142\":\"\",\"2143\":\"获取当前进程所属的系统账号ID，使用Promise异步回调。\",\"2144\":\"\",\"2145\":\"> **说明：**\",\"2146\":\">\",\"2147\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalId](#getosaccountlocalid9-1)。\",\"2148\":\"\"}",
      "修改建议": "混用了'callback'和'Promise'描述异步回调方式",
      "更改后示例": "获取当前进程所属的系统账号ID。使用Promise异步回调。",
      "触发条件": "同一文档或相邻上下文中存在异步回调术语（如callback/Promise）不一致，且与参考句子或既定术语冲突时触发。需识别相邻句子/段落是否混用不同异步机制描述，并与API版本推荐术语对比。"
    },
    {
      "defect_id": 483355,
      "sentence": "系统账号激是否激活",
      "reference_sentence": "系统账号激活状态",
      "line_num": 2986,
      "context": "{\"2981\":\"| photo<sup>8+</sup>             | string                                                       | 是   | 系统账号头像，默认为空。                      |\",\"2982\":\"| createTime<sup>8+</sup>        | number                                                       | 是   | 系统账号创建时间。                  |\",\"2983\":\"| lastLoginTime<sup>8+</sup>     | number                                                       | 是   | 系统账号最后一次登录时间，默认为空。          |\",\"2984\":\"| serialNumber<sup>8+</sup>      | number                                                       | 是   | 系统账号SN码。                      |\",\"2985\":\"| isActived<sup>(deprecated)</sup>         | boolean                                            | 是   | 系统账号激活状态。true表示指定账号处于激活状态；false表示指定账号处于未激活状态。<br>**说明**：从API version 7开始支持，从API version 11开始废弃。                  |\",\"2986\":\"| isActivated<sup>11+</sup>         | boolean                                                   | 是   | 系统账号激是否激活。true表示指定账号已激活；false表示指定账号未激活。                  |\",\"2987\":\"| isCreateCompleted<sup>8+</sup> | boolean                                                      | 是   | 系统账号创建是否完整。true表示指定账号已创建完整；false表示指定账号未创建完整。              |\",\"2988\":\"| distributedInfo                | [distributedAccount.DistributedInfo](js-apis-distributed-account.md#distributedinfo) | 是   | 分布式账号信息，默认为空。                    |\",\"2989\":\"| domainInfo<sup>8+</sup>        | [DomainAccountInfo](#domainaccountinfo8)                      | 是   | 域账号信息，默认为空。                        |\",\"2990\":\"\",\"2991\":\"## DomainAccountInfo<sup>8+</sup>\"}",
      "修改建议": "用词不一致，'激'与'激活'混用",
      "更改后示例": "系统账号是否激活",
      "触发条件": "当同一术语在相邻上下文或关联字段中出现不一致的缩写/全称混用（如\"激\"与\"激活\"），或存在冗余词语组合（如\"激是否激活\"中的重复表意）时触发。\n\n识别模式：\n1. 术语截断检测：识别核心术语（如\"激活\"）被非常规截断（如\"激\"）且缺乏明确注释的情况\n2. 上下文对比验证：当相邻字段存在正确用法（如\"激活状态\"）时，强化对异常缩写的敏感度\n3. 语义重复判断：检测\"是否\"判断句式中的冗余组合（动词片段+完整动词），如\"激是否激活\"中的双重表意"
    },
    {
      "defect_id": 488998,
      "sentence": "非焦点态背景色不支持设置透明度，即ARGB颜色中的透明度alpha值必须固定为`'FF'`",
      "reference_sentence": "非焦点态背景色不支持设置透明度，即ARGB颜色中的透明度alpha值必须固定为`'FF'`",
      "line_num": 855,
      "context": "{\"850\":\"**参数：**\",\"851\":\"\",\"852\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"853\":\"| ----- | ------ | -- | ----------------------------------------------------------------------- |\",\"854\":\"| activeColor | string | 是 | 窗口容器处于焦点态时的背景色，为十六进制RGB或ARGB颜色，不区分大小写，例如`'#00FF00'`或`'#FF00FF00'`。|\",\"855\":\"| inactiveColor | string | 是 | 窗口容器处于非焦点态时的背景色，为十六进制RGB或ARGB颜色，不区分大小写，例如`'#00FF00'`或`'#FF00FF00'`。<br>非焦点态背景色不支持设置透明度，即ARGB颜色中的透明度alpha值必须固定为`'FF'`|\",\"856\":\"\",\"857\":\"**错误码：**\",\"858\":\"\",\"859\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[窗口错误码](errorcode-window.md)。\",\"860\":\"\"}",
      "修改建议": "混用了'透明度'和'透明度alpha值'，应统一使用'透明度alpha值'。",
      "更改后示例": "非焦点态背景色不支持设置透明度alpha值，即ARGB颜色中的透明度alpha值必须固定为`'FF'`",
      "触发条件": "同一技术参数在相邻语句中存在术语混用（如\"透明度\"与\"透明度alpha值\"交替出现），且上下文已建立明确的技术术语标准（如参考句使用\"透明度alpha值\"）。"
    },
    {
      "defect_id": 487064,
      "sentence": "设置预览图宽高的可布局区域，预览图的百分比依据此设置计算，最终可能因安全区限制而被压缩或裁剪。",
      "reference_sentence": "布局空间不足时，控制预览图的缩放方式。未设置或设置undefined按照PreviewScaleMode.AUTO处理。当设置成PreviewScaleMode.CONSTANT时，如果预览图过大，剩余的空间不足以放置菜单时，菜单将重叠显示在预览图之下。",
      "line_num": 186,
      "context": "{\"181\":\"| onWillAppear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单显示动效前的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br/>2.aboutToAppear是初始化时触发调用，onWillAppear是在动画执行前触发调用，onWillAppear在aboutToAppear之后执行。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"182\":\"| onDidAppear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单弹出时的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br />2.快速点击弹出，消失菜单时，存在onWillDisappear在onDidAppear前生效。<br />3. 当菜单入场动效未完成时关闭菜单，该回调不会触发。<br/>4.onAppear和onDidAppear触发时机相同，onDidAppear在onAppear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"183\":\"| onWillDisappear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单退出动效前的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br />2.快速点击弹出，消失菜单时，存在onWillDisappear在onDidAppear前生效。<br/>3.aboutToDisappear和onWillDisappear触发时机相同，onWillDisappear在aboutToDisappear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"184\":\"| onDidDisappear<sup>20+</sup> | [Callback&lt;void&gt;](ts-types.md#callback12) | 否 | 菜单消失时的事件回调。<br />**说明：**<br />1.正常时序依次为：aboutToAppear>>onWillAppear>>onAppear>>onDidAppear>>aboutToDisappear>>onWillDisappear>>onDisappear>>onDidDisappear。<br/>2.onDisappear和onDidDisappear触发时机相同，onDidDisappear在onDisappear后生效。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"185\":\"| previewScaleMode<sup>20+</sup> | [PreviewScaleMode](#previewscalemode20类型说明) | 否 | 预览图缩放方式。<br />默认值：PreviewScaleMode.AUTO<br />**说明：**<br />布局空间不足时，控制预览图的缩放方式。未设置或设置undefined按照PreviewScaleMode.AUTO处理。当设置成PreviewScaleMode.CONSTANT时，如果预览图过大，剩余的空间不足以放置菜单时，菜单将重叠显示在预览图之下。<br />预览图的最大宽高不会超过预览图最大可布局区域（窗口大小减去上下左右的安全边距）。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"186\":\"| availableLayoutArea<sup>20+</sup> | [AvailableLayoutArea](#availablelayoutarea20类型说明) | 否 | 设置预览图宽高的可布局区域，预览图的百分比依据此设置计算，最终可能因安全区限制而被压缩或裁剪。 <br /> **说明：** <br /> 未设置或设置为undefined时，百分比依据窗口大小计算。若设置为AvailableLayoutArea.SAFE_AREA，预览图的可布局区域为：窗口大小减去上下左右的安全边距。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"187\":\"\",\"188\":\"## MenuPreviewMode<sup>11+</sup>\",\"189\":\"\",\"190\":\"菜单的预览样式。\",\"191\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一概念，'安全区限制'与'安全边距'应统一",
      "更改后示例": "设置预览图宽高的可布局区域，预览图的百分比依据此设置计算，最终可能因安全边距限制而被压缩或裁剪。",
      "触发条件": "同一技术概念在相邻上下文或关联参数说明中使用了不同术语表述（如\"安全区\"与\"安全边距\"），且存在已定义的规范术语（如参考句中的\"安全边距\"）时触发。\n\n识别模式：\n1. 检测相邻段落/参数说明中是否存在同义技术术语的变体（如\"区\"与\"边距\"的表述差异）\n2. 验证文档前文是否已明确定义规范术语（如185行明确使用\"安全边距\"）\n3. 判断术语差异是否会导致用户对同一技术要素的理解歧义"
    },
    {
      "defect_id": 491061,
      "sentence": "注意事项：**目前迁移工具不会扫描oh_modules下的文件，想要扫描/迁移，得先把下载好的三方库拷贝出来，才能进行后续操作**",
      "reference_sentence": "注意事项：**目前迁移工具不会扫描oh_modules下的文件，想要扫描/迁移，需要先把下载好的三方库拷贝出来，才能进行后续操作**",
      "line_num": 226,
      "context": "{\"221\":\"\",\"222\":\"![mig13](figures/mig13.png) \",\"223\":\"\",\"224\":\"### 三方库迁移\",\"225\":\"\",\"226\":\"注意事项：**目前迁移工具不会扫描oh_modules下的文件，想要扫描/迁移，得先把下载好的三方库拷贝出来，才能进行后续操作** \",\"227\":\"\",\"228\":\"```js\",\"229\":\"//通用命令\",\"230\":\"node dist/tslinter.js --ide-interactive --arkts-2 --autofix --migrate --project-folder <三方库文件夹>\",\"231\":\"   \"}",
      "修改建议": "“得”和“需要”用词不一致，建议统一。",
      "更改后示例": "注意事项：**目前迁移工具不会扫描oh_modules下的文件，想要扫描/迁移，需要先把下载好的三方库拷贝出来，才能进行后续操作**",
      "触发条件": "同一文档或上下文存在相同/相似语义表达时，出现用词不一致（如\"得\"与\"需要\"混用），且存在可对齐的参考表达（如其他注意事项或规范示例）。"
    },
    {
      "defect_id": 491060,
      "sentence": "依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。",
      "reference_sentence": "依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。",
      "line_num": 214,
      "context": "{\"209\":\"\\\"dependencies\\\": {\",\"210\":\"    \\\"@ibestservices/ibest-ui\\\": \\\"^2.1.0\\\"\",\"211\":\"  }\",\"212\":\"```\",\"213\":\"\",\"214\":\"​      依赖设置完成后，需要执行ohpm install命令安装依赖包，依赖包会存储在工程的oh_modules目录下。\",\"215\":\"\",\"216\":\"```\",\"217\":\"ohpm install\",\"218\":\"```\",\"219\":\"\"}",
      "修改建议": "句式一致，但建议使用祈使句以保持风格一致。",
      "更改后示例": "执行ohpm install命令安装依赖包，依赖包将存储在工程的oh_modules目录下。",
      "触发条件": "当操作步骤描述中存在混合使用陈述句与祈使句的情况，且上下文存在统一使用祈使句的指令模式时触发。具体通过检测\"需要/请/应\"等助动词与直接动词开头的句式冲突进行识别。"
    },
    {
      "defect_id": 491754,
      "sentence": "| value     | bigint                            | 是   | 执行运算的操作数。         |\r",
      "reference_sentence": "| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |\r",
      "line_num": 78,
      "context": "{\"73\":\"**参数：**\",\"74\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"75\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"76\":\"| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\",\"77\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"78\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"79\":\"\",\"80\":\"**返回值：** \",\"81\":\"| 类型        | 说明                         |\",\"82\":\"| ----------- | --------------------------- |\",\"83\":\"| bigint      | typedArray[index]被修改之前的值。   |\"}",
      "修改建议": "混用了`bigint`和`number`，导致类型不一致",
      "更改后示例": "| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |\r",
      "触发条件": "当同一文档中相同参数的类型描述存在术语不一致（如bigint与number混用），或参数类型与上下文其他参数类型体系不匹配时触发。"
    },
    {
      "defect_id": 491756,
      "sentence": "| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |\r",
      "reference_sentence": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\r",
      "line_num": 112,
      "context": "{\"107\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"108\":\"\",\"109\":\"**参数：**\",\"110\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"111\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"112\":\"| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |\",\"113\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。    |\",\"114\":\"| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |\",\"115\":\"\",\"116\":\"**返回值：** \",\"117\":\"| 类型        | 说明                         |\"}",
      "修改建议": "混用了`smalltypeArray`，应保持一致",
      "更改后示例": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\r",
      "触发条件": "同一文档上下文中存在同一术语的拼写、大小写或格式不一致，且相邻参数/条目已建立明确的命名规范（如驼峰式）。例如参数表中的参数名出现\"smalltypeArray\"与\"smallTypeArray\"混合形式时触发。"
    },
    {
      "defect_id": 491755,
      "sentence": "| bigint      | typedArray[index]被修改之前的值。   |\r",
      "reference_sentence": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\r",
      "line_num": 83,
      "context": "{\"78\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"79\":\"\",\"80\":\"**返回值：** \",\"81\":\"| 类型        | 说明                         |\",\"82\":\"| ----------- | --------------------------- |\",\"83\":\"| bigint      | typedArray[index]被修改之前的值。   |\",\"84\":\"\",\"85\":\"**错误信息**\",\"86\":\"| 错误信息        | 说明                         |\",\"87\":\"| ----------- | --------------------------- |\",\"88\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "混用了`bigint`和`number`，导致类型不一致",
      "更改后示例": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\r",
      "触发条件": "当同一参数/返回值的类型描述在文档不同位置出现冲突（如bigint vs number），且存在明确参考依据（如正确类型定义）时触发。"
    },
    {
      "defect_id": 491696,
      "sentence": "执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。",
      "reference_sentence": "要操作的数组。",
      "line_num": 42,
      "context": "{\"37\":\"**参数：**\",\"38\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"39\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"40\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"41\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"42\":\"| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。        |\",\"43\":\"\",\"44\":\"**返回值：** \",\"45\":\"| 类型        | 说明                         |\",\"46\":\"| ----------- | --------------------------- |\",\"47\":\"| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\"}",
      "修改建议": "使用了不同的词汇描述同一事物，'执行运算'与'操作'。",
      "更改后示例": "要操作的元素，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。",
      "触发条件": "同一文档中相邻或相关条目对同一概念使用不同动词短语（如\"执行运算\"与\"操作\"），且上下文存在明确统一的术语参照（如\"要操作的数组\"）。\n\n识别模式：\n1. 在参数说明/返回值等结构化描述场景中\n2. 同一参数链（如value参数与返回值）出现对同一实体的不同动作描述\n3. 存在明显的术语参照锚点（如参数typedArray的\"要操作的\"描述）\n4. 动词短语差异导致概念表述分裂（操作数 vs 操作元素）"
    },
    {
      "defect_id": 491694,
      "sentence": "此方法返回typedArray[index]被修改之前的值。",
      "reference_sentence": "此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。",
      "line_num": 34,
      "context": "{\"29\":\"## add\",\"30\":\"\",\"31\":\"static add(typedArray: smalltypeArray, index: int, value: number): number  \",\"32\":\"\",\"33\":\"将typedArray[index]与value进行加法运算，结果写回typedArray[index]。  \",\"34\":\"此方法返回typedArray[index]被修改之前的值。  \",\"35\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"36\":\"\",\"37\":\"**参数：**\",\"38\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"39\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\"}",
      "修改建议": "使用了不同的词汇描述同一事物，'修改'与'修改'。",
      "更改后示例": "此方法返回typedArray[index]被写回之前的值。",
      "触发条件": "同一上下文或相邻语句中对同一操作（如数据更新）使用不同动词（如\"修改\"和\"写回\"）进行描述，且存在已确立的标准术语（如参考句中的\"修改\"）时。\n\n识别模式：\n1. 检测相邻/同段描述中针对同一操作对象的动作动词\n2. 交叉比对上下文已建立的术语标准（如参考句中的固定表述）\n3. 当出现同义但不同词的表达（如修改/写回）且破坏术语统一性时触发"
    },
    {
      "defect_id": 491695,
      "sentence": "typedArray中的要使用数组的下标。",
      "reference_sentence": "要操作的数组。",
      "line_num": 41,
      "context": "{\"36\":\"\",\"37\":\"**参数：**\",\"38\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"39\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"40\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"41\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"42\":\"| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。        |\",\"43\":\"\",\"44\":\"**返回值：** \",\"45\":\"| 类型        | 说明                         |\",\"46\":\"| ----------- | --------------------------- |\"}",
      "修改建议": "使用了不同的词汇描述同一事物，'使用'与'操作'。",
      "更改后示例": "typedArray中的要操作数组的下标。",
      "触发条件": "同一文档相邻条目或上下文对同一技术概念（如操作类型、参数行为）使用不一致的动词/名词描述时触发。\n\n识别模式：\n1. 定位相邻参数说明区域（如参数表相邻行）\n2. 检测核心操作动词（如\"使用\"/\"操作\"）是否与上下文参考表达（如\"要操作的数组\"）产生冲突\n3. 验证是否指向同一技术动作（通过主语/宾语匹配，如本例均描述对数组下标的处理）"
    },
    {
      "defect_id": 491697,
      "sentence": "typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。",
      "reference_sentence": "此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。",
      "line_num": 47,
      "context": "{\"42\":\"| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。        |\",\"43\":\"\",\"44\":\"**返回值：** \",\"45\":\"| 类型        | 说明                         |\",\"46\":\"| ----------- | --------------------------- |\",\"47\":\"| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\",\"48\":\"\",\"49\":\"**错误信息**\",\"50\":\"| 错误信息        | 说明                         |\",\"51\":\"| ----------- | --------------------------- |\",\"52\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "使用了不同的词汇描述同一事物，'修改'与'写回'。",
      "更改后示例": "typedArray[index]被写回之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。",
      "触发条件": "同一文档中对同一操作或对象使用了不同的动词（如“修改”与“写回”），且相邻上下文已存在明确的标准术语。"
    },
    {
      "defect_id": 491752,
      "sentence": "static add(typedArray: bigtypeArray, index: int, value: bigint): bigint  \r",
      "reference_sentence": "static add(typedArray: smalltypeArray, index: int, value: number): number  \r",
      "line_num": 67,
      "context": "{\"62\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //12\",\"63\":\"```\",\"64\":\"\",\"65\":\"## add\",\"66\":\"\",\"67\":\"static add(typedArray: bigtypeArray, index: int, value: bigint): bigint  \",\"68\":\"\",\"69\":\"将typedArray[index]与value进行加法运算，结果写回typedArray[index]。  \",\"70\":\"此方法返回typedArray[index]被修改之前的值。  \",\"71\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"72\":\"\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`，导致类型不一致",
      "更改后示例": "static add(typedArray: smalltypeArray, index: int, value: number): number  \r",
      "触发条件": "当同一方法签名中同时存在`bigtypeArray`/`smalltypeArray`和`bigint`/`number`的混用组合，且上下文存在明确定义的类型配对规则时（如smalltypeArray必须对应number类型参数/返回值）。\n\n识别模式：\n1. 检测方法参数类型与返回值类型是否遵循`[small|big]typeArray`与`[number|bigint]`的固定对应关系\n2. 当参数列表出现`bigtypeArray`但返回值使用`number`，或参数使用`smalltypeArray`但返回值使用`bigint`时触发规则"
    },
    {
      "defect_id": 491799,
      "sentence": "static and(typedArray: bigtypeArray, index: int, value: bigint): bigint",
      "reference_sentence": "static and(typedArray: smalltypeArray, index: int, value: number): number",
      "line_num": 139,
      "context": "{\"134\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"old is:\\\" + old) //3\",\"135\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //2\",\"136\":\"```\",\"137\":\"## and\",\"138\":\"\",\"139\":\"static and(typedArray: bigtypeArray, index: int, value: bigint): bigint  \",\"140\":\"\",\"141\":\"将typedArray[index]与value进行按位与运算，结果写回typedArray[index]。  \",\"142\":\"此方法返回typedArray[index]被修改之前的值。  \",\"143\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"144\":\"\"}",
      "修改建议": "在前文和后文中，typedArray的类型不一致，前文使用`bigtypeArray`，后文使用`smalltypeArray`。",
      "更改后示例": "static and(typedArray: smalltypeArray, index: int, value: number): number",
      "触发条件": "当同一参数或变量的类型声明在上下文或相邻代码块中出现术语不一致（如 bigtypeArray/smalltypeArray、bigint/number 混用），且存在明确的前后文类型冲突时触发。\n\n识别模式：\n1. 参数类型与后文操作语义矛盾（如操作 smalltypeArray 却声明 bigtypeArray）\n2. 返回类型与参数类型体系不匹配（如参数用 bigint 但返回 number）\n3. 同一概念在相邻代码/注释中出现不同术语表述（需建立类型别名映射表检测）"
    },
    {
      "defect_id": 491753,
      "sentence": "| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\r",
      "reference_sentence": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\r",
      "line_num": 76,
      "context": "{\"71\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"72\":\"\",\"73\":\"**参数：**\",\"74\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"75\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"76\":\"| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\",\"77\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"78\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"79\":\"\",\"80\":\"**返回值：** \",\"81\":\"| 类型        | 说明                         |\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`，导致类型不一致",
      "更改后示例": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\r",
      "触发条件": "同一参数或术语在相邻条目或上下文中出现命名/类型描述不一致，且存在已明确定义的参考表达形式时。  \n\n识别模式：通过对比同结构表格条目（如参数表）、上下文参数引用及参考句子的术语使用，检测是否存在同义但拼写/大小写/前缀差异的冲突表述（如 smalltypeArray vs bigtypeArray）。"
    },
    {
      "defect_id": 491693,
      "sentence": "将typedArray[index]与value进行加法运算，结果写回typedArray[index]。",
      "reference_sentence": "此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"## add\",\"30\":\"\",\"31\":\"static add(typedArray: smalltypeArray, index: int, value: number): number  \",\"32\":\"\",\"33\":\"将typedArray[index]与value进行加法运算，结果写回typedArray[index]。  \",\"34\":\"此方法返回typedArray[index]被修改之前的值。  \",\"35\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"36\":\"\",\"37\":\"**参数：**\",\"38\":\"| 名称     | 类型                                    | 必填 | 说明                   |\"}",
      "修改建议": "使用了不同的词汇描述同一事物，'写回'与'修改'。",
      "更改后示例": "将typedArray[index]与value进行加法运算，结果修改为typedArray[index]。",
      "触发条件": "同一上下文或相邻语句中对同一操作使用不同动词（如\"写回\"与\"修改\"），且存在文档内已确立的标准术语（如参考句中的\"修改\"重复出现）。\n\n识别模式：\n1. 动词冲突检测：在3句范围内出现描述相同数据操作的不同动词（如写/修改/更新）\n2. 术语锚定验证：存在至少两处相同操作的标准表达作为参照（如后文连续出现\"被修改\"）\n3. 语义等价判断：不同动词指向同一对象（typedArray[index]）的相同变更行为（数值更新）"
    },
    {
      "defect_id": 491800,
      "sentence": "| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |",
      "line_num": 148,
      "context": "{\"143\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"144\":\"\",\"145\":\"**参数：**\",\"146\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"147\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"148\":\"| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\",\"149\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。    |\",\"150\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"151\":\"\",\"152\":\"**返回值：** \",\"153\":\"| 类型        | 说明                         |\"}",
      "修改建议": "前文和后文中的描述一致，但typedArray的类型不一致。",
      "更改后示例": "| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |",
      "触发条件": "当同一参数或术语在文档的不同位置（如参数表、方法说明、上下文描述）出现类型名称不一致，且存在已定义的规范类型时触发。\n\n识别模式：通过对比参数名称对应的类型声明（如\"bigtypeArray\" vs \"smalltypeArray\"），检查是否与上下文参考句或已明确定义的术语（如参考句中的\"smalltypeArray\"）保持严格一致。当同一参数名在相邻段落/表格中出现类型描述冲突时即需修复。"
    },
    {
      "defect_id": 491801,
      "sentence": "| value     | bigint                            | 是   | 执行运算的操作数。         |",
      "reference_sentence": "| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |",
      "line_num": 150,
      "context": "{\"145\":\"**参数：**\",\"146\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"147\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"148\":\"| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\",\"149\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。    |\",\"150\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"151\":\"\",\"152\":\"**返回值：** \",\"153\":\"| 类型        | 说明                         |\",\"154\":\"| ----------- | --------------------------- |\",\"155\":\"| bigint      | typedArray[index]被修改之前的值。   |\"}",
      "修改建议": "前文和后文中的描述一致，但value的类型不一致。",
      "更改后示例": "| value     | number                            | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |",
      "触发条件": "当同一参数或术语在相邻上下文中的类型描述（如表格列、返回值说明）与其他相关描述（如数组元素类型、前文定义）存在不一致时触发。  \n\n识别模式：1）检查表格内参数类型是否与关联结构（如数组类型中的元素类型）或前文定义冲突；2）同一参数在多个位置（如参数表、返回值、示例）的类型声明不一致。"
    },
    {
      "defect_id": 491802,
      "sentence": "| bigint      | typedArray[index]被修改之前的值。   |",
      "reference_sentence": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "line_num": 155,
      "context": "{\"150\":\"| value     | bigint                            | 是   | 执行运算的操作数。         |\",\"151\":\"\",\"152\":\"**返回值：** \",\"153\":\"| 类型        | 说明                         |\",\"154\":\"| ----------- | --------------------------- |\",\"155\":\"| bigint      | typedArray[index]被修改之前的值。   |\",\"156\":\"\",\"157\":\"**错误信息**\",\"158\":\"| 错误信息        | 说明                         |\",\"159\":\"| ----------- | --------------------------- |\",\"160\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "前文和后文中的描述一致，但返回值的类型不一致。",
      "更改后示例": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "触发条件": "当同一参数或返回值的类型描述在文档相邻段落或相关上下文中出现不一致（如参数类型与返回值类型冲突），且存在明确参考句子或前文定义时触发。"
    },
    {
      "defect_id": 491822,
      "sentence": "| expectedValue     | bigint                              | 是   | 用于检查与typedArray[index]是否相等的值。     |",
      "reference_sentence": "| expectedValue     | number                              | 是   | 用于检查与typedArray[index]是否相等的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。     |",
      "line_num": 224,
      "context": "{\"219\":\"**参数：**\",\"220\":\"| 名称     | 类型                                          | 必填 | 说明                   |\",\"221\":\"| -------- | -------------------------------------------- | ---- | ---------------------- |\",\"222\":\"| typedArray | bigtypeArray                                    | 是   | 要操作的数组。    |\",\"223\":\"| index     | int                                         | 是   | typedArray中的要使用数组的下标。     |\",\"224\":\"| expectedValue     | bigint                              | 是   | 用于检查与typedArray[index]是否相等的值。     |\",\"225\":\"| replacementValue     | bigint                           | 是   | typedArray[index]要被替换的值。         |\",\"226\":\"\",\"227\":\"**返回值：** \",\"228\":\"| 类型        | 说明                         |\",\"229\":\"| ----------- | --------------------------- |\"}",
      "修改建议": "混用了`bigint`和`number`类型",
      "更改后示例": "| expectedValue     | number                              | 是   | 用于检查与typedArray[index]是否相等的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。     |",
      "触发条件": "当同一参数或相关参数的类型声明在文档不同位置（如参数表、说明字段、返回值）存在不一致（如混用`bigint`与`number`），或与上下文关联类型（如对应数组元素类型）产生矛盾时触发。"
    },
    {
      "defect_id": 491820,
      "sentence": "static compareExchange(typedArray: bigtypeArray, index: int, expectedValue: bigint, replacementValue: bigint): bigint",
      "reference_sentence": "static compareExchange(typedArray: smalltypeArray, index: int, expectedValue: number, replacementValue: number): number",
      "line_num": 213,
      "context": "{\"208\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"old is:\\\" + old) //7\",\"209\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //12\",\"210\":\"```\",\"211\":\"## compareExchange\",\"212\":\"\",\"213\":\"static compareExchange(typedArray: bigtypeArray, index: int, expectedValue: bigint, replacementValue: bigint): bigint  \",\"214\":\"\",\"215\":\"如果typedArray[index]等于expectedValue，将typedArray[index]赋值为replacementValue，如果不相等则不做任何处理。  \",\"216\":\"此方法返回typedArray[index]被修改之前的值。  \",\"217\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"218\":\"\"}",
      "修改建议": "混用了`bigtypeArray`和`smalltypeArray`概念，且`bigint`与`number`类型不一致",
      "更改后示例": "static compareExchange(typedArray: smalltypeArray, index: int, expectedValue: number, replacementValue: number): number",
      "触发条件": "同一参数或返回值的类型声明在文档中混用了不一致的类型术语（如`bigtypeArray`与`smalltypeArray`、`bigint`与`number`），且与上下文实际类型或代码示例存在冲突。\n\n识别模式：检查参数/返回值类型是否出现概念对立术语（如\"big\"/\"small\"前缀冲突）、类型系统不一致（如`bigint`与`number`混用），并与上下文代码示例类型（如日志输出的数值类型）进行交叉验证。"
    },
    {
      "defect_id": 491821,
      "sentence": "| typedArray | bigtypeArray                                    | 是   | 要操作的数组。    |",
      "reference_sentence": "| typedArray | smalltypeArray                                    | 是   | 要操作的数组。    |",
      "line_num": 222,
      "context": "{\"217\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"218\":\"\",\"219\":\"**参数：**\",\"220\":\"| 名称     | 类型                                          | 必填 | 说明                   |\",\"221\":\"| -------- | -------------------------------------------- | ---- | ---------------------- |\",\"222\":\"| typedArray | bigtypeArray                                    | 是   | 要操作的数组。    |\",\"223\":\"| index     | int                                         | 是   | typedArray中的要使用数组的下标。     |\",\"224\":\"| expectedValue     | bigint                              | 是   | 用于检查与typedArray[index]是否相等的值。     |\",\"225\":\"| replacementValue     | bigint                           | 是   | typedArray[index]要被替换的值。         |\",\"226\":\"\",\"227\":\"**返回值：** \"}",
      "修改建议": "混用了`bigtypeArray`和`smalltypeArray`概念",
      "更改后示例": "| typedArray | smalltypeArray                                    | 是   | 要操作的数组。    |",
      "触发条件": "当同一文档中存在多个相关术语变体（如bigtypeArray/smalltypeArray），且当前使用的术语与上下文已确立的标准术语（如参考句中的smalltypeArray）不一致时触发。\n\n识别模式：通过对比参数表与上下文描述（如方法说明中的typedArray类型引用），检测到同一概念存在大小写/前缀冲突（big/small）、术语结构不统一（typeArray结尾格式）或语义矛盾时，应触发一致性修复规则。"
    },
    {
      "defect_id": 491837,
      "sentence": "| value     | bigint         | 是   | typedArray[index]要被修改为的值。         |",
      "reference_sentence": "| value     | number         | 是   | typedArray[index]要被修改为的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。     |",
      "line_num": 297,
      "context": "{\"292\":\"**参数：**\",\"293\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"294\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"295\":\"| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |\",\"296\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。     |\",\"297\":\"| value     | bigint         | 是   | typedArray[index]要被修改为的值。         |\",\"298\":\"\",\"299\":\"**返回值：** \",\"300\":\"| 类型        | 说明                         |\",\"301\":\"| ----------- | --------------------------- |\",\"302\":\"| bigint       | typedArray[index]被修改前的值。   |\"}",
      "修改建议": "参数类型不一致，前文为number，此处为bigint",
      "更改后示例": "| value     | number         | 是   | typedArray[index]要被修改为的值。         |",
      "触发条件": "当同一参数的类型声明在文档不同位置存在矛盾（如前文为number后文为bigint），或参数类型与关联数据结构（如smalltypeArray元素类型）存在逻辑冲突时。"
    },
    {
      "defect_id": 491836,
      "sentence": "| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |",
      "line_num": 295,
      "context": "{\"290\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"291\":\"\",\"292\":\"**参数：**\",\"293\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"294\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"295\":\"| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |\",\"296\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。     |\",\"297\":\"| value     | bigint         | 是   | typedArray[index]要被修改为的值。         |\",\"298\":\"\",\"299\":\"**返回值：** \",\"300\":\"| 类型        | 说明                         |\"}",
      "修改建议": "参数类型不一致，前文为smalltypeArray，此处为bigtypeArray",
      "更改后示例": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |",
      "触发条件": "同一参数或术语在相邻上下文或参数表中出现命名、类型定义不一致（如bigtypeArray vs smalltypeArray），且存在已定义的规范表达（如smalltypeArray被前文引用）。"
    },
    {
      "defect_id": 492060,
      "sentence": "| bigint       | typedArray[index]被修改之前的值。        |",
      "reference_sentence": "| number       | 返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。      |",
      "line_num": 520,
      "context": "{\"515\":\"| value     | bigint       | 是   | 执行运算的操作数。         |\",\"516\":\"\",\"517\":\"**返回值：** \",\"518\":\"| 类型        | 说明                         |\",\"519\":\"| ----------- | --------------------------- |\",\"520\":\"| bigint       | typedArray[index]被修改之前的值。        |\",\"521\":\"\",\"522\":\"**错误信息**\",\"523\":\"| 错误信息        | 说明                         |\",\"524\":\"| ----------- | --------------------------- |\",\"525\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "用词不一致，`bigint`与`number`混用",
      "更改后示例": "| number       | typedArray[index]被修改之前的值。        |",
      "触发条件": "同一参数或返回值的类型描述在文档相邻上下文或相同表格中出现术语不一致（如`bigint`与`number`混用），且存在明确参考标准（如其他同类参数统一使用`number`）。"
    },
    {
      "defect_id": 491857,
      "sentence": "typedArray | bigtypeArray",
      "reference_sentence": "typedArray | smalltypeArray",
      "line_num": 391,
      "context": "{\"386\":\"此方法确保在typedArray[index]被加载之前，typedArray[index]不会发生其他线程的读写操作。  \",\"387\":\"\",\"388\":\"**参数：**\",\"389\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"390\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"391\":\"| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |\",\"392\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。   |\",\"393\":\"\",\"394\":\"**返回值：** \",\"395\":\"| 类型        | 说明                         |\",\"396\":\"| ----------- | --------------------------- |\"}",
      "修改建议": "混用了`bigtypeArray`和`smalltypeArray`概念",
      "更改后示例": "typedArray | smalltypeArray",
      "触发条件": "在相邻或相关文档位置中，同一术语存在不一致的命名变体（如 `bigtypeArray` 和 `smalltypeArray`），且上下文存在已确认的正确术语（如参考句中的 `smalltypeArray`）。\n\n识别模式：\n1. **术语变体冲突**：通过对比参数表、返回值表及上下文描述，检测相似术语（如前缀/后缀相同但核心词不同）。\n2. **参考一致性验证**：匹配问题位置术语与已知正确参考句（如 `smalltypeArray`），若不符则触发规则。"
    },
    {
      "defect_id": 492059,
      "sentence": "| value     | bigint       | 是   | 执行运算的操作数。         |",
      "reference_sentence": "| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "line_num": 515,
      "context": "{\"510\":\"**参数：**\",\"511\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"512\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"513\":\"| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |\",\"514\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"515\":\"| value     | bigint       | 是   | 执行运算的操作数。         |\",\"516\":\"\",\"517\":\"**返回值：** \",\"518\":\"| 类型        | 说明                         |\",\"519\":\"| ----------- | --------------------------- |\",\"520\":\"| bigint       | typedArray[index]被修改之前的值。        |\"}",
      "修改建议": "用词不一致，`bigint`与`number`混用",
      "更改后示例": "| value     | number       | 是   | 执行运算的操作数。         |",
      "触发条件": "同一参数或返回值的类型描述在文档不同位置使用不一致术语（如`bigint`与`number`混用），且存在上下文明确的标准用词（如参考句子中`number`与`smalltypeArray`类型体系严格对应）。"
    },
    {
      "defect_id": 491824,
      "sentence": "| bigint      | typedArray[index]被修改之前的值。   |",
      "reference_sentence": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "line_num": 230,
      "context": "{\"225\":\"| replacementValue     | bigint                           | 是   | typedArray[index]要被替换的值。         |\",\"226\":\"\",\"227\":\"**返回值：** \",\"228\":\"| 类型        | 说明                         |\",\"229\":\"| ----------- | --------------------------- |\",\"230\":\"| bigint      | typedArray[index]被修改之前的值。   |\",\"231\":\"\",\"232\":\"**错误信息**\",\"233\":\"| 错误信息        | 说明                         |\",\"234\":\"| ----------- | --------------------------- |\",\"235\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "混用了`bigint`和`number`类型",
      "更改后示例": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "触发条件": "当同一文档中相同/相关参数的类型声明存在术语不一致（如`bigint`与`number`混用），或与上下文/参考定义的类型描述产生矛盾时触发。\n\n识别模式：\n1. 类型标识符冲突：检测相邻参数表/返回值表中相同语义实体的类型标注差异（如问题句的bigint与参考句的number冲突）\n2. 上下文矛盾：检查当前类型声明是否与文档其他位置（如参数说明、错误处理）的关联类型描述形成逻辑冲突（如问题句的bigint与上文replacementValue的bigint形成隐性矛盾）"
    },
    {
      "defect_id": 491838,
      "sentence": "| bigint       | typedArray[index]被修改前的值。   |",
      "reference_sentence": "| number      | typedArray[index]被修改前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "line_num": 302,
      "context": "{\"297\":\"| value     | bigint         | 是   | typedArray[index]要被修改为的值。         |\",\"298\":\"\",\"299\":\"**返回值：** \",\"300\":\"| 类型        | 说明                         |\",\"301\":\"| ----------- | --------------------------- |\",\"302\":\"| bigint       | typedArray[index]被修改前的值。   |\",\"303\":\"\",\"304\":\"**错误信息**\",\"305\":\"| 错误信息        | 说明                         |\",\"306\":\"| ----------- | --------------------------- |\",\"307\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "返回值类型不一致，前文为number，此处为bigint",
      "更改后示例": "| number      | typedArray[index]被修改前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "触发条件": "同一参数或返回值的类型描述在文档不同位置（如参数定义与返回值说明）出现不一致，且未提供合理上下文解释差异时触发。  \n\n识别模式：通过对比相邻上下文中的类型声明（如参数类型为number，但对应返回值类型错误标注为bigint），检测术语、数据类型或格式是否统一。"
    },
    {
      "defect_id": 492118,
      "sentence": "返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。",
      "reference_sentence": "返回要存储的新值value，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。",
      "line_num": 586,
      "context": "{\"581\":\"| value     | bigint         | 是   | 执行运算的操作数。         |\",\"582\":\"\",\"583\":\"**返回值：** \",\"584\":\"| 类型        | 说明                         |\",\"585\":\"| ----------- | --------------------------- |\",\"586\":\"| bigint       | 返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。       |\",\"587\":\"\",\"588\":\"**错误信息**\",\"589\":\"| 错误信息        | 说明                         |\",\"590\":\"| ----------- | --------------------------- |\",\"591\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`概念",
      "更改后示例": "返回要存储的新值value，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。",
      "触发条件": "当文档中同一概念存在多个命名变体（如smalltypeArray与bigtypeArray）时，或术语使用与上下文参数表/返回值说明中的定义不一致时触发。\n\n识别模式：\n1. 检查核心术语是否与上下文参数表（如问题上下文第581行的bigtypeArray）或参考句子保持严格一致\n2. 捕捉相似前缀但后缀矛盾的术语组合（如small-与big-前缀冲突）\n3. 验证类型描述是否与对应数组的数值范围特征匹配（如bigtypeArray应关联大整数类型）"
    },
    {
      "defect_id": 492058,
      "sentence": "| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | Int32Array | BigInt64Array             | 是   | 要操作的数组。     |",
      "line_num": 513,
      "context": "{\"508\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"509\":\"\",\"510\":\"**参数：**\",\"511\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"512\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"513\":\"| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |\",\"514\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。  |\",\"515\":\"| value     | bigint       | 是   | 执行运算的操作数。         |\",\"516\":\"\",\"517\":\"**返回值：** \",\"518\":\"| 类型        | 说明                         |\"}",
      "修改建议": "用词不一致，`bigtypeArray`与`Int32Array | BigInt64Array`混用",
      "更改后示例": "| typedArray | Int32Array | BigInt64Array             | 是   | 要操作的数组。     |",
      "触发条件": "当参数类型列中的术语与上下文或已定义的标准类型名称不一致，或混用非官方/未定义的缩写与具体类型组合时触发。\n\n识别模式：\n1. 检查参数类型字段是否包含自创/非标准术语（如\"bigtypeArray\"）\n2. 对比上下文是否存在明确定义的类型组合（如\"Int32Array | BigInt64Array\"）\n3. 验证术语是否与语言/框架的官方类型命名规范冲突\n4. 发现同一参数在说明部分与类型列使用不同表述时触发"
    },
    {
      "defect_id": 492063,
      "sentence": "| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "reference_sentence": "| value     | number       | 是   | 执行运算的操作数。         |",
      "line_num": 550,
      "context": "{\"545\":\"**参数：**\",\"546\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"547\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"548\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"549\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。 |\",\"550\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\",\"551\":\"\",\"552\":\"**返回值：** \",\"553\":\"| 类型        | 说明                         |\",\"554\":\"| ----------- | --------------------------- |\",\"555\":\"| number       | 返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。      |\"}",
      "修改建议": "用词不一致，`number`与`bigint`混用",
      "更改后示例": "| value     | number       | 是   | 执行运算的操作数。         |",
      "触发条件": "当同一参数/返回值的类型声明（如`number`）与上下文中的技术术语（如`bigint`）或说明中隐含的数据类型产生矛盾时触发。\n\n识别模式：\n1. 参数表与返回值表存在相同字段时，类型声明必须严格一致\n2. 说明文本中若出现特定数据类型描述（如\"不可为浮点数\"暗示整型），需与声明的类型（如`number`）保持逻辑一致\n3. 同一文档范围内，相同参数应使用统一类型术语（如`int`与`number`不可混用）"
    },
    {
      "defect_id": 492065,
      "sentence": "static store(typedArray: bigtypeArray, index: int, value: bigint): bigint  ",
      "reference_sentence": "static store(typedArray: Int32Array | BigInt64Array, index: int, value: number): number  ",
      "line_num": 572,
      "context": "{\"567\":\"let re = Atomics.store(ta, 0, 12)\",\"568\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //12\",\"569\":\"```\",\"570\":\"## store\",\"571\":\"\",\"572\":\"static store(typedArray: bigtypeArray, index: int, value: bigint): bigint  \",\"573\":\"\",\"574\":\"将typedArray[index]赋值为value，并返回value。  \",\"575\":\"\",\"576\":\"**参数：**\",\"577\":\"| 名称     | 类型                                    | 必填 | 说明                   |\"}",
      "修改建议": "用词不一致，`bigtypeArray`与`Int32Array | BigInt64Array`混用，`bigint`与`number`混用",
      "更改后示例": "static store(typedArray: Int32Array | BigInt64Array, index: int, value: number): number  ",
      "触发条件": "当参数类型或返回值类型存在术语混用（如自创类型名与标准类型名混用、不同精度类型混用）时触发。\n\n识别模式：检查类型声明是否使用非标准或自创术语（如`bigtypeArray`），且与上下文/语言规范存在冲突（如将`bigint`与`number`混用，或未正确区分`Int32Array`/`BigInt64Array`类型族）。"
    },
    {
      "defect_id": 492062,
      "sentence": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | Int32Array | BigInt64Array             | 是   | 要操作的数组。     |",
      "line_num": 548,
      "context": "{\"543\":\"将typedArray[index]赋值为value，并返回value。\",\"544\":\"\",\"545\":\"**参数：**\",\"546\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"547\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"548\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"549\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。 |\",\"550\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\",\"551\":\"\",\"552\":\"**返回值：** \",\"553\":\"| 类型        | 说明                         |\"}",
      "修改建议": "用词不一致，`smalltypeArray`与`Int32Array | BigInt64Array`混用",
      "更改后示例": "| typedArray | Int32Array | BigInt64Array             | 是   | 要操作的数组。     |",
      "触发条件": "同一参数或实体的类型描述在文档中存在术语混用（如别名与全称、非标准命名与标准类型），且上下文存在明确对应的规范术语时触发。"
    },
    {
      "defect_id": 491835,
      "sentence": "static exchange(typedArray: bigtypeArray, index: int, value: bigint): bigint",
      "reference_sentence": "static exchange(typedArray: smalltypeArray, index: int, value: number): number",
      "line_num": 286,
      "context": "{\"281\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"old is:\\\" + old) //0\",\"282\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //12\",\"283\":\"```\",\"284\":\"## exchange\",\"285\":\"\",\"286\":\"static exchange(typedArray: bigtypeArray, index: int, value: bigint): bigint  \",\"287\":\"\",\"288\":\"将typedArray[index]赋值为value。  \",\"289\":\"此方法返回typedArray[index]被修改之前的值。  \",\"290\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"291\":\"\"}",
      "修改建议": "方法参数类型与返回值类型不一致，前文为smalltypeArray和number，此处为bigtypeArray和bigint",
      "更改后示例": "static exchange(typedArray: smalltypeArray, index: int, value: number): number",
      "触发条件": "当方法参数类型或返回值类型与上下文中的其他同类方法声明、或文档既定命名规范存在不一致时触发\n\n识别模式：通过对比当前方法签名与上下文/参考内容中的参数类型（如smalltypeArray vs bigtypeArray）、数值类型（number vs bigint）、返回类型是否保持统一，识别出违反类型命名一致性的参数组合。"
    },
    {
      "defect_id": 492119,
      "sentence": "static sub(typedArray: smalltypeArray, index: int, value: number): number  ",
      "reference_sentence": "static sub(typedArray: bigtypeArray, index: int, value: bigint): bigint  ",
      "line_num": 604,
      "context": "{\"599\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //12\",\"600\":\"```\",\"601\":\"\",\"602\":\"## sub\",\"603\":\"\",\"604\":\"static sub(typedArray: smalltypeArray, index: int, value: number): number  \",\"605\":\"\",\"606\":\"将typedArray[index]与value做减法，结果写回typedArray[index]。  \",\"607\":\"此方法返回typedArray[index]被修改之前的值。  \",\"608\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"609\":\"\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`概念，且`number`和`bigint`类型不一致",
      "更改后示例": "static sub(typedArray: bigtypeArray, index: int, value: bigint): bigint  ",
      "触发条件": "方法签名中参数类型与返回值类型存在概念前缀不一致（如smalltypeArray与bigtypeArray混用），或基础类型与扩展类型冲突（如number与bigint混用），且与上下文参考模式（如bigtypeArray/bigint组合）不匹配时触发。"
    },
    {
      "defect_id": 492064,
      "sentence": "| number       | 返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。      |",
      "reference_sentence": "| number       | typedArray[index]被修改之前的值。        |",
      "line_num": 555,
      "context": "{\"550\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\",\"551\":\"\",\"552\":\"**返回值：** \",\"553\":\"| 类型        | 说明                         |\",\"554\":\"| ----------- | --------------------------- |\",\"555\":\"| number       | 返回要存储的新值value，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。      |\",\"556\":\"\",\"557\":\"**错误信息**\",\"558\":\"| 错误信息        | 说明                         |\",\"559\":\"| ----------- | --------------------------- |\",\"560\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "用词不一致，`number`与`bigint`混用",
      "更改后示例": "| number       | 返回要存储的新值value。      |",
      "触发条件": "当同一参数/返回值的类型描述在文档不同位置存在术语冲突（如\"number\"与\"bigint\"混用），或与上下文已定义的类型术语体系不一致时触发。\n\n识别模式：\n1. 类型标识符重复性检测：在参数说明表、返回值表等结构化区域，对同一参数名/返回值名进行术语交叉比对\n2. 上下文一致性验证：检查当前类型描述是否与相邻参数说明（如示例中550行的value参数类型定义）保持相同术语体系"
    },
    {
      "defect_id": 492061,
      "sentence": "static store(typedArray: smalltypeArray, index: int, value: number): number  ",
      "reference_sentence": "static store(typedArray: bigtypeArray, index: int, value: bigint): bigint  ",
      "line_num": 541,
      "context": "{\"536\":\"hilog.info(0x0000, \\\"testTag\\\", \\\"res is:\\\" + re) //3\",\"537\":\"```\",\"538\":\"\",\"539\":\"## store\",\"540\":\"\",\"541\":\"static store(typedArray: smalltypeArray, index: int, value: number): number  \",\"542\":\"\",\"543\":\"将typedArray[index]赋值为value，并返回value。\",\"544\":\"\",\"545\":\"**参数：**\",\"546\":\"| 名称     | 类型                                    | 必填 | 说明                   |\"}",
      "修改建议": "用词不一致，`smalltypeArray`与`bigtypeArray`混用，`number`与`bigint`混用",
      "更改后示例": "static store(typedArray: Int32Array | BigInt64Array, index: int, value: number): number  ",
      "触发条件": "同一参数或返回值类型在文档中使用了不一致的命名模式（如 smalltypeArray/bigtypeArray 配对未统一），或存在类型声明与标准类型术语冲突（如 number 与 bigint 混用）。\n\n识别模式：\n1. 检测到类型名称包含可配对前缀（small/big）但未成组出现（如 smalltypeArray 未对应 bigtypeArray）\n2. 同一函数声明中基础类型（number）与扩展类型（bigint）混用，且与上下文参考实现存在冲突\n3. 参数类型与返回值类型在语义层级不匹配（如数值类型与精确位宽类型混用）"
    },
    {
      "defect_id": 491823,
      "sentence": "| replacementValue     | bigint                           | 是   | typedArray[index]要被替换的值。         |",
      "reference_sentence": "| replacementValue     | number                           | 是   | typedArray[index]要被替换的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |",
      "line_num": 225,
      "context": "{\"220\":\"| 名称     | 类型                                          | 必填 | 说明                   |\",\"221\":\"| -------- | -------------------------------------------- | ---- | ---------------------- |\",\"222\":\"| typedArray | bigtypeArray                                    | 是   | 要操作的数组。    |\",\"223\":\"| index     | int                                         | 是   | typedArray中的要使用数组的下标。     |\",\"224\":\"| expectedValue     | bigint                              | 是   | 用于检查与typedArray[index]是否相等的值。     |\",\"225\":\"| replacementValue     | bigint                           | 是   | typedArray[index]要被替换的值。         |\",\"226\":\"\",\"227\":\"**返回值：** \",\"228\":\"| 类型        | 说明                         |\",\"229\":\"| ----------- | --------------------------- |\",\"230\":\"| bigint      | typedArray[index]被修改之前的值。   |\"}",
      "修改建议": "混用了`bigint`和`number`类型",
      "更改后示例": "| replacementValue     | number                           | 是   | typedArray[index]要被替换的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。         |",
      "触发条件": "同一参数或相关参数在文档中的类型声明不一致（如混用`bigint`和`number`），或参数类型与上下文其他关联参数/返回值的类型定义存在逻辑冲突时触发。\n\n识别模式：通过对比参数类型字段与上下文相邻参数类型、返回值类型的一致性，以及检查参数说明中数值范围描述（如\"不可为浮点数\"）与类型声明（如应使用`number`却声明`bigint`）的逻辑匹配性进行识别。"
    },
    {
      "defect_id": 492120,
      "sentence": "| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |",
      "line_num": 613,
      "context": "{\"608\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"609\":\"\",\"610\":\"**参数：**\",\"611\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"612\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"613\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"614\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。         |\",\"615\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。    |\",\"616\":\"\",\"617\":\"**返回值：** \",\"618\":\"| 类型        | 说明                         |\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`概念",
      "更改后示例": "| typedArray | bigtypeArray                         | 是   | 要操作的数组。     |",
      "触发条件": "同一参数或术语在文档的不同位置（如参数表、说明段落）出现命名或类型描述不一致，且存在明确参考标准（如已有统一术语）时触发。  \n\n识别模式：检查参数表中的类型字段是否与上下文中的相关术语（如参数说明、返回值描述）严格匹配，若发现同一参数使用多个变体名称（如smalltypeArray vs bigtypeArray），且存在明确正确版本（如参考句子），则判定为不一致需修复。"
    },
    {
      "defect_id": 492121,
      "sentence": "| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。    |",
      "reference_sentence": "| value     | bigint         | 是   | 执行运算的操作数，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。    |",
      "line_num": 615,
      "context": "{\"610\":\"**参数：**\",\"611\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"612\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"613\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\",\"614\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。         |\",\"615\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。    |\",\"616\":\"\",\"617\":\"**返回值：** \",\"618\":\"| 类型        | 说明                         |\",\"619\":\"| ----------- | --------------------------- |\",\"620\":\"| number       | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`概念，且`number`和`bigint`类型不一致",
      "更改后示例": "| value     | bigint         | 是   | 执行运算的操作数，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。    |",
      "触发条件": "当参数/返回值的类型声明与关联的术语概念不一致（如`number`对应`bigtypeArray`），或相邻条目存在统一术语模式（如`smalltypeArray`对应`number`）时触发。\n\n识别模式：\n1. 检测类型字段与说明字段的术语关联性（如`bigint`应关联`bigtypeArray`，`number`应关联`smalltypeArray`）\n2. 对比上下文相邻条目的术语-类型对应模式（如参数表第613行`smalltypeArray`对应`number`类型返回值）"
    },
    {
      "defect_id": 492195,
      "sentence": "static wait(typedArray: BigInt64Array, index: nubmer, value: bigint, timeout?: number): string",
      "reference_sentence": "static wait(typedArray: BigInt64Array, index: number, value: bigint, timeout?: number): string",
      "line_num": 729,
      "context": "{\"724\":\"    p1.Await()\",\"725\":\"}\",\"726\":\"```\",\"727\":\"## wait\",\"728\":\"\",\"729\":\"static wait(typedArray: BigInt64Array, index: nubmer, value: bigint, timeout?: number): string  \",\"730\":\"\",\"731\":\"验证typedArray[index]是否等于value。如果不相等就直接返回\\\"not-equal\\\"。如果相等则进行等待状态。  \",\"732\":\"等待状态下如果收到notify，则结束等待并返回\\\"ok\\\"，如果设置了timeout超时时间，超过超时时间则不再等待并返回\\\"time-out\\\"，否则一直等待。    \",\"733\":\"\",\"734\":\"**参数：**\"}",
      "修改建议": "参数类型不一致，原句中使用了'number'，而实际类型为'nubmer'。",
      "更改后示例": "static wait(typedArray: BigInt64Array, index: number, value: bigint, timeout?: number): string",
      "触发条件": "当参数类型声明中存在拼写错误（如'nubmer'与'number'），或与上下文/语言规范定义的类型名称不一致时触发该规则。识别模式需检查类型标识符拼写准确性，并与语言内置类型库或上下文已明确定义的类型进行匹配验证。"
    },
    {
      "defect_id": 498873,
      "sentence": "解析当前目录下的rawheap文件，并在指定路径（如：D:\\temp）下生成的heapsnapshot",
      "reference_sentence": "解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot",
      "line_num": 68,
      "context": "{\"63\":\"### 参数列表\",\"64\":\"\",\"65\":\"| 选项 | 描述 | 举例 |\",\"66\":\"| -------- | ----------------- | ---------------------------------- |\",\"67\":\"| \\\\<rawheap_file\\\\> | 必选参数，OOM时生成的rawheap文件路径：<br>/data/log/reliability/resource_leak/memory_leak | 解析指定目录（如：D:\\\\temp\\\\rawheap）下的rawheap文件：<br>rawheap_translator D:\\\\temp\\\\rawheap\\\\xxx.rawheap<br>解析当前目录下的rawheap文件：<br>rawheap_translator xxx.rawheap |\",\"68\":\"| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；<br>不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot | 解析当前目录下的rawheap文件，并在指定路径（如：D:\\\\temp）下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap D:\\\\temp\\\\xxx.heapsnapshot<br>解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap xxx.heapsnapshot |\",\"69\":\"> **注意：**\",\"70\":\">\",\"71\":\"> [heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\",\"72\":\"> 以windows为例:\",\"73\":\"> D:\\\\> ...\\\\rawheap_translator.exe ...\\\\example.rawheap 命令中，需要保证“D:\\\\”路径具有读写权限。\"}",
      "修改建议": "混用了'指定路径'和'当前路径'，导致表意模糊",
      "更改后示例": "解析当前目录下的rawheap文件，并在指定路径（如：D:\\temp）下生成heapsnapshot",
      "触发条件": "同一句子或相邻上下文中出现多个路径描述词（如\"当前路径\"与\"指定路径\"）且存在逻辑矛盾，或同一操作涉及多个路径时未保持术语一致性。\n\n识别模式：\n1. 检测句子中路径指示词（当前/指定/默认/目标等）的混用现象\n2. 验证上下文参数说明（如参数列表中的路径定义）是否与操作描述一致\n3. 检查路径动作动词（生成/保存/创建）与路径描述的语义连贯性\n4. 对比相邻示例语句的表述方式（如参考句中的\"当前路径\"统一用法）"
    },
    {
      "defect_id": 492217,
      "sentence": "| value     | number              | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。 |",
      "reference_sentence": "| value     | bigint                            | 是   | 执行运算的操作数。         |",
      "line_num": 859,
      "context": "{\"854\":\"**参数：**\",\"855\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"856\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"857\":\"| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |\",\"858\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。    |\",\"859\":\"| value     | number              | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。 |\",\"860\":\"\",\"861\":\"**返回值：** \",\"862\":\"| 类型        | 说明                         |\",\"863\":\"| ----------- | --------------------------- |\",\"864\":\"| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。  |\"}",
      "修改建议": "参数类型不一致，`number` 和 `bigint` 混用",
      "更改后示例": "| value     | bigint              | 是   | 执行运算的操作数，对应BigInt64Array中的元素类型，可为负数，不可为浮点数。 |",
      "触发条件": "当参数类型声明与上下文相关类型术语（如数组类型后缀、返回值类型或说明中的元素类型）存在命名不一致时触发，特别是出现基础类型与特定类型（如number与bigint）混用的情况。"
    },
    {
      "defect_id": 492215,
      "sentence": "static xor(typedArray: smalltypeArray, index: int, value: number): number",
      "reference_sentence": "static xor(typedArray: bigtypeArray, index: int, value: bigint): bigint",
      "line_num": 848,
      "context": "{\"843\":\"}\",\"844\":\"```\",\"845\":\"\",\"846\":\"## xor\",\"847\":\"\",\"848\":\"static xor(typedArray: smalltypeArray, index: int, value: number): number  \",\"849\":\"\",\"850\":\"将typedArray[index]与value进行按位异或运算，结果写回typedArray[index]。  \",\"851\":\"此方法返回typedArray[index]被修改之前的值。  \",\"852\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"853\":\"\"}",
      "修改建议": "参数类型不一致，`smalltypeArray` 和 `bigtypeArray` 混用",
      "更改后示例": "static xor(typedArray: BigInt64Array, index: int, value: number): number",
      "触发条件": "当参数类型名称存在多个相似变体（如smalltypeArray/bigtypeArray）且在同一上下文或相邻方法中出现不一致用法时；或参数类型与参考示例中的标准命名模式（如xxxArray类型后缀）不匹配时。"
    },
    {
      "defect_id": 498901,
      "sentence": "原因：生成文件路径下没有写文件权限，指定到有写权限路径下可解决。参考路径：/data/local/tmp。",
      "reference_sentence": "通过hdc shell命令拉起解析工具，设备内工具路径：/bin/rawheap_translator，推荐指定生成heapsnapshot文件路径在/data/local/tmp下，其他路径可能面临没有写权限问题。",
      "line_num": 220,
      "context": "{\"215\":\"[INFO ] ReadStringTable         string table count 11208\",\"216\":\"[INFO ] ReadObjTable            section objects count 96432\",\"217\":\"[INFO ] Translate               success\",\"218\":\"[ERROR] Initialize              open file failed\",\"219\":\"```\",\"220\":\"原因：生成文件路径下没有写文件权限，指定到有写权限路径下可解决。参考路径：/data/local/tmp。\"}",
      "修改建议": "使用了'生成'和'指定'两个不同词汇来描述同一动作，应保持用词一致。",
      "更改后示例": "原因：指定生成文件路径下没有写文件权限，指定到有写权限路径下可解决。参考路径：/data/local/tmp。",
      "触发条件": "同一句子或相邻上下文中对同一操作使用多个不同动词（如\"生成\"和\"指定\"），且存在上下文明确的同一操作指向（如文件路径设置）。\n\n识别模式：\n1. 动词不一致检测：在描述单一操作流程时，识别关键动作动词的重复使用情况（如\"生成路径\"与\"指定路径\"）\n2. 上下文语义关联：通过前后文判断不同动词是否指向同一技术操作（如文件路径设置场景中的权限问题）\n3. 术语统一验证：检查是否存在更早出现的标准表述（如参考句中的\"指定生成\"统一用法）作为修正基准"
    },
    {
      "defect_id": 492216,
      "sentence": "| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |",
      "reference_sentence": "| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |",
      "line_num": 857,
      "context": "{\"852\":\"此方法确保在typedArray[index]被修改之前，typedArray[index]不会发生其他线程的读写操作。  \",\"853\":\"\",\"854\":\"**参数：**\",\"855\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"856\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"857\":\"| typedArray | smalltypeArray                        | 是   | 要操作的数组。     |\",\"858\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。    |\",\"859\":\"| value     | number              | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。 |\",\"860\":\"\",\"861\":\"**返回值：** \",\"862\":\"| 类型        | 说明                         |\"}",
      "修改建议": "参数类型不一致，`smalltypeArray` 和 `bigtypeArray` 混用",
      "更改后示例": "| typedArray | BigInt64Array                        | 是   | 要操作的数组。     |",
      "触发条件": "同一参数的类型名称在文档中存在不一致的命名模式（例如混用占位符 smalltypeArray/bigtypeArray 与具体类型 BigInt64Array），或未保持相同的前缀/后缀结构。"
    },
    {
      "defect_id": 492138,
      "sentence": "typedArray[index]要比较相等性的数据。Int32类型取值范围",
      "reference_sentence": "typedArray[index]要减的值。",
      "line_num": 687,
      "context": "{\"682\":\"**参数：**\",\"683\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"684\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"685\":\"| typedArray | Int32Array                         | 是   | 要操作的数组。     |\",\"686\":\"| index     | number                               | 是   | typedArray中的要使用数组的下标，不能为负数。   |\",\"687\":\"| value     | number                           | 是   | typedArray[index]要比较相等性的数据。Int32类型取值范围         |\",\"688\":\"| timeout     | number                           | 否   | 超时时间，单位毫秒（ms），不可为负数。     |\",\"689\":\"\",\"690\":\"**返回值：** \",\"691\":\"| 类型        | 说明                         |\",\"692\":\"| ----------- | --------------------------- |\"}",
      "修改建议": "混用了“要比较相等性的数据”和“操作数”",
      "更改后示例": "typedArray[index]要比较相等性的数据，Int32类型取值范围。",
      "触发条件": "同一参数描述中存在结构断裂（如句号分隔本应连贯的说明项）或与上下文同类条目句式不匹配时触发。\n\n识别模式：\n1. 标点断裂：主句后使用句号而非逗号连接补充说明（如\"数据。Int32类型\"）\n2. 句式差异：当参数说明包含\"要+动词+的+名词\"结构时，需与上下文同类参数（如\"要减的值\"）保持\"主句，补充说明\"的连贯句式"
    },
    {
      "defect_id": 492122,
      "sentence": "| number       | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "reference_sentence": "| bigint       | typedArray[index]被修改之前的值，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "line_num": 620,
      "context": "{\"615\":\"| value     | number         | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。    |\",\"616\":\"\",\"617\":\"**返回值：** \",\"618\":\"| 类型        | 说明                         |\",\"619\":\"| ----------- | --------------------------- |\",\"620\":\"| number       | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。   |\",\"621\":\"\",\"622\":\"**错误信息**\",\"623\":\"| 错误信息        | 说明                         |\",\"624\":\"| ----------- | --------------------------- |\",\"625\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "混用了`smalltypeArray`和`bigtypeArray`概念，且`number`和`bigint`类型不一致",
      "更改后示例": "| bigint       | typedArray[index]被修改之前的值，对应bigtypeArray中的元素类型，可为负数，不可为浮点数。   |",
      "触发条件": "当同一参数/返回值的类型描述（如number/bigint）与关联的术语体系（如smalltypeArray/bigtypeArray）出现不匹配，或同一术语体系在文档不同位置出现矛盾时触发。\n\n识别模式：\n1. 类型-术语组合异常检测：当类型描述（number/bigint）与修饰语（smalltypeArray/bigtypeArray）的组合不符合既定对应关系时（如number配bigtypeArray）\n2. 跨条目术语冲突检测：当同一参数位置（如typedArray[index]）在不同条目中使用了相互矛盾的术语体系（如615行用smalltypeArray，620行却对应bigtypeArray）"
    },
    {
      "defect_id": 492218,
      "sentence": "| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。  |",
      "reference_sentence": "| bigint       | typedArray[index]被修改之前的值。   |",
      "line_num": 864,
      "context": "{\"859\":\"| value     | number              | 是   | 执行运算的操作数，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。 |\",\"860\":\"\",\"861\":\"**返回值：** \",\"862\":\"| 类型        | 说明                         |\",\"863\":\"| ----------- | --------------------------- |\",\"864\":\"| number      | typedArray[index]被修改之前的值，对应smalltypeArray中的元素类型，可为负数，不可为浮点数。  |\",\"865\":\"\",\"866\":\"**错误信息**\",\"867\":\"| 错误信息        | 说明                         |\",\"868\":\"| ----------- | --------------------------- |\",\"869\":\"| \\\"Index out of bounds\\\" | 访问typedArray越界。<br>可能原因：index超出typedArray的边界。<br>处理步骤：传入index确保在typedArray的范围内，无法保证时，需捕获RangeError异常。 |\"}",
      "修改建议": "返回值类型不一致，`number` 和 `bigint` 混用",
      "更改后示例": "| bigint      | typedArray[index]被修改之前的值，对应BigInt64Array中的元素类型，可为负数，不可为浮点数。  |",
      "触发条件": "当同一参数/返回值的类型描述在文档不同位置出现不一致（如number与bigint混用），或关联术语（如smalltypeArray与BigInt64Array）未保持对应关系时触发。\n\n识别模式：\n1. 类型冲突检测：比较参数说明与返回值说明中的类型字段（如864行number与参考句子bigint冲突）\n2. 术语关联验证：检查数组类型名称与元素类型的对应关系（如smalltypeArray对应number，BigInt64Array对应bigint的逻辑关联）"
    },
    {
      "defect_id": 498872,
      "sentence": "解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot",
      "reference_sentence": "解析当前目录下的rawheap文件，并在指定路径（如：D:\\temp）下生成的heapsnapshot",
      "line_num": 68,
      "context": "{\"63\":\"### 参数列表\",\"64\":\"\",\"65\":\"| 选项 | 描述 | 举例 |\",\"66\":\"| -------- | ----------------- | ---------------------------------- |\",\"67\":\"| \\\\<rawheap_file\\\\> | 必选参数，OOM时生成的rawheap文件路径：<br>/data/log/reliability/resource_leak/memory_leak | 解析指定目录（如：D:\\\\temp\\\\rawheap）下的rawheap文件：<br>rawheap_translator D:\\\\temp\\\\rawheap\\\\xxx.rawheap<br>解析当前目录下的rawheap文件：<br>rawheap_translator xxx.rawheap |\",\"68\":\"| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；<br>不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot | 解析当前目录下的rawheap文件，并在指定路径（如：D:\\\\temp）下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap D:\\\\temp\\\\xxx.heapsnapshot<br>解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap xxx.heapsnapshot |\",\"69\":\"> **注意：**\",\"70\":\">\",\"71\":\"> [heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\",\"72\":\"> 以windows为例:\",\"73\":\"> D:\\\\> ...\\\\rawheap_translator.exe ...\\\\example.rawheap 命令中，需要保证“D:\\\\”路径具有读写权限。\"}",
      "修改建议": "混用了'当前路径'和'指定路径'，导致表意模糊",
      "更改后示例": "解析当前目录下的rawheap文件，并在当前目录下生成heapsnapshot",
      "触发条件": "同一上下文或相邻描述中混用\"路径\"与\"目录\"等指代文件位置的同义/近义术语，且可能造成用户对操作位置的理解歧义时。\n\n识别模式：\n1. 术语冲突检测：在参数说明、操作步骤等连贯性内容中，出现\"路径/目录/位置\"等同类概念的不同表述\n2. 上下文关联验证：结合参数列表的上下文（如问题上下文第67-68行），当发现\"当前路径\"与\"当前目录\"、\"指定路径\"与\"指定目录\"等交替出现时\n3. 歧义风险判断：当不同表述可能让用户误认为指向不同位置（如\"当前路径\"可能被理解为环境变量PATH，而\"当前目录\"明确指执行目录）时"
    },
    {
      "defect_id": 492137,
      "sentence": "typedArray[index]要减的值。",
      "reference_sentence": "typedArray[index]要减的值。",
      "line_num": 651,
      "context": "{\"646\":\"**参数：**\",\"647\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"648\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"649\":\"| typedArray | bigtypeArray                          | 是   | 要操作的数组。     |\",\"650\":\"| index     | int                               | 是   | typedArray中的要使用数组的下标。         |\",\"651\":\"| value     | bigint                            | 是   | typedArray[index]要减的值。         |\",\"652\":\"\",\"653\":\"**返回值：** \",\"654\":\"| 类型        | 说明                         |\",\"655\":\"| ----------- | --------------------------- |\",\"656\":\"| bigint       | typedArray[index]被修改之前的值。   |\"}",
      "修改建议": "混用了“减的值”和“操作数”",
      "更改后示例": "typedArray[index]要减的操作数。",
      "触发条件": "同一文档中对同一概念使用多个不一致的术语（如\"值\"与\"操作数\"混用），且上下文存在已明确定义的标准化表述（如参数命名、返回值说明等场景）。"
    },
    {
      "defect_id": 492194,
      "sentence": "等待结果可通过返回值获得。",
      "reference_sentence": "等待结果可通过返回值获得。",
      "line_num": 785,
      "context": "{\"780\":\"## waitAsync\",\"781\":\"\",\"782\":\"async static waitAsync(typedArray: Int32Array | BigInt64Array, index: number, value: bigint, timeout?: number): Promise\\\\<string>\",\"783\":\"\",\"784\":\"等待共享内存的特定位置，与wait不同不会阻塞调用者。  \",\"785\":\"等待结果可通过返回值获得。  \",\"786\":\"\",\"787\":\"**参数：**\",\"788\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"789\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"790\":\"| typedArray | Int32Array \\\\| BigInt64Array            | 是   | 要操作的数组。     |\"}",
      "修改建议": "前后描述不一致，原句中使用了'等待结果可通过返回值获得'，而后续句子中使用了'等待结果'。",
      "更改后示例": "等待结果可以通过返回值获得。",
      "触发条件": "同一术语或短语在相邻或相关上下文中存在不一致的表达形式（如动词结构差异、术语混用），且可能引发理解歧义或破坏文档连贯性时触发。\n\n具体识别模式：\n1. **动词结构不一致**：检测同一动作描述中是否混用不同语法结构（如\"可通过\" vs \"可以通过\"），需结合上下文判断是否存在冗余或时态冲突。\n2. **术语指代波动**：识别核心概念（如\"等待结果\"）是否在相邻段落中存在非必要替换表达，通过词性标注和共指消解技术验证一致性。"
    },
    {
      "defect_id": 501963,
      "sentence": "在RTL文字方向下是否自动翻转图源。<br/>true：自动翻转图源。<br/>false：不会翻转图源。",
      "reference_sentence": "设置评分条是否作为一个指示器。<br>true：作为一个指示器，此时用户不可操作。<br>false：不作为一个指示器，此时用户可以操作。",
      "line_num": 42,
      "context": "{\"37\":\"| star-background | string | - | 否 | 设置单个星级未选中的背景图片，只支持本地路径图片，图片格式为png和jpg。 |\",\"38\":\"| star-foreground | string | - | 否 | 设置单个星级选中的前景图片，只支持本地路径图片，图片格式为png和jpg。 |\",\"39\":\"| star-secondary | string | - | 否 | 设置单个星级部分选中的次级背景图片，该图片会覆盖背景图片，只支持本地路径图片，图片格式为png和jpg。 |\",\"40\":\"| width | &lt;length&gt;\\\\|&lt;percentage&gt; | 120px<br/>60px（不可操作） | 否 | 默认值是在未设置自定义资源和评分星数时，使用5个星和默认资源下的宽度值。 |\",\"41\":\"| height | &lt;length&gt;\\\\|&lt;percentage&gt; | 24px<br/>12px（不可操作） | 否 | 默认值是在未设置自定义资源和评分星数时，使用5个星和默认资源下的高度值。 |\",\"42\":\"| rtl-flip | boolean | true | 否 | 在RTL文字方向下是否自动翻转图源。<br/>true：自动翻转图源。<br/>false：不会翻转图源。 |\",\"43\":\"\",\"44\":\">  **说明：**\",\"45\":\"> star-background，star-secondary，star-foreground三个星级图源必须全部设置，否则默认的星级颜色为灰色，以此提示图源设置错误。\",\"46\":\"\",\"47\":\"\"}",
      "修改建议": "句式不一致，前文使用了完整的句子描述，而问题句使用了简略的表述。",
      "更改后示例": "在RTL文字方向下是否自动翻转图源。<br/>true：自动翻转图源。<br/>false：不自动翻转图源。",
      "触发条件": "同一参数选项（如true/false）的描述存在句式结构不一致，或使用不对称的肯定/否定表达（如\"自动\"与\"不会\"不对应）。  \n\n识别模式：  \n1. 检查同一参数下不同选项的说明是否采用相同的主谓结构（如true用\"自动翻转\"，false应使用\"不自动翻转\"而非\"不会翻转\"）  \n2. 对比否定词与肯定词是否严格对应（如\"自动\"对应\"不自动\"，而非使用\"不会\"等不同否定形式）"
    },
    {
      "defect_id": 498900,
      "sentence": "通过hdc shell命令拉起解析工具，设备内工具路径：/bin/rawheap_translator，推荐指定生成heapsnapshot文件路径在/data/local/tmp下，其他路径可能面临没有写权限问题。",
      "reference_sentence": "在Java编程中，开发者通常使用`ArrayList`来存储和管理数据集合。`ArrayList`提供了多种方法来操作数据，例如添加、删除和查找元素。此外，`ArrayList`还支持动态扩容，能够根据数据量的变化自动调整容量。",
      "line_num": 79,
      "context": "{\"74\":\"\",\"75\":\"## 解析命令示例\",\"76\":\"\",\"77\":\"### OHOS设备中解析示例\",\"78\":\"\",\"79\":\"通过hdc shell命令拉起解析工具，设备内工具路径：/bin/rawheap_translator，推荐指定生成heapsnapshot文件路径在/data/local/tmp下，其他路径可能面临没有写权限问题。\",\"80\":\"```bash\",\"81\":\"> hdc shell /bin/rawheap_translator /data/log/reliability/resource_leak/memory_leak/memleak-js-com.example.myapplication-7979-7979-20241215191332.rawheap /data/local/tmp/myapplication-7979-7979.heapsnapshot\",\"82\":\"[INFO ] ParseVersion            current metadata version is 1.0.0\",\"83\":\"[INFO ] ParseTypeEnums          total JSType count 214\",\"84\":\"[INFO ] ParseTypeList           total metadata count 220\"}",
      "修改建议": "使用了'生成'和'指定'两个不同词汇来描述同一动作，应保持用词一致。",
      "更改后示例": "通过hdc shell命令拉起解析工具，设备内工具路径：/bin/rawheap_translator，推荐指定生成heapsnapshot文件路径为/data/local/tmp，其他路径可能面临没有写权限问题。",
      "触发条件": "同一段落或相邻句子中对同一动作/对象使用不同动词或术语（如\"生成\"与\"指定\"混用），且上下文存在明确的一致性要求（如技术说明、操作步骤等需要精准表述的场景）。\n\n识别模式：\n1. 动作重复性检测：在操作步骤描述中，针对同一核心动作（如文件路径指定）出现不同动词（生成/指定/设置）\n2. 术语一致性验证：在同一技术对象描述中（如heapsnapshot文件路径），出现非标准化的表达方式（路径在...下 vs 路径为...）\n3. 上下文关联分析：结合技术文档特性（如命令行示例段落）判断是否需要严格保持术语统一"
    },
    {
      "defect_id": 508348,
      "sentence": "用户通过AI入口触发意图时，如果意图调用中需要传递对象类型参数，则开发者需要使用[@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)装饰器将该参数定义为意图实体。例如，用户想通过小艺播放某首音乐，用户需要告诉小艺播放的音乐名称和歌手信息，歌手信息包括歌手名称和国家等，一般为对象格式，无法用基础类型表示，需要定义为意图实体。",
      "reference_sentence": "用户通过AI入口触发意图时，如果意图调用中需要传递对象类型参数，则开发者需要使用[@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)装饰器将该参数定义为意图实体。例如，用户想通过小艺播放某首音乐，用户需要告诉小艺播放的音乐名称和歌手信息，歌手信息包括歌手名称和国家等，一般为对象格式，无法用基础类型表示，需要定义为意图实体。",
      "line_num": 3,
      "context": "{\"1\":\"# 开发意图实体\",\"2\":\"\",\"3\":\"用户通过AI入口触发意图时，如果意图调用中需要传递对象类型参数，则开发者需要使用[@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)装饰器将该参数定义为意图实体。例如，用户想通过小艺播放某首音乐，用户需要告诉小艺播放的音乐名称和歌手信息，歌手信息包括歌手名称和国家等，一般为对象格式，无法用基础类型表示，需要定义为意图实体。\",\"4\":\"\",\"5\":\"## 接口介绍\",\"6\":\"\",\"7\":\"定义意图实体使用@InsightIntentEntity装饰器。以下介绍相关API：\",\"8\":\"\"}",
      "修改建议": "句子重复，建议删除或合并。",
      "更改后示例": "用户通过AI入口触发意图时，如果意图调用中需要传递对象类型参数，例如播放音乐时的音乐名称和歌手信息，歌手信息包括歌手名称和国家等，一般为对象格式，无法用基础类型表示，需要使用[@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)装饰器将该参数定义为意图实体。",
      "触发条件": "当文档在同一段落或相邻句子中出现重复的说明性内容（例如用例描述与前置条件重复，或例子中冗余复述前文规则）时触发。\n\n识别模式：\n1. **重复结构检测**：同一段落内存在相同/近义句式（例如问题句中的\"用户需要告诉小艺...\"与\"需要定义为意图实体\"两次重复）；\n2. **例子冗余**：示例部分复述了前文已明确的技术条件（如\"对象格式无法用基础类型表示\"在规则说明和示例中重复出现）；\n3. **细节重叠**：参数特征描述（如\"歌手信息包括...国家等\"）在规则定义和示例中双重展开。"
    },
    {
      "defect_id": 508126,
      "sentence": "只支持设置px类型的数值，如需设置其他类型的数值，可以将其他类型转为px类型传入，例如需要设置vp，可以将vp改成px传入。",
      "reference_sentence": "无",
      "line_num": 148,
      "context": "{\"143\":\"| message                 | string&nbsp;\\\\|&nbsp;[Resource](arkui-ts/ts-types.md#resource) | 是   | 显示的文本信息。<br>**说明：** <br/>默认字体为'Harmony Sans'，不支持设置其他字体。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"144\":\"| duration                | number                                                       | 否   | 设置提示框弹出的持续时间。<br/>默认值1500ms，取值区间：1500ms-10000ms。若小于1500ms则取默认值，若大于10000ms则取上限值10000ms。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"145\":\"| bottom                  | string&nbsp;\\\\|&nbsp;number                                   | 否   | 设置弹窗底部边框距离导航条的高度，ToastShowMode.TOP_MOST模式下，软键盘拉起时，如果bottom值过小，toast要被软键盘遮挡时，会自动避让至距离软键盘80vp处。ToastShowMode.DEFAULT模式下，软键盘拉起时，会上移软键盘的高度。<br/>默认值：80vp<br/>**说明：** <br/>当底部没有导航条时，bottom为设置弹窗底部边框距离窗口底部的高度。<br/>设置对齐方式alignment后，bottom不生效。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"146\":\"| showMode<sup>11+</sup>  | [ToastShowMode](#toastshowmode11)                            | 否   | 设置弹窗层级。<br>默认值：ToastShowMode.DEFAULT，默认显示在应用内。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"147\":\"| alignment<sup>12+</sup> | [Alignment](arkui-ts/ts-appendix-enums.md#alignment)         | 否   | 对齐方式。<br>**说明：** <br/>不同alignment下，Toast位置对齐效果，如下图所示。<br/>![zh-cn_image_0001](figures/toast_alignment.PNG)<br/>Toast的文本显示默认自左向右，不支持其他对齐方式。<br/>默认值：undefined，默认底部偏上位置。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。         |\",\"148\":\"| offset<sup>12+</sup>    | [Offset](arkui-ts/ts-types.md#offset)                        | 否   | 在对齐方式上的偏移。<br/>默认值：{ dx: 0, dy: 0 }，默认没有偏移。<br/>**说明：** <br/>只支持设置px类型的数值，如需设置其他类型的数值，可以将其他类型转为px类型传入，例如需要设置vp，可以将vp改成px传入。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"149\":\"| backgroundColor<sup>12+</sup>    | [ResourceColor](arkui-ts/ts-types.md#resourcecolor) | 否   | 文本提示框背板颜色。<br/>默认值：Color.Transparent<br/>**说明：** <br/>backgroundColor会与模糊属性backgroundBlurStyle叠加产生效果，如果不符合预期，可将backgroundBlurStyle设置为BlurStyle.NONE，即可取消模糊。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"150\":\"| textColor<sup>12+</sup>    | [ResourceColor](arkui-ts/ts-types.md#resourcecolor) | 否   | 文本提示框文本颜色。<br/>默认值：Color.Black<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"151\":\"| backgroundBlurStyle<sup>12+</sup>    | [BlurStyle](arkui-ts/ts-universal-attributes-background.md#blurstyle9) | 否   | 文本提示框背板模糊材质。<br/>默认值：BlurStyle.COMPONENT_ULTRA_THICK<br/>**说明：** <br/>设置为BlurStyle.NONE即可关闭背景虚化。当设置了backgroundBlurStyle为非NONE值时，则不要设置backgroundColor，否则颜色显示将不符合预期效果。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"152\":\"| shadow<sup>12+</sup>    | [ShadowOptions](arkui-ts/ts-universal-attributes-image-effect.md#shadowoptions对象说明)&nbsp;\\\\|&nbsp;[ShadowStyle](arkui-ts/ts-universal-attributes-image-effect.md#shadowstyle10枚举说明) | 否   | 文本提示框背板阴影。<br/>默认值：ShadowStyle.OUTER_DEFAULT_MD<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"153\":\"| enableHoverMode<sup>14+</sup>    | boolean                       | 否   | 是否响应悬停态，值为true时，响应悬停态。<br/>默认值：false，默认不响应。<br/>**原子化服务API：** 从API version 14开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "使用了'类型'和'数值'两个不同的词汇描述同一事物，建议全部使用'类型'。",
      "更改后示例": "只支持设置px类型的数值，如需设置其他类型的数值，可以将其他类型转换为px类型传入，例如需要设置vp类型，可以将vp类型转换为px类型传入。",
      "触发条件": "在同一语境或相邻描述中对同一技术概念使用多个不同术语（如\"类型\"和\"数值\"），且上下文存在明确的标准术语（如\"类型\"）时触发。\n\n识别模式：\n1. 术语冲突检测：在3个相邻句子范围内，发现同一技术属性被两个及以上不同名词指代（如\"数值\"与\"类型\"）\n2. 标准术语验证：通过上下文扫描确认文档已建立标准术语（如其他参数描述均使用\"类型\"）\n3. 功能干扰判断：术语不一致可能造成用户理解歧义（如混淆数值格式与单位类型）"
    },
    {
      "defect_id": 508488,
      "sentence": "| placeholder<sup>12+<sup> | [ComponentContent](../js-apis-arkui-ComponentContent.md)       | 否   | 设置占位符，在UIExtensionComponent与UIExtensionAbility建立连接前显示。 |",
      "reference_sentence": "| code    | number | 否 | 被拉起UIExtensionAbility退出时返回的结果码。 |",
      "line_num": 224,
      "context": "{\"219\":\"\",\"220\":\"\",\"221\":\"| 名称               | 类型                                 | 必填 | 说明                                                                                                      |\",\"222\":\"| ----                 | ---------------------------------------- | ---- | ---------------                                                                                               |\",\"223\":\"| isTransferringCaller | boolean                                  | 否   | 在使用UIExtensionComponent嵌套时，设置当前UIExtensionComponent是否转发上一级的Caller信息。</br> 默认值：false |\",\"224\":\"| placeholder<sup>12+<sup> | [ComponentContent](../js-apis-arkui-ComponentContent.md)       | 否   | 设置占位符，在UIExtensionComponent与UIExtensionAbility建立连接前显示。 |\",\"225\":\"| dpiFollowStrategy<sup>12+<sup> | [DpiFollowStrategy](ts-container-ui-extension-component-sys.md#dpifollowstrategy12)                  | 否   | 提供接口支持设置DPI跟随宿主或跟随UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_DPI |\",\"226\":\"| areaChangePlaceholder<sup>14+<sup> | Record<string, [ComponentContent](../js-apis-arkui-ComponentContent.md)>       | 否   | 设置尺寸变化占位符，在UIExtensionComponent尺寸发生变化并且UIExtension内部渲染未完成时显示, key值支持\\\"FOLD_TO_EXPAND\\\"(折叠展开尺寸变化)、\\\"UNDEFINED\\\"(默认尺寸变化)。 |\",\"227\":\"| windowModeFollowStrategy<sup>18+<sup> | [WindowModeFollowStrategy](ts-container-ui-extension-component-sys.md#windowmodefollowstrategy18)    | 否   | 提供接口以支持设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_WINDOW_MODE |\",\"228\":\"\",\"229\":\"## DpiFollowStrategy<sup>12+</sup>\"}",
      "修改建议": "`<sup>`标签使用不当",
      "更改后示例": "| placeholder<sup>12+</sup> | [ComponentContent](../js-apis-arkui-ComponentContent.md)       | 否   | 设置占位符，在UIExtensionComponent与UIExtensionAbility建立连接前显示。 |",
      "触发条件": "当文档中版本号标注（如\"12+\"）使用`<sup>`标签时出现标签未闭合（缺少闭合标签`</sup>`）或嵌套错误情况。  \n\n识别模式：  \n1. 检测到`<sup>`标签后紧跟版本号（如\"12+\"）但未匹配到对应的闭合标签`</sup>`  \n2. 版本号标注存在连续多个`<sup>`开标签（如`<sup>12+<sup>`）的明显嵌套错误结构"
    },
    {
      "defect_id": 508487,
      "sentence": "### TerminationInfo<sup>12+<sup>",
      "reference_sentence": "### onTerminated<sup>12+<sup>onTerminated(callback: Callback<TerminationInfo>)",
      "line_num": 181,
      "context": "{\"176\":\"\",\"177\":\"| 参数名                       | 类型   | 必填 | 说明                                                         |\",\"178\":\"| ---------------------------- | ------ | ------ | ------------------------------------------------------------ |\",\"179\":\"| callback                        | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback) \\\\<void> | 否 | 回调函数，UIExtensionAbility绘制第一帧时触发本回调，类型为void。    |\",\"180\":\"\",\"181\":\"### TerminationInfo<sup>12+<sup>\",\"182\":\"\",\"183\":\"用于表示被拉起的UIExtensionAbility通过调用`terminateSelfWithResult`或者`terminateSelf`正常退出时的返回结果。\",\"184\":\"\",\"185\":\"**系统接口：** 此接口为系统接口。\",\"186\":\"\"}",
      "修改建议": "前后版本号标注不一致，且`<sup>`标签使用不当",
      "更改后示例": "### TerminationInfo<sup>12+</sup>",
      "触发条件": "当检测到版本号标注（如“12+”）的`<sup>`标签未正确闭合，或同一文档中版本号格式存在不一致（如多余/缺失符号、空格）时触发。"
    },
    {
      "defect_id": 508490,
      "sentence": "| windowModeFollowStrategy<sup>18+<sup> | [WindowModeFollowStrategy](ts-container-ui-extension-component-sys.md#windowmodefollowstrategy18)    | 否   | 提供接口以支持设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_WINDOW_MODE |",
      "reference_sentence": "| code    | number | 否 | 被拉起UIExtensionAbility退出时返回的结果码。 |",
      "line_num": 227,
      "context": "{\"222\":\"| ----                 | ---------------------------------------- | ---- | ---------------                                                                                               |\",\"223\":\"| isTransferringCaller | boolean                                  | 否   | 在使用UIExtensionComponent嵌套时，设置当前UIExtensionComponent是否转发上一级的Caller信息。</br> 默认值：false |\",\"224\":\"| placeholder<sup>12+<sup> | [ComponentContent](../js-apis-arkui-ComponentContent.md)       | 否   | 设置占位符，在UIExtensionComponent与UIExtensionAbility建立连接前显示。 |\",\"225\":\"| dpiFollowStrategy<sup>12+<sup> | [DpiFollowStrategy](ts-container-ui-extension-component-sys.md#dpifollowstrategy12)                  | 否   | 提供接口支持设置DPI跟随宿主或跟随UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_DPI |\",\"226\":\"| areaChangePlaceholder<sup>14+<sup> | Record<string, [ComponentContent](../js-apis-arkui-ComponentContent.md)>       | 否   | 设置尺寸变化占位符，在UIExtensionComponent尺寸发生变化并且UIExtension内部渲染未完成时显示, key值支持\\\"FOLD_TO_EXPAND\\\"(折叠展开尺寸变化)、\\\"UNDEFINED\\\"(默认尺寸变化)。 |\",\"227\":\"| windowModeFollowStrategy<sup>18+<sup> | [WindowModeFollowStrategy](ts-container-ui-extension-component-sys.md#windowmodefollowstrategy18)    | 否   | 提供接口以支持设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_WINDOW_MODE |\",\"228\":\"\",\"229\":\"## DpiFollowStrategy<sup>12+</sup>\",\"230\":\"\",\"231\":\"**系统接口：** 此接口为系统接口。\",\"232\":\"\"}",
      "修改建议": "`<sup>`标签使用不当",
      "更改后示例": "| windowModeFollowStrategy<sup>18+</sup> | [WindowModeFollowStrategy](ts-container-ui-extension-component-sys.md#windowmodefollowstrategy18)    | 否   | 提供接口以支持设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。</br> 默认值：FOLLOW_UI_EXTENSION_ABILITY_WINDOW_MODE |",
      "触发条件": "当文档中存在版本号标注（如\"18+\"）被错误包裹在重复的起始标签`<sup>`而非闭合标签`</sup>`时触发。识别模式为检测到`<sup>X+<sup>`双起始标签结构（X为数字），而非标准`<sup>X+</sup>`闭合结构。"
    },
    {
      "defect_id": 509240,
      "sentence": "中华人民共和国碗岁",
      "reference_sentence": "无",
      "line_num": 1,
      "context": "{\"1\":\"中华人民共和国碗岁  \",\"2\":\"中国任民战无不胜。\"}",
      "修改建议": "句子中的'碗岁'用词不当，应根据上下文确定正确表述",
      "更改后示例": "中华人民共和国万岁",
      "触发条件": "检测到文本中存在同音/形近字错误组合（如\"碗岁\"），且该组合不符合上下文语义逻辑或常见用法模式时触发。\n\n识别模式：通过汉字音形相似性比对，结合上下文语义连贯性分析，当错误组合与相邻语句（如\"战无不胜\"等政治口号）存在显著语义冲突时，判定为需修复的表述不一致问题。"
    },
    {
      "defect_id": 512510,
      "sentence": "当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。",
      "reference_sentence": "当相似度超过50%，加载耗时小于1000ms时启用插帧，否则不启用。",
      "line_num": 9504,
      "context": "{\"9499\":\"\",\"9500\":\"> **说明：**\",\"9501\":\">\",\"9502\":\"> - 需在触发页面加载的接口之后调用，其他约束同[getBlanklessInfoWithKey](#getblanklessinfowithkey20)。\",\"9503\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"9504\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"9505\":\"\",\"9506\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9507\":\"\",\"9508\":\"**参数：**\",\"9509\":\"\"}",
      "修改建议": "前后文使用了不同的术语描述相似的概念，'跳变太大'与'加载耗时小于1000ms'。",
      "更改后示例": "当相似度低于0.33时系统会判定为变化过大，启用插帧会不成功。",
      "触发条件": "当同一技术概念在相邻段落中出现两种以上不同术语表述，且与上下文已建立的术语体系存在冲突时触发。\n\n识别模式：1）在3句范围内存在描述相同判断条件的多个近义词（如\"跳变太大\"与\"变化过大\"） 2）存在与参考句/前文形成对照关系的术语（如\"跳变太大\"与\"加载耗时\"形成逻辑并列但用词风格不统一）"
    },
    {
      "defect_id": 512814,
      "sentence": "当相似度比较低（<0.33）时系统会判定为跳变太大，[setBlanklessLoadingWithKey](./arkts-apis-webview-WebviewController.md#setblanklessloadingwithkey20)接口启用插帧不成功。",
      "reference_sentence": "当相似度比较低（<0.33）时系统会判定为跳变太大，[setBlanklessLoadingWithKey](./arkts-apis-webview-WebviewController.md#setblanklessloadingwithkey20)接口启用插帧不成功。",
      "line_num": 187,
      "context": "{\"182\":\"| ------------------------------- | - | ---------- |\",\"183\":\"| SUCCESS | 0 | 成功。 |\",\"184\":\"| ERR_UNKNOWN   | -1 | 未知错误，内部状态错误等。 |\",\"185\":\"| ERR_INVALID_PARAM   | -2 | 参数不合法。 |\",\"186\":\"| ERR_CONTROLLER_NOT_INITED   | -3 | web controller未绑定组件。 |\",\"187\":\"| ERR_KEY_NOT_MATCH   | -4 | 未匹配到key值，对于[setBlanklessLoadingWithKey](./arkts-apis-webview-WebviewController.md#setblanklessloadingwithkey20)需与[getBlanklessInfoWithKey](./arkts-apis-webview-WebviewController.md#getblanklessinfowithkey20)配套使用并且key值一致，否则返回该错误码。 |\",\"188\":\"| ERR_SIGNIFICANT_CHANGE   | -5 | 当相似度比较低（<0.33）时系统会判定为跳变太大，[setBlanklessLoadingWithKey](./arkts-apis-webview-WebviewController.md#setblanklessloadingwithkey20)接口启用插帧不成功。 |\",\"189\":\"\",\"190\":\"## HistoryItem\",\"191\":\"\",\"192\":\"页面历史记录项。\"}",
      "修改建议": "句式不一致，使用了负面表达，建议改为肯定的祈使句。",
      "更改后示例": "当相似度较低（<0.33）时，系统会判定为跳变太大，[setBlanklessLoadingWithKey](./arkts-apis-webview-WebviewController.md#setblanklessloadingwithkey20)接口不会成功启用插帧。",
      "触发条件": "当同一上下文中的否定表达存在句式结构不一致（如\"启用...不成功\"与\"不会成功启用\"混用），且与文档其他部分的肯定/否定表达模式不匹配时触发。识别模式需检测否定词位置（前置/后置）、动词短语结构一致性，并比对上下文同类表述的语法模式。"
    },
    {
      "defect_id": 512853,
      "sentence": "必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLodaIntercpt中使用。",
      "reference_sentence": "必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLoadIntercept中使用。",
      "line_num": 341,
      "context": "{\"336\":\"获取页面本次加载无白屏预测信息，并启用本次加载过渡帧生成，应用根据此信息确定是否需要启用无白屏加载，具体见返回值说明。\",\"337\":\"\",\"338\":\"\",\"339\":\"> **说明：**\",\"340\":\">\",\"341\":\"> - 必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLodaIntercpt中使用。需在webviewController与web组件绑定之后才能使用。\",\"342\":\"> - 如果发现相似度极低，请确认key值是否传递正确。\",\"343\":\"> - 本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。\",\"344\":\"> - 开销说明：配置开启无白屏加载的页面会有一定的资源开销，开销多少和web组件分辨率相关，假定分辨率宽高分别为：w,h。\",\"345\":\"> - 1. 页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。\",\"346\":\"> - 2. 增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\"}",
      "修改建议": "混用了`onLodaIntercpt`和`onLoadIntercept`，应保持一致。",
      "更改后示例": "必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLoadIntercept中使用。",
      "触发条件": "当同一技术术语在文档中出现拼写变体（如\"onLodaIntercpt\"与\"onLoadIntercept\"）时，或同一接口名称存在拼写/大小写不一致时触发。\n\n识别模式：\n1. 通过驼峰命名法模式匹配技术术语（如首字母小写+大写组合词）\n2. 对比相邻段落/同一功能模块中相同语境下的术语表达\n3. 检测包含相同词根但存在拼写偏差的复合词（如\"Loda\"与\"Load\"的元音差异）\n4. 检查接口名称中下划线连接符与大小写的统一性（如OH_NativeArkWeb前缀的一致性）"
    },
    {
      "defect_id": 517731,
      "sentence": "当JS引擎遇到内存不足的问题时，系统会抛出一个OOM Error，如果开发者提前向JS引擎中注册了OOM-Error的处理函数，系统就会调用这个设置的处理函数，开发者可以在处理函数中执行一些清理或者日志记录操作。",
      "reference_sentence": "当JS引擎遇到内存不足的问题时，系统会抛出一个OOM Error，如果开发者提前向JS引擎中注册了处理OOM Error的函数，系统就会调用这个设置的处理函数，开发者可以在处理函数中执行一些清理或者日志记录操作。",
      "line_num": 10,
      "context": "{\"5\":\"JSVM-API提供了一组用于处理JSVM异常的接口。用户可以通过这些接口，向JSVM中注册回调函数。当JSVM触发异常时，会触发对所注册的回调函数的回调。\",\"6\":\"这些接口提供了对JS引擎中某些关键错误的定制化处理能力，可以帮助开发者在运行时更好地管理错误和异常情况。\",\"7\":\"\",\"8\":\"## 基本概念\",\"9\":\"\",\"10\":\"当JS引擎遇到内存不足的问题时，系统会抛出一个OOM Error，如果开发者提前向JS引擎中注册了OOM-Error的处理函数，系统就会调用这个设置的处理函数，开发者可以在处理函数中执行一些清理或者日志记录操作。\",\"11\":\"当JS引擎发生致命错误时，例如执行JavaScript代码时出现无法恢复的错误，系统会抛出一个Fatal Error，同时系统会调用用户提前设置的处理Fatal Error的函数。在这个处理函数中，用户可以输出额外的日志或者报告错误，而不是让程序直接崩溃。\",\"12\":\"当JavaScript中的Promise被拒绝，而这个拒绝又没有被catch处理时，系统就会抛出一个Promise Reject，同时系统会调用用户提前设置的处理Promise Reject的函数。在这个处理函数中，用户可以处理未捕获的Promise拒绝。\",\"13\":\"\",\"14\":\"## 接口说明\",\"15\":\"\"}",
      "修改建议": "混用了'OOM-Error'和'OOM Error'，应保持一致。",
      "更改后示例": "当JS引擎遇到内存不足的问题时，系统会抛出一个OOM Error，如果开发者提前向JS引擎中注册了处理OOM Error的函数，系统就会调用这个设置的处理函数，开发者可以在处理函数中执行一些清理或者日志记录操作。",
      "触发条件": "同一技术术语在相邻段落或同一主题描述中，出现两种及以上不同拼写形式（如连字符差异、大小写不统一等），且上下文存在明确的命名风格参照。\n\n识别模式：\n1. 术语变异检测：在3个相邻段落内检测到同一核心术语存在拼写差异（如\"OOM-Error\"与\"OOM Error\"）\n2. 风格锚点匹配：上下文中存在该术语的标准写法（如第11段\"Fatal Error\"、第12段\"Promise Reject\"均采用无连字符形式）\n3. 功能表述冲突：变异写法出现在相同语法位置（均作名词性成分）但破坏命名体系一致性"
    },
    {
      "defect_id": 516367,
      "sentence": "将需要执行的Task放到了一个TaskGroup里面，当TaskGroup中的所有Task执行完毕后，会将所有Task的结果都放在一个数组中并返回给宿主线程，而不是每执行完一个Task就返回一次，这样宿主线程就可以在返回的数据里拿到所有Task的执行结果，便于后续使用。",
      "reference_sentence": "如果宿主线程需要所有任务执行完毕的数据，请通过[TaskGroup](../reference/apis-arkts/js-apis-taskpool.md#taskgroup10)的方式实现。",
      "line_num": 50,
      "context": "{\"45\":\"     return iconItemSourceList;\",\"46\":\"   }\",\"47\":\"   ```\",\"48\":\"   <!-- @[implement_child_thread_task](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ConcurrentThreadCommunication/InterThreadCommunicationScenario/entry/src/main/ets/managers/TaskSendDataUsage.ets) -->\",\"49\":\"\",\"50\":\"2. 将需要执行的Task放到了一个TaskGroup里面，当TaskGroup中的所有Task执行完毕后，会将所有Task的结果都放在一个数组中并返回给宿主线程，而不是每执行完一个Task就返回一次，这样宿主线程就可以在返回的数据里拿到所有Task的执行结果，便于后续使用。\",\"51\":\"\",\"52\":\"   ```ts\",\"53\":\"   // MultiTask.ets\",\"54\":\"   import { taskpool } from '@kit.ArkTS';\",\"55\":\"   import { IconItemSource } from './IconItemSource';\"}",
      "修改建议": "前后句子中对TaskGroup的描述不一致，前文提到的是'通过[TaskGroup]的方式实现'，后文描述为'将需要执行的Task放到了一个TaskGroup里面'。",
      "更改后示例": "将需要执行的Task放到一个TaskGroup里面，当TaskGroup中的所有Task执行完毕后，会将所有Task的结果都放在一个数组中并返回给宿主线程，而不是每执行完一个Task就返回一次，这样宿主线程就可以在返回的数据里拿到所有Task的执行结果，便于后续使用。",
      "触发条件": "当同一术语在文档中多次出现时，若出现量词使用不一致（如\"一个TaskGroup\"与\"通过[TaskGroup]的方式实现\"中的零量词差异）或术语格式不统一（如带方括号的[TaskGroup]与纯文本TaskGroup混用），则触发该规则。\n\n识别模式：通过对比上下文术语的呈现形式，检测是否满足以下特征：\n1. 同一核心名词前后出现量词修饰差异（存在/缺失量词）\n2. 术语格式不一致（如带特殊符号的[TaskGroup]与未格式化的TaskGroup交替出现）\n3. 上下文引用方式冲突（如技术文档中带超链接的术语与普通文本术语混用）"
    },
    {
      "defect_id": 517802,
      "sentence": "Mask作为Filter的入参实现对应的效果，该效果中Mask是在屏幕中心向四周扩散的水波环",
      "reference_sentence": "Mask作为Filter的入参实现对应的效果，该效果中Mask是在屏幕左上角的四分之一圆环",
      "line_num": 1035,
      "context": "{\"1030\":\"    Stack() {\",\"1031\":\"      Image('test.jpg')\",\"1032\":\"      Column()\",\"1033\":\"        .width('100%')\",\"1034\":\"        .height('100%')\",\"1035\":\"        // Mask作为Filter的入参实现对应的效果，该效果中Mask是在屏幕中心向四周扩散的水波环\",\"1036\":\"        .backgroundFilter(uiEffect.createFilter().edgeLight(1.0, null, mask))\",\"1037\":\"    }\",\"1038\":\"  }\",\"1039\":\"}\",\"1040\":\"```\"}",
      "修改建议": "混用了“水波环”和“四分之一圆环”的表述",
      "更改后示例": "Mask作为Filter的入参实现对应的效果，该效果中Mask是在屏幕中心向四周扩散的水波形状分布效果",
      "触发条件": "当同一文档中相邻或相关段落对同一技术概念使用了不一致的术语或表述方式（如\"水波环\"与\"四分之一圆环\"），且存在可对照的标准表述时，应触发语言表达一致性规则。通过检测同一上下文(如Mask效果描述)中图形特征词（环/圆环/形状分布）的表述冲突进行识别。"
    },
    {
      "defect_id": 517735,
      "sentence": "在LOG中输出：　JSVM Trigger OOM-Error: success",
      "reference_sentence": "在LOG中输出：　JSVM Trigger OOM Error: success",
      "line_num": 91,
      "context": "{\"86\":\"\",\"87\":\"const char *srcCallNative = R\\\"JS(triggerOOMError();)JS\\\";\",\"88\":\"\",\"89\":\"#### 执行结果\",\"90\":\"\",\"91\":\"在LOG中输出：　JSVM Trigger OOM-Error: success\",\"92\":\"\",\"93\":\"### OH_JSVM_SetHandlerForFatalError\",\"94\":\"通过OH_JSVM_SetHandlerForFatalError，用户可以设置处理Fatal Error的函数。当多次调用这个API进行函数设置时，仅最后一次设置会生效。当用户传入的设置函数为NULL时，则表示取消之前设置的处理函数。\",\"95\":\"#### cpp部分代码：\",\"96\":\"\"}",
      "修改建议": "混用了'OOM-Error'和'OOM Error'，应保持一致。",
      "更改后示例": "在LOG中输出：　JSVM Trigger OOM Error: success",
      "触发条件": "当同一术语在相邻或相关上下文中出现连字符\"-\"与空格格式混用时（如\"OOM-Error\"和\"OOM Error\"），且存在已确立的规范写法（如变量名triggerOOMError中的无连字符形式）需强制保持统一时触发。"
    },
    {
      "defect_id": 512855,
      "sentence": "页面的加载必须在调用本套接口的组件加载。",
      "reference_sentence": "页面的加载必须在调用本套接口的组件加载。",
      "line_num": 379,
      "context": "{\"374\":\"设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。\",\"375\":\"\",\"376\":\"> **说明：**\",\"377\":\">\",\"378\":\"> - 必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。\",\"379\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"380\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"381\":\"\",\"382\":\"**起始版本：** 20\",\"383\":\"\",\"384\":\"**参数：**\"}",
      "修改建议": "句式不一致，应使用祈使句。",
      "更改后示例": "页面的加载必须在调用本套接口的组件中进行。",
      "触发条件": "当技术文档中相邻条款或同一规范体系的说明项存在句式结构差异（如陈述句与祈使句混用），且动词短语与介词短语使用不统一时触发。识别模式为：检测\"必须\"类强制性表述后接的语法结构（如\"组件加载\"动词短语）与上下文同类条款（如\"接口之后调用\"介词短语）存在语法对称性断裂。"
    },
    {
      "defect_id": 512813,
      "sentence": "建议当相似度为0时，应用不是能插帧功能。",
      "reference_sentence": "建议当相似度为0时，应用不是能插帧功能。",
      "line_num": 172,
      "context": "{\"167\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"168\":\"\",\"169\":\"| 名称        | 类型   | 只读 | 可选 |说明                 |\",\"170\":\"| ----------- | ------ | -----|------|------------------- |\",\"171\":\"| errCode | WebBlanklessErrorCode | 否   | 否   | 见[WebBlanklessErrorCode](#webblanklesserrorcode20)定义。 |\",\"172\":\"| similarity | number | 否   | 否   | 无白屏加载的快照相似度，根据历史加载首屏快照计算相似度，范围0~1.0，1.0为完全一致，越接近1，越相似。该值会有滞后性，本地加载的相似性在下次加载时才能反映。建议当相似度为0时，应用不是能插帧功能。 |\",\"173\":\"| loadingTime | int | 否   | 否   | 根据历史加载首屏的耗时估计本次加载的耗时，单位ms，范围>0。 |\",\"174\":\"\",\"175\":\"## WebBlanklessErrorCode<sup>20+</sup>\",\"176\":\"\",\"177\":\"无白屏加载相关的异常错误码。\"}",
      "修改建议": "句式不一致，使用了负面表达，建议改为肯定的祈使句。",
      "更改后示例": "建议当相似度为0时，应用不要启用插帧功能。",
      "触发条件": "当技术文档中的否定表达存在句式结构不一致（如双重否定与直接否定混用）或否定助词搭配错误（如\"不是能\"）时触发；当同一功能说明的祈使句建议存在正反表述不统一时触发。  \n\n识别模式：  \n1. 检测否定结构中是否存在非常规助词组合（如\"不是能\"替代\"不能\"或\"不要启用\"）  \n2. 对比上下文同类建议句式，判断是否违反\"肯定式祈使句优先\"原则（如将否定表达\"不是能\"改为规范否定结构\"不要启用\"）"
    },
    {
      "defect_id": 517732,
      "sentence": "| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM-Error的函数|",
      "reference_sentence": "| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM Error的函数|",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"## 接口说明\",\"15\":\"\",\"16\":\"| 接口                       | 功能说明                            |\",\"17\":\"|----------------------------|-------------------------------------|\",\"18\":\"| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM-Error的函数|\",\"19\":\"| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal-Error的函数|\",\"20\":\"| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise-Reject的函数 |\",\"21\":\"\",\"22\":\"## 使用示例\",\"23\":\"\"}",
      "修改建议": "混用了'OOM-Error'和'OOM Error'，应保持一致。",
      "更改后示例": "| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM Error的函数|",
      "触发条件": "当同一术语在相邻条目或上下文范围内出现连字符使用不一致（如\"OOM-Error\"与\"OOM Error\"混用），且存在已定义的规范表达形式时。\n\n识别模式：\n1. 检测相邻表格行/接口说明中同类术语的命名模式（如\"Fatal-Error\"保持连字符）\n2. 对比问题术语与参考术语的符号使用一致性（连字符 vs 空格）\n3. 验证术语是否在同一文档的其他位置存在标准化表达形式（如参考句中的\"OOM Error\"）"
    },
    {
      "defect_id": 517733,
      "sentence": "| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal-Error的函数|",
      "reference_sentence": "| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal Error的函数|",
      "line_num": 19,
      "context": "{\"14\":\"## 接口说明\",\"15\":\"\",\"16\":\"| 接口                       | 功能说明                            |\",\"17\":\"|----------------------------|-------------------------------------|\",\"18\":\"| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM-Error的函数|\",\"19\":\"| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal-Error的函数|\",\"20\":\"| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise-Reject的函数 |\",\"21\":\"\",\"22\":\"## 使用示例\",\"23\":\"\",\"24\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\"}",
      "修改建议": "混用了'Fatal-Error'和'Fatal Error'，应保持一致。",
      "更改后示例": "| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal Error的函数|",
      "触发条件": "同一术语在相邻接口描述或同一文档范围内出现连字符\"-\"和空格形式混用的情况，且存在参考规范或上下文统一用法。\n\n识别模式：当检测到技术术语(如Fatal Error/OOM Error)在相邻条目中存在拼写差异(如\"Fatal-Error\" vs \"Fatal Error\")，且上下文存在明确统一用法(如其他接口均使用无连字符形式)时触发规则。"
    },
    {
      "defect_id": 517734,
      "sentence": "| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise-Reject的函数 |",
      "reference_sentence": "| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise Reject的函数 |",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"| 接口                       | 功能说明                            |\",\"17\":\"|----------------------------|-------------------------------------|\",\"18\":\"| OH_JSVM_SetHandlerForOOMError         | 用于在VM中设置处理OOM-Error的函数|\",\"19\":\"| OH_JSVM_SetHandlerForFatalError   | 用于在VM中设置处理Fatal-Error的函数|\",\"20\":\"| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise-Reject的函数 |\",\"21\":\"\",\"22\":\"## 使用示例\",\"23\":\"\",\"24\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"25\":\"\"}",
      "修改建议": "混用了'Promise-Reject'和'Promise Reject'，应保持一致。",
      "更改后示例": "| OH_JSVM_SetHandlerForPromiseReject | 用于在VM中设置处理Promise Reject的函数 |",
      "触发条件": "当同一术语在相邻条目或上下文中出现连字符（\"-\"）与空格格式混用时，或与参考句子的连接符形式不一致时。\n\n识别模式：\n1. 检测到相同语义的复合词存在格式差异（如\"X-Y\"与\"X Y\"）\n2. 通过对比相邻条目（如OOM-Error/Fatal-Error）的术语结构，发现当前条目（Promise-Reject）的连接符使用与上下文模式不匹配\n3. 术语中的连接符形式与参考标准（如API命名规范）或权威用例（如参考句子）不一致"
    },
    {
      "defect_id": 518940,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 184,
      "context": "{\"179\":\"// 样例测试js\",\"180\":\"const char* srcCallNative = R\\\"JS(getValueInt64(-123))JS\\\";\",\"181\":\"```\",\"182\":\"<!-- @[oh_jsvm_get_value_int64](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/getvalueint64/src/main/cpp/hello.cpp) -->\",\"183\":\"\",\"184\":\"预期的输出结果：\",\"185\":\"\",\"186\":\"```\",\"187\":\"JSVM GetValueInt64 success: -123\",\"188\":\"```\",\"189\":\"\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻代码块中重复出现相同引导句但缺少具体内容描述，且存在明确示例需要区分预期输出的场景。识别模式为检测到连续或邻近位置出现两次及以上\"预期的输出结果：\"等固定引导语，但未跟随具体结果说明的情况。"
    },
    {
      "defect_id": 518540,
      "sentence": "增加/减少 传入的引用的引用计数，并获取新的计数。",
      "reference_sentence": "增加/减少 传入的引用的引用计数，并获取新的计数。",
      "line_num": 174,
      "context": "{\"169\":\"\",\"170\":\"调用者需要自己管理引用生命周期，引用有效期间 JavaScript 变量不会被垃圾回收处理。\",\"171\":\"\",\"172\":\"### OH_JSVM_ReferenceRef、OH_JSVM_ReferenceUnref\",\"173\":\"\",\"174\":\"增加/减少 传入的引用的引用计数，并获取新的计数。当引用计数被置为 0 后，对于可以被设置为弱引用的 JavaScript 类型（对象、函数、外部变量），引用将被置为弱引用，在垃圾回收机制认为必要的时候该变量会被回收，当变量被回收后，调用 OH_JSVM_GetReferenceValue 会获得 C NULL；对于不可被置为弱引用的 JavaScript 类型，该引用会被清除，调用 OH_JSVM_GetReferenceValue 会获得 C NULL。\",\"175\":\"\",\"176\":\"cpp部分代码：\",\"177\":\"\",\"178\":\"```cpp\",\"179\":\"static JSVM_Value UseReference(JSVM_Env env, JSVM_CallbackInfo info)\"}",
      "修改建议": "表述一致，但建议使用一致的术语“引用”而不是“变量”",
      "更改后示例": "增加/减少传入的引用的引用计数，并获取新的计数。",
      "触发条件": "当同一术语（如“引用”）在上下文或相邻段落中多次出现且已确立为规范表述时，若某处出现同义词（如“变量”）或非统一表述，则触发该规则。识别需检查术语在上下文中的高频重复性及是否存在表述偏差。"
    },
    {
      "defect_id": 518945,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 437,
      "context": "{\"432\":\"// 样例测试js\",\"433\":\"const char* srcCallNative = R\\\"JS(createDouble())JS\\\";\",\"434\":\"```\",\"435\":\"<!-- @[oh_jsvm_create_double](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/createdouble/src/main/cpp/hello.cpp) -->\",\"436\":\"\",\"437\":\"预期的输出结果：\",\"438\":\"\",\"439\":\"```\",\"440\":\"JSVM CreateDouble success: 1.234000\",\"441\":\"```\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻上下文中重复出现相同的引导性语句（如“预期的输出结果：”），且后续重复实例未补充具体描述内容，导致示例与结果映射关系不清晰。"
    },
    {
      "defect_id": 518942,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 283,
      "context": "{\"278\":\"// 样例测试js\",\"279\":\"const char* srcCallNative = R\\\"JS(createInt32())JS\\\";\",\"280\":\"```\",\"281\":\"<!-- @[oh_jsvm_create_int32](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/createint32/src/main/cpp/hello.cpp) -->\",\"282\":\"\",\"283\":\"预期的输出结果：\",\"284\":\"\",\"285\":\"```\",\"286\":\"JSVM CreateInt32 success: -20\",\"287\":\"```\",\"288\":\"\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻上下文中重复出现相同引导性语句（如“预期的输出结果：”），且未跟随具体描述内容时触发。"
    },
    {
      "defect_id": 518825,
      "sentence": "在JSVM-API中，在用户提供的Latin1/UTF16格式字符串所在内存上直接创建对应的JS字符串，和正常的JS字符串能够进行同样的操作。",
      "reference_sentence": "在JSVM-API中，在用户提供的Latin1/UTF16格式字符串所在内存上直接创建对应的JavaScript字符串，和正常的JavaScript字符串能够进行同样的操作。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"JSVM-API中新增创建和使用external string的接口。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，在用户提供的Latin1/UTF16格式字符串所在内存上直接创建对应的JS字符串，和正常的JS字符串能够进行同样的操作。\",\"10\":\"\",\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                                   | 功能说明                       |\",\"14\":\"|----------------------------------------|--------------------------------|\"}",
      "修改建议": "混用了'JS字符串'和'JavaScript字符串'概念",
      "更改后示例": "在JSVM-API中，在用户提供的Latin1/UTF16格式字符串所在内存上直接创建对应的JavaScript字符串，和正常的JavaScript字符串能够进行同样的操作。",
      "触发条件": "同一文档中出现同一术语的全称与缩写混用（如\"JS字符串\"和\"JavaScript字符串\"），且相邻上下文存在相同概念的不同表达形式时触发。\n\n识别模式：\n1. 术语变异检测：识别核心术语的缩写/全称形态（如\"JS\"与\"JavaScript\"）\n2. 邻近性验证：检查同一段落内（特别是相邻句子）是否存在混合使用情况\n3. 概念一致性判断：确认不同表达形式指向同一技术实体（通过词根匹配和上下文语义分析）\n4. 首次出现验证：若文档已明确定义术语规范（如首次使用全称+括号标注缩写），后续出现非规范形式则触发规则"
    },
    {
      "defect_id": 518922,
      "sentence": "在使用JSVM-API接口时，可能需要从JSVM模块数值类型转换为JavaScript数值类型值，或者从JavaScript数据类型值转换为JSVM模块数值类型。",
      "reference_sentence": "在使用JSVM-API接口时，可能需要从JSVM模块数值类型转换为JavaScript数值类型，或者从JavaScript数值类型转换为JSVM模块数值类型。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"当使用JSVM-API接口进行数值类型的创建和获取时，需要了解以下基本概念：\",\"10\":\"\",\"11\":\"- **数值类型** 在使用JSVM-API接口时，可能需要从JSVM模块数值类型转换为JavaScript数值类型值，或者从JavaScript数据类型值转换为JSVM模块数值类型。在进行数据类型转换时，需要注意数据范围是否匹配，以及有无符号整数和双精度数值等区别。\",\"12\":\"- **错误处理** 在使用这些接口时，需要对可能发生的错误进行适当处理。例如，在创建整数值时可能发生内存分配错误或其他运行时错误，需要使用JSVM-API提供的错误处理机制来捕获并处理这些错误。\",\"13\":\"- **JavaScript交互** 在开发过程中，需要考虑如何将创建的数值类型值与JavaScript环境进行交互，包括传递参数、返回值等。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\"}",
      "修改建议": "混用了`数值类型值`和`数值类型`，术语不一致",
      "更改后示例": "在使用JSVM-API接口时，可能需要从JSVM模块数值类型转换为JavaScript数值类型，或者从JavaScript数值类型转换为JSVM模块数值类型。",
      "触发条件": "同一术语在相邻段落中出现不一致的变体表达（如\"数值类型值\"与\"数值类型\"混用），且存在明确定义的基准术语（如上下文已确立的\"数值类型\"标准表述）。需通过术语词根匹配（如\"数值类型\"）识别冗余词缀（如\"值\"）或多余限定词。"
    },
    {
      "defect_id": 518521,
      "sentence": "JSVM_Value的生命周期与JavaScript值的生命周相关。",
      "reference_sentence": "JSVM_Value的生命周期与JavaScript值的生命周期相关。",
      "line_num": 6,
      "context": "{\"1\":\"# 使用JSVM-API接口进行生命周期相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"在JSVM-API中，JSVM_Value是一个表示JavaScript值的抽象类型，它可以表示任何JavaScript值，包括基本类型（如数字、字符串、布尔值）和对象类型（如数组、函数、对象等）。\",\"6\":\"JSVM_Value的生命周期与JavaScript值的生命周相关。JavaScript值被垃圾回收时，JSVM_Value不再有效。不要在JavaScript值不再存在时使用JSVM_Value。\",\"7\":\"\",\"8\":\"框架层的scope通常用于管理JSVM_Value的生命周期。在JSVM-API中，可以使用OH_JSVM_OpenHandleScope和OH_JSVM_CloseHandleScope函数来创建和销毁scope。通过在scope内创建JSVM_Value，可以确保在scope结束时自动释放JSVM_Value，避免内存泄漏。\",\"9\":\"\",\"10\":\"JSVM_Ref是一个JSVM-API类型，用于管理JSVM_Value的生命周期。JSVM_Ref允许您在JSVM_Value的生命周期内保持对其的引用，即使它已经超出了其原始上下文的范围。这使得您可以在不同的上下文中共享JSVM_Value，并确保在不再需要时正确释放其内存。\",\"11\":\"\"}",
      "修改建议": "混用了'生命周'和'生命周期'概念。",
      "更改后示例": "JSVM_Value的生命周期与JavaScript值的生命周期相关。",
      "触发条件": "同一术语或概念在相邻上下文或同一段落中出现不一致的简化/变体（如\"生命周\"与\"生命周期\"混用），且存在明确的标准表达形式（如参考句中的统一用法）。"
    },
    {
      "defect_id": 518941,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 233,
      "context": "{\"228\":\"// 样例测试js\",\"229\":\"const char* srcCallNative = R\\\"JS(getDouble(-110.0456))JS\\\";\",\"230\":\"```\",\"231\":\"<!-- @[oh_jsvm_get_value_double](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/getvaluedouble/src/main/cpp/hello.cpp) -->\",\"232\":\"\",\"233\":\"预期的输出结果：\",\"234\":\"\",\"235\":\"```\",\"236\":\"JSVM GetDouble success: -110.045600\",\"237\":\"```\",\"238\":\"\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻段落中重复使用相同占位语句（如“预期的输出结果：”）且未填充具体内容，导致多个示例输出描述缺失时触发。  \n识别模式：检测到连续/邻近段落中存在完全相同的非具体化表达结构（例如空值占位符），且上下文存在代码示例但缺乏对应结果说明时判定为需修复。"
    },
    {
      "defect_id": 518895,
      "sentence": "JSVM-API中装箱类型(Wrapper object)判断相关接口支持通过不同API快速判断object的装箱类型。",
      "reference_sentence": "JSVM-API中，装箱类型相关接口能够给用户提供快速判断5种不同装箱类型能力。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行Wrapper object相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"JSVM-API中装箱类型(Wrapper object)判断相关接口支持通过不同API快速判断object的装箱类型。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，装箱类型相关接口能够给用户提供快速判断5种不同装箱类型能力。\",\"10\":\"\"}",
      "修改建议": "混用了“装箱类型(Wrapper object)”和“装箱类型”两种表述方式，应保持一致。",
      "更改后示例": "JSVM-API中，装箱类型(Wrapper object)判断相关接口支持通过不同API快速判断object的装箱类型。",
      "触发条件": "同一术语在邻近上下文中出现带括号注释和纯中文两种表述形式，或同一术语存在重复但结构不一致的注释模式。\n\n识别模式：\n1. 检测相邻段落/句子中同一核心术语是否同时存在\"中文(English)\"和\"纯中文\"两种形态\n2. 检查术语注释括号是否保持统一（如首次出现带注释，后续出现无注释时应触发）\n3. 匹配重复术语后的括号内容是否完全一致（如\"装箱类型(Wrapper object)\"与\"装箱类型\"属于注释缺失型不一致）"
    },
    {
      "defect_id": 518944,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 387,
      "context": "{\"382\":\"// 样例测试js\",\"383\":\"const char* srcCallNative = R\\\"JS(createInt64())JS\\\";\",\"384\":\"```\",\"385\":\"<!-- @[oh_jsvm_create_int64](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/createint64/src/main/cpp/hello.cpp) -->\",\"386\":\"\",\"387\":\"预期的输出结果：\",\"388\":\"\",\"389\":\"```\",\"390\":\"JSVM CreateInt64 success: 2147483648\",\"391\":\"```\",\"392\":\"\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻上下文中重复出现相同的引导句（如“预期的输出结果：”）且未跟随具体描述内容，或同一文档内多个示例使用相同引导句但未差异化说明预期结果时触发。"
    },
    {
      "defect_id": 518896,
      "sentence": "在JSVM-API中，装箱类型相关接口能够给用户提供快速判断5种不同装箱类型能力。",
      "reference_sentence": "JSVM-API中装箱类型(Wrapper object)判断相关接口支持通过不同API快速判断object的装箱类型。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"JSVM-API中装箱类型(Wrapper object)判断相关接口支持通过不同API快速判断object的装箱类型。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，装箱类型相关接口能够给用户提供快速判断5种不同装箱类型能力。\",\"10\":\"\",\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                                    | 功能说明                       |\",\"14\":\"|----------------------------------------|--------------------------------|\"}",
      "修改建议": "混用了“装箱类型”和“装箱类型(Wrapper object)”两种表述方式，应保持一致。",
      "更改后示例": "在JSVM-API中，装箱类型(Wrapper object)相关接口能够给用户提供快速判断5种不同装箱类型能力。",
      "触发条件": "同一术语在文档中存在带括号说明与不带括号的简洁形式混用，且上下文已存在该术语的标准完整表达形式（如首次定义或引用时使用的\"术语(补充说明)\"格式）。\n\n识别模式：\n1. 检测相邻段落中是否存在同一术语的完整/缩写混合形态（如\"装箱类型(Wrapper object)\" vs \"装箱类型\"）\n2. 当某段落出现简洁术语时，检查文档前文是否已定义过带补充说明的完整形式\n3. 验证术语使用是否符合\"首次完整定义，后续统一简称\"的文档规范要求"
    },
    {
      "defect_id": 518943,
      "sentence": "预期的输出结果：",
      "reference_sentence": "预期的输出结果：",
      "line_num": 337,
      "context": "{\"332\":\"// 样例测试js\",\"333\":\"const char* srcCallNative = R\\\"JS(createUInt32())JS\\\";\",\"334\":\"```\",\"335\":\"<!-- @[oh_jsvm_create_uint32](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/JSVMAPI/JsvmUsageGuide/JsvmBasicDataTypes/createuint32/src/main/cpp/hello.cpp) -->\",\"336\":\"\",\"337\":\"预期的输出结果：\",\"338\":\"\",\"339\":\"```\",\"340\":\"JSVM CreateUInt32 success: 26\",\"341\":\"```\",\"342\":\"\"}",
      "修改建议": "同一段落中重复使用相同的句子，导致表意模糊，建议在每个示例中明确描述预期的输出结果",
      "更改后示例": "预期的输出结果：具体的输出结果描述",
      "触发条件": "同一段落或相邻上下文中重复出现相同描述性语句（如“预期的输出结果：”），且未跟随具体差异化内容时触发。识别模式为连续/邻近行存在完全相同的引导句（如问题句子与参考句子重复），且未明确关联具体示例的输出结果。"
    },
    {
      "defect_id": 518921,
      "sentence": "在JavaScript中，整数类型是一种基本数据类型，用于表示没有小数部分的数值。double类型用于表示有小数的数值。",
      "reference_sentence": "在JavaScript中，整数类型是一种基本数据类型，用于表示没有小数部分的数值。Double类型用于表示有小数的数值。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口创建基本数据类型\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"在JavaScript中，整数类型是一种基本数据类型，用于表示没有小数部分的数值。double类型用于表示有小数的数值。JavaScript的数值存储方式会导致在某些情况下无法准确表示非常大或非常小的数值，在这种情况下，需要使用BigInt对应的JSVM-API接口来处理更大范围的整数。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"当使用JSVM-API接口进行数值类型的创建和获取时，需要了解以下基本概念：\",\"10\":\"\"}",
      "修改建议": "混用了`double`和`Double`，术语大小写不一致",
      "更改后示例": "在JavaScript中，整数类型是一种基本数据类型，用于表示没有小数部分的数值。Double类型用于表示有小数的数值。",
      "触发条件": "同一术语在相邻或相近段落中出现大小写不一致（如double/Double），且上下文存在明确的术语规范（如BigInt采用首字母大写）时触发。\n\n识别模式：\n1. 术语重复检测：在文档扫描范围内（建议3-5个相邻段落）发现同一术语存在不同大小写形式\n2. 规范锚点识别：上下文存在同类术语的标准化书写形式（如示例中的BigInt采用首字母大写）\n3. 技术语境验证：术语属于编程语言/框架的专有名词范畴（类型名称、API接口等）"
    },
    {
      "defect_id": 518377,
      "sentence": "用于判断给定的JSVM_Value是否表示一个error对象。",
      "reference_sentence": "用于判断给定的JSVM_Value是否表示一个Error对象。",
      "line_num": 297,
      "context": "{\"292\":\"JSVM error message: throw syntax error, error code: JsVmThrowSyntaxError\",\"293\":\"```\",\"294\":\"\",\"295\":\"### OH_JSVM_IsError\",\"296\":\"\",\"297\":\"用于判断给定的JSVM_Value是否表示一个error对象。\",\"298\":\"\",\"299\":\"cpp部分代码：\",\"300\":\"\",\"301\":\"```cpp\",\"302\":\"// hello.cpp\"}",
      "修改建议": "混用了`error`和`Error`概念",
      "更改后示例": "用于判断给定的JSVM_Value是否表示一个Error对象。",
      "触发条件": "同一技术术语在相邻段落/代码注释中出现大小写不一致（如error vs Error），且上下文指向相同技术概念时触发。识别模式需检测术语在技术规范中的标准形式（如Error对象首字母大写）与文档实际使用形式（如小写error）是否匹配。"
    },
    {
      "defect_id": 515465,
      "sentence": "Promise是一个JavaScript对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。",
      "reference_sentence": "Promise是JavaScript中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"Promise是JavaScript中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在JavaScript中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个JavaScript对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\",\"17\":\"\",\"18\":\"这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。JSVM-API提供的方法可以帮助开发者在JSVM模块中处理JavaScript中的异步操作。\"}",
      "修改建议": "前文使用了'JavaScript中用来处理异步操作的对象'，后文使用了'JavaScript对象'，描述不一致。",
      "更改后示例": "Promise是JavaScript中用来处理异步操作的对象，Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。",
      "触发条件": "同一术语或核心概念在相邻/相近上下文中出现不一致的修饰语（如\"JavaScript中用来处理异步操作的对象\" vs \"JavaScript对象\"）或结构表达时触发。\n\n识别模式：\n1. 在术语定义区域（如词条列表、概念解释段落）检测重复出现的核心术语\n2. 对比相邻条目/段落中针对同一概念的描述性短语结构（如\"用来处理...\" vs \"用于...\"）\n3. 验证修饰语成分是否保持统一（如位置关系：前置定语\"JavaScript中用来...\" vs 后置定语\"JavaScript对象，用于...\"）"
    },
    {
      "defect_id": 518824,
      "sentence": "JSVM-API中新增创建和使用external string的接口。",
      "reference_sentence": "JSVM-API中新增创建和使用外部字符串的接口。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口提供Latin1/UTF16格式字符串相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"JSVM-API中新增创建和使用external string的接口。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，在用户提供的Latin1/UTF16格式字符串所在内存上直接创建对应的JS字符串，和正常的JS字符串能够进行同样的操作。\",\"10\":\"\"}",
      "修改建议": "混用了'external string'和'外部字符串'概念",
      "更改后示例": "JSVM-API中新增创建和使用外部字符串的接口。",
      "触发条件": "同一术语在文档中存在中英文混用（如\"external string\"与\"外部字符串\"交替出现），或与上下文已定义的中文术语不一致时触发。\n\n识别模式：\n1. 检测专业术语是否同时存在英文原词和中文翻译形式（如：external string→外部字符串）\n2. 检查上下文是否存在该术语的官方中文定义（如参考句中的\"外部字符串\"）\n3. 验证当前用词是否与文档已建立的术语体系冲突（如问题句英文形式与参考句中文形式不匹配）"
    },
    {
      "defect_id": 518330,
      "sentence": "用于获取当前版本信息。",
      "reference_sentence": "用于获取当前版本信息。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口获取JSVM API的版本号\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"用于获取当前版本信息。\",\"6\":\"\",\"7\":\"## 接口说明\",\"8\":\"\",\"9\":\"| 接口                       | 功能说明                       |\",\"10\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子表述不明确，建议使用更具体的表述。",
      "更改后示例": "用于获取当前JSVM API的版本信息。",
      "触发条件": "当句子中的核心名词（如“版本信息”）缺乏上下文关键限定词（如“JSVM API”），且文档其他部分已明确定义该限定词时触发。\n\n识别模式：\n1. 检测泛化表述：识别如“当前版本信息”等未绑定具体对象的名词短语；\n2. 上下文匹配验证：检查标题/相邻段落是否包含可补充的限定词（如标题含\"JSVM API\"）；\n3. 术语一致性校验：对比文档全局术语库，发现未使用已定义的专业术语。"
    },
    {
      "defect_id": 518480,
      "sentence": "在指定的主机和端口上激活inspector，将用来调试JS代码。",
      "reference_sentence": "OH_JSVM_OpenInspector和OH_JSVM_CloseInspector接口提供了在特定主机和端口上激活和关闭inspector的功能，inspector是一个用于调试JavaScript代码的工具，允许开发者实时查看和交互程序的运行状态。",
      "line_num": 182,
      "context": "{\"177\":\"\",\"178\":\"获取当前堆快照并将其输出到流。\",\"179\":\"\",\"180\":\"### OH_JSVM_OpenInspector\",\"181\":\"\",\"182\":\"在指定的主机和端口上激活inspector，将用来调试JS代码。\",\"183\":\"\",\"184\":\"### OH_JSVM_CloseInspector\",\"185\":\"\",\"186\":\"尝试关闭剩余的所有inspector连接。\",\"187\":\"\"}",
      "修改建议": "混用了'inspector'和'inspector'，但表述不一致，建议统一表述。",
      "更改后示例": "在指定的主机和端口上激活inspector，用于调试JavaScript代码。",
      "触发条件": "当同一技术术语在相邻上下文中存在全称与缩写混用（如\"JS\"和\"JavaScript\"），且文档其他部分存在该术语的规范表述时触发。\n\n识别模式：\n1. 检测相邻段落/标题中同一概念存在不同表述形式（如缩略语与全称）\n2. 交叉验证接口名称、功能描述等上下文是否包含规范术语（如接口名\"OH_JSVM\"隐含\"JS\"应扩展为\"JavaScript\"）\n3. 检查技术名词是否与参考段落（如inspector工具定义）的表述形式保持一致"
    },
    {
      "defect_id": 518925,
      "sentence": "将JavaScript value转为JSVM模块中的int64类型数据。",
      "reference_sentence": "将JavaScript value转为JSVM模块中的Int64类型数据。",
      "line_num": 141,
      "context": "{\"136\":\"JSVM GetValueInt32 success: -123\",\"137\":\"```\",\"138\":\"\",\"139\":\"### OH_JSVM_GetValueInt64\",\"140\":\"\",\"141\":\"将JavaScript value转为JSVM模块中的int64类型数据。\",\"142\":\"\",\"143\":\"cpp部分代码：\",\"144\":\"\",\"145\":\"```cpp\",\"146\":\"// hello.cpp\"}",
      "修改建议": "混用了`int64`和`Int64`，术语大小写不一致",
      "更改后示例": "将JavaScript value转为JSVM模块中的Int64类型数据。",
      "触发条件": "同一技术术语在文档中出现大小写不一致（如int64与Int64混用），且存在明确定义的规范拼写形式（如代码示例或API名称中使用的Int64）。\n\n识别模式：通过对比文档正文与代码示例/API名称中的术语形态，检测到技术名词存在驼峰式(Int64)与全小写(int64)混用时，识别为术语不一致问题。"
    },
    {
      "defect_id": 518374,
      "sentence": "用于抛出JavaScript Error对象。当在本机代码中发生错误或检测到不符合预期的情况时，可以使用此接口来抛出一个Javascript Error，使其能够被捕获并处理。",
      "reference_sentence": "用于抛出一个带文本信息的JS Error。",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"34\":\"\",\"35\":\"### OH_JSVM_Throw\",\"36\":\"\",\"37\":\"用于抛出JavaScript Error对象。当在本机代码中发生错误或检测到不符合预期的情况时，可以使用此接口来抛出一个Javascript Error，使其能够被捕获并处理。示例参考OH_JSVM_CreateError。\",\"38\":\"\",\"39\":\"### OH_JSVM_CreateError\",\"40\":\"\",\"41\":\"创建并获取一个带文本信息的JavaScript Error。\",\"42\":\"\"}",
      "修改建议": "前后描述不一致，前文使用了'JavaScript Error对象'，后文使用了'Javascript Error'。",
      "更改后示例": "用于抛出JavaScript Error对象。当在本机代码中发生错误或检测到不符合预期的情况时，可以使用此接口来抛出JavaScript Error，使其能够被捕获并处理。",
      "触发条件": "同一术语在相邻或同一上下文中存在拼写/大小写不一致（如\"Javascript\"与\"JavaScript\"）、或术语结构不一致（如\"Error对象\"与\"Error\"单独使用）时触发。\n\n识别模式：\n1. **术语变形检测**：识别核心术语（如JavaScript Error）是否出现大小写变形（Javascript/JAVASCRIPT）、缩写变形（JS Error）或附加词增减（Error对象 vs Error）\n2. **邻近上下文比对**：在相同段落/相邻语句中，检测对同一实体的描述是否保持完全一致的命名格式\n3. **跨语言混合校验**：当术语包含多语言元素（如\"JSVM-API\"）时，需校验连字符、大小写组合是否统一"
    },
    {
      "defect_id": 518924,
      "sentence": "将JavaScript value转为JSVM模块中的int32类型数据。",
      "reference_sentence": "将JavaScript value转为JSVM模块中的Int32类型数据。",
      "line_num": 87,
      "context": "{\"82\":\"JSVM GetValueUint32 success: 123\",\"83\":\"```\",\"84\":\"\",\"85\":\"### OH_JSVM_GetValueInt32\",\"86\":\"\",\"87\":\"将JavaScript value转为JSVM模块中的int32类型数据。\",\"88\":\"\",\"89\":\"cpp部分代码：\",\"90\":\"\",\"91\":\"```cpp\",\"92\":\"// hello.cpp\"}",
      "修改建议": "混用了`int32`和`Int32`，术语大小写不一致",
      "更改后示例": "将JavaScript value转为JSVM模块中的Int32类型数据。",
      "触发条件": "同一术语在文档中出现大小写不一致（如int32与Int32混用），且上下文存在该术语的标准大写形式（如代码/接口名称使用Int32）时触发。  \n\n识别模式：检测相邻段落或代码示例中相同技术术语的大小写差异，当名词在普通描述与代码/接口引用中存在驼峰式（Int32）与全小写（int32）混用时，判定为术语不一致需修复。"
    },
    {
      "defect_id": 515466,
      "sentence": "OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript Promise",
      "reference_sentence": "OH_JSVM_CreatePromise        | 创建一个延迟对象和一个JavaScript promise",
      "line_num": 27,
      "context": "{\"22\":\"| 接口                       | 功能说明                       |\",\"23\":\"|----------------------------|--------------------------------|\",\"24\":\"| OH_JSVM_IsPromise            | 查询Promise是否为Promise对象|\",\"25\":\"| OH_JSVM_CreatePromise        | 创建一个延迟对象和一个JavaScript promise|\",\"26\":\"| OH_JSVM_ResolveDeferred      | 通过与之关联的延迟对象来解析JavaScript promise|\",\"27\":\"| OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript Promise|\",\"28\":\"| OH_JSVM_PromiseRegisterHandler | 为 Promise 创建兑现或拒绝后的回调 |\",\"29\":\"\",\"30\":\"## 使用示例\",\"31\":\"\",\"32\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\"}",
      "修改建议": "前文使用了'JavaScript promise'，后文使用了'JavaScript Promise'，大小写不一致。",
      "更改后示例": "OH_JSVM_RejectDeferred       | 通过与之关联的延迟对象来拒绝JavaScript promise",
      "触发条件": "同一术语在相邻或相关上下文中出现大小写不一致（如\"promise\"与\"Promise\"），且该术语在文档其他位置存在已确定的标准化表达形式（如参考句中的小写形式）。\n\n识别模式：\n1. **术语定位**：识别特定领域术语（如\"JavaScript promise\"）在文档中的首次定义或高频使用形式；\n2. **上下文对比**：检查相邻条目（如同一表格中的接口说明行）或相同语法结构位置（如接口功能描述字段）的术语表达；\n3. **格式差异检测**：通过字符级比对发现同一术语存在仅大小写不同的变体（如\"Promise\" vs \"promise\"）；\n4. **冲突验证**：确认术语未因特殊语义需要（如作为类名/专有名词）而必须保持特定大小写形式。"
    },
    {
      "defect_id": 518972,
      "sentence": "将检索给定环境的虚拟机实例。",
      "reference_sentence": "OH_JSVM_GetVM  |  将检索给定环境的虚拟机实例。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"JSVM，即标准JS引擎，是严格遵守Ecmascript规范的JavaScript代码执行引擎。详情参考：[JSVM](../reference/common/_j_s_v_m.md)。\",\"4\":\"基于JSVM的JS代码调试调优能力包括：Debugger、CPU Profiler、Heap Snapshot、Heap Statistics。涉及以下接口：\",\"5\":\"| 接口名  |  接口功能 |\",\"6\":\"|---|---|\",\"7\":\"| OH_JSVM_GetVM  |  将检索给定环境的虚拟机实例。 |\",\"8\":\"| OH_JSVM_GetHeapStatistics  |  返回一组虚拟机堆的统计数据。 |\",\"9\":\"| OH_JSVM_StartCpuProfiler  |  创建并启动一个CPU profiler。 |\",\"10\":\"| OH_JSVM_StopCpuProfiler  |  停止CPU profiler并将结果输出到流。 |\",\"11\":\"| OH_JSVM_TakeHeapSnapshot  |  获取当前堆快照并将其输出到流。 |\",\"12\":\"| OH_JSVM_OpenInspector  |  在指定的主机和端口上激活inspector，将用来调试JS代码。 |\"}",
      "修改建议": "用词不一致，'检索'应改为'获取'，与上文保持一致。",
      "更改后示例": "获取给定环境的虚拟机实例。",
      "触发条件": "当同一上下文存在多个相同功能的动词表述（如\"检索\"和\"获取\"），且相邻接口描述已建立固定用词模式（如\"获取\"被其他接口重复使用）时触发。"
    },
    {
      "defect_id": 518974,
      "sentence": "本文将介绍调试、CPU Profiler、Heap Snapshot的使用方法。",
      "reference_sentence": "基于JSVM的JS代码调试调优能力包括：Debugger、CPU Profiler、Heap Snapshot、Heap Statistics。涉及以下接口：",
      "line_num": 18,
      "context": "{\"13\":\"| OH_JSVM_OpenInspectorWithName | 基于传入的 pid 和 name 激活 inspector。 |\",\"14\":\"| OH_JSVM_CloseInspector  |  尝试关闭剩余的所有inspector连接。 |\",\"15\":\"| OH_JSVM_WaitForDebugger  |  等待主机与inspector建立socket连接，连接建立后程序将继续运行。发送Runtime.runIfWaitingForDebugger命令。 |\",\"16\":\"\",\"17\":\"\",\"18\":\"本文将介绍调试、CPU Profiler、Heap Snapshot的使用方法。\",\"19\":\"\",\"20\":\"## 调试能力使用方法\",\"21\":\"\",\"22\":\"### 使用 OH_JSVM_OpenInspector\",\"23\":\"\"}",
      "修改建议": "用词不一致，'调试'应改为'Debugger'，与上文保持一致。",
      "更改后示例": "本文将介绍Debugger、CPU Profiler、Heap Snapshot的使用方法。",
      "触发条件": "当同一术语在文档中存在中英文混用，且上下文已建立明确英文术语标准（如接口名称、前文定义）时触发。\n\n识别模式：\n1. 检测中文词汇是否对应上下文/参考句中的英文专有名词（如\"调试\"对应\"Debugger\"）\n2. 验证该英文术语是否已在相邻段落（如接口定义表）、前文技术名词列表或规范文档中被明确定义"
    },
    {
      "defect_id": 520405,
      "sentence": "那么在 native 层，要解决冷启动和生成 code cache 之间的矛盾",
      "reference_sentence": "无",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"上面在考虑减少 v8 层开销的时候，提到了为了热启动的性能可以开启 `eager compile` 进行编译，而为了冷启动性能却又需要关闭 `eager compile` 选项，看起来是矛盾的。为了解决这个矛盾，避免在冷热启动性能上的权衡，关键点是在 code cache 生成本身。\",\"59\":\"\",\"60\":\"首先 code cache 的生成是需要前置的编译的，其次生成 code cache 本身也存在开销；\",\"61\":\"\",\"62\":\"那么在 native 层，要解决冷启动和生成 code cache 之间的矛盾，首先我们可以另起一个线程用于生成 code cache，这样避免了生成 code cache 这个操作本身对冷启动的影响；\",\"63\":\"\",\"64\":\"然后，有两个方法可以参考(下面的伪代码仅用于展示逻辑流程，不涉及真正的 api 调用)：\",\"65\":\"\",\"66\":\"- 将生成 code cache 必需的前置编译也放到新增的线程上，这样编译选项可以分开使用：生成 code cache 打开 `eager compile`，冷启动运行则关闭，这样做的缺点是可能进一步提高运行时的峰值资源占用，优点是 code cache 生成和运行可以完全解耦，不再需要考虑生成 code cache 的时间点。这个流程的伪代码如下所示\",\"67\":\"\"}",
      "修改建议": "术语不一致，'native'应与前文的'本地层'一致",
      "更改后示例": "那么在 本地层，要解决冷启动和生成 code cache 之间的矛盾",
      "触发条件": "当同一技术术语在上下文中已存在中文译法时，出现对应的英文原词或不同译法。\n\n识别模式：\n1. 通过上下文扫描建立术语对照表（如\"native=本地层\"）\n2. 检测新句子中英文术语是否与最近的中文译法冲突\n3. 当英文术语在相邻段落（3-5句内）存在已定义译法时触发\n4. 优先匹配相同技术概念链中的术语（如本案例的\"层\"上下文）"
    },
    {
      "defect_id": 520385,
      "sentence": "校验生成 cache 的 js 源码，是否与当前输入源码长度一致",
      "reference_sentence": "校验生成 cache 的 js 源码，是否与当前输入源码长度一致",
      "line_num": 18,
      "context": "{\"13\":\"## code cache 校验规格说明\",\"14\":\"| 规格       | 规格说明                                            |\",\"15\":\"| ---------- | -------------------------------------------------- |\",\"16\":\"| 完整性校验  | 校验 cache 实际长度，是否与生成时一致                 |\",\"17\":\"| 兼容性校验  | 校验生成 cache 的 JSVM 版本与编译选项是否与当前一致    |\",\"18\":\"| 一致性校验  | 校验生成 cache 的 js 源码，是否与当前输入源码长度一致  |\",\"19\":\"\",\"20\":\"## 场景示例\",\"21\":\"\",\"22\":\"下面的伪代码是一个典型的使用方法，其中第二次编译，如果 cacheRejected 为 true，那么说明 code cache 被拒绝无法生效，运行时间会与无 code cache 时间一致；为 false 则这次运行将会极大加快。\",\"23\":\"\"}",
      "修改建议": "混用了“校验”和“检查”",
      "更改后示例": "检查生成 cache 的 js 源码，是否与当前输入源码长度一致",
      "触发条件": "在同一上下文或相邻条目中存在相同语义的动词混用（如\"校验\"与\"检查\"），且上下文存在结构化表达（表格/列表）要求术语统一时触发。\n\n识别模式：当文档中重复出现的结构化条目（如规格说明表格）在相同语法位置（如动词位）出现同义词交替使用，且参考相邻条目存在明确术语范式（如\"完整性校验\"、\"兼容性校验\"等均使用\"校验\"）时，判定为术语不一致需要修复。"
    },
    {
      "defect_id": 520384,
      "sentence": "将 OH_JSVM_CreateCodeCache 生成的 code cache 保存，等待下一次编译时，作为参数传递给 compile 系列接口",
      "reference_sentence": "将 OH_JSVM_CreateCodeCache 生成的 code cache 保存，等待下一次编译时，作为参数传递给 compile 系列接口",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"JSVM 提供了生成并使用 code cache 加速编译过程的方法，其获取和使用分为下面几个部分：\",\"6\":\"\",\"7\":\"- 首先使用 compile 系列接口编译得到 JSVM_Script\",\"8\":\"- 使用 OH_JSVM_CreateCodeCache 接口，传入编译完成后生成的 JSVM_Script\",\"9\":\"- 将 OH_JSVM_CreateCodeCache 生成的 code cache 保存，等待下一次编译时，作为参数传递给 compile 系列接口\",\"10\":\"\",\"11\":\"通过上述流程，将会在使用 code cache 的那次编译中，极大减少编译时间，其原理为将编译完成的 script 序列化，然后使用 code cache 编译时就不再需要重新解析/编译已经被序列化的函数，只需要进行一次反序列化即可，这样编译就简化为了一次数据读取。\",\"12\":\"\",\"13\":\"## code cache 校验规格说明\",\"14\":\"| 规格       | 规格说明                                            |\"}",
      "修改建议": "混用了“传入”和“传递”",
      "更改后示例": "将 OH_JSVM_CreateCodeCache 生成的 code cache 保存，等待下一次编译时，作为参数传入 compile 系列接口",
      "触发条件": "同一技术动作在相邻步骤描述中混用近义动词（如\"传递\"与\"传入\"），且上下文存在相同操作场景的标准化表达参照（如参数传递统一使用\"传入\"）。\n\n识别模式：\n1. 检测相邻步骤描述中相同操作对象（如code cache参数）的传递动作\n2. 对比动词使用与上下文已建立的表达惯例（如问题上下文第8行已确立\"传入\"作为标准术语）\n3. 当发现同义动词混用（传递→传入）且破坏术语统一性时触发规则"
    },
    {
      "defect_id": 520388,
      "sentence": "对于第一种情况，这个参数会被置为 true，而后两种情况都是 false，因此需要注意即使 reject 为 false，也不能说明 code cache 被接收了",
      "reference_sentence": "对于第一种情况，这个参数会被置为 true，而后两种情况都是 false，因此需要注意即使 reject 为 false，也不能说明 code cache 被接收了",
      "line_num": 126,
      "context": "{\"121\":\"\",\"122\":\"- code cache 校验失败\",\"123\":\"- code cache 校验成功\",\"124\":\"- 内存中存在编译缓存，code cache 没有被校验\",\"125\":\"\",\"126\":\"对于第一种情况，这个参数会被置为 true，而后两种情况都是 false，因此需要注意即使 reject 为 false，也不能说明 code cache 被接收了。\"}",
      "修改建议": "混用了“置为”和“设置为”",
      "更改后示例": "对于第一种情况，这个参数会被设置为 true，而后两种情况都是 false，因此需要注意即使 reject 为 false，也不能说明 code cache 被接收了",
      "触发条件": "同一文档中混用多个同义动词（如\"置为/设置为/设为\"）描述同一操作，且在相邻/相似上下文中出现术语不一致。  \n\n识别模式：  \n1. 动词冲突检测：在相同段落/逻辑链中，检测到描述参数赋值时存在\"置为\"与\"设置为\"等近义动词交替使用  \n2. 语境相似性：动词出现在相同技术场景（如参数设置）、相同句式结构（\"会被__ true\"）中，但未保持统一表达。"
    },
    {
      "defect_id": 520401,
      "sentence": "小程序使用 JSVM 执行 JS 代码的过程大概可以分为 native，JSVM-API，JSVM 三层：",
      "reference_sentence": "无",
      "line_num": 5,
      "context": "{\"1\":\"# JSVM 通用调优实践\",\"2\":\"\",\"3\":\"## JSVM 调用结构\",\"4\":\"\",\"5\":\"小程序使用 JSVM 执行 JS 代码的过程大概可以分为 native，JSVM-API，JSVM 三层：\",\"6\":\"\",\"7\":\"- native：小程序运行 JS 的逻辑层，使用 JSVM 提供的接口完成 JS 代码编译，运行，code cache 生成等操作的逻辑排布和组合\",\"8\":\"- JSVM-API：连接 native 和 v8 的接口兼容层，保持对不同版本 JS 引擎的兼容，提供 JS 引擎标准化的使用实践\",\"9\":\"- JSVM：JS 引擎层，负责 JS 代码实际的编译运行\",\"10\":\"\"}",
      "修改建议": "术语不一致，'native'应与后文的'本地层'一致",
      "更改后示例": "小程序使用 JSVM 执行 JS 代码的过程大概可以分为 本地层，JSVM-API，JSVM 三层：",
      "触发条件": "同一文档中同一术语存在多种表达形式（如中英文混用），且相邻上下文已明确使用某一标准译法或定义。识别需检查术语在全文及相邻段落中的一致性，尤其当后续内容出现标准术语时，前文首次提及需主动匹配。"
    },
    {
      "defect_id": 520273,
      "sentence": "3. 在坚盾守护模式开启期间，操作系统将在全局范围内禁用JIT（即时编译）功能，此限制适用于所有应用程序，包括已获得ACL权限的特权应用，具体技术实现细节请参阅[JSVM 坚盾守护模式](jsvm-secure-shield-mode.md)。",
      "reference_sentence": "JIT(Just In Time) 即时编译功能会引入任意代码注入的安全风险，为保护应用安全、维护鸿蒙纯净生态，系统默认关闭JSVM的JIT功能，若开发者期望使用该功能， 需要向应用市场（AppGallery Connect，简称为AGC）提交ohos.permission.kernel.ALLOW_EXECUTABLE_FORT_MEMORY受限ACL权限的申请， 并在附带材料中说明使用JSVM引擎JIT功能的具体场景。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"\",\"6\":\"## 适配注意事项\",\"7\":\"1. 如果应用未申请相应的权限证书，却试图在配置文件中声明此权限，将会导致应用安装失败。\",\"8\":\"2. 若在编译时报以下错误日志`The ohos.permission.kernel.ALLOW_EXECUTABLE_FORT_MEMORY permission under requestPermissions must be a value that is predefined within the SDK or a custom one that you have included under definePermissions.`， 请将OpenHarmony SDK更新到最新版本(>=5.0.2.125版本)。\",\"9\":\"3. 在坚盾守护模式开启期间，操作系统将在全局范围内禁用JIT（即时编译）功能，此限制适用于所有应用程序，包括已获得ACL权限的特权应用，具体技术实现细节请参阅[JSVM 坚盾守护模式](jsvm-secure-shield-mode.md)。\"}",
      "修改建议": "混用了‘即时编译’和‘即时编译’的英文缩写‘JIT’，建议全文统一使用‘JIT’。",
      "更改后示例": "3. 在坚盾守护模式开启期间，操作系统将在全局范围内禁用JIT功能，此限制适用于所有应用程序，包括已获得ACL权限的特权应用，具体技术实现细节请参阅[JSVM 坚盾守护模式](jsvm-secure-shield-mode.md)。",
      "触发条件": "同一术语在相邻上下文中同时出现全称（含括号内英文缩写）和单独英文缩写形式，且未保持统一表达方式时触发。\n\n识别模式：\n1. 检测括号内存在\"英文缩写（全称）\"或\"全称（英文缩写）\"结构\n2. 检查同一段落/相邻条目中是否存在单独使用该术语的英文缩写或全称\n3. 验证术语首次出现时是否已建立定义关系（如参考句中的\"JIT(Just In Time)\"定义）\n4. 确认后续出现时是否违反首次定义的表达惯例（首次定义后应统一使用缩写形式）"
    },
    {
      "defect_id": 520365,
      "sentence": "使用releaseJsCore方法来释放CoreID对应的运行环境。",
      "reference_sentence": "开发者通过createJsCore方法来创建一个新的JS运行时环境，并通过该方法获得一个CoreID。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口创建多个引擎执行JS代码并销毁\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"开发者通过createJsCore方法来创建一个新的JS运行时环境，并通过该方法获得一个CoreID。然后，通过evaluateJS方法使用CoreID对应的运行环境来运行JS代码，在JS代码中创建promise并异步执行函数。最后，使用releaseJsCore方法来释放CoreID对应的运行环境。\",\"6\":\"\",\"7\":\"## 使用示例\",\"8\":\"\",\"9\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"10\":\"\"}",
      "修改建议": "用词不一致，'释放'与'创建'对应，但用词不一致",
      "更改后示例": "使用releaseJsCore方法来销毁CoreID对应的运行环境。",
      "触发条件": "当文档中存在成对操作动词(如创建/销毁)但用词不匹配时触发，或同一上下文关键术语(如CoreID环境操作)出现动词表达不一致时触发。\n\n具体识别模式：\n1. 动词反义匹配检测：识别存在逻辑对应关系的操作动词对(如create/destroy、allocate/free)，当后项动词未使用前项动词的标准反义词时触发\n2. 上下文术语绑定检测：在特定对象(如CoreID环境)的完整生命周期描述中，针对同一操作对象的不同阶段动作动词需保持词根/语义一致性，如\"创建环境\"必须对应\"销毁环境\"而非\"释放环境\""
    },
    {
      "defect_id": 520383,
      "sentence": "使用 OH_JSVM_CreateCodeCache 接口，传入编译完成后生成的 JSVM_Script",
      "reference_sentence": "使用 OH_JSVM_CreateCodeCache 接口，传入编译完成后生成的 JSVM_Script",
      "line_num": 8,
      "context": "{\"3\":\"## code cache 简介\",\"4\":\"\",\"5\":\"JSVM 提供了生成并使用 code cache 加速编译过程的方法，其获取和使用分为下面几个部分：\",\"6\":\"\",\"7\":\"- 首先使用 compile 系列接口编译得到 JSVM_Script\",\"8\":\"- 使用 OH_JSVM_CreateCodeCache 接口，传入编译完成后生成的 JSVM_Script\",\"9\":\"- 将 OH_JSVM_CreateCodeCache 生成的 code cache 保存，等待下一次编译时，作为参数传递给 compile 系列接口\",\"10\":\"\",\"11\":\"通过上述流程，将会在使用 code cache 的那次编译中，极大减少编译时间，其原理为将编译完成的 script 序列化，然后使用 code cache 编译时就不再需要重新解析/编译已经被序列化的函数，只需要进行一次反序列化即可，这样编译就简化为了一次数据读取。\",\"12\":\"\",\"13\":\"## code cache 校验规格说明\"}",
      "修改建议": "混用了“传入”和“传递”",
      "更改后示例": "使用 OH_JSVM_CreateCodeCache 接口，传递编译完成后生成的 JSVM_Script",
      "触发条件": "同一文档中相邻段落或流程步骤中，对参数传递动作使用不同动词（如\"传入\"与\"传递给\"）形成术语冲突，且上下文存在相同功能接口调用场景时。\n\n识别模式：\n1. 检测相邻段落/步骤中相同接口操作描述\n2. 比对动词使用一致性（如参数传递类动词：传入/传递/传给）\n3. 验证是否存在相同接口调用场景下的动词混用\n4. 检查是否违反前后文已建立的术语惯例（如第9步已使用\"传递给\"）"
    },
    {
      "defect_id": 520289,
      "sentence": "通过给定的构造函数，构建一个实例。",
      "reference_sentence": "通过给定的构造函数，构建一个实例。",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"## 接口说明\",\"15\":\"\",\"16\":\"| 接口                | 功能说明                           |\",\"17\":\"| ------------------- | ---------------------------------- |\",\"18\":\"| OH_JSVM_NewInstance   | 通过给定的构造函数，构建一个实例。|\",\"19\":\"| OH_JSVM_GetNewTarget  | 获取函数的元属性new.target。|\",\"20\":\"| OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，支持C和JavaScript之间的数据交互。|\",\"21\":\"| OH_JSVM_Wrap           | 在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例。|\",\"22\":\"| OH_JSVM_Unwrap         | 解包先前封装在JavaScript对象中的原生实例。|\",\"23\":\"| OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例，并释放封装。|\"}",
      "修改建议": "用词不一致，'构建'与'创建'混用",
      "更改后示例": "通过给定的构造函数，创建一个实例。",
      "触发条件": "同一文档上下文中存在对同一操作使用不同动词描述的情况，且相邻接口说明或相关段落出现相同概念的标准化术语。  \n\n识别模式：  \n1. 动词不一致检测：在相邻接口/功能描述中，识别对相同动作（如实例生成）使用不同动词（构建/创建）  \n2.上下文术语对齐：当当前句子动词与同一章节其他接口说明中的标准化术语（如OH_JSVM_DefineClass使用\"创建\"）形成冲突时触发"
    },
    {
      "defect_id": 520364,
      "sentence": "新建多个JS运行时环境并运行JS代码",
      "reference_sentence": "开发者通过createJsCore方法来创建一个新的JS运行时环境，并通过该方法获得一个CoreID。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 使用示例\",\"8\":\"\",\"9\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"10\":\"\",\"11\":\"新建多个JS运行时环境并运行JS代码\",\"12\":\"\",\"13\":\"  ```cpp\",\"14\":\"#include <map>\",\"15\":\"#include <mutex>\",\"16\":\"#include <deque>\"}",
      "修改建议": "用词不一致，'新建'与'创建'混用",
      "更改后示例": "创建多个JS运行时环境并运行JS代码",
      "触发条件": "同一文档中针对同一操作或概念出现\"新建\"与\"创建\"等近义词混用，或与API方法命名动词(如create)不一致时。  \n\n识别模式：  \n1. 检测同一上下文范围内描述相同操作时是否交替使用近义动词  \n2. 核对技术术语是否与API方法命名(如createJsCore)中的核心动词保持词根一致  \n3. 验证动词与参考案例(如\"创建新的JS运行时环境\")用词规范是否统一"
    },
    {
      "defect_id": 520387,
      "sentence": "这个接口的传入参数中包含 cacheRejected，用于接收实际编译过程中 code cache 是否被拒绝的状态",
      "reference_sentence": "这个接口的传入参数中包含 cacheRejected，用于接收实际编译过程中 code cache 是否被拒绝的状态",
      "line_num": 120,
      "context": "{\"115\":\"```\",\"116\":\"\",\"117\":\"## 注意事项\",\"118\":\"\",\"119\":\"上述代码中使用了 code cache 进行编译: `OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);`\",\"120\":\"这个接口的传入参数中包含 cacheRejected，用于接收实际编译过程中 code cache 是否被拒绝的状态，具体包括多种情况：\",\"121\":\"\",\"122\":\"- code cache 校验失败\",\"123\":\"- code cache 校验成功\",\"124\":\"- 内存中存在编译缓存，code cache 没有被校验\",\"125\":\"\"}",
      "修改建议": "混用了“传入”和“传递”",
      "更改后示例": "这个接口的传递参数中包含 cacheRejected，用于接收实际编译过程中 code cache 是否被拒绝的状态",
      "触发条件": "同一文档或上下文中存在同一术语的两种不同表达形式（如\"传入参数\"和\"传递参数\"），且其中一个表达已在当前上下文被确立为规范用法时。\n\n识别模式：通过对比相邻段落/句子的术语使用（如问题上下文第119行使用\"传入参数\"），检测同一语义概念是否出现非标准表达变体，且存在已建立的上下文术语基准。需结合术语重复出现频率及首次定义位置判断规范形式。"
    },
    {
      "defect_id": 520429,
      "sentence": "过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：",
      "reference_sentence": "过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：",
      "line_num": 117,
      "context": "{\"112\":\"\",\"113\":\"在能达到相同效果时，使用更高效的 JSVM-API 是简单有效的性能优化方法，以下实践是在优化实践过程中发现的一些例子\",\"114\":\"\",\"115\":\"#### 使用 IsXXX 代替 TypeOf\",\"116\":\"\",\"117\":\"过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：\",\"118\":\"\",\"119\":\"从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。\",\"120\":\"\",\"121\":\"这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"122\":\"\"}",
      "修改建议": "用词不一致，建议将“对象原生类型”统一为“对象类型”",
      "更改后示例": "过去发现，针对仅需要判断对象类型的场景，存在一种相对低效的使用方法：",
      "触发条件": "同一技术概念在文档中使用了与上下文或项目规范不一致的冗余/变体术语（如\"原生类型\"与\"类型\"混用），且存在已明确定义的统一表达（如参考材料/上下文已使用\"对象类型\"）时触发。"
    },
    {
      "defect_id": 520402,
      "sentence": "native：小程序运行 JS 的逻辑层，使用 JSVM 提供的接口完成 JS 代码编译，运行，code cache 生成等操作的逻辑排布和组合",
      "reference_sentence": "无",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## JSVM 调用结构\",\"4\":\"\",\"5\":\"小程序使用 JSVM 执行 JS 代码的过程大概可以分为 native，JSVM-API，JSVM 三层：\",\"6\":\"\",\"7\":\"- native：小程序运行 JS 的逻辑层，使用 JSVM 提供的接口完成 JS 代码编译，运行，code cache 生成等操作的逻辑排布和组合\",\"8\":\"- JSVM-API：连接 native 和 v8 的接口兼容层，保持对不同版本 JS 引擎的兼容，提供 JS 引擎标准化的使用实践\",\"9\":\"- JSVM：JS 引擎层，负责 JS 代码实际的编译运行\",\"10\":\"\",\"11\":\"使用 JSVM 的过程中，可能由于各种原因产生一些不必要的开销导致启动变慢，其中的原因可以从以上三层的角度进行拆分。\",\"12\":\"\"}",
      "修改建议": "术语不一致，'native'应与前文的'本地层'一致",
      "更改后示例": "本地层：小程序运行 JS 的逻辑层，使用 JSVM 提供的接口完成 JS 代码编译，运行，code cache 生成等操作的逻辑排布和组合",
      "触发条件": "当同一技术术语在文档中出现中英文混用或翻译不一致，且前文已确立标准中文译名时触发；当列表项术语与上下文层级命名体系存在表述差异时触发。\n\n识别模式：通过比对相邻段落/列表中的术语表述，检测是否存在相同概念使用不同语言版本（如\"native\"与\"本地层\"）的情况；检查层级结构描述是否保持统一的命名范式（如三层架构应统一使用中文或英文命名）。"
    },
    {
      "defect_id": 520427,
      "sentence": "这种在已经有值的情况下创建一个新的 object 的操作是冗余的，直接创建对值的引用即可。",
      "reference_sentence": "这种在已经有值的情况下创建一个新的 object 的操作是冗余的，直接创建对值的引用即可。",
      "line_num": 155,
      "context": "{\"150\":\"\",\"151\":\"过去存在这样一种创建 reference 的路径：\",\"152\":\"\",\"153\":\"创建一个新的 object -> 设置 object 的值 -> 创建 object 的 reference。\",\"154\":\"\",\"155\":\"这种在已经有值的情况下创建一个新的 object 的操作是冗余的，直接创建对值的引用即可。\",\"156\":\"\",\"157\":\"下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"158\":\"\",\"159\":\"\",\"160\":\"- 低效用例\"}",
      "修改建议": "用词不一致，建议将“object”统一为“对象”",
      "更改后示例": "这种在已经有值的情况下创建一个新的对象的操作是冗余的，直接创建对值的引用即可。",
      "触发条件": "同一术语在相邻上下文或同一文档中存在中英文混用的情况（如\"object\"与\"对象\"交替出现），且未遵循该术语在文档中的首次出现形式或行业通用翻译标准时触发。"
    },
    {
      "defect_id": 520430,
      "sentence": "这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。",
      "reference_sentence": "这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。",
      "line_num": 121,
      "context": "{\"116\":\"\",\"117\":\"过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：\",\"118\":\"\",\"119\":\"从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。\",\"120\":\"\",\"121\":\"这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"122\":\"\",\"123\":\"- 低效用例\",\"124\":\"\",\"125\":\"\",\"126\":\"```cpp\"}",
      "修改建议": "用词不一致，建议将“object 的类型”统一为“类型”",
      "更改后示例": "这种方法需要先查询类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。",
      "触发条件": "当同一术语在相邻上下文出现不一致表述（如\"object 的类型\"与上文单独使用的\"类型\"），或存在冗余限定词破坏术语统一性时触发。\n\n识别模式：\n1. 对比当前术语与前文已建立的术语表述（如第119行已单独使用\"类型\"）\n2. 检测名词短语中是否存在可省略的冗余限定词（如\"object\"在上下文已明确时）\n3. 验证术语是否与参考文档标题表述一致（如\"[JSVM 数据类型]\"对应\"类型\"而非\"object 类型\"）"
    },
    {
      "defect_id": 518973,
      "sentence": "发送Runtime.runIfWaitingForDebugger命令。",
      "reference_sentence": "等待主机与inspector建立socket连接，连接建立后程序将继续运行。",
      "line_num": 15,
      "context": "{\"10\":\"| OH_JSVM_StopCpuProfiler  |  停止CPU profiler并将结果输出到流。 |\",\"11\":\"| OH_JSVM_TakeHeapSnapshot  |  获取当前堆快照并将其输出到流。 |\",\"12\":\"| OH_JSVM_OpenInspector  |  在指定的主机和端口上激活inspector，将用来调试JS代码。 |\",\"13\":\"| OH_JSVM_OpenInspectorWithName | 基于传入的 pid 和 name 激活 inspector。 |\",\"14\":\"| OH_JSVM_CloseInspector  |  尝试关闭剩余的所有inspector连接。 |\",\"15\":\"| OH_JSVM_WaitForDebugger  |  等待主机与inspector建立socket连接，连接建立后程序将继续运行。发送Runtime.runIfWaitingForDebugger命令。 |\",\"16\":\"\",\"17\":\"\",\"18\":\"本文将介绍调试、CPU Profiler、Heap Snapshot的使用方法。\",\"19\":\"\",\"20\":\"## 调试能力使用方法\"}",
      "修改建议": "用词不一致，'发送'应改为'执行'，与上文保持一致。",
      "更改后示例": "执行Runtime.runIfWaitingForDebugger命令。",
      "触发条件": "当动词使用与相邻条目或参考句子的技术动作描述不一致（如\"发送\"与\"执行\"），且存在明确上下文动词惯例（如其他API均用\"执行\"描述命令操作）时触发。\n\n识别模式：\n1. 动词冲突检测：识别技术动作动词（发送/执行/运行等）与上下文同类操作动词的差异\n2. 跨条目模式匹配：通过对比相邻API条目（如OH_JSVM_WaitForDebugger前后条目）的固定句式结构，发现非常用动词的使用\n3. 参考句锚定：当存在明确的技术流程描述（如\"程序将继续运行\"），后续关联操作需保持动作连贯性"
    },
    {
      "defect_id": 520426,
      "sentence": "从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。",
      "reference_sentence": "从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。",
      "line_num": 119,
      "context": "{\"114\":\"\",\"115\":\"#### 使用 IsXXX 代替 TypeOf\",\"116\":\"\",\"117\":\"过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：\",\"118\":\"\",\"119\":\"从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。\",\"120\":\"\",\"121\":\"这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"122\":\"\",\"123\":\"- 低效用例\",\"124\":\"\"}",
      "修改建议": "用词不一致，建议将“对象类型”统一为“类型”",
      "更改后示例": "从 OH_JSVM_TypeOf 接口获取类型后，再判断是否与某个类型相同。",
      "触发条件": "同一段落或相邻上下文中出现同一概念的不同术语表述（如\"对象类型\"和\"类型\"），且存在已定义的参考术语（如接口名称中的\"TypeOf\"或后文统一使用的\"类型\"）时触发。\n\n识别模式：\n1. 核心概念重复出现时存在术语变异（如\"对象类型\"→\"类型\"）\n2. 接口名称中的关键术语（如TypeOf）与描述参数不一致（如\"对象类型\"未保持\"类型\"的简称）\n3. 相邻语句存在术语统一示范（如后文统一使用\"类型\"时前文出现长版本表述）"
    },
    {
      "defect_id": 520315,
      "sentence": "解包先前封装在JavaScript对象中的原生实例",
      "reference_sentence": "在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例",
      "line_num": 212,
      "context": "{\"207\":\"\",\"208\":\"在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例\",\"209\":\"\",\"210\":\"### OH_JSVM_Unwrap\",\"211\":\"\",\"212\":\"解包先前封装在JavaScript对象中的原生实例\",\"213\":\"\",\"214\":\"### OH_JSVM_RemoveWrap\",\"215\":\"\",\"216\":\"解包先前封装在JavaScript对象中的原生实例并释放封装\",\"217\":\"\"}",
      "修改建议": "前后句子用词不一致，应保持一致。",
      "更改后示例": "解包先前封装在JavaScript对象中的原生实例。",
      "触发条件": "当相邻或上下文关联的句子描述同一操作流程时，若出现标点符号（如句号缺失）或语法结构（如动宾短语完整性）不一致，且存在明确的参考模板句式时触发。\n\n识别模式：通过对比问题句与上下文同类操作描述（如\"封装\"与\"解包\"配对动作），检测标点完整性、句式对称性（如是否均采用完整陈述句+句号结构），并匹配参考句的语法规范。"
    },
    {
      "defect_id": 520386,
      "sentence": "如果 cacheRejected 为 true，那么说明 code cache 被拒绝无法生效，运行时间会与无 code cache 时间一致",
      "reference_sentence": "如果 cacheRejected 为 true，那么说明 code cache 被拒绝无法生效，运行时间会与无 code cache 时间一致",
      "line_num": 22,
      "context": "{\"17\":\"| 兼容性校验  | 校验生成 cache 的 JSVM 版本与编译选项是否与当前一致    |\",\"18\":\"| 一致性校验  | 校验生成 cache 的 js 源码，是否与当前输入源码长度一致  |\",\"19\":\"\",\"20\":\"## 场景示例\",\"21\":\"\",\"22\":\"下面的伪代码是一个典型的使用方法，其中第二次编译，如果 cacheRejected 为 true，那么说明 code cache 被拒绝无法生效，运行时间会与无 code cache 时间一致；为 false 则这次运行将会极大加快。\",\"23\":\"\",\"24\":\"其中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"25\":\"外层跨语言交互的部分可以参考 [使用 JSVM-API 实现 JS 与 C/C++ 语言交互开发流程](./use-jsvm-process.md)。\",\"26\":\"\",\"27\":\"```c++\"}",
      "修改建议": "混用了“一致”和“相同”",
      "更改后示例": "如果 cacheRejected 为 true，那么说明 code cache 被拒绝无法生效，运行时间会与无 code cache 时间相同",
      "触发条件": "当同一文档或相邻上下文中存在同义/近义词汇混用（如\"一致\"与\"相同\"），且已有其他语句确立标准用词时触发。识别模式为：检测到同语义表达词汇与上下文既定用词（如参考句中的\"一致\"）不一致，且处于相同技术描述场景时。"
    },
    {
      "defect_id": 521656,
      "sentence": "例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。",
      "reference_sentence": "例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作的功能，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。这些操作是在处理JavaScript对象时非常常见的，提供了一种与JavaScript对象交互的方式。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM接口开发中，经常需要定义和操作对象。例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。\",\"10\":\"\",\"11\":\"- **接口（API）**：接口定义了组件之间的交互协议，包括输入参数、输出结果以及可能的错误处理。通过接口，组件可以相互调用和交换数据，而无需了解对方的内部实现细节。\",\"12\":\"- **对象（Object）**：在JavaScript，对象是一种复合数据类型，允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。\",\"13\":\"\",\"14\":\"## 接口说明\"}",
      "修改建议": "混用了'接口'与'API接口'，建议统一使用'接口'",
      "更改后示例": "例如，创建一个接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。",
      "触发条件": "当同一术语在文档中存在多个表述变体(如\"接口\"与\"API接口\")，且上下文已明确定义标准术语时，或相邻段落出现重复术语但表述不一致时。\n\n识别模式：\n1. 术语重复出现场景下检测表述差异（如\"接口\"在相邻段落中分别出现\"API接口\"和\"接口\"）\n2. 匹配文档内已定义的术语标准（如术语表或括号补充说明\"接口（API）\"）\n3. 检查核心技术名词在单一句子/段落中的表述一致性（如\"接口\"作为主语的重复出现场景）"
    },
    {
      "defect_id": 521655,
      "sentence": "使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作的功能，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。",
      "reference_sentence": "使用JSVM-API接口进行object相关开发",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行object相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作的功能，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。这些操作是在处理JavaScript对象时非常常见的，提供了一种与JavaScript对象交互的方式。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM接口开发中，经常需要定义和操作对象。例如，创建一个API接口，该接口接受一个对象作为输入参数，对该对象执行某些操作，并返回一个结果对象。在这个过程中，需要确保接口的定义清晰、规范，并且与对象的属性和方法相兼容。\",\"10\":\"\"}",
      "修改建议": "混用了'功能'与'操作'，建议统一使用'操作'",
      "更改后示例": "使用JSVM-API接口进行object相关开发，处理JavaScript对象的基本操作，例如创建对象、获取原型、冻结和密封对象，检查对象的类型等。",
      "触发条件": "同一句子或相邻上下文中出现多个同义/近义术语（如\"功能\"与\"操作\"）描述同一概念，且存在术语混用不一致现象。具体表现为：名词性成分重复（如\"操作的功能\"）或相邻语句对同一行为使用不同抽象层级的表述。"
    },
    {
      "defect_id": 521668,
      "sentence": "删除现有属性",
      "reference_sentence": "移除现有属性",
      "line_num": 139,
      "context": "{\"134\":\"JSVM CreateObject success\",\"135\":\"```\",\"136\":\"\",\"137\":\"### OH_JSVM_ObjectFreeze\",\"138\":\"\",\"139\":\"冻结给定的对象，防止向其添加新属性，删除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。\",\"140\":\"\",\"141\":\"cpp部分代码：\",\"142\":\"\",\"143\":\"```cpp\",\"144\":\"// hello.cpp\"}",
      "修改建议": "混用了'删除'与'移除'，这两个词是近义词，可能会导致表意模糊",
      "更改后示例": "移除现有属性",
      "触发条件": "同一文档或上下文中存在多个近义词描述同一操作/对象，且该文档已存在明确的统一术语（如参考句中的\"移除\"）。\n\n识别模式：当检测到当前用词（如\"删除\"）与上下文既定术语（如\"移除\"）形成近义词冲突，且两者指向同一技术动作时触发规则。需结合术语库或上下文高频词进行语义对比验证。"
    },
    {
      "defect_id": 521683,
      "sentence": "OH_JSVM_CreateExternal可以创建包装自定义的C/C++对象并将其公开给JavaScript代码，而OH_JSVM_GetValueExternal就是用来获得OH_JSVM_CreateExternal所包装的外部对象的指针。",
      "reference_sentence": "OH_JSVM_CreateExternal创建一个包装了外部指针的JavaScript对象。",
      "line_num": 550,
      "context": "{\"545\":\"JSVM CreateExternal success\",\"546\":\"```\",\"547\":\"\",\"548\":\"### OH_JSVM_GetValueExternal\",\"549\":\"\",\"550\":\"OH_JSVM_CreateExternal可以创建包装自定义的C/C++对象并将其公开给JavaScript代码，而OH_JSVM_GetValueExternal就是用来获得OH_JSVM_CreateExternal所包装的外部对象的指针。\",\"551\":\"\",\"552\":\"cpp部分代码：\",\"553\":\"\",\"554\":\"```cpp\",\"555\":\"// hello.cpp\"}",
      "修改建议": "混用了“创建”和“可以创建”以及“指针”和“外部对象的指针”",
      "更改后示例": "OH_JSVM_CreateExternal可以创建并包装自定义的C/C++对象，并将其公开给JavaScript代码，而OH_JSVM_GetValueExternal则用于获取OH_JSVM_CreateExternal所包装的外部对象的指针。",
      "触发条件": "同一功能描述中混用不同动词结构(如\"可以创建\"与\"创建\")或关键术语不完整(如\"指针\"未保持\"外部对象的指针\"完整表述)，且存在同功能参考句式时触发。\n\n识别模式：\n1. 动词一致性检测：识别同一功能链(如CreateExternal与GetValueExternal)中是否交替使用不同动词结构(如\"可以创建\"与\"创建\"、\"用来获得\"与\"用于获取\")\n2. 术语完整性验证：检查核心技术术语(如\"指针\")是否在重复出现时保持完整修饰关系(\"外部对象的指针\")，避免省略关键限定词\n3. 跨句对照分析：当存在参考句式(如\"创建...对象\")时，检测相邻功能描述是否采用相同语法结构(主动语态+无冗余助动词)"
    },
    {
      "defect_id": 522139,
      "sentence": "用于获取JavaScript undefined",
      "reference_sentence": "用于获取JavaScript undefined。",
      "line_num": 420,
      "context": "{\"415\":\"JSVM OH_JSVM_GetNull success\",\"416\":\"```\",\"417\":\"\",\"418\":\"### OH_JSVM_GetUndefined\",\"419\":\"\",\"420\":\"用于获取JavaScript undefined\",\"421\":\"\",\"422\":\"cpp部分代码：\",\"423\":\"\",\"424\":\"```cpp\",\"425\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少句号",
      "更改后示例": "用于获取JavaScript undefined。",
      "触发条件": "当句子结尾缺少与上下文或文档规范一致的标点符号（如句号），且相邻条目或同类描述中存在统一结尾格式时触发。\n\n识别模式：  \n1. **标点一致性检测**：检查当前句子结尾是否缺失句号，而上下文同类条目（如函数描述）普遍以句号结尾。  \n2. **结构对比**：通过对比相邻条目（如415行无句号，但参考句子或规范要求有句号），识别句式或标点使用差异。"
    },
    {
      "defect_id": 522138,
      "sentence": "用于获取JavaScript null",
      "reference_sentence": "用于获取JavaScript null。",
      "line_num": 379,
      "context": "{\"374\":\"JSVM OH_JSVM_GetGlobal success\",\"375\":\"```\",\"376\":\"\",\"377\":\"### OH_JSVM_GetNull\",\"378\":\"\",\"379\":\"用于获取JavaScript null\",\"380\":\"\",\"381\":\"cpp部分代码：\",\"382\":\"\",\"383\":\"```cpp\",\"384\":\"// hello.cpp\"}",
      "修改建议": "句式不一致，缺少句号",
      "更改后示例": "用于获取JavaScript null。",
      "触发条件": "当同一结构或列表中的相邻条目使用句号结尾，而当前条目为功能说明性陈述句但缺少句号时触发。  \n识别模式：检查上下文相邻条目是否以句号结尾，且当前句子为无标点结尾的陈述句（如“用于...”句式），同时与参考句式结构一致但标点不匹配。"
    },
    {
      "defect_id": 522903,
      "sentence": "如果源码中相同作用域下出现了同名的实体，同名的名称后会加上重名序号",
      "reference_sentence": "如果源码中相同作用域下出现了同名的函数，重名的名称后面会加上重名序号",
      "line_num": 45,
      "context": "{\"40\":\"    function A() { }                       // A的函数名\\\"#*@0*#A\\\"，其中\\\"@0\\\"表示在其对应LiteralArray中，索引为0的字符串，此时这个字符串是\\\"longFuncName\\\"。即这个函数原本的名称为\\\"#*longFuncName*#A\\\"\",\"41\":\"    function B() { }                       // B的函数名\\\"#*@0*#B\\\"\",\"42\":\"}  \",\"43\":\"```\",\"44\":\"#### 重名序号\",\"45\":\"如果源码中相同作用域下出现了同名的实体，同名的名称后会加上重名序号，重名序号以`^十六进制数字`的形式表示。出现重名时，第一个不编号（即重名序号为空），从第二个开始编号，编号从`1`开始。\",\"46\":\"\",\"47\":\"例子：\",\"48\":\"```ts\",\"49\":\"namespace A {\",\"50\":\"    function bar() { }                      // bar的函数名为\\\"#&A*#bar\\\"\"}",
      "修改建议": "同名实体/函数的表述使用了不同的词汇",
      "更改后示例": "如果源码中相同作用域下出现了同名的实体或函数，同名的名称后会加上重名序号",
      "触发条件": "当文档中相邻或同一主题的句子对同一概念（如同名冲突对象）使用不一致的术语表述（如\"实体\"/\"函数\"混用）时触发。\n\n识别模式：\n1. 上下文存在语义关联的相邻句子（如问题句与参考句）\n2. 核心概念出现术语变异（如\"实体\"与\"函数\"交替使用）\n3. 句法结构高度相似但关键术语不统一（如\"同名实体\" vs \"同名函数\"）\n4. 存在明确的参考基准句（如示例中的参考句明确使用\"函数\"表述）"
    },
    {
      "defect_id": 522594,
      "sentence": "request部件主要给应用提供上传下载文件、后台传输代理的基础能力。",
      "reference_sentence": "request的cacheDownload子组件主要给应用提供应用资源提前缓存的基础能力。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.request.cacheDownload (缓存下载)\",\"2\":\"\",\"3\":\"request部件主要给应用提供上传下载文件、后台传输代理的基础能力。\",\"4\":\"\",\"5\":\"- request的cacheDownload子组件主要给应用提供应用资源提前缓存的基础能力。\",\"6\":\"\",\"7\":\"- cacheDownload组件使用HTTP协议进行数据下载，并将数据资源缓存至应用内存或应用沙箱目录的文件中。\",\"8\":\"\"}",
      "修改建议": "混用了“部件”和“子组件”描述同一对象",
      "更改后示例": "request子组件主要给应用提供上传下载文件、后台传输代理的基础能力。",
      "触发条件": "同一文档中对同一技术组件使用了多个不一致的术语（如“部件”和“子组件”），且存在上下文关联的参考句子明确使用标准术语（如“子组件”）时触发。"
    },
    {
      "defect_id": 522640,
      "sentence": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式清除多余的已缓存的文件缓存内容。",
      "reference_sentence": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式删除多余的已缓存的内存缓存内容。",
      "line_num": 177,
      "context": "{\"172\":\"\",\"173\":\"setFileCacheSize(bytes: number)\",\"174\":\"\",\"175\":\"设置缓存下载组件能够保存的文件缓存上限。\",\"176\":\"\",\"177\":\"- 使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式清除多余的已缓存的文件缓存内容。\",\"178\":\"\",\"179\":\"- 该方法为同步方法，不阻塞调用线程。\",\"180\":\"\",\"181\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"182\":\"\"}",
      "修改建议": "混用了'清除'与'删除'，应保持术语一致",
      "更改后示例": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式删除多余的已缓存的文件缓存内容。",
      "触发条件": "同一文档中对相同操作或概念使用多个不同术语（如\"清除\"与\"删除\"混用），且存在上下文关联的参考基准（如其他段落已使用\"删除\"描述同类操作）。识别模式需检测相邻段落/同类接口描述中针对相同语义动作的动词/名词是否保持统一。"
    },
    {
      "defect_id": 522595,
      "sentence": "这些缓存数据可以被部分ArkUI相关组件使用（例如：Image组件），从而提升资源加载效率。请查看ArkUI组件文档确定组件是否支持该功能。",
      "reference_sentence": "OpenHarmony上原生UI框架。是一套极简、高性能、跨设备应用设计研发的UI开发框架，支撑开发者高效地构建跨设备应用UI界面。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"- request的cacheDownload子组件主要给应用提供应用资源提前缓存的基础能力。\",\"6\":\"\",\"7\":\"- cacheDownload组件使用HTTP协议进行数据下载，并将数据资源缓存至应用内存或应用沙箱目录的文件中。\",\"8\":\"\",\"9\":\"- 这些缓存数据可以被部分ArkUI相关组件使用（例如：Image组件），从而提升资源加载效率。请查看ArkUI组件文档确定组件是否支持该功能。\",\"10\":\"\",\"11\":\"> **说明：**\",\"12\":\">\",\"13\":\"> 本模块首批接口从API version 18开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"14\":\"\"}",
      "修改建议": "混用了“ArkUI相关组件”和“ArkUI组件”描述同一对象",
      "更改后示例": "这些缓存数据可以被部分ArkUI组件使用（例如：Image组件），从而提升资源加载效率。请查看ArkUI组件文档确定组件是否支持该功能。",
      "触发条件": "当同一文档中针对同一技术组件出现\"修饰词+组件名称\"（如\"相关组件\"）与\"标准组件名称\"（如\"组件\"）两种不同表述形式时触发。\n\n识别模式：\n1. 检测相邻段落中是否存在对同一组件的不同命名结构（如\"ArkUI相关组件\" vs \"ArkUI组件\"）\n2. 验证修饰词是否造成冗余表达（如\"相关\"在上下文未提供额外有效信息）\n3. 对比文档其他章节的术语使用一致性（如参考句采用\"ArkUI组件\"标准表述）"
    },
    {
      "defect_id": 522639,
      "sentence": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式清除多余的已缓存的内存缓存内容。",
      "reference_sentence": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式清除多余的已缓存的文件缓存内容。",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"setMemoryCacheSize(bytes: number)\",\"135\":\"\",\"136\":\"设置缓存下载组件能够保存的内存缓存上限。\",\"137\":\"\",\"138\":\"- 使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式清除多余的已缓存的内存缓存内容。\",\"139\":\"\",\"140\":\"- 该方法为同步方法，不阻塞调用线程。\",\"141\":\"\",\"142\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"143\":\"\"}",
      "修改建议": "混用了'清除'与'删除'，应保持术语一致",
      "更改后示例": "使用该接口调整缓存大小时，默认使用“LRU”（最近最少使用）方式删除多余的已缓存的内存缓存内容。",
      "触发条件": "当同一操作在文档不同位置出现动词不一致（如\"清除\"与\"删除\"混用），且存在已定义的规范术语（如参考句中的\"清除\"）时触发；或同一功能模块中相同动作的术语使用出现矛盾时触发。\n\n识别模式：\n1. 动词冲突检测：在相同上下文（如内存缓存操作）中，比对描述同类动作的动词是否统一\n2. 跨模块一致性检查：当\"内存缓存\"与\"文件缓存\"等相似功能模块使用不同操作动词时（如内存用\"删除\"而文件用\"清除\"）\n3. 术语库匹配验证：通过预先定义的术语对照表（如\"清除→内存操作/删除→数据移除\"）识别异常用词"
    },
    {
      "defect_id": 523032,
      "sentence": "如果需要分析方舟字节码文件（\\*.abc）相关问题，开发者可以使用Disassembler将字节数据反编译为可读的汇编指令。",
      "reference_sentence": "如果需要分析方舟字节码文件（\\*.abc）相关问题，开发者可以使用Disassembler将方舟字节码文件反编译为可读的汇编指令。",
      "line_num": 5,
      "context": "{\"1\":\"# Disassembler反汇编工具\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"Disassembler是ArkTS反汇编工具。如果需要分析方舟字节码文件（\\\\*.abc）相关问题，开发者可以使用Disassembler将字节数据反编译为可读的汇编指令。\",\"6\":\"\",\"7\":\"工具随DevEco Studio SDK发布。以Windows平台为例，Disassembler工具位于DevEco Studio/sdk/default/openharmony/toolchains/ark_disasm.exe。\",\"8\":\"\",\"9\":\"## 命令行说明\",\"10\":\"\"}",
      "修改建议": "混用了'字节数据'和'方舟字节码文件'，应使用同一术语描述同一对象。",
      "更改后示例": "如果需要分析方舟字节码文件（*.abc）相关问题，开发者可以使用Disassembler将方舟字节码文件反编译为可读的汇编指令。",
      "触发条件": "同一文档中针对同一技术对象（如\"方舟字节码文件\"）出现两个及以上不同术语表述（如\"字节数据\"），且未保持术语统一时触发。\n\n识别模式：\n1. 通过上下文检测同一段落内是否存在多个指代同一实体的不同术语\n2. 对比核心技术名词（如带扩展名的文件类型*.abc）与其后续指代词是否保持完全一致\n3. 在技术文档中识别非标准化表述（如用\"字节数据\"替代已明确定义的\"方舟字节码文件\"）"
    },
    {
      "defect_id": 522286,
      "sentence": "对于值在`0x0c`和`0xff`（含）之间的特殊操作码，状态机按照以下步骤将`line`和`address`寄存器移动一小部分，然后生成一个新的位置条目（参见[DWARF调试信息格式第3版](https://dwarfstd.org/dwarf3std.html)第6.2.5.1项 Special Opcodes）：",
      "reference_sentence": "特殊操作码           | `0x0c..0xff`   |   |  |   | 使 `line` 和 `address` 寄存器指向下一个地址，并生成一个位置条目。详情参阅下文中的说明。",
      "line_num": 427,
      "context": "{\"422\":\"| `SET_SOURCE_CODE`      | `0x0a`  |    | `uleb128 source_idx` | `source_idx`：一个偏移量，指向[字符串](#字符串)，表示文件的源码。 | 设置`source_code`寄存器的值。`source_idx`的值可能是0，如果是0，则代表着对应的信息是不存在的。 |\",\"423\":\"| `SET_COLUMN`           | `0x0b` |    | `uleb128 column_num`   | `column_num`：待设置的列号。   | 设置`column`寄存器的值，并生成一个位置条目。  |\",\"424\":\"| 特殊操作码           | `0x0c..0xff`   |   |  |   | 使 `line` 和 `address` 寄存器指向下一个地址，并生成一个位置条目。详情参阅下文中的说明。 |\",\"425\":\"\",\"426\":\"\",\"427\":\"对于值在`0x0c`和`0xff`（含）之间的特殊操作码，状态机按照以下步骤将`line`和`address`寄存器移动一小部分，然后生成一个新的位置条目（参见[DWARF调试信息格式第3版](https://dwarfstd.org/dwarf3std.html)第6.2.5.1项 Special Opcodes）：\",\"428\":\"\",\"429\":\"| **步骤序号** | **操作**                                     | **说明**                                               |\",\"430\":\"| ----- | -------------------------------------------------- | ------------------------------------------------------------ |\",\"431\":\"| 1     | `adjusted_opcode = opcode - OPCODE_BASE`            | 计算调整后的操作码。`OPCODE_BASE`的值是`0x0c`，是第一个特殊操作码。 |\",\"432\":\"| 2     | `address += adjusted_opcode / LINE_RANGE`            | 增加`address`寄存器中的值。`LINE_RANGE`的值是15，用来计算行号信息的变化。 |\"}",
      "修改建议": "混用了'下一个地址'和'移动一小部分'",
      "更改后示例": "对于值在`0x0c`和`0xff`（含）之间的特殊操作码，状态机按照以下步骤将`line`和`address`寄存器移动到下一个地址，并生成一个新的位置条目（参见[DWARF调试信息格式第3版](https://dwarfstd.org/dwarf3std.html)第6.2.5.1项 Special Opcodes）：",
      "触发条件": "当同一技术概念在相邻段落或表格中存在两种及以上不同表述（如\"移动一小部分\"和\"下一个地址\"），且上下文存在明确的标准化表述（如表格中的\"指向下一个地址\"）时触发。\n\n识别模式：通过对比操作说明性语句与上下文表格/参考条目的标准术语表述，检测动词短语（移动/指向）和关键名词（地址/位置条目）是否保持严格一致，特别关注数值范围描述（0x0c..0xff）对应的操作流程表述差异。"
    },
    {
      "defect_id": 521991,
      "sentence": "- 编译期自定义修改方舟字节码：介绍如何修改字节码文件的内容。",
      "reference_sentence": "无",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\",\"9\":\"- 方舟字节码函数命名规则：介绍字节码文件中函数名字的字符串的命名规则。\",\"10\":\"\",\"11\":\"- 编译期自定义修改方舟字节码：介绍如何修改字节码文件的内容。\"}",
      "修改建议": "句式不一致，建议统一使用祈使句。",
      "更改后示例": "- 编译期自定义修改方舟字节码：了解如何修改字节码文件的内容。",
      "触发条件": "同一列表或结构中的条目描述部分使用不一致的动词或句式（如祈使句与非祈使句混用），且相邻条目存在统一表达模式时触发。"
    },
    {
      "defect_id": 522253,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。",
      "reference_sentence": "### DebugInfo",
      "line_num": 406,
      "context": "{\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\"}",
      "修改建议": "术语“寄存器”与“source_code”不一致，应该使用一致的术语。",
      "更改后示例": "一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么该值是0。",
      "触发条件": "当同一字段/概念的描述中混用不同术语（如\"寄存器\"和\"source_code\"），或术语与字段定义名称不一致时触发；当上下文存在明确字段定义（如`source_code`），但描述使用其他技术术语指代该字段时触发。\n\n识别模式：\n1. 匹配字段定义名称（如`source_code`）与描述性文本中的指代词（如\"寄存器\"）\n2. 检测同一概念在相邻段落/条目中出现不同术语表达（如405行用\"寄存器\"，406行用\"source_code\"）\n3. 识别技术性术语（如寄存器）是否与当前字段的技术属性存在语义冲突（寄存器属于硬件概念，而source_code属于软件数据结构）"
    },
    {
      "defect_id": 523987,
      "sentence": "根据URL移除缓存下载任务，已保存的内存缓存和文件缓存保持不变。",
      "reference_sentence": "删除和查找元素。",
      "line_num": 85,
      "context": "{\"80\":\"\",\"81\":\"## cacheDownload.cancel\",\"82\":\"\",\"83\":\"cancel(url: string)\",\"84\":\"\",\"85\":\"根据URL移除缓存下载任务，已保存的内存缓存和文件缓存保持不变。\",\"86\":\"\",\"87\":\"- 如果不存在对应任务，无其他效果。\",\"88\":\"\",\"89\":\"- 该方法是同步方法，不会阻塞调用线程。\",\"90\":\"\"}",
      "修改建议": "使用了'移除'，与文中其他地方的'删除'不一致。",
      "更改后示例": "根据URL删除缓存下载任务，已保存的内存缓存和文件缓存保持不变。",
      "触发条件": "同一功能描述中存在多个同义动词（如\"移除/删除\"），且文档其他位置已确立标准用词（如\"删除\"被重复使用）时触发。识别模式需检测技术动词在上下文中的一致性，当同功能动词与既定术语库（如参考句中的\"删除\"）冲突时判定为不一致。"
    },
    {
      "defect_id": 522248,
      "sentence": "基于状态机（State machine）的执行模型对行号程序（Line number program)进行解释，可得到映射和局部变量信息编码。",
      "reference_sentence": "基于状态机（State machine）的执行模型对行号程序（Line number program)进行解释，可得到映射和局部变量信息编码。",
      "line_num": 378,
      "context": "{\"373\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"374\":\"| `offsets`        | `uint32_t[]`     | 一个数组，数组中每个元素的值是一个偏移量，指向一个行号程序。数组长度由[Header](#header)中的`num_lnps`指定。 |\",\"375\":\"\",\"376\":\"\",\"377\":\"### DebugInfo\",\"378\":\"调试信息（DebugInfo）包含方法的程序计数器与源代码中的行列号之间的映射以及有关局部变量的信息。调试信息的格式由[DWARF调试信息格式第3版](https://dwarfstd.org/dwarf3std.html)（见第6.2项）的内容演变形成。基于状态机（State machine）的执行模型对行号程序（Line number program)进行解释，可得到映射和局部变量信息编码。为对不同方法的相同行号程序进行去重，程序中引用的所有常量都被移动到了常量池（Constant pool）中。\",\"379\":\"\",\"380\":\"- 对齐方式：单字节对齐。\",\"381\":\"- 格式：\",\"382\":\"\",\"383\":\"| **名称**          | **格式** | **说明**                                               |\"}",
      "修改建议": "括号中的英文术语与正文中的术语不一致，应该使用一致的术语。",
      "更改后示例": "基于状态机（State Machine）的执行模型对行号程序（Line Number Program）进行解释，可得到映射和局部变量信息编码。",
      "触发条件": "当文档中出现括号内英文术语与正文中对应术语存在大小写不一致（如首字母大写/小写差异）或单词分隔符不一致（如空格/连字符使用差异）时触发。  \n\n识别模式：通过比对括号内外术语的命名格式（如State Machine vs state machine），检测首字母大写规范、术语构成词分隔方式（Line Number Program vs Line number program）是否保持统一。"
    },
    {
      "defect_id": 522032,
      "sentence": "`class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是一个指向[Class](#class)或[ForeignClass](#foreignclass)的偏移量。",
      "reference_sentence": "`name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。",
      "line_num": 108,
      "context": "{\"103\":\"- 对齐方式：单字节对齐。\",\"104\":\"- 格式：\",\"105\":\"\",\"106\":\"| **名称** | **格式** | **说明**                                               |\",\"107\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"108\":\"| `class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是一个指向[Class](#class)或[ForeignClass](#foreignclass)的偏移量。 |\",\"109\":\"| `reserved`       | `uint16_t`       | 方舟字节码文件内部使用的保留字段。               |\",\"110\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。 |\",\"111\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"112\":\"\",\"113\":\"> **注意：**\"}",
      "修改建议": "在`class_idx`的说明中使用了`索引`，而在`name_off`的说明中使用了`偏移量`，这两个词在描述同一概念时应保持一致。",
      "更改后示例": "`class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的偏移量，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是一个指向[Class](#class)或[ForeignClass](#foreignclass)的偏移量。",
      "触发条件": "同一文档中对同一技术概念（如偏移量）使用了不一致的术语（如\"索引\"和\"偏移量\"），且相邻/相关字段描述中存在已确立的标准术语（如其他字段统一使用\"偏移量\"）。"
    },
    {
      "defect_id": 523988,
      "sentence": "使用该接口调整缓存大小时，默认采用LRU（最近最少使用）方式清除多余缓存。",
      "reference_sentence": "根据缓存下载组件的各类型缓存大小上限决定存储位置，并默认使用“LRU”（最近最少使用）策略替换已有缓存内容。",
      "line_num": 177,
      "context": "{\"172\":\"\",\"173\":\"setFileCacheSize(bytes: number)\",\"174\":\"\",\"175\":\"设置缓存下载组件的文件缓存上限。\",\"176\":\"\",\"177\":\"- 使用该接口调整缓存大小时，默认采用LRU（最近最少使用）方式清除多余缓存。\",\"178\":\"\",\"179\":\"- 该方法为同步方法。它不阻塞调用线程。\",\"180\":\"\",\"181\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"182\":\"\"}",
      "修改建议": "使用了'方式'和'策略'，不一致。",
      "更改后示例": "使用该接口调整缓存大小时，默认采用LRU（最近最少使用）策略清除多余缓存。",
      "触发条件": "同一技术概念在文档不同位置出现同义词混用（如\"方式\"与\"策略\"），且存在已定义的规范术语（如参考句中的\"策略\"）时触发。识别需通过术语对比和上下文一致性检查。"
    },
    {
      "defect_id": 522252,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。",
      "reference_sentence": "### DebugInfo",
      "line_num": 405,
      "context": "{\"400\":\"| **名称**    | **初始值**                                             | **说明**                                               |\",\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\"}",
      "修改建议": "术语“寄存器”与“file”不一致，应该使用一致的术语。",
      "更改后示例": "一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么该字段的值是0。",
      "触发条件": "当同一字段或概念的描述中混用不一致的术语（如“寄存器”与“字段”），且上下文存在明确对应的正确术语时触发。  \n\n识别模式：  \n1. **术语冲突**：同一字段的说明中，关键实体（如`file`字段）被错误关联到其他上下文术语（如“寄存器”）。  \n2. **上下文一致性**：相邻条目或参考句子中已明确使用正确术语（如405行`file`字段的修复建议与406行`source_code`的“寄存器”形成对比，需根据字段属性区分“寄存器”与“字段”）。"
    },
    {
      "defect_id": 523890,
      "sentence": "request的cacheDownload子组件主要给应用提供应用资源提前缓存的基础能力。",
      "reference_sentence": "request部件主要提供文件上传下载和后台传输代理的基础能力。",
      "line_num": 5,
      "context": "{\"1\":\"# @ohos.request.cacheDownload (缓存下载)\",\"2\":\"\",\"3\":\"request部件主要提供文件上传下载和后台传输代理的基础能力。\",\"4\":\"\",\"5\":\"- request的cacheDownload子组件主要给应用提供应用资源提前缓存的基础能力。\",\"6\":\"\",\"7\":\"- cacheDownload组件使用HTTP协议进行数据下载，并将数据资源缓存至应用内存或应用沙箱目录的文件中。\",\"8\":\"\",\"9\":\"- 这些缓存数据可以被部分ArkUI组件（如Image组件）使用，以提升资源加载效率。请参阅ArkUI组件文档，确定组件是否支持该功能。\",\"10\":\"\"}",
      "修改建议": "混用了'部件'和'子组件'描述同一对象",
      "更改后示例": "request的cacheDownload部件主要给应用提供应用资源提前缓存的基础能力。",
      "触发条件": "同一文档中对同一技术组件存在多个不一致的命名表述（如\"部件\"和\"子组件\"混用），且上下文存在已定义的基准术语（如参考句中的\"部件\"）。\n\n识别模式：\n1. 实体指代匹配：检测同一组件在不同位置的命名变体（如\"cacheDownload子组件\"与\"request部件\"中的核心实体\"cacheDownload\"和\"request\"存在从属关系）\n2. 术语冲突定位：通过相邻段落/参考句建立基准术语（如第3段已确立\"部件\"），当后续出现同指实体的不同术语（如第5段\"子组件\"）时触发规则"
    },
    {
      "defect_id": 523982,
      "sentence": "cacheDownload组件使用HTTP协议下载数据，并将数据缓存到应用内存或应用沙箱目录的文件中。",
      "reference_sentence": "request的cacheDownload部件主要给应用提供应用资源提前缓存的基础能力。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"request部件提供文件上传下载和后台传输代理的基础能力。\",\"4\":\"\",\"5\":\"- request的cacheDownload部件主要给应用提供应用资源提前缓存的基础能力。\",\"6\":\"\",\"7\":\"- cacheDownload组件使用HTTP协议下载数据，并将数据缓存到应用内存或应用沙箱目录的文件中。\",\"8\":\"\",\"9\":\"- 缓存数据可被部分ArkUI组件（如Image组件）使用，以提升资源加载效率。查阅ArkUI组件文档，确定组件是否支持该功能。\",\"10\":\"\",\"11\":\"> **说明：**\",\"12\":\">\"}",
      "修改建议": "混用了“部件”和“组件”描述同一对象",
      "更改后示例": "cacheDownload部件使用HTTP协议下载数据，并将数据缓存到应用内存或应用沙箱目录的文件中。",
      "触发条件": "同一文档中出现对同一技术实体的不同术语指代（如\"组件\"与\"部件\"混用），且存在已确定的参考术语（如上下文其他位置固定使用\"部件\"）。\n\n识别模式：通过对比相邻段落/列表项的术语使用（如问题句中的\"组件\"与参考句中的\"部件\"），检测同一技术实体描述是否保持单一名词一致性，尤其关注中文近义词在技术文档中的统一性要求。"
    },
    {
      "defect_id": 523981,
      "sentence": "request部件提供文件上传下载和后台传输代理的基础能力。",
      "reference_sentence": "request的cacheDownload部件主要给应用提供应用资源提前缓存的基础能力。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.request.cacheDownload (缓存下载)\",\"2\":\"\",\"3\":\"request部件提供文件上传下载和后台传输代理的基础能力。\",\"4\":\"\",\"5\":\"- request的cacheDownload部件主要给应用提供应用资源提前缓存的基础能力。\",\"6\":\"\",\"7\":\"- cacheDownload组件使用HTTP协议下载数据，并将数据缓存到应用内存或应用沙箱目录的文件中。\",\"8\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一模块（部件）",
      "更改后示例": "request模块提供文件上传下载和后台传输代理的基础能力。",
      "触发条件": "同一文档中，同一模块/组件存在多个术语指代（如\"部件\"、\"模块\"、\"组件\"混用），且上下文存在明确的关联引用（如问题句与参考句均描述request相关功能）。通过术语词典匹配和邻近段落实体指代分析识别不一致表述。"
    },
    {
      "defect_id": 526622,
      "sentence": "- y2: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。",
      "reference_sentence": "- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。",
      "line_num": 59,
      "context": "{\"54\":\"\",\"55\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"56\":\"\",\"57\":\"- x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"58\":\"\",\"59\":\"- y2: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\"}",
      "修改建议": "y2描述的应为贝塞尔曲线第二点的纵坐标，这里与y1的描述混淆。",
      "更改后示例": "- y2: 确定贝塞尔曲线第二点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。",
      "触发条件": "当参数命名中的序号（如y2中的\"2\"）与对应描述中的位置表述（如\"第二点\"）不匹配，或同一参数组（x1/y1/x2/y2）存在描述模板不一致时触发。\n\n识别模式：1）检查参数名数字后缀与描述中\"第X点\"的对应关系 2）对比相邻参数项（如x2/y2）的描述句式是否保持相同结构模板"
    },
    {
      "defect_id": 525784,
      "sentence": "用于终止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。",
      "reference_sentence": "用于中止异步操作的对象。当signal.aborted为true时，锁请求将被丢弃；当signal.aborted为false时，请求会继续等待获取锁；当signal为null时，请求正常排队运行。默认为 null。",
      "line_num": 463,
      "context": "{\"458\":\"| mode      | [AsyncLockMode](#asynclockmode) | 否   | 否   | 锁的模式。                                                |\",\"459\":\"| contextId | number                          | 否   | 否   | [AsyncLockMode](#asynclockmode)调用者的执行上下文标识符。 |\",\"460\":\"\",\"461\":\"### AbortSignal\",\"462\":\"\",\"463\":\"用于终止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。\",\"464\":\"\",\"465\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"466\":\"\",\"467\":\"**系统能力：** SystemCapability.Utils.Lang\",\"468\":\"\"}",
      "修改建议": "混用了“终止”与“中止”两个近义词，可能导致表意模糊。",
      "更改后示例": "用于中止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。",
      "触发条件": "同一文档中存在相同概念使用多个近义词（如\"终止\"与\"中止\"），且上下文存在明确定义的统一术语（如类名AbortSignal对应\"中止\"）时触发。\n\n识别模式：\n1. 术语冲突检测：识别同一语义场景下出现的近义词（如动词性术语的混用）\n2. 上下文锚定验证：检查类名/接口名（AbortSignal）、参考示例（signal.aborted）等上下文是否存在对应术语的规范表达\n3. 跨段落一致性校验：对比相邻段落（如问题上下文第467行系统能力声明）是否使用相同术语体系"
    },
    {
      "defect_id": 525785,
      "sentence": "异步调用进入等待中，将在被唤醒后继续执行。使用Promise异步回调。",
      "reference_sentence": "异步调用进入等待中, 将在被唤醒或者等待时间结束后继续执行。使用Promise异步回调。",
      "line_num": 532,
      "context": "{\"527\":\"\",\"528\":\"#### wait<sup>18+</sup>\",\"529\":\"\",\"530\":\"wait(): Promise\\\\<void>\",\"531\":\"\",\"532\":\"异步调用进入等待中，将在被唤醒后继续执行。使用Promise异步回调。\",\"533\":\"\",\"534\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"535\":\"\",\"536\":\"**系统能力：** SystemCapability.Utils.Lang\",\"537\":\"\"}",
      "修改建议": "前后句子中“将在被唤醒后继续执行”与“将在被唤醒或者等待时间结束后继续执行”描述不一致，可能导致用户理解上的混乱。",
      "更改后示例": "异步调用进入等待中，将在被唤醒或者等待时间结束后继续执行。使用Promise异步回调。",
      "触发条件": "同一功能描述的相邻或上下文语句中，存在关键条件（如触发事件/结束方式）表述不一致（例如原句仅包含\"被唤醒\"而参考句补充\"等待时间结束\"），且差异直接影响用户对操作结果的理解。"
    },
    {
      "defect_id": 525716,
      "sentence": "在获取的锁下执行操作。该方法首先获取锁，然后调用回调，最后释放锁。",
      "reference_sentence": "在获取的锁下执行操作。该方法首先获取锁，然后调用回调，最后释放锁。",
      "line_num": 217,
      "context": "{\"212\":\"\",\"213\":\"#### lockAsync\",\"214\":\"\",\"215\":\"lockAsync\\\\<T>(callback: AsyncLockCallback\\\\<T>): Promise\\\\<T>\",\"216\":\"\",\"217\":\"在获取的锁下执行操作。该方法首先获取锁，然后调用回调，最后释放锁。回调在调用[lockAsync](#lockasync)的同一线程中以异步方式执行。\",\"218\":\"\",\"219\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"220\":\"\",\"221\":\"**系统能力：** SystemCapability.Utils.Lang\",\"222\":\"\"}",
      "修改建议": "重复使用相同的句子，但该句子在不同方法的描述中使用，需要确保一致性和准确性。",
      "更改后示例": "在获取的锁下执行操作。该方法首先获取锁，然后调用回调函数，最后释放锁。",
      "触发条件": "当同一文档的多个方法描述中重复使用相同句子结构但关键术语（如\"回调\"与\"回调函数\"）不统一，且存在相邻API说明上下文时触发。\n\n识别模式：\n1. 跨方法重复句式检测：匹配到\"在获取的锁下执行操作。该方法首先...，然后...，最后...\"的模板化句式\n2. 术语一致性验证：在相同句式模板中识别出核心概念术语差异（如\"回调\"与\"回调函数\"）\n3. 上下文关联性：问题句子与参考句子位于相邻API方法描述区块（如lockAsync与unlockAsync），且共享相同技术要素（锁机制、线程行为）。"
    },
    {
      "defect_id": 524516,
      "sentence": "typedArray不在类型范围内",
      "reference_sentence": "typedArray不在类型范围内",
      "line_num": 52,
      "context": "{\"47\":\"| number      | 返回typedArray[index]被修改之前的值，与smalltypedArray中的元素类型一致，可为负数，不可为浮点数。   |\",\"48\":\"\",\"49\":\"**错误信息**\",\"50\":\"| 错误信息        | 说明                         |\",\"51\":\"| ----------- | --------------------------- |\",\"52\":\"| \\\"Unhandled array type!\\\" | typedArray不在类型范围内 |\",\"53\":\"\",\"54\":\"**示例**  \",\"55\":\"```ts\",\"56\":\"let ab = new ArrayBuffer(1024)\",\"57\":\"let ta = new Uint8Array(ab)\"}",
      "修改建议": "建议使用更明确的术语，避免歧义。",
      "更改后示例": "typedArray的类型不在支持的范围内",
      "触发条件": "当文档中描述类型或范围时，关键术语（如\"类型\"）与上下文存在表述断层，或出现\"在范围内/外\"等模糊表述但未明确主体与限定条件时触发。\n\n识别模式：通过检测\"名词+不在...范围内\"的句式结构，结合上下文验证是否缺失核心术语（如\"类型\"）的主语归属，或是否缺少\"支持/允许\"等范围限定词（如\"支持的范围内\"）。"
    },
    {
      "defect_id": 525816,
      "sentence": "此设计基于资源访问的考虑：近期访问的数据可能在不久的将来再次访问，因此最少访问的数据价值最小，应优先移出缓存。",
      "reference_sentence": "SendableLruCache在缓存空间不足时，会用新数据替换近期最少使用的数据。",
      "line_num": 900,
      "context": "{\"895\":\"// 期望输出: 'SendableFunc is Sendable'\",\"896\":\"```\",\"897\":\"\",\"898\":\"## SendableLruCache<K, V><sup>18+</sup>\",\"899\":\"\",\"900\":\"SendableLruCache在缓存空间不足时，会用新数据替换近期最少使用的数据。此设计基于资源访问的考虑：近期访问的数据可能在不久的将来再次访问，因此最少访问的数据价值最小，应优先移出缓存。SendableLruCache支持Sendable特性，可保存Sendable对象，确保跨线程安全访问。\",\"901\":\"\",\"902\":\"### 属性\",\"903\":\"\",\"904\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"905\":\"\"}",
      "修改建议": "混用了“移出”和“替换”概念，导致表意不一致。",
      "更改后示例": "此设计基于资源访问的考虑：近期访问的数据可能在不久的将来再次访问，因此最少访问的数据价值最小，应优先被新数据替换。",
      "触发条件": "同一上下文或相邻段落中对同一操作概念混用不同动词（如\"移出\"与\"替换\"），且存在已明确定义的参考术语（如\"替换\"在参考句中被规范使用）时触发。"
    },
    {
      "defect_id": 526109,
      "sentence": "在解析的键值对的值。",
      "reference_sentence": "在解析的键值对所属的对象。",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"| 参数名 | 类型   | 必填 | 说明            |\",\"31\":\"| ------ | ------ | ---- | --------------- |\",\"32\":\"| this   | Object | 是 | 在解析的键值对所属的对象。|\",\"33\":\"| key  | string | 是 | 属性名。|\",\"34\":\"| value  | Object | 是 | 在解析的键值对的值。|\",\"35\":\"\",\"36\":\"**返回值：**\",\"37\":\"\",\"38\":\"| 类型 | 说明 |\",\"39\":\"| -------- | -------- |\"}",
      "修改建议": "前文称'在解析的键值对的值'，后文称'在解析的键值对所属的对象'，前后描述不一致。",
      "更改后示例": "键值对的值。",
      "触发条件": "当文档中同一上下文或相邻位置出现结构相似（如\"键值对的X\"）但关键术语（如\"值\"/\"所属的对象\"）表述不统一时触发，特别是在表格、列表等需要严格并列的格式场景下。\n\n识别模式：\n1. 检测相同前缀结构（如\"键值对的\"）后接不同属性描述\n2. 验证并列结构（如参数说明表）中对应位置的术语一致性\n3. 对比相邻条目是否存在语义关联但表述差异（如\"值\"与\"所属的对象\"的从属关系不匹配）"
    },
    {
      "defect_id": 525817,
      "sentence": "如果缓冲区中值的总数超过指定容量，将删除最少使用的键值对。",
      "reference_sentence": "将缓冲区容量设置为指定值。",
      "line_num": 949,
      "context": "{\"944\":\"\",\"945\":\"### updateCapacity<sup>18+</sup>\",\"946\":\"\",\"947\":\"updateCapacity(newCapacity: number): void\",\"948\":\"\",\"949\":\"将缓冲区容量设置为指定值。如果缓冲区中值的总数超过指定容量，将删除最少使用的键值对。\",\"950\":\"\",\"951\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"952\":\"\",\"953\":\"**系统能力：** SystemCapability.Utils.Lang\",\"954\":\"\"}",
      "修改建议": "混用了“删除”和“替换”概念，导致表意不一致。",
      "更改后示例": "如果缓冲区中值的总数超过指定容量，将移除最少使用的键值对。",
      "触发条件": "同一上下文或相邻语句中对同一操作使用不同动词表述，或与参考术语存在概念偏差时触发。具体表现为当技术文档中针对相同操作交替使用近义词（如\"删除\"与\"移除\"）或不同语义动词（如\"替换\"与\"删除\"），且与上下文术语体系（如参考句中的\"设置\"）产生逻辑矛盾时。"
    },
    {
      "defect_id": 526108,
      "sentence": "在解析的键值对所属的对象。",
      "reference_sentence": "在解析的键值对的值。",
      "line_num": 32,
      "context": "{\"27\":\"\",\"28\":\"**参数：**\",\"29\":\"\",\"30\":\"| 参数名 | 类型   | 必填 | 说明            |\",\"31\":\"| ------ | ------ | ---- | --------------- |\",\"32\":\"| this   | Object | 是 | 在解析的键值对所属的对象。|\",\"33\":\"| key  | string | 是 | 属性名。|\",\"34\":\"| value  | Object | 是 | 在解析的键值对的值。|\",\"35\":\"\",\"36\":\"**返回值：**\",\"37\":\"\"}",
      "修改建议": "前文称'在解析的键值对所属的对象'，后文称'在解析的键值对的值'，前后描述不一致。",
      "更改后示例": "所属的对象。",
      "触发条件": "当相邻或结构相似的句子中，相同语法位置的修饰成分（如\"所属的对象\"和\"的值\"）存在语义范畴不一致，且上下文存在明确对应参照系（如参数表相邻条目）时触发。\n\n识别模式：\n1. 结构对齐检测：识别表格/列表中具有相同语法结构的相邻条目（如参数说明的三列结构）\n2. 成分对比分析：定位相同语法位置的关键修饰成分（如参数说明第三列开头的介词短语）\n3. 语义范畴验证：检查对应成分是否属于同一语义维度（如\"所属\"表示归属关系，\"值\"表示内容属性）"
    },
    {
      "defect_id": 525735,
      "sentence": "10200031 | Timeout exceeded.",
      "reference_sentence": "10200030 | The lock does not exist.",
      "line_num": 326,
      "context": "{\"321\":\"\",\"322\":\"| 错误码ID | 错误信息          |\",\"323\":\"| -------- | ----------------- |\",\"324\":\"| 401      | The input parameters are invalid. |\",\"325\":\"| 10200030 | The lock does not exist.     |\",\"326\":\"| 10200031 | Timeout exceeded. |\",\"327\":\"\",\"328\":\"**示例：**\",\"329\":\"\",\"330\":\"```ts\",\"331\":\"let lock = new ArkTSUtils.locks.AsyncLock();\"}",
      "修改建议": "错误码和错误信息不一致",
      "更改后示例": "10200031 | Timeout has been exceeded.",
      "触发条件": "当错误信息的语法结构（如时态、语态）或句式（主谓完整性）与同文档其他错误信息条目存在显著差异时触发，特别是当错误码对应的描述信息存在被动语态助动词缺失（如\"exceeded\"未使用\"has been exceeded\"）或主谓结构不完整（如缺少冠词）时。"
    },
    {
      "defect_id": 525869,
      "sentence": "| V&nbsp;\\|&nbsp;undefined | 返回一个包含已删除键值对的Optional对象；如果key不存在，则返回undefined，如果key为null，则抛出异常。 |",
      "reference_sentence": "| V&nbsp;\\|&nbsp;undefined | 如果指定的键存在于缓冲区中，则返回与键关联的值；否则调用内部默认接口，并返回其结果。如果内部默认接口返回undefined，则最终返回undefined。 |",
      "line_num": 1366,
      "context": "{\"1361\":\"\",\"1362\":\"**返回值：**\",\"1363\":\"\",\"1364\":\"| 类型                     | 说明                                                         |\",\"1365\":\"| ------------------------ | ------------------------------------------------------------ |\",\"1366\":\"| V&nbsp;\\\\|&nbsp;undefined | 返回一个包含已删除键值对的Optional对象；如果key不存在，则返回undefined，如果key为null，则抛出异常。 |\",\"1367\":\"\",\"1368\":\"**示例：**\",\"1369\":\"\",\"1370\":\"```ts\",\"1371\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "混用了'包含已删除键值对的Optional对象'和'与键关联的值'，用词不一致，且'删除'与'查询'近义词混用。",
      "更改后示例": "| V&nbsp;\\|&nbsp;undefined | 返回一个包含与键关联的值的Optional对象；如果key不存在，则返回undefined，如果key为null，则抛出异常。 |",
      "触发条件": "同一功能描述中存在对相同概念使用不一致的术语（如\"键值对\"与\"值\"），或混用具有冲突语义的近义词（如\"删除\"与\"查询\"操作动词）。"
    },
    {
      "defect_id": 525855,
      "sentence": "当缓冲区中值的数量超过容量时，会执行删除操作。",
      "reference_sentence": "当缓冲区数量超过容量限制时，最少使用的键值对将被回收。",
      "line_num": 1263,
      "context": "{\"1258\":\"\",\"1259\":\"### put<sup>18+</sup>\",\"1260\":\"\",\"1261\":\"put(key: K,value: V): V\",\"1262\":\"\",\"1263\":\"将键值对添加到缓冲区，并返回与添加的键关联的值。当缓冲区中值的数量超过容量时，会执行删除操作。\",\"1264\":\"\",\"1265\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1266\":\"\",\"1267\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1268\":\"\"}",
      "修改建议": "混用了'删除'与'回收'的概念，导致表意模糊。",
      "更改后示例": "当缓冲区中值的数量超过容量时，会执行回收操作。",
      "触发条件": "文档中同一操作或概念出现多个不同术语表述，且上下文存在已确立的标准术语（如参考句中的\"回收\"）时触发。通过检测关键操作动词与上下文既定术语的匹配度，识别术语混用导致的表意不一致问题。"
    },
    {
      "defect_id": 524670,
      "sentence": "添加selinux标签",
      "reference_sentence": "为系统参数添加selinux标签",
      "line_num": 108,
      "context": "{\"103\":\"\",\"104\":\"  ![UGO规则信息](figures/系统参数DAC.png)\",\"105\":\"\",\"106\":\"#### MAC访问控制权限设置\",\"107\":\"\",\"108\":\" - 添加selinux标签：\",\"109\":\"\",\"110\":\"    为系统参数添加selinux标签，首先需要在文件/base/security/selinux_adapter/sepolicy/base/public/parameter.te中定义标签，例如：\",\"111\":\"\",\"112\":\"    ```java\",\"113\":\"    type servicectrl_param, parameter_attr\"}",
      "修改建议": "混用了'添加'和'为...添加'的表述，建议统一使用'为...添加'",
      "更改后示例": "为系统参数添加selinux标签",
      "触发条件": "同一段落或相邻上下文中存在同一动作的两种不同句式结构（如\"添加\"和\"为...添加\"），且存在明确的参考句式作为统一标准。"
    },
    {
      "defect_id": 524710,
      "sentence": "typedArray不在类型范围内",
      "reference_sentence": "访问typedArray越界。",
      "line_num": 937,
      "context": "{\"932\":\"| bigint       | 返回typedArray[index]被修改之前的值。   |\",\"933\":\"\",\"934\":\"**错误信息**\",\"935\":\"| 错误信息        | 说明                         |\",\"936\":\"| ----------- | --------------------------- |\",\"937\":\"| \\\"Unhandled array type!\\\" | typedArray不在类型范围内 |\",\"938\":\"\",\"939\":\"**示例：**\",\"940\":\"```ts\",\"941\":\"let ab = new ArrayBuffer(1024)\",\"942\":\"let ta = new BigInt64Array(ab)\"}",
      "修改建议": "混用了不同错误信息的描述方式，应保持一致",
      "更改后示例": "typedArray不在支持的类型范围内",
      "触发条件": "同一文档章节内的同类错误信息描述存在句式结构或关键词不一致（如“不在类型范围内”与“不在支持的类型范围内”），且上下文存在可参照的一致性表达模式（如“访问typedArray越界”）。"
    },
    {
      "defect_id": 524631,
      "sentence": "系统参数没有定义任何DAC，MAC权限时，其默认权限为：",
      "reference_sentence": "系统参数没有定义任何DAC，MAC权限时，其默认权限为：",
      "line_num": 70,
      "context": "{\"65\":\"### 系统参数权限设置\",\"66\":\"\",\"67\":\"系统参数支持DAC和MAC访问控制。\",\"68\":\"#### 默认权限\",\"69\":\"\",\"70\":\"系统参数没有定义任何DAC，MAC权限时，其默认权限为：\",\"71\":\"\",\"72\":\"| [DAC] User | [DAC] Group | [DAC] UGO | [MAC] SELinux Label |\",\"73\":\"| ---------- | ----------- | --------- | ------------------- |\",\"74\":\"| root       | root        | 775       | default_param       |\",\"75\":\"\"}",
      "修改建议": "术语不一致，'权限'应统一为'访问控制'。",
      "更改后示例": "系统参数没有定义任何DAC，MAC访问控制时，其默认访问控制为：",
      "触发条件": "当同一技术概念在相邻段落或上下文中出现术语混用（如\"权限\"与\"访问控制\"交替使用），且存在已明确定义的规范术语时触发。\n\n识别模式：\n1. 定位核心技术术语（如\"访问控制\"）在文档中的首次明确定义位置（例中第67行）\n2. 检测后续段落中同一概念是否出现非规范表达（如第70行使用\"权限\"替代\"访问控制\"）\n3. 验证术语替换是否导致技术含义偏差（本例\"权限\"与\"访问控制\"属于包含关系，需保持精确性）"
    },
    {
      "defect_id": 525793,
      "sentence": "该方法将ArkTS对象数据转换为JSON字符串，额外支持Map和Set相关类型。",
      "reference_sentence": "用于解析JSON字符串生成ISendable数据或null。",
      "line_num": 779,
      "context": "{\"774\":\"\",\"775\":\"### stringify\",\"776\":\"\",\"777\":\"stringify(value: Object | null | undefined): string\",\"778\":\"\",\"779\":\"该方法将ArkTS对象数据转换为JSON字符串，额外支持Map和Set相关类型。\",\"780\":\"\",\"781\":\"> **说明：**\",\"782\":\">\",\"783\":\"> 从API 18开始参数修改为Object类型，API 18之前参数只支持ISendable类型。\",\"784\":\"\"}",
      "修改建议": "描述相同的操作时，用词不一致。",
      "更改后示例": "该方法将ArkTS对象数据转换为JSON字符串，并额外支持Map和Set类型。",
      "触发条件": "同一句子或相邻上下文中存在对相同功能的描述存在词汇冗余（如\"相关类型\"与直接类型列举混用）或结构不一致（如\"额外支持\"与\"并额外支持\"的连词缺失），且与上下文同类描述模式不匹配时触发。"
    },
    {
      "defect_id": 525734,
      "sentence": "Promise\\<T \\| U> | 回调执行后解决的Promise，或者在超时情况下被拒绝。",
      "reference_sentence": "Promise\\<T> | 回调执行后将解决的Promise。",
      "line_num": 316,
      "context": "{\"311\":\"\",\"312\":\"**返回值：**\",\"313\":\"\",\"314\":\"| 类型             | 说明                                               |\",\"315\":\"| ---------------- | -------------------------------------------------- |\",\"316\":\"| Promise\\\\<T \\\\| U> | 回调执行后解决的Promise，或者在超时情况下被拒绝。 |\",\"317\":\"\",\"318\":\"**错误码：**\",\"319\":\"\",\"320\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"321\":\"\"}",
      "修改建议": "返回值类型不一致，且描述不一致",
      "更改后示例": "Promise<T | U> | 回调执行后返回的Promise，或者在超时情况下被拒绝。",
      "触发条件": "当文档中同一返回值类型的描述动词（如\"解决\"与\"返回\"）或类型参数（如\\<T>与\\<T | U>）出现不一致，且与上下文参考句式存在术语/结构矛盾时触发。"
    },
    {
      "defect_id": 528163,
      "sentence": "删除Worker所有的事件监听。",
      "reference_sentence": "删除Worker的事件监听，该接口与[off<sup>9+</sup>](#off9)接口功能一致。",
      "line_num": 1195,
      "context": "{\"1190\":\"\",\"1191\":\"### removeAllListener<sup>9+</sup>\",\"1192\":\"\",\"1193\":\"removeAllListener(): void\",\"1194\":\"\",\"1195\":\"删除Worker所有的事件监听。\",\"1196\":\"\",\"1197\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"1198\":\"\",\"1199\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1200\":\"\"}",
      "修改建议": "混用了“删除”和“移除”近义词",
      "更改后示例": "移除Worker所有的事件监听。",
      "触发条件": "同一文档或上下文中对同一操作或对象使用了不同近义动词（如“删除”与“移除”），且存在已确立的标准术语（如参考句中的“删除”或接口命名中的“remove”）。需通过对比上下文动词与接口命名、参考句用词的一致性进行识别。"
    },
    {
      "defect_id": 528223,
      "sentence": "宿主线程通过转移对象所有权的方式向Worker线程发送消息。",
      "reference_sentence": "宿主线程通过转移对象所有权的方式向ThreadWorker线程发送消息。",
      "line_num": 1744,
      "context": "{\"1739\":\"\",\"1740\":\"### postMessage<sup>(deprecated)</sup>\",\"1741\":\"\",\"1742\":\"postMessage(message: Object, transfer: ArrayBuffer[]): void\",\"1743\":\"\",\"1744\":\"宿主线程通过转移对象所有权的方式向Worker线程发送消息。\",\"1745\":\"\",\"1746\":\"> **说明：**<br/>\",\"1747\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorker.postMessage<sup>9+</sup>](#postmessage9)替代。\",\"1748\":\"\",\"1749\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "混用了`Worker`和`ThreadWorker`概念，且`Worker`已被废弃，建议使用`ThreadWorker`",
      "更改后示例": "宿主线程通过转移对象所有权的方式向ThreadWorker线程发送消息。",
      "触发条件": "当文档中混用同一概念的不同术语（如已废弃术语与推荐术语并存），且上下文存在明确API版本废弃说明时触发。\n\n识别模式：检测到术语与同段落/相邻版本说明中推荐的正式术语不一致（如\"Worker\" vs \"ThreadWorker\"），且存在版本废弃标记（如\"deprecated\"）及替代建议时，判定为术语不统一问题。"
    },
    {
      "defect_id": 526584,
      "sentence": "3、 执行循环主体的语句。  ",
      "reference_sentence": "3、 执行循环主体的语句。  ",
      "line_num": 429,
      "context": "{\"424\":\"\",\"425\":\"`for`语句的执行流程如下：\",\"426\":\"\",\"427\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"428\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"429\":\"3、 执行循环主体的语句。  \",\"430\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"431\":\"5、 回到步骤2。  \",\"432\":\"\",\"433\":\"示例：\",\"434\":\"\"}",
      "修改建议": "句子结构不一致，建议使用统一的祈使句",
      "更改后示例": "3、 执行循环主体的语句。",
      "触发条件": "同一列表或上下文中相邻条目存在句式结构不一致（如部分使用祈使句，部分使用陈述句），且当前句子与相邻条目语法模式不匹配时触发。"
    },
    {
      "defect_id": 528218,
      "sentence": "使用以下方法前，均需先构造Worker实例，Worker类继承[EventTarget](#eventtargetdeprecated)。",
      "reference_sentence": "使用以下方法前，均需先构造ThreadWorker实例，ThreadWorker类继承[EventTarget](#eventtargetdeprecated)。",
      "line_num": 1706,
      "context": "{\"1701\":\"| --------- | ------------------------------- | ---- | ------------------------------------------------------------ |\",\"1702\":\"| err | ErrorEvent                          | 是   | 错误事件类，用于表示Worker执行过程中出现异常的详细信息。 |\",\"1703\":\"\",\"1704\":\"## Worker<sup>(deprecated)</sup>\",\"1705\":\"\",\"1706\":\"使用以下方法前，均需先构造Worker实例，Worker类继承[EventTarget](#eventtargetdeprecated)。\",\"1707\":\"\",\"1708\":\"> **说明：**<br/>\",\"1709\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorker<sup>9+</sup>](#threadworker9)替代。\",\"1710\":\"\",\"1711\":\"### constructor<sup>(deprecated)</sup>\"}",
      "修改建议": "混用了`Worker`和`ThreadWorker`概念，且`Worker`已被废弃，建议使用`ThreadWorker`",
      "更改后示例": "使用以下方法前，均需先构造ThreadWorker实例，ThreadWorker类继承[EventTarget](#eventtargetdeprecated)。",
      "触发条件": "文档中存在同一概念使用多个不同术语的情况，且上下文明确显示存在新旧术语更替（如被废弃类名与替代类名同时出现）。具体表现为当废弃术语与推荐替代术语在相邻版本说明中同时存在时，仍使用废弃术语进行描述。"
    },
    {
      "defect_id": 528076,
      "sentence": "Worker的上下文对象和UI主线程的上下文对象是不同的，Worker线程不支持UI操作",
      "reference_sentence": "Worker的上下文对象和UI主线程的上下文对象是不同的，Worker线程不支持UI操作",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"Worker是与主线程并行的独立线程。创建Worker的线程称之为宿主线程，Worker自身的线程称之为Worker线程。创建Worker传入的url文件在Worker线程中执行，可以处理耗时操作但不可以直接操作UI。\",\"4\":\"\",\"5\":\"Worker主要作用是为应用程序提供一个多线程的运行环境，可满足应用程序在执行过程中与宿主线程分离，在后台线程中运行一个脚本处理耗时操作，极大避免类似于计算密集型或高延迟的任务阻塞宿主线程的运行。由于Worker一旦被创建则不会主动被销毁，若不处于任务状态一直运行，在一定程度上会造成资源的浪费，应及时关闭空闲的Worker。\",\"6\":\"\",\"7\":\"Worker的上下文对象和UI主线程的上下文对象是不同的，Worker线程不支持UI操作。\",\"8\":\"\",\"9\":\"Worker使用过程中的相关注意点请查看[Worker注意事项](../../arkts-utils/worker-introduction.md#worker注意事项)。\",\"10\":\"\",\"11\":\"> **说明：**<br/>\",\"12\":\"> 本模块首批接口从API version 7开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\"}",
      "修改建议": "使用了'UI主线程'和'UI操作'两种表述，应保持一致",
      "更改后示例": "Worker的上下文对象和UI线程的上下文对象是不同的，Worker线程不支持UI操作。",
      "触发条件": "同一技术概念在相邻上下文或同一句子中存在两种及以上不同表述形式（如\"UI主线程\"与\"UI线程\"），且存在已确立的标准术语（如参考句中的\"UI主线程\"）时触发。"
    },
    {
      "defect_id": 528185,
      "sentence": "销毁Worker线程，终止Worker接收消息。",
      "reference_sentence": "Worker线程向宿主线程发送消息，消息中的[Sendable对象](../../arkts-utils/arkts-sendable.md)通过引用传递，非Sendable对象通过拷贝数据的方式传递。",
      "line_num": 1484,
      "context": "{\"1479\":\"\",\"1480\":\"### close<sup>9+</sup>\",\"1481\":\"\",\"1482\":\"close(): void\",\"1483\":\"\",\"1484\":\"销毁Worker线程，终止Worker接收消息。\",\"1485\":\"\",\"1486\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"1487\":\"\",\"1488\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1489\":\"\"}",
      "修改建议": "混用了'发送消息'和'接收消息'的描述方式，导致前后不一致。",
      "更改后示例": "销毁Worker线程，停止Worker接收消息。",
      "触发条件": "同一文档中对相同操作（如消息传递）使用不一致的动词（如“终止”与“停止”混用），且上下文存在明确统一表达（如参考句已用“发送”对应“停止”）。"
    },
    {
      "defect_id": 526300,
      "sentence": "当id为tab3的TabContent显示的时候冻结设置该节点的冻结状态为false。",
      "reference_sentence": "当id为tab1的TabContent显示的时候设置该节点的冻结状态为false。",
      "line_num": 235,
      "context": "{\"230\":\"        .onWillHide(() => {\",\"231\":\"          //当id为tab3的TabContent隐藏的时候设置该节点的冻结状态为true。\",\"232\":\"          this.getUIContext().freezeUINode('tab3', true);\",\"233\":\"        })\",\"234\":\"        .onWillShow(() => {\",\"235\":\"          //id为tab3的TabContent显示的时候冻结设置该节点的冻结状态为false。\",\"236\":\"          this.getUIContext().freezeUINode('tab3', false);\",\"237\":\"        })\",\"238\":\"\",\"239\":\"      }\",\"240\":\"      .vertical(false)\"}",
      "修改建议": "描述中混用了'设置'和'冻结设置'，应保持一致。",
      "更改后示例": "当id为tab3的TabContent显示的时候设置该节点的冻结状态为false。",
      "触发条件": "同一操作在相邻注释或相邻代码块中使用了不一致的动词短语（如\"设置\"与\"冻结设置\"），且存在可匹配的参考表达模式时。\n\n识别模式：\n1. 动词短语冲突检测：在相邻3行内或同一代码块注释中，检测到描述相同操作时混用包含/不包含修饰词的动词（如\"冻结设置\"vs\"设置\"）\n2. 参考模式匹配：上下文中存在相同操作的标准表达形式（如问题上下文第231行使用\"设置\"，而第235行却使用\"冻结设置\"）\n3. 功能指向验证：通过代码方法名验证操作本质（如freezeUINode方法对应\"设置冻结状态\"语义），确保术语简化不影响准确性"
    },
    {
      "defect_id": 528233,
      "sentence": "宿主线程通过转移对象所有权或者拷贝数据的方式向Worker线程发送消息。",
      "reference_sentence": "宿主线程通过转移对象所有权的方式向Worker线程发送消息。",
      "line_num": 1771,
      "context": "{\"1766\":\"\",\"1767\":\"### postMessage<sup>(deprecated)</sup>\",\"1768\":\"\",\"1769\":\"postMessage(message: Object, options?: PostMessageOptions): void\",\"1770\":\"\",\"1771\":\"宿主线程通过转移对象所有权或者拷贝数据的方式向Worker线程发送消息。\",\"1772\":\"\",\"1773\":\"> **说明：**<br/>\",\"1774\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorker.postMessage<sup>9+</sup>](#postmessage9-1)替代。\",\"1775\":\"\",\"1776\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "混用了“转移对象所有权”和“转移对象所有权或者拷贝数据”的描述",
      "更改后示例": "宿主线程通过转移对象所有权或拷贝数据的方式向Worker线程发送消息。",
      "触发条件": "当同一并列结构中混用不同连接词（如\"或\"与\"或者\"交替使用），或同一术语在邻近上下文中出现表达形式不一致时触发。\n\n识别模式：\n1. 检测并列结构中存在\"或\"/\"或者\"的混用（如\"X或者Y的方式\"与参考句\"X或Y的方式\"冲突）\n2. 比对相邻段落/相似句式中的相同语义表达（如问题句与参考句在相同API说明场景下使用不同连接词）"
    },
    {
      "defect_id": 528095,
      "sentence": "| options | [PostMessageOptions](#postmessageoptions) | 否   | 当填入该参数时，与传入ArrayBuffer[]的作用一致，该数组中对象的所有权会被转移到Worker线程，在宿主线程中将会变为不可用，仅在Worker线程中可用。<br>若不填入该参数，默认设置为 undefined，通过拷贝数据的方式传输信息到Worker线程。 |",
      "reference_sentence": "| transfer | ArrayBuffer[] | 是   | 表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到Worker线程，在宿主线程中将会变为不可用，仅在Worker线程中可用，数组不可传入null。 |",
      "line_num": 220,
      "context": "{\"215\":\"**参数：**\",\"216\":\"\",\"217\":\"| 参数名  | 类型                                      | 必填 | 说明                                                         |\",\"218\":\"| ------- | ----------------------------------------- | ---- | ------------------------------------------------------------ |\",\"219\":\"| message | Object                                    | 是   | 发送至Worker的数据，该数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。 |\",\"220\":\"| options | [PostMessageOptions](#postmessageoptions) | 否   | 当填入该参数时，与传入ArrayBuffer[]的作用一致，该数组中对象的所有权会被转移到Worker线程，在宿主线程中将会变为不可用，仅在Worker线程中可用。<br>若不填入该参数，默认设置为 undefined，通过拷贝数据的方式传输信息到Worker线程。 |\",\"221\":\"\",\"222\":\"**错误码：**\",\"223\":\"\",\"224\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"225\":\"\"}",
      "修改建议": "参数描述不一致，应统一描述为`transfer`",
      "更改后示例": "| options | [PostMessageOptions](#postmessageoptions) | 否   | 当填入该参数时，表示传输的数据将通过所有权转移的方式发送到Worker线程，这些数据在宿主线程中将变为不可用，仅在Worker线程中可用。<br>若不填入该参数，默认设置为 undefined，通过拷贝数据的方式传输信息到Worker线程。 |",
      "触发条件": "当参数说明中引用其他参数的实现机制但未使用统一术语，或同一功能在不同参数描述中存在术语/表达方式不一致时触发。具体表现为参数描述出现\"与传入X的作用一致\"类表述却未采用X参数的标准术语，或相同功能点在不同参数说明中使用不同关键词（如\"所有权转移\"与\"传入ArrayBuffer[]的作用\"）。"
    },
    {
      "defect_id": 528085,
      "sentence": "ThreadWorker类继承[WorkerEventTarget](#workereventtarget9)。",
      "reference_sentence": "ThreadWorker类继承[WorkerEventTarget](#workereventtarget9)。",
      "line_num": 63,
      "context": "{\"58\":\"| IDLE | 3 | 后台优先级，对应QOS_BACKGROUND。 |\",\"59\":\"\",\"60\":\"\",\"61\":\"## ThreadWorker<sup>9+</sup>\",\"62\":\"\",\"63\":\"使用以下方法前，均需先构造ThreadWorker实例，ThreadWorker类继承[WorkerEventTarget](#workereventtarget9)。\",\"64\":\"\",\"65\":\"### constructor<sup>9+</sup>\",\"66\":\"\",\"67\":\"constructor(scriptURL: string, options?: WorkerOptions)\",\"68\":\"\"}",
      "修改建议": "混用了“类”和“类”概念",
      "更改后示例": "ThreadWorker类继承自[WorkerEventTarget](#workereventtarget9)。",
      "触发条件": "当句子中出现类继承关系的描述（如“继承[类名]”），但缺少必要介词“自”导致语法结构不完整时，触发该规则。具体表现为动词“继承”后直接跟随目标类名或链接，未形成“继承自”的标准表达模式。"
    },
    {
      "defect_id": 528074,
      "sentence": "创建Worker传入的url文件在Worker线程中执行",
      "reference_sentence": "创建Worker传入的url文件在Worker线程中执行",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.worker (启动一个Worker)\",\"2\":\"\",\"3\":\"Worker是与主线程并行的独立线程。创建Worker的线程称之为宿主线程，Worker自身的线程称之为Worker线程。创建Worker传入的url文件在Worker线程中执行，可以处理耗时操作但不可以直接操作UI。\",\"4\":\"\",\"5\":\"Worker主要作用是为应用程序提供一个多线程的运行环境，可满足应用程序在执行过程中与宿主线程分离，在后台线程中运行一个脚本处理耗时操作，极大避免类似于计算密集型或高延迟的任务阻塞宿主线程的运行。由于Worker一旦被创建则不会主动被销毁，若不处于任务状态一直运行，在一定程度上会造成资源的浪费，应及时关闭空闲的Worker。\",\"6\":\"\",\"7\":\"Worker的上下文对象和UI主线程的上下文对象是不同的，Worker线程不支持UI操作。\",\"8\":\"\"}",
      "修改建议": "使用了'创建Worker'和'创建Worker传入的url文件'两种表述，应保持一致",
      "更改后示例": "创建Worker时传入的url文件在Worker线程中执行",
      "触发条件": "同一段落或相邻句子中对同一操作存在结构不一致的表述（如\"创建Worker\"与\"创建Worker传入的url文件\"），且关键动作短语存在省略/冗余成分时触发。\n\n识别模式：\n1. 检测相邻句子中描述同一核心动作的短语结构差异（如是否包含时间状语\"时\"）\n2. 验证是否指向同一技术操作（本例中均为Worker创建过程）\n3. 对比上下文是否存在统一表达范式（参考句中的\"创建Worker时传入\"结构）"
    },
    {
      "defect_id": 528129,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 581,
      "context": "{\"576\":\"\",\"577\":\"terminate(): void\",\"578\":\"\",\"579\":\"销毁Worker线程，终止Worker接收消息。\",\"580\":\"\",\"581\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"582\":\"\",\"583\":\"**系统能力：** SystemCapability.Utils.Lang\",\"584\":\"\",\"585\":\"**错误码：**\",\"586\":\"\"}",
      "修改建议": "原文中使用了'API version 11'，但建议使用统一的术语以保持一致性。",
      "更改后示例": "从API版本11开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一术语在文档中存在中英文混用（如“version”与“版本”交替出现），且与上下文或既定术语标准（如参考句中的“API version”）不一致时触发。"
    },
    {
      "defect_id": 528128,
      "sentence": "销毁Worker线程，终止Worker接收消息。",
      "reference_sentence": "销毁Worker线程，终止Worker接收消息。",
      "line_num": 579,
      "context": "{\"574\":\"\",\"575\":\"### terminate<sup>9+</sup>\",\"576\":\"\",\"577\":\"terminate(): void\",\"578\":\"\",\"579\":\"销毁Worker线程，终止Worker接收消息。\",\"580\":\"\",\"581\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"582\":\"\",\"583\":\"**系统能力：** SystemCapability.Utils.Lang\",\"584\":\"\"}",
      "修改建议": "原文中使用了'销毁'和'终止'，但建议使用统一的术语以保持一致性。",
      "更改后示例": "销毁Worker线程并停止Worker接收消息。",
      "触发条件": "在同一句子或相邻上下文中，使用多个不同动词或术语描述同一操作或对象，且未明确区分其含义时触发。  \n识别模式：检测并列结构（如逗号分隔的短语）或连续步骤中针对同一主体（如\"Worker线程\"）的动词差异（如\"销毁\"与\"终止\"），并结合上下文判断是否指向同一逻辑行为。"
    },
    {
      "defect_id": 528184,
      "sentence": "Worker线程调用注册在宿主线程上某个对象的指定方法，调用对于Worker线程是同步的，对于宿主线程是异步的，返回值通过拷贝数据的方式传递。",
      "reference_sentence": "Worker线程向宿主线程发送消息，消息中的[Sendable对象](../../arkts-utils/arkts-sendable.md)通过引用传递，非Sendable对象通过拷贝数据的方式传递。",
      "line_num": 1402,
      "context": "{\"1397\":\"\",\"1398\":\"### callGlobalCallObjectMethod<sup>11+</sup>\",\"1399\":\"\",\"1400\":\"callGlobalCallObjectMethod(instanceName: string, methodName: string, timeout: number, ...args: Object[]): Object\",\"1401\":\"\",\"1402\":\"Worker线程调用注册在宿主线程上某个对象的指定方法，调用对于Worker线程是同步的，对于宿主线程是异步的，返回值通过拷贝数据的方式传递。\",\"1403\":\"\",\"1404\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"1405\":\"\",\"1406\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1407\":\"\"}",
      "修改建议": "混用了'发送消息'和'调用方法'的描述方式，导致前后不一致。",
      "更改后示例": "Worker线程调用宿主线程上注册的某个对象的指定方法，调用对Worker线程是同步的，对宿主线程是异步的，返回值通过数据拷贝方式传递。",
      "触发条件": "同一段落或相邻上下文中，对同一操作机制存在混用不同动词（如\"调用方法\"与\"发送消息\"）或短语结构（如\"拷贝数据的方式\"与\"数据拷贝方式\"）的情况。"
    },
    {
      "defect_id": 528152,
      "sentence": "删除Worker所有的事件监听。",
      "reference_sentence": "删除Worker的事件监听，该接口与[off<sup>9+</sup>](#off9)接口功能一致。",
      "line_num": 1005,
      "context": "{\"1000\":\"\",\"1001\":\"### removeAllListener<sup>9+</sup>\",\"1002\":\"\",\"1003\":\"removeAllListener(): void\",\"1004\":\"\",\"1005\":\"删除Worker所有的事件监听。\",\"1006\":\"\",\"1007\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"1008\":\"\",\"1009\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1010\":\"\"}",
      "修改建议": "混用了'删除'和'移除'，应保持用词一致。",
      "更改后示例": "移除Worker所有的事件监听。",
      "触发条件": "同一文档中对同一操作或对象使用了多个不一致的中文动词（如“删除”和“移除”），且上下文存在关联术语（如接口名称含“remove”或参考句已明确用词）。"
    },
    {
      "defect_id": 528293,
      "sentence": "Actor并发模型的交互原理：各个Actor并发地处理宿主线程任务，每个Actor内部都有一个消息队列和单线程执行模块。消息队列负责接收宿主线程及其他Actor的请求，而单线程执行模块则负责串行地处理这些请求、向其他Actor发送请求以及创建新的Actor。由于Actor采用的是异步方式，各个Actor之间相互隔离且没有数据竞争，因此Actor可以高并发运行。",
      "reference_sentence": "Worker基于Actor并发模型实现。在Worker的交互流程中，JS宿主线程可以创建多个Worker子线程，各个Worker线程间相互隔离，并通过序列化传递对象，等到Worker线程完成计算任务，再把结果返回给宿主线程。",
      "line_num": 2525,
      "context": "{\"2520\":\"```\",\"2521\":\"\",\"2522\":\"### 内存模型\",\"2523\":\"Worker基于Actor并发模型实现。在Worker的交互流程中，JS宿主线程可以创建多个Worker子线程，各个Worker线程间相互隔离，并通过序列化传递对象，等到Worker线程完成计算任务，再把结果返回给宿主线程。\",\"2524\":\"\",\"2525\":\"Actor并发模型的交互原理：各个Actor并发地处理宿主线程任务，每个Actor内部都有一个消息队列和单线程执行模块。消息队列负责接收宿主线程及其他Actor的请求，而单线程执行模块则负责串行地处理这些请求、向其他Actor发送请求以及创建新的Actor。由于Actor采用的是异步方式，各个Actor之间相互隔离且没有数据竞争，因此Actor可以高并发运行。\",\"2526\":\"\",\"2527\":\"## 完整示例\",\"2528\":\"> **说明：**<br/>\",\"2529\":\"> API version 8及之前的版本仅支持FA模型，如需使用，注意更换构造Worker的接口和创建Worker线程中与宿主线程通信的对象的两个方法。<br>\",\"2530\":\"### FA模型\"}",
      "修改建议": "混用了`Actor`和`Worker`概念，且描述方式不一致，建议统一使用`Worker`",
      "更改后示例": "Worker并发模型的交互原理：各个Worker并发地处理宿主线程任务，每个Worker内部都有一个消息队列和单线程执行模块。消息队列负责接收宿主线程及其他Worker的请求，而单线程执行模块则负责串行地处理这些请求、向其他Worker发送请求以及创建新的Worker。由于Worker采用的是异步方式，各个Worker之间相互隔离且没有数据竞争，因此Worker可以高并发运行。",
      "触发条件": "同一技术概念在相邻段落中使用了不同术语表述，且上下文存在明确定义的统一术语时触发。\n\n识别模式：通过对比相邻段落和参考句子的核心术语（如Actor/Worker），检测是否存在术语混用现象。当满足以下特征时应触发修复：1) 存在多个可互换术语描述同一机制；2) 上下文已有明确术语定义（如参考句子的\"Worker\"）；3) 术语不一致出现在技术原理描述等需要严格概念统一的场景。"
    },
    {
      "defect_id": 528274,
      "sentence": "Worker线程通过转移对象所有权的方式向宿主线程发送消息。",
      "reference_sentence": "Worker线程通过转移对象所有权或者拷贝数据的方式向宿主线程发送消息。",
      "line_num": 2229,
      "context": "{\"2224\":\"}\",\"2225\":\"```\",\"2226\":\"\",\"2227\":\"### postMessage<sup>(deprecated)</sup>\",\"2228\":\"\",\"2229\":\"postMessage(messageObject: Object, options?: PostMessageOptions): void\",\"2230\":\"\",\"2231\":\"Worker线程通过转移对象所有权或者拷贝数据的方式向宿主线程发送消息。\",\"2232\":\"\",\"2233\":\"> **说明：**<br/>\",\"2234\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorkerGlobalScope<sup>9+</sup>.postMessage<sup>9+</sup>](#postmessage9-3)替代。\"}",
      "修改建议": "前后描述不一致，前文描述为'转移对象所有权的方式'，后文描述为'转移对象所有权或者拷贝数据的方式'。",
      "更改后示例": "Worker线程通过转移对象所有权或拷贝数据的方式向宿主线程发送消息。",
      "触发条件": "当同一概念或操作在相邻段落中存在表述方式（如单一方法与多选方案）、数量（如单数/复数）或术语（如\"或者\"/\"或\"）不一致时触发。\n\n识别模式：检查文档中相同操作描述是否保持选项数量一致（如\"转移对象所有权的方式\"与\"转移对象所有权或者拷贝数据的方式\"），特别关注并列连词（或/和）的使用差异，以及同一功能说明中是否突然增加/减少可选方案而未同步更新相关描述。"
    },
    {
      "defect_id": 528259,
      "sentence": "需要删除的监听事件类型。",
      "reference_sentence": "需要删除的事件类型。",
      "line_num": 2047,
      "context": "{\"2042\":\"\",\"2043\":\"**参数：**\",\"2044\":\"\",\"2045\":\"| 参数名   | 类型                                      | 必填 | 说明                     |\",\"2046\":\"| -------- | ----------------------------------------- | ---- | ------------------------ |\",\"2047\":\"| type     | string                                    | 是   | 需要删除的监听事件类型。 |\",\"2048\":\"| callback | [EventListener](#eventlistenerdeprecated) | 否   | 删除监听事件后所执行的回调事件。 |\",\"2049\":\"\",\"2050\":\"**示例：**\",\"2051\":\"\",\"2052\":\"```ts\"}",
      "修改建议": "混用了'监听事件类型'与'事件类型'，建议保持一致。",
      "更改后示例": "需要删除的事件类型。",
      "触发条件": "同一文档或上下文范围内，同一概念出现多个术语变体（如\"监听事件类型\"与\"事件类型\"），且无明确语义区分需求时触发。通过检测相邻段落/表格中相同语义字段的修饰词冗余（如\"监听\"）或核心名词不一致（如\"事件类型\"与\"监听事件类型\"）进行识别。"
    },
    {
      "defect_id": 528243,
      "sentence": "| listener | [EventListener](#eventlistenerdeprecated) | 否   | 删除监听事件后所执行的回调事件。 |",
      "reference_sentence": "| listener | [EventListener](#eventlistenerdeprecated) | 是   | 回调事件。 |",
      "line_num": 1869,
      "context": "{\"1864\":\"**参数：**\",\"1865\":\"\",\"1866\":\"| 参数名   | 类型                                      | 必填 | 说明                 |\",\"1867\":\"| -------- | ----------------------------------------- | ---- | -------------------- |\",\"1868\":\"| type     | string                                    | 是   | 需要删除的事件类型。 |\",\"1869\":\"| listener | [EventListener](#eventlistenerdeprecated) | 否   | 删除监听事件后所执行的回调事件。 |\",\"1870\":\"\",\"1871\":\"**示例：**\",\"1872\":\"\",\"1873\":\"```ts\",\"1874\":\"const workerInstance = new worker.Worker(\\\"workers/worker.ets\\\");\"}",
      "修改建议": "混用了'删除'与'移除'，且参数名'listener'在'on'方法中是必填的，而在'off'方法中是可选的",
      "更改后示例": "| listener | [EventListener](#eventlistenerdeprecated) | 否   | 移除监听事件后所执行的回调函数。 |",
      "触发条件": "当同一参数描述中混用不同动词（如\"删除\"与\"移除\"）或关键术语（如\"事件\"与\"函数\"）时，且相邻上下文存在对应的标准术语参照（如API方法命名或参数定义）。\n\n识别模式：\n1. 检测参数说明中的操作动词是否与对应API方法命名一致（如off方法对应\"移除\"而非\"删除\"）\n2. 对比同一参数在不同方法中的必填状态描述（如listener在on/off方法中的必填性差异）\n3. 匹配技术名词与接口定义的一致性（如\"回调函数\"需与参数类型EventListener保持术语统一）"
    },
    {
      "defect_id": 528260,
      "sentence": "删除监听事件后所执行的回调事件。",
      "reference_sentence": "删除监听事件后所执行的回调事件。",
      "line_num": 2048,
      "context": "{\"2043\":\"**参数：**\",\"2044\":\"\",\"2045\":\"| 参数名   | 类型                                      | 必填 | 说明                     |\",\"2046\":\"| -------- | ----------------------------------------- | ---- | ------------------------ |\",\"2047\":\"| type     | string                                    | 是   | 需要删除的监听事件类型。 |\",\"2048\":\"| callback | [EventListener](#eventlistenerdeprecated) | 否   | 删除监听事件后所执行的回调事件。 |\",\"2049\":\"\",\"2050\":\"**示例：**\",\"2051\":\"\",\"2052\":\"```ts\",\"2053\":\"// worker.ets\"}",
      "修改建议": "混用了'回调事件'与'回调'，建议保持一致。",
      "更改后示例": "删除监听事件后所执行的回调。",
      "触发条件": "同一文档中相邻上下文或参数说明部分对同一技术概念（如\"回调\"）出现术语使用不一致（如\"回调\"与\"回调事件\"混用），且存在明确参考基准（如参数命名或前文统一表述）。"
    },
    {
      "defect_id": 528242,
      "sentence": "删除类型为type的事件监听，该接口与[removeEventListener<sup>(deprecated)</sup>](#removeeventlistenerdeprecated)接口功能一致。",
      "reference_sentence": "向Worker添加一个事件监听，该接口与[addEventListener<sup>(deprecated)</sup>](#addeventlistenerdeprecated)接口功能一致。",
      "line_num": 1857,
      "context": "{\"1852\":\"\",\"1853\":\"### off<sup>(deprecated)</sup>\",\"1854\":\"\",\"1855\":\"off(type: string, listener?: EventListener): void\",\"1856\":\"\",\"1857\":\"删除类型为type的事件监听，该接口与[removeEventListener<sup>(deprecated)</sup>](#removeeventlistenerdeprecated)接口功能一致。\",\"1858\":\"\",\"1859\":\"> **说明：**<br/>\",\"1860\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorker.off<sup>9+</sup>](#off9)替代。\",\"1861\":\"\",\"1862\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "混用了'删除'与'移除'，且'添加'与'删除'对应关系不一致",
      "更改后示例": "移除类型为type的事件监听，该接口与[removeEventListener<sup>(deprecated)</sup>](#removeeventlistenerdeprecated)接口功能一致。",
      "触发条件": "同一上下文或对应接口中存在术语混用（如\"删除\"与\"移除\"），且与关联操作（如\"添加\"）或接口命名（如removeXXX）的动词表达不一致时触发。\n\n识别模式：\n1. 动词对应性检测：当描述反向操作时（如添加/移除），需检查动词是否形成逻辑对应\n2. 接口命名映射：检查中文动词是否与接口英文命名（如removeXXX）保持语义一致性\n3. 跨接口一致性：同一功能的不同接口描述需保持相同动词（如removeEventListener与off接口都对应\"移除\"）"
    },
    {
      "defect_id": 528257,
      "sentence": "向Worker添加一个事件监听，该接口与[on<sup>(deprecated)</sup>](#ondeprecated)接口功能一致。",
      "reference_sentence": "删除类型为type的事件监听，该接口与[removeEventListener<sup>(deprecated)</sup>](#removeeventlistenerdeprecated)接口功能一致。",
      "line_num": 2004,
      "context": "{\"1999\":\"\",\"2000\":\"### addEventListener<sup>(deprecated)</sup>\",\"2001\":\"\",\"2002\":\"addEventListener(type: string, listener: EventListener): void\",\"2003\":\"\",\"2004\":\"向Worker添加一个事件监听，该接口与[on<sup>(deprecated)</sup>](#ondeprecated)接口功能一致。\",\"2005\":\"\",\"2006\":\"> **说明：**<br/>\",\"2007\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[addEventListener<sup>9+</sup>](#addeventlistener9)替代。\",\"2008\":\"\",\"2009\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "混用了'添加'与'删除'、'on'与'off'，建议保持一致。",
      "更改后示例": "向Worker添加一个事件监听，该接口与[addEventListener<sup>(deprecated)</sup>](#addeventlistenerdeprecated)接口功能一致。",
      "触发条件": "当文档中同时出现\"添加/删除\"类操作动词与\"addEventListener/removeEventListener\"类接口名称，且二者语义前缀（add/remove）未保持对应关系时触发；或当接口引用出现\"on/off\"与\"add/remove\"两组命名体系混用时触发。"
    },
    {
      "defect_id": 528287,
      "sentence": "ArrayBuffer数组，用于传递所有权。该数组中不可传入null。默认值为undefined。",
      "reference_sentence": "表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到宿主线程，在Worker线程中将会变为不可用，仅在宿主线程中可用，数组不可传入null。",
      "line_num": 2369,
      "context": "{\"2364\":\"\",\"2365\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2366\":\"\",\"2367\":\"| 名称     | 类型     | 只读 | 可选 | 说明                              |\",\"2368\":\"| -------- | -------- | ---- | ---- | --------------------------------- |\",\"2369\":\"| transfer | Object[] | 否   | 是   | ArrayBuffer数组，用于传递所有权。该数组中不可传入null。默认值为undefined。 |\",\"2370\":\"\",\"2371\":\"\",\"2372\":\"## Event\",\"2373\":\"\",\"2374\":\"事件类。\"}",
      "修改建议": "混用了`ArrayBuffer`和`ArrayBuffer[]`，且描述风格不一致",
      "更改后示例": "ArrayBuffer数组（ArrayBuffer[]），用于传递所有权。该数组中不可传入null，且默认值为undefined。",
      "触发条件": "当同一技术术语存在类型名称与符号混用（如\"ArrayBuffer数组\"与\"ArrayBuffer[]\"），且相邻说明语句出现句式结构/标点符号不一致（如分句间使用句号分隔而非逗号连接）时触发。\n\n识别模式：\n1. 术语一致性检测：匹配技术名词是否同时存在中文描述和类型符号两种形态（如\"数组\"与\"[]\"）\n2. 句式连贯性检测：检查说明性语句中是否出现：a) 分句间标点符号不统一（句号/逗号混用） b) 逻辑连接词缺失（如缺少\"且\"等连词） c) 句子结构不对称（如主谓结构/动宾结构混用）"
    },
    {
      "defect_id": 528286,
      "sentence": "明确数据传递过程中需要转移所有权对象的类，传递所有权的对象必须是ArrayBuffer，发送它的上下文中将会变为不可用，仅在接收方可用。",
      "reference_sentence": "表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到宿主线程，在Worker线程中将会变为不可用，仅在宿主线程中可用，数组不可传入null。",
      "line_num": 2361,
      "context": "{\"2356\":\"```\",\"2357\":\"\",\"2358\":\"\",\"2359\":\"## PostMessageOptions\",\"2360\":\"\",\"2361\":\"明确数据传递过程中需要转移所有权对象的类，传递所有权的对象必须是ArrayBuffer，发送它的上下文中将会变为不可用，仅在接收方可用。\",\"2362\":\"\",\"2363\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2364\":\"\",\"2365\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2366\":\"\"}",
      "修改建议": "描述风格不一致，且混用了`ArrayBuffer`和`ArrayBuffer[]`",
      "更改后示例": "明确数据传递过程中需要转移所有权的对象，这些对象必须是ArrayBuffer，在发送方的上下文中将变为不可用，仅在接收方可用。",
      "触发条件": "同一术语或概念在相邻语句中存在单复数形式不一致（如ArrayBuffer/ArrayBuffer[]混用）、代词与主体名称混用（如\"发送它的上下文\"/\"发送方上下文\"），或句式结构不匹配（如主被动语态交替）。"
    },
    {
      "defect_id": 528268,
      "sentence": "删除Worker所有的事件监听。",
      "reference_sentence": "删除Worker的事件监听，该接口与[off<sup>(deprecated)</sup>](#offdeprecated)接口功能一致。",
      "line_num": 2136,
      "context": "{\"2131\":\"\",\"2132\":\"### removeAllListener<sup>(deprecated)</sup>\",\"2133\":\"\",\"2134\":\"removeAllListener(): void\",\"2135\":\"\",\"2136\":\"删除Worker所有的事件监听。\",\"2137\":\"\",\"2138\":\"> **说明：**<br/>\",\"2139\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[removeAllListener<sup>9+</sup>](#removealllistener9)替代。\",\"2140\":\"\",\"2141\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "描述不一致，建议使用更具体的描述",
      "更改后示例": "移除Worker上所有已注册的事件监听器。",
      "触发条件": "当文档中的动词（如“删除”）或术语（如“事件监听”）与上下文推荐术语（如“移除”“事件监听器”）不一致，或缺少必要修饰语（如“已注册的”）时触发。"
    },
    {
      "defect_id": 533497,
      "sentence": "通过ContentModifier实现自定义复选框样式的功能，用一个五边形复选框替换原本Checkbox的样式。如果选中，内部会出现红色三角图案，标题会显示选中字样；如果取消选中，红色三角图案消失，标题会显示非选中字样。",
      "reference_sentence": "当某些组件的内容区不满足开发者诉求时，可以采用ContentModifier实现以自定义Builder替换组件内容区的效果。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"仅特定组件支持该能力。分别是Button、Checkbox、DataPanel、TextTimer、Slider、Select、Rating、Radio、Gauge、Toggle、TextClock。\",\"8\":\"\",\"9\":\"## 示例\",\"10\":\"\",\"11\":\"通过ContentModifier实现自定义复选框样式的功能，用一个五边形复选框替换原本Checkbox的样式。如果选中，内部会出现红色三角图案，标题会显示选中字样；如果取消选中，红色三角图案消失，标题会显示非选中字样。\",\"12\":\"\",\"13\":\"```ts\",\"14\":\"// xxx.ets\",\"15\":\"class MyCheckboxStyle implements ContentModifier<CheckBoxConfiguration> {\",\"16\":\"  selectedColor: Color = Color.White;\"}",
      "修改建议": "混用了“复选框”和“Checkbox”描述同一对象",
      "更改后示例": "通过ContentModifier实现自定义复选框样式的功能，用一个五边形复选框替换原本的复选框样式。如果选中，内部会出现红色三角图案，标题会显示选中字样；如果取消选中，红色三角图案消失，标题会显示非选中字样。",
      "触发条件": "同一段落或相邻上下文中出现同一技术术语的中英文混用（如\"Checkbox\"与\"复选框\"），或同一概念存在两种及以上不同中文译名时触发。\n\n识别模式：\n1. 技术名词匹配：检测中英文术语对应关系（如Checkbox=复选框）\n2. 邻近重复检查：在3句范围内出现同一概念的不同表达形式\n3. 上下文一致性验证：对比问题出现位置与文档其他部分的术语使用惯例（如参考句统一使用中文\"组件\"而非\"Component\"）"
    },
    {
      "defect_id": 533448,
      "sentence": "开发者可以根据实际应用场景选择合适的表单与选择组件进行页面开发。",
      "reference_sentence": "开发者可以根据实际应用场景选择合适的表单与选择组件进行界面开发。",
      "line_num": 5,
      "context": "{\"1\":\"# 表单与选择组件概述\",\"2\":\"\",\"3\":\"表单与选择组件通常用于构建一个页面的基础元素，如按钮、开关等。\",\"4\":\"\",\"5\":\"开发者可以根据实际应用场景选择合适的表单与选择组件进行页面开发。\",\"6\":\"\",\"7\":\"| 表单与选择组件名称 | 应用场景 |\",\"8\":\"| -------- | -------- |\",\"9\":\"| [按钮(Button)](arkts-common-components-button.md) | 通常用于响应用户的点击操作。 |\",\"10\":\"| [弧形按钮(ArcButton)](arkts-advanced-components-arcbutton.md) | 用于圆形屏幕。为手表用户提供强调、普通、警告等样式按钮。 |\"}",
      "修改建议": "混用了'页面'和'界面'概念",
      "更改后示例": "开发者可以根据实际应用场景选择合适的表单与选择组件进行界面开发。",
      "触发条件": "当同一文档中相邻段落或同一概念范畴内出现\"页面\"与\"界面\"等表达相同语义的术语混用时，且上下文存在明确的概念指向一致性要求（如组件开发场景中界面/页面指代同一实体）。"
    },
    {
      "defect_id": 528289,
      "sentence": "从API version 7开始支持，从API version 9开始废弃，建议使用[(event:Event)<sup>9+</sup>](#event-event9)替代。",
      "reference_sentence": "从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorkerGlobalScope<sup>9+</sup>.onmessageerror<sup>9+</sup>](#onmessageerror9-1)替代。",
      "line_num": 2400,
      "context": "{\"2395\":\"\",\"2396\":\"(evt: Event): void | Promise&lt;void&gt;\",\"2397\":\"\",\"2398\":\"> **说明：**\",\"2399\":\">\",\"2400\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[(event:Event)<sup>9+</sup>](#event-event9)替代。\",\"2401\":\"\",\"2402\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2403\":\"\",\"2404\":\"**参数：**\",\"2405\":\"\"}",
      "修改建议": "描述风格不一致",
      "更改后示例": "从API version 7开始支持，从API version 9开始废弃，建议使用[(event:Event)<sup>9+</sup>](#event-event9)。",
      "触发条件": "当文档中同一段落内存在多个API版本说明时，若替代建议的链接文本中同时出现参数类型括号和版本标记<sup>但未保持统一格式结构，或与上下文其他替代链接的语法模式不一致。  \n\n识别模式：1）检查替代链接是否同时包含参数类型括号和版本标记；2）对比同文档中其他替代链接的格式（如版本标记是否直接附加在标识符后而非括号外），确保参数描述与版本标注的层级关系一致。"
    },
    {
      "defect_id": 535450,
      "sentence": "周期执行任务每隔period时长执行一次。",
      "reference_sentence": "校验并发函数的参数类型和返回类型后，周期执行泛型任务，每隔period时长执行一次。",
      "line_num": 436,
      "context": "{\"431\":\"\",\"432\":\"## taskpool.executePeriodically<sup>12+</sup>\",\"433\":\"\",\"434\":\"executePeriodically(period: number, task: Task, priority?: Priority): void\",\"435\":\"\",\"436\":\"周期执行任务每隔period时长执行一次。当前执行模式支持设置任务优先级，并可以通过调用cancel取消任务周期执行。周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。\",\"437\":\"\",\"438\":\"\",\"439\":\"**系统能力：** SystemCapability.Utils.Lang\",\"440\":\"\",\"441\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\"}",
      "修改建议": "前后描述不一致，应使用一致的术语和描述方式。",
      "更改后示例": "周期任务每隔period时长执行一次。",
      "触发条件": "同一段落或相邻句子中对同一概念使用不一致的术语（如“周期执行任务”与“周期任务”），或存在冗余修饰词导致表达重复。  \n识别模式：检查核心名词短语是否在上下文中有统一缩写或扩展形式（如“周期任务”是否被其他句子简写/全称混用），并比对相邻句子中相同概念的命名差异。"
    },
    {
      "defect_id": 535356,
      "sentence": "将待执行的函数放入taskpool内部任务队列，函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不可取消任务。",
      "reference_sentence": "任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "line_num": 32,
      "context": "{\"27\":\"```\",\"28\":\"## taskpool.execute\",\"29\":\"\",\"30\":\"execute(func: Function, ...args: Object[]): Promise\\\\<Object>\",\"31\":\"\",\"32\":\"将待执行的函数放入taskpool内部任务队列，函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不可取消任务。\",\"33\":\"\",\"34\":\"**系统能力：** SystemCapability.Utils.Lang\",\"35\":\"\",\"36\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"37\":\"\"}",
      "修改建议": "术语'taskpool'应与上文保持一致，应使用'任务池'。",
      "更改后示例": "将待执行的函数放入任务池内部任务队列，函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不可取消任务。",
      "触发条件": "当技术文档中同一术语出现中英文混用，且该术语在上下文或参考内容中已有明确中文译名时触发；或当接口名称/代码符号与自然语言描述存在术语形式不统一时触发。\n\n识别模式：1.检测到代码符号/接口名（如taskpool）与自然语言描述（如\"任务池\"）存在语言形式差异 2.在相同文档范围内，该术语存在两种及以上表达形式且未声明别名关系 3.存在权威参考句（如技术定义段落）明确使用规范译名。"
    },
    {
      "defect_id": 535591,
      "sentence": "删除当前任务对其他任务的依赖。使用该方法前需先构造Task。",
      "reference_sentence": "为当前任务添加对其他任务的依赖。使用该方法前需先构造Task。",
      "line_num": 1522,
      "context": "{\"1517\":\"\",\"1518\":\"### removeDependency<sup>11+</sup>\",\"1519\":\"\",\"1520\":\"removeDependency(...tasks: Task[]): void\",\"1521\":\"\",\"1522\":\"删除当前任务对其他任务的依赖。使用该方法前需先构造Task。\",\"1523\":\"\",\"1524\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1525\":\"\",\"1526\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1527\":\"\"}",
      "修改建议": "“删除”与“移除”近义词混用",
      "更改后示例": "移除当前任务对其他任务的依赖。使用该方法前需先构造Task。",
      "触发条件": "同一文档或相邻上下文中存在多个近义词描述同一操作，且存在明确术语参照（如API方法名、用户指南术语）时。"
    },
    {
      "defect_id": 535806,
      "sentence": "执行异步任务。使用该方法前需要先构造AsyncRunner。",
      "reference_sentence": "构造一个非全局的异步队列，如果参数相同，返回的是不同的异步队列。",
      "line_num": 2344,
      "context": "{\"2339\":\"\",\"2340\":\"### execute<sup>18+</sup>\",\"2341\":\"\",\"2342\":\"execute(task: Task, priority?: Priority): Promise\\\\<Object>\",\"2343\":\"\",\"2344\":\"执行异步任务。使用该方法前需要先构造AsyncRunner。\",\"2345\":\"\",\"2346\":\"> **说明：**\",\"2347\":\">\",\"2348\":\"> - 不支持执行任务组任务。\",\"2349\":\"> - 不支持执行串行队列任务。\"}",
      "修改建议": "混用了“构造”和“创建”概念",
      "更改后示例": "执行异步任务。使用该方法前需要先创建AsyncRunner。",
      "触发条件": "同一文档中对同一技术概念使用多个不同术语（如\"构造\"和\"创建\"），且存在已确立的标准术语（参考句子中持续使用\"构造\"）时触发。识别模式为检测同一上下文范围内，对相同操作行为使用语义相近但用词不一致的动词描述。"
    },
    {
      "defect_id": 535722,
      "sentence": "将创建好的任务添加到任务组中。使用该方法前需先构造TaskGroup。任务组不能添加其他任务组任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。",
      "reference_sentence": "将待执行的函数添加到任务组中。使用该方法前需要先构造TaskGroup。",
      "line_num": 2073,
      "context": "{\"2068\":\"\",\"2069\":\"### addTask<sup>10+</sup>\",\"2070\":\"\",\"2071\":\"addTask(task: Task): void\",\"2072\":\"\",\"2073\":\"将创建好的任务添加到任务组中。使用该方法前需先构造TaskGroup。任务组不能添加其他任务组任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。\",\"2074\":\"\",\"2075\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2076\":\"\",\"2077\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2078\":\"\"}",
      "修改建议": "混用了“任务”和“函数”概念，且“需”与“需要”用词不一致",
      "更改后示例": "将创建好的任务添加到任务组中。使用该方法前需要先构造TaskGroup。任务组不能添加其他任务组中的任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。",
      "触发条件": "同一文档中出现相同概念使用不同术语表述（如\"任务\"与\"函数\"混用），或同一动词存在不同形态表达（如\"需\"与\"需要\"交替使用）。\n\n识别模式：\n1. 术语一致性检测：通过对比上下文及参考句，识别同一技术概念是否使用多个不同术语（如\"任务组任务\"与\"任务组中的任务\"的结构差异）\n2. 用词形态检测：在相邻语句中扫描同一语义动词的不同表达形式（如\"需\"的缩略形式与\"需要\"完整形式混用），特别关注单字动词与双字动词的交替使用场景"
    },
    {
      "defect_id": 535777,
      "sentence": "指定任务执行的最大并发度，该参数应为正整数。负数时报错，非整数会向下取整。",
      "reference_sentence": "指定任务执行的最大并发度，该参数应为正整数。负数时报错，非整数会向下取整。",
      "line_num": 2323,
      "context": "{\"2318\":\"**参数：**\",\"2319\":\"\",\"2320\":\"| 参数名   | 类型                  | 必填 | 说明                                                       |\",\"2321\":\"| -------- | --------------------- | ---- | ---------------------------------------------------------- |\",\"2322\":\"| name     | string                | 是   | 异步队列的名字。 |\",\"2323\":\"| runningCapacity | number | 是   | 指定任务执行的最大并发度，该参数应为正整数。负数时报错，非整数会向下取整。 |\",\"2324\":\"| waitingCapacity | number | 否   |  指定等待任务的列表容量，取值需大于等于0，负数时报错，输入非整数时会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。 |\",\"2325\":\"\",\"2326\":\"**错误码：**\",\"2327\":\"\",\"2328\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\"}",
      "修改建议": "混用了'输入非整数'和'非整数'描述同一概念。",
      "更改后示例": "指定任务执行的最大并发度，该参数应为正整数。负数时报错，输入非整数会向下取整。",
      "触发条件": "同一文档中相邻参数描述对同类输入验证使用不一致的修饰语（如\"非整数\"与\"输入非整数\"），且上下文存在相同参数类型的平行结构描述时。"
    },
    {
      "defect_id": 535812,
      "sentence": "在当前线程上运行的任务id列表。返回为空时，代表没有任务执行。",
      "reference_sentence": "任务执行至当前所用的时间，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。",
      "line_num": 2465,
      "context": "{\"2460\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2461\":\"\",\"2462\":\"| 名称     | 类型                    | 只读 | 可选 | 说明                                                      |\",\"2463\":\"| -------- | ---------------------- | ---- | ---- | -------------------------------------------------------- |\",\"2464\":\"| tid      | number                 | 是   | 否   | 工作线程的标识符。返回为空时，代表没有任务执行。              |\",\"2465\":\"| taskIds  | number[]               | 是   | 否   | 在当前线程上运行的任务id列表。返回为空时，代表没有任务执行。   |\",\"2466\":\"| priority | [Priority](#priority)  | 是   | 否   | 当前线程的优先级。返回为空时，代表没有任务执行。              |\",\"2467\":\"\",\"2468\":\"## TaskPoolInfo<sup>10+</sup>\",\"2469\":\"\",\"2470\":\"任务池的内部信息。\"}",
      "修改建议": "混用了'返回为空时，代表没有任务执行'和'返回为空时，表示没有任务执行'，用词不一致",
      "更改后示例": "在当前线程上运行的任务id列表。返回为空时，表示没有任务执行。",
      "触发条件": "当同一文档或相邻上下文中出现相同语义但使用不同动词（如\"代表\"和\"表示\"）描述相同逻辑关系时，且存在已确立的参考用词规范（如参考句中的\"表示\"）。\n\n识别模式：\n1. 相邻条目间句式重复（如\"返回为X时，[动词]...\"结构）\n2. 相同逻辑场景（空值语义）使用不同动词表达\n3. 存在明确的参考用词模板（如问题上下文外的规范示例）"
    },
    {
      "defect_id": 535354,
      "sentence": "任务池（taskpool）的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "reference_sentence": "任务池（taskpool）的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.taskpool（启动任务池）\",\"2\":\"\",\"3\":\"任务池（taskpool）的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。您可以使用任务池API创建后台任务（Task），并进行如执行任务或取消任务等操作。理论上，任务池API允许创建的任务数量不受限制，但由于内存限制，不建议这样做。此外，不建议在任务中执行阻塞操作，尤其是无限期阻塞操作，因为长时间的阻塞操作会占用工作线程，可能阻塞其他任务的调度，影响应用性能。\",\"4\":\"\",\"5\":\"您所创建的同一优先级任务的执行顺序可以由您决定，任务真实执行的顺序与您调用任务池API提供的任务执行接口顺序一致。任务默认优先级是MEDIUM。\",\"6\":\"\",\"7\":\"当同一时间待执行的任务数量大于任务池工作线程数量，任务池会根据负载均衡机制进行扩容，增加工作线程数量，减少整体等待时长。同样，当执行的任务数量减少，工作线程数量大于执行任务数量，部分工作线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少工作线程数量。\",\"8\":\"\"}",
      "修改建议": "术语'taskpool'应与上文保持一致，应使用'任务池'。",
      "更改后示例": "任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "触发条件": "当同一术语在上下文中已存在中英文对照形式（如\"任务池（taskpool）\"），后续单独出现英文术语且无必要保留英文时，或术语使用形式与首次定义的中英文对照格式不一致时。\n\n识别模式：\n1. 检测到中文术语后带括号英文的初始定义（如X（Y））\n2. 在后续文本中发现单独使用括号内的英文术语（Y）而非中文术语（X）\n3. 排除技术参数、代码片段等必须使用英文的合理场景"
    },
    {
      "defect_id": 535529,
      "sentence": "**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 911,
      "context": "{\"906\":\"**系统能力：**  SystemCapability.Utils.Lang\",\"907\":\"\",\"908\":\"| 名称 | 值 | 说明 |\",\"909\":\"| -------- | -------- | -------- |\",\"910\":\"| HIGH   | 0    | 任务为高优先级。<br/>**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。 |\",\"911\":\"| MEDIUM | 1 | 任务为中优先级。<br/>**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。 |\",\"912\":\"| LOW | 2 | 任务为低优先级。<br/>**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。 |\",\"913\":\"| IDLE<sup>12+</sup> | 3 | 任务为后台任务。<br/>**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。 |\",\"914\":\"\",\"915\":\"**示例：**\",\"916\":\"\"}",
      "修改建议": "重复使用了相同的句子，导致冗余。",
      "更改后示例": "**原子化服务API**：从API version 11开始支持。",
      "触发条件": "当同一段落或相邻列表项中存在两个及以上相同/高度相似的句式结构（如重复的版本说明语句），且上下文存在可合并或简化的冗余表达时触发。\n\n识别模式：需检测表格/列表中相邻条目末尾是否包含相同句式（例如固定短语\"**原子化服务API**：从API version X开始...\"），并验证其是否仅在版本号等关键参数存在差异。若差异仅为一个数字/单词且位置固定，则判定为冗余重复。"
    },
    {
      "defect_id": 535451,
      "sentence": "周期执行的任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。",
      "reference_sentence": "需要周期执行的泛型任务。",
      "line_num": 436,
      "context": "{\"431\":\"\",\"432\":\"## taskpool.executePeriodically<sup>12+</sup>\",\"433\":\"\",\"434\":\"executePeriodically(period: number, task: Task, priority?: Priority): void\",\"435\":\"\",\"436\":\"周期执行任务每隔period时长执行一次。当前执行模式支持设置任务优先级，并可以通过调用cancel取消任务周期执行。周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。\",\"437\":\"\",\"438\":\"\",\"439\":\"**系统能力：** SystemCapability.Utils.Lang\",\"440\":\"\",\"441\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\"}",
      "修改建议": "前后描述不一致，应使用一致的术语和描述方式。",
      "更改后示例": "周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。",
      "触发条件": "同一文档或相邻段落中出现同一概念使用不同术语描述（如\"周期执行的任务\"和\"周期任务\"），或存在与参考句子/上下文已确立的术语（如\"周期任务\"）不一致的表达方式时触发。"
    },
    {
      "defect_id": 535738,
      "sentence": "SequenceRunner的构造函数。构造一个全局串行队列，如果名字相同，将返回同一个串行队列。",
      "reference_sentence": "SequenceRunner的构造函数。",
      "line_num": 2158,
      "context": "{\"2153\":\"\",\"2154\":\"### constructor<sup>12+</sup>\",\"2155\":\"\",\"2156\":\"constructor(name: string, priority?: Priority)\",\"2157\":\"\",\"2158\":\"SequenceRunner的构造函数。构造一个全局串行队列，如果名字相同，将返回同一个串行队列。\",\"2159\":\"\",\"2160\":\"> **说明：**\",\"2161\":\">\",\"2162\":\"> - 底层通过单例模式保证了：创建同名串行队列时，获取到同一个实例。\",\"2163\":\"> - 不支持修改串行队列的优先级。\"}",
      "修改建议": "混用了“构造函数”和“构造函数。构造一个全局串行队列，如果名字相同，将返回同一个串行队列。”描述，导致表意不一致。",
      "更改后示例": "SequenceRunner的构造函数，用于构造一个全局串行队列。如果名字相同，将返回同一个串行队列。",
      "触发条件": "同一段落或相邻句子中对同一术语或概念存在结构断裂（如独立句与从句混用）或术语不一致（如重复使用不同动词描述同一功能）。识别模式为检查是否在解释同一对象时出现句间逻辑连接缺失或主谓结构突变。"
    },
    {
      "defect_id": 535776,
      "sentence": "指定任务执行的最大并发度，该参数应为正整数，负数时报错，输入非整数时会向下取整。",
      "reference_sentence": "指定任务执行的最大并发度，该参数应为正整数。负数时报错，非整数会向下取整。",
      "line_num": 2286,
      "context": "{\"2281\":\"\",\"2282\":\"**参数：**\",\"2283\":\"\",\"2284\":\"| 参数名   | 类型                  | 必填 | 说明                                                       |\",\"2285\":\"| -------- | --------------------- | ---- | ---------------------------------------------------------- |\",\"2286\":\"| runningCapacity | number | 是   | 指定任务执行的最大并发度，该参数应为正整数，负数时报错，输入非整数时会向下取整。 |\",\"2287\":\"| waitingCapacity | number | 否   | 指定等待任务的列表容量，取值需大于等于0，负数时报错，输入非整数时会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。 |\",\"2288\":\"\",\"2289\":\"**错误码：**\",\"2290\":\"\",\"2291\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\"}",
      "修改建议": "混用了'输入非整数'和'非整数'描述同一概念。",
      "更改后示例": "指定任务执行的最大并发度，该参数应为正整数，负数时报错，非整数时会向下取整。",
      "触发条件": "同一参数说明或相邻条目中存在对相同类型数值（如非整数）使用不同修饰词（如\"输入非整数\"与\"非整数\"）的不一致表述时。\n\n识别模式：\n1. 检查同一参数/相邻参数的数值类型描述结构（是否包含\"输入\"等动词前缀）\n2. 对比相邻错误处理条款中同类数值的表述方式（如\"负数时\"与\"非整数时\"的语法结构匹配度）\n3. 验证同一概念是否在相同上下文出现不同限定词（如\"输入非整数\"与纯\"非整数\"的表述差异）"
    },
    {
      "defect_id": 535813,
      "sentence": "当前线程的优先级。返回为空时，代表没有任务执行。",
      "reference_sentence": "任务执行至当前所用的时间，单位为ms。当返回为0时，表示任务未执行；返回为空时，表示没有任务执行。",
      "line_num": 2466,
      "context": "{\"2461\":\"\",\"2462\":\"| 名称     | 类型                    | 只读 | 可选 | 说明                                                      |\",\"2463\":\"| -------- | ---------------------- | ---- | ---- | -------------------------------------------------------- |\",\"2464\":\"| tid      | number                 | 是   | 否   | 工作线程的标识符。返回为空时，代表没有任务执行。              |\",\"2465\":\"| taskIds  | number[]               | 是   | 否   | 在当前线程上运行的任务id列表。返回为空时，代表没有任务执行。   |\",\"2466\":\"| priority | [Priority](#priority)  | 是   | 否   | 当前线程的优先级。返回为空时，代表没有任务执行。              |\",\"2467\":\"\",\"2468\":\"## TaskPoolInfo<sup>10+</sup>\",\"2469\":\"\",\"2470\":\"任务池的内部信息。\",\"2471\":\"\"}",
      "修改建议": "混用了'返回为空时，代表没有任务执行'和'返回为空时，表示没有任务执行'，用词不一致",
      "更改后示例": "当前线程的优先级。返回为空时，表示没有任务执行。",
      "触发条件": "同一文档相邻条目中出现相同语义但使用不同动词（如\"代表\"和\"表示\"）描述相同逻辑关系，且存在已定义的规范用词（如参考句中的\"表示\"）。\n\n识别模式：\n1. 在结构化内容（如表格）的连续条目中检测相同句式结构\n2. 定位关键逻辑词（如\"返回为空时\"后的动词）\n3. 对比相邻条目中的对应动词是否一致\n4. 对照参考句验证规范用词\n5. 发现同一语义场景存在两种以上表达方式时触发规则"
    },
    {
      "defect_id": 535739,
      "sentence": "串行队列不能执行任务组任务、其他串行队列任务、异步队列任务、有依赖关系的任务和已执行的任务。",
      "reference_sentence": "任务组不能添加其他任务组任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。",
      "line_num": 2194,
      "context": "{\"2189\":\"\",\"2190\":\"### execute<sup>11+</sup>\",\"2191\":\"\",\"2192\":\"execute(task: Task): Promise\\\\<Object>\",\"2193\":\"\",\"2194\":\"执行串行任务。使用该方法前需先构造SequenceRunner。串行队列不能执行任务组任务、其他串行队列任务、异步队列任务、有依赖关系的任务和已执行的任务。\",\"2195\":\"\",\"2196\":\"> **说明：**\",\"2197\":\">\",\"2198\":\"> - 不支持加入存在依赖的任务。\",\"2199\":\"> - 前面的任务执行失败或取消不影响后续任务执行。\"}",
      "修改建议": "前后描述不一致，前文提到任务组不能添加特定类型的任务，后文又提到串行队列不能执行特定类型的任务。",
      "更改后示例": "串行队列不能执行任务组任务、其他串行队列任务、异步队列任务或有依赖关系的任务，也不能执行已执行的任务。",
      "触发条件": "当同一段落或相邻上下文中存在多个并列限制条件，但连接词（\"和\"/\"或\"）使用不统一，或同类语义表达出现结构不一致（如混合使用并列连接词与补充说明句式）时触发。"
    },
    {
      "defect_id": 535417,
      "sentence": "延时执行任务。当前执行模式可以设置任务优先级和尝试调用cancel进行任务取消。该任务不可以是任务组任务、串行队列任务、异步队列任务和周期任务。若该任务非长时任务，可以多次调用executeDelayed执行，长时任务仅支持执行一次。",
      "reference_sentence": "校验并发函数的参数类型和返回类型后，将创建好的泛型任务放入taskpool内部任务队列。",
      "line_num": 321,
      "context": "{\"316\":\"\",\"317\":\"## taskpool.executeDelayed<sup>11+</sup>\",\"318\":\"\",\"319\":\"executeDelayed(delayTime: number, task: Task, priority?: Priority): Promise\\\\<Object>\",\"320\":\"\",\"321\":\"延时执行任务。当前执行模式可以设置任务优先级和尝试调用cancel进行任务取消。该任务不可以是任务组任务、串行队列任务、异步队列任务和周期任务。若该任务非长时任务，可以多次调用executeDelayed执行，长时任务仅支持执行一次。\",\"322\":\"\",\"323\":\"**系统能力：** SystemCapability.Utils.Lang\",\"324\":\"\",\"325\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"326\":\"\"}",
      "修改建议": "描述不一致",
      "更改后示例": "延时执行任务。当前执行模式可以设置任务优先级，并且可以尝试调用cancel取消任务。该任务不能是任务组任务、串行队列任务、异步队列任务或周期任务。如果该任务不是长时任务，可以多次调用executeDelayed执行；长时任务仅支持执行一次。",
      "触发条件": "同一段落或相邻句子中存在连接词（如“和”/“或”）、否定词（如“不可以”/“不能”）、条件词（如“若”/“如果”）混用，或句式结构（如“进行任务取消”/“取消任务”）不统一时触发。\n\n识别模式：\n1. **并列结构不一致**：检查并列成分是否使用相同逻辑连接词（如“和”与“并且”冲突）；\n2. **否定/条件表达差异**：识别否定词（不可/不能）、条件词（若/如果）是否与上下文或参考句子的用词标准一致；\n3. **动宾结构冗余**：检测“进行+名词化动作”（如“进行任务取消”）是否可简化为直接动词结构（如“取消任务”）。"
    },
    {
      "defect_id": 535561,
      "sentence": "Task的构造函数，可以指定任务名称。",
      "reference_sentence": "Task表示任务。任务可以多次执行或放入任务组执行或放入串行队列执行或放入异步队列执行或添加依赖关系执行。",
      "line_num": 1011,
      "context": "{\"1006\":\"\",\"1007\":\"### constructor<sup>11+</sup>\",\"1008\":\"\",\"1009\":\"constructor(name: string, func: Function, ...args: Object[])\",\"1010\":\"\",\"1011\":\"Task的构造函数，可以指定任务名称。\",\"1012\":\"\",\"1013\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1014\":\"\",\"1015\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1016\":\"\"}",
      "修改建议": "混用了“构造函数”和“构造方法”概念，应保持一致。",
      "更改后示例": "Task的构造方法，可以指定任务名称。",
      "触发条件": "当同一技术概念在邻近上下文中出现术语混用（如\"构造函数\"与\"构造方法\"），且存在文档内已确立的标准术语（如参考句中的\"方法\"统一用法）时触发。\n\n识别模式：通过比对同一章节/API描述中核心技术术语的一致性（如构造相关术语），检测是否存在与上下文既定用词（如\"构造方法\"）或参考句式（如\"xx方法\"）相冲突的同义词（如\"构造函数\"）。"
    },
    {
      "defect_id": 535778,
      "sentence": " 指定等待任务的列表容量，取值需大于等于0，负数时报错，输入非整数时会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。",
      "reference_sentence": "指定等待任务的列表容量，取值需大于等于0，负数时报错，输入非整数时会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。",
      "line_num": 2324,
      "context": "{\"2319\":\"\",\"2320\":\"| 参数名   | 类型                  | 必填 | 说明                                                       |\",\"2321\":\"| -------- | --------------------- | ---- | ---------------------------------------------------------- |\",\"2322\":\"| name     | string                | 是   | 异步队列的名字。 |\",\"2323\":\"| runningCapacity | number | 是   | 指定任务执行的最大并发度，该参数应为正整数。负数时报错，非整数会向下取整。 |\",\"2324\":\"| waitingCapacity | number | 否   |  指定等待任务的列表容量，取值需大于等于0，负数时报错，输入非整数时会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。 |\",\"2325\":\"\",\"2326\":\"**错误码：**\",\"2327\":\"\",\"2328\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"2329\":\"\"}",
      "修改建议": "混用了'输入非整数'和'非整数'描述同一概念。",
      "更改后示例": "指定等待任务的列表容量，取值需大于等于0，负数时报错，非整数输入会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。",
      "触发条件": "同一参数说明中存在对同一概念使用不同术语（如\"输入非整数\"和\"非整数输入\"），或相邻参数描述（如runningCapacity参数说明）已建立固定表达模式时。\n\n识别模式：\n1. 对比相邻参数项的平行描述结构（如runningCapacity的\"非整数\"表达）\n2. 检测同一句子内对同一操作对象使用不同修饰结构（主动/被动语态转换）\n3. 检查是否在相同语义场景下混用带/不带动作主体的描述（如是否保留\"输入\"前缀）"
    },
    {
      "defect_id": 538075,
      "sentence": "makeObserved可以在ArkUI中导入可观察的colletions容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。",
      "reference_sentence": "makeObserved可以在ArkUI中导入可观察的collections容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。",
      "line_num": 247,
      "context": "{\"242\":\"### makeObserved和collections.Array/Set/Map配合使用\",\"243\":\"\",\"244\":\"**该场景仅适用于ArkTS1.1。**\",\"245\":\"\",\"246\":\"collections提供ArkTS容器集，可用于并发场景下的高性能数据传递。详情见[@arkts.collections文档](../reference/apis-arkts/js-apis-arkts-collections.md)。\",\"247\":\"makeObserved可以在ArkUI中导入可观察的colletions容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。\",\"248\":\"\",\"249\":\"#### collections.Array\",\"250\":\"collections.Array可以触发UI刷新的API有：\",\"251\":\"- 改变数组长度：push、pop、shift、unshift、splice、shrinkTo、extendTo\",\"252\":\"- 改变数组项本身：sort、fill\"}",
      "修改建议": "混用了“colletions”和“collections”",
      "更改后示例": "makeObserved可以在ArkUI中导入可观察的collections容器，但makeObserved不能和状态管理V1的状态变量装饰器如@State和@Prop等配合使用，否则会抛出运行时异常。",
      "触发条件": "当同一术语在相邻段落或同一上下文范围内出现拼写不一致（例如\"colletions\"与\"collections\"混用），且存在正确拼写的参考基准时触发该规则。识别需检测术语重复出现时的形态差异，并匹配预定义术语库进行拼写验证。"
    },
    {
      "defect_id": 536029,
      "sentence": "好的标识符命名应遵循以下原则：\r- 能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名\r - 使用正确的英文单词并符合英文语法，不要使用中文拼音\r - 能区分出意思，避免造成误导",
      "reference_sentence": "无",
      "line_num": 49,
      "context": "{\"44\":\"### 为标识符取一个好名字，提高代码可读性\",\"45\":\"\",\"46\":\"**【描述】**\",\"47\":\"\",\"48\":\"好的标识符命名应遵循以下原则：\",\"49\":\" - 能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名\",\"50\":\" - 使用正确的英文单词并符合英文语法，不要使用中文拼音\",\"51\":\" - 能区分出意思，避免造成误导\",\"52\":\"\",\"53\":\"### 类名、枚举名、命名空间名采用UpperCamelCase风格\",\"54\":\"\"}",
      "修改建议": "“未成惯例的缩写”与“未形成惯例的缩写”用词不一致",
      "更改后示例": "好的标识符命名应遵循以下原则：\r- 能清晰的表达意图，避免使用单个字母、未形成惯例的缩写来命名\r- 使用正确的英文单词并符合英文语法，不要使用中文拼音\r- 能区分出意思，避免造成误导",
      "触发条件": "当同一文档中相邻的并列条目出现相同语义但用词不一致的动词短语（如\"未成惯例\"与\"未形成惯例\"），且条目采用完全相同的句式结构时触发。\n\n识别模式：\n1. 检查编号/项目符号列表中的并列条目\n2. 匹配\"能...，避免...\"的固定句式结构\n3. 对比动词短语成分（特别是四字短语中的动词使用）\n4. 识别同一语义下不同形态的动词（如\"成\"与\"形成\"）"
    },
    {
      "defect_id": 535775,
      "sentence": "AsyncRunner的构造函数。构造一个非全局的异步队列，如果参数相同，返回的是不同的异步队列。",
      "reference_sentence": "SequenceRunner的构造函数。构造一个全局串行队列，如果名字相同，将返回同一个串行队列。",
      "line_num": 2276,
      "context": "{\"2271\":\"\",\"2272\":\"### constructor<sup>18+</sup>\",\"2273\":\"\",\"2274\":\"constructor(runningCapacity: number, waitingCapacity?: number)\",\"2275\":\"\",\"2276\":\"AsyncRunner的构造函数。构造一个非全局的异步队列，如果参数相同，返回的是不同的异步队列。\",\"2277\":\"\",\"2278\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2279\":\"\",\"2280\":\"**原子化服务API**：从API version 18开始，该接口支持在原子化服务中使用。\",\"2281\":\"\"}",
      "修改建议": "混用了'全局'和'非全局'概念，以及'返回'与'返回的是'不一致。",
      "更改后示例": "AsyncRunner的构造函数。构造一个非全局的异步队列，即使参数相同，返回的也是不同的异步队列。",
      "触发条件": "当文档中同时存在\"全局\"和\"非全局\"队列构造描述时，若条件句式（\"如果\"/\"即使\"）与返回结果（\"返回的是\"/\"返回的也是\"）存在结构不一致，或同一功能模块出现混合表达（如\"返回\"与\"返回的是\"交替使用），则应触发该规则。\n\n识别模式：\n1. 检测\"构造[全局/非全局]队列\"的关键词组合\n2. 匹配条件从句结构（\"如果参数相同\"/\"即使参数相同\"）\n3. 验证结果动词短语一致性（\"返回的是\"/\"返回的也是\"）\n4. 对比同类型接口描述（如SequenceRunner的全局队列描述）的句式结构"
    },
    {
      "defect_id": 538070,
      "sentence": "### makeObserved仅对入参生效，不会改变接受返回值的观察能力",
      "reference_sentence": "### makeObserved仅对入参生效，不会改变接收返回值的观察能力",
      "line_num": 106,
      "context": "{\"101\":\"          })\",\"102\":\"      }\",\"103\":\"    }\",\"104\":\"  }\",\"105\":\"  ```\",\"106\":\"### makeObserved仅对入参生效，不会改变接受返回值的观察能力\",\"107\":\"\",\"108\":\"该条件适用于ArkTS1.1：\",\"109\":\"\",\"110\":\" - `message`被@Local装饰，本身具有观察自身赋值的能力。其初始值为makeObserved的返回值，具有深度观察能力。\",\"111\":\" - 点击`change id`可以触发UI刷新。\"}",
      "修改建议": "混用了“接受”和“接收”",
      "更改后示例": "### makeObserved仅对入参生效，不会改变接收返回值的观察能力",
      "触发条件": "当文档中同一技术术语或动词（如“接收”与“接受”）在描述相同操作时出现混用，且上下文明确指向数据传递行为（如参数/返回值处理）时触发。需通过同音词/近义词匹配及技术场景语义分析识别。"
    },
    {
      "defect_id": 536051,
      "sentence": "在`finally`代码块中，直接使用`return`、`break`、`continue`、`throw`语句或调用方法时未处理异常，会导致`finally`代码块无法正常结束。`finally`代码块非正常结束会影响`try`或`catch`代码块中异常的抛出，也可能影响方法的返回值。因此，必须确保`finally`代码块正常结束。",
      "reference_sentence": "在`finally`代码块中，直接使用`return`、`break`、`continue`、`throw`语句或调用方法时未处理异常，会导致`finally`代码块无法正常结束。`finally`代码块非正常结束会影响`try`或`catch`代码块中异常的抛出，也可能影响方法的返回值。因此，必须确保`finally`代码块正常结束。",
      "line_num": 719,
      "context": "{\"714\":\"\",\"715\":\"**【级别】要求**\",\"716\":\"\",\"717\":\"**【描述】**\",\"718\":\"\",\"719\":\"在`finally`代码块中，直接使用`return`、`break`、`continue`、`throw`语句或调用方法时未处理异常，会导致`finally`代码块无法正常结束。`finally`代码块非正常结束会影响`try`或`catch`代码块中异常的抛出，也可能影响方法的返回值。因此，必须确保`finally`代码块正常结束。\",\"720\":\"\",\"721\":\"**【反例】**\",\"722\":\"\",\"723\":\"```\",\"724\":\"function foo() {\"}",
      "修改建议": "句子中的“非正常结束”可以更明确地表述为“异常结束”，以提高一致性。",
      "更改后示例": "在`finally`代码块中，直接使用`return`、`break`、`continue`、`throw`语句或调用方法时未处理异常，会导致`finally`代码块无法正常结束。`finally`代码块异常结束会影响`try`或`catch`代码块中异常的抛出，也可能影响方法的返回值。因此，必须确保`finally`代码块正常结束。",
      "触发条件": "同一技术术语在相邻段落或同一规则描述中出现两种及以上不同表述形式（如\"非正常结束\"和\"异常结束\"），且存在已定义的规范术语时。\n\n识别模式：\n1. 检测重复出现的核心概念存在词汇变体（如\"非正常\"/\"异常\"+\"结束\"）\n2. 对比上下文已明确定义的术语（如后文使用\"正常结束\"时，前文应保持\"异常结束\"的对应表述）\n3. 确认术语对存在逻辑关联性（如\"正常结束\"与\"异常结束\"构成完整状态集合）"
    },
    {
      "defect_id": 536103,
      "sentence": "尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能将会导致程序编译失败。",
      "reference_sentence": "尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能会导致程序编译失败。",
      "line_num": 30,
      "context": "{\"25\":\"**级别**\",\"26\":\"\",\"27\":\"约束分为两个级别：错误、警告。\",\"28\":\"\",\"29\":\"- **错误**: 必须要遵从的约束。如果不遵从该约束，将会导致程序编译失败。 \",\"30\":\"- **警告**: 推荐遵从的约束。尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能将会导致程序编译失败。\",\"31\":\"\",\"32\":\"**不支持的特性**\",\"33\":\"\",\"34\":\"目前，不支持的特性主要包括：\",\"35\":\"\"}",
      "修改建议": "重复使用“将会”导致句式冗余，建议使用“可能”替换一个“将会”。",
      "更改后示例": "尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能会导致程序编译失败。",
      "触发条件": "当句子中同时出现\"可能\"和\"将会\"等双重未来时态表述，且上下文存在相同语义的单一表述（如\"可能会导致\"）时触发。\n\n识别模式：\n1. 检测相邻或同句内是否同时包含可能性副词（可能/或许）和确定性未来时态动词（将/将会）\n2. 交叉验证上下文是否存在相同语义但更简洁的表达方式（如参考句中的\"可能会导致\"）\n3. 检查是否存在语义重复（如\"可能\"已含不确定性，\"将会\"的确定性表述与之冲突）"
    },
    {
      "defect_id": 536030,
      "sentence": "布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。",
      "reference_sentence": "无",
      "line_num": 150,
      "context": "{\"145\":\"\",\"146\":\"**【级别】建议**\",\"147\":\"\",\"148\":\"**【描述】**\",\"149\":\"\",\"150\":\"布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。\",\"151\":\"\",\"152\":\"**【反例】**\",\"153\":\"\",\"154\":\"```\",\"155\":\"let isNoError = true;\"}",
      "修改建议": "“建议”与“建议加上”用词不一致，且“不是很好理解”与“难以理解”用词不一致",
      "更改后示例": "布尔型的局部变量建议加上表达是非意义的前缀，比如 is，也可以是 has、can、should 等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如 !isNotError，难以理解。因此，应避免定义否定的布尔变量名。",
      "触发条件": "同一段落内出现重复动词结构缺失（如\"建议\"与\"建议加上\"）或同义表达不一致（如\"不是很好理解\"与\"难以理解\"）时触发。\n\n识别模式：\n1. 动词结构不完整重复：前句使用\"动词+宾语\"结构（建议加上），后句相同语境仅保留动词（建议）\n2. 同义形容词短语混用：针对相同语义（理解难度）使用不同强度/结构的表达（\"不是很好理解\"与\"难以理解\"）\n3. 相邻句子存在语义重复场景，但关键术语未保持统一表达形式"
    },
    {
      "defect_id": 536049,
      "sentence": "对于数组的遍历处理，应该优先使用Array对象方法，如：`forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()`。",
      "reference_sentence": "对于数组的遍历处理，应该优先使用Array对象方法，如：`forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()`。",
      "line_num": 665,
      "context": "{\"660\":\"\",\"661\":\"**【级别】要求**\",\"662\":\"\",\"663\":\"**【描述】**\",\"664\":\"\",\"665\":\"对于数组的遍历处理，应该优先使用Array对象方法，如：`forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()`。\",\"666\":\"\",\"667\":\"**【反例】**\",\"668\":\"\",\"669\":\"```\",\"670\":\"const numbers = [1, 2, 3, 4, 5];\"}",
      "修改建议": "句子中的“数组的遍历处理”可以更明确地表述为“数组遍历”，以提高一致性。",
      "更改后示例": "对于数组遍历，应该优先使用Array对象方法，如：`forEach(), map(), every(), filter(), find(), findIndex(), reduce(), some()`。",
      "触发条件": "检测到同一术语存在冗余修饰（如\"的遍历处理\"）且文档中存在更简洁的标准表达（如\"数组遍历\"）时触发；当相邻上下文显示同类表述存在统一表达模式时触发。\n\n识别模式：通过对比文档中相似语义结构的表达差异（如\"数组的遍历处理\" vs \"数组遍历\"），结合术语在全文的使用频率，识别冗余修饰词（如\"的\"+\"处理\"）与核心名词（\"遍历\"）的不必要组合，匹配已有规范表达进行替换建议。"
    },
    {
      "defect_id": 537631,
      "sentence": "设置web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如js运行上下文、渲染上下文等等，默认值：普通模式（NORMAL_MODE）由系统决定合适的销毁时机，应用可以设置快速模式（FAST_MODE）立即销毁资源，提升部分场景的性能。",
      "reference_sentence": "设置web组件的销毁模式。",
      "line_num": 9764,
      "context": "{\"9759\":\"\",\"9760\":\"## setWebDestroyMode<sup>20+</sup>\",\"9761\":\"\",\"9762\":\"setWebDestroyMode(mode: WebDestroyMode): void\",\"9763\":\"\",\"9764\":\"设置web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如js运行上下文、渲染上下文等等，默认值：普通模式（NORMAL_MODE）由系统决定合适的销毁时机，应用可以设置快速模式（FAST_MODE）立即销毁资源，提升部分场景的性能。\",\"9765\":\"\",\"9766\":\"> **说明：**\",\"9767\":\">\",\"9768\":\"> 快速模式（FAST_MODE）会改变web组件销毁时机，应用需要关注代码中依赖web组件销毁时机的错误实现，例如：web组件下树销毁后仍调用WebviewController这种未定义行为，对比普通模式（NORMAL_MODE），因为销毁时机提前了，有更高的几率触发未关联绑定的异常（17100001），建议应用捕捉异常，或者通过[getAttachState](#getattachstate20)查询是否绑定状态，来避免稳定性问题。\",\"9769\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一事物，如'普通模式'和'快速模式'与'NORMAL_MODE'和'FAST_MODE'混用。",
      "更改后示例": "设置web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如JS运行上下文、渲染上下文等等，默认值：NORMAL_MODE（普通模式），由系统决定合适的销毁时机，应用可以设置FAST_MODE（快速模式）立即销毁资源，提升部分场景的性能。",
      "触发条件": "同一术语存在中英文混用且格式不一致（如\"普通模式（NORMAL_MODE）\"与\"快速模式（FAST_MODE）\"交替出现时），或同一概念采用不同词汇表达（如\"普通模式\"与\"NORMAL_MODE\"未保持固定对应关系）。\n\n识别模式：检测括号内外/术语对是否存在非对称映射（中文在前英文在后 vs 英文在前中文在后），以及同一技术概念是否使用超过两种及以上不同表达形式（如混合使用全称、简称、代码常量等）。"
    },
    {
      "defect_id": 536082,
      "sentence": "## 支持与TS/JS的交互",
      "reference_sentence": "## 程序稳定性动态类型语言如JavaScript（简称JS）虽能提升开发效率，但也容易在运行时引发非预期错误。",
      "line_num": 141,
      "context": "{\"136\":\"根据工程的compatibleSdkVersion，具体策略如下：\",\"137\":\"\",\"138\":\"  - compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。\",\"139\":\"  - compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。\",\"140\":\"\",\"141\":\"## 支持与TS/JS的交互\",\"142\":\"\",\"143\":\"ArkTS支持与TS/JS的高效互操作。在当前版本中，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互时，将TS/JS的数据和对象作为ArkTS的数据和对象使用，可能会绕过ArkTS的静态编译检查，导致非预期的行为或增加额外的开销。\",\"144\":\"\",\"145\":\"```typescript\",\"146\":\"// lib.ts\"}",
      "修改建议": "标题不一致，应与原文风格保持一致",
      "更改后示例": "### 支持与TS/JS的交互",
      "触发条件": "当检测到标题层级（如##/###）与上下文中的同级标题或父级章节结构存在级别差异，且不符合文档现有标题序列规范时触发。  \n\n识别模式：通过分析当前标题的Markdown标记级别（#数量）与上下文相邻标题的层级关系，判断是否破坏章节嵌套逻辑（例如父级为二级标题时子标题应为三级），或与同层级标题群组的标记级别产生冲突。"
    },
    {
      "defect_id": 539414,
      "sentence": "语法：ctx.font='font-style&nbsp;font-weight&nbsp;font-size&nbsp;font-family'",
      "reference_sentence": "可选值为：- 'butt'：线端点以方形结束。- 'round'：线端点以圆形结束。- 'square'：线端点以方形结束，该样式下会增加一个长度和线段厚度相同，宽度是线段厚度一半的矩形。默认值：'butt'",
      "line_num": 44,
      "context": "{\"39\":\"| [lineWidth](#linewidth)                  | number                                   | 否 | 否 | 设置绘制线条的宽度。<br/>默认值：1(px)<br/>默认单位：vp<br/>linewidth取值不支持0和负数，0和负数按异常值处理，异常值按默认值处理。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| [strokeStyle](#strokestyle)              | string&nbsp;\\\\|number<sup>10+</sup>&nbsp;\\\\|[CanvasGradient](ts-components-canvas-canvasgradient.md)&nbsp;\\\\|&nbsp;[CanvasPattern](ts-components-canvas-canvaspattern.md) | 否 | 否 | 设置线条的颜色。<br/>-&nbsp;类型为string时，表示设置线条使用的颜色，颜色格式参考[ResourceColor](ts-types.md#resourcecolor)中string类型说明。<br/>默认值：'#000000'<br/>- 类型为number时，表示设置线条使用的颜色，不支持设置全透明色，颜色格式参考[ResourceColor](ts-types.md#resourcecolor)中number类型说明。<br/>默认值：0x000000<br/>-&nbsp;类型为CanvasGradient时，表示渐变对象，使用[createLinearGradient](#createlineargradient)方法创建。<br/>-&nbsp;类型为CanvasPattern时，使用[createPattern](#createpattern)方法创建。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| [lineCap](#linecap) | [CanvasLineCap](ts-canvasrenderingcontext2d.md#canvaslinecap类型说明) | 否 | 否 | 指定线端点的样式，可选值为：<br/>-&nbsp;'butt'：线端点以方形结束。<br/>-&nbsp;'round'：线端点以圆形结束。<br/>-&nbsp;'square'：线端点以方形结束，该样式下会增加一个长度和线段厚度相同，宽度是线段厚度一半的矩形。<br/>默认值：'butt'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| [lineJoin](#linejoin) | [CanvasLineJoin](ts-canvasrenderingcontext2d.md#canvaslinejoin类型说明) | 否 | 否 | 指定线段间相交的交点样式，可选值为：<br/>-&nbsp;'round'：在线段相连处绘制一个扇形，扇形的圆角半径是线段的宽度。<br/>-&nbsp;'bevel'：在线段相连处使用三角形为底填充，&nbsp;每个部分矩形拐角独立。<br/>-&nbsp;'miter'：在相连部分的外边缘处进行延伸，使其相交于一点，形成一个菱形区域，该属性可以通过设置miterLimit属性展现效果。<br/>默认值：'miter'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| [miterLimit](#miterlimit) | number | 否 | 否 | 设置斜接面限制值，该值指定了线条相交处内角和外角的距离。  <br/>默认值：10px<br/>单位：px。 <br/>miterLimit取值不支持0和负数，0和负数按异常值处理，异常值按默认值处理。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| [font](#font) | string | 否 | 否 | 设置文本绘制中的字体样式。<br/>语法：ctx.font='font-style&nbsp;font-weight&nbsp;font-size&nbsp;font-family'<br/>-&nbsp;font-style(可选)，用于指定字体样式，支持如下几种样式：'normal','italic'。<br/>-&nbsp;font-weight(可选)，用于指定字体的粗细，支持如下几种类型：'normal',&nbsp;'bold',&nbsp;'bolder',&nbsp;'lighter',&nbsp;100,&nbsp;200,&nbsp;300,&nbsp;400,&nbsp;500,&nbsp;600,&nbsp;700,&nbsp;800,&nbsp;900。<br/>-&nbsp;font-size(可选)，指定字号和行高，单位支持px、vp。使用时需要添加单位。<br/>-&nbsp;font-family(可选)，指定字体系列，支持如下几种类型：'sans-serif',&nbsp;'serif',&nbsp;'monospace'。API version 20及以后支持注册过的自定义字体（只能在主线程使用，不支持在worker线程中使用；DevEco Studio的预览器不支持显示自定义字体），具体使用方法参考自定义字体[font](#font)示例。<br/>默认值：'normal normal 14px sans-serif'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| [textAlign](#textalign) | [CanvasTextAlign](ts-canvasrenderingcontext2d.md#canvastextalign类型说明) | 否 | 否 | 设置文本绘制中的文本对齐方式，可选值为：<br/>-&nbsp;'left'：文本左对齐。<br/>-&nbsp;'right'：文本右对齐。<br/>-&nbsp;'center'：文本居中对齐。<br/>-&nbsp;'start'：文本对齐界线开始的地方。<br/>-&nbsp;'end'：文本对齐界线结束的地方。<br/>> **说明：**<br/>>&nbsp;ltr布局模式下'start'和'left'一致，rtl布局模式下'start'和'right'一致。<br/>默认值：'left'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| [textBaseline](#textbaseline)            | [CanvasTextBaseline](ts-canvasrenderingcontext2d.md#canvastextbaseline类型说明) | 否 | 否 | 设置文本绘制中的水平对齐方式，可选值为：<br/>-&nbsp;'alphabetic'：文本基线是标准的字母基线。<br/>-&nbsp;'top'：文本基线在文本块的顶部。<br/>-&nbsp;'hanging'：文本基线是悬挂基线。<br/>-&nbsp;'middle'：文本基线在文本块的中间。<br/>-&nbsp;'ideographic'：文字基线是表意字基线；如果字符本身超出了alphabetic基线，那么ideograhpic基线位置在字符本身的底部。<br/>-&nbsp;'bottom'：文本基线在文本块的底部。&nbsp;与ideographic基线的区别在于ideographic基线不需要考虑下行字母。<br/>默认值：'alphabetic'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| [globalAlpha](#globalalpha) | number | 否 | 否 | 设置透明度，范围为[0.0, 1.0]，0.0为完全透明，1.0为完全不透明。若给定值小于0.0，则取值0.0；若给定值大于1.0，则取值1.0.<br/>默认值：1.0<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| [lineDashOffset](#linedashoffset) | number | 否 | 否 | 设置画布的虚线偏移量，精度为float。    <br/>默认值：0.0<br/>单位：vp。<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"49\":\"| [globalCompositeOperation](#globalcompositeoperation) | string | 否 | 否 | 设置合成操作的方式。类型字段可选值有'source-over'，'source-atop'，'source-in'，'source-out'，'destination-over'，'destination-atop'，'destination-in'，'destination-out'，'lighter'，'copy'，'xor'。<br/>-&nbsp;默认值：'source-over'<br/>**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。<br/>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "修改建议": "句式不一致，应使用相同句式以保持文档风格的一致性。",
      "更改后示例": "语法：ctx.font = 'font-style font-weight font-size font-family'",
      "触发条件": "当同一文档中存在多个语法说明句式时，若出现符号使用不一致（如HTML实体&nbsp;与普通空格混用）或赋值格式差异（如等号两侧空格缺失），且上下文存在相同语义结构的标准句式时触发。"
    },
    {
      "defect_id": 538306,
      "sentence": "Register the audio and haptic files represented by fd into the manager. The audio and haptic effects play in sync.",
      "reference_sentence": "Register the audio and haptic files represented by fd into the manager. The audio and haptic effects play in sync.",
      "line_num": 124,
      "context": "{\"119\":\"\",\"120\":\"### registerSourceFromFd\",\"121\":\"\",\"122\":\"registerSourceFromFd(audioFd: AudioHapticFileDescriptor, hapticFd: AudioHapticFileDescriptor): Promise&lt;number&gt;\",\"123\":\"\",\"124\":\"Register the audio and haptic files represented by fd into the manager. The audio and haptic effects play in sync.\",\"125\":\"After registering the source, this method returns the source ID using a promise.\",\"126\":\"\",\"127\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"128\":\"\",\"129\":\"**Parameters**\"}",
      "修改建议": "句式不一致，建议统一使用祈使句",
      "更改后示例": "Register the audio and haptic files represented by fd into the manager. Ensure the audio and haptic effects play in sync.",
      "触发条件": "当相邻或同一段落中的操作说明性语句出现句式结构不一致（如祈使句与陈述句混用），且上下文属于指令性内容时触发。\n\n识别模式：\n1. 检测连续句子中动词形态差异：首句为无主语的祈使结构（如\"Register...\"），后续句子转为陈述结构（如\"The effects play...\"）\n2. 分析语义关联性：后句内容与前句构成操作步骤的延续关系，而非单纯的事实陈述\n3. 上下文验证：出现在API参数说明、方法使用指引等需要保持指令连续性的技术文档段落中"
    },
    {
      "defect_id": 537805,
      "sentence": "Web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如js运行上下文、渲染上下文等等。",
      "reference_sentence": "Web组件的销毁模式，当Web组件下树析构时，销毁模式会影响Web内核的资源释放时机，例如JS运行上下文、渲染上下文等等。",
      "line_num": 330,
      "context": "{\"325\":\"| MATCH_HTTP        | 1 |HTTP请求会使用代理。|\",\"326\":\"| MATCH_HTTPS       | 2 |HTTPS请求会使用代理。|\",\"327\":\"\",\"328\":\"## WebDestroyMode<sup>20+</sup>\",\"329\":\"\",\"330\":\"Web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如js运行上下文、渲染上下文等等。\",\"331\":\"\",\"332\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"333\":\"\",\"334\":\"| 名称 | 值 | 说明 |\",\"335\":\"| ------------------------------- | - | ---------- |\"}",
      "修改建议": "混用了'web'和'Web'、'js'和'JS'大小写不一致",
      "更改后示例": "Web组件的销毁模式，当Web组件下树析构时，销毁模式会影响Web内核的资源释放时机，例如JS运行上下文、渲染上下文等等。",
      "触发条件": "同一术语或缩写词在文档中出现大小写混用（如\"web/Web\"、\"js/JS\"），且上下文存在统一大写格式的参考实例时触发。\n\n识别模式：\n1. 检测到同一词汇存在大小写变体（通过词形匹配+大小写敏感比对）\n2. 在相邻段落或同类型说明项（如参考句子中的HTTP/HTTPS全大写）中已建立大写规范\n3. 涉及技术专有名词（Web组件、JS引擎）或标准缩写（HTTP/JS）时优先触发"
    },
    {
      "defect_id": 538315,
      "sentence": "Call this API before releasing the player, setting it only once per playback.",
      "reference_sentence": "Call this API before the player starts or after it stops but before it is released.",
      "line_num": 669,
      "context": "{\"664\":\"### setHapticsIntensity\",\"665\":\"\",\"666\":\"setHapticsIntensity(intensity: number): Promise&lt;void&gt;\",\"667\":\"\",\"668\":\"Sets the haptics intensity for this player, using a promise to return the result.\",\"669\":\"Call this API before releasing the player, setting it only once per playback.\",\"670\":\"\",\"671\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"672\":\"\",\"673\":\"**Parameters**\",\"674\":\"\"}",
      "修改建议": "混用了'releasing the player'和'released'的概念，导致前后不一致。",
      "更改后示例": "Call this API before the player is released, setting it only once per playback.",
      "触发条件": "当同一动词的不同语态形式（如主动语态\"releasing\"与被动语态\"is released\"）出现在相同语法结构（如时间状语从句\"before...\"）中，且上下文存在明确被动语态参照（如参考句中的\"before it is released\"）时触发。"
    },
    {
      "defect_id": 538316,
      "sentence": "Call this API before releasing the player.",
      "reference_sentence": "Call this API before the player starts or after it stops but before it is released.",
      "line_num": 764,
      "context": "{\"759\":\"### setLoop\",\"760\":\"\",\"761\":\"setLoop(loop: boolean): Promise&lt;void&gt;\",\"762\":\"\",\"763\":\"Set the playback to be looping; this method uses a promise to return the result.\",\"764\":\"Call this API before releasing the player.\",\"765\":\"\",\"766\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"767\":\"\",\"768\":\"**Parameters**\",\"769\":\"\"}",
      "修改建议": "混用了'releasing the player'和'released'的概念，导致前后不一致。",
      "更改后示例": "Call this API before the player is released.",
      "触发条件": "当同一动作或状态在相邻上下文或同一句子中混用主动/被动语态（如 \"releasing\" 和 \"is released\"）或时态形式，导致核心概念表述矛盾时触发。\n\n识别模式：\n1. **语态冲突检测**：主动语态（动词-ing作主语）与被动语态（be+过去分词）在同一动作描述中共存\n2. **时态/阶段矛盾**：如进程性动作（releasing）与完成性结果（released）被错误并列使用\n3. **上下文锚定**：参考相邻句子（如问题上下文中的被动表达 \"it is released\"）强制要求语态统一"
    },
    {
      "defect_id": 538907,
      "sentence": "从API version 20开始，RichEditor组件在执行复制或剪切操作时，会将HTML格式的内容添加到剪贴板中。",
      "reference_sentence": "从API version 20开始，RichEditor组件在执行复制或剪切操作时，会将HTML格式的内容添加到剪贴板中。",
      "line_num": 106,
      "context": "{\"101\":\"\",\"102\":\"copyOptions(value: CopyOptions)\",\"103\":\"\",\"104\":\"设置组件是否支持文本内容可复制粘贴。\",\"105\":\"\",\"106\":\"从API version 20开始，RichEditor组件在执行复制或剪切操作时，会将HTML格式的内容添加到剪贴板中。\",\"107\":\"\",\"108\":\"- 仅支持TextSpan和ImageSpan向剪贴板中添加HTML内容，其他Span类型则不能添加。\",\"109\":\"\",\"110\":\"- 设置RichEditor组件的属性字符串时，请参考属性字符串[toHtml](ts-universal-styled-string.md#tohtml14)接口文档，以了解支持转换为HTML的范围。\",\"111\":\"\"}",
      "修改建议": "混用了'复制'与'剪切'，建议统一使用'复制'。",
      "更改后示例": "从API version 20开始，RichEditor组件在执行复制操作时，会将HTML格式的内容添加到剪贴板中。",
      "触发条件": "当同一功能描述中混用多个同义/相关术语（如\"复制\"与\"剪切\"），且上下文存在明确对应的单一标准术语时触发。\n\n识别模式：\n1. 检测同一句子中并列使用的操作动词（通过\"或\"/\"与\"连接）\n2. 交叉验证相邻API描述字段（如本例中102行的copyOptions方法名）及参考文档的术语使用一致性\n3. 当发现非必要术语扩展（如新增\"剪切\"）导致概念边界模糊时，需执行术语统一修正"
    },
    {
      "defect_id": 538309,
      "sentence": "console.info(`Promise returned to indicate that the source id of the registerd source ${value}.`);",
      "reference_sentence": "console.info(`Promise returned to indicate that the source id of the registerd source ${value}.`);",
      "line_num": 166,
      "context": "{\"161\":\"  length: hapticFile.length,\",\"162\":\"};\",\"163\":\"let id = 0;\",\"164\":\"\",\"165\":\"audioHapticManagerInstance.registerSourceFromFd(audioFd, hapticFd).then((value: number) => {\",\"166\":\"  console.info(`Registered source with ID ${value}.`);\",\"167\":\"  id = value;\",\"168\":\"}).catch ((err: BusinessError) => {\",\"169\":\"  console.error(`Failed to register source ${err}`);\",\"170\":\"});\",\"171\":\"```\"}",
      "修改建议": "用词不一致，应使用“注册”而非“registerd”",
      "更改后示例": "console.info(`Promise returned to indicate that the source id of the registered source is ${value}.`);",
      "触发条件": "文档中出现中英文混杂的拼写形式（如\"registerd\"），且与上下文同一术语的标准拼写（如\"registered\"）或项目术语库定义不一致时触发。\n\n识别模式：\n1. 通过正则表达式匹配疑似混合拼写词汇（如全小写字母结尾的\"ed\"变形词）\n2. 建立项目术语白名单进行交叉验证（如上下文已出现\"Registered source\"的标准形式）\n3. 结合语义分析确认是否为同一概念的不同表述形式"
    },
    {
      "defect_id": 538307,
      "sentence": "After registering the source, this method returns the source ID using a promise.",
      "reference_sentence": "After registering the source, this method returns the source ID using a promise.",
      "line_num": 125,
      "context": "{\"120\":\"### registerSourceFromFd\",\"121\":\"\",\"122\":\"registerSourceFromFd(audioFd: AudioHapticFileDescriptor, hapticFd: AudioHapticFileDescriptor): Promise&lt;number&gt;\",\"123\":\"\",\"124\":\"Register the audio and haptic files represented by fd into the manager. The audio and haptic effects play in sync.\",\"125\":\"After registering the source, this method returns the source ID using a promise.\",\"126\":\"\",\"127\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"128\":\"\",\"129\":\"**Parameters**\",\"130\":\"\"}",
      "修改建议": "句式不一致，建议统一使用祈使句",
      "更改后示例": "Return the source ID using a promise after registering the source.",
      "触发条件": "当文档中存在混合句式（陈述句与祈使句混用）且当前句子与上下文/相邻句子的句式不一致时触发，特别是当方法描述部分其他语句使用祈使句时。\n\n识别模式：\n1. 检查句子是否包含主谓结构（如\"this method returns\"）与上下文祈使句结构（动词原形开头）形成冲突\n2. 比对相邻语句的句式特征（如上下文\"Register the audio...\"使用祈使句，当前句却使用陈述句）\n3. 验证技术文档是否处于方法描述章节（如参数说明、返回值说明等要求句式统一的区域）"
    },
    {
      "defect_id": 538314,
      "sentence": "Call this API before releasing the player.",
      "reference_sentence": "Call this API before the player starts or after it stops but before it is released.",
      "line_num": 626,
      "context": "{\"621\":\"### setVolume\",\"622\":\"\",\"623\":\"setVolume(volume: number): Promise&lt;void&gt;\",\"624\":\"\",\"625\":\"Sets the audio volume for this player and uses a promise to return the result.\",\"626\":\"Call this API before releasing the player.\",\"627\":\"\",\"628\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"629\":\"\",\"630\":\"**Parameters**\",\"631\":\"\"}",
      "修改建议": "混用了'releasing the player'和'released'的概念，导致前后不一致。",
      "更改后示例": "Call this API before the player is released.",
      "触发条件": "同一句子或相邻上下文中出现同一动词的主动语态与被动语态混用（如\"releasing\"与\"released\"），或同一动作概念存在时态/语态不一致表达时触发。\n\n识别模式：\n1. 检测动词形态差异：通过NLP工具识别动词的-ing形式与-ed形式同时描述同一动作\n2. 上下文对比验证：检查问题句所在段落是否存在统一语态规范（如参考句中的被动语态\"is released\"）\n3. 逻辑一致性判断：确保时间状语（before/after）后的动作状态与主句逻辑匹配（如\"before releasing\"隐含主动操作，而上下文可能需要被动状态描述）"
    },
    {
      "defect_id": 537632,
      "sentence": "快速模式（FAST_MODE）会改变web组件销毁时机，应用需要关注代码中依赖web组件销毁时机的错误实现，例如：web组件下树销毁后仍调用WebviewController这种未定义行为，对比普通模式（NORMAL_MODE），因为销毁时机提前了，有更高的几率触发未关联绑定的异常（17100001），建议应用捕捉异常，或者通过[getAttachState](#getattachstate20)查询是否绑定状态，来避免稳定性问题。",
      "reference_sentence": "设置web组件的销毁模式。",
      "line_num": 9768,
      "context": "{\"9763\":\"\",\"9764\":\"设置web组件的销毁模式，当web组件下树析构时，销毁模式会影响web内核的资源释放时机，例如js运行上下文、渲染上下文等等，默认值：普通模式（NORMAL_MODE）由系统决定合适的销毁时机，应用可以设置快速模式（FAST_MODE）立即销毁资源，提升部分场景的性能。\",\"9765\":\"\",\"9766\":\"> **说明：**\",\"9767\":\">\",\"9768\":\"> 快速模式（FAST_MODE）会改变web组件销毁时机，应用需要关注代码中依赖web组件销毁时机的错误实现，例如：web组件下树销毁后仍调用WebviewController这种未定义行为，对比普通模式（NORMAL_MODE），因为销毁时机提前了，有更高的几率触发未关联绑定的异常（17100001），建议应用捕捉异常，或者通过[getAttachState](#getattachstate20)查询是否绑定状态，来避免稳定性问题。\",\"9769\":\"\",\"9770\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9771\":\"\",\"9772\":\"**参数：**\",\"9773\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一事物，如'普通模式'和'快速模式'与'NORMAL_MODE'和'FAST_MODE'混用。",
      "更改后示例": "快速模式（FAST_MODE）会改变Web组件的销毁时机，应用需要关注代码中依赖Web组件销毁时机的错误实现，例如：Web组件下树销毁后仍调用WebViewController这种未定义行为。与普通模式（NORMAL_MODE）相比，因为销毁时机提前了，有更高的几率触发未关联绑定的异常（17100001），建议应用捕捉异常，或者通过[getAttachState](#getattachstate20)查询是否绑定状态，来避免稳定性问题。",
      "触发条件": "同一术语在文档中存在中文名称与对应英文标识符混用（如\"普通模式\"与\"NORMAL_MODE\"交替出现未保持括号关联），或组件名称/专有名词存在大小写不一致（如WebviewController/WebViewController）。"
    },
    {
      "defect_id": 539793,
      "sentence": "在开发过程中，需要考虑如何将创建的数值类型值与ArkTS环境进行交互，包括传递参数、返回值等。",
      "reference_sentence": "在开发过程中，需要考虑如何将创建的数值类型值与ArkTS环境进行交互，包括传递参数、返回值等。",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"当使用Node-API接口进行数值类型的创建和获取时，有一些基本概念需要了解：\",\"10\":\"\",\"11\":\"- **数值类型** 在使用Node-API接口时，可能需要从Node-API模块数值类型转换为ArkTS数值类型值，或者从ArkTS数据类型值转换为Node-API模块数值类型。在进行数据类型转换时，需要注意数据范围是否匹配，以及有无符号整数和双精度数值等区别。\",\"12\":\"- **错误处理** 在使用这些接口时，需要对可能发生的错误进行适当处理。比如，在创建整数值时可能发生内存分配错误或其他运行时错误，需要使用Node-API提供的错误处理机制来捕获并处理这些错误。\",\"13\":\"- **ArkTS交互** 在开发过程中，需要考虑如何将创建的数值类型值与ArkTS环境进行交互，包括传递参数、返回值等。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\"}",
      "修改建议": "用词一致，但“数值类型值”应与“数值类型”保持一致",
      "更改后示例": "在开发过程中，需要考虑如何将创建的数值类型与ArkTS环境进行交互，包括传递参数、返回值等。",
      "触发条件": "当同一术语在相邻上下文中存在\"基础形式+修饰词\"（如\"数值类型\"与\"数值类型值\"）的变体形式，且修饰词未在上下文形成有效语义区分时触发。\n\n识别模式：1) 定位核心术语（如\"数值类型\"）2) 检查同一段落/章节是否出现添加冗余修饰词的同源表述（如\"值\"）3) 验证修饰词是否具有必要的语义区分功能（本例中上下文未建立\"类型\"与\"类型值\"的区分性定义）"
    },
    {
      "defect_id": 539802,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "line_num": 31,
      "context": "{\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\",\"27\":\"| napi_create_double | 将Node-API模块中的double类型转换为ArkTS环境中number类型。 |\",\"28\":\"\",\"29\":\"## 使用示例\",\"30\":\"\",\"31\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"32\":\"\",\"33\":\"### napi_get_value_uint32\",\"34\":\"\",\"35\":\"用于从ArkTS环境中获取32位无符号整数值。\",\"36\":\"\"}",
      "修改建议": "用词一致，但“接口”应与“函数”保持一致",
      "更改后示例": "Node-API函数开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对函数对应C++及ArkTS相关代码进行展示。",
      "触发条件": "当同一技术概念在文档中存在多个术语表述（如\"接口\"与\"函数\"混用），且上下文存在明确的标准术语（如函数列表/API命名）时触发。\n\n识别模式：通过比对问题句中的争议术语（如\"接口\"）与上下文高频术语（如表格中的napi_create_xxx函数命名）、参考材料中的标准命名（如\"Node-API函数\"的官方表述）是否形成术语冲突，同时验证是否存在更符合技术规范的标准表述（如\"函数\"对应C++函数实现）。"
    },
    {
      "defect_id": 541482,
      "sentence": "将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。",
      "reference_sentence": "将ArkTS环境中number类型数据转换为Node-API模块中的uint32类型数据。",
      "line_num": 20,
      "context": "{\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\",\"23\":\"| napi_get_value_double | 将ArkTS环境中获取的number类型数据转为Node-API模块中的double类型数据。 |\",\"24\":\"| napi_create_int32 | 将Node-API模块中的int32_t类型转换为ArkTS环境中number类型。 |\",\"25\":\"| napi_create_uint32 | 将Node-API模块中的uint32_t类型转换为ArkTS环境中number类型。 |\"}",
      "修改建议": "混用了“转为”和“转换为”概念",
      "更改后示例": "将ArkTS环境中number类型数据转换为Node-API模块中的uint32类型数据。",
      "触发条件": "同一文档中混用不同动词（如“转为”与“转换为”）描述相同操作，且在相邻条目或相同上下文场景中存在表达冲突时触发。"
    },
    {
      "defect_id": 541483,
      "sentence": "将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。",
      "reference_sentence": "将ArkTS环境中获取的number类型数据转换为Node-API模块中的int32类型数据。",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\",\"23\":\"| napi_get_value_double | 将ArkTS环境中获取的number类型数据转为Node-API模块中的double类型数据。 |\",\"24\":\"| napi_create_int32 | 将Node-API模块中的int32_t类型转换为ArkTS环境中number类型。 |\",\"25\":\"| napi_create_uint32 | 将Node-API模块中的uint32_t类型转换为ArkTS环境中number类型。 |\",\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\"}",
      "修改建议": "混用了“转为”和“转换为”概念",
      "更改后示例": "将ArkTS环境中的number类型数据转换为Node-API模块中的int32类型数据。",
      "触发条件": "同一文档或上下文中出现相同语义的转换操作时，混用\"转为\"与\"转换为\"等不同表达形式，且存在至少一个正确用法作为参照基准（如参考句中的\"转换为\"）。\n\n识别模式：通过对比相邻条目/相似句式中的动宾结构短语，检测描述相同类型转换操作时是否使用不一致的动词表达（如\"转为\"与\"转换为\"交替出现），同时验证上下文存在已确立的标准表达形式作为修正依据。"
    },
    {
      "defect_id": 541481,
      "sentence": "以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：",
      "reference_sentence": "以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型，帮助开发人员在Node-API模块中和JavaScript数值进行交互：",
      "line_num": 17,
      "context": "{\"12\":\"- **错误处理** 在使用这些接口时，需要对可能发生的错误进行适当处理。比如，在创建整数值时可能发生内存分配错误或其他运行时错误，需要使用Node-API提供的错误处理机制来捕获并处理这些错误。\",\"13\":\"- **ArkTS交互** 在开发过程中，需要考虑如何将创建的数值类型值与ArkTS环境进行交互，包括传递参数、返回值等。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\"}",
      "修改建议": "混用了“数值类型值”和“数值类型”概念，以及“JavaScript”和“JavaScrip”拼写错误",
      "更改后示例": "以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型，帮助开发人员在Node-API模块中与JavaScript数值进行交互：",
      "触发条件": "当文档中同一术语存在多种表达形式（如\"数值类型值\"与\"数值类型\"混用）或出现技术术语拼写错误（如\"JavaScript\"误写为\"JavaScrip\"）时触发。\n\n识别模式：\n1. 术语一致性检测：通过对比上下文术语使用频率（如\"数值类型\"在相邻段落出现3次，\"数值类型值\"仅出现1次），识别低频异常表达\n2. 拼写校验规则：建立技术术语白名单（如JavaScript/Node-API/ArkTS），通过字符串匹配识别拼写偏差（如JavaScrip少字母\"t\"）\n3. 语法结构分析：检测\"处理数值类型值\"中的冗余修饰词（\"值\"），结合动宾搭配习惯判断是否需要简化"
    },
    {
      "defect_id": 541651,
      "sentence": "- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\r",
      "reference_sentence": "- **实例**：实例是通过类创建的具体对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\r",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用Node-API接口进行class相关开发时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **类**：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在ArkTS中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。\",\"12\":\"- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\",\"13\":\"\",\"14\":\"## 场景和功能介绍\",\"15\":\"\",\"16\":\"以下Node-API接口主要用于处理class。他们的使用场景如下：\",\"17\":\"| 接口 | 描述 |\"}",
      "修改建议": "混用了“具体的对象”与“具体对象”",
      "更改后示例": "- **实例**：实例是通过类创建的具体对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。",
      "触发条件": "当同一术语或短语在相邻上下文或同一文档中，出现修饰词顺序不一致（如\"具体的对象\"与\"具体对象\"）或冗余助词（如\"的\"）时触发。\n\n识别模式：\n1. 检测名词短语中修饰词与核心词的组合结构（如形容词+名词）\n2. 对比同一语义单元内（如同一条目、相邻段落）的同类表达\n3. 识别存在\"的\"字冗余（\"具体的对象\"）或词序差异（具体对象 vs 对象具体）的情况\n4. 匹配参考句式中已确立的标准表达形式（如\"具体对象\"）"
    },
    {
      "defect_id": 541349,
      "sentence": "napi提供了线程安全任务的优先级, 底层任务队列中的任务会根据其优先级被依次执行, 优先级的定义如下：",
      "reference_sentence": "napi提供了运行底层事件循环的两种模式, 其定义如下：",
      "line_num": 236,
      "context": "{\"231\":\"| napi_event_mode_default | 阻塞式的运行底层事件循环，直到循环中没有或活跃的uv_handle句柄时退出事件循环。 |\",\"232\":\"| napi_event_mode_nowait | 非阻塞式的运行底层事件循环，尝试去处理一个任务，处理完之后退出事件循环；如果事件循环中没有任务，立刻退出事件循环。 |\",\"233\":\"\",\"234\":\"### 线程安全任务优先级\",\"235\":\"\",\"236\":\"napi提供了线程安全任务的优先级, 底层任务队列中的任务会根据其优先级被依次执行, 优先级的定义如下：\",\"237\":\"\",\"238\":\"```c\",\"239\":\"typedef enum {\",\"240\":\"    napi_priority_immediate = 0,\",\"241\":\"    napi_priority_high = 1,\"}",
      "修改建议": "混用了'模式'和'定义'，建议统一使用'定义'。",
      "更改后示例": "napi提供了线程安全任务的优先级定义，底层任务队列中的任务会根据其优先级被依次执行，优先级的定义如下：",
      "触发条件": "同一段落或相邻上下文中，对同一功能或概念的描述存在术语或表达结构不一致（如混用“模式”和“定义”），且存在明确的前后对应关系（如“提供X”后需统一用“X的定义”）。"
    },
    {
      "defect_id": 541484,
      "sentence": "将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。",
      "reference_sentence": "将ArkTS环境中获取的number类型数据转换为Node-API模块中的int64类型数据。",
      "line_num": 22,
      "context": "{\"17\":\"以下Node-API函数通常在开发ArkTS的Node-API模块时使用，以便处理数值类型值，帮助开发人员在Node-API模块中和JavaScrip数值进行交互：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_get_value_uint32 | 将ArkTS环境中number类型数据转为Node-API模块中的uint32类型数据。 |\",\"21\":\"| napi_get_value_int32 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int32类型数据。 |\",\"22\":\"| napi_get_value_int64 | 将ArkTS环境中获取的number类型数据转为Node-API模块中的int64类型数据。 |\",\"23\":\"| napi_get_value_double | 将ArkTS环境中获取的number类型数据转为Node-API模块中的double类型数据。 |\",\"24\":\"| napi_create_int32 | 将Node-API模块中的int32_t类型转换为ArkTS环境中number类型。 |\",\"25\":\"| napi_create_uint32 | 将Node-API模块中的uint32_t类型转换为ArkTS环境中number类型。 |\",\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\",\"27\":\"| napi_create_double | 将Node-API模块中的double类型转换为ArkTS环境中number类型。 |\"}",
      "修改建议": "混用了“转为”和“转换为”概念",
      "更改后示例": "将ArkTS环境中获取的number类型数据转换为Node-API模块中的int64类型数据。",
      "触发条件": "当同一上下文范围内存在多个相似表达结构时，若出现\"转为\"与\"转换为\"等同义但不同形的动词短语混用，且参考句已建立统一表达规范时触发。\n\n识别模式：\n1. 检测相邻表格条目/列表项中\"将A...数据转为B\"与\"将C...数据转换为D\"的句式差异\n2. 对比上下文动词使用频率，当非规范表达(如\"转为\")出现在规范表达(如\"转换为\")主导的语义环境中时识别\n3. 验证目标动词短语在技术文档中的标准用法(如Node-API文档统一使用\"转换为\"作为规范术语)"
    },
    {
      "defect_id": 542545,
      "sentence": "当ArkTS Object中的对象被垃圾回收时调用注册的napi_add_finalizer回调。",
      "reference_sentence": "为Object创建一个reference，以延长其生命周期。调用者需要自己管理reference生命周期。",
      "line_num": 199,
      "context": "{\"194\":\">\",\"195\":\"> 这意味着你可能在napi_ref有效的情况下，通过本接口获取到一个空指针。\",\"196\":\"\",\"197\":\"### napi_add_finalizer\",\"198\":\"\",\"199\":\"当ArkTS Object中的对象被垃圾回收时调用注册的napi_add_finalizer回调。\",\"200\":\"\",\"201\":\"cpp部分代码\",\"202\":\"\",\"203\":\"```cpp\",\"204\":\"// log.h用于C++中日志打印\"}",
      "修改建议": "调用与触发近义词混用",
      "更改后示例": "当ArkTS Object中的对象被垃圾回收时触发注册的napi_add_finalizer回调。",
      "触发条件": "在描述相同操作或机制时，文档中混用了具有相同语义但表述不一致的动词（如\"调用\"与\"触发\"），且上下文存在明确术语规范（如参考句已使用\"调用\"描述主动操作，\"触发\"描述被动事件）时触发。"
    },
    {
      "defect_id": 542513,
      "sentence": "通过接口napi_open_escapable_handle_scope创建出一个可逃逸的handel scope，可将范围内声明的值返回到父作用域。该作用域需要使用napi_close_escapable_handle_scope进行关闭。napi_escape_handle用于提升传入的ArkTS对象的生命周期到其父作用域。",
      "reference_sentence": "通过接口napi_open_escapable_handle_scope创建出一个可逃逸的handle scope，可将范围内声明的值返回到父作用域。该作用域需要使用napi_close_escapable_handle_scope进行关闭。napi_escape_handle用于提升传入的ArkTS对象的生命周期到其父作用域。",
      "line_num": 122,
      "context": "{\"117\":\"```\",\"118\":\"<!-- @[ark_napi_open_close_handle_scope](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPILifeCycle/entry/src/main/ets/pages/Index.ets) -->\",\"119\":\"\",\"120\":\"### napi_open_escapable_handle_scope、napi_close_escapable_handle_scope、napi_escape_handle\",\"121\":\"\",\"122\":\"通过接口napi_open_escapable_handle_scope创建出一个可逃逸的handel scope，可将范围内声明的值返回到父作用域。该作用域需要使用napi_close_escapable_handle_scope进行关闭。napi_escape_handle用于提升传入的ArkTS对象的生命周期到其父作用域。\",\"123\":\"通过上述接口可以更灵活的使用管理传入的ArkTS对象，特别是在处理跨作用域的值传递时非常有用。\",\"124\":\"\",\"125\":\"cpp部分代码\",\"126\":\"\",\"127\":\"```cpp\"}",
      "修改建议": "handel scope与handle scope拼写不一致。",
      "更改后示例": "通过接口napi_open_escapable_handle_scope创建出一个可逃逸的handle scope，可将范围内声明的值返回到父作用域。该作用域需要使用napi_close_escapable_handle_scope进行关闭。napi_escape_handle用于提升传入的ArkTS对象的生命周期到其父作用域。",
      "触发条件": "当同一技术术语在文档中存在多种拼写变体（如handel scope/handle scope），或与接口名称/上下文定义的关键词（如napi_open_escapable_handle_scope）存在拼写矛盾时触发。\n\n识别模式：\n1. 术语形态对比：检测同一段落中核心术语（如handle scope）的拼写一致性\n2. 接口名称映射：验证技术描述中的术语是否与API接口名称中的关键词严格匹配（如handle_scope接口名与handel scope描述词的匹配性）"
    },
    {
      "defect_id": 542682,
      "sentence": "在ArkTS代码环境中使用Node-API模块编写的代码来实现特定的功能，可以将这部分功能封装成自定义模块，然后通过napi_module_register将其注册到ArkTS代码环境中，以实现功能的扩展和复用。",
      "reference_sentence": "通过将这些功能实现为自定义模块并注册到ArkTS环境中，可以在一定程度上提高整体的性能。",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"[使用Node-API接口进行模块加载](use-napi-load-module-with-info.md)\",\"28\":\"\",\"29\":\"#### napi_module_register\",\"30\":\"\",\"31\":\"在ArkTS代码环境中使用Node-API模块编写的代码来实现特定的功能，可以将这部分功能封装成自定义模块，然后通过napi_module_register将其注册到ArkTS代码环境中，以实现功能的扩展和复用。\",\"32\":\"\",\"33\":\"cpp部分代码\",\"34\":\"\",\"35\":\"```cpp\",\"36\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了`ArkTS代码环境`和`ArkTS环境`概念，建议保持一致。",
      "更改后示例": "在ArkTS环境中使用Node-API模块编写的代码来实现特定的功能，可以将这部分功能封装成自定义模块，然后通过napi_module_register将其注册到ArkTS环境中，以实现功能的扩展和复用。",
      "触发条件": "同一技术术语在邻近段落或同一文档中存在多个变体（如\"ArkTS代码环境\"和\"ArkTS环境\"），且变体间存在冗余修饰词（如\"代码\"）或缩写/全称混用的情况。"
    },
    {
      "defect_id": 542493,
      "sentence": "napi_value是一个表示ArkTS值的抽象类型，它可以表示任何ArkTS值，包括基本类型（如数字、字符串、布尔值）和复杂对象类型（如数组、函数、对象等）。",
      "reference_sentence": "napi_value是一个表示ArkTS值的抽象类型，它可以表示任何ArkTS值，包括基本类型（如数字、字符串、布尔值）和复杂对象类型（如数组、函数、对象等）。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口进行生命周期相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"在Node-API中，napi_value是一个表示ArkTS值的抽象类型，它可以表示任何ArkTS值，包括基本类型（如数字、字符串、布尔值）和复杂对象类型（如数组、函数、对象等）。\",\"6\":\"\",\"7\":\"napi_value的生命周期与其在ArkTS中的对应值的生命周期紧密相关。当ArkTS值被垃圾回收时，与之关联的napi_value也将不再有效。重要的是不要在ArkTS值不再存在时尝试使用napi_value。\",\"8\":\"\",\"9\":\"框架层的scope通常用于管理napi_value的生命周期。在Node-API中，可以使用napi_open_handle_scope和napi_close_handle_scope函数来创建和销毁scope。通过在scope内创建napi_value，可以确保在scope结束时自动释放napi_value，避免内存泄漏。\",\"10\":\"\"}",
      "修改建议": "原文中使用了“基本类型”和“复杂对象类型”，建议统一为“基本类型”和“复杂类型”以保持用词一致。",
      "更改后示例": "napi_value是一个表示ArkTS值的抽象类型，它可以表示任何ArkTS值，包括基本类型（如数字、字符串、布尔值）和复杂类型（如数组、函数、对象等）。",
      "触发条件": "当同一分类层级的术语在并列结构中存在修饰词冗余或不匹配时（例如\"基本类型\"与\"复杂对象类型\"中的\"对象\"冗余），或同一语义范畴的术语用词结构不一致时（如\"类型\"应统一为\"类型\"结尾的表述）。  \n\n识别模式：  \n1. **并列结构检测**：识别文档中带有枚举/并列关系的短语（如\"包括A和B\"），检查并列项是否采用相同修饰结构  \n2. **词根一致性验证**：对比并列术语的核心词（如\"基本类型\"的\"类型\" vs \"复杂对象类型\"的\"类型\"）是否匹配，同时检测冗余修饰词（如\"对象\"在上下文未强调具体对象类型时多余）  \n3. **语义对称性判断**：确保同一逻辑层级的术语保持相同抽象程度（如\"基本/复杂\"为同级分类，不应单方面添加\"对象\"限定）"
    },
    {
      "defect_id": 542681,
      "sentence": "用于在Node-API中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用。",
      "reference_sentence": "用于在Node-API模块中将abc文件作为模块加载，返回模块的命名空间，适用于需要在运行时动态加载模块或资源的应用程序，从而实现灵活的扩展和定制。",
      "line_num": 16,
      "context": "{\"11\":\"### 接口描述\",\"12\":\"\",\"13\":\"| 接口 | 描述 |\",\"14\":\"| -------- | -------- |\",\"15\":\"| napi_load_module | 用于在Node-API模块中将abc文件作为模块加载，返回模块的命名空间，适用于需要在运行时动态加载模块或资源的应用程序，从而实现灵活的扩展和定制。 |\",\"16\":\"| napi_load_module_with_info | 用于在Node-API中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用。 |\",\"17\":\"| napi_module_register | 有些功能可能需要通过Node-API模块来实现以获得更好的性能，通过将这些功能实现为自定义模块并注册到ArkTS环境中，可以在一定程度上提高整体的性能。 |\",\"18\":\"\",\"19\":\"### 使用示例\",\"20\":\"\",\"21\":\"#### napi_load_module\"}",
      "修改建议": "混用了`Node-API`和`Node-API模块`概念，建议保持一致。",
      "更改后示例": "用于在Node-API模块中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用。",
      "触发条件": "当同一文档中相邻/相关段落对同一技术概念（如\"Node-API\"和\"Node-API模块\"）出现术语混用，且上下文存在明确的标准术语参照（如参考句子的\"Node-API模块\"用法）时触发。\n\n识别模式：\n1. 在限定技术领域内（如Node-API模块系统），检测相邻段落是否存在核心术语的缩略/扩展形式交替使用\n2. 通过交叉比对文档内已建立的术语标准（如接口表格中的规范用法），识别偏离标准表述的异常点\n3. 当修饰语结构（如\"在X中进行...\"）中的技术名词存在概念层级混乱（API名称 vs 模块实体）时进行标记"
    },
    {
      "defect_id": 542507,
      "sentence": "此处以在ArkTS/JS侧实现add()接口、在Native侧实现Add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。",
      "reference_sentence": "使用Node-API实现跨语言交互，首先需要按照Node-API的机制实现模块的注册和加载等相关动作。",
      "line_num": 12,
      "context": "{\"7\":\"- **ArkTS/JS侧**：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。\",\"8\":\"\",\"9\":\"- **Native侧**：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。\",\"10\":\"\",\"11\":\"\",\"12\":\"此处以在ArkTS/JS侧实现add()接口、在Native侧实现Add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。\",\"13\":\"\",\"14\":\"\",\"15\":\"## 创建Native C++工程\",\"16\":\"\",\"17\":\"- 在DevEco Studio中**New &gt; Create Project**，选择**Native C++**模板，点击**Next**，选择API版本，设置好工程名称，点击**Finish**，创建得到新工程。\"}",
      "修改建议": "混用了`add()`和`Add()`方法名，应保持一致",
      "更改后示例": "此处以在ArkTS/JS侧实现add()接口、在Native侧实现add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。",
      "触发条件": "当文档中同一接口/方法名在相邻段落或跨语言上下文（如ArkTS/JS与Native侧）出现大小写不一致（例如`add()`与`Add()`），且该名称属于代码元素需严格匹配时。\n\n识别模式：\n1. 检测相邻段落或技术步骤描述中重复出现的同名代码元素\n2. 对比代码元素的大小写形态（如驼峰式与全小写）\n3. 验证上下文是否属于需要严格命名匹配的技术场景（如跨语言接口映射、模块注册等）"
    },
    {
      "defect_id": 541936,
      "sentence": "以下是一些可能的使用场景：",
      "reference_sentence": "以下是一些可能的使用场景：",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"在Node-API中，通过提供与Date对象交互的函数，Node-API模块能够更紧密地与ArkTS环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"以下Node-API函数通常在开发Node-API模块中与ArkTS的Date对象进行交互时使用，来处理和操作日期数据。以下是一些可能的使用场景：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_create_date | 在需要根据当前系统时间或特定计算生成一个Date对象时，可通过使用此接口创建表示这些时间的ArkTS Date对象，然后将其传递给ArkTS代码进行进一步处理。 |\",\"21\":\"| napi_get_date_value | 在Node-API模块中接收到一个ArkTS的Date对象，并且需要获取其对应的时间戳或日期值时，可以使用此接口。|\",\"22\":\"| napi_is_date | 在需要确定一个ArkTS对象是否为Date对象时，可使用此接口判断给定的值是否为Date对象。例如，在接收函数参数时，需要验证参数是否为Date对象以确保正确的数据类型。 |\"}",
      "修改建议": "句式一致，建议使用祈使句",
      "更改后示例": "以下列出一些可能的使用场景：",
      "触发条件": "当文档中存在引导列表/示例的段落首句，且该句未采用与上下文同类结构一致的祈使句式(动词开头)时触发，尤其当相邻章节存在\"以下列出...\"等规范表述时。\n\n识别模式：检测以\"以下\"开头的引导句，若其未包含主动动词(如\"列出\"\"介绍\"等)构成祈使结构，而采用静态描述(如\"是...\")，且上下文存在同类引导句使用规范祈使句式时，判定为需要修复的不一致表达。"
    },
    {
      "defect_id": 541785,
      "sentence": "使用Node-API接口在进程退出时处理未释放资源，在Node-API模块注册清理钩子，一旦当前环境退出，这些钩子就会运行，使所有资源都被正确释放。",
      "reference_sentence": "使用Node-API接口在进程退出时处理未释放资源，在Node-API模块注册清理钩子，一旦当前环境退出，这些钩子就会运行，使所有资源都被正确释放。",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口注册和使用环境清理钩子\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用Node-API接口在进程退出时处理未释放资源，在Node-API模块注册清理钩子，一旦当前环境退出，这些钩子就会运行，使所有资源都被正确释放。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：\",\"10\":\"\"}",
      "修改建议": "无用词不一致问题，但建议将“使所有资源都被正确释放”改为“确保所有资源都被正确释放”，以符合祈使句的风格。",
      "更改后示例": "使用Node-API接口在进程退出时处理未释放资源，在Node-API模块注册清理钩子，一旦当前环境退出，这些钩子就会运行，确保所有资源都被正确释放。",
      "触发条件": "同一段落或上下文中存在多个功能相似的祈使句结构，但动词使用不一致（如\"使\"与\"确保\"混用），且存在表达结果性语义的语境。\n\n识别模式：\n1. 检测连续指令性语句中结果描述动词的语态一致性（如\"使\"与\"确保\"的语义等价性）\n2. 当文本包含\"处理...，注册...，运行...\"等系列祈使结构时，需检查后续结果从句是否保持主动确保型动词（如\"确保\"而非被动式\"使\"）"
    },
    {
      "defect_id": 541787,
      "sentence": "接口提供了注册和取消注册清理钩子函数的功能，以下是相关概念：",
      "reference_sentence": "Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用Node-API接口在进程退出时处理未释放资源，在Node-API模块注册清理钩子，一旦当前环境退出，这些钩子就会运行，使所有资源都被正确释放。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：\",\"10\":\"\",\"11\":\"- **资源管理**：在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源必须在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。\",\"12\":\"- **钩子函数（Hook）**：钩子函数是一种在特定事件或时间点自动执行的回调函数。在Node-API模块的上下文中，清理钩子函数通常用于在环境或进程退出时执行资源清理任务。这是因为环境或进程退出时，操作系统可能不会立即回收所有资源，因此需要通过清理钩子函数来确保所有资源都被正确释放。\",\"13\":\"\",\"14\":\"以上这些基本概念是理解和使用Node-API接口注册环境清理钩子的基础，下面将介绍具体的接口和使用示例。\"}",
      "修改建议": "用词不一致，应使用“Node-API”而非“接口”。",
      "更改后示例": "Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：",
      "触发条件": "当文档中同一技术术语存在多种表述形式（如\"Node-API\"与\"接口\"混用），且上下文已明确确立标准术语时；或特定术语在相邻段落中高频重复出现，但某处出现非标准替代词时。\n\n识别模式：\n1. 术语冲突检测：对比当前句子与上下文高频术语（如本案例前文出现4次\"Node-API\"）\n2. 定义一致性验证：检查是否在概念定义段落（如\"## 基本概念\"章节）出现术语表述偏差\n3. 功能主体匹配：当描述对象具有明确命名空间（如Node-API）时，普通词汇（如\"接口\"）无法准确指代特定技术组件"
    },
    {
      "defect_id": 542544,
      "sentence": "增加/减少传入的reference的引用计数，并获取新的计数。",
      "reference_sentence": "为Object创建一个reference，以延长其生命周期。调用者需要自己管理reference生命周期。",
      "line_num": 183,
      "context": "{\"178\":\"\",\"179\":\"为Object创建一个reference，以延长其生命周期。调用者需要自己管理reference生命周期。可以调用napi_delete_reference删除传入的reference。\",\"180\":\"\",\"181\":\"### napi_reference_ref、napi_reference_unref\",\"182\":\"\",\"183\":\"增加/减少传入的reference的引用计数，并获取新的计数。\",\"184\":\"\",\"185\":\"### napi_get_reference_value\",\"186\":\"\",\"187\":\"获取与reference相关联的ArkTS Object。\",\"188\":\"\"}",
      "修改建议": "增加/减少与添加/减少近义词混用",
      "更改后示例": "增加或减少传入的reference的引用计数，并获取新的计数。",
      "触发条件": "同一句子中存在用斜杠分隔的动词/名词对（如\"增加/减少\"），且该词对在文档其他位置存在更一致的表达形式（如\"创建/删除\"使用\"与\"或\"和\"连接）时触发；或当斜杠分隔词对存在近义词混用风险（如\"增加\"与\"添加\"交替出现）时触发。"
    },
    {
      "defect_id": 542543,
      "sentence": "可以调用napi_delete_reference删除传入的reference。",
      "reference_sentence": "为Object创建一个reference，以延长其生命周期。调用者需要自己管理reference生命周期。",
      "line_num": 179,
      "context": "{\"174\":\"```\",\"175\":\"<!-- @[ark_napi_open_close_escapable_handle_scope](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPILifeCycle/entry/src/main/ets/pages/Index.ets) -->\",\"176\":\"\",\"177\":\"### napi_create_reference、napi_delete_reference\",\"178\":\"\",\"179\":\"为Object创建一个reference，以延长其生命周期。调用者需要自己管理reference生命周期。可以调用napi_delete_reference删除传入的reference。\",\"180\":\"\",\"181\":\"### napi_reference_ref、napi_reference_unref\",\"182\":\"\",\"183\":\"增加/减少传入的reference的引用计数，并获取新的计数。\",\"184\":\"\"}",
      "修改建议": "删除与移除近义词混用",
      "更改后示例": "可以调用napi_delete_reference移除传入的reference。",
      "触发条件": "同一文档上下文中对同一操作使用多个近义动词（如\"删除\"与\"移除\"），且存在已确立的规范术语（如参考句中的\"管理\"对应\"移除\"的语义连贯性）时。"
    },
    {
      "defect_id": 541934,
      "sentence": "在Node-API的中，ArkTS Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。",
      "reference_sentence": "在Node-API中，ArkTS Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"Node-API中date相关接口用于处理ArkTS Date对象，并在Node-API模块和ArkTS代码之间进行日期数据的转换和处理。这对于在Node-API模块中处理时间和日期相关逻辑非常有用。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在Node-API的中，ArkTS Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"ArkTS Date对象提供了一种在ArkTS中表示和操作日期和时间的方式。它们允许您创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在Node-API中，通过提供与Date对象交互的函数，Node-API模块能够更紧密地与ArkTS环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\"}",
      "修改建议": "用词不一致，'的中'应改为'中'",
      "更改后示例": "在Node-API中，ArkTS Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。",
      "触发条件": "当同一术语在上下文出现介词结构不一致（如\"的中\"冗余助词），且与文档其他部分标准用法（如\"在Node-API中\"）产生矛盾时触发。\n\n识别模式：\n1. 检测\"在...中\"结构内是否存在冗余助词（如\"的中\"）\n2. 对比文档全局术语使用（如上下文第5/13段均使用标准形式\"在Node-API中\"）\n3. 验证是否符合汉语介词短语规范（\"在+名词+中\"结构不应插入\"的\"）"
    },
    {
      "defect_id": 542090,
      "sentence": "在Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应的C++及ArkTS相关代码进行展示。",
      "line_num": 21,
      "context": "{\"16\":\"| napi_set_instance_data | 绑定与当前运行的环境相关联的数据项。 |\",\"17\":\"| napi_get_instance_data | 检索与当前运行的环境相关联的数据项。 |\",\"18\":\"\",\"19\":\"## 使用示例\",\"20\":\"\",\"21\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"22\":\"\",\"23\":\"### napi_set_instance_data\",\"24\":\"\",\"25\":\"将需要绑定的数据与当前运行的环境相关联。\",\"26\":\"\"}",
      "修改建议": "“对应”与“对应的”混用，建议统一使用“对应的”",
      "更改后示例": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应的C++及ArkTS相关代码进行展示。",
      "触发条件": "当同一文档中出现\"对应\"与\"对应的\"混用作名词定语，且上下文存在统一用\"对应的\"的参考实例时触发；或检测到\"对应\"直接修饰名词而未添加结构助词\"的\"时触发。"
    },
    {
      "defect_id": 542735,
      "sentence": "使用类型标签type_tag来标记ArkTS对象，后续可以更精确地识别ArkTS对象。",
      "reference_sentence": "用于检查一个对象是否是指定构造函数的实例。",
      "line_num": 452,
      "context": "{\"447\":\"```\",\"448\":\"<!-- @[ark_napi_instanceof](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIObject/entry/src/main/ets/pages/Index.ets) -->\",\"449\":\"\",\"450\":\"### napi_type_tag_object\",\"451\":\"\",\"452\":\"使用类型标签type_tag来标记ArkTS对象，后续可以更精确地识别ArkTS对象。\",\"453\":\"\",\"454\":\"### napi_check_object_type_tag\",\"455\":\"\",\"456\":\"验证一个ArkTS对象是否带有特定类型标签。\",\"457\":\"\"}",
      "修改建议": "句式不一致，应统一使用祈使句",
      "更改后示例": "使用类型标签type_tag来标记ArkTS对象，以便后续更精确地识别这些对象。",
      "触发条件": "当文档中的操作步骤或说明性语句混合使用祈使句（指令性表达）和陈述句（描述性表达），导致句式结构不统一时触发。例如，前半句为动作指令（如“使用...”），后半句转为结果描述（如“后续可以...”），且未通过逻辑连接词（如“以便”）保持连贯性。"
    },
    {
      "defect_id": 541451,
      "sentence": "获取给定js Boolean对应的C bool值。",
      "reference_sentence": "获取给定JS Boolean对象。",
      "line_num": 412,
      "context": "{\"407\":\"| napi_create_double | 通过一个C的double数据创建JS number。 |\",\"408\":\"| napi_get_value_int32 | 获取给定JS number对应的C int32值。 |\",\"409\":\"| napi_get_value_uint32 | 获取给定JS number对应的C uint32值。 |\",\"410\":\"| napi_get_value_int64 | 获取给定JS number对应的C int64值。 |\",\"411\":\"| napi_get_value_double | 获取给定JS number对应的C double值。 |\",\"412\":\"|napi_get_value_bool|获取给定js Boolean对应的C bool值。|\",\"413\":\"\",\"414\":\"### bigint相关\",\"415\":\"\",\"416\":\"| 接口 | 功能说明 |\",\"417\":\"| -------- | -------- |\"}",
      "修改建议": "混用了`js`和`JS`，应保持一致。",
      "更改后示例": "获取给定JS Boolean对应的C bool值。",
      "触发条件": "当同一术语在文档中出现大小写不一致（如\"js\"与\"JS\"混用）且上下文存在明确的标准形式（如参考句及相邻条目均使用\"JS\"全大写）时触发。\n\n识别模式：\n1. 通过对比相邻条目（如问题上下文中的JS number）识别术语标准形式\n2. 检测到同一术语存在非标准变体（如全小写/驼峰/首字母大写）时标记\n3. 特别关注技术缩写（如JS/C/Bool）在复合词组中的格式一致性"
    },
    {
      "defect_id": 541440,
      "sentence": "通过现有的ArrayBuffer创建一个ArkTS TypeArray。",
      "reference_sentence": "通过现有的ArrayBuffer创建一个ArkTS DataView。",
      "line_num": 353,
      "context": "{\"348\":\"| napi_is_array | 判断给定ArkTS value是否为array。 |\",\"349\":\"| napi_set_element | 在给定Object的指定索引处，设置属性值。 |\",\"350\":\"| napi_get_element | 获取给定Object指定索引处的元素。 |\",\"351\":\"| napi_has_element | 若给定Object的指定索引处拥有属性。 |\",\"352\":\"| napi_delete_element | 尝试删除给定Object的指定索引处的元素。 |\",\"353\":\"| napi_create_typedarray | 通过现有的ArrayBuffer创建一个ArkTS TypeArray。 |\",\"354\":\"| napi_is_typedarray | 判断给定ArkTS value是否为TypeArray。|\",\"355\":\"| napi_get_typedarray_info | 获取给定TypedArray的各种属性（例如：类型，长度，字节偏移量，ArrayBuffer等）。 |\",\"356\":\"| napi_create_dataview | 通过现有的ArrayBuffer创建一个ArkTS DataView。 |\",\"357\":\"| napi_is_dataview | 判断给定ArkTS value是否为DataView。|\",\"358\":\"| napi_get_dataview_info | 获取给定DataView的各种属性。|\"}",
      "修改建议": "混用了'TypeArray'和'DataView'，应保持一致",
      "更改后示例": "通过现有的ArrayBuffer创建一个ArkTS TypedArray。",
      "触发条件": "当同一技术文档中混合使用大小写敏感的关键术语变体（如\"TypeArray\"与\"TypedArray\"），或存在与关联术语结构不匹配（如\"TypedArray\"与\"DataView\"后缀形式不一致）时触发。\n\n识别模式：\n1. **术语形态对比**：检测相邻段落中相同概念的拼写差异（如TypeArray→TypedArray）\n2. **关联术语对称性**：检查同类API命名结构是否统一（如TypedArray/DataView应保持\"XxxedXxx\"/\"XxxXxx\"的对称格式）\n3. **跨条目一致性验证**：通过上下文交叉比对（如napi_create_typedarray与napi_is_typedarray条目间的术语连贯性）"
    },
    {
      "defect_id": 545620,
      "sentence": "停止闪控球，采用Promise进行异步回调。",
      "reference_sentence": "更新闪控球，使用Promise异步回调。",
      "line_num": 222,
      "context": "{\"217\":\"\",\"218\":\"### stopFloatingBall\",\"219\":\"\",\"220\":\"stopFloatingBall(): Promise&lt;void&gt;\",\"221\":\"\",\"222\":\"停止闪控球，采用Promise进行异步回调。\",\"223\":\"\",\"224\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"225\":\"\",\"226\":\"**返回值：**\",\"227\":\"\"}",
      "修改建议": "混用了“采用”与“使用”描述同一操作",
      "更改后示例": "停止闪控球，使用Promise进行异步回调。",
      "触发条件": "同一操作在相邻上下文或同一文档中被不同动词（如“采用”与“使用”）交替描述，且存在已定义的标准术语（如参考句中的“使用”）时触发。"
    },
    {
      "defect_id": 545645,
      "sentence": "开启闪控球的点击监听事件，不使用时，关闭监听以避免内存泄漏。",
      "reference_sentence": "注册闪控球生命周期状态变化的监听事件，建议在不需要使用时取消监听，否则可能存在内存泄漏。",
      "line_num": 334,
      "context": "{\"329\":\"\",\"330\":\"### on('click')\",\"331\":\"\",\"332\":\"on(type: 'click', callback: Callback&lt;void&gt;): void\",\"333\":\"\",\"334\":\"开启闪控球的点击监听事件，不使用时，关闭监听以避免内存泄漏。\",\"335\":\"\",\"336\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"337\":\"\",\"338\":\"**参数：**\",\"339\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一操作，'开启'与'注册'、'关闭'与'取消'混用。",
      "更改后示例": "注册闪控球的点击监听事件，不使用时，取消监听以避免内存泄漏。",
      "触发条件": "同一操作的不同步骤中使用了语义相近但表述不一致的动词（如开启/注册、关闭/取消），或技术术语与API方法命名不匹配（如on对应注册而非开启）。"
    },
    {
      "defect_id": 541555,
      "sentence": "获取给定js Boolean对应的C bool值。",
      "reference_sentence": "获取给定JS Boolean对应的C bool值。",
      "line_num": 424,
      "context": "{\"419\":\"| napi_create_bigint_uint64 | 通过一个C的uint64数据创建JS BigInt。 |\",\"420\":\"| napi_create_bigint_words | 通过一个C的uint64数组创建单个JS BigInt。 |\",\"421\":\"| napi_get_value_bigint_int64 | 获取给定JS BigInt对应的C int64值。 |\",\"422\":\"| napi_get_value_bigint_uint64 | 获取给定JS BigInt对应的C uint64值。 |\",\"423\":\"| napi_get_value_bigint_words | 获取给定JS BigInt对应的信息，包括符号位、64位小端序数组和数组中的元素个数。 |\",\"424\":\"\",\"425\":\"### 异常和错误相关\",\"426\":\"\",\"427\":\"| 接口 | 功能说明 |\",\"428\":\"| -------- | -------- |\",\"429\":\"| napi_throw | 抛出一个JS value。 |\"}",
      "修改建议": "混用了小写和大写的'JS Boolean'，应保持一致。",
      "更改后示例": "获取给定JS Boolean对应的C bool值。",
      "触发条件": "当同一技术术语（如\"JS Boolean\"）在相邻上下文或相同功能模块中出现大小写不一致（如混用\"js Boolean\"和\"JS Boolean\"），且存在明确统一格式的参考实例（如上下文中的\"JS BigInt\"）时触发。\n\n识别模式：\n1. 检测技术术语的缩写格式（如\"JS\"应全大写）\n2. 对比相邻条目中相同语义的术语表达（如函数参数类型\"Boolean/bool\"）\n3. 验证术语是否符合上下文已确立的命名规范（如参考句子中的\"JS BigInt\"统一格式）\n\n附加说明：该规则优先检查相邻条目（如API文档表格行）和相同功能模块（如N-API的BigInt/Boolean处理接口）的术语一致性，通过模式匹配识别首字母大小写、全称/缩写等形态差异。"
    },
    {
      "defect_id": 545654,
      "sentence": "恢复应用主窗口并加载指定页面。仅支持在闪控球点击事件回调上下文的5秒内调用，使用Promise异步回调。",
      "reference_sentence": "获得闪控球窗口信息，使用Promise进行异步回调。",
      "line_num": 449,
      "context": "{\"444\":\"\",\"445\":\"### restoreMainWindow\",\"446\":\"\",\"447\":\"restoreMainWindow(want: Want): Promise&lt;void&gt;\",\"448\":\"\",\"449\":\"恢复应用主窗口并加载指定页面。仅支持在闪控球点击事件回调上下文的5秒内调用，使用Promise异步回调。\",\"450\":\"\",\"451\":\"**需要权限：** ohos.permission.USE_FLOAT_BALL\",\"452\":\"\",\"453\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"454\":\"\"}",
      "修改建议": "混用了'使用Promise进行异步回调'和'使用Promise异步回调'，句式不一致。",
      "更改后示例": "恢复应用主窗口并加载指定页面。仅支持在闪控球点击事件回调上下文的5秒内调用，使用Promise进行异步回调。",
      "触发条件": "同一技术术语或操作描述在相邻上下文中出现句式结构不一致（如\"使用Promise进行异步回调\" vs \"使用Promise异步回调\"），且存在已定义的标准表达形式（参考句中的\"进行\"动词结构）。"
    },
    {
      "defect_id": 545646,
      "sentence": "关闭闪控球点击的监听事件。",
      "reference_sentence": "取消闪控球生命周期状态变化的监听事件。",
      "line_num": 373,
      "context": "{\"368\":\"\",\"369\":\"### off('click')\",\"370\":\"\",\"371\":\"off(type: 'click', callback?: Callback&lt;void&gt;): void\",\"372\":\"\",\"373\":\"关闭闪控球点击的监听事件。\",\"374\":\"\",\"375\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"376\":\"\",\"377\":\"**参数：**\",\"378\":\"\"}",
      "修改建议": "使用了不同的词汇描述同一操作，'关闭'与'取消'混用。",
      "更改后示例": "取消闪控球点击的监听事件。",
      "触发条件": "同一操作在相邻或相关描述中使用了不同动词（如\"关闭\"与\"取消\"），或技术术语（如API方法名\"off\"）与对应描述动词存在语义冲突。"
    },
    {
      "defect_id": 545655,
      "sentence": "启动、更新闪控球的配置参数。",
      "reference_sentence": "获得闪控球窗口信息，使用Promise进行异步回调。",
      "line_num": 503,
      "context": "{\"498\":\"}\",\"499\":\"```\",\"500\":\"\",\"501\":\"## FloatingBallParams\",\"502\":\"\",\"503\":\"启动、更新闪控球的配置参数。\",\"504\":\"\",\"505\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"506\":\"\",\"507\":\"| 名称 | 类型 | 必填 | 说明 |\",\"508\":\"|------------|------------|------------|------------|\"}",
      "修改建议": "混用了'启动、更新'和'获得'，句式不一致。",
      "更改后示例": "启动和更新闪控球的配置参数。",
      "触发条件": "当句子中并列动词或名词短语的连接符号（如顿号、逗号）或连接词（如“和”）与上下文同类结构不一致，且存在参考句式（如其他句子中相同语义场景使用统一连接方式）时触发。"
    },
    {
      "defect_id": 543055,
      "sentence": "- **错误（Error）**：表示程序无法顺利执行某些操作，可以是由底层系统、API函数或开发者自定义的。",
      "reference_sentence": "- **错误（Error）**：表示程序无法顺利执行某些操作，可以是由底层系统、API函数或开发者自定义的。",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在ArkTS编程中，异常和错误是常见的概念。异常表示发生了某种意外情况，而错误则指示程序无法正确执行某些操作。Node-API提供了一系列方法来帮助开发者在Node-API模块中处理ArkTS中的异常和错误。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **异常（Exception）**：在程序执行过程中可能会出现的意外情况，可以是语法错误、运行时错误或逻辑错误，例如除以零或对未定义变量的操作。\",\"12\":\"- **错误（Error）**：表示程序无法顺利执行某些操作，可以是由底层系统、API函数或开发者自定义的。\",\"13\":\"- **类型错误（Type Error）**：表示操作或值的类型不符合预期，通常是由错误的数据类型导致的。\",\"14\":\"- **范围错误（Range Error）**：表示一个值不在预期的范围内，例如对数组长度之外的索引进行访问。\",\"15\":\"\",\"16\":\"这些基本概念在异常和错误处理中非常重要，开发者需要通过适当的方法来捕获、处理或向用户报告这些异常和错误，以确保程序的稳定性和正确性。Node-API提供的方法可以帮助开发者在Node-API模块中处理ArkTS中的异常和错误。\",\"17\":\"\"}",
      "修改建议": "原文中使用了'异常'和'错误'两个词，但没有明确区分它们的用法。根据规则，术语需要全文一致。建议统一使用'错误'或'异常'。",
      "更改后示例": "- **错误（Error）**：表示程序无法顺利执行某些操作，可以是由底层系统、API函数或开发者自定义的错误。",
      "触发条件": "同一文档中交替使用多个未明确区分的同义/近义术语（如\"错误\"与\"异常\"），且术语定义段与后续使用场景存在不一致表述。\n\n识别模式：\n1. 术语定义冲突：在概念定义段落（如问题上下文第9、11行）同时出现多个未明确区分的近义词\n2. 上下文混用：在相邻段落（如问题句第12行与参考句第9行）对同一概念使用不同术语\n3. 定义不完整：术语解释未形成闭环（如原句\"开发者自定义的\"缺少宾语，导致与前置定义脱节）"
    },
    {
      "defect_id": 542803,
      "sentence": "1. 在SDK的ets/build-tools/ets-loader/bin/ark/build-win/bin目录下放置test.js文件",
      "reference_sentence": "无",
      "line_num": 286,
      "context": "{\"281\":\"```\",\"282\":\"<!-- @[ark_node_api_module_run_script_path](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"283\":\"\",\"284\":\"test.js代码，将js代码编成.abc文件，步骤如下：\",\"285\":\"\",\"286\":\"1. 在SDK的ets/build-tools/ets-loader/bin/ark/build-win/bin目录下放置test.js文件\",\"287\":\"2. 执行命令如es2abc.exe test.js  --output test.abc后便可生成test.abc文件\",\"288\":\"\",\"289\":\"放入指定路径中：/entry/resources/rawfile\",\"290\":\"\",\"291\":\"```js\"}",
      "修改建议": "术语不一致，'ets/build-tools/ets-loader/bin/ark/build-win/bin'应为'ets/build-tools/ets-loader/bin/ark/build-win/bin/'",
      "更改后示例": "1. 在SDK的ets/build-tools/ets-loader/bin/ark/build-win/bin/目录下放置test.js文件",
      "触发条件": "当文档中路径描述存在目录结尾斜杠缺失时（例如\"bin目录\"应保持\"bin/目录\"的格式一致性），或与上下文/规范路径格式存在术语结尾符号不一致时触发。"
    },
    {
      "defect_id": 542867,
      "sentence": "判断给定ArkTS value是否是Sendable的。",
      "reference_sentence": "napi_is_sendable           | 判断给定ArkTS value是否是Sendable的。",
      "line_num": 782,
      "context": "{\"777\":\"\",\"778\":\"### 使用示例\",\"779\":\"\",\"780\":\"#### napi_is_sendable\",\"781\":\"\",\"782\":\"判断给定ArkTS value是否是Sendable的。\",\"783\":\"\",\"784\":\"cpp部分代码\",\"785\":\"\",\"786\":\"```cpp\",\"787\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "行内描述与接口描述表中的描述不一致，应使用相同的描述方式。",
      "更改后示例": "判断给定的ArkTS value是否为Sendable。",
      "触发条件": "同一文档中对相同功能的描述存在句式结构不一致（如\"是否是\"与\"是否为\"差异）或术语格式不统一（如\"Sendable\"大小写不一致）。"
    },
    {
      "defect_id": 543139,
      "sentence": "用于引发致命错误以立即终止进程。在调用napi_fatal_error函数后，导致应用程序终止，因此应该慎重使用，避免在正常操作中频繁调用该函数。",
      "reference_sentence": "用于引发致命错误以立即终止进程。在调用napi_fatal_error函数后，导致应用程序终止，因此应该慎重使用，避免在正常操作中频繁调用该函数。",
      "line_num": 589,
      "context": "{\"584\":\"```\",\"585\":\"<!-- @[ark_napi_is_exception_pending](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIError/entry/src/main/ets/pages/Index.ets) -->\",\"586\":\"\",\"587\":\"### napi_fatal_error\",\"588\":\"\",\"589\":\"用于引发致命错误以立即终止进程。在调用napi_fatal_error函数后，导致应用程序终止，因此应该慎重使用，避免在正常操作中频繁调用该函数。\",\"590\":\"\",\"591\":\"cpp部分代码\",\"592\":\"\",\"593\":\"```cpp\",\"594\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句式不一致，应使用祈使句",
      "更改后示例": "用于引发致命错误以立即终止进程。调用napi_fatal_error函数后，应用程序将终止，因此应慎重使用，避免在正常操作中频繁调用该函数。",
      "触发条件": "当同一段落内出现祈使句与陈述句混合使用时，或技术文档中连续说明性语句存在句式结构不统一（如介词短语与主谓结构混用）时触发。识别模式为检测\"导致/使得\"类陈述句式与\"应/将\"类祈使句式在相邻分句中的交替使用。"
    },
    {
      "defect_id": 549094,
      "sentence": "@Monitor仅会保存变量可访问时的值，当状态变量成不可访问的状态时，并不会记录其value的变化。",
      "reference_sentence": "当状态变量成不可访问的状态时，并不会记录其value的变化。",
      "line_num": 1189,
      "context": "{\"1184\":\"    }\",\"1185\":\"  }\",\"1186\":\"}\",\"1187\":\"```\",\"1188\":\"### 无法监听变量从可访问到不访问和从不可访问到可访问\",\"1189\":\"@Monitor仅会保存变量可访问时的值，当状态变量成不可访问的状态时，并不会记录其value的变化。在下面的例子中，点击三个Button，均不会触发`onChange`的回调。\",\"1190\":\"\",\"1191\":\"```ts\",\"1192\":\"@ObservedV2\",\"1193\":\"class User {\",\"1194\":\"  @Trace age: number = 10;\"}",
      "修改建议": "句子中“状态变量成不可访问的状态”表述不一致，应该使用统一的表达方式。",
      "更改后示例": "@Monitor仅会保存变量可访问时的值，当状态变量变为不可访问的状态时，并不会记录其值的变化。",
      "触发条件": "同一术语或表达在相邻上下文中存在中英文混用（如\"value\"与\"值\"）或动词不一致（如\"成\"与\"变为\"）时触发。\n\n识别模式：\n1. 检查同一语义概念是否使用不同词性/词形（如名词\"value\"与代词\"其值\"）\n2. 对比相邻语句中的动词使用（如\"成\"与\"变为\"是否指向相同状态变化）\n3. 验证技术术语中英文是否统一（专有名词是否全篇保持英文或中文翻译）"
    },
    {
      "defect_id": 542957,
      "sentence": "在ArkTS对象上绑定一个Node-API模块对象实例并指定实例大小，开发者可以指定绑定的回调函数是否异步执行，如果异步执行，则回调函数必须是线程安全的。",
      "reference_sentence": "napi_wrap_enhance | 在ArkTS对象上绑定一个Node-API模块对象实例并指定实例大小，开发者可以指定绑定的回调函数是否异步执行，如果异步执行，则回调函数必须是线程安全的。",
      "line_num": 1326,
      "context": "{\"1321\":\"\",\"1322\":\"### 使用示例\",\"1323\":\"\",\"1324\":\"#### napi_wrap_enhance\",\"1325\":\"\",\"1326\":\"在ArkTS对象上绑定一个Node-API模块对象实例并指定实例大小，开发者可以指定绑定的回调函数是否异步执行，如果异步执行，则回调函数必须是线程安全的。\",\"1327\":\"\",\"1328\":\"cpp部分代码\",\"1329\":\"\",\"1330\":\"```cpp\",\"1331\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "重复描述，导致前后内容冗余。",
      "更改后示例": "在ArkTS对象上绑定一个Node-API模块对象实例并指定实例大小，开发者可以指定回调函数是否异步执行，如果异步执行，回调函数必须是线程安全的。",
      "触发条件": "同一句子中重复使用修饰词（如\"绑定的\"）或冗余连接词（如\"则\"），导致成分赘余。识别模式需检测相邻分句是否存在重复修饰同一名词（如\"回调函数\"被\"绑定的\"重复修饰）或冗余逻辑连接词。"
    },
    {
      "defect_id": 549425,
      "sentence": "会话对象的生命周期从CreateSession函数返回开始，到调用DestroySession为止。",
      "reference_sentence": "会话对象的生命周期从`OH_QoS_GewuCreateSession`函数返回开始，到调用`OH_QoS_GewuDestroySession`为止。",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"`OH_QoS_GewuCreateSession`接口用于创建会话。\",\"43\":\"\",\"44\":\"该接口异步处理请求，即该接口只是发起创建会话，并不会等到会话资源分配完成、模型加载完成才返回。格物优化端侧推理资源管理，可以动态按需加载资源。\",\"45\":\"\",\"46\":\"会话对象的生命周期从CreateSession函数返回开始，到调用DestroySession为止。\",\"47\":\"\",\"48\":\"##### 声明\",\"49\":\"\",\"50\":\"```C\",\"51\":\"typedef struct {\"}",
      "修改建议": "混用了`CreateSession`和`OH_QoS_GewuCreateSession`，`DestroySession`和`OH_QoS_GewuDestroySession`术语",
      "更改后示例": "会话对象的生命周期从`OH_QoS_GewuCreateSession`函数返回开始，到调用`OH_QoS_GewuDestroySession`为止。",
      "触发条件": "当文档中同一术语存在全称和缩写混用（如`CreateSession`与`OH_QoS_GewuCreateSession`），且上下文已明确定义过全称形式时触发。\n\n识别模式：通过交叉验证术语在代码声明段（如第42行）、参考句及问题句中的命名形式，检测是否出现未保持全称/命名空间前缀一致的情况（如缺失`OH_QoS_Gewu`前缀）。"
    },
    {
      "defect_id": 542839,
      "sentence": "处理异步操作：：通过Libuv可以实现异步操作，避免阻塞主线程，使得程序可以同时执行多个任务而不会出现阻塞现象。",
      "reference_sentence": "实现事件循环：：Libuv提供了事件循环机制，可以处理事件、触发回调函数，并管理事件队列，使得Node-API模块能够实现事件驱动的编程模型。",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- **模块加载：** 在Node-API模块中，模块是指包含特定功能的ArkTS文件，通过import导入lib共享库中的模块。了解Node-API模块中的加载机制以及模块之间的依赖关系对于理解node_api_get_module_file_name接口的使用很有帮助。\",\"10\":\"- **文件路径和URL：** node_api_get_module_file_name返回的是加载项的绝对路径的URL。\",\"11\":\"- **比较ArkTS值严格相等：** 比较两个ArkTS值是否严格相等。严格相等比较不会进行类型转换，它要求两个值的类型和值完全相同才会返回true。\",\"12\":\"- **处理异步操作：**：通过Libuv可以实现异步操作，避免阻塞主线程，使得程序可以同时执行多个任务而不会出现阻塞现象。\",\"13\":\"- **实现事件循环：**：Libuv提供了事件循环机制，可以处理事件、触发回调函数，并管理事件队列，使得Node-API模块能够实现事件驱动的编程模型。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"| 接口 | 描述 |\"}",
      "修改建议": "句式不一致，多了冒号。",
      "更改后示例": "处理异步操作：通过Libuv可以实现异步操作，避免阻塞主线程，使得程序可以同时执行多个任务而不会出现阻塞现象。",
      "触发条件": "同一文档中存在列表项标题后连续使用多个冒号（如双冒号\"::\"），而其他同类条目仅使用单个冒号时触发。\n\n识别模式：\n1. 检测Markdown列表项格式（如\"**关键词：**\"结构）\n2. 匹配标题末尾连续重复的标点符号（如\"：\"后紧跟额外冒号）\n3. 对比上下文同类条目标点数量一致性（如其他列表项均使用单冒号）"
    },
    {
      "defect_id": 549097,
      "sentence": "// age可访问->不可访问",
      "reference_sentence": "// age可访问->不可访问",
      "line_num": 1221,
      "context": "{\"1216\":\"      Button('set user to User').onClick(() => {\",\"1217\":\"        // age不可访问->可访问\",\"1218\":\"        this.user = new User();\",\"1219\":\"      })\",\"1220\":\"      Button('set user to null').onClick(() => {\",\"1221\":\"        // age可访问->不可访问\",\"1222\":\"        this.user = null;\",\"1223\":\"      })\",\"1224\":\"    }\",\"1225\":\"  }\",\"1226\":\"}\"}",
      "修改建议": "句子中“age可访问->不可访问”表述不一致，应该使用统一的表达方式。",
      "更改后示例": "// age 从可访问变为不可访问",
      "触发条件": "同一注释块或相邻上下文中存在描述状态变化的连接符号（如\"->\"）与文字表述（如\"从...变为...\"）混合使用时，触发语言表达一致性规则。\n\n识别模式：检测到注释中同时出现\"可访问->不可访问\"的符号连接形式和\"不可访问->可访问\"的文字连接形式时，通过对比相邻行注释（如1217行与1221行）的连接方式差异，识别符号与文字混用的不一致表述。"
    },
    {
      "defect_id": 549096,
      "sentence": "// age不可访问->可访问",
      "reference_sentence": "// age不可访问->可访问",
      "line_num": 1217,
      "context": "{\"1212\":\"      Button('set user to undefined').onClick(() => {\",\"1213\":\"        // age可访问->不可访问\",\"1214\":\"        this.user = undefined;\",\"1215\":\"      })\",\"1216\":\"      Button('set user to User').onClick(() => {\",\"1217\":\"        // age不可访问->可访问\",\"1218\":\"        this.user = new User();\",\"1219\":\"      })\",\"1220\":\"      Button('set user to null').onClick(() => {\",\"1221\":\"        // age可访问->不可访问\",\"1222\":\"        this.user = null;\"}",
      "修改建议": "句子中“age不可访问->可访问”表述不一致，应该使用统一的表达方式。",
      "更改后示例": "// age 从不可访问变为可访问",
      "触发条件": "当同一上下文出现相同语义的状态变化描述时，若存在混合使用不同连接符号（如\"->\"）与连接词（如\"变为\"）的情况，或与相邻注释的表达结构不一致时触发。\n\n识别模式：1）检测到\"X→Y\"符号化表达与\"从X变为Y\"文字化表达共存 2）同一代码块内相邻注释采用统一表达结构（如\"从...变为...\"）时出现结构偏离"
    },
    {
      "defect_id": 542956,
      "sentence": "移除并获取ArkTS对象包裹的native实例，移除后回调将不再触发，需手动delete释放内存。",
      "reference_sentence": "napi_unwrap_sendable获取ArkTS对象包裹的native实例。",
      "line_num": 1258,
      "context": "{\"1253\":\"```\",\"1254\":\"<!-- @[ark_napi_unwrap_sendable](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIExtendCapabilities/entry/src/main/ets/pages/Index.ets) -->\",\"1255\":\"\",\"1256\":\"#### napi_remove_wrap_sendable\",\"1257\":\"\",\"1258\":\"移除并获取ArkTS对象包裹的native实例，移除后回调将不再触发，需手动delete释放内存。\",\"1259\":\"\",\"1260\":\"cpp部分代码\",\"1261\":\"\",\"1262\":\"```cpp\",\"1263\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了'移除'与'获取'，容易引起表意模糊。",
      "更改后示例": "移除并获取ArkTS对象包裹的native实例，移除后回调将不再触发，需要手动delete释放内存。",
      "触发条件": "当同一动词短语中连续使用不同语义层级的动作描述（如\"移除并获取\"），或相邻句子中关键动词与上下文参考用法（如\"获取\"）存在语义冲突时触发。识别模式需检测动词搭配是否存在逻辑矛盾（如移除与获取并存），以及是否与API命名核心动词（如napi_unwrap_sendable中的\"unwrap\"）形成表意偏差。"
    },
    {
      "defect_id": 549095,
      "sentence": "// age可访问->不可访问",
      "reference_sentence": "// age可访问->不可访问",
      "line_num": 1213,
      "context": "{\"1208\":\"\",\"1209\":\"  build() {\",\"1210\":\"    Column() {\",\"1211\":\"      Text(`User age ${this.user?.age}`).fontSize(20)\",\"1212\":\"      Button('set user to undefined').onClick(() => {\",\"1213\":\"        // age可访问->不可访问\",\"1214\":\"        this.user = undefined;\",\"1215\":\"      })\",\"1216\":\"      Button('set user to User').onClick(() => {\",\"1217\":\"        // age不可访问->可访问\",\"1218\":\"        this.user = new User();\"}",
      "修改建议": "句子中“age可访问->不可访问”表述不一致，应该使用统一的表达方式。",
      "更改后示例": "// age: 可访问 -> 不可访问",
      "触发条件": "当同一注释块或相邻代码注释中存在多个状态变更描述，且属性名称与状态变化表述之间缺乏统一的分隔符（如冒号）时触发。\n\n识别模式：\n1. 检测到连续注释中存在\"属性+状态变化\"结构（如\"X可访问->不可访问\"）\n2. 同一属性在相邻注释中出现不同表述结构（如有的带冒号\"age: 可访问->不可访问\"，有的未带）\n3. 状态变化箭头符号（->）前后存在格式不一致（如属性名与状态间缺少分隔符）"
    },
    {
      "defect_id": 549090,
      "sentence": "状态管理接入Openharmony的Hidumper，将状态变量关联的组件，自定义组件树等信息加入到dump中，完成状态管理相关信息的输出，方便开发者了解使用状态变量影响的UI范围，便于写出高性能应用代码。",
      "reference_sentence": "状态管理接入OpenHarmony的Hidumper，将状态变量关联的组件，自定义组件树等信息加入到dump中，完成状态管理相关信息的输出，方便开发者了解使用状态变量影响的UI范围，便于写出高性能应用代码。",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"为提升开发者定位状态管理的问题的效率和易用性，UI提供专门针对状态变量的调试和调优能力，将状态变量的黑盒信息暴露给开发者，让开发者白盒化地了解状态变量和UI组件变化过程，提升开发者开发高性能应用的效率。\",\"8\":\"\",\"9\":\"### 状态变量dump调试能力\",\"10\":\"\",\"11\":\"状态管理接入Openharmony的Hidumper，将状态变量关联的组件，自定义组件树等信息加入到dump中，完成状态管理相关信息的输出，方便开发者了解使用状态变量影响的UI范围，便于写出高性能应用代码。\",\"12\":\"\",\"13\":\"下面介绍dump状态变量每个参数的含义：\",\"14\":\"\",\"15\":\"- jsdump: 请求状态管理中的dump信息；\",\"16\":\"- viewHierarchy: 打印自定义组件树信息，默认只打印根自定义组件；\"}",
      "修改建议": "混用了'Openharmony'和'OpenHarmony'，术语大小写不一致",
      "更改后示例": "状态管理接入OpenHarmony的Hidumper，将状态变量关联的组件、自定义组件树等信息加入到dump中，完成状态管理相关信息的输出，方便开发者了解使用状态变量影响的UI范围，便于写出高性能应用代码。",
      "触发条件": "当同一术语在文档中出现不一致的大小写形式（如\"Openharmony\"与\"OpenHarmony\"混用）或存在多个拼写变体时触发该规则。\n\n识别模式：通过对比术语在上下文中的呈现形式，检测专有名词/技术术语是否保持首字母全大写、驼峰式等规范格式，特别关注存在官方明确命名规范（如OpenHarmony）但实际文本出现小写字母开头的异常形态。"
    },
    {
      "defect_id": 552586,
      "sentence": "从服务器获取用户可以更改的系统隐私保护和应用隐私保护配置。使用Promise异步回调。",
      "reference_sentence": "从服务器获取用户可以更改的系统隐私保护和应用隐私保护配置。使用Promise异步回调。",
      "line_num": 162,
      "context": "{\"157\":\"\",\"158\":\"## media.getAVScreenCaptureConfigurableParameters<sup>20+</sup>\",\"159\":\"\",\"160\":\"getAVScreenCaptureConfigurableParameters(sessionId: number): Promise\\\\<string>\",\"161\":\"\",\"162\":\"从服务器获取用户可以更改的系统隐私保护和应用隐私保护配置。使用Promise异步回调。\",\"163\":\"\",\"164\":\">**注意：**\",\"165\":\">\",\"166\":\"> 此接口仅提供给创建弹窗的系统应用调用。\",\"167\":\"\"}",
      "修改建议": "使用了“使用Promise异步回调”而不是“异步返回函数执行结果”，建议保持一致。",
      "更改后示例": "从服务器获取用户可以更改的系统隐私保护和应用隐私保护配置，异步返回函数执行结果。",
      "触发条件": "当同一文档中对异步机制存在多种表述方式（如\"使用Promise异步回调\"和\"异步返回函数执行结果\"），且存在已定义的规范表述时。\n\n识别模式：\n1. 检测技术描述段落中是否同时包含\"Promise\"相关术语和功能等效的非规范表述（如\"异步回调\"）\n2. 对比接口定义(如\"Promise\\<string>\")与说明文本的表述一致性\n3. 匹配预定义的规范术语库（如要求统一使用\"异步返回函数执行结果\"作为标准表述）"
    },
    {
      "defect_id": 553470,
      "sentence": "ArkUI Inspector是DevEco Studio内置的页面布局检查工具，帮助开发者查看应用的UI层级结构、组件属性和布局效果。",
      "reference_sentence": "详细Inspector使用方法及案例参考：[页面布局检查器ArkUI Inspector使用指导](../performance/arkUI-inspector.md)。",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"ArkUI内部针对关键的UI处理流程添加了trace信息，帮助开发者通过trace工具观测应用的UI耗时，辅助定位问题。详细trace说明及案例参考：[常用Trace使用指导](../performance/common-trace-using-instructions.md)。\",\"6\":\"\",\"7\":\"## Inspector调试能力\",\"8\":\"\",\"9\":\"ArkUI Inspector是DevEco Studio内置的页面布局检查工具，帮助开发者查看应用的UI层级结构、组件属性和布局效果。详细Inspector使用方法及案例参考：[页面布局检查器ArkUI Inspector使用指导](../performance/arkUI-inspector.md)。\"}",
      "修改建议": "混用了“页面布局检查器”和“页面布局检查工具”描述同一工具。",
      "更改后示例": "ArkUI Inspector是DevEco Studio内置的页面布局检查器，帮助开发者查看应用的UI层级结构、组件属性和布局效果。",
      "触发条件": "当同一文档中针对同一功能/工具出现\"检查器\"与\"检查工具\"等近义术语混用，且在相邻段落或参考链接标题中存在术语表述冲突时触发。\n\n识别模式：\n1. 核心名词存在语义重复变体（如\"器\"与\"工具\"后缀差异）\n2. 同一功能实体在相邻3个段落内被不同术语指代（如第9段与参考链接标题）\n3. 链接锚文本与正文描述存在术语不一致（如正文用\"工具\"而链接标题用\"检查器\"）"
    },
    {
      "defect_id": 549092,
      "sentence": "当前状态管理在Profier工具中，会展示如下信息内容：",
      "reference_sentence": "当前状态管理在Profiler工具中，会展示如下信息内容：",
      "line_num": 190,
      "context": "{\"185\":\"```\",\"186\":\"\",\"187\":\"### 状态变量Profier调优能力\",\"188\":\"状态管理提供状态变量相关的信息给IDE的profier工具，在profier工具的泳道图上展示状态变量的变化及展示关联组件的更新耗时，以告诉开发者更新导致卡顿的原因。\",\"189\":\"\",\"190\":\"当前状态管理在Profier工具中，会展示如下信息内容：\",\"191\":\"- Start Time：状态变量修改的时间；\",\"192\":\"- Attributes：状态变量的属性名；\",\"193\":\"- Owned by Component：所属自定义组件名；\",\"194\":\"- Owned by Class：所属类名；\",\"195\":\"- Property Type：装饰器名称；\"}",
      "修改建议": "混用了'Profier'和'Profiler'，术语不一致",
      "更改后示例": "当前状态管理在Profiler工具中，会展示如下信息内容：",
      "触发条件": "同一术语在文档中出现两种及以上拼写变体，且变体形式出现在相邻段落或同一语义单元中时触发。\n\n识别模式：通过文本匹配检测术语的非常规拼写形式（如Profier），结合上下文分析（如相邻标题\"状态变量Profier调优能力\"和问题句中的Profier）确认是否为同一概念的不同拼写，当同一语义单元内存在≥2种变体时判定为术语不一致。"
    },
    {
      "defect_id": 550870,
      "sentence": "查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "line_num": 189,
      "context": "{\"184\":\"| [int32_t OH_Input_InjectMouseEvent(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseevent) | - | 注入鼠标事件。 |\",\"185\":\"| [int32_t OH_Input_GetMouseEventDisplayId(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventdisplayid) | - | 获取鼠标事件的屏幕Id。 |\",\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触摸事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 查询触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "触发条件": "当相邻或相关API接口描述中，对相同操作类型（如获取/查询数据）使用不同动词（如\"查询\"和\"获取\"），且存在同系列接口使用统一动词的参考实例时触发。\n\n识别模式：\n1. 动词冲突检测：在相同功能模块（如鼠标事件操作）中，检测描述性动词是否与相邻接口（如GetMouseEventGlobalY使用\"获取\"）或同类型接口（如QueryMaxTouchPoints使用\"查询\"）保持术语一致\n2. 功能动作匹配：当接口命名包含明确动作词（如Get/Query）时，要求描述语句的动词与接口命名动词严格对应（Get对应\"获取\"，Query对应\"查询\"）"
    },
    {
      "defect_id": 550873,
      "sentence": "查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "查询触摸事件的触摸位置距离主屏幕左上角的X坐标。",
      "line_num": 196,
      "context": "{\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触摸事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 查询触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "触发条件": "当相邻或同类型API描述中，相同操作动词（如\"查询\"与\"获取\"）在相同语义场景下出现混用时，且存在明确参考基准（如函数命名规则或相邻条目统一用词）。\n\n识别模式：通过对比函数命名（如Get/Set前缀）与对应描述的动词对应关系，以及检查相邻条目中相同操作（如X/Y坐标获取）的用词一致性，发现动词与功能不匹配的异常（如Get函数使用\"查询\"而相邻Get函数使用\"获取\"）。"
    },
    {
      "defect_id": 549091,
      "sentence": "步骤1：点击ArkUI模版创建session，并启动录制，录制过程中点击按钮，修改状态变量'message', 触发组件刷新；",
      "reference_sentence": "步骤1：点击ArkUI模板创建session，并启动录制，录制过程中点击按钮，修改状态变量'message', 触发组件刷新；",
      "line_num": 201,
      "context": "{\"196\":\"- Current Values：状态变量当前值；\",\"197\":\"- Update Component Count：自定义组件更新的次数；\",\"198\":\"\",\"199\":\"录制ArkUI State泳道图步骤如下：\",\"200\":\"\",\"201\":\"步骤1：点击ArkUI模版创建session，并启动录制，录制过程中点击按钮，修改状态变量'message', 触发组件刷新；\",\"202\":\"\",\"203\":\"步骤2： 录制结束等待数据处理完成。点击ArkUI State泳道，可在下方数据区查看录制过程中状态变量变化。如图1所示，Summary区域可查看状态变量名称，变化次数，状态变量类型，所属组件或所属类等信息，同时在Current Value区域可查看每个状态变量，在右侧more区域将展示关联的UI组件树信息，每个组件的创建，measure和layout时间。\",\"204\":\"\",\"205\":\"**图1** ArkUI State泳道图示意图\",\"206\":\"\"}",
      "修改建议": "混用了'模版'和'模板'，术语不一致",
      "更改后示例": "步骤1：点击ArkUI模板创建session，并启动录制，录制过程中点击按钮，修改状态变量'message', 触发组件刷新；",
      "触发条件": "同一文档中出现同一术语的两种及以上不同写法（如\"模版\"与\"模板\"），且存在至少一个正确用法的参考实例（如上下文中的\"ArkUI模板\"）。识别模式需检测术语在文档中的重复出现形态差异，并通过邻近上下文匹配确定标准术语形式。"
    },
    {
      "defect_id": 551274,
      "sentence": "获取给定TypedArray的各种属性。",
      "reference_sentence": "用于在Node-API模块中判断ArkTS侧给定的napi_value是否为TypedArray。",
      "line_num": 661,
      "context": "{\"656\":\"```\",\"657\":\"<!-- @[ark_napi_is_typed_array](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"658\":\"\",\"659\":\"### napi_get_typedarray_info\",\"660\":\"\",\"661\":\"获取给定TypedArray的各种属性。\",\"662\":\"\",\"663\":\"cpp部分代码\",\"664\":\"\",\"665\":\"```cpp\",\"666\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "前文使用了'获取给定TypedArray'，后文也应保持一致，用'给定的TypedArray'而非'给定TypedArray'。",
      "更改后示例": "获取给定的TypedArray的各种属性。",
      "触发条件": "当同一术语在相邻或相近上下文中作为定语出现时，若其修饰结构（是否包含结构助词\"的\"）存在不一致，则触发该规则。例如前文使用\"给定TypedArray\"（无\"的\"），后文出现\"给定TypedArray\"或\"给定的TypedArray\"时需检查一致性。"
    },
    {
      "defect_id": 551192,
      "sentence": "用于在Node-API模块中创建指定长度的ArkTS数组时。",
      "reference_sentence": "用于在Node-API模块中向ArkTS层创建一个ArkTS数组对象。",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"使用Node-API接口进行数组相关开发时，可以处理各种涉及ArkTS数组的操作和交互场景。以下是几个具体的使用场景介绍：\",\"20\":\"| 接口 | 描述 |\",\"21\":\"| -------- | -------- |\",\"22\":\"| napi_create_array | 用于在Node-API模块中向ArkTS层创建一个ArkTS数组对象。 |\",\"23\":\"| napi_create_array_with_length | 用于在Node-API模块中向ArkTS层创建指定长度的ArkTS数组时。 |\",\"24\":\"| napi_get_array_length | 用于在Node-API模块中获取ArkTS数组对象的长度。 |\",\"25\":\"| napi_is_array | 用于在Node-API模块中判断一个napi_value值是否为数组。 |\",\"26\":\"| napi_set_element | 用于在Node-API模块中对ArkTS数组对象的特定索引处设置一个值。 |\",\"27\":\"| napi_get_element | 用于在Node-API模块中从ArkTS数组对象的特定索引处获取一个值。 |\",\"28\":\"| napi_has_element | 用于在Node-API模块中判断ArkTS数组对象请求索引处是否包含元素。 |\"}",
      "修改建议": "句子结构不一致，建议统一使用祈使句。",
      "更改后示例": "用于在Node-API模块中创建指定长度的ArkTS数组。",
      "触发条件": "同一列表或上下文中，条目描述句式不一致（如祈使句与非祈使句混用），且句尾包含冗余时间状语（如\"时\"）破坏结构统一性。"
    },
    {
      "defect_id": 550871,
      "sentence": "查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "line_num": 191,
      "context": "{\"186\":\"| [Input_Result OH_Input_QueryMaxTouchPoints(int32_t *count)](#oh_input_querymaxtouchpoints) | - | 查询设备支持的最大触屏报点数。 |\",\"187\":\"| [int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)](#oh_input_injectmouseeventglobal) | - | 使用全局坐标注入鼠标事件。 |\",\"188\":\"| [void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)](#oh_input_setmouseeventglobalx) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触摸事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 查询触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "触发条件": "当同一功能模块中API方法命名动词（如Get/Query）与对应描述文本动词（如获取/查询）存在近义词混用，且相邻/相关条目已确立固定术语对应关系时触发。\n\n识别模式：1) 检查API方法名中的核心动词（如GetXXX）是否与描述文本动词（如\"获取XXX\"）严格对应 2) 验证相邻条目（如X/Y坐标描述对）是否采用相同动词结构 3) 发现同一语义操作（如数据读取）使用不同动词（查询/获取）时标记异常"
    },
    {
      "defect_id": 549093,
      "sentence": "步骤2： 录制结束等待数据处理完成。点击ArkUI State泳道，可在下方数据区查看录制过程中状态变量变化。如图1所示，Summary区域可查看状态变量名称，变化次数，状态变量类型，所属组件或所属类等信息，同时在Current Value区域可查看每个状态变量，在右侧more区域将展示关联的UI组件树信息，每个组件的创建，measure和layout时间。",
      "reference_sentence": "步骤2： 录制结束等待数据处理完成。点击ArkUI State泳道，可在下方数据区查看录制过程中状态变量变化。如图1所示，Summary区域可查看状态变量名称，变化次数，状态变量类型，所属组件或所属类等信息，同时在Current Value区域可查看每个状态变量，在右侧more区域将展示关联的UI组件树信息，每个组件的创建，测量和布局时间。",
      "line_num": 203,
      "context": "{\"198\":\"\",\"199\":\"录制ArkUI State泳道图步骤如下：\",\"200\":\"\",\"201\":\"步骤1：点击ArkUI模版创建session，并启动录制，录制过程中点击按钮，修改状态变量'message', 触发组件刷新；\",\"202\":\"\",\"203\":\"步骤2： 录制结束等待数据处理完成。点击ArkUI State泳道，可在下方数据区查看录制过程中状态变量变化。如图1所示，Summary区域可查看状态变量名称，变化次数，状态变量类型，所属组件或所属类等信息，同时在Current Value区域可查看每个状态变量，在右侧more区域将展示关联的UI组件树信息，每个组件的创建，measure和layout时间。\",\"204\":\"\",\"205\":\"**图1** ArkUI State泳道图示意图\",\"206\":\"\",\"207\":\"![UI-StateProfier1](figures/UI-StateProfier1.gif)\",\"208\":\"步骤3：定位到可能造成卡顿的状态变量变化时间点，框选对应的时间段，选择ArkUI Component泳道，查看对应的组件刷新时间，如果组件刷新时间长，则说明组件创建性能需要优化。\"}",
      "修改建议": "混用了'measure'和'测量'，'layout'和'布局'，术语不一致",
      "更改后示例": "步骤2： 录制结束等待数据处理完成。点击ArkUI State泳道，可在下方数据区查看录制过程中状态变量变化。如图1所示，Summary区域可查看状态变量名称，变化次数，状态变量类型，所属组件或所属类等信息，同时在Current Value区域可查看每个状态变量，在右侧more区域将展示关联的UI组件树信息，每个组件的创建、测量和布局时间。",
      "触发条件": "同一术语在相邻语句或并列结构中存在中英文混用（如\"measure\"与\"测量\"并存），或在技术概念表达时未保持全篇术语形式统一（英文/中文译名择一）。"
    },
    {
      "defect_id": 551273,
      "sentence": "用于在Node-API模块中判断ArkTS侧给定的napi_value是否为TypedArray对象。",
      "reference_sentence": "用于在Node-API模块中通过现有的ArrayBuffer创建指定类型的ArkTS TypedArray。",
      "line_num": 605,
      "context": "{\"600\":\"```\",\"601\":\"<!-- @[change_use_napi_process](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/cpp/napi_init.cpp) -->\",\"602\":\"\",\"603\":\"### napi_is_typedarray\",\"604\":\"\",\"605\":\"用于在Node-API模块中判断ArkTS侧给定的napi_value是否为TypedArray对象。\",\"606\":\"\",\"607\":\"cpp部分代码\",\"608\":\"\",\"609\":\"```cpp\",\"610\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "前文使用了'TypedArray'，后文也应保持一致，用'TypedArray'而非'TypedArray对象'。",
      "更改后示例": "用于在Node-API模块中判断ArkTS侧给定的napi_value是否为TypedArray。",
      "触发条件": "当同一术语在相邻或关联上下文中存在不一致表达（如带/不带修饰词、单复数差异）时触发，尤其当参考句或前文已明确该术语的标准形式（如\"TypedArray\"）时。"
    },
    {
      "defect_id": 550875,
      "sentence": "查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。",
      "line_num": 200,
      "context": "{\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\",\"204\":\"\",\"205\":\"### Input_KeyStateAction\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。",
      "触发条件": "当相邻或同类型功能描述中，相同操作动词出现近义词混用（如\"查询\"与\"获取\"），且存在统一用法的参考句式（如X/Y坐标描述需保持对称）时触发。\n\n识别模式：\n1. 检测相邻条目（如X/Y坐标对）或同类接口（Get/Set系列）的动词一致性\n2. 匹配API命名与功能描述动词的对应关系（如Get前缀对应\"获取\"而非\"查询\"）\n3. 验证对称参数描述（如X/Y坐标应保持完全相同的句式结构）"
    },
    {
      "defect_id": 549099,
      "sentence": "以上主要介绍状态管理dump和profier能力，方便开发者调测，提升开发者开发高性能应用的效率。",
      "reference_sentence": "状态管理提供状态变量相关的信息给IDE的profier工具",
      "line_num": 216,
      "context": "{\"211\":\">\",\"212\":\"> 由于隐私安全政策，已上架应用市场的应用不支持录制ArkUI State泳道。\",\"213\":\"\",\"214\":\"#  总结\",\"215\":\"\",\"216\":\"以上主要介绍状态管理dump和profier能力，方便开发者调测，提升开发者开发高性能应用的效率。\",\"217\":\"\",\"218\":\"\",\"219\":\"\",\"220\":\"\"}",
      "修改建议": "混用了'profier'和'Profiler'概念",
      "更改后示例": "以上主要介绍状态管理dump和Profiler能力，方便开发者调测，提升开发者开发高性能应用的效率。",
      "触发条件": "同一术语在文档中存在大小写不一致（如\"Profiler\"与\"profier\"）或拼写变体（如\"Profiler\"与\"profier\"），且上下文存在正确参考实例（如\"profier工具\"）时触发。 \n\n识别模式：通过NLP技术检测术语形态变化，结合术语库匹配及上下文对比（如参考句中的\"profier工具\"），当同一概念出现非标准拼写/大小写时自动标记。"
    },
    {
      "defect_id": 551275,
      "sentence": "创建dataview对象，便于访问和操作二进制数据，需要提供一个指向二进制数据的缓冲区，并指定要包含的字节数。",
      "reference_sentence": "用于在Node-API模块中通过现有的ArrayBuffer创建指定类型的ArkTS TypedArray。",
      "line_num": 754,
      "context": "{\"749\":\"```\",\"750\":\"<!-- @[ark_napi_get_typed_array_info](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"751\":\"\",\"752\":\"### napi_create_dataview\",\"753\":\"\",\"754\":\"创建dataview对象，便于访问和操作二进制数据，需要提供一个指向二进制数据的缓冲区，并指定要包含的字节数。\",\"755\":\"\",\"756\":\"cpp部分代码\",\"757\":\"\",\"758\":\"```cpp\",\"759\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "前文使用了'创建指定类型的ArkTS TypedArray'，后文也应保持一致，用'创建dataview'而非'创建dataview对象'。",
      "更改后示例": "创建dataview，便于访问和操作二进制数据，需要提供一个指向二进制数据的缓冲区，并指定要包含的字节数。",
      "触发条件": "当同一术语在相邻或相关上下文中存在冗余修饰词（如\"对象\"）时，且前文或参考示例已采用简洁表达（如\"创建dataview\"），需触发规则。  \n识别模式：检测术语是否包含与上下文/参考句不匹配的附加词汇（如\"dataview对象\" vs \"ArkTS TypedArray\"），且该词汇未在技术定义中强制要求存在。"
    },
    {
      "defect_id": 550872,
      "sentence": "查询触摸事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "line_num": 194,
      "context": "{\"189\":\"| [int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobalx) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"190\":\"| [void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)](#oh_input_setmouseeventglobaly) | - | 设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"191\":\"| [int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)](#oh_input_getmouseeventglobaly) | - | 查询鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"192\":\"| [int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)](#oh_input_injecttoucheventglobal) | - | 使用全局坐标注入触摸事件。 |\",\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 查询触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取触摸事件的触摸位置距离主屏幕左上角的X坐标。",
      "触发条件": "当同一功能模块中存在多个近义动词（如\"查询\"与\"获取\"）混用，且与接口方法命名（Get/Set）存在语义映射冲突时触发。识别模式需检测相邻接口描述中相同操作动作的动词一致性，并验证动词与接口方法名的语义对应关系（如Get对应\"获取\"，Set对应\"设置\"）。"
    },
    {
      "defect_id": 553632,
      "sentence": "### 在ArkTS1.2引用ArkTS1.1中的全局自定义构建函数显示UI",
      "reference_sentence": "全局自定义构建函数互操作适用于主模块使用ArkTS1.2、子模块使用ArkTS1.1的场景。",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"- ArkTS1.1全局自定义构建函数的参数最多不超过10个。\",\"28\":\"\",\"29\":\"## 开发场景\",\"30\":\"\",\"31\":\"### 在ArkTS1.2引用ArkTS1.1中的全局自定义构建函数显示UI\",\"32\":\"\",\"33\":\"下面的代码示例展示了在ArkTS1.2中引用ArkTS1.1的全局自定义构建函数来显示“Hello World!”。\",\"34\":\"\",\"35\":\"- 创建ArkTS1.1子模块`har1_1`，在`har1_1/src/main/ets/components`目录创建并导出全局自定义构建函数。\",\"36\":\"\"}",
      "修改建议": "前后描述不一致，应统一描述为同一场景。",
      "更改后示例": "### 在ArkTS1.2中引用ArkTS1.1的全局自定义构建函数显示UI",
      "触发条件": "同一上下文中的技术术语（如ArkTS版本号）出现语法结构或位置不一致（如\"ArkTS1.2引用ArkTS1.1中的\" vs \"ArkTS1.2中引用ArkTS1.1\"），且存在明确参考基准（如主模块/子模块版本对应关系）时触发。\n\n识别模式：\n1. 对比相邻句子/段落中相同技术要素的表述结构（如介词\"中\"的位置、动词与版本号的连接方式）\n2. 检查是否违反上下文已建立的术语对应关系（如参考句子中主模块ArkTS1.2与子模块ArkTS1.1的固定组合）"
    },
    {
      "defect_id": 551531,
      "sentence": "这个函数用于在给定的Node-API环境中依据一个带有符号的64位整数创建一个ArkTS的BigInt对象。",
      "reference_sentence": "用于创建64位带符号整数（int64）的BigInt对象的函数。",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"30\":\"\",\"31\":\"### napi_create_bigint_int64\",\"32\":\"\",\"33\":\"这个函数用于在给定的Node-API环境中依据一个带有符号的64位整数创建一个ArkTS的BigInt对象。\",\"34\":\"\",\"35\":\"cpp部分代码\",\"36\":\"\",\"37\":\"```cpp\",\"38\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了“带有符号的64位整数”和“带符号整数”概念，建议保持一致。",
      "更改后示例": "这个函数用于在给定的Node-API环境中依据一个带符号的64位整数创建一个ArkTS的BigInt对象。",
      "触发条件": "当同一技术术语存在\"带符号\"/\"带有符号\"、\"无符号\"/\"没有符号\"等近义但不同构词形式的混用时，或当修饰词顺序与文档常规用法不一致时（如\"64位带符号\"与\"带符号64位\"）应触发规则。\n\n识别模式：通过对比术语结构成分（动词+名词 vs 动宾短语）、检查量词位置（\"带符号的64位\" vs \"64位带符号\"）、匹配文档既有表达范式（参考句中的\"带符号\"用法）来识别不一致表述。"
    },
    {
      "defect_id": 553631,
      "sentence": "互操作场景下，将ArkTS1.1全局自定义构建函数的调用转换为[占位组件](../reference/apis-arkui/arkui-ts/ts-interop-compatible-component.md)，链接ArkTS1.2和ArkTS1.1的UI节点，构建完整的UI界面。",
      "reference_sentence": "全局自定义构建函数互操作适用于主模块使用ArkTS1.2、子模块使用ArkTS1.1的场景。",
      "line_num": 10,
      "context": "{\"5\":\"全局自定义构建函数互操作适用于[ArkTS1.2互操作](../quick-start/arkts-interop-overview.md)中使用全局自定义构建函数的场景。\",\"6\":\"\",\"7\":\"\",\"8\":\"## 架构原理\",\"9\":\"\",\"10\":\"互操作场景下，将ArkTS1.1全局自定义构建函数的调用转换为[占位组件](../reference/apis-arkui/arkui-ts/ts-interop-compatible-component.md)，链接ArkTS1.2和ArkTS1.1的UI节点，构建完整的UI界面。\",\"11\":\"\",\"12\":\"\",\"13\":\"## 设计理念\",\"14\":\"\",\"15\":\"全局自定义构建函数互操作适用于主模块使用ArkTS1.2、子模块使用ArkTS1.1的场景。\"}",
      "修改建议": "前后描述不一致，应统一描述为同一场景。",
      "更改后示例": "在互操作场景下，将ArkTS1.1全局自定义构建函数的调用转换为[占位组件](../reference/apis-arkui/arkui-ts/ts-interop-compatible-component.md)，链接ArkTS1.2和ArkTS1.1的UI节点，构建完整的UI界面。",
      "触发条件": "当文档中同一技术场景的描述存在术语不一致（如\"互操作场景下\"与\"在互操作场景下\"），或上下文对同一概念的适用范围产生矛盾（如段落5与段落15对ArkTS版本适用场景的不同解释）时触发。\n\n识别模式：\n1. 术语一致性检测：通过对比相邻段落/标题中相同技术场景的介词使用（如是否包含\"在\"）、版本号修饰方式（如ArkTS1.1与ArkTS 1.1）\n2. 上下文逻辑验证：当技术场景描述涉及多模块/版本时，检查主从模块关系是否与参考段落（如段落15）的明确定义保持一致"
    },
    {
      "defect_id": 551257,
      "sentence": "用于从ArkTS数组对象中删除请求索引的元素。",
      "reference_sentence": "用于从ArkTS数组中获取请求索引位置的元素值。请求索引值应在数组的有效范围内，如果索引超出数组长度，函数会返回undefined。",
      "line_num": 417,
      "context": "{\"412\":\"```\",\"413\":\"<!-- @[ark_napi_has_element](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"414\":\"\",\"415\":\"### napi_delete_element\",\"416\":\"\",\"417\":\"用于从ArkTS数组对象中删除请求索引的元素。\",\"418\":\"\",\"419\":\"cpp部分代码\",\"420\":\"\",\"421\":\"```cpp\",\"422\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了'数组'和'数组对象'的表述，应该保持一致。",
      "更改后示例": "用于从ArkTS数组中删除请求索引的元素。",
      "触发条件": "同一术语在相邻或相关句子中存在不一致表述（如“数组”与“数组对象”混用），或同一段落中出现同一概念的不同变体（如冗余修饰词）。  \n识别模式：检测名词短语中是否包含非必要修饰词（如“对象”），并与上下文/参考句中的标准术语（如“数组”）对比，判定是否需统一简化。"
    },
    {
      "defect_id": 551218,
      "sentence": "用于在Node-API模块中创建一个具有指定长度的ArkTS数组。",
      "reference_sentence": "用于在Node-API模块中创建一个ArkTS数组。",
      "line_num": 89,
      "context": "{\"84\":\"```\",\"85\":\"<!-- @[ark_napi_create_array](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"86\":\"\",\"87\":\"### napi_create_array_with_length\",\"88\":\"\",\"89\":\"用于在Node-API模块中创建一个具有指定长度的ArkTS数组。\",\"90\":\"\",\"91\":\"cpp部分代码\",\"92\":\"\",\"93\":\"```cpp\",\"94\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了“具有指定长度的ArkTS数组”和“ArkTS数组”概念",
      "更改后示例": "用于在Node-API模块中创建一个指定长度的ArkTS数组。",
      "触发条件": "当同一术语或短语在相邻句子中混合使用冗余修饰结构（如\"具有+属性\"）和简洁属性前置结构（如\"指定长度的\"）时，且上下文存在该术语的简化表达实例时触发。  \n\n识别模式：检测是否存在\"具有+属性\"结构（如\"具有指定长度\"）与同属性前置结构（如\"指定长度的\"）交替使用，同时匹配到参考句子中该术语的简化形式（如\"ArkTS数组\"），判定为冗余修饰导致概念表达不一致。"
    },
    {
      "defect_id": 551546,
      "sentence": "用于从传入的参数中提取64位整数的BigInt数据，以供后续处理。",
      "reference_sentence": "这个函数用于在给定的Node-API环境中依据一个带有符号的64位整数创建一个ArkTS的BigInt对象。",
      "line_num": 158,
      "context": "{\"153\":\"```\",\"154\":\"<!-- @[ark_napi_create_bigint_words](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIBigint/entry/src/main/ets/pages/Index.ets) -->\",\"155\":\"\",\"156\":\"### napi_get_value_bigint_int64\",\"157\":\"\",\"158\":\"用于从传入的参数中提取64位整数的BigInt数据，以供后续处理。\",\"159\":\"\",\"160\":\"cpp部分代码\",\"161\":\"\",\"162\":\"```cpp\",\"163\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "混用了“从传入的参数中提取”和“依据”描述同一操作，应保持用词一致",
      "更改后示例": "用于从传入的参数中提取64位整数的BigInt数据，供后续处理。",
      "触发条件": "当同一操作在相邻句子或上下文描述中混用不同介词结构（如\"以供\"与\"供\"）且存在冗余连接词时，或与参考句中的规范表述（如\"依据\"）产生用词冲突时触发。"
    },
    {
      "defect_id": 550874,
      "sentence": "查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。",
      "line_num": 198,
      "context": "{\"193\":\"| [void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)](#oh_input_settoucheventglobalx) | - | 设置触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"194\":\"| [int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobalx) | - | 查询触摸事件的触摸位置距离主屏幕左上角的X坐标。 |\",\"195\":\"| [void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)](#oh_input_settoucheventglobaly) | - | 设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"196\":\"| [int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)](#oh_input_gettoucheventglobaly) | - | 查询触摸事件的触摸位置距离主屏幕左上角的Y坐标。 |\",\"197\":\"| [Input_Result OH_Input_SetAxisEventGlobalX(struct Input_AxisEvent* axisEvent, int32_t globalX)](#oh_input_setaxiseventglobalx) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"198\":\"| [Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)](#oh_input_getaxiseventglobalx) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"199\":\"| [Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)](#oh_input_setaxiseventglobaly) | - | 设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"200\":\"| [Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)](#oh_input_getaxiseventglobaly) | - | 查询轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"201\":\"| [Input_Result OH_Input_GetPointerLocation(int32_t *displayId, double *displayX, double *displayY)](#oh_input_getpointerlocation) | - | 获取鼠标在屏幕上的坐标点。 |\",\"202\":\"\",\"203\":\"## 枚举类型说明\"}",
      "修改建议": "混用了“查询”和“获取”两个近义词。",
      "更改后示例": "获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。",
      "触发条件": "当同一上下文中的相邻API方法描述（如Get/Set配对方法或同参数类型方法）混用\"查询\"和\"获取\"等近义动词，且存在明确参考基准（如对称的Y坐标描述使用统一动词）时。\n\n识别模式：\n1. 检查方法命名与描述动词的对应关系（如Get方法应统一使用\"获取\"或\"查询\"）\n2. 对比相邻行/对称参数的描述一致性（如X/Y坐标、Get/Set方法应保持相同动词）\n3. 发现同一功能模块中存在动词混用（如触摸事件与轴事件使用不同动词）"
    },
    {
      "defect_id": 556907,
      "sentence": "获取锁后需要调用的函数。",
      "reference_sentence": "获取锁后要调用的具体回调函数。",
      "line_num": 349,
      "context": "{\"344\":\"\",\"345\":\"**参数：**\",\"346\":\"\",\"347\":\"| 名称     | 类型                                      | 必填 | 说明                   |\",\"348\":\"| -------- | ----------------------------------------- | ---- | ---------------------- |\",\"349\":\"| callback | [AsyncLockCallback\\\\<T>](#asynclockcallback)   | 是   | 获取锁后需要调用的函数。 |\",\"350\":\"| mode     | [AsyncLockMode](#asynclockmode)           | 是   | 指定锁的操作模式。         |\",\"351\":\"| options  | [AsyncLockOptions\\\\<U>](#asynclockoptions) | 是   | 锁的操作选项，用于配置锁的行为。         |\",\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\"}",
      "修改建议": "混用了“函数”和“回调函数”描述同一概念。",
      "更改后示例": "获取锁后需要调用的回调函数。",
      "触发条件": "同一参数或概念在相邻上下文中混用不同术语（如“函数”和“回调函数”），且存在明确的参考基准（参数名/类型定义/相邻条目统一表述）时触发。\n\n识别模式：\n1. 参数名包含特定术语（如\"callback\"）时，其描述应与参数名隐含的术语类型保持一致\n2. 类型定义包含特定术语（如AsyncLockCallback）时，其参数说明应保持术语一致性\n3. 相邻条目存在统一表述（如参考句使用\"回调函数\"）时需保持横向一致性\n4. 同一表格/段落内对同一概念出现两种及以上不同术语表述"
    },
    {
      "defect_id": 556906,
      "sentence": "锁的操作模式，例如读模式或写模式。",
      "reference_sentence": "指定锁的操作模式。",
      "line_num": 309,
      "context": "{\"304\":\"**参数：**\",\"305\":\"\",\"306\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"307\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"308\":\"| callback | [AsyncLockCallback\\\\<T>](#asynclockcallback) | 是   | 获取锁后要调用的函数。 |\",\"309\":\"| mode     | [AsyncLockMode](#asynclockmode)         | 是   | 锁的操作模式，例如读模式或写模式。         |\",\"310\":\"\",\"311\":\"**返回值：**\",\"312\":\"\",\"313\":\"| 类型        | 说明                        |\",\"314\":\"| ----------- | --------------------------- |\"}",
      "修改建议": "混用了“操作模式”和“指定操作模式”描述同一概念。",
      "更改后示例": "锁的指定操作模式，例如读模式或写模式。",
      "触发条件": "当同一术语或概念在相邻上下文或关联参数描述中出现不一致的修饰词（如\"操作模式\"与\"指定操作模式\"混用），且存在明确的参考基准（如接口定义中的规范表述）时触发。\n\n识别模式：\n1. 检测相邻段落/参数表中对同一实体的描述是否包含冗余/缺失的动词修饰（如\"指定\"）\n2. 对比同一文档中已建立的规范表达（如参考句子的\"指定锁的操作模式\"），验证后续说明是否保持完全一致的动宾结构"
    },
    {
      "defect_id": 556905,
      "sentence": "获取锁后要调用的函数。",
      "reference_sentence": "获取锁后要调用的具体回调函数。",
      "line_num": 308,
      "context": "{\"303\":\"\",\"304\":\"**参数：**\",\"305\":\"\",\"306\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"307\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"308\":\"| callback | [AsyncLockCallback\\\\<T>](#asynclockcallback) | 是   | 获取锁后要调用的函数。 |\",\"309\":\"| mode     | [AsyncLockMode](#asynclockmode)         | 是   | 锁的操作模式，例如读模式或写模式。         |\",\"310\":\"\",\"311\":\"**返回值：**\",\"312\":\"\",\"313\":\"| 类型        | 说明                        |\"}",
      "修改建议": "混用了“函数”和“回调函数”描述同一概念。",
      "更改后示例": "获取锁后要调用的回调函数。",
      "触发条件": "同一参数或上下文中混用不同术语描述同一概念（如参数名称为\"callback\"但描述使用\"函数\"，而参考句子使用\"回调函数\"），且存在明确的标准术语（如类型定义、参数命名或参考案例中的统一表达）时触发。"
    },
    {
      "defect_id": 556897,
      "sentence": "查询指定异步锁的信息。",
      "reference_sentence": "查找指定名称的异步锁实例，如果未找到，则创建该实例。",
      "line_num": 189,
      "context": "{\"184\":\"\",\"185\":\"#### query\",\"186\":\"\",\"187\":\"static query(name: string): AsyncLockState\",\"188\":\"\",\"189\":\"查询指定异步锁的信息。\",\"190\":\"\",\"191\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"192\":\"\",\"193\":\"**系统能力：** SystemCapability.Utils.Lang\",\"194\":\"\"}",
      "修改建议": "使用了不同的词汇描述类似的函数，可能导致用户混淆",
      "更改后示例": "获取指定异步锁的信息。",
      "触发条件": "同一API或上下文中，描述相似功能的动词（如“查询”、“获取”、“查找”）未统一，或与接口名称（如“query”）存在术语不一致。"
    },
    {
      "defect_id": 556924,
      "sentence": "默认构造函数创建一个所有属性均具有默认值的异步锁配置项实例。",
      "reference_sentence": "默认构造函数创建一个所有属性均具有默认值的异步锁配置项实例。",
      "line_num": 442,
      "context": "{\"437\":\"\",\"438\":\"#### constructor\",\"439\":\"\",\"440\":\"constructor()\",\"441\":\"\",\"442\":\"默认构造函数创建一个所有属性均具有默认值的异步锁配置项实例。\",\"443\":\"\",\"444\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"445\":\"\",\"446\":\"**系统能力：** SystemCapability.Utils.Lang\",\"447\":\"\"}",
      "修改建议": "用词一致，但建议统一使用祈使句。",
      "更改后示例": "创建一个所有属性均具有默认值的异步锁配置项实例。",
      "触发条件": "当方法/构造函数描述句中出现非祈使句结构，且上下文存在统一使用祈使句的规范要求时触发；或同一文档中同类功能描述存在陈述句与祈使句混用的情况时触发。"
    },
    {
      "defect_id": 556923,
      "sentence": "如果指定了此模式，可以在任意线程同时执行。",
      "reference_sentence": "如果指定了此模式，仅在独占获取锁时才能执行。",
      "line_num": 394,
      "context": "{\"389\":\"\",\"390\":\"**系统能力：** SystemCapability.Utils.Lang\",\"391\":\"\",\"392\":\"| 名称      | 值  | 说明                                                     |\",\"393\":\"| --------- | --- | -------------------------------------------------------- |\",\"394\":\"| SHARED    | 1   | 共享锁模式。如果指定了此模式，可以在任意线程同时执行。   |\\t\",\"395\":\"| EXCLUSIVE | 2   | 独占锁模式。如果指定了此模式，仅在独占获取锁时才能执行。 |\",\"396\":\"\",\"397\":\"**示例：**\",\"398\":\"\",\"399\":\"```ts\"}",
      "修改建议": "混用了'同时执行'与'才能执行'，导致用词不一致。",
      "更改后示例": "如果指定了此模式，可以在任意线程中执行。",
      "触发条件": "当同一文档的相邻/相关条目中存在相同句式结构但使用不一致的动词短语（如\"执行\"的修饰语不统一），或在相同上下文语义场景下出现术语混用（如\"同时执行\"与\"才能执行\"表意冲突）时触发。"
    },
    {
      "defect_id": 556922,
      "sentence": "回调执行后解决的Promise，或者在超时情况下被拒绝的Promise。",
      "reference_sentence": "回调执行后将解决的Promise。",
      "line_num": 357,
      "context": "{\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\",\"355\":\"| 类型             | 说明                                               |\",\"356\":\"| ---------------- | -------------------------------------------------- |\",\"357\":\"| Promise\\\\<T \\\\| U> | 回调执行后解决的Promise，或者在超时情况下被拒绝的Promise。 |\",\"358\":\"\",\"359\":\"**错误码：**\",\"360\":\"\",\"361\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"362\":\"\"}",
      "修改建议": "混用了'解决'与'将解决'，导致用词不一致。",
      "更改后示例": "回调执行后将解决的Promise，或者在超时情况下被拒绝的Promise。",
      "触发条件": "同一并列结构中动词时态或助动词使用不一致（如\"解决\"与\"将解决\"混用），或同一语义表达出现主动/被动语态不匹配（如\"解决的\"与\"被拒绝的\"结构不对称）。"
    },
    {
      "defect_id": 556908,
      "sentence": "锁的操作选项，用于配置锁的行为。",
      "reference_sentence": "锁的操作模式，例如读模式或写模式。",
      "line_num": 351,
      "context": "{\"346\":\"\",\"347\":\"| 名称     | 类型                                      | 必填 | 说明                   |\",\"348\":\"| -------- | ----------------------------------------- | ---- | ---------------------- |\",\"349\":\"| callback | [AsyncLockCallback\\\\<T>](#asynclockcallback)   | 是   | 获取锁后需要调用的函数。 |\",\"350\":\"| mode     | [AsyncLockMode](#asynclockmode)           | 是   | 指定锁的操作模式。         |\",\"351\":\"| options  | [AsyncLockOptions\\\\<U>](#asynclockoptions) | 是   | 锁的操作选项，用于配置锁的行为。         |\",\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\",\"355\":\"| 类型             | 说明                                               |\",\"356\":\"| ---------------- | -------------------------------------------------- |\"}",
      "修改建议": "混用了“操作模式”和“操作选项”描述同一概念。",
      "更改后示例": "锁的操作配置，用于配置锁的行为。",
      "触发条件": "同一文档中相邻或相关术语存在不一致（如\"操作模式\"与\"操作选项\"混用），或同一概念被不同词语重复描述（如\"选项\"与\"配置\"交替出现）。需通过对比上下文参数命名（如mode/options）、参考句子的核心术语（如\"操作模式\"）及相邻条目描述（如表格字段说明）识别矛盾。"
    },
    {
      "defect_id": 556925,
      "sentence": "取值为true，则只有在尚未持有锁定请求时才会授予该锁定请求；为false则表示将等待当前锁被释放。默认为 false。",
      "reference_sentence": "当signal.aborted为true时，锁请求将被丢弃；当signal.aborted为false时，请求会继续等待获取锁；当signal为null时，请求正常排队运行。默认为 null。",
      "line_num": 467,
      "context": "{\"462\":\"\",\"463\":\"#### 属性\",\"464\":\"\",\"465\":\"| 名称        | 类型                                  | 只读 | 可选 | 说明                                                                                                                      |\",\"466\":\"| ----------- | ------------------------------------- | ---- | ---- | ------------------------------------------------------------------------------------------------------------------------- |\",\"467\":\"| isAvailable | boolean                               | 否   | 否   | 当前锁是否可用。取值为true，则只有在尚未持有锁定请求时才会授予该锁定请求；为false则表示将等待当前锁被释放。默认为 false。 |\",\"468\":\"| signal      | [AbortSignal\\\\<T>](#abortsignal)\\\\|null | 否   | 否   | 用于中止异步操作的对象。当signal.aborted为true时，锁请求将被丢弃；当signal.aborted为false时，请求会继续等待获取锁；当signal为null时，请求正常排队运行。默认为 null。               |\",\"469\":\"| timeout     | number                                | 否   | 否   | 锁操作的超时时间，单位为毫秒。若该值大于零，且操作运行时间超过该时间，[lockAsync](#lockasync)将返回被拒绝的Promise。默认为 0。      |\",\"470\":\"\",\"471\":\"### AsyncLockState\",\"472\":\"\"}",
      "修改建议": "混用了'只有在尚未持有锁定请求时才会授予'与'请求会继续等待获取锁'，导致用词不一致。",
      "更改后示例": "取值为true时，表示只有在尚未持有锁定请求时才会授予该锁定请求；为false时，表示将等待当前锁被释放。默认为 false。",
      "触发条件": "同一参数的不同取值描述存在句式结构不一致（如\"取值为true，则...\"与\"为false则表示...\"混用），或与文档中其他同类参数描述模式不匹配（如未采用\"当...为X时，...\"的统一结构）。  \n\n识别模式：  \n1. 检查条件语句是否采用相同引导词（如统一使用\"取值为X时\"或\"当X为Y时\"）  \n2. 对比相邻参数描述（如示例中isAvailable与signal属性的说明结构差异）  \n3. 检测连接词一致性（如\"则\"与\"则表示\"混用、是否统一包含\"表示\"动词）"
    },
    {
      "defect_id": 556948,
      "sentence": "用于存储特定异步锁实例上当前执行的所有锁操作的信息的类。",
      "reference_sentence": "表示锁操作选项的类。",
      "line_num": 473,
      "context": "{\"468\":\"| signal      | [AbortSignal\\\\<T>](#abortsignal)\\\\|null | 否   | 否   | 用于中止异步操作的对象。当signal.aborted为true时，锁请求将被丢弃；当signal.aborted为false时，请求会继续等待获取锁；当signal为null时，请求正常排队运行。默认为 null。               |\",\"469\":\"| timeout     | number                                | 否   | 否   | 锁操作的超时时间，单位为毫秒。若该值大于零，且操作运行时间超过该时间，[lockAsync](#lockasync)将返回被拒绝的Promise。默认为 0。      |\",\"470\":\"\",\"471\":\"### AsyncLockState\",\"472\":\"\",\"473\":\"用于存储特定异步锁实例上当前执行的所有锁操作的信息的类。\",\"474\":\"\",\"475\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"476\":\"\",\"477\":\"**系统能力：** SystemCapability.Utils.Lang\",\"478\":\"\"}",
      "修改建议": "描述类的语句格式不一致，应该统一使用'表示...的类'这种描述方式",
      "更改后示例": "表示特定异步锁实例上当前执行的所有锁操作的信息的类。",
      "触发条件": "当文档中存在多个类定义描述且动词结构不一致时（如\"用于...\"与\"表示...\"混用），且存在已确立的标准句式（如\"表示...的类\"）作为参照。  \n\n识别模式：  \n1. 句子结构匹配\"动词+...+的类\"模式  \n2. 动词部分与上下文/参考句式的标准动词（如\"表示\"）不一致  \n3. 同一文档中存在使用标准动词的同类描述（如参考句子）形成对照"
    },
    {
      "defect_id": 556961,
      "sentence": "通知第一个等待的线程。",
      "reference_sentence": "通知第一个等待的线程。",
      "line_num": 649,
      "context": "{\"644\":\"\",\"645\":\"#### notifyOne<sup>18+</sup>\",\"646\":\"\",\"647\":\"notifyOne() : void\",\"648\":\"\",\"649\":\"通知第一个等待的线程。\",\"650\":\"\",\"651\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"652\":\"\",\"653\":\"**系统能力：** SystemCapability.Utils.Lang\",\"654\":\"\"}",
      "修改建议": "‘等待的’与‘等待’使用了不同的词汇，应统一为‘等待’。",
      "更改后示例": "通知第一个等待线程。",
      "触发条件": "当同一文档中相同概念的修饰语存在\"的\"字冗余或缺失导致表述不一致时，或上下文已确立特定术语表达形式而当前句子出现偏离时。  \n\n识别模式：  \n1. 检测名词前修饰语存在\"X的\"与\"X\"两种变体（如\"等待的线程\"vs\"等待线程\"）  \n2. 通过上下文对比确认文档已确立某一种固定表达形式（如参考句采用\"等待的线程\"，但其他位置出现无\"的\"的表述）"
    },
    {
      "defect_id": 557001,
      "sentence": "获取缓冲区键值对的回收次数。当缓冲区数量超出容量限制时，最少使用的键值对将被回收。",
      "reference_sentence": "将缓冲区容量设置为指定值。如果缓冲区中值的总数超过指定容量，将移除最少使用的键值对。",
      "line_num": 1125,
      "context": "{\"1120\":\"\",\"1121\":\"### getRemoveCount<sup>18+</sup>\",\"1122\":\"\",\"1123\":\"getRemoveCount(): number\",\"1124\":\"\",\"1125\":\"获取缓冲区键值对的回收次数。当缓冲区数量超出容量限制时，最少使用的键值对将被回收。\",\"1126\":\"\",\"1127\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1128\":\"\",\"1129\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1130\":\"\"}",
      "修改建议": "混用了'移除'与'回收'近义词",
      "更改后示例": "获取缓冲区键值对的移除次数。当缓冲区数量超出容量限制时，最少使用的键值对将被移除。",
      "触发条件": "同一上下文或相邻语句中存在描述相同操作但使用不同动词（如\"回收\"与\"移除\"）的情况，且存在明确参考句（如系统API文档）规定应使用统一术语时。"
    },
    {
      "defect_id": 556959,
      "sentence": "异步调用进入等待中，将在被唤醒或者等待时间结束后继续执行。使用Promise异步回调。",
      "reference_sentence": "异步调用进入等待，将在被唤醒或等待时间结束后继续执行。使用Promise进行异步回调。",
      "line_num": 573,
      "context": "{\"568\":\"\",\"569\":\"#### wait<sup>18+</sup>\",\"570\":\"\",\"571\":\"wait(): Promise\\\\<void>\",\"572\":\"\",\"573\":\"异步调用进入等待中，将在被唤醒或者等待时间结束后继续执行。使用Promise异步回调。\",\"574\":\"\",\"575\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"576\":\"\",\"577\":\"**系统能力：** SystemCapability.Utils.Lang\",\"578\":\"\"}",
      "修改建议": "‘等待中’与‘等待’使用了不同的词汇，应统一为‘等待’；‘或者’与‘或’使用了不同的词汇，应统一为‘或’。",
      "更改后示例": "异步调用进入等待状态，将在被唤醒或等待时间结束后继续执行。使用Promise异步回调。",
      "触发条件": "同一术语或短语在相邻句子或同一上下文中存在不一致表达（如“等待中”与“等待”），或存在可统一简化的连接词（如“或者”与“或”）时触发。\n\n识别模式：\n1. **术语一致性检测**：对比相邻句子中描述同一概念的词汇（如“等待中”与“等待”），若存在非必要变体则标记。\n2. **连接词简化识别**：检查句子中冗余表达（如“或者”与“或”），优先采用简洁形式（“或”）并统一上下文。"
    },
    {
      "defect_id": 556952,
      "sentence": "用于中止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。",
      "reference_sentence": "表示锁操作选项的类。",
      "line_num": 504,
      "context": "{\"499\":\"| mode      | [AsyncLockMode](#asynclockmode) | 否   | 否   | 锁的模式。                                                |\",\"500\":\"| contextId | number                          | 否   | 否   | [AsyncLockMode](#asynclockmode)调用者的执行上下文标识符。 |\",\"501\":\"\",\"502\":\"### AbortSignal\",\"503\":\"\",\"504\":\"用于中止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。\",\"505\":\"\",\"506\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"507\":\"\",\"508\":\"**系统能力：** SystemCapability.Utils.Lang\",\"509\":\"\"}",
      "修改建议": "描述类的语句格式不一致，应该统一使用'表示...的类'这种描述方式",
      "更改后示例": "表示用于中止异步操作的对象。该类的实例必须在其创建的同一线程中访问。从其他线程访问此类的字段会导致未定义的行为。",
      "触发条件": "当文档中存在描述类用途的语句时，若首句未采用\"表示...的类\"的标准句式，且上下文存在同类描述模板（如参考句\"表示锁操作选项的类\"），则触发语言一致性规则。\n\n识别模式：\n1. 定位类描述段落（如上下文中的### AbortSignal标题下）\n2. 检测首句是否以非标准动词结构开头（如\"用于...\"而非\"表示...\"）\n3. 对比相邻类描述模板（如参考句的\"表示...的类\"结构）\n4. 验证语义是否属于类定义范畴（如包含\"对象/类/实例\"等关键词）"
    },
    {
      "defect_id": 556954,
      "sentence": "实现异步等待功能的类，支持异步等待通知操作。该类使用[@Sendable装饰器](../../arkts-utils/arkts-sendable.md)装饰。",
      "reference_sentence": "表示锁操作选项的类。",
      "line_num": 519,
      "context": "{\"514\":\"| aborted | boolean | 否   | 否   | 是否终止异步操作。为true时表示中止异步操作，为false时表示异步操作未被中止。     |\",\"515\":\"| reason  | \\\\<T>    | 否   | 否   | 中止的原因。此值将用于拒绝[lockAsync](#lockasync)返回的Promise。 |\",\"516\":\"\",\"517\":\"### ConditionVariable<sup>18+</sup>\",\"518\":\"\",\"519\":\"实现异步等待功能的类，支持异步等待通知操作。该类使用[@Sendable装饰器](../../arkts-utils/arkts-sendable.md)装饰。\",\"520\":\"\",\"521\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"522\":\"\",\"523\":\"**系统能力：** SystemCapability.Utils.Lang\",\"524\":\"\"}",
      "修改建议": "描述类的语句格式不一致，应该统一使用'表示...的类'这种描述方式",
      "更改后示例": "表示实现异步等待功能并支持异步等待通知操作的类。该类使用[@Sendable装饰器](../../arkts-utils/arkts-sendable.md)装饰。",
      "触发条件": "当文档中存在描述类定义的句子时，若未统一采用\"表示...的类\"的句式结构，且出现其他动词（如\"实现\"）引导类功能描述时触发。\n\n识别模式：检测到以\"实现/提供/包含\"等动词开头描述类功能的句式（如\"实现X功能的类\"），且上下文存在采用\"表示...的类\"的统一表达范例时，判定为句式不一致需要修复。"
    },
    {
      "defect_id": 556982,
      "sentence": "所有Sendable类型的父类型。",
      "reference_sentence": "ISendable是所有Sendable类型（除`null`和`undefined`）的父类型。",
      "line_num": 681,
      "context": "{\"676\":\"\",\"677\":\"**系统能力：** SystemCapability.Utils.Lang\",\"678\":\"\",\"679\":\"| 类型 | 说明   |\",\"680\":\"| ------ | ------ |\",\"681\":\"| [lang.ISendable](js-apis-arkts-lang.md#langisendable)   | 所有Sendable类型的父类型。 |\",\"682\":\"\",\"683\":\"### Transformer\",\"684\":\"\",\"685\":\"type Transformer = (this: ISendable, key: string, value: ISendable | undefined | null) => ISendable | undefined | null\",\"686\":\"\"}",
      "修改建议": "用词不一致，前者缺少对`null`和`undefined`的说明。",
      "更改后示例": "所有Sendable类型的父类型，包括`undefined`和`null`。",
      "触发条件": "当文档中同一术语或概念在不同位置的描述存在关键信息差异（如包含/排除特定类型），且存在明确上下文参考时触发。识别模式需检测术语定义是否遗漏其他段落已声明的限定条件（如`null`/`undefined`）。"
    },
    {
      "defect_id": 556950,
      "sentence": "关于锁的信息。",
      "reference_sentence": "表示锁操作选项的类。",
      "line_num": 488,
      "context": "{\"483\":\"| held    | [AsyncLockInfo[]](#asynclockinfo) | 否   | 否   | 持有的锁信息。   |\",\"484\":\"| pending | [AsyncLockInfo[]](#asynclockinfo) | 否   | 否   | 等待中的锁信息。 |\",\"485\":\"\",\"486\":\"### AsyncLockInfo\",\"487\":\"\",\"488\":\"关于锁的信息。\",\"489\":\"\",\"490\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"491\":\"\",\"492\":\"**系统能力：** SystemCapability.Utils.Lang\",\"493\":\"\"}",
      "修改建议": "描述类的语句格式不一致，应该统一使用'表示...的类'这种描述方式",
      "更改后示例": "表示锁信息的类。",
      "触发条件": "当文档中描述类定义的语句未采用统一句式（如“表示...的类”）且存在同类描述不一致时触发。\n\n识别模式：\n1. 检测到类定义描述语句（如“关于X的信息”）；\n2. 上下文存在同类描述的标准句式（如“表示Y的类”）；\n3. 两者句式结构不匹配（如名词短语 vs 主谓结构）。"
    },
    {
      "defect_id": 557023,
      "sentence": "获取返回键的值。",
      "reference_sentence": "返回使用内部默认接口创建对象的次数。",
      "line_num": 1232,
      "context": "{\"1227\":\"\",\"1228\":\"### get<sup>18+</sup>\",\"1229\":\"\",\"1230\":\"get(key: K): V | undefined\",\"1231\":\"\",\"1232\":\"获取返回键的值。\",\"1233\":\"\",\"1234\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1235\":\"\",\"1236\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1237\":\"\"}",
      "修改建议": "获取和返回近义词混用",
      "更改后示例": "返回键的值。",
      "触发条件": "同一文档或上下文中出现描述同一操作或概念的近义动词（如“获取”与“返回”）混用，且存在明确的参考基准（如其他同类语句统一使用特定动词）时触发。"
    },
    {
      "defect_id": 556998,
      "sentence": "从API 18开始，参数修改为Object类型。API 18之前，参数只支持ISendable类型。",
      "reference_sentence": "从API version 12开始，该接口支持在原子化服务中使用。",
      "line_num": 824,
      "context": "{\"819\":\"\",\"820\":\"该方法将ArkTS对象数据转换为JSON字符串，并额外支持Map和Set类型。\",\"821\":\"\",\"822\":\"> **说明：**\",\"823\":\">\",\"824\":\"> 从API 18开始，参数修改为Object类型。API 18之前，参数只支持ISendable类型。\",\"825\":\"\",\"826\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"827\":\"\",\"828\":\"**系统能力：** SystemCapability.Utils.Lang\",\"829\":\"\"}",
      "修改建议": "混用了'API 18'和'API version 18'，建议统一为'API version 18'。",
      "更改后示例": "从API version 18开始，参数修改为Object类型。API version 18之前，参数只支持ISendable类型。",
      "触发条件": "同一术语在相邻或相关语句中存在不一致的缩略/完整表达形式（如\"API 18\"与\"API version 18\"混用），且文档中存在该术语的标准表达形式（如参考句中的\"API version X\"规范用法）。\n\n识别模式：检测相邻句子/段落中相同术语的变体表达（如数字前是否带\"version\"关键词），并与上下文/参考规范中的标准形式进行对比，当出现≥2种变体且存在明确规范用例时触发规则。"
    },
    {
      "defect_id": 556960,
      "sentence": "通知所有等待的线程。",
      "reference_sentence": "通知所有等待的线程。",
      "line_num": 629,
      "context": "{\"624\":\"\",\"625\":\"#### notifyAll<sup>18+</sup>\",\"626\":\"\",\"627\":\"notifyAll() : void\",\"628\":\"\",\"629\":\"通知所有等待的线程。\",\"630\":\"\",\"631\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"632\":\"\",\"633\":\"**系统能力：** SystemCapability.Utils.Lang\",\"634\":\"\"}",
      "修改建议": "‘等待的’与‘等待’使用了不同的词汇，应统一为‘等待’。",
      "更改后示例": "通知所有等待线程。",
      "触发条件": "同一术语在相邻语句或同一上下文中出现带\"的\"的形容词形式和不带\"的\"的名词形式混用（如\"等待的线程\"与\"等待线程\"），且上下文存在明确的一致性表达要求时触发。\n\n识别模式：\n1. 检测同一词根在相邻3句内出现形容词（XX的）和名词（XX）两种形态\n2. 验证目标短语是否作为固定术语在上下文被重复使用（如参考句中的\"等待线程\"）\n3. 排除语法结构必需使用\"的\"的情况（如复杂定语结构）"
    },
    {
      "defect_id": 556956,
      "sentence": "默认构造函数。创建一个异步等待通知操作的对象。",
      "reference_sentence": "默认构造函数创建一个所有属性均具有默认值的异步锁配置项实例。",
      "line_num": 529,
      "context": "{\"524\":\"\",\"525\":\"#### constructor<sup>18+</sup>\",\"526\":\"\",\"527\":\"constructor()\",\"528\":\"\",\"529\":\"默认构造函数。创建一个异步等待通知操作的对象。\",\"530\":\"\",\"531\":\"**原子化服务API**：从API version 18 开始，该接口支持在原子化服务中使用。\",\"532\":\"\",\"533\":\"**系统能力：** SystemCapability.Utils.Lang\",\"534\":\"\"}",
      "修改建议": "描述构造函数的语句格式不一致，应该统一使用'默认构造函数创建...的实例'这种描述方式",
      "更改后示例": "默认构造函数创建一个异步等待通知操作的实例。",
      "触发条件": "当文档中存在描述默认构造函数功能的句子，且其句式结构不符合“默认构造函数创建...的实例”的统一格式时触发。\n\n识别模式：\n1. 句子以“默认构造函数”开头，但后续描述被拆分为独立短句（如用句号分隔）；\n2. 未使用“创建...的实例”固定结构，或出现术语不一致（如“对象”与“实例”混用）；\n3. 与上下文同类描述（如参考句）的动宾结构存在明显格式差异。"
    },
    {
      "defect_id": 557022,
      "sentence": "返回将值添加到缓冲区的次数。",
      "reference_sentence": "返回使用内部默认接口创建对象的次数。",
      "line_num": 1190,
      "context": "{\"1185\":\"\",\"1186\":\"**返回值：**\",\"1187\":\"\",\"1188\":\"| 类型   | 说明                         |\",\"1189\":\"| ------ | ---------------------------- |\",\"1190\":\"| number | 返回将值添加到缓冲区的次数。 |\",\"1191\":\"\",\"1192\":\"**示例：**\",\"1193\":\"\",\"1194\":\"```ts\",\"1195\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "获取和返回近义词混用",
      "更改后示例": "返回值添加到缓冲区的次数。",
      "触发条件": "当文档中返回值描述同时出现\"返回\"和\"获取\"等近义动词时，或同一功能模块的返回值描述存在动词不一致现象时触发。识别模式需检测返回值说明段落中是否在相同语义场景下混用\"return\"类动词近义词（如返回/获取/获得等），并通过上下文对比验证一致性需求。"
    },
    {
      "defect_id": 557021,
      "sentence": "获取添加到缓冲区的值的次数。",
      "reference_sentence": "返回使用内部默认接口创建对象的次数。",
      "line_num": 1180,
      "context": "{\"1175\":\"\",\"1176\":\"### getPutCount<sup>18+</sup>\",\"1177\":\"\",\"1178\":\"getPutCount(): number\",\"1179\":\"\",\"1180\":\"获取添加到缓冲区的值的次数。\",\"1181\":\"\",\"1182\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1183\":\"\",\"1184\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1185\":\"\"}",
      "修改建议": "获取和返回近义词混用",
      "更改后示例": "返回添加到缓冲区的值的次数。",
      "触发条件": "当文档中函数描述使用与函数实际行为（如返回数据）不符的动词（如“获取”），或与上下文术语（如参考句的“返回”）存在近义词混用时触发。\n\n识别模式：\n1. **动词冲突**：检测描述函数行为的动词（如“获取”）是否与函数名隐含的操作（如getXXX通常对应“返回”）或参考案例用词（如“返回”）不一致\n2. **近义混用**：识别同一上下文场景下存在多个近义动词（如获取/返回/取得），且未保持术语统一的情况\n3. **行为匹配**：验证动词是否准确反映API的实际行为（如“返回次数”对应计数查询，而非数据获取操作）"
    },
    {
      "defect_id": 557404,
      "sentence": "通过任务ID取消任务池中的任务。如果任务在taskpool等待队列中，取消后任务将不再执行，并返回任务取消异常。如果任务已在taskpool工作线程中执行，取消不影响任务继续执行，执行结果在catch分支返回。使用isCanceled可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。在其他线程调用taskpool.cancel时，需注意其行为是异步的，可能影响之后的taskpool.execute或taskpool.executeDelayed。",
      "reference_sentence": "通过任务ID取消任务池中的任务。如果任务在taskpool等待队列中，取消后任务将不再执行，并返回任务取消的异常。如果任务已在taskpool工作线程中执行，取消不影响任务继续执行，执行结果在catch分支返回。使用isCanceled可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。在其他线程调用taskpool.cancel时，需注意其行为是异步的，可能影响之后的taskpool.execute或taskpool.executeDelayed。",
      "line_num": 735,
      "context": "{\"730\":\"\",\"731\":\"## taskpool.cancel<sup>18+</sup>\",\"732\":\"\",\"733\":\"cancel(taskId: number): void\",\"734\":\"\",\"735\":\"通过任务ID取消任务池中的任务。如果任务在taskpool等待队列中，取消后任务将不再执行，并返回任务取消异常。如果任务已在taskpool工作线程中执行，取消不影响任务继续执行，执行结果在catch分支返回。使用isCanceled可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。在其他线程调用taskpool.cancel时，需注意其行为是异步的，可能影响之后的taskpool.execute或taskpool.executeDelayed。\",\"736\":\"\",\"737\":\"从API version 20开始，支持在执行cancel操作后，在catch分支里使用BusinessError<[taskpool.TaskResult](#taskresult20)>的泛型标记，来获取任务中抛出的异常信息或最终的执行结果。\",\"738\":\"\",\"739\":\"**系统能力：** SystemCapability.Utils.Lang\",\"740\":\"\"}",
      "修改建议": "混用了'取消异常'和'取消的异常'，导致表意模糊。",
      "更改后示例": "通过任务ID取消任务池中的任务。如果任务在taskpool等待队列中，取消后任务将不再执行，并返回任务取消的异常。如果任务已在taskpool工作线程中执行，取消不影响任务继续执行，执行结果在catch分支返回。使用isCanceled可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。在其他线程调用taskpool.cancel时，需注意其行为是异步的，可能影响之后的taskpool.execute或taskpool.executeDelayed。",
      "触发条件": "同一文档中对同一概念使用不同结构的名词短语（如\"取消异常\"与\"取消的异常\"），或同一术语存在修饰词位置差异（如\"任务取消异常\"与\"任务取消的异常\"）。当检测到描述同一技术实体的短语存在语法结构不一致时触发规则。"
    },
    {
      "defect_id": 557356,
      "sentence": "校验并发函数的参数类型和返回类型后，系统将创建好的泛型任务放入taskpool内部任务队列。",
      "reference_sentence": "校验并发函数的参数类型和返回类型，然后将待执行的函数放入taskpool的任务队列。",
      "line_num": 205,
      "context": "{\"200\":\"\",\"201\":\"## taskpool.execute<sup>13+</sup>\",\"202\":\"\",\"203\":\"execute<A extends Array\\\\<Object>, R>(task: GenericsTask<A, R>, priority?: Priority): Promise\\\\<R>\",\"204\":\"\",\"205\":\"校验并发函数的参数类型和返回类型后，系统将创建好的泛型任务放入taskpool内部任务队列。\",\"206\":\"\",\"207\":\"**系统能力：** SystemCapability.Utils.Lang\",\"208\":\"\",\"209\":\"**原子化服务API**：从API version 13开始，该接口支持在原子化服务中使用。\",\"210\":\"\"}",
      "修改建议": "描述不一致，前文使用“任务队列”，后文使用“内部任务队列”。",
      "更改后示例": "校验并发函数的参数类型和返回类型后，系统将创建好的泛型任务放入任务队列。",
      "触发条件": "同一术语在相邻上下文或相关描述中出现修饰词不一致（如\"任务队列\"与\"内部任务队列\"），或存在冗余限定词（如\"taskpool内部\"与上下文已明确的所属关系重复）。\n\n识别模式：\n1. 检查名词短语是否在相同语义场景下存在修饰词增减（如\"内部\"）\n2. 对比上下文已建立的术语结构（如参考句中的\"taskpool的任务队列\"）\n3. 验证限定词必要性（当所属关系已通过上下文/taskpool前缀明确时，\"内部\"成为冗余描述）"
    },
    {
      "defect_id": 557415,
      "sentence": "中止任务池中的长时任务，在长时任务执行完成后调用。中止后，执行长时任务的线程可能会被回收。",
      "reference_sentence": "取消任务池中的任务。当任务在taskpool等待队列中，取消该任务后该任务将不再执行，并返回任务被取消的异常；当任务已经在taskpool工作线程执行，取消该任务并不影响任务继续执行，执行结果在catch分支返回，搭配isCanceled使用可以对任务取消行为作出响应。",
      "line_num": 800,
      "context": "{\"795\":\"\",\"796\":\"## taskpool.terminateTask<sup>12+</sup>\",\"797\":\"\",\"798\":\"terminateTask(longTask: LongTask): void\",\"799\":\"\",\"800\":\"中止任务池中的长时任务，在长时任务执行完成后调用。中止后，执行长时任务的线程可能会被回收。\",\"801\":\"\",\"802\":\"**系统能力：** SystemCapability.Utils.Lang\",\"803\":\"\",\"804\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"805\":\"\"}",
      "修改建议": "用词不一致，'中止'与'取消'混用。",
      "更改后示例": "取消任务池中的长时任务，在长时任务执行完成后调用。取消后，执行长时任务的线程可能会被回收。",
      "触发条件": "同一文档或上下文中，同一概念或操作使用多个不同术语（如“中止”与“取消”混用），且存在已定义的规范用词（如参考句子中的“取消”）。"
    },
    {
      "defect_id": 557054,
      "sentence": "获取当前缓冲区中的所有键，并按从最近访问到最少访问的顺序排列。",
      "reference_sentence": "返回当前缓冲区中所有键的列表，按从最近访问到最少访问的顺序排列。",
      "line_num": 1324,
      "context": "{\"1319\":\"\",\"1320\":\"### keys<sup>18+</sup>\",\"1321\":\"\",\"1322\":\"keys(): K[]\",\"1323\":\"\",\"1324\":\"获取当前缓冲区中的所有键，并按从最近访问到最少访问的顺序排列。\",\"1325\":\"\",\"1326\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1327\":\"\",\"1328\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1329\":\"\"}",
      "修改建议": "描述不一致，前文使用了'返回当前缓冲区中所有键的列表'，后文使用了'获取当前缓冲区中的所有键'。",
      "更改后示例": "返回当前缓冲区中的所有键，并按从最近访问到最少访问的顺序排列。",
      "触发条件": "同一功能点的描述动词在相邻上下文中不一致（如\"获取\"与\"返回\"混用），且存在前序统一表达范例（如\"返回当前缓冲区中所有键的列表\"）时触发。\n\n识别模式：通过对比API方法声明（keys(): K[]）、参数说明与功能描述段落，检测动作动词（获取/返回/生成等）及核心名词短语（键/键列表）是否保持术语一致性，特别关注同一语义链中动词的连贯性断裂。"
    },
    {
      "defect_id": 557345,
      "sentence": "当同一时间待执行的任务数量大于任务池工作线程数量，任务池会根据负载均衡机制进行扩容，增加工作线程数量，减少整体等待时长。同样，当执行的任务数量减少，工作线程数量大于执行任务数量，部分工作线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少工作线程数量。",
      "reference_sentence": "当同一时间待执行的任务数量大于任务池工作线程数量，任务池会根据负载均衡机制进行扩容，增加工作线程数量，减少整体等待时长。同样，当执行的任务数量减少，工作线程数量大于执行任务数量，部分工作线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少工作线程数量。",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。您可以使用任务池API创建后台任务（Task），并进行如执行任务或取消任务等操作。理论上，任务池API允许创建的任务数量不受限制，但由于内存限制，不建议这样做。此外，不建议在任务中执行阻塞操作，尤其是无限期阻塞操作，因为长时间的阻塞操作会占用工作线程，可能阻塞其他任务的调度，影响应用性能。\",\"4\":\"\",\"5\":\"您所创建的同一优先级任务的执行顺序可以由您决定，任务真实执行的顺序与您调用任务池API提供的任务执行接口顺序一致。任务默认优先级是MEDIUM。\",\"6\":\"\",\"7\":\"当同一时间待执行的任务数量大于任务池工作线程数量，任务池会根据负载均衡机制进行扩容，增加工作线程数量，减少整体等待时长。同样，当执行的任务数量减少，工作线程数量大于执行任务数量，部分工作线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少工作线程数量。\",\"8\":\"\",\"9\":\"任务池API以数字形式返回错误码。如需了解各错误码的详细信息，请参阅文档[语言基础类库错误码](errorcode-utils.md)。\",\"10\":\"\",\"11\":\"taskpool使用过程中的相关注意点请查[TaskPool注意事项](../../arkts-utils/taskpool-introduction.md#taskpool注意事项)。\",\"12\":\"\"}",
      "修改建议": "“工作线程数量”与“线程数量”混用，建议统一使用“线程数量”",
      "更改后示例": "当同一时间待执行的任务数量大于线程数量，任务池会根据负载均衡机制进行扩容，增加线程数量，减少整体等待时长。同样，当执行的任务数量减少，线程数量大于执行任务数量，部分线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少线程数量。",
      "触发条件": "同一段落或相邻上下文中对同一概念使用两种及以上不同术语表述（如\"工作线程数量\"与\"线程数量\"交替出现），且术语变体间无明确语义区分需求。\n\n识别模式：\n1. 检测名词短语的重复变体（如带/不带修饰语的\"线程数量\"）\n2. 验证变体是否指代同一技术实体（通过上下文语义分析）\n3. 排除合理需要区分概念的场景（如确需强调\"工作线程\"特性时）"
    },
    {
      "defect_id": 557344,
      "sentence": "任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "reference_sentence": "任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.taskpool（启动任务池）\",\"2\":\"\",\"3\":\"任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程实例的生命周期。您可以使用任务池API创建后台任务（Task），并进行如执行任务或取消任务等操作。理论上，任务池API允许创建的任务数量不受限制，但由于内存限制，不建议这样做。此外，不建议在任务中执行阻塞操作，尤其是无限期阻塞操作，因为长时间的阻塞操作会占用工作线程，可能阻塞其他任务的调度，影响应用性能。\",\"4\":\"\",\"5\":\"您所创建的同一优先级任务的执行顺序可以由您决定，任务真实执行的顺序与您调用任务池API提供的任务执行接口顺序一致。任务默认优先级是MEDIUM。\",\"6\":\"\",\"7\":\"当同一时间待执行的任务数量大于任务池工作线程数量，任务池会根据负载均衡机制进行扩容，增加工作线程数量，减少整体等待时长。同样，当执行的任务数量减少，工作线程数量大于执行任务数量，部分工作线程处于空闲状态，任务池会根据负载均衡机制进行缩容，减少工作线程数量。\",\"8\":\"\"}",
      "修改建议": "“线程实例”与“线程”混用，建议统一使用“线程”",
      "更改后示例": "任务池的作用是为应用程序提供多线程运行环境，降低资源消耗并提升系统性能，且您无需关心线程的生命周期。",
      "触发条件": "同一文档中对同一概念存在两种及以上不同术语表述（如\"线程\"与\"线程实例\"），且这些术语在相邻上下文或技术定义场景中交替出现。\n\n识别模式：\n1. 概念同义性检测：通过术语库匹配或语义分析识别指代同一实体的不同表述\n2. 上下文密度分析：在相同段落/相邻段落中检测到同一概念的不同表达形式\n3. 技术定义验证：在核心功能描述场景下（如系统组件定义、API参数说明）出现术语不一致"
    },
    {
      "defect_id": 557448,
      "sentence": "The input parameters are invalid.",
      "reference_sentence": "Parameter error. Possible causes: 1. Incorrect parameter types; 2. Parameter verification failed.",
      "line_num": 1373,
      "context": "{\"1368\":\"\",\"1369\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1370\":\"\",\"1371\":\"| 错误码ID | 错误信息                                 |\",\"1372\":\"| -------- | --------------------------------------- |\",\"1373\":\"| 401       | The input parameters are invalid. |\",\"1374\":\"| 10200006  | An exception occurred during serialization. |\",\"1375\":\"| 10200022  | The function is not called in the TaskPool thread. |\",\"1376\":\"| 10200023  | The function is not called in the concurrent function. |\",\"1377\":\"| 10200024  | The callback is not registered on the host side. |\",\"1378\":\"\"}",
      "修改建议": "前后描述不一致，前文描述了参数错误的具体原因，后文仅描述参数无效",
      "更改后示例": "The input parameters are invalid because they do not meet the required format.",
      "触发条件": "当同一上下文或相邻条目中存在具体原因说明时，若当前描述仅给出笼统结论且未保持细节层级一致性（如错误码描述与前文原因说明/同列表其他条目存在信息断层），则触发该规则。"
    },
    {
      "defect_id": 557403,
      "sentence": "取消任务池中的任务。当任务在taskpool等待队列中，取消该任务后该任务将不再执行，并返回任务被取消的异常；当任务已经在taskpool工作线程执行，取消该任务并不影响任务继续执行，执行结果在catch分支返回，搭配isCanceled使用可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute/taskpool.executeDelayed生效。",
      "reference_sentence": "取消任务池中的任务。当任务在taskpool等待队列中，取消该任务后该任务将不再执行，并返回任务被取消的异常；当任务已经在taskpool工作线程执行，取消该任务并不影响任务继续执行，执行结果在catch分支返回，搭配isCanceled使用可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。",
      "line_num": 592,
      "context": "{\"587\":\"\",\"588\":\"## taskpool.cancel\",\"589\":\"\",\"590\":\"cancel(task: Task): void\",\"591\":\"\",\"592\":\"取消任务池中的任务。当任务在taskpool等待队列中，取消该任务后该任务将不再执行，并返回任务被取消的异常；当任务已经在taskpool工作线程执行，取消该任务并不影响任务继续执行，执行结果在catch分支返回，搭配isCanceled使用可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute/taskpool.executeDelayed生效。\",\"593\":\"\",\"594\":\"从API version 20开始，支持在执行cancel操作后，在catch分支里使用BusinessError<[taskpool.TaskResult](#taskresult20)>的泛型标记，来获取任务中抛出的异常信息或最终的执行结果。\",\"595\":\"\",\"596\":\"**系统能力：** SystemCapability.Utils.Lang\",\"597\":\"\"}",
      "修改建议": "混用了'/'和'或'，导致句式不一致。",
      "更改后示例": "取消任务池中的任务。当任务在taskpool等待队列中，取消该任务后该任务将不再执行，并返回任务被取消的异常；当任务已经在taskpool工作线程执行，取消该任务并不影响任务继续执行，执行结果在catch分支返回，搭配isCanceled使用可以对任务取消行为作出响应。taskpool.cancel对其之前的taskpool.execute或taskpool.executeDelayed生效。",
      "触发条件": "当同一并列结构中出现符号（如\"/\"）与连词（如\"或\"）混用，或同一文档不同位置对相同类型连接使用不一致的表达方式时触发。\n\n识别模式：检查文本中具有并列关系的词组/分句是否使用统一连接方式，重点识别以下特征：\n1. 同一句子内交替使用斜杠分隔符和文字连词（如\"参数A/参数B\"与\"选项X或选项Y\"并存）\n2. 相邻语句对相同语义的并列关系使用不同表达方式（如前半句用\"方法A/B\"，后半句用\"方法C或方法D\"）"
    },
    {
      "defect_id": 557390,
      "sentence": "周期任务每隔period时长执行一次。当前执行模式支持设置任务优先级，并可以通过调用cancel取消任务周期执行。周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。",
      "reference_sentence": "校验并发函数的参数类型和返回类型，然后周期性执行泛型任务，每隔period时长执行一次。",
      "line_num": 440,
      "context": "{\"435\":\"\",\"436\":\"## taskpool.executePeriodically<sup>12+</sup>\",\"437\":\"\",\"438\":\"executePeriodically(period: number, task: Task, priority?: Priority): void\",\"439\":\"\",\"440\":\"周期任务每隔period时长执行一次。当前执行模式支持设置任务优先级，并可以通过调用cancel取消任务周期执行。周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。\",\"441\":\"\",\"442\":\"\",\"443\":\"**系统能力：** SystemCapability.Utils.Lang\",\"444\":\"\",\"445\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\"}",
      "修改建议": "使用了不同的词汇描述同一操作（周期执行）",
      "更改后示例": "周期任务每隔period时长执行一次。当前执行模式支持设置任务优先级，并可以通过调用cancel取消周期任务的执行。周期任务不能是任务组任务、串行队列任务或异步队列任务，不能再次调用执行接口，且不能拥有依赖关系。",
      "触发条件": "同一文档中对同一操作或概念使用不同术语描述（如\"任务周期执行\"与\"周期任务的执行\"），且存在明确上下文关联（如共享核心名词\"周期任务\"）时触发。\n\n识别模式：\n1. 核心名词重复出现（如案例中\"周期任务\"出现3次）\n2. 动词短语结构不一致（\"取消任务周期执行\" vs 修复后的\"取消周期任务的执行\"）\n3. 存在参考句子的术语锚点（如案例中\"周期性执行\"与\"周期任务\"形成语义关联）\n4. 操作主体与动作表述不匹配（原句将\"周期任务\"作为被取消对象，但未保持主谓结构一致性）"
    },
    {
      "defect_id": 557346,
      "sentence": "将待执行的函数放入taskpool的内部任务队列。函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不支持取消任务。",
      "reference_sentence": "将待执行的函数放入taskpool的内部任务队列。函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不支持取消任务。",
      "line_num": 32,
      "context": "{\"27\":\"```\",\"28\":\"## taskpool.execute\",\"29\":\"\",\"30\":\"execute(func: Function, ...args: Object[]): Promise\\\\<Object>\",\"31\":\"\",\"32\":\"将待执行的函数放入taskpool的内部任务队列。函数不会立即执行，而是等待分发到工作线程执行。当前执行模式不支持取消任务。\",\"33\":\"\",\"34\":\"**系统能力：** SystemCapability.Utils.Lang\",\"35\":\"\",\"36\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"37\":\"\"}",
      "修改建议": "“工作线程”与“线程”混用，建议统一使用“线程”",
      "更改后示例": "将待执行的函数放入taskpool的内部任务队列。函数不会立即执行，而是等待分发到线程执行。当前执行模式不支持取消任务。",
      "触发条件": "同一技术概念在相邻上下文或同一文档中出现多个不一致的术语表述（如\"工作线程\"与\"线程\"混用），且未明确声明为同义词关系时触发。\n\n识别模式：通过对比相邻句子/段落中的技术术语，检测是否存在同一概念使用不同缩略词（如完整术语与简称）、修饰词（如带\"工作\"前缀）或近义词的情况，且上下文未提供术语等价性说明。"
    },
    {
      "defect_id": 557055,
      "sentence": "从当前缓冲区删除指定键及其关联值，并返回该键关联的值。如果键不存在，则返回 undefined。",
      "reference_sentence": "返回一个包含与键关联的值的Optional对象；如果key不存在，则返回undefined，如果key为null，则抛出异常。",
      "line_num": 1351,
      "context": "{\"1346\":\"\",\"1347\":\"### remove<sup>18+</sup>\",\"1348\":\"\",\"1349\":\"remove(key: K): V | undefined\",\"1350\":\"\",\"1351\":\"从当前缓冲区删除指定键及其关联值，并返回该键关联的值。如果键不存在，则返回 undefined。\",\"1352\":\"\",\"1353\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1354\":\"\",\"1355\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1356\":\"\"}",
      "修改建议": "描述不一致，前文使用了'从当前缓冲区删除指定键及其关联值，并返回该键关联的值。如果键不存在，则返回 undefined'，后文使用了'返回一个包含与键关联的值的Optional对象；如果key不存在，则返回undefined，如果key为null，则抛出异常'。",
      "更改后示例": "从当前缓冲区删除指定键及其关联值，并返回该键关联的值。如果键不存在，则返回 undefined；如果键为 null，则抛出异常。",
      "触发条件": "同一功能描述中存在多个条件分支但句式结构不一致，或参数/返回值的异常处理逻辑在不同段落中表述方式不统一。\n\n识别模式：\n1. 条件语句结构差异：当\"如果...则...\"句式出现分号分隔多条件（如参考句子）与独立短句（如问题句子）混合时\n2. 异常处理完整性缺失：当部分条件说明异常抛出（如\"抛出异常\"）而其他同类条件仅说明返回值（如\"返回undefined\"）时\n3. 参数约束分离表述：关键参数限制（如null检查）未与基础功能说明形成并列条件结构时触发"
    },
    {
      "defect_id": 557444,
      "sentence": "此接口可以设置任务池中ArrayBuffer的transfer列表，transfer列表中的ArrayBuffer对象在传输时不会复制buffer内容到工作线程而是转移buffer控制权至工作线程，传输后当前的ArrayBuffer失效。若ArrayBuffer为空，则不会transfer转移。",
      "reference_sentence": "所有传入cloneList的对象持有的[Sendable class](../../arkts-utils/arkts-sendable.md#sendable-class)实例或ArrayBuffer类型对象，在线程间传输的行为都会变成拷贝传递，即修改传输后的对象不会对原有对象产生任何影响。",
      "line_num": 1128,
      "context": "{\"1123\":\"\",\"1124\":\"设置任务的传输列表。使用该方法前需要先构造Task。不调用该接口，则传给任务的数据中的ArrayBuffer默认transfer转移。\",\"1125\":\"\",\"1126\":\"> **说明：**\",\"1127\":\">\",\"1128\":\"> 此接口可以设置任务池中ArrayBuffer的transfer列表，transfer列表中的ArrayBuffer对象在传输时不会复制buffer内容到工作线程而是转移buffer控制权至工作线程，传输后当前的ArrayBuffer失效。若ArrayBuffer为空，则不会transfer转移。\",\"1129\":\"\",\"1130\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1131\":\"\",\"1132\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1133\":\"\"}",
      "修改建议": "同一概念（ArrayBuffer的传输行为）使用了不同的表述（transfer转移 vs 拷贝传递）。",
      "更改后示例": "此接口可以设置任务池中ArrayBuffer的transfer列表，transfer列表中的ArrayBuffer对象在传输时不会复制buffer内容到工作线程而是转移buffer控制权至工作线程，传输后当前的ArrayBuffer失效。若ArrayBuffer为空，则不会转移。",
      "触发条件": "同一技术概念在相邻段落或同一上下文中出现术语表述不一致（如\"transfer转移\"与\"转移\"混用），或与参考句中的标准表述（如\"拷贝传递\"）形成非对称表达时触发。"
    },
    {
      "defect_id": 557349,
      "sentence": "从API version 13开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "line_num": 84,
      "context": "{\"79\":\"\",\"80\":\"校验并发函数的参数类型和返回类型，然后将待执行的函数放入taskpool的任务队列。\",\"81\":\"\",\"82\":\"**系统能力：** SystemCapability.Utils.Lang\",\"83\":\"\",\"84\":\"**原子化服务API**：从API version 13开始，该接口支持在原子化服务中使用。\",\"85\":\"\",\"86\":\"**参数：**\",\"87\":\"\",\"88\":\"| 参数名 | 类型      | 必填 | 说明                                                                   |\",\"89\":\"| ------ | --------- | ---- | ---------------------------------------------------------------------- |\"}",
      "修改建议": "混用了不同的API版本号，导致前后描述不一致。",
      "更改后示例": "从API v13开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一文档中同一术语存在不同缩写或全称形式（如“API version X”与“API vX”），且上下文存在已统一的标准表达模式。  \n\n识别模式：通过正则表达式匹配类似“API (version|v)\\d+”的结构，对比相邻段落或历史版本中同一术语的固定表达方式（如参考句中的“API version 11”），检测到缩写/全称混用即触发规则。"
    },
    {
      "defect_id": 557447,
      "sentence": "401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "reference_sentence": "401      | Parameter error. Possible causes: 1. Incorrect parameter types; 2. Parameter verification failed.",
      "line_num": 1211,
      "context": "{\"1206\":\"\",\"1207\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1208\":\"\",\"1209\":\"| 错误码ID | 错误信息                                                        |\",\"1210\":\"| -------- | -------------------------------------------------------------- |\",\"1211\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1212\":\"| 10200029 | An ArrayBuffer cannot be set as both a transfer list and a clone list. |\",\"1213\":\"\",\"1214\":\"**示例：**\",\"1215\":\"\",\"1216\":\"```ts\"}",
      "修改建议": "前后描述不一致，前文未提及必填参数未指定的情况",
      "更改后示例": "401      | Parameter error. Possible causes: 1. Required parameters are not specified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "触发条件": "当同一错误描述列表中存在术语混用（如\"Mandatory\"与\"Required\"交替出现）且与上下文/参考内容存在表述冲突时，或并列条目间出现语法结构不一致（如被动语态与主动语态混用）时。"
    },
    {
      "defect_id": 557363,
      "sentence": "如果该任务不是长时任务，可以多次调用executeDelayed执行；长时任务仅支持执行一次。",
      "reference_sentence": "系统将创建好的泛型任务放入taskpool内部任务队列。",
      "line_num": 325,
      "context": "{\"320\":\"\",\"321\":\"## taskpool.executeDelayed<sup>11+</sup>\",\"322\":\"\",\"323\":\"executeDelayed(delayTime: number, task: Task, priority?: Priority): Promise\\\\<Object>\",\"324\":\"\",\"325\":\"延时执行任务。当前执行模式可以设置任务优先级，并且可以尝试调用cancel取消任务。该任务不能是任务组任务、串行队列任务、异步队列任务或周期任务。如果该任务不是长时任务，可以多次调用executeDelayed执行；长时任务仅支持执行一次。\",\"326\":\"\",\"327\":\"**系统能力：** SystemCapability.Utils.Lang\",\"328\":\"\",\"329\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"330\":\"\"}",
      "修改建议": "句式不一致，前文使用‘将...放入...’，后文使用‘如果...可以...；...仅支持...’。",
      "更改后示例": "如果任务不是长时任务，可以多次调用executeDelayed执行；如果是长时任务，则仅支持执行一次。",
      "触发条件": "同一复合句或相邻分句中存在多个条件分支时，句式结构不一致（如一个分支使用\"如果...可以...\"完整结构，另一个分支缺少条件引导词或结果连接词）；或结果表达方式不对称（如主动态与被动态混用、肯定/否定形式不匹配）。"
    },
    {
      "defect_id": 557357,
      "sentence": "需要在任务池中执行的泛型任务。",
      "reference_sentence": "需要在任务池中执行的任务。",
      "line_num": 215,
      "context": "{\"210\":\"\",\"211\":\"**参数：**\",\"212\":\"\",\"213\":\"| 参数名   | 类型                  | 必填 | 说明                                       |\",\"214\":\"| -------- | --------------------- | ---- | ---------------------------------------- |\",\"215\":\"| task     | [GenericsTask<A, R>](#genericstask13)         | 是   | 需要在任务池中执行的泛型任务。                  |\",\"216\":\"| priority | [Priority](#priority) | 否   | 等待执行的任务的优先级，默认值为taskpool.Priority.MEDIUM。 |\",\"217\":\"\",\"218\":\"**返回值：**\",\"219\":\"\",\"220\":\"| 类型              | 说明              |\"}",
      "修改建议": "描述不一致，前文使用“任务”，后文使用“泛型任务”。",
      "更改后示例": "需要在任务池中执行的任务。",
      "触发条件": "同一术语在相邻或相关上下文中存在冗余修饰词（如\"泛型任务\" vs \"任务\"），或出现概念相同但表达不一致的词汇（如\"参数名\" vs \"参数名称\"）。当参数/返回值说明中的描述与类型定义（如`GenericsTask<A, R>`）或前文术语产生重复修饰时需触发。\n\n识别模式：\n1. **类型与描述重复**：参数类型字段已包含核心概念（如`GenericsTask`），描述语句中重复添加类型修饰词（如\"泛型\"）\n2. **跨段落一致性**：检查当前参数说明与前文/表格标题等位置是否使用相同术语（如全局用\"任务\"则局部禁止出现\"泛型任务\"）\n3. **修饰词必要性**：通过语义分析判断修饰词（如\"泛型\"）是否在类型定义中已隐含，若冗余则删除以保持统一"
    },
    {
      "defect_id": 557056,
      "sentence": "检查当前缓冲区是否包含指定的键。如果存在，返回true；否则，返回false。",
      "reference_sentence": "如果缓冲区包含指定的键，则返回true，否则返回false。",
      "line_num": 1383,
      "context": "{\"1378\":\"\",\"1379\":\"### contains<sup>18+</sup>\",\"1380\":\"\",\"1381\":\"contains(key: K): boolean\",\"1382\":\"\",\"1383\":\"检查当前缓冲区是否包含指定的键。如果存在，返回true；否则，返回false。\",\"1384\":\"\",\"1385\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1386\":\"\",\"1387\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1388\":\"\"}",
      "修改建议": "描述不一致，前文使用了'检查当前缓冲区是否包含指定的键。如果存在，返回true；否则，返回false'，后文使用了'如果缓冲区包含指定的键，则返回true，否则返回false'。",
      "更改后示例": "检查当前缓冲区是否包含指定的键。如果缓冲区包含指定的键，则返回true；否则，返回false。",
      "触发条件": "同一句子或相邻上下文中对同一条件或操作的描述存在术语不一致（如“存在”与“包含指定的键”交替使用），或与文档其他部分定义的术语模式不匹配。\n\n识别模式：\n1. **术语冲突检测**：对比条件句中的主语/动词是否与上下文定义的核心术语一致（例如“缓冲区包含键”是核心概念，但后文简化为“存在”）；\n2. **指代一致性验证**：检查条件分支（如if/else）是否重复使用完整描述而非模糊指代（如用“缓冲区包含键”替代代词“存在”）。"
    },
    {
      "defect_id": 557468,
      "sentence": "The input parameters are invalid.",
      "reference_sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "line_num": 1609,
      "context": "{\"1604\":\"\",\"1605\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1606\":\"\",\"1607\":\"| 错误码ID | 错误信息                       |\",\"1608\":\"| -------- | ------------------------------ |\",\"1609\":\"| 401       | The input parameters are invalid. |\",\"1610\":\"| 10200034  | The executed task does not support the registration of listeners. |\",\"1611\":\"\",\"1612\":\"**示例：**\",\"1613\":\"\",\"1614\":\"```ts\"}",
      "修改建议": "混用了“The input parameters are invalid.”和“Parameter error.”描述参数错误，且描述方式不一致。",
      "更改后示例": "Parameter error.",
      "触发条件": "同一错误类型或参数问题在相邻上下文中存在两种及以上不同的表达方式（如完整句与短语混用），且未遵循参考句子的既定术语模式。"
    },
    {
      "defect_id": 557457,
      "sentence": "使用该方法前，需先构造Task。",
      "reference_sentence": "使用该方法前需先构造Task。",
      "line_num": 1526,
      "context": "{\"1521\":\"\",\"1522\":\"### removeDependency<sup>11+</sup>\",\"1523\":\"\",\"1524\":\"removeDependency(...tasks: Task[]): void\",\"1525\":\"\",\"1526\":\"删除当前任务对其他任务的依赖。使用该方法前，需先构造Task。\",\"1527\":\"\",\"1528\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1529\":\"\",\"1530\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1531\":\"\"}",
      "修改建议": "用词不一致，'使用该方法前，需先构造Task。'与'使用该方法前需先构造Task。'句式不一致",
      "更改后示例": "使用该方法前需先构造Task。",
      "触发条件": "同一文档内存在相同句式但标点符号（如逗号）使用不一致，或连接词（如\"前需\"）被标点分割导致句式冗余时触发。\n\n识别模式：当句子结构为「条件状语+需操作」时（如\"使用...前，需...\"），若上下文同类句式未使用逗号分割（如\"使用...前需...\"），则判定为句式冗余不一致。需对比文档内其他相似语法结构的标点使用模式进行校验。"
    },
    {
      "defect_id": 557350,
      "sentence": "参数验证失败。",
      "reference_sentence": "Parameter verification failed.",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"102\":\"\",\"103\":\"| 错误码ID | 错误信息                                      |\",\"104\":\"| -------- | -------------------------------------------- |\",\"105\":\"| 401      | Parameter error. Possible causes: 1.Incorrect parameter types; 2.Parameter verification failed. |\",\"106\":\"| 10200006 | An exception occurred during serialization.  |\",\"107\":\"| 10200014 | The function is not marked as concurrent.      |\",\"108\":\"\",\"109\":\"**示例：**\",\"110\":\"\"}",
      "修改建议": "中文和英文混用，且用词不一致。",
      "更改后示例": "参数验证未通过。",
      "触发条件": "同一上下文或相邻内容中存在中英文混用，或同一术语的中文表达不一致（如“失败”与“未通过”混用）。具体表现为技术术语/错误描述在中文和英文版本间未严格对应，或同一语言内用词不统一。"
    },
    {
      "defect_id": 557470,
      "sentence": "The input parameters are invalid.",
      "reference_sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "line_num": 1706,
      "context": "{\"1701\":\"\",\"1702\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1703\":\"\",\"1704\":\"| 错误码ID | 错误信息                       |\",\"1705\":\"| -------- | ------------------------------ |\",\"1706\":\"| 401       | The input parameters are invalid. |\",\"1707\":\"| 10200034  | The executed task does not support the registration of listeners. |\",\"1708\":\"\",\"1709\":\"**示例：**\",\"1710\":\"\",\"1711\":\"```ts\"}",
      "修改建议": "混用了“The input parameters are invalid.”和“Parameter error.”描述参数错误，且描述方式不一致。",
      "更改后示例": "Parameter error.",
      "触发条件": "同一文档上下文中，对同一类型错误（如参数错误）的描述存在术语（如“input parameters”与“parameter”）或句式结构（完整句与短语）不一致时触发。"
    },
    {
      "defect_id": 557510,
      "sentence": "1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. 3.Parameter verification failed.",
      "reference_sentence": "1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. 3. Parameter verification failed.",
      "line_num": 2186,
      "context": "{\"2181\":\"\",\"2182\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"2183\":\"\",\"2184\":\"| 错误码ID | 错误信息 |\",\"2185\":\"| -------- | -------- |\",\"2186\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. 3.Parameter verification failed. |\",\"2187\":\"\",\"2188\":\"**示例：**\",\"2189\":\"\",\"2190\":\"```ts\",\"2191\":\"let runner:taskpool.SequenceRunner = new taskpool.SequenceRunner(\\\"runner1\\\", taskpool.Priority.LOW);\"}",
      "修改建议": "标点符号不一致，原句中每个条目之间使用了“.”分隔，建议保持一致。",
      "更改后示例": "1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. 3. Parameter verification failed.",
      "触发条件": "同一结构内的多个条目存在标点符号不一致（如混合使用\".\"分隔与无分隔符）或格式不统一（如数字编号后空格缺失），且上下文呈现并列关系时触发。\n\n识别模式：\n1. 结构特征：包含数字编号的并列条目（如1. XXXX 2. YYYY）\n2. 不一致表现：条目间分隔符差异（如\". \"与无符号）、空格缺失（如3.Parameter）、标点类型混用\n3. 上下文线索：位于表格单元格、错误码说明等需要清晰排版的格式化内容区域"
    },
    {
      "defect_id": 557508,
      "sentence": "SequenceRunner的构造函数，用于构造一个全局串行队列。如果名字相同，将返回同一个串行队列。",
      "reference_sentence": "SequenceRunner的构造函数。",
      "line_num": 2162,
      "context": "{\"2157\":\"\",\"2158\":\"### constructor<sup>12+</sup>\",\"2159\":\"\",\"2160\":\"constructor(name: string, priority?: Priority)\",\"2161\":\"\",\"2162\":\"SequenceRunner的构造函数，用于构造一个全局串行队列。如果名字相同，将返回同一个串行队列。\",\"2163\":\"\",\"2164\":\"> **说明：**\",\"2165\":\">\",\"2166\":\"> - 底层通过单例模式保证了：创建同名串行队列时，获取到同一个实例。\",\"2167\":\"> - 无法修改串行队列的优先级。\"}",
      "修改建议": "描述不一致，原句描述了额外的功能，建议保持简洁一致。",
      "更改后示例": "SequenceRunner的构造函数，用于构造一个全局串行队列。",
      "触发条件": "当句子在描述同一功能时，出现与上下文或参考示例中不一致的冗余细节（如额外功能说明、实现原理），且该细节已在其他独立模块（如说明块）明确覆盖时触发。\n\n识别模式：\n1. 存在功能描述与实现原理混合（如构造函数用途中混入单例模式行为）\n2. 出现与当前模块职责不符的重复信息（如参数描述区复现说明区已声明的特性）"
    },
    {
      "defect_id": 557469,
      "sentence": "The input parameters are invalid.",
      "reference_sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "line_num": 1658,
      "context": "{\"1653\":\"\",\"1654\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1655\":\"\",\"1656\":\"| 错误码ID | 错误信息                       |\",\"1657\":\"| -------- | ------------------------------ |\",\"1658\":\"| 401       | The input parameters are invalid. |\",\"1659\":\"| 10200034  | The executed task does not support the registration of listeners. |\",\"1660\":\"\",\"1661\":\"**示例：**\",\"1662\":\"\",\"1663\":\"```ts\"}",
      "修改建议": "混用了“The input parameters are invalid.”和“Parameter error.”描述参数错误，且描述方式不一致。",
      "更改后示例": "Parameter error.",
      "触发条件": "同一上下文或相邻条目中存在描述同一概念但表达方式不一致的短语或句子（如错误信息混用完整句与短语），且存在已确认的参考表达模式时触发。"
    },
    {
      "defect_id": 557443,
      "sentence": "不调用该接口，则传给任务的数据中的ArrayBuffer默认transfer转移。",
      "reference_sentence": "所有传入cloneList的对象持有的[Sendable class](../../arkts-utils/arkts-sendable.md#sendable-class)实例或ArrayBuffer类型对象，在线程间传输的行为都会变成拷贝传递，即修改传输后的对象不会对原有对象产生任何影响。",
      "line_num": 1124,
      "context": "{\"1119\":\"\",\"1120\":\"### setTransferList<sup>10+</sup>\",\"1121\":\"\",\"1122\":\"setTransferList(transfer?: ArrayBuffer[]): void\",\"1123\":\"\",\"1124\":\"设置任务的传输列表。使用该方法前需要先构造Task。不调用该接口，则传给任务的数据中的ArrayBuffer默认transfer转移。\",\"1125\":\"\",\"1126\":\"> **说明：**\",\"1127\":\">\",\"1128\":\"> 此接口可以设置任务池中ArrayBuffer的transfer列表，transfer列表中的ArrayBuffer对象在传输时不会复制buffer内容到工作线程而是转移buffer控制权至工作线程，传输后当前的ArrayBuffer失效。若ArrayBuffer为空，则不会transfer转移。\",\"1129\":\"\"}",
      "修改建议": "同一概念（ArrayBuffer的传输行为）使用了不同的表述（transfer转移 vs 拷贝传递）。",
      "更改后示例": "不调用该接口，则传给任务的数据中的ArrayBuffer默认转移。",
      "触发条件": "同一技术概念在相邻或关联上下文中出现中英文混合术语（如\"transfer转移\"）或同义异形表述（如\"转移\" vs \"拷贝传递\"），且存在已明确定义的参考表述（如\"拷贝传递\"）时触发。\n\n识别模式：\n1. 检测相邻段落/句子中描述同一技术行为时，是否混用中英文组合术语（如transfer转移）与纯中文术语（如转移）\n2. 对比当前表述与文档中已存在的权威定义（如参考句中的\"拷贝传递\"），判断是否存在同概念不同表述的情况\n3. 特别关注包含技术动作动词的短语（如\"转移/传输/传递\"），检查其修饰词（transfer/拷贝）是否与上下文定义保持一致"
    },
    {
      "defect_id": 557491,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 13开始，该接口支持在原子化服务中使用。",
      "line_num": 1994,
      "context": "{\"1989\":\"\",\"1990\":\"这是TaskGroup的构造函数。\",\"1991\":\"\",\"1992\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1993\":\"\",\"1994\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1995\":\"\",\"1996\":\"**示例：**\",\"1997\":\"\",\"1998\":\"```ts\",\"1999\":\"let taskGroup = new taskpool.TaskGroup();\"}",
      "修改建议": "描述API版本支持的不一致",
      "更改后示例": "从API版本11开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一术语在文档中存在中英文混用（如\"version\"与\"版本\"交替出现），或与上下文/参考句中的既定表达形式（如\"API version\"与\"API版本\"）不统一。"
    },
    {
      "defect_id": 557493,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 13开始，该接口支持在原子化服务中使用。",
      "line_num": 2042,
      "context": "{\"2037\":\"\",\"2038\":\"将待执行的函数添加到任务组。使用此方法前需先创建TaskGroup。\",\"2039\":\"\",\"2040\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2041\":\"\",\"2042\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2043\":\"\",\"2044\":\"**参数：**\",\"2045\":\"\",\"2046\":\"| 参数名 | 类型      | 必填 | 说明                                                                   |\",\"2047\":\"| ------ | --------- | ---- | ---------------------------------------------------------------------- |\"}",
      "修改建议": "描述API版本支持的不一致",
      "更改后示例": "从API版本11开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一文档中相邻或相关段落对同一术语（如“API version”与“API版本”）存在中英文混用或不一致表达，且存在明确参考实例（如历史版本描述）时触发。"
    },
    {
      "defect_id": 557509,
      "sentence": "创建同名串行队列时，获取到同一个实例。",
      "reference_sentence": "底层通过单例模式保证了：创建同名串行队列时，获取到同一个实例。",
      "line_num": 2166,
      "context": "{\"2161\":\"\",\"2162\":\"SequenceRunner的构造函数，用于构造一个全局串行队列。如果名字相同，将返回同一个串行队列。\",\"2163\":\"\",\"2164\":\"> **说明：**\",\"2165\":\">\",\"2166\":\"> - 底层通过单例模式保证了：创建同名串行队列时，获取到同一个实例。\",\"2167\":\"> - 无法修改串行队列的优先级。\",\"2168\":\"\",\"2169\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2170\":\"\",\"2171\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\"}",
      "修改建议": "描述不一致，原句使用了“单例模式”这一专业术语，建议保持一致。",
      "更改后示例": "创建同名串行队列时，通过单例模式获取到同一个实例。",
      "触发条件": "当文档中同一技术概念存在专业术语与普通描述混用，且上下文已明确使用专业术语时，应触发语言表达一致性规则。识别模式为：检查是否存在核心机制（如单例模式）在说明性语句中使用非专业表述（如\"返回同一个实例\"），而参考性语句已采用对应专业术语的情况。"
    },
    {
      "defect_id": 557492,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "从API version 13开始，该接口支持在原子化服务中使用。",
      "line_num": 2010,
      "context": "{\"2005\":\"\",\"2006\":\"TaskGroup的构造函数可以指定任务组名称。\",\"2007\":\"\",\"2008\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2009\":\"\",\"2010\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2011\":\"\",\"2012\":\"**参数：**\",\"2013\":\"\",\"2014\":\"| 参数名 | 类型   | 必填 | 说明         |\",\"2015\":\"| ------ | ------ | ---- | ------------ |\"}",
      "修改建议": "描述API版本支持的不一致",
      "更改后示例": "从API版本11开始，该接口支持在原子化服务中使用。",
      "触发条件": "同一术语在文档中存在中英文混用（如\"version\"与\"版本\"），且上下文中存在该术语的规范表达作为参考基准。"
    },
    {
      "defect_id": 557535,
      "sentence": "执行异步任务。使用该方法前需要先创建AsyncRunner。",
      "reference_sentence": "构造一个非全局的异步队列，即使参数相同，返回的也是不同的异步队列。",
      "line_num": 2348,
      "context": "{\"2343\":\"\",\"2344\":\"### execute<sup>18+</sup>\",\"2345\":\"\",\"2346\":\"execute(task: Task, priority?: Priority): Promise\\\\<Object>\",\"2347\":\"\",\"2348\":\"执行异步任务。使用该方法前需要先创建AsyncRunner。\",\"2349\":\"\",\"2350\":\"> **说明：**\",\"2351\":\">\",\"2352\":\"> - 不支持执行任务组中的任务。\",\"2353\":\"> - 不支持执行串行队列任务。\"}",
      "修改建议": "混用了`创建`和`构造`概念",
      "更改后示例": "执行异步任务。使用该方法前需要先构造AsyncRunner。",
      "触发条件": "同一技术概念在相邻或相关上下文中使用了不同动词（如“创建”与“构造”），且存在已明确定义的统一表达方式（如参考句中的“构造”）。通过对比当前句子与上下文/参考句的动词选择差异进行识别。"
    },
    {
      "defect_id": 557475,
      "sentence": "检查任务是否已完成。",
      "reference_sentence": "检查任务是否已完成。",
      "line_num": 1790,
      "context": "{\"1785\":\"\",\"1786\":\"### isDone<sup>12+</sup>\",\"1787\":\"\",\"1788\":\"isDone(): boolean\",\"1789\":\"\",\"1790\":\"检查任务是否已完成。\",\"1791\":\"\",\"1792\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1793\":\"\",\"1794\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\",\"1795\":\"\"}",
      "修改建议": "前后描述不一致，'检查任务是否已完成'与'任务执行完成返回true，任务未执行完成返回false'句式不一致。",
      "更改后示例": "返回任务是否已完成。",
      "触发条件": "当函数描述中的动作动词（如\"检查\"）与函数实际行为（如返回布尔值）存在语义矛盾，或与上下文相同功能的描述句式不匹配时触发。\n\n识别模式：\n1. 检测描述语句的主谓结构（动词+宾语），当动词与函数返回值的逻辑关系不匹配时（如返回判断结果应使用\"返回...是否...\"而非\"检查...\"）\n2. 对比上下文相邻接口的句式结构，识别同一功能模块中不一致的表达模式（如参数说明用\"返回\"而方法说明用\"检查\"）"
    },
    {
      "defect_id": 557474,
      "sentence": "注册回调函数，确保在任务执行前完成注册。任务成功时，将调用此回调函数。未在任务执行前注册将导致异常抛出。",
      "reference_sentence": "注册回调函数，并在任务执行前调用。若未在任务执行前注册，将抛出异常。",
      "line_num": 1742,
      "context": "{\"1737\":\"\",\"1738\":\"### onExecutionSucceeded<sup>12+</sup>\",\"1739\":\"\",\"1740\":\"onExecutionSucceeded(callback: CallbackFunction): void\",\"1741\":\"\",\"1742\":\"注册回调函数，确保在任务执行前完成注册。任务成功时，将调用此回调函数。未在任务执行前注册将导致异常抛出。\",\"1743\":\"\",\"1744\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1745\":\"\",\"1746\":\"**原子化服务API**：从API version 12开始，该接口支持在原子化服务中使用。\",\"1747\":\"\"}",
      "修改建议": "前后描述不一致，'确保在任务执行前完成注册'与'若未在任务执行前注册，将抛出异常'表意不清晰，且'任务成功时'与'若未在任务执行前注册'句式不一致。",
      "更改后示例": "注册回调函数，确保在任务执行前完成注册。任务成功时，将调用此回调函数；若未在任务执行前注册，将抛出异常。",
      "触发条件": "同一语义的正反陈述存在结构不对称（如肯定/否定句式混用），或相邻逻辑描述使用不一致的句式（如陈述句与条件句混用）。\n\n具体识别模式：\n1. 检测同一段落中针对同一逻辑点的正反描述（如\"确保X\"与\"未X将Y\"）\n2. 分析相邻句子的语法结构：\n   - 前半部分使用\"确保...\"的祈使句式\n   - 后半部分未保持相同条件结构（如缺少\"若...\"条件引导词）\n3. 检查标点符号一致性（如分号连接并列逻辑，句号分割独立逻辑）"
    },
    {
      "defect_id": 557497,
      "sentence": "将创建好的任务添加到任务组中。使用该方法前需要先构造TaskGroup。任务组不能添加其他任务组中的任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。",
      "reference_sentence": "将待执行的函数添加到任务组。使用此方法前需先创建TaskGroup。",
      "line_num": 2077,
      "context": "{\"2072\":\"\",\"2073\":\"### addTask<sup>10+</sup>\",\"2074\":\"\",\"2075\":\"addTask(task: Task): void\",\"2076\":\"\",\"2077\":\"将创建好的任务添加到任务组中。使用该方法前需要先构造TaskGroup。任务组不能添加其他任务组中的任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。\",\"2078\":\"\",\"2079\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2080\":\"\",\"2081\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"2082\":\"\"}",
      "修改建议": "混用了“构造”和“创建”概念，以及“此”和“该”近义词混用。",
      "更改后示例": "将创建好的任务添加到任务组中。使用此方法前需要先创建TaskGroup。任务组不能添加其他任务组中的任务、串行队列任务、异步队列任务、有依赖关系的任务、长时任务、周期任务和已执行的任务。",
      "触发条件": "同一技术概念出现多个不同动词表述（如\"构造\"与\"创建\"混用），或同一指代对象使用不同限定词（如\"该\"与\"此\"交替出现）。\n\n识别模式：\n1. 动词一致性检测：识别技术操作动词是否与上下文/参考句保持统一（如参考句用\"创建\"则禁用\"构造\"）\n2. 指代一致性检测：检查限定词在相邻段落中的使用规律（如前后文统一使用\"此方法\"时禁用\"该方法\"）\n3. 术语映射检查：建立技术术语标准词库（如TaskGroup操作统一使用\"创建\"而非\"构造\"），检测非常用表达"
    },
    {
      "defect_id": 557525,
      "sentence": "取值需大于等于0，负数时报错，非整数输入会向下取整。",
      "reference_sentence": "取值需大于等于0，负数时报错，非整数时会向下取整。",
      "line_num": 2328,
      "context": "{\"2323\":\"\",\"2324\":\"| 参数名   | 类型                  | 必填 | 说明                                                       |\",\"2325\":\"| -------- | --------------------- | ---- | ---------------------------------------------------------- |\",\"2326\":\"| name     | string                | 是   | 异步队列的名字。 |\",\"2327\":\"| runningCapacity | number | 是   | 指定任务执行的最大并发度，该参数应为正整数。如果为负数，将会报错；如果为非整数，将会向下取整。 |\",\"2328\":\"| waitingCapacity | number | 否   | 指定等待任务的列表容量，取值需大于等于0，负数时报错，非整数输入会向下取整。默认值为0，表示等待任务列表的容量没有限制。如果设置大于0的值，则表示排队策略为丢弃策略，当加入的任务数量超过该值时，等待列表中处于队头的任务会被丢弃。 |\",\"2329\":\"\",\"2330\":\"**错误码：**\",\"2331\":\"\",\"2332\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"2333\":\"\"}",
      "修改建议": "描述方式不一致，一个使用“非整数输入”，一个使用“非整数时”",
      "更改后示例": "取值需大于等于0，负数时报错，非整数时会向下取整。",
      "触发条件": "同一段落内存在相同语义的条件描述但使用不同连接词（如\"时\"与\"输入\"混用），且上下文存在统一表达范式时。\n\n识别模式：\n1. 检测相邻条件句的语法结构差异（如\"负数时...报错\"与\"非整数输入...取整\"）\n2. 对比上下文参数描述范式（如runningCapacity参数使用\"如果为...将会\"的统一结构）\n3. 发现相同语义成分使用不同时间状语（\"时\"）与名词性短语（\"输入\"）的搭配冲突"
    },
    {
      "defect_id": 557442,
      "sentence": "检查当前正在运行的任务是否已取消。在使用此方法之前，需要先构造一个Task对象。",
      "reference_sentence": "使用该方法前需要先构造Task。",
      "line_num": 1056,
      "context": "{\"1051\":\"\",\"1052\":\"### isCanceled<sup>10+</sup>\",\"1053\":\"\",\"1054\":\"static isCanceled(): boolean\",\"1055\":\"\",\"1056\":\"检查当前正在运行的任务是否已取消。在使用此方法之前，需要先构造一个Task对象。\",\"1057\":\"\",\"1058\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1059\":\"\",\"1060\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"1061\":\"\"}",
      "修改建议": "同一概念（构造Task对象）使用了不同的表述。",
      "更改后示例": "检查当前正在运行的任务是否已取消。使用此方法前，需要先创建一个Task对象。",
      "触发条件": "在同一上下文或相邻语句中，针对同一技术动作（如对象创建）出现两个及以上不同动词表述（如\"构造\"与\"创建\"），且存在已明确定义的参考表述（如\"构造\"被参考句子使用）时触发。"
    },
    {
      "defect_id": 557547,
      "sentence": "取消处于等待或执行过程中的任务后，catch分支会捕获到BusinessError中的补充信息。在其他场景下，该信息为undefined。",
      "reference_sentence": "任务被取消后，有如下两种情况：",
      "line_num": 2491,
      "context": "{\"2486\":\"| threadInfos   | [ThreadInfo[]](#threadinfo10)    | 是   | 否   | 工作线程的内部信息。   |\",\"2487\":\"| taskInfos     | [TaskInfo[]](#taskinfo10)        | 是   | 否   | 任务的内部信息。       |\",\"2488\":\"\",\"2489\":\"## TaskResult<sup>20+</sup>\",\"2490\":\"\",\"2491\":\"取消处于等待或执行过程中的任务后，catch分支会捕获到BusinessError中的补充信息。在其他场景下，该信息为undefined。\",\"2492\":\"\",\"2493\":\"**系统能力：** SystemCapability.Utils.Lang\",\"2494\":\"\",\"2495\":\"### 属性\",\"2496\":\"\"}",
      "修改建议": "在同一文档中，'取消'与'任务被取消'表述不一致，建议统一。",
      "更改后示例": "任务被取消处于等待或执行过程后，catch分支会捕获到BusinessError中的补充信息。在其他场景下，该信息为undefined。",
      "触发条件": "同一文档中对同一动作或状态存在主语省略（如“取消”）与完整主被动结构（如“任务被取消”）混用，且上下文已存在明确统一表达范式时触发。识别模式需检测动词短语是否与参考句中的主谓结构（含隐含被动关系）产生语义重复但形式不一致的表达冲突。"
    },
    {
      "defect_id": 557524,
      "sentence": "如果队列名称相同，将返回同一个异步队列。",
      "reference_sentence": "如果名字相同，将返回同一个串行队列。",
      "line_num": 2311,
      "context": "{\"2306\":\"\",\"2307\":\"### constructor<sup>18+</sup>\",\"2308\":\"\",\"2309\":\"constructor(name: string, runningCapacity: number, waitingCapacity?: number)\",\"2310\":\"\",\"2311\":\"AsyncRunner的构造函数用于构造一个全局异步队列。如果队列名称相同，将返回同一个异步队列。\",\"2312\":\"\",\"2313\":\"> **说明：**\",\"2314\":\">\",\"2315\":\"> - 底层通过单例模式确保创建同名的异步队列时，获取同一个实例。\",\"2316\":\"> - 不支持修改并发度和等待任务列表容量。\"}",
      "修改建议": "前后描述不一致，一个描述为“队列名称相同”，一个描述为“名字相同”",
      "更改后示例": "如果队列名称相同，将返回同一个异步队列实例。",
      "触发条件": "同一概念在相邻或相关描述中使用了不同术语（如\"名称\"与\"名字\"），或关键实体描述存在成分缺失（如\"队列\"未明确为\"队列实例\"）。\n\n识别模式：\n1. 术语一致性检测：对比当前句与上下文(特别是参数名、接口说明、参考示例)的关键术语是否统一\n2. 实体完整性验证：检查技术实体是否缺少必要限定词（如未区分\"类\"与\"实例\"等面向对象概念）"
    },
    {
      "defect_id": 557548,
      "sentence": "如果当前任务处于等待阶段，result为undefined，error与BusinessError的message字段一致；",
      "reference_sentence": "如果当前任务正在运行，有异常抛出的情况下result的值为undefined，error的值为抛出的异常信息；没有异常的情况下，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。",
      "line_num": 2509,
      "context": "{\"2504\":\"| error   | Error \\\\| Object   | 否   | 是   | 错误信息。默认和BusinessError的message字段一致。不推荐修改此值。 |\",\"2505\":\"\",\"2506\":\"> **说明：**\",\"2507\":\">\",\"2508\":\"> 任务被取消后，有如下两种情况：\",\"2509\":\">    - 如果当前任务处于等待阶段，result为undefined，error与BusinessError的message字段一致；\",\"2510\":\">    - 如果当前任务正在运行，有异常抛出的情况下result的值为undefined，error的值为抛出的异常信息；没有异常的情况下，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。\",\"2511\":\">\",\"2512\":\"\",\"2513\":\"**示例**\",\"2514\":\"\"}",
      "修改建议": "在同一文档中，'与'与'和'表述不一致，建议统一。",
      "更改后示例": "如果当前任务处于等待阶段，result为undefined，error和BusinessError的message字段一致；",
      "触发条件": "当同一文档中出现相同语义的并列结构时，若存在\"与/和\"、\"或/或者\"等近义连词混用，且上下文存在统一用词范例时触发。\n\n识别模式：\n1. 检测并列结构中的连词类型（如\"与\"和\"和\"）\n2. 比对同一文档中相邻段落或相同语义场景的参考表达（如示例中的2504行和2510行均使用\"和\"）\n3. 当同一语义关系出现两种及以上连词表达时判定为不一致"
    }
  ]
}