{
  "规则ID": 11,
  "规则名称": "冗余表达",
  "规则描述": "待提取 - 冗余表达的规则描述",
  "正面示例": [
    {
      "defect_id": 103603,
      "sentence": "可以上报事件的数据处理者对象。",
      "reference_sentence": "",
      "line_num": 64,
      "context": "",
      "用户拒绝的修改": "提供上报事件的数据处理者对象。",
      "注意事项": "修复冗余表达时应优先保持原句核心信息完整，仅在确实存在重复语义时调整措辞，避免将简单句复杂化；修改前需确认\"冗余\"的具体位置（如\"数据处理者对象\"中\"对象\"是否冗余），而非盲目添加主谓宾结构。"
    },
    {
      "defect_id": 103610,
      "sentence": "事件定时上报时间周期，单位为秒。传入数值必须大于或等于0，小于0时会被置为默认值0，不进行定时上报。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 76,
      "context": "",
      "用户拒绝的修改": "事件定时上报时间周期，单位为秒。数值必须大于或等于0，小于0时置为默认值0，不进行定时上报。<br>**原子化服务API：** 从API version 11开始支持。",
      "注意事项": "修复冗余表达时需确保技术参数（如\"传入数值\"中的\"传入\"）和被动语态（如\"会被置为\"中的系统行为）等关键信息不丢失，优先通过拆分长句或调整句式简化结构，而非直接删除技术性限定词。"
    },
    {
      "defect_id": 103676,
      "sentence": "应用资源泄露事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1030,
      "context": "",
      "用户拒绝的修改": "应用资源泄露事件。",
      "注意事项": "修复冗余表达时需精准识别并删除重复修饰语（如\"从API version 12开始\"中的时间状语），同时优化标点结构避免逗号滥用，确保修改后的句子既保持核心信息完整又符合技术文档简洁性要求。"
    },
    {
      "defect_id": 103670,
      "sentence": "应用崩溃事件。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1024,
      "context": "",
      "用户拒绝的修改": "应用崩溃事件。",
      "注意事项": "修复冗余表达时应优先保留技术文档的规范性表述（如API版本号等关键参数），避免过度删除导致技术信息缺失；需特别警惕复合句中的结构性冗余与技术说明的必要重复，使用语法分析准确识别真正冗余成分。"
    },
    {
      "defect_id": 103679,
      "sentence": "## hiappevent.param",
      "reference_sentence": "",
      "line_num": 1035,
      "context": "",
      "用户拒绝的修改": "hiappevent.param",
      "注意事项": "修复冗余表达时需优先识别上下文格式规范，避免误删必要的结构性标记（如标题符号）；同时结合用户意图明确区分“冗余内容”与“格式要求”，仅在确认标记无实际功能时进行简化。"
    },
    {
      "defect_id": 103674,
      "sentence": "应用CPU高负载事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1028,
      "context": "",
      "用户拒绝的修改": "应用CPU高负载事件。",
      "注意事项": "修复冗余表达时需保留关键性技术参数（如API版本号、支持环境等核心信息），优先调整句式结构（如拆分过长的修饰成分）而非直接删除技术文档的必要功能说明。"
    },
    {
      "defect_id": 103672,
      "sentence": "应用启动耗时事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1026,
      "context": "",
      "用户拒绝的修改": "应用启动耗时事件。",
      "注意事项": "修复冗余表达时需精准识别冗余成分，避免误删必要技术信息；优先调整标点结构而非直接删除整句，例如将长句拆分为\"应用启动耗时事件。该接口从API version 12起支持原子化服务（API标注移至末尾）\"。"
    },
    {
      "defect_id": 103671,
      "sentence": "应用卡死事件。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1025,
      "context": "",
      "用户拒绝的修改": "应用卡死事件。",
      "注意事项": "修复冗余表达时应优先保留关键信息(如技术参数、版本号等必要修饰成分)，避免因过度简化导致语义缺失；需结合上下文准确区分冗余修饰和必要限定条件，不得删除影响技术准确性的内容。"
    },
    {
      "defect_id": 103626,
      "sentence": "上报事件数据处理者ID。值大于0。",
      "reference_sentence": "",
      "line_num": 112,
      "context": "",
      "用户拒绝的修改": "上报事件数据处理者ID，值大于0。",
      "注意事项": "修复冗余表达时应优先理解功能需求本质，避免仅进行标点符号替换，需通过语义重组直接呈现核心信息（如改为\"上报事件数据处理者ID（需为正整数）\"）。"
    },
    {
      "defect_id": 103678,
      "sentence": "应用主线程超时事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1032,
      "context": "",
      "用户拒绝的修改": "应用主线程超时事件。",
      "注意事项": "修复时应精准识别冗余成分（如重复指代、冗长结构），保留关键信息（如API版本号等必要技术规格），避免过度删除导致技术细节丢失。"
    },
    {
      "defect_id": 103673,
      "sentence": "应用滑动丢帧事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1027,
      "context": "",
      "用户拒绝的修改": "应用滑动丢帧事件。",
      "注意事项": "修复冗余表达时需精准识别并保留关键信息（如API版本号等必要技术细节），避免过度删除导致语义缺失；同时应优先调整句式结构而非直接删除整句，确保技术文档的准确性和完整性。"
    },
    {
      "defect_id": 103622,
      "sentence": "事件领域名称支持数字、字母、下划线字符，需要以字母开头且不能以下划线结尾，长度非空且不超过32个字符。",
      "reference_sentence": "",
      "line_num": 94,
      "context": "",
      "用户拒绝的修改": "事件领域名称支持数字、字母、下划线字符，以字母开头，不能以下划线结尾，长度不超过32个字符。",
      "注意事项": "确保删除冗余词时保留所有必要限制条件（如\"非空\"），优先使用简洁的并列结构替代\"需要...且...\"句式，避免遗漏关键信息。"
    },
    {
      "defect_id": 103648,
      "sentence": "以下错误码的详细介绍请参见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "reference_sentence": "",
      "line_num": 654,
      "context": "",
      "用户拒绝的修改": "错误码详情请参见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "注意事项": "确保简化时保留必要的上下文指代（如\"以下\"）和关键信息完整性，避免因过度删减导致指代不清或信息缺失，尤其在技术文档中需优先保障表述准确性。"
    },
    {
      "defect_id": 103628,
      "sentence": "以下错误码的详细介绍请参见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "reference_sentence": "",
      "line_num": 156,
      "context": "",
      "用户拒绝的修改": "错误码详情请参见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "注意事项": "确保修改后的表述在精简冗余词汇的同时，需保留功能性指引的明确性，避免因过度简化导致语义模糊或偏离用户实际需求（例如将\"请参见\"改为\"参见\"可能更直接）。"
    },
    {
      "defect_id": 103624,
      "sentence": "配置值为true表示实时上报事件，false表示不实时上报事件。",
      "reference_sentence": "",
      "line_num": 96,
      "context": "",
      "用户拒绝的修改": "true表示实时上报事件，false表示不实时上报事件。",
      "注意事项": "修复冗余表达时需保留必要参数名称或配置项上下文（如\"配置值\"），采用\"设置为true时...\"结构替代冗余表述，避免因过度简化导致功能说明不完整。"
    },
    {
      "defect_id": 103623,
      "sentence": "事件名称。首字符必须为字母字符或$字符，中间字符必须为数字字符、字母字符或下划线字符，结尾字符必须为数字字符或字母字符，长度非空且不超过48个字符。",
      "reference_sentence": "",
      "line_num": 95,
      "context": "",
      "用户拒绝的修改": "事件名称首字符为字母或$字符，中间字符为数字、字母或下划线字符，结尾字符为数字或字母字符，长度不超过48个字符。",
      "注意事项": "修复冗余表达时需彻底删除重复限定词（如\"字符\"），避免机械替换；优先采用\"直接条件说明\"结构替代\"必须为\"类强制句式，确保技术规范简洁无歧义。"
    },
    {
      "defect_id": 103636,
      "sentence": "以下错误码的详细介绍请参见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "reference_sentence": "",
      "line_num": 345,
      "context": "",
      "用户拒绝的修改": "错误码详情见[应用事件打点错误码](errorcode-hiappevent.md)。",
      "注意事项": "确保简化后的句子保留原文关键信息（如\"详细介绍\"的强调作用），并检查指代关系是否明确（如\"以下错误码\"的限定范围），避免因过度删减导致语义缺失或歧义。"
    },
    {
      "defect_id": 103675,
      "sentence": "应用24h功耗器件分解统计事件。<br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1029,
      "context": "",
      "用户拒绝的修改": "应用24小时功耗统计事件。",
      "注意事项": "修复冗余表达时需优先分析句子主干结构，避免仅替换表面词汇而忽略修饰语嵌套问题，同时要保留专业术语完整性（如\"器件\"为必要技术要素时不可删除）。 \n\n处理复杂技术文档时，应识别并保留API版本号等关键信息（如\"API version 12\"），避免因过度简化导致技术参数丢失。"
    },
    {
      "defect_id": 226456,
      "sentence": "保留参数，必须为空。\r",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"void* OH_IPC_MessageOption::reserved\",\"43\":\"```\",\"44\":\"\",\"45\":\"**描述**\",\"46\":\"\",\"47\":\"保留参数，必须为空。\",\"48\":\"\",\"49\":\"\",\"50\":\"### timeout\",\"51\":\"\",\"52\":\"```\"}",
      "用户拒绝的修改": "保留参数，必须为空。",
      "注意事项": "在修复冗余表达前，需明确识别具体冗余成分（如重复语义或冗余修饰词），若原文已简洁无赘述，应保留原句避免无效修改；同时需结合上下文判断是否存在隐藏冗余，避免仅依赖表面文字重复率误判。"
    },
    {
      "defect_id": 226455,
      "sentence": "消息请求模式。\r",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"OH_IPC_RequestMode OH_IPC_MessageOption::mode\",\"32\":\"```\",\"33\":\"\",\"34\":\"**描述**\",\"35\":\"\",\"36\":\"消息请求模式。\",\"37\":\"\",\"38\":\"\",\"39\":\"### reserved\",\"40\":\"\",\"41\":\"```\"}",
      "用户拒绝的修改": "消息请求模式。",
      "注意事项": "在修复冗余表达时必须明确识别并标注具体冗余部分（如重复修饰词或冗余定语），同时需结合上下文确认是否为必要术语或固定表述，避免误删关键信息。"
    },
    {
      "defect_id": 284483,
      "sentence": "设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 应用文件概述\",\"2\":\"\",\"3\":\"应用文件：文件所有者为应用，包括应用安装文件、应用资源文件、应用缓存文件等。\",\"4\":\"\",\"5\":\"- 设备上应用所使用及存储的数据，以文件、键值对、数据库等形式保存在一个应用专属的目录内。该专属目录我们称为“应用文件目录”，该目录下所有数据以不同的文件格式存放，这些文件即应用文件。\",\"6\":\"\",\"7\":\"- “应用文件目录”与一部分系统文件（应用运行必须使用的系统文件）所在的目录组成了一个集合，该集合称为“[应用沙箱目录](app-sandbox-directory.md)”，代表应用可见的所有目录范围。因此“应用文件目录”是在“应用沙箱目录”内的。\",\"8\":\"\",\"9\":\"- 系统文件及其目录对于应用是只读的；应用仅能保存文件到“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”下，根据目录的使用规范和注意事项来选择将数据保存到不同的子目录中。\",\"10\":\"\"}",
      "用户拒绝的修改": "设备上应用使用的数据存储在一个专属目录内。该目录称为“应用文件目录”。目录下的数据以不同的文件格式存放，这些文件即应用文件。",
      "注意事项": "修复冗余表达时需保留关键限定信息（如\"文件、键值对、数据库等形式\"），避免删除具有技术区分度的内容；拆分长句应通过分号或连接词保持逻辑连贯性，而非简单删除技术特征。"
    },
    {
      "defect_id": 284588,
      "sentence": "在应用沙箱路径下读写文件，经过映射转换，实际读写的是真实物理路径中的应用文件，应用沙箱路径与真实物理路径对应关系如下表所示。",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"   | preferences | preferencesDir | 应用首选项文件路径 | 应用在本设备内部存储上通过数据库API存储配置类或首选项的目录；随应用卸载而清理。详见[通过用户首选项实现数据持久化](../database/data-persistence-by-preferences.md)。 <br>可以用于保存应用的首选项数据，主要包括应用首选项文件以及配置文件等。此路径下仅适用于存储小量数据。|\",\"98\":\"   | temp | tempDir | 应用临时文件路径 | 应用在本设备内部存储上仅在应用运行期间产生和需要的文件，应用退出后即清理。<br>可以用于保存应用的临时生成的数据，主要包括数据库缓存、图片缓存、临时日志文件、以及下载的应用安装包文件等。此路径下存储使用后即可删除的数据。 |\",\"99\":\"\",\"100\":\"## 应用沙箱路径和真实物理路径的对应关系\",\"101\":\"\",\"102\":\"在应用沙箱路径下读写文件，经过映射转换，实际读写的是真实物理路径中的应用文件，应用沙箱路径与真实物理路径对应关系如下表所示。\",\"103\":\"\",\"104\":\"其中&lt;USERID&gt;为当前用户ID，从100开始递增，&lt;EXTENSIONPATH&gt;为moduleName-extensionName。应用是否以Extension独立沙箱运行可参考[ExtensionAbility组件](../application-models/extensionability-overview.md)。\",\"105\":\"\",\"106\":\"| 应用沙箱路径 | 物理路径 |\",\"107\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "应用沙箱路径与真实物理路径对应关系如下表所示。",
      "注意事项": "修复时应完整识别上下文已明确的信息，避免保留重复性解释；严格删除所有非必要修饰语，确保核心信息以最简洁句式呈现（主谓宾结构优先）。"
    },
    {
      "defect_id": 284570,
      "sentence": "系统文件目录对应用的可见范围由OpenHarmony系统预置，开发者无需关注。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"## 应用文件目录与应用文件路径\",\"32\":\"\",\"33\":\"如前文所述，“应用沙箱目录”内分为两类：应用文件目录和系统文件目录。\",\"34\":\"\",\"35\":\"系统文件目录对应用的可见范围由OpenHarmony系统预置，开发者无需关注。\",\"36\":\"\",\"37\":\"在此主要介绍应用文件目录，如下图所示。应用文件目录下某个文件或某个具体目录的路径称为应用文件路径。应用文件目录下的各个文件路径，具备不同的属性和特征。\",\"38\":\"\",\"39\":\"**图3** 应用文件目录结构图  \",\"40\":\"![Application file directory structure](figures/application-file-directory-structure.png)\"}",
      "用户拒绝的修改": "系统文件目录的可见范围由OpenHarmony预置，开发者无需关注。",
      "注意事项": "在删除修饰成分前必须确认其是否承担关键限定作用，优先保留技术文档中明确指向主体或作用对象的定语，确保不改变原句的技术含义和逻辑关系。"
    },
    {
      "defect_id": 284590,
      "sentence": "应用el1级别加密数据目录：<br> - 非独立沙箱运行的应用：/data/app/el1/&lt;USERID&gt;/base/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用： /data/app/el1/&lt;USERID&gt;/base/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt;",
      "reference_sentence": "",
      "line_num": 109,
      "context": "{\"104\":\"其中&lt;USERID&gt;为当前用户ID，从100开始递增，&lt;EXTENSIONPATH&gt;为moduleName-extensionName。应用是否以Extension独立沙箱运行可参考[ExtensionAbility组件](../application-models/extensionability-overview.md)。\",\"105\":\"\",\"106\":\"| 应用沙箱路径 | 物理路径 |\",\"107\":\"| -------- | -------- |\",\"108\":\"| /data/storage/el1/bundle | 应用安装包目录：<br> /data/app/el1/bundle/public/&lt;PACKAGENAME&gt; |\",\"109\":\"| /data/storage/el1/base | 应用el1级别加密数据目录：<br> - 非独立沙箱运行的应用：/data/app/el1/&lt;USERID&gt;/base/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用： /data/app/el1/&lt;USERID&gt;/base/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt; |\",\"110\":\"| /data/storage/el2/base | 应用el2级别加密数据目录：<br> - 非独立沙箱运行的应用：/data/app/el2/&lt;USERID&gt;/base/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用： /data/app/el2/&lt;USERID&gt;/base/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt; |\",\"111\":\"| /data/storage/el1/database | 应用el1级别加密数据库目录：<br> - 非独立沙箱运行的应用：/data/app/el1/&lt;USERID&gt;/database/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用：/data/app/el1/&lt;USERID&gt;/database/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt; |\",\"112\":\"| /data/storage/el2/database | 应用el2级别加密数据库目录：<br> - 非独立沙箱运行的应用：/data/app/el2/&lt;USERID&gt;/database/&lt;PACKAGENAME&gt;<br> - 以独立沙箱运行的Extension应用：/data/app/el2/&lt;USERID&gt;/database/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt; |\",\"113\":\"| /data/storage/el2/distributedfiles | /mnt/hmdfs/&lt;USERID&gt;/account/merge_view/data/&lt;PACKAGENAME&gt; | 应用el2加密级别有账号分布式数据融合目录 |\"}",
      "用户拒绝的修改": "非独立沙箱运行的应用：/data/app/el1/&lt;USERID&gt;/base/&lt;PACKAGENAME&gt;。独立沙箱运行的Extension应用： /data/app/el1/&lt;USERID&gt;/base/+extension-&lt;EXTENSIONPATH&gt;+&lt;PACKAGENAME&gt;",
      "注意事项": "修复冗余表达时需保留原始文档的表格结构和项目符号格式，避免破坏排版一致性；技术文档修改应优先保持结构清晰性，仅在语义重复时调整文字，不可省略关键路径说明。"
    },
    {
      "defect_id": 382990,
      "sentence": "表示被保活应用的应用类型。",
      "reference_sentence": "",
      "line_num": 69,
      "context": "{\"64\":\"**系统接口**：此接口为系统接口。\",\"65\":\"\",\"66\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"67\":\"| ------------------------- | ------ | ---- | ---- | --------- |\",\"68\":\"| bundleName   | string | 是 | 否  | Bundle名称。 |\",\"69\":\"| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |\",\"70\":\"| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |\",\"71\":\"| setterUserId<sup>20+</sup>   | number | 是 | 是  | 应用保活设置者的用户ID。 |\",\"72\":\"| allowUserToCancel<sup>20+</sup>   | boolean | 是 | 是  | 表示是否允许用户取消应用保活，true表示允许，false表示不允许。 |\",\"73\":\"\",\"74\":\"## appManager.isSharedBundleRunning<sup>10+</sup>\"}",
      "用户拒绝的修改": "表示应用类型。",
      "注意事项": "在删除冗余修饰成分时，必须确认被删除部分是否承载关键限定信息（如\"被保活应用\"这类技术文档特有的上下文关联词），需结合参数定义字段类型（KeepAliveAppType）和上下文表格结构判断修饰词的必要性。"
    },
    {
      "defect_id": 376476,
      "sentence": "指向证书数据的指针。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"### 成员变量\",\"19\":\"\",\"20\":\"| 名称 | 描述 | \",\"21\":\"| -------- | -------- |\",\"22\":\"| struct [OH_Huks_Blob](_o_h___huks___blob.md) \\\\* [certs](#certs) | 指向证书数据的指针。  | \",\"23\":\"| uint32_t [certsCount](#certscount) | 证书本数。  | \",\"24\":\"\",\"25\":\"\",\"26\":\"## 结构体成员变量说明\",\"27\":\"\"}",
      "用户拒绝的修改": "证书数据指针。",
      "注意事项": "在修复\"冗余表达\"时需优先保留技术文档中必要的指向性描述（如\"指向\"），避免因过度简化导致关键信息丢失；需结合变量类型（如指针）和上下文判断冗余程度，确保术语准确性高于语言简洁性。"
    },
    {
      "defect_id": 382991,
      "sentence": "表示应用保活设置者类型。",
      "reference_sentence": "",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"| 名称 | 类型 | 只读 | 可选 | 说明 |\",\"67\":\"| ------------------------- | ------ | ---- | ---- | --------- |\",\"68\":\"| bundleName   | string | 是 | 否  | Bundle名称。 |\",\"69\":\"| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |\",\"70\":\"| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |\",\"71\":\"| setterUserId<sup>20+</sup>   | number | 是 | 是  | 应用保活设置者的用户ID。 |\",\"72\":\"| allowUserToCancel<sup>20+</sup>   | boolean | 是 | 是  | 表示是否允许用户取消应用保活，true表示允许，false表示不允许。 |\",\"73\":\"\",\"74\":\"## appManager.isSharedBundleRunning<sup>10+</sup>\",\"75\":\"\"}",
      "用户拒绝的修改": "表示设置者类型。",
      "注意事项": "修复冗余表达时必须优先保留核心领域术语（如\"应用保活\"），仅删除纯语法重复成分；需结合上下文判断修饰词是否承担区分不同技术概念的语义功能。"
    },
    {
      "defect_id": 403857,
      "sentence": "通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"以下Node-API接口提供了对ArkTS对象属性的基本操作，包括设置、获取、删除和检查属性是否存在。使用场景如下：\",\"19\":\"| 接口 | 描述 |\",\"20\":\"| -------- | -------- |\",\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\"}",
      "用户拒绝的修改": "此接口向对象添加属性，或修改属性值。",
      "注意事项": "保留技术文档中强调动态操作的关键词（如\"动态地\"），避免过度简化导致功能特性丢失；区分冗余修饰语与核心技术指标，优先保留体现接口特性的限定词。"
    },
    {
      "defect_id": 403819,
      "sentence": "异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\",\"17\":\"\"}",
      "用户拒绝的修改": "异步任务可以同时执行，不会阻塞后续任务。常见的异步操作有定时器、事件监听和网络请求。",
      "注意事项": "修复冗余表达时应保留与上下文强关联的核心术语（如\"回调函数\"和\"Promise\"），避免因过度简化导致关键概念脱节；需确保修改后的语句与文档其他章节的定义保持逻辑连贯性。"
    },
    {
      "defect_id": 403856,
      "sentence": "在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"## 场景和功能介绍\",\"17\":\"\",\"18\":\"以下Node-API接口提供了对ArkTS对象属性的基本操作，包括设置、获取、删除和检查属性是否存在。使用场景如下：\",\"19\":\"| 接口 | 描述 |\",\"20\":\"| -------- | -------- |\",\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\"}",
      "用户拒绝的修改": "此接口提取对象的属性名，用于动态获取对象的属性信息。",
      "注意事项": "修复冗余表达时应优先保留关键场景描述和技术上下文，避免过度删除导致功能说明不完整；需检查表格中同类语句结构的一致性，确保修改后仍符合技术文档的规范表述要求。"
    },
    {
      "defect_id": 403858,
      "sentence": "在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"以下Node-API接口提供了对ArkTS对象属性的基本操作，包括设置、获取、删除和检查属性是否存在。使用场景如下：\",\"19\":\"| 接口 | 描述 |\",\"20\":\"| -------- | -------- |\",\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\"}",
      "用户拒绝的修改": "此接口获取属性值，传递给其他函数。",
      "注意事项": "保留关键应用场景描述（如\"调用Node-API模块函数时需传递属性值\"），避免过度删除必要上下文；保持技术文档中\"使用场景-接口功能\"的完整逻辑链，仅删除重复性动作描述（如\"进行处理\"）。"
    },
    {
      "defect_id": 402795,
      "sentence": "true:继续解析 false:停止解析",
      "reference_sentence": "",
      "line_num": 172,
      "context": "{\"167\":\"    ```ts\",\"168\":\"    let str: string = '';\",\"169\":\"    function func(name: xml.EventType, value: xml.ParseInfo): boolean {\",\"170\":\"      str = name + ' ' + value.getDepth(); // getDepth 获取元素的当前深度\",\"171\":\"      console.info(str);\",\"172\":\"      return true; // true:继续解析 false:停止解析\",\"173\":\"    }\",\"174\":\"    ```\",\"175\":\"\",\"176\":\"4. 设置解析选项，调用parse函数。\",\"177\":\"\"}",
      "用户拒绝的修改": "true: 继续解析",
      "注意事项": "修复冗余表达时需优先保留关键功能说明，避免因过度简化导致语义缺失；需结合上下文判断注释与代码的对应关系，确保修改后仍能准确反映参数的实际用途。"
    },
    {
      "defect_id": 404557,
      "sentence": "1. 调用napi方法使用已创建的napi数据结构时，入参napi_env与创建时不一致。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"### 各问题场景关键日志\",\"10\":\"\",\"11\":\"该维测手段主要包含以下两种场景：\",\"12\":\"\",\"13\":\"1. 调用napi方法使用已创建的napi数据结构时，入参napi_env与创建时不一致。\",\"14\":\"\",\"15\":\"   > **关键日志**\",\"16\":\"   > param env not equal to its owner.\",\"17\":\"   >\",\"18\":\"\"}",
      "用户拒绝的修改": "调用napi方法时，入参napi_env与创建时不一致。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的关键限定条件（如\"使用已创建的napi数据结构\"），避免因过度简化导致上下文缺失；需结合问题上下文判断冗余成分是否承载必要技术信息，而非仅依据句子长度或标点数量进行删减。"
    },
    {
      "defect_id": 403868,
      "sentence": "检查对象中是否存在指定的属性，可以避免访问不存在属性导致的异常或错误。",
      "reference_sentence": "",
      "line_num": 199,
      "context": "{\"194\":\"}\",\"195\":\"```\",\"196\":\"\",\"197\":\"### napi_has_property\",\"198\":\"\",\"199\":\"检查对象中是否存在指定的属性，可以避免访问不存在属性导致的异常或错误。\",\"200\":\"\",\"201\":\"cpp部分代码\",\"202\":\"\",\"203\":\"```cpp\",\"204\":\"#include \\\"napi/native_api.h\\\"\"}",
      "用户拒绝的修改": "检查对象中是否存在指定的属性，避免访问不存在属性导致的异常。",
      "注意事项": "在修复冗余表达时，不仅要删除重复词汇（如\"或错误\"），还需优化整体句式结构，避免保留多个逗号分隔的冗长分句。建议通过合并因果关系或使用连词（如\"以\"）简化表达，例如改为\"检查对象是否存在指定属性以避免访问不存在的属性异常\"。"
    },
    {
      "defect_id": 403867,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\",\"33\":\"## 使用示例\",\"34\":\"\",\"35\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"36\":\"\",\"37\":\"### napi_get_property_names\",\"38\":\"\",\"39\":\"以字符串数组的形式获取对象的可枚举属性的名称。\",\"40\":\"\"}",
      "用户拒绝的修改": "参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文展示接口对应C++及ArkTS代码。",
      "注意事项": "修复冗余表达时应保留关键技术术语（如\"Node-API接口开发流程\"）确保上下文衔接，避免过度简化导致专业表述缺失；需区分重复性冗余与必要限定词（如\"可参考\"中的情态动词），保持技术文档的严谨性。"
    },
    {
      "defect_id": 405434,
      "sentence": "传入的XML文本中若包含“&”字符，请使用实体引用“\\&amp;”替换。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"2. 输入待转换的XML，设置转换选项，支持的转换选项及含义具体可见[ConvertOptions](../reference/apis-arkts/js-apis-convertxml.md#convertoptions)。\",\"26\":\"\",\"27\":\"   > **说明：**\",\"28\":\"   >\",\"29\":\"   > 传入的XML文本中若包含“&”字符，请使用实体引用“\\\\&amp;”替换。\",\"30\":\"\",\"31\":\"   ```ts\",\"32\":\"   let xml: string =\",\"33\":\"    '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>' +\",\"34\":\"    '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\"}",
      "用户拒绝的修改": "XML文本中若包含“&”字符，使用实体引用“\\&amp;”替换。",
      "注意事项": "在删除冗余表达时需保留必要限定词（如\"传入的\"），确保技术指代准确性；同时检查上下文是否存在重复说明，避免因过度简化导致关键信息缺失或歧义。"
    },
    {
      "defect_id": 405456,
      "sentence": "当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\<number\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"## FastBuffer\",\"30\":\"\",\"31\":\"FastBuffer是一种高性能二进制数据容器，专为固定长度字节序列的存储与处理设计。相比 Buffer，它在效率、读写速度上具有显著优势。\",\"32\":\"\",\"33\":\"当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\\\<number\\\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。\",\"34\":\"\",\"35\":\"FastBuffer模块的核心功能包括：\",\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\"}",
      "用户拒绝的修改": "推荐使用FastBuffer处理大量二进制数据，如图片处理和文件上传。",
      "注意事项": "修复冗余表达时需保留关键参数类型等必要技术细节，优先简化重复性描述（如“接收上传”合并为“上传”）而非删除开发者依赖的类型说明。"
    },
    {
      "defect_id": 405244,
      "sentence": "并发管理：Actor并发模型中的方舟字节码文件管理器。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"  - 内存管理：对象分配器与[垃圾回收器](gc-introduction.md)（并发标记和部分内存压缩的CMS-GC和Partial-Compressing-GC）。\",\"16\":\"\",\"17\":\"  - 分析工具：DFX工具、CPU和heap的profiling工具。\",\"18\":\"\",\"19\":\"  - 并发管理：Actor并发模型中的方舟字节码文件管理器。\",\"20\":\"\",\"21\":\"  - 标准库：ECMAScript规范定义的标准库、高效的container容器库与对象模型。\",\"22\":\"  \",\"23\":\"  - 其他：异步工作队列、跟C++交互的Node-API接口等。\"}",
      "用户拒绝的修改": "并发管理：方舟字节码文件管理器。",
      "注意事项": "保留关键限定词（如\"Actor并发模型中\"）确保技术准确性，避免过度简化导致信息缺失；在删除嵌套结构前需确认被删部分是否承载重要上下文或区分功能。"
    },
    {
      "defect_id": 405469,
      "sentence": "当前提供了线性和非线性两类容器。[线性容器](linear-container.md)和[非线性容器](nonlinear-container.md)都是非多线程安全的。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"容器类库用于存储各种数据类型的元素，并提供一系列处理数据元素的方法，作为纯数据结构容器来使用具有一定的优势。\",\"4\":\"\",\"5\":\"容器类采用类似静态语言的方式来实现，通过限制存储位置和属性，确保每种类型的数据都能在完成自身功能的同时去除冗余逻辑，从而实现高效的数据访问，提升应用性能。\",\"6\":\"\",\"7\":\"当前提供了线性和非线性两类容器。[线性容器](linear-container.md)和[非线性容器](nonlinear-container.md)都是非多线程安全的。\"}",
      "用户拒绝的修改": "提供线性和非线性容器，均非多线程安全。",
      "注意事项": "修复冗余表达时需优先保留技术文档中的关键名词标签（如超链接和术语定义），避免因过度简化导致文档引用关系断裂或信息缺失，同时需平衡专业术语完整性与表达简洁性。"
    },
    {
      "defect_id": 405555,
      "sentence": "Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。",
      "reference_sentence": "",
      "line_num": 103,
      "context": "{\"98\":\"\",\"99\":\"[Deque](../reference/apis-arkts/js-apis-deque.md)可用来构造双端队列对象，存储元素遵循先进先出以及先进后出的规则，双端队列可以分别从队头或者队尾进行访问。\",\"100\":\"\",\"101\":\"Deque依据泛型定义，要求存储位置为连续的内存空间，其初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。Deque底层采用循环队列实现，入队及出队操作效率高。\",\"102\":\"\",\"103\":\"Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。\",\"104\":\"\",\"105\":\"Deque和[Vector](../reference/apis-arkts/js-apis-vector.md)相比，它们都支持在两端增删元素，但Deque不支持中间插入的操作。Deque对头部元素的插入删除效率高于Vector，而Vector访问元素的效率高于Deque。\",\"106\":\"\",\"107\":\"需要频繁在集合两端进行增删元素的操作时，推荐使用Deque。\",\"108\":\"\"}",
      "用户拒绝的修改": "Deque支持两端增删操作。Queue仅支持头部删除和尾部增加。",
      "注意事项": "修复时应保留关键对比信息避免过度简化，同时检查上下文避免重复已明确说明的功能特性（如\"两端增删\"在99/101段已提及，应侧重补充未覆盖的差异点）。"
    },
    {
      "defect_id": 405567,
      "sentence": "此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：",
      "reference_sentence": "",
      "line_num": 199,
      "context": "{\"194\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"195\":\"| 删除元素 | removeByRange(fromIndex:number,toIndex:number) | 删除指定范围内的元素。 |\",\"196\":\"\",\"197\":\"## 线性容器的使用\",\"198\":\"\",\"199\":\"此处列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改等操作。示例代码如下所示：\",\"200\":\"\",\"201\":\"\",\"202\":\"```ts\",\"203\":\"// ArrayList\",\"204\":\"import { ArrayList } from '@kit.ArkTS'; // 导入ArrayList模块\"}",
      "用户拒绝的修改": "列举常用的线性容器ArrayList、Deque、Stack、List的使用示例，包括导入模块、增加元素、访问元素及修改操作。",
      "注意事项": "修复时应完整分析上下文结构，避免因局部删除导致前后信息断层；特别注意代码示例标记与文字描述的对应关系，若上下文已存在明确代码区块标识，可适当保留引导性表述避免语义断裂。"
    },
    {
      "defect_id": 405677,
      "sentence": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。",
      "reference_sentence": "",
      "line_num": 130,
      "context": "{\"125\":\"\",\"126\":\"[LightWeightMap](../reference/apis-arkts/js-apis-lightweightmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。LightWeightMap依据泛型定义，采用更加轻量级的结构，底层通过hash实现唯一key，冲突策略为线性探测。集合中的key值的查找依赖于hash值以及二分查找算法，通过一个数组存储hash值，然后映射到其他数组中的key值以及value值，key的类型满足ECMA标准。\",\"127\":\"\",\"128\":\"初始默认容量为8，每次扩容为原始容量的2倍。\",\"129\":\"\",\"130\":\"LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)都是用来存储键值对的集合，LightWeightMap占用内存更小。\",\"131\":\"\",\"132\":\"当需要存取key-value键值对时，推荐使用占用内存更小的LightWeightMap。\",\"133\":\"\",\"134\":\"LightWeightMap支持增、删、改、查操作，常用API如下：\",\"135\":\"\"}",
      "用户拒绝的修改": "LightWeightMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)存储键值对，LightWeightMap占用内存更小。",
      "注意事项": "修复冗余表达时需优先保留关键术语（如\"集合\"）以确保技术准确性，并检查上下文术语一致性；避免过度简化导致核心信息丢失，应在简洁性和专业表述间取得平衡。"
    },
    {
      "defect_id": 408203,
      "sentence": "缺点：对对象操作时插入计数环节，增加了内存分配和赋值的开销，影响程序性能。更严重的是存在由循环引用导致的内存泄漏问题。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"#### 引用计数\",\"10\":\"\",\"11\":\"当对象B指向对象A时，A的引用计数加1；当该指向断开时，A的引用计数减1。如果A的引用计数为0，回收对象A。  \",\"12\":\"\",\"13\":\"- 优点：引用计数算法设计简单，内存回收及时，在对象成为垃圾时立即回收，因此无需引入单独的暂停业务代码（Stop The World，STW）阶段。\",\"14\":\"- 缺点：对对象操作时插入计数环节，增加了内存分配和赋值的开销，影响程序性能。更严重的是存在由循环引用导致的内存泄漏问题。\",\"15\":\"```\",\"16\":\"class Parent {\",\"17\":\"  constructor() {\",\"18\":\"    this.child = null;\",\"19\":\"  }\"}",
      "用户拒绝的修改": "缺点：增加内存分配和赋值开销，影响性能。存在循环引用导致的内存泄漏。",
      "注意事项": "修复冗余表达时需保留关键技术细节（如\"对对象操作时插入计数环节\"），避免过度简化导致信息丢失；优先确保技术准确性，专业术语和因果关系不可模糊处理。"
    },
    {
      "defect_id": 408202,
      "sentence": "优点：引用计数算法设计简单，内存回收及时，在对象成为垃圾时立即回收，因此无需引入单独的暂停业务代码（Stop The World，STW）阶段。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"#### 引用计数\",\"10\":\"\",\"11\":\"当对象B指向对象A时，A的引用计数加1；当该指向断开时，A的引用计数减1。如果A的引用计数为0，回收对象A。  \",\"12\":\"\",\"13\":\"- 优点：引用计数算法设计简单，内存回收及时，在对象成为垃圾时立即回收，因此无需引入单独的暂停业务代码（Stop The World，STW）阶段。\",\"14\":\"- 缺点：对对象操作时插入计数环节，增加了内存分配和赋值的开销，影响程序性能。更严重的是存在由循环引用导致的内存泄漏问题。\",\"15\":\"```\",\"16\":\"class Parent {\",\"17\":\"  constructor() {\",\"18\":\"    this.child = null;\"}",
      "用户拒绝的修改": "优点：设计简单，内存回收及时，对象成为垃圾时立即回收，无需暂停业务代码。",
      "注意事项": "保留关键术语和必要限定词（如\"引用计数算法\"和\"单独的\"），避免因过度简化导致技术细节丢失；处理复合型长句时优先拆分而非删除，通过调整句式结构而非移除核心成分来缩短句子长度。"
    },
    {
      "defect_id": 408230,
      "sentence": "函数方法：`AdjustCapacity`",
      "reference_sentence": "",
      "line_num": 256,
      "context": "{\"251\":\"- 说明：尝试触发并发mark，将遍历对象进行标记的任务交由线程池中并发运行，减少UI主线程挂起时间。\",\"252\":\"- 典型日志：`fullMarkRequested`，`trigger full mark`，`Trigger the first full mark`，`Trigger full mark`，`Trigger the first semi mark`，`Trigger semi mark`。\",\"253\":\"\",\"254\":\"#### new space GC前后的阈值调整\",\"255\":\"\",\"256\":\"- 函数方法：`AdjustCapacity`\",\"257\":\"- 说明：GC后调整SemiSpace的触发水线，优化空间结构。\",\"258\":\"- 典型日志：无直接日志，可以通过GC统计日志看出，GC前young space的阈值有动态调整。\",\"259\":\"\",\"260\":\"#### 第一次OldGC后阈值的调整\",\"261\":\"\"}",
      "用户拒绝的修改": "函数方法：`AdjustCapacity`调整SemiSpace的触发水线。",
      "注意事项": "修复时必须明确补充执行主体（如\"该方法用于\"），避免仅扩展描述而忽略句子结构完整性；同时需检查上下文是否已存在相同信息，防止新增内容与已有说明产生语义重复。"
    },
    {
      "defect_id": 408212,
      "sentence": "这种回收方式既解决了“标记-清扫回收”导致的大量内存碎片问题，同时避免了“标记-复制回收”浪费一半内存空间的缺点，但性能开销比“标记-复制回收”高。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"#### 标记-整理回收\",\"67\":\"\",\"68\":\"![image](./figures/mark-shuffle.png)\",\"69\":\"\",\"70\":\"完成对象图遍历后，将可达对象（蓝色）往本区域（或指定区域）的头部空闲位置复制，然后将已经完成复制的对象回收整理到空闲队列中。  \",\"71\":\"这种回收方式既解决了“标记-清扫回收”导致的大量内存碎片问题，同时避免了“标记-复制回收”浪费一半内存空间的缺点，但性能开销比“标记-复制回收”高。  \",\"72\":\"### HPP GC\",\"73\":\"\",\"74\":\"HPP GC（High Performance Partial Garbage Collection），即高性能部分垃圾回收，其中“High Performance”主要体现在三方面，分代模型、混合算法和GC流程优化。在算法方面，HPP GC会根据不同对象区域、采取不同的回收方式。\",\"75\":\"\",\"76\":\"#### 分代模型\"}",
      "用户拒绝的修改": "这种回收方式解决大量内存碎片问题，避免浪费一半内存空间，但性能开销比“标记-复制回收”高。",
      "注意事项": "修复时应优先保留技术术语间的对比逻辑（如\"既...同时...但...\"结构），避免过度简化导致技术细节丢失；在优化句式长度时需确保核心优缺点对比关系不受破坏，必要时可拆分句子而非强行删减。"
    },
    {
      "defect_id": 408234,
      "sentence": "根据当前GC统计的数据变化，重新计算并调整`newOldSpaceLimit`、`newGlobalSpaceLimit`、`globalSpaceNativeLimit`和增长因子。",
      "reference_sentence": "",
      "line_num": 269,
      "context": "{\"264\":\"- 日志关键词：`AdjustOldSpaceLimit`。\",\"265\":\"\",\"266\":\"#### 第二次及以后的OldGC对old Space/global space阈值调整，以及增长因子的调整\",\"267\":\"\",\"268\":\"- 函数方法：`RecomputeLimits`\",\"269\":\"- 说明：根据当前GC统计的数据变化，重新计算并调整`newOldSpaceLimit`、`newGlobalSpaceLimit`、`globalSpaceNativeLimit`和增长因子。\",\"270\":\"- 日志关键词：`RecomputeLimits`。\",\"271\":\"\",\"272\":\"#### PartialGC的CSet 选择策略\",\"273\":\"\",\"274\":\"- 函数方法：`OldSpace::SelectCSet()`\"}",
      "用户拒绝的修改": "根据当前GC统计的数据变化，重新计算并调整`newOldSpaceLimit`。调整`newGlobalSpaceLimit`、`globalSpaceNativeLimit`和增长因子。",
      "注意事项": "保持技术文档中参数列表的完整性，拆分长句时应优先使用分号/冒号保持语义连贯，避免将关联性强的参数拆解为独立操作步骤导致语义割裂。"
    },
    {
      "defect_id": 408229,
      "sentence": "切换后台后主动触发一次Full GC。",
      "reference_sentence": "",
      "line_num": 242,
      "context": "{\"237\":\"- 说明：影响是否进行全量mark，以及是否开始并发mark。\",\"238\":\"\",\"239\":\"#### 切换后台触发GC\",\"240\":\"\",\"241\":\"- 函数方法：`ChangeGCParams`\",\"242\":\"- 说明：切换后台后主动触发一次Full GC。\",\"243\":\"- 典型日志：`app is inBackground` 和 `app is not inBackground`。\",\"244\":\"  GC 日志中可区分GCReason::SWITCH_BACKGROUND。\",\"245\":\"\",\"246\":\"### 执行策略\",\"247\":\"\"}",
      "用户拒绝的修改": "切换后台后触发一次Full GC。",
      "注意事项": "在技术文档中需严格区分\"主动触发\"等专业术语的特殊含义，保留体现系统行为的核心副词，避免将技术场景中的必要修饰语误判为冗余表达。"
    },
    {
      "defect_id": 409280,
      "sentence": "异步并发是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"\",\"8\":\"- 任务轻量且无 CPU 阻塞​​：单次任务执行时间短。\",\"9\":\"\",\"10\":\"- 逻辑依赖清晰​​：任务有明确的顺序或并行关系。\",\"11\":\"\",\"12\":\"异步并发是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。\",\"13\":\"\",\"14\":\"## Promise\",\"15\":\"\",\"16\":\"Promise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一种状态机制来管理异步操作的不同阶段，Promise有三种状态：pending（进行中）、fulfilled（已完成，也叫resolved）和rejected（已拒绝）。其创建后处于pending状态，异步操作完成后转换为fulfilled或rejected状态。\",\"17\":\"\"}",
      "用户拒绝的修改": "异步并发允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。",
      "注意事项": "修复时应先核对上下文是否已包含被删内容，保留核心定义要素（如\"编程语言特性\"属于关键分类信息），避免因过度简化导致定义完整性缺失或与上下文重复。"
    },
    {
      "defect_id": 410198,
      "sentence": "SystemCapability.ArkUI.ArkUI.Full",
      "reference_sentence": "",
      "line_num": 524,
      "context": "{\"519\":\"\",\"520\":\"设置是否同步加载Grid区域内所有子组件。\",\"521\":\"\",\"522\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"523\":\"\",\"524\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"525\":\"\",\"526\":\"**参数：** \",\"527\":\"\",\"528\":\"| 参数名 | 类型                                                         | 必填 | 说明                                                         |\",\"529\":\"| ------ | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "系统能力：SystemCapability.ArkUI.ArkUI.Full",
      "注意事项": "修复冗余表达时需严格遵循文档现有标签格式规范，优先核对上下文已有系统能力标签写法（如\"**系统能力：**\"加代码块），避免擅自添加或修改统一前缀结构。"
    },
    {
      "defect_id": 410197,
      "sentence": "从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 522,
      "context": "{\"517\":\"\",\"518\":\"syncLoad(enable: boolean)\",\"519\":\"\",\"520\":\"设置是否同步加载Grid区域内所有子组件。\",\"521\":\"\",\"522\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"523\":\"\",\"524\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"525\":\"\",\"526\":\"**参数：** \",\"527\":\"\"}",
      "用户拒绝的修改": "该接口从API version 20开始支持原子化服务。",
      "注意事项": "修复冗余表达时必须优先保留文档中已定义的固定术语标签（如\"原子化服务API：\"），在保持专业表述规范性的前提下优化句式结构，避免因过度精简破坏技术文档的术语统一性。"
    },
    {
      "defect_id": 410530,
      "sentence": "任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"- 实现任务的函数需要使用[@Concurrent装饰器](#concurrent装饰器)标注，且仅支持在.ets文件中使用。\",\"16\":\"\",\"17\":\"- 从API version 11开始，跨并发实例传递带方法的实例对象时，该类必须使用装饰器[@Sendable装饰器](arkts-sendable.md#sendable装饰器)标注，且仅支持在.ets文件中使用。\",\"18\":\"\",\"19\":\"- 任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。\",\"20\":\"\",\"21\":\"- 实现任务的函数入参需满足序列化支持的类型，详情请参见[线程间通信对象](interthread-communication-overview.md)。目前不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。\",\"22\":\"\",\"23\":\"- ArrayBuffer参数在TaskPool中默认转移，需要设置转移列表的话可通过接口[setTransferList()](../reference/apis-arkts/js-apis-taskpool.md#settransferlist10)设置。如果需要多次调用使用ArrayBuffer作为参数的task，则需要通过接口[setCloneList()](../reference/apis-arkts/js-apis-taskpool.md#setclonelist11)把ArrayBuffer在线程中的传输行为改成拷贝传递，避免对原有对象产生影响。\",\"24\":\"\"}",
      "用户拒绝的修改": "任务函数在TaskPool工作线程的执行耗时不能超过3分钟。否则，任务将被强制终止。",
      "注意事项": "必须保留所有例外情况（如\"[LongTask]除外\"）和关键限定条件（如执行耗时范围说明），避免因过度简化导致技术准确性缺失；在优化冗余表达时应优先使用括号拆分或句式重组，而非直接删除关键技术参数。"
    },
    {
      "defect_id": 412940,
      "sentence": "NAPI相关接口请参考[Sendable相关的NAPI接口](../napi/use-napi-about-extension.md#sendable相关)，具体使用请参考[Native与Sendable ArkTS对象绑定](../napi/use-sendable-napi.md)。",
      "reference_sentence": "",
      "line_num": 483,
      "context": "{\"478\":\"> 改变属性类型不包括Sendable对象类型的改变，例如从Sendable class A变为Sendable class B。\",\"479\":\"\",\"480\":\"\",\"481\":\"### NAPI规则（目前只针对Sendable对象）\",\"482\":\"\",\"483\":\"NAPI相关接口请参考[Sendable相关的NAPI接口](../napi/use-napi-about-extension.md#sendable相关)，具体使用请参考[Native与Sendable ArkTS对象绑定](../napi/use-sendable-napi.md)。\",\"484\":\"\",\"485\":\"| 规则 |\",\"486\":\"| -------- |\",\"487\":\"| 禁止删除属性，不能使用的接口有：napi_delete_property。 |\",\"488\":\"| 禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\"}",
      "用户拒绝的修改": "参考[Sendable相关的NAPI接口](../napi/use-napi-about-extension.md#sendable相关)和[Native与Sendable ArkTS对象绑定](../napi/use-sendable-napi.md)。",
      "注意事项": "保留原文中不同参考链接的独立说明目的，避免过度合并导致信息分层丢失；技术文档需优先确保准确性而非单纯简化句式，需确认合并后未模糊不同功能模块的区分。"
    },
    {
      "defect_id": 413002,
      "sentence": "> - 针对API version大于12的工程，开发者可直接使用\\@Sendable装饰器校验Sendable function，无需再进行其他配置。",
      "reference_sentence": "",
      "line_num": 49,
      "context": "{\"44\":\">\",\"45\":\"> - 从API version 12开始，支持使用\\\\@Sendable装饰器校验Sendable function。\",\"46\":\">\",\"47\":\"> - 针对API version 12的工程，开发者使用\\\\@Sendable装饰器校验Sendable function时，需在工程中配置\\\"compatibleSdkVersionStage\\\": \\\"beta3\\\"，否则其Sendable特性将不生效。参考[build-profile.json5配置文件说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-profile-V5)。\",\"48\":\">\",\"49\":\"> - 针对API version大于12的工程，开发者可直接使用\\\\@Sendable装饰器校验Sendable function，无需再进行其他配置。\",\"50\":\"\",\"51\":\"Sendable function需同时满足以下两个规则：\",\"52\":\"\",\"53\":\"1. 当且仅当被标注了[@Sendable装饰器](#sendable装饰器)。\",\"54\":\"\"}",
      "用户拒绝的修改": "API version大于12的工程，可直接使用@Sendable装饰器校验Sendable function。",
      "注意事项": "在删除\"冗余表达\"时需优先保留关键操作条件说明，特别是当上下文存在版本对比时，必须保留否定性描述（如\"无需配置\"）以明确区分不同场景的技术要求。"
    },
    {
      "defect_id": 413000,
      "sentence": "> 从API version 11开始，支持使用\\@Sendable装饰器校验Sendable class。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"### Sendable class\",\"30\":\"\",\"31\":\"> **说明：**\",\"32\":\">\",\"33\":\"> 从API version 11开始，支持使用\\\\@Sendable装饰器校验Sendable class。\",\"34\":\"\",\"35\":\"Sendable class需同时满足以下两个规则：\",\"36\":\"\",\"37\":\"1. 当且仅当被标注了[@Sendable装饰器](#sendable装饰器)。\",\"38\":\"\"}",
      "用户拒绝的修改": "API version 11开始支持使用@Sendable装饰器校验Sendable class。",
      "注意事项": "修复冗余表达时需保留原句的Markdown引用格式（如开头的`>`符号），避免因删除必要格式符号导致文档结构错误；优先检查上下文格式一致性，再处理文字冗余问题。"
    },
    {
      "defect_id": 418042,
      "sentence": "字体特征描述字体内置的排版规则，控制字形显示。例如：连字、替代字形、上下标等。",
      "reference_sentence": "",
      "line_num": 50,
      "context": "{\"45\":\"| strikethroughThickness<sup>12+</sup>  | number | 否   | 是   | 文本删除线的厚度，即贯穿文本字符的水平线的宽度。    |\",\"46\":\"| strikethroughPosition<sup>12+</sup>  | number | 否   | 是   | 文本基线到底部删除线的垂直距离，通常为负值。         |\",\"47\":\"\",\"48\":\"## FontFeature<sup>20+</sup>\",\"49\":\"\",\"50\":\"字体特征描述字体内置的排版规则，控制字形显示。例如：连字、替代字形、上下标等。\",\"51\":\"\",\"52\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"53\":\"| 名称    | 类型   | 只读 | 可选 | 说明   |\",\"54\":\"| ------- | ------ | ---- | ---- | ------------------ |\",\"55\":\"| name   | string | 否   | 否   | 字体特征的名称。   |\"}",
      "用户拒绝的修改": "字体特征描述排版规则，控制字形显示。",
      "注意事项": "在删除修饰成分前需评估其对核心概念解释的必要性，优先保留帮助用户理解功能属性的限定词（如\"字体内置的\"），避免过度简化导致技术术语丧失上下文关联性。"
    },
    {
      "defect_id": 417317,
      "sentence": "普通模块在同一线程内只加载一次，而在不同线程中会加载多次，每个线程都会生成新的模块对象。如果需要在进程内只会加载一次，请使用共享模块。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"A文件称为入口文件，即执行起点。一些内置的加载接口，如[windowStage.loadContent](../reference/apis-arkui/arkts-apis-window-Window.md#loadcontent9)和[路由跳转](../ui/arkts-navigation-navigation.md)等页面拉起接口（即不是通过import写法拉起的文件），入参文件都会作为入口文件执行。\",\"18\":\"\",\"19\":\"以A文件为入口，会加载一整套文件，包含A文件，A文件依赖的文件，这些文件后面依赖的文件，直到各分支叶节点。\",\"20\":\"\",\"21\":\"普通模块在同一线程内只加载一次，而在不同线程中会加载多次，每个线程都会生成新的模块对象。如果需要在进程内只会加载一次，请使用[共享模块](./arkts-sendable-module.md)。\",\"22\":\"\",\"23\":\"## ArkTS支持的模块化规范\",\"24\":\"\",\"25\":\"### ECMAScript模块\",\"26\":\"\"}",
      "用户拒绝的修改": "普通模块在同一线程内只加载一次，不同线程中会加载多次。如果需要在进程内只加载一次，请使用共享模块。",
      "注意事项": "在删除冗余表达时需保留必要技术细节，确保\"不同线程加载多次\"与\"生成新模块对象\"的因果关系不被破坏，避免因过度简化导致关键机制描述缺失。"
    },
    {
      "defect_id": 410777,
      "sentence": "Worker的主要作用是为应用程序提供一个多线程的运行环境，满足应用程序在执行过程中与宿主线程分离，在后台线程中运行脚本进行耗时操作，避免计算密集型或高延迟的任务阻塞宿主线程。具体接口信息及使用方法详情请见[Worker](../reference/apis-arkts/js-apis-worker.md)。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# Worker简介\",\"2\":\"\",\"3\":\"Worker的主要作用是为应用程序提供一个多线程的运行环境，满足应用程序在执行过程中与宿主线程分离，在后台线程中运行脚本进行耗时操作，避免计算密集型或高延迟的任务阻塞宿主线程。具体接口信息及使用方法详情请见[Worker](../reference/apis-arkts/js-apis-worker.md)。\",\"4\":\"\",\"5\":\"\",\"6\":\"## Worker运作机制\",\"7\":\"\",\"8\":\"**图1** Worker运作机制示意图\"}",
      "用户拒绝的修改": "Worker为应用程序提供多线程运行环境，避免计算密集型或高延迟任务阻塞宿主线程。具体接口信息及使用方法请见[Worker](../reference/apis-arkts/js-apis-worker.md)。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的核心功能描述（如\"与宿主线程分离\"和\"后台线程运行脚本\"），避免因过度简化导致关键机制说明缺失，同时需区分冗余修饰语与必要技术细节的边界。"
    },
    {
      "defect_id": 413017,
      "sentence": "1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。",
      "reference_sentence": "",
      "line_num": 61,
      "context": "{\"56\":\"\",\"57\":\"### Sendable interface\",\"58\":\"\",\"59\":\"Sendable interface需同时满足以下两个规则：\",\"60\":\"\",\"61\":\"1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。\",\"62\":\"\",\"63\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"64\":\"\",\"65\":\"### Sendable支持的数据类型\",\"66\":\"\"}",
      "用户拒绝的修改": "1. 是[ISendable](#isendable)或继承了ISendable。",
      "注意事项": "修复时应优先保留关键逻辑术语（如\"当且仅当\"），避免改变原句逻辑含义；拆分冗余表达需通过调整句式结构（如将长句改为分项列表）而非直接删除核心限定词，确保技术文档的严谨性。"
    },
    {
      "defect_id": 417314,
      "sentence": "以下图为例，每个父节点加载对应子节点，并按import顺序执行同级。模块图文件执行顺序为：D->F->G->E->B->I->H->C->A。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"## 模块化运行加载流程\",\"10\":\"\",\"11\":\"ArkTS模块化运行根据ECMAScript模块规范实现，以后序遍历的方式执行模块：从模块图的最左侧子树开始，执行模块，然后执行它们的同级，然后执行它们的父级。此算法递归运行，直至执行到模块图的根。\",\"12\":\"\",\"13\":\"以下图为例，每个父节点加载对应子节点，并按import顺序执行同级。模块图文件执行顺序为：D-&gt;F-&gt;G-&gt;E-&gt;B-&gt;I-&gt;H-&gt;C-&gt;A。\",\"14\":\"\",\"15\":\"![zh-cn_image_0000002043487154](figures/zh-cn_image_0000002043487154.png)\",\"16\":\"\",\"17\":\"A文件称为入口文件，即执行起点。一些内置的加载接口，如[windowStage.loadContent](../reference/apis-arkui/arkts-apis-window-Window.md#loadcontent9)和[路由跳转](../ui/arkts-navigation-navigation.md)等页面拉起接口（即不是通过import写法拉起的文件），入参文件都会作为入口文件执行。\",\"18\":\"\"}",
      "用户拒绝的修改": "每个父节点加载子节点，并按import顺序执行同级。模块图文件执行顺序为：D->F->G->E->B->I->H->C->A。",
      "注意事项": "在修复技术文档冗余表达时，需优先保留指向图表的关键引导词（如\"以下图为例\"）和体现逻辑关系的限定词（如\"对应\"），避免因过度简化破坏上下文衔接或技术准确性。"
    },
    {
      "defect_id": 417720,
      "sentence": "字体特征描述字体内置的排版规则，控制字形显示。例如：连字、替代字形、上下标等。",
      "reference_sentence": "",
      "line_num": 50,
      "context": "{\"45\":\"| strikethroughThickness<sup>12+</sup>  | number | 否   | 是   | 文本删除线的厚度，即贯穿文本字符的水平线的宽度。    |\",\"46\":\"| strikethroughPosition<sup>12+</sup>  | number | 否   | 是   | 文本基线到底部删除线的垂直距离，通常为负值。         |\",\"47\":\"\",\"48\":\"## FontFeature<sup>20+</sup>\",\"49\":\"\",\"50\":\"字体特征描述字体内置的排版规则，控制字形显示。例如：连字、替代字形、上下标等。\",\"51\":\"\",\"52\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"53\":\"| 名称    | 类型   | 只读 | 可选 | 说明   |\",\"54\":\"| ------- | ------ | ---- | ---- | ------------------ |\",\"55\":\"| name   | string | 否   | 否   | 字体特征的名称。   |\"}",
      "用户拒绝的修改": "字体特征描述字体内置的排版规则，控制字形显示。例如：连字、替代字形、上下标。",
      "注意事项": "修复冗余表达时必须优先检查文档规范要求，保留示例列表末尾的\"等\"字等必要格式标记；避免机械应用逗号数量规则，需结合上下文和DocLinter规范判断是否属于有效冗余。"
    },
    {
      "defect_id": 410866,
      "sentence": "3. 在entry模块的oh-package.json5文件中配置har包的依赖。",
      "reference_sentence": "",
      "line_num": 302,
      "context": "{\"297\":\"     workerPort.postMessage('worker thread post message to main thread');\",\"298\":\"   }\",\"299\":\"   ```\",\"300\":\"   <!-- @[create_har_worker](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/har/src/main/ets/workers/worker.ets) -->\",\"301\":\"\",\"302\":\"3. 在entry模块的oh-package.json5文件中配置har包的依赖。\",\"303\":\"\",\"304\":\"   ```ts\",\"305\":\"   // 在entry模块配置har包的依赖\",\"306\":\"   {\",\"307\":\"     \\\"name\\\": \\\"entry\\\",\"}",
      "用户拒绝的修改": "在entry模块的oh-package.json5文件中配置har包依赖。",
      "注意事项": "在修复冗余表达时需优先保持技术术语的准确性，避免过度删除修饰词导致语义歧义（如\"har包依赖\"易误解为依赖类型而非所属关系），同时应结合上下文同类表述（如\"workerPort.postMessage\"）验证修改后的语法一致性。"
    },
    {
      "defect_id": 413001,
      "sentence": "> - 从API version 12开始，支持使用\\@Sendable装饰器校验Sendable function。",
      "reference_sentence": "",
      "line_num": 45,
      "context": "{\"40\":\"\",\"41\":\"### Sendable function\",\"42\":\"\",\"43\":\"> **说明：**\",\"44\":\">\",\"45\":\"> - 从API version 12开始，支持使用\\\\@Sendable装饰器校验Sendable function。\",\"46\":\">\",\"47\":\"> - 针对API version 12的工程，开发者使用\\\\@Sendable装饰器校验Sendable function时，需在工程中配置\\\"compatibleSdkVersionStage\\\": \\\"beta3\\\"，否则其Sendable特性将不生效。参考[build-profile.json5配置文件说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-profile-V5)。\",\"48\":\">\",\"49\":\"> - 针对API version大于12的工程，开发者可直接使用\\\\@Sendable装饰器校验Sendable function，无需再进行其他配置。\",\"50\":\"\"}",
      "用户拒绝的修改": "API version 12开始支持使用@Sendable装饰器校验Sendable function。",
      "注意事项": "修复冗余表达时需优先保留技术文档的固定格式结构（如\"从...开始\"），避免破坏列表项一致性；修改前应检查上下文格式规范，确保不误删必要技术术语或标准表述。"
    },
    {
      "defect_id": 418641,
      "sentence": "更多异步锁相关接口，请参见[异步锁ArkTSUtils.locks](../reference/apis-arkts/js-apis-arkts-utils.md#arktsutilslocks)。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"为了解决多线程并发实例间的数据竞争问题，ArkTS引入了异步锁能力。异步锁可能会被类对象持有，因此为了更方便地在并发实例间获取同一个异步锁对象，[AsyncLock对象](../reference/apis-arkts/js-apis-arkts-utils.md#asynclock)支持跨线程引用传递。\",\"4\":\"\",\"5\":\"由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）。同时，异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题。\",\"6\":\"\",\"7\":\"更多异步锁相关接口，请参见[异步锁ArkTSUtils.locks](../reference/apis-arkts/js-apis-arkts-utils.md#arktsutilslocks)。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> 使用异步锁的方法需标记为async，调用时需用await修饰，以确保时序正确。\",\"12\":\"\"}",
      "用户拒绝的修改": "参见[异步锁相关接口](../reference/apis-arkts/js-apis-arkts-utils.md#arktsutilslocks)。",
      "注意事项": "修复冗余表达时必须保留原文关键术语（如\"ArkTSUtils.locks\"）和限定词（如\"更多\"），确保技术文档的精准性和链接锚文本的完整性，避免因过度简化导致语义偏差或导航功能失效。"
    },
    {
      "defect_id": 423802,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 440,
      "context": "{\"435\":\"\",\"436\":\"## Axis\",\"437\":\"\",\"438\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"439\":\"\",\"440\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"441\":\"\",\"442\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"443\":\"\",\"444\":\"| 名称         | 值 | 说明     |\",\"445\":\"| ---------- | -- | ------ |\"}",
      "用户拒绝的修改": "该接口支持在原子化服务中使用。",
      "注意事项": "在修复冗余表达时需识别并保留文档中的固定格式或版本声明（如“从API version X开始”），避免删除关键上下文信息，应先验证内容是否属于规范化的标准表述结构。"
    },
    {
      "defect_id": 428592,
      "sentence": "配置levelFrom时，安全级别可选配置如下：",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"  配置user时，如果user未定义，需要先在users策略文件里定义，示例：\",\"18\":\"  ```text\",\"19\":\"  user o roles { r } level s0 range s0 - s0:c0.x1279;\",\"20\":\"  ```\",\"21\":\"\",\"22\":\"  配置levelFrom时，安全级别可选配置如下：\",\"23\":\"\",\"24\":\" | levelFrom | 释义 | level级别 |\",\"25\":\" | -------- | ---- | ------------- |\",\"26\":\" | app | 根据appId确认级别。 | \\\"s0:x%u,x%u,x%u\\\", appId & 0xff, 256 + (appId>>8 & 0xff), 512 + (appId>>16 & 0xff)|\",\"27\":\" | user | 根据userId确认级别。 | \\\"s0:x%u,x%u\\\", 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\"}",
      "用户拒绝的修改": "配置levelFrom时，安全级别配置如下：",
      "注意事项": "在优化冗余表达时必须优先保留关键限定词（如\"可选\"），需结合上下文确认术语准确性，避免因过度简化导致技术参数描述失准。"
    },
    {
      "defect_id": 423801,
      "sentence": "从API version 9开始，该接口支持在ArkTS卡片中使用。",
      "reference_sentence": "",
      "line_num": 438,
      "context": "{\"433\":\"| Round  | 在线条两端延伸半个圆，直径等于线宽。            |\",\"434\":\"| Square | 在线条两端延伸一个矩形，宽度等于线宽的一半，高度等于线宽。 |\",\"435\":\"\",\"436\":\"## Axis\",\"437\":\"\",\"438\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"439\":\"\",\"440\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"441\":\"\",\"442\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"443\":\"\"}",
      "用户拒绝的修改": "该接口支持在ArkTS卡片中使用。",
      "注意事项": "必须保留技术文档中明确标注API版本号的关键技术规格信息，注意识别文档中\"卡片能力\"/\"原子化服务API\"等固定版块的结构化表达模式，避免误删具有版本区分作用的时间状语。"
    },
    {
      "defect_id": 430190,
      "sentence": "- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。",
      "reference_sentence": "",
      "line_num": 76,
      "context": "{\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\"}",
      "用户拒绝的修改": "- 信号编号35～45：已被系统内部模块占用，禁止使用。",
      "注意事项": "保留技术文档中必要的版本信息（如\"API 19\"）和具体示例（如\"内存、DFX模块\"），在删除冗余表达时需确保关键限定条件不丢失，同时保持与上下文其他信号描述格式的一致性。"
    },
    {
      "defect_id": 428589,
      "sentence": "当前MCS默认为开启状态，需要关闭MCS时，可在selinux_adapter部件里配置selinux_adapter_mcs_enable=false。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"## MCS背景介绍\",\"4\":\"\",\"5\":\"Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。\",\"6\":\"\",\"7\":\"## MCS开关配置\",\"8\":\"当前MCS默认为开启状态，需要关闭MCS时，可在selinux_adapter部件里配置selinux_adapter_mcs_enable=false。\",\"9\":\"\",\"10\":\"## MCS安全级别配置\",\"11\":\"\",\"12\":\"  为应用进程添加MCS配置，需要保证MCS开关开启，然后在sehap_contexts配置文件中按需配置levelFrom和user，如果未配置user，默认为user=u。示例如下：\",\"13\":\"  ```text\"}",
      "用户拒绝的修改": "MCS默认开启，关闭时配置selinux_adapter_mcs_enable=false。",
      "注意事项": "修复冗余表达时必须保留关键配置路径（如selinux_adapter部件），优先删除重复性描述而非技术细节，技术文档中具体组件名称和参数位置属于必要信息不可省略。"
    },
    {
      "defect_id": 430157,
      "sentence": "由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\"}",
      "用户拒绝的修改": "由于命名空间隔离机制，应用仅允许加载对应安装目录下的应用native库。当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。",
      "注意事项": "在删除冗余信息前需确认示例是否属于关键上下文（如历史问题引用或平台差异说明），避免因过度简化导致技术细节丢失；优先采用分句/补充标点代替直接删除，例如保留括号示例并改为\"例如arm64平台的`libs/arm64`目录\"来维持信息完整性。"
    },
    {
      "defect_id": 430154,
      "sentence": "系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\",\"18\":\"**已知C++兼容性问题：**\",\"19\":\"\",\"20\":\"应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。解决此问题需要更新应用或者共享库HAR包的SDK版本。\",\"21\":\"\"}",
      "用户拒绝的修改": "系统和应用使用的C++标准库不能混用。Native API接口当前只能是C接口，通过这个接口隔离两边的C++运行环境。使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的版本，可能会导致不兼容问题。可以使用相同的SDK版本更新HAR包解决此问题。",
      "注意事项": "在删除冗余表达前需确认重复内容是否承载技术细节强调作用，优先保留关键术语的完整表述（如\"libc++_shared.so版本\"的重复出现）以维持技术文档的精确性，同时保留\"因此\"等逻辑连接词确保因果关系的明确性。"
    },
    {
      "defect_id": 430192,
      "sentence": "鸿蒙内部信号使用统计如下：",
      "reference_sentence": "",
      "line_num": 79,
      "context": "{\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\",\"82\":\"|------|-----------|-----------------|------|--------------------------------------------|---------------------------|\",\"83\":\"| 1    | SIGHUP    |  控制终端挂起    | 24   | SIGXCPU                                    | 超出 CPU 时间限制          | \",\"84\":\"| 2    | SIGINT    |  中断           | 25   | SIGXFSZ                                    | 文件超出大小限制            |\"}",
      "用户拒绝的修改": "鸿蒙内部信号使用统计：",
      "注意事项": "修复冗余表达时需优先核对上下文术语一致性，确认目标词汇是否为历史沿用固定搭配（如\"使用统计\"在技术文档中可能为专有统计分类），避免因过度简化破坏行业术语或已有规范。"
    },
    {
      "defect_id": 423803,
      "sentence": "SystemCapability.ArkUI.ArkUI.Full",
      "reference_sentence": "",
      "line_num": 442,
      "context": "{\"437\":\"\",\"438\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\",\"439\":\"\",\"440\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"441\":\"\",\"442\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"443\":\"\",\"444\":\"| 名称         | 值 | 说明     |\",\"445\":\"| ---------- | -- | ------ |\",\"446\":\"| Vertical   | 0 | 方向为纵向。 |\",\"447\":\"| Horizontal | 1 | 方向为横向。 |\"}",
      "用户拒绝的修改": "系统能力：SystemCapability.ArkUI.ArkUI.Full",
      "注意事项": "修复冗余表达时需严格识别并保留技术文档中的固定术语和官方命名规范，避免修改系统能力、API名称等不可变内容，同时遵循原文格式要求（如加粗、代码块等）。"
    },
    {
      "defect_id": 428669,
      "sentence": "  OpenHarmony SELinux支持两种运行模式：",
      "reference_sentence": "",
      "line_num": 49,
      "context": "{\"44\":\"\",\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\"}",
      "用户拒绝的修改": "  OpenHarmony SELinux支持两种模式：",
      "注意事项": "修复冗余表达时需优先识别技术术语的固定搭配（如\"运行模式\"），结合上下文确认术语完整性，避免将必要限定词误判为冗余。"
    },
    {
      "defect_id": 428665,
      "sentence": "  表示被访问方，客体一般是文件、目录、参数、SA服务、HDF服务等系统资源。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"  表示访问方，主体可以是一个用户、一个进程、一个服务或其他SELinux类型，OpenHarmony SELinux对进程主体分为四大类：Native进程、应用进程、SA进程、HDF进程。\",\"30\":\"\",\"31\":\"- **客体**\",\"32\":\"\",\"33\":\"  表示被访问方，客体一般是文件、目录、参数、SA服务、HDF服务等系统资源。\",\"34\":\"\",\"35\":\"- **sid**\",\"36\":\"\",\"37\":\"  安全标识符(**S**ecurity **ID**)，用于标识进程、文件或其他SELinux对象的唯一标识符。\",\"38\":\"\"}",
      "用户拒绝的修改": "  表示被访问方，客体包括文件、目录、参数、SA服务、HDF服务等。",
      "注意事项": "在删除冗余修饰成分时需保留具有分类解释功能的核心概括词(如\"系统资源\")，避免因过度简化导致专业术语失去上下文支撑，同时需结合相邻条目结构保持文档逻辑一致性。"
    },
    {
      "defect_id": 430188,
      "sentence": "为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：",
      "reference_sentence": "",
      "line_num": 74,
      "context": "{\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\"}",
      "用户拒绝的修改": "避免与系统保留信号冲突，开发者需遵循以下规则：",
      "注意事项": "保留技术文档中必要的上下文限定词（如\"在使用信号时\"）和目的连词（如\"为\"），避免过度简化导致语义模糊或破坏原有规范表述的完整性。"
    },
    {
      "defect_id": 428555,
      "sentence": "**接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。相关接口列表如下：\",\"10\":\"\",\"11\":\"| 接口名 | 接口说明 | 参数说明 |\",\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\"}",
      "用户拒绝的修改": "更新单个文件或目录的标签。返回值：0表示成功，其他表示失败。",
      "注意事项": "修复冗余表达时需先检查上下文是否存在对比项，保留必要的区分性描述（如\"不递归遍历\"）；技术文档中关键行为差异应优先于句式简洁性要求。"
    },
    {
      "defect_id": 428420,
      "sentence": "SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。",
      "reference_sentence": "",
      "line_num": 82,
      "context": "{\"77\":\"allow hdcd selinuxfs:file open;\",\"78\":\"```\",\"79\":\"\",\"80\":\"## 策略格式\",\"81\":\"\",\"82\":\"SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。通常allow规则如下:\",\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\"}",
      "用户拒绝的修改": "SELinux策略通常以allow或neverallow开头，表示允许或禁止某种行为。",
      "注意事项": "在删除重复表述前需确认是否为必要术语解释，优先保留有助于理解关键概念的同义表述，特别是当上下文可能涉及多术语交替使用时。\n\n应结合技术文档特性区分冗余信息和术语补充，避免机械删除具有解释功能的同位语结构（如\"又称XX\"）。"
    },
    {
      "defect_id": 434191,
      "sentence": "动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。",
      "reference_sentence": "",
      "line_num": 27,
      "context": "{\"22\":\"## 2. musl libc动态链接器\",\"23\":\"\",\"24\":\"### 动态库加载命名空间隔离\",\"25\":\"动态库加载命名空间（namespace，下面统称为ns）是动态链接器设计的一个概念（区别于C++语言中的命名空间），其设计的主要目的是为了在进程中做native库资源访问的管控，以达到安全隔离的目的。例如系统native库允许加载系统目录（/system/lib64;/vendor/lib64等）下的native库，但是普通应用native库仅允许加载普通应用native库和ndk库，而不允许直接加载系统native库。\",\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\"}",
      "用户拒绝的修改": "动态链接器在加载编译依赖的共享库或调用`dlopen`加载指定的共享库时，都需要关联到具体的ns。",
      "注意事项": "在修复冗余表达时需优先保留技术文档中的关键术语（如\"DT_NEEDED\"）和括号补充说明，避免因过度简化导致专业信息丢失；应通过拆分长句而非直接删除技术细节来优化可读性。"
    },
    {
      "defect_id": 432031,
      "sentence": "宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\",\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\"}",
      "用户拒绝的修改": "宏定义FD_ISSET检查fd的有效值。如果fd不在区间`[0, 1024)`中，返回false。",
      "注意事项": "保留技术文档中强调功能变更的关键词（如\"增加\"），避免过度简化导致版本信息丢失；处理长句时应优先拆分而非删减必要修饰，确保技术细节的完整性和上下文一致性。"
    },
    {
      "defect_id": 428316,
      "sentence": "4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\",\"38\":\"| contexts类型 | 加载方 | 用途 |\",\"39\":\"| -------- | -------- | -------- |\"}",
      "用户拒绝的修改": "4. 将contexts归档到`system.img`。位于`/system/etc/selinux/targeted/contexts/`。",
      "注意事项": "避免机械拆分必要补充信息，优先保持技术文档的语义连贯性；修复冗余表达时需结合上下文判断信息完整性，仅在存在重复描述时进行合并或删减。"
    },
    {
      "defect_id": 428419,
      "sentence": "另外，当`permissive=0`时，表示强制模式，会告警并拦截。",
      "reference_sentence": "",
      "line_num": 68,
      "context": "{\"63\":\"  - `dev=\\\"selinuxfs\\\"`，表示被访问客体属于selinuxfs这一文件系统。\",\"64\":\"  - `ino=4`，表示文件节点编号为4。\",\"65\":\"  - `scontext=u:r:hdcd:s0`，表示主体SELinux标签为`u:r:hdcd:s0`。\",\"66\":\"  - `tcontext=u:object_r:selinuxfs:s0`，表示被访问客体SELinux标签为`u:object_r:selinuxfs:s0`。\",\"67\":\"  - `tclass=file`，表示当前执行file的操作类型。\",\"68\":\"  - `permissive=1`，表示当前SELinux处于宽容模式，只告警不拦截。另外，当`permissive=0`时，表示强制模式，会告警并拦截。\",\"69\":\"\",\"70\":\"开发者可以使用关键字`avc denied`来过滤日志，对于影响业务的avc告警，可以利用告警提供的信息来编写相应的SELinux策略，例如：\",\"71\":\"```text\",\"72\":\"audit: type=1400 audit(1502458430.566:4): avc:  denied  { open } for  pid=1658 comm=\\\"setenforce\\\" path=\\\"/sys/fs/selinux/enforce\\\" dev=\\\"selinuxfs\\\" ino=4 scontext=u:r:hdcd:s0 tcontext=u:object_r:selinuxfs:s0 tclass=file permissive=1\",\"73\":\"```\"}",
      "用户拒绝的修改": "当`permissive=0`时，表示强制模式，会告警并拦截。",
      "注意事项": "修复冗余表达时必须结合上下文判断逻辑衔接词的必要性，保留用于补充说明或转折关系的过渡词（如\"另外\"），避免破坏语句间的逻辑连贯性。"
    },
    {
      "defect_id": 428308,
      "sentence": "2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件，得到`system.cil`和`vendor.cil`。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"![selinux_structure](./figures/SELinux-policy.png)\",\"10\":\"### 策略编译\",\"11\":\"OpenHarmony SELinux策略编译主要包括以下流程：\",\"12\":\"1. 按`security_classes, initial_sids, access_vectors, glb_perm_def.spt, glb_never_def.spt, mls, policy_cap, glb_te_def.spt, attributes, .te, glb_roles.spt, users, initial_sid_contexts, fs_use, virtfs_contexts`顺序遍历策略目录`//base/security/selinux_adapter/sepolicy/`，得到父目录为system和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`system.conf`中间文件，这里会决定是否展开隔离宏。同理，遍历得到父目录为vendor和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`vendor.conf`中间文件，这里也会决定是否展开隔离宏。\",\"13\":\"2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件，得到`system.cil`和`vendor.cil`。\",\"14\":\"3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。\",\"15\":\"4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。\",\"16\":\"\",\"17\":\"### 策略加载\",\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\"}",
      "用户拒绝的修改": "2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件。得到`system.cil`和`vendor.cil`。",
      "注意事项": "修复冗余表达时需保持动作与结果的逻辑连贯性，避免拆分导致语义断裂；优先保留技术文档中步骤描述的整体性，拆分前需确认上下文是否存在统一的结构规范。"
    },
    {
      "defect_id": 428556,
      "sentence": "**接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。相关接口列表如下：\",\"10\":\"\",\"11\":\"| 接口名 | 接口说明 | 参数说明 |\",\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\",\"19\":\"## 开发步骤\"}",
      "用户拒绝的修改": "单线程更新文件或目录的标签。返回值：0表示成功，其他表示失败。",
      "注意事项": "在技术文档中，冗余信息可能承载关键区别功能，需优先保留技术参数差异；精简时应通过\"对比上下文\"确认修饰成分是否属于核心功能描述，避免因过度简化导致接口特性混淆。"
    },
    {
      "defect_id": 432034,
      "sentence": "信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。",
      "reference_sentence": "",
      "line_num": 76,
      "context": "{\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\",\"81\":\"| 编号 | 名称      | 备注             | 编号 | 名称                                        | 备注                      |\"}",
      "用户拒绝的修改": "信号编号35～45已被系统内部模块占用，避免使用该范围内的信号。",
      "注意事项": "保留关键技术细节和示例说明，避免过度简化导致信息缺失。在删除修饰成分时需评估上下文必要性，优先保留有助于开发者理解限制原因的说明性内容。"
    },
    {
      "defect_id": 428727,
      "sentence": "这里使用APL等级为normal的应用作为示例，其他APL等级的应用参考下表配置：",
      "reference_sentence": "",
      "line_num": 106,
      "context": "{\"101\":\"2. 在type.te中定义`permissionmanager_hap`和`permissionmanager_hap_data_file`，使`u:r:permissionmanager_hap:s0`和`u:object_r:permissionmanager_hap_data_file:s0`是合法的。\",\"102\":\"    ```text\",\"103\":\"    type permissionmanager_hap, normal_hap_attr, hap_domain, domain;\",\"104\":\"    type permissionmanager_hap_data_file, normal_hap_data_file_attr, hap_file_attr, data_file_attr, file_attr;\",\"105\":\"    ```\",\"106\":\"    这里使用APL等级为normal的应用作为示例，其他APL等级的应用参考下表配置：\",\"107\":\"\",\"108\":\"    **表1** APL等级与应用attribute归属对应关系\",\"109\":\"    | APL等级 | 应用进程attribute归属 | 应用数据目录attribute归属 |\",\"110\":\"    | -------- | -------- | -------- |\",\"111\":\"    | normal | normal_hap_attr | normal_hap_data_file_attr |\"}",
      "用户拒绝的修改": "使用APL等级为normal的应用作为示例，其他APL等级的应用参考下表配置：",
      "注意事项": "保留具有上下文限定功能的指示词（如\"这里\"），避免删除技术文档中具有特定范围指向性的词汇；在简化冗余表达前需结合上下文确认修饰成分是否承担重要语义功能。"
    },
    {
      "defect_id": 428722,
      "sentence": "如果demo是由init孵化，则定义：",
      "reference_sentence": "",
      "line_num": 26,
      "context": "{\"21\":\"        ]\",\"22\":\"    }\",\"23\":\"    ```\",\"24\":\"2. 在type.te中定义SELinux标签u:r:demo:s0中的SELinux类型demo，使u:r:demo:s0是合法的。\",\"25\":\"\",\"26\":\"    如果demo是由init孵化，则定义：\",\"27\":\"    ```text\",\"28\":\"    type demo, native_system_domain, domain;\",\"29\":\"    ```\",\"30\":\"    如果demo是由chipset_init孵化，则定义：\",\"31\":\"    ```text\"}",
      "用户拒绝的修改": "如果demo由init孵化，定义：",
      "注意事项": "在修复冗余表达时需保留技术文档中必要的条件关联词（如“如果···则···”），避免破坏条件句的逻辑结构，优先检查领域特定语法规范后再进行简化。"
    },
    {
      "defect_id": 428309,
      "sentence": "4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"### 策略编译\",\"11\":\"OpenHarmony SELinux策略编译主要包括以下流程：\",\"12\":\"1. 按`security_classes, initial_sids, access_vectors, glb_perm_def.spt, glb_never_def.spt, mls, policy_cap, glb_te_def.spt, attributes, .te, glb_roles.spt, users, initial_sid_contexts, fs_use, virtfs_contexts`顺序遍历策略目录`//base/security/selinux_adapter/sepolicy/`，得到父目录为system和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`system.conf`中间文件，这里会决定是否展开隔离宏。同理，遍历得到父目录为vendor和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`vendor.conf`中间文件，这里也会决定是否展开隔离宏。\",\"13\":\"2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件，得到`system.cil`和`vendor.cil`。\",\"14\":\"3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。\",\"15\":\"4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。\",\"16\":\"\",\"17\":\"### 策略加载\",\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\",\"19\":\"1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。\",\"20\":\"2. 然后根据配置文件`/system/etc/selinux/config`中SELINUX字段的值设置运行模式，`SELINUX=enforcing`时，设置为强制模式，`SELINUX=permissive`时，设置为宽容模式。从OpenHarmony 3.2开始，OpenHarmony SELinux默认以强制模式运行。\"}",
      "用户拒绝的修改": "4. 编译后的二进制策略文件会归档到`system.img`。位于`/system/etc/selinux/targeted/policy/policy.31`。",
      "注意事项": "拆分句子前需优先评估语义连贯性，仅当拆分后能形成独立完整语义时执行；在技术文档中应保持路径描述与主句的隶属关系，避免因拆分导致上下文脱节。"
    },
    {
      "defect_id": 428559,
      "sentence": "**接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\",\"19\":\"## 开发步骤\",\"20\":\"\",\"21\":\"1. 编译依赖添加\",\"22\":\"\"}",
      "用户拒绝的修改": "根据父目录标签更新当前路径的标签。返回值：0表示成功，其他表示失败。",
      "注意事项": "在精简冗余表达时需优先保留关键性技术细节（如\"单线程\"等操作方式描述）和功能区分要素，避免因过度简化导致核心信息丢失；同时应结合上下文同类接口描述模式，保持技术文档的术语一致性和功能对比性。"
    },
    {
      "defect_id": 431704,
      "sentence": "由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\"}",
      "用户拒绝的修改": "由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下的应用native库。当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库，这种情况可以通过rpath机制编译时指定搜索路径。",
      "注意事项": "拆分长句时应优先保留关键示例（如平台路径说明），避免因过度简化导致技术细节丢失；需结合上下文判断信息冗余性，确保修复后逻辑连贯性和示例完整性。"
    },
    {
      "defect_id": 432030,
      "sentence": "宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"### 支持symbol-version机制\",\"60\":\"symbol-version是libc在**动态链接-符号重定位**阶段的符号检索机制，支持不同版本的符号重定位，也可以帮助解决重复符号的问题。可参考<a href=\\\"https://www.gnu.org/software/gnulib/manual/html_node/LD-Version-Scripts.html\\\">LD Version Scripts (GNU Gnulib)</a>。\",\"61\":\"\",\"62\":\"### 网络接口select支持fd fortify检测\",\"63\":\"宏定义FD_SET和FD_CLR增加了对fd有效值的检查。如果传入的fd不在区间`[0, 1024)`中，将触发abort crash。\",\"64\":\"\",\"65\":\"宏定义FD_ISSET增加了对fd有效值的检查，如果传入的fd不在区间`[0, 1024)`中会返回false。\",\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\"}",
      "用户拒绝的修改": "宏定义FD_SET和FD_CLR检查fd的有效值。如果fd不在区间`[0, 1024)`中，触发abort crash。",
      "注意事项": "修复冗余表达时需优先保留技术文档中的关键术语（如\"传入的fd\"）和上下文关联词（如\"增加\"暗示功能变更），避免过度简化导致技术细节丢失。"
    },
    {
      "defect_id": 428557,
      "sentence": "**接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"| 接口名 | 接口说明 | 参数说明 |\",\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\",\"19\":\"## 开发步骤\",\"20\":\"\"}",
      "用户拒绝的修改": "多线程更新文件或目录的标签。返回值：0表示成功，其他表示失败。",
      "注意事项": "在删除冗余表达时需保留关键区别性描述（如\"递归遍历\"是区分接口功能的核心特征），避免过度简化导致重要上下文信息丢失；需结合相邻接口描述的对比关系判断必要修饰成分。"
    },
    {
      "defect_id": 434187,
      "sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\",\"9\":\"- 系统库：使用libc++.so，随系统镜像发布。\",\"10\":\"- 应用Native库：使用libc++_shared.so，随应用发布。\",\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\"}",
      "用户拒绝的修改": "两个库使用不同的C++命名空间。libc++.so使用__h作为C++符号的命名空间，libc++_shared.so使用__n1作为C++符号的命名空间。",
      "注意事项": "保留必要的对比连接词（如\"而\"）以明确技术差异，避免过度简化导致关键信息弱化；技术文档中优先保证概念表述的精确性，冗余优化需确保不影响专业术语的完整性和对比关系的清晰度。"
    },
    {
      "defect_id": 428558,
      "sentence": "**接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"| 接口名 | 接口说明 | 参数说明 |\",\"12\":\"| --------- | ---------- | ---------- |\",\"13\":\"| int **Restorecon**(const char *path); | **接口功能**：更新单个文件或者目录的标签，不递归遍历子目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"14\":\"| int **RestoreconRecurse**(const char *path); | **接口功能**：单线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"15\":\"| int **RestoreconRecurseParallel**(const char *path, unsigned int nthreads); | **接口功能**：多线程更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。<br/>nthreads表示线程个数。 |\",\"16\":\"| int **RestoreconRecurseForce**(const char *path); | **接口功能**：单线程强制更新文件或者目录的标签，递归遍历更新子目录和文件标签。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"17\":\"| int **RestoreconFromParentDir**(const char *path); | **接口功能**：根据当前路径的父目录标签，单线程更新当前路径的标签，递归遍历更新整个目录。<br/>**返回值**：0表示成功，其他返回值表示失败。 | path表示绝对路径。 |\",\"18\":\"\",\"19\":\"## 开发步骤\",\"20\":\"\",\"21\":\"1. 编译依赖添加\"}",
      "用户拒绝的修改": "单线程强制更新文件或目录的标签。返回值：0表示成功，其他表示失败。",
      "注意事项": "在消除冗余表达时应优先保留技术文档中的关键区别信息（如\"强制\"等限定词），避免因过度简化导致接口功能描述失去关键特征或产生歧义。"
    },
    {
      "defect_id": 432033,
      "sentence": "信号编号 1～34：为系统内部保留信号，禁止使用；",
      "reference_sentence": "",
      "line_num": 75,
      "context": "{\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\",\"77\":\"- SIGRTMIN和__libc_current_sigrtmin的值是35, 表示可供应用程序使用的实时信号起始编号(应用实际只能使用46及以上的信号)。\",\"78\":\"\",\"79\":\"鸿蒙内部信号使用统计如下：\",\"80\":\"\"}",
      "用户拒绝的修改": "信号编号1～34为系统内部保留信号，禁止使用。",
      "注意事项": "保留技术文档中列表项的标准标点格式（如冒号、分号），避免将结构化排版符号误判为冗余；修改前需检查相邻条目格式一致性，确保不破坏技术规范文档的严谨性。"
    },
    {
      "defect_id": 428723,
      "sentence": "如果demo是由chipset_init孵化，则定义：",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"\",\"26\":\"    如果demo是由init孵化，则定义：\",\"27\":\"    ```text\",\"28\":\"    type demo, native_system_domain, domain;\",\"29\":\"    ```\",\"30\":\"    如果demo是由chipset_init孵化，则定义：\",\"31\":\"    ```text\",\"32\":\"    type demo, native_chipset_domain, domain;\",\"33\":\"    ```\",\"34\":\"\",\"35\":\"## 新增SA服务进程\"}",
      "用户拒绝的修改": "如果demo由chipset_init孵化，定义：",
      "注意事项": "保留必要的逻辑连接词（如\"则\"）以维持条件句逻辑完整性，修复时需检查上下文同类句式确保结构一致性。"
    },
    {
      "defect_id": 434193,
      "sentence": "default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"动态链接器无论是在加载编译依赖（DT_NEEDED）中指定的共享库，还是调用`dlopen`加载指定的共享库，都需要关联到具体的ns。\",\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\",\"33\":\"- ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。\",\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\"}",
      "用户拒绝的修改": "default ns是动态链接器启动时默认创建的ns，可以搜索系统目录路径下的so。",
      "注意事项": "修复冗余表达时需保留必要的技术细节（如路径示例），确保与上下文格式一致；优先删除重复性描述而非关键参数，避免过度简化导致信息缺失。"
    },
    {
      "defect_id": 434194,
      "sentence": "ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"OpenHarmony中动态库加载namespace配置的情况\",\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\",\"33\":\"- ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。\",\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\"}",
      "用户拒绝的修改": "ndk ns是动态链接器启动时默认创建的ns，可以搜索`/system/lib{abi}/ndk`目录下的so，主要暴露NDK接口。",
      "注意事项": "修复冗余表达时应优先保留技术文档特有的术语结构和上下文一致性，避免过度简化导致语义偏移；确保删除的修饰成分不影响关键信息准确性（如被动语态、逻辑连接词）。"
    },
    {
      "defect_id": 434195,
      "sentence": "app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"- default ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi};/vendor/lib{abi}`等系统目录路径下的so。\",\"32\":\"\",\"33\":\"- ndk ns：动态链接器启动时默认创建的ns，它可以搜索`/system/lib{abi}/ndk`目录下的so，主要是暴露了NDK接口的so。\",\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\"}",
      "用户拒绝的修改": "app ns是应用启动时创建的ns，搜索路径一般是应用的安装路径（可能为沙箱路径），可以加载应用的so。",
      "注意事项": "保持技术文档的术语连贯性和上下文结构一致性，避免过度修改导致语义弱化（如\"即可\"改为\"可以\"会丢失因果关系）；优先保留技术场景中的惯用表达，冗余判断需结合相邻条目格式综合评估。"
    },
    {
      "defect_id": 434199,
      "sentence": "由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\"}",
      "用户拒绝的修改": "由于命名空间隔离机制，应用仅允许加载对应安装目录下的native库。当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制在编译时指定搜索路径。",
      "注意事项": "在删除冗余修饰成分时需保留必要的技术细节（如平台示例\"arm64\"），避免过度简化导致关键信息丢失；处理长句时应优先拆分逻辑单元而非单纯删除逗号，保持技术文档的精确性和示例完整性。"
    },
    {
      "defect_id": 434197,
      "sentence": "2. app ns能访问ndk ns的全部so，不能访问default ns的so。",
      "reference_sentence": "",
      "line_num": 40,
      "context": "{\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\"}",
      "用户拒绝的修改": "2. app ns能访问ndk ns的全部so，但不能访问default ns的so。",
      "注意事项": "保持技术文档的简洁性和一致性，避免在已有清晰并列结构中添加冗余转折词（如\"但\"），优先沿用上下文已有的句式结构和连接方式。"
    },
    {
      "defect_id": 437028,
      "sentence": "      // 从图像源中读取图片的EXIF方向信息。",
      "reference_sentence": "",
      "line_num": 2005,
      "context": "{\"2000\":\"    if (!context) {\",\"2001\":\"      return;\",\"2002\":\"    }\",\"2003\":\"    this.getFileBuffer(context).then((buf: ArrayBuffer | undefined) => {\",\"2004\":\"      let imageSource = image.createImageSource(buf);\",\"2005\":\"      // 从图像源中读取图片的EXIF方向信息。\",\"2006\":\"      imageSource.getImageProperty(image.PropertyKey.ORIENTATION).then((orientation) => {\",\"2007\":\"        this.rotateOrientation = this.getOrientation(orientation);\",\"2008\":\"        this.text1 = this.text1 + orientation;\",\"2009\":\"      })\",\"2010\":\"      let options: image.DecodingOptions = {\"}",
      "用户拒绝的修改": "从图像源中读取图片的EXIF方向信息。",
      "注意事项": "修复代码注释时需保留注释符号\"//\"，避免破坏语法结构；修改冗余表达前应先识别注释与代码的边界，确保不误删功能性符号。"
    },
    {
      "defect_id": 434196,
      "sentence": "1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"- app ns: 应用启动时创建的ns，它的搜索路径一般是应用的安装路径(可能为沙箱路径)，即可加载应用的so。\",\"36\":\"\",\"37\":\"当前的命名空间机制主要限制了应用native库和系统native库之间的调用，具体规则如图所示：\",\"38\":\"\",\"39\":\"1. default ns和ndk ns可以互相访问全部so，不能访问app ns的so。\",\"40\":\"2. app ns能访问ndk ns的全部so，不能访问default ns的so。\",\"41\":\"\",\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\"}",
      "用户拒绝的修改": "1. default ns和ndk ns可以互相访问全部so，但不能访问app ns的so。",
      "注意事项": "修复冗余表达时应优先保持技术文档的精确性和结构一致性，避免过度修改导致语义转折词（如\"但\"）破坏并列规则表述；需结合上下文判断句式复杂度是否合理，技术条款中分项列举的并列结构不宜强制简化。"
    },
    {
      "defect_id": 437027,
      "sentence": "      // 转为ArrayBuffer并返回。",
      "reference_sentence": "",
      "line_num": 1989,
      "context": "{\"1984\":\"    try {\",\"1985\":\"      const resourceMgr: resourceManager.ResourceManager = context.resourceManager;\",\"1986\":\"      // 传入带有EXIF信息的资源文件，获取资源文件内容，返回Uint8Array。\",\"1987\":\"      const fileData: Uint8Array = await resourceMgr.getRawFileContent('hello.jpg');\",\"1988\":\"      console.info('Successfully get RawFileContent');\",\"1989\":\"      // 转为ArrayBuffer并返回。\",\"1990\":\"      const buffer: ArrayBuffer = fileData.buffer.slice(0);\",\"1991\":\"      return buffer;\",\"1992\":\"    } catch (error) {\",\"1993\":\"      console.error('Failed to get RawFileContent');\",\"1994\":\"      return undefined;\"}",
      "用户拒绝的修改": "转为ArrayBuffer并返回。",
      "注意事项": "处理代码注释时必须保留注释符\"//\"，修改时仅优化注释文本内容；区分代码语句与注释说明的语法差异，避免将注释内容误判为可执行代码进行删减。"
    },
    {
      "defect_id": 434233,
      "sentence": "[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"### 全球化支持\",\"68\":\"自API12起，newlocale及setlocale接口支持将locale设置C、C.UTF-8、en_US、en_US.UTF-8、zh_CN及zh_CN.UTF-8。新增在zh_CN及zh_CN.UTF-8的locale设置下对strtod_l、wcstod_l和localeconv的支持。注意strtod_l及wcstod_l不支持对十六进制及十六进制小数的转换。\",\"69\":\"\",\"70\":\"### fdsan功能\",\"71\":\"[fdsan使用指导](./fdsan.md)可以帮助检测文件的重复关闭和关闭后使用问题。\",\"72\":\"\",\"73\":\"## 3. 信号使用\",\"74\":\"为避免与系统保留信号冲突，开发者在使用信号时需遵循以下规则：\",\"75\":\"- 信号编号 1～34：为系统内部保留信号，禁止使用；\",\"76\":\"- 信号编号 35～45: 截止到目前 API 19，这些信号已被系统内部模块（如内存、DFX、运行时、系统服务等）占用，为避免与系统行为冲突并导致不可预期的问题，请勿使用该范围内的信号。\"}",
      "用户拒绝的修改": "使用[fdsan使用指导](./fdsan.md)检测文件的重复关闭和关闭后使用问题。",
      "注意事项": "修复冗余表达时需严格区分功能描述与操作指导的语境差异，保留技术文档中必要的功能说明性措辞（如\"可以帮助\"），避免过度简化导致语义重心从功能陈述向操作指令偏移。"
    },
    {
      "defect_id": 434200,
      "sentence": "例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。",
      "reference_sentence": "",
      "line_num": 49,
      "context": "{\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\",\"53\":\"```\",\"54\":\"![zh-cn_image_musl_ld_rpath](figures/dl_rpath.png)\"}",
      "用户拒绝的修改": "例如，应用安装目录`lib/arm64`下的`libhello.so`依赖`lib/arm64/module`下的`libworld.so`。在应用的`CMakeList.txt`中设置`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。",
      "注意事项": "修复冗余表达时应优先保留技术文档的关键路径描述和逻辑完整性，避免过度简化导致必要信息丢失；需结合上下文判断修饰成分是否影响技术准确性，例如\"新创建路径\"的删除可能弱化目录层级关系。"
    },
    {
      "defect_id": 441771,
      "sentence": "在API version 9上，Navigation需要配合[NavRouter](../reference/apis-arkui/arkui-ts/ts-basic-components-navrouter.md)组件实现页面路由。从API version 10开始，更推荐使用[NavPathStack](../reference/apis-arkui/arkui-ts/ts-basic-components-navigation.md#navpathstack10)实现页面路由。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"[Navigation](../reference/apis-arkui/arkui-ts/ts-basic-components-navigation.md)是路由导航的根视图容器，一般作为页面（@Entry）的根容器，包括单栏（Stack）、分栏（Split）和自适应（Auto）三种显示模式。Navigation组件适用于模块内和跨模块的路由切换，通过组件级路由能力实现更加自然流畅的转场体验，并提供多种标题栏样式来呈现更好的标题和内容联动效果。一次开发，多端部署场景下，Navigation组件能够自动适配窗口显示大小，在窗口较大的场景下自动切换分栏展示效果。\",\"6\":\"\",\"7\":\"Navigation组件主要包含​导航页和子页。导航页由标题栏（包含菜单栏）、内容区和工具栏组成，可以通过[hideNavBar](../reference/apis-arkui/arkui-ts/ts-basic-components-navigation.md#hidenavbar9)属性进行隐藏，导航页不存在[页面栈](../reference/apis-arkui/arkui-ts/ts-basic-components-navigation.md#navpathstack10)中，与子页，以及子页之间可以通过路由操作进行切换。\",\"8\":\"\",\"9\":\"在API version 9上，Navigation需要配合[NavRouter](../reference/apis-arkui/arkui-ts/ts-basic-components-navrouter.md)组件实现页面路由。从API version 10开始，更推荐使用[NavPathStack](../reference/apis-arkui/arkui-ts/ts-basic-components-navigation.md#navpathstack10)实现页面路由。\",\"10\":\"\",\"11\":\"\",\"12\":\"## 设置页面显示模式\",\"13\":\"\",\"14\":\"Navigation组件通过mode属性设置页面的显示模式。\"}",
      "用户拒绝的修改": "在API version 9上，Navigation需要配合NavRouter组件实现页面路由。从API version 10开始，推荐使用NavPathStack实现页面路由。",
      "注意事项": "保留技术文档中必要的参考链接和版本说明，避免将关键组件名称的文档链接误判为冗余信息；在精简表达时应优先确保技术术语的完整性和参考信息的可追溯性。"
    },
    {
      "defect_id": 443038,
      "sentence": "  // 禁用所有系统服务菜单项",
      "reference_sentence": "",
      "line_num": 234,
      "context": "{\"229\":\"  // xxx.ets\",\"230\":\"  @Entry\",\"231\":\"  @Component\",\"232\":\"  struct Index {\",\"233\":\"    aboutToAppear(): void {\",\"234\":\"      // 禁用所有系统服务菜单项\",\"235\":\"      TextMenuController.disableSystemServiceMenuItems(true)\",\"236\":\"    }\",\"237\":\"  \",\"238\":\"    aboutToDisappear(): void {\",\"239\":\"      // 页面消失时恢复系统服务菜单项\"}",
      "用户拒绝的修改": "  // 禁用系统服务菜单项",
      "注意事项": "在简化冗余表达时应优先保留与代码参数（如disableSystemServiceMenuItems(true)中的\"所有\"对应布尔参数）直接相关的技术性修饰词，避免因过度简化导致注释与实现逻辑脱节。"
    },
    {
      "defect_id": 447627,
      "sentence": "支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。",
      "reference_sentence": "",
      "line_num": 46,
      "context": "{\"41\":\"**图二**\",\"42\":\"![ide_previewer_001](figures/ide_previewer_001.gif)\",\"43\":\"\",\"44\":\"### inspector双向预览\",\"45\":\"\",\"46\":\"支持ets文件与预览器的双向预览。使用时，点击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。\",\"47\":\"\",\"48\":\"开启双向预览功能后，支持代码编辑器、UI界面和组件树之间的联动：\",\"49\":\"\",\"50\":\"1. 选中预览器界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。\",\"51\":\"\"}",
      "用户拒绝的修改": "支持ets文件与预览器的双向预览。使用时，点击预览器界面图标打开双向预览功能。",
      "注意事项": "在删除图片引用或技术文档中的可视化元素前，必须确认其是否属于必要操作指引；处理\"冗余表达\"时应优先保持技术文档的完整性，仅当文字描述与图示内容重复时才进行精简。"
    },
    {
      "defect_id": 449114,
      "sentence": "ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。具体请参考图1 卡片工程结构对比。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"以下内容介绍基于声明式范式ArkTS UI卡片开发。\",\"3\":\"\",\"4\":\"## 亮点/特征\",\"5\":\"1. 统一开发范式\",\"6\":\"\",\"7\":\"    - ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。具体请参考图1 卡片工程结构对比。\",\"8\":\"\",\"9\":\"    **图1** 卡片工程结构对比   \",\"10\":\"    ![WidgetProject](figures/WidgetProject.png)\",\"11\":\"\",\"12\":\"2. 卡片能力增强\"}",
      "用户拒绝的修改": "ArkTS卡片统一了卡片和应用页面的开发范式，应用页面的布局可以直接复用到卡片布局中，提升开发效率。",
      "注意事项": "修复冗余表达时应优先删除重复或非必要修饰词，避免直接删除并列的有效信息点；需结合上下文确认被删内容是否在原文其他位置承担独立语义功能。"
    },
    {
      "defect_id": 449199,
      "sentence": "- [Stage模型卡片JS与C++通信（ArkTS）（API10）](https://gitee.com/openharmony/applications_app_samples/tree/master/code/SuperFeature/Widget/FormGame)",
      "reference_sentence": "",
      "line_num": 94,
      "context": "{\"89\":\"\",\"90\":\"## 相关实例\",\"91\":\"\",\"92\":\"针对ArkTS卡片开发，有以下相关实例可供参考：\",\"93\":\"\",\"94\":\"- [Stage模型卡片JS与C++通信（ArkTS）（API10）](https://gitee.com/openharmony/applications_app_samples/tree/master/code/SuperFeature/Widget/FormGame)\"}",
      "用户拒绝的修改": "- [Stage模型卡片JS与C++通信（API10）](https://gitee.com/openharmony/applications_app_samples/tree/master/code/SuperFeature/Widget/FormGame)",
      "注意事项": "修复冗余表达时应优先确认被删除内容是否具备独立技术含义（如ArkTS标注语言类型、API10标识版本），避免因过度简化导致关键信息缺失；同时需结合修改上下文判断是否属于当前任务范围，防止引入无关变更。"
    },
    {
      "defect_id": 447412,
      "sentence": "用户场景id。无长度限制，推荐字母大写且用下划线连接，例如LAUNCHER_APP_LAUNCH_FROM_ICON。",
      "reference_sentence": "",
      "line_num": 60,
      "context": "{\"55\":\"\",\"56\":\"**参数：** \",\"57\":\"\",\"58\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"59\":\"| -- | -- | -- | -- |\",\"60\":\"| scene | string | 是 | 用户场景id。无长度限制，推荐字母大写且用下划线连接，例如LAUNCHER_APP_LAUNCH_FROM_ICON。 |\",\"61\":\"| startInputType | [ActionType](#actiontype)| 是 | 用户场景触发模式。 |\",\"62\":\"| note | string| 否 | 用户场景备注信息。长度限制30个字符，可以空缺不填，填写后性能指标上报会携带备注信息，不填无影响。 |\",\"63\":\"\",\"64\":\"**示例：** \",\"65\":\"\"}",
      "用户拒绝的修改": "用户场景id。推荐字母大写且用下划线连接。",
      "注意事项": "修复技术文档时应优先保留示例说明和关键限制条件，避免将必要的格式指导误判为冗余信息，特别是当上下文存在相似参数对比时需保持说明的完整性。"
    },
    {
      "defect_id": 449190,
      "sentence": "message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。",
      "reference_sentence": "",
      "line_num": 56,
      "context": "{\"51\":\"![WidgetPostCardAction](figures/WidgetPostCardAction.png)\",\"52\":\"\",\"53\":\"动态卡片事件的主要使用场景如下：\",\"54\":\"- router事件：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转应用内页面的交互功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。\",\"55\":\"- call事件：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。\",\"56\":\"- message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。\",\"57\":\"\",\"58\":\"### 静态卡片\",\"59\":\"ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。\",\"60\":\"请参见[FormLink](../reference/apis-arkui/arkui-ts/ts-container-formlink.md)。\",\"61\":\"\"}",
      "用户拒绝的修改": "message事件：拉起FormExtensionAbility，通过onFormEvent回调通知，完成卡片内控件点击消息传递，更新卡片内容。",
      "注意事项": "修复冗余表达时需优先检查上下文结构一致性，确保修改不破坏原有事件描述的平行格式；确认用户指明的修改范围，避免处理未被明确标注为冗余的原始表述。"
    },
    {
      "defect_id": 447415,
      "sentence": "用于标记用户场景结束，用户场景结束时调用此接口。",
      "reference_sentence": "",
      "line_num": 76,
      "context": "{\"71\":\"\",\"72\":\"## performanceMonitor.end\",\"73\":\"\",\"74\":\"end(scene: string): void\",\"75\":\"\",\"76\":\"用于标记用户场景结束，用户场景结束时调用此接口。\",\"77\":\"\",\"78\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"79\":\"\",\"80\":\"**参数：** \",\"81\":\"| 参数名 | 类型 | 必填 | 说明 |\"}",
      "用户拒绝的修改": "标记用户场景结束。",
      "注意事项": "在修复冗余表达时需结合上下文确认必要信息是否被覆盖，避免过度简化导致关键操作指引（如调用时机）缺失；优先保留技术文档中明确参数用途和触发条件的说明性内容。"
    },
    {
      "defect_id": 449115,
      "sentence": "新增了动效的能力：ArkTS卡片开放了[属性动画](../reference/apis-arkui/arkui-ts/ts-animatorproperty.md)和[显式动画](../reference/apis-arkui/arkui-ts/ts-explicit-animation.md)的能力，使卡片的交互更加友好。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"    **图1** 卡片工程结构对比   \",\"10\":\"    ![WidgetProject](figures/WidgetProject.png)\",\"11\":\"\",\"12\":\"2. 卡片能力增强\",\"13\":\"\",\"14\":\"    - 新增了动效的能力：ArkTS卡片开放了[属性动画](../reference/apis-arkui/arkui-ts/ts-animatorproperty.md)和[显式动画](../reference/apis-arkui/arkui-ts/ts-explicit-animation.md)的能力，使卡片的交互更加友好。\",\"15\":\"    - 新增了自定义绘制的能力：ArkTS卡片开放了[Canvas](../reference/apis-arkui/arkui-ts/ts-components-canvas-canvas.md)画布组件的能力，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。\",\"16\":\"    - 允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。\",\"17\":\"\",\"18\":\"## 实现原理\",\"19\":\"\"}",
      "用户拒绝的修改": "新增了动效能力：ArkTS卡片开放了属性动画和显式动画，使卡片的交互更友好。",
      "注意事项": "修复冗余表达时应优先保留技术术语完整性，避免删除关键限定词（如\"的能力\"可能属于技术概念范畴）；同时需结合上下文检查条目间表述一致性，确保修改不破坏原有技术信息的准确性和结构统一性。"
    },
    {
      "defect_id": 449116,
      "sentence": "新增了自定义绘制的能力：ArkTS卡片开放了[Canvas](../reference/apis-arkui/arkui-ts/ts-components-canvas-canvas.md)画布组件的能力，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"    ![WidgetProject](figures/WidgetProject.png)\",\"11\":\"\",\"12\":\"2. 卡片能力增强\",\"13\":\"\",\"14\":\"    - 新增了动效的能力：ArkTS卡片开放了[属性动画](../reference/apis-arkui/arkui-ts/ts-animatorproperty.md)和[显式动画](../reference/apis-arkui/arkui-ts/ts-explicit-animation.md)的能力，使卡片的交互更加友好。\",\"15\":\"    - 新增了自定义绘制的能力：ArkTS卡片开放了[Canvas](../reference/apis-arkui/arkui-ts/ts-components-canvas-canvas.md)画布组件的能力，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。\",\"16\":\"    - 允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。\",\"17\":\"\",\"18\":\"## 实现原理\",\"19\":\"\",\"20\":\"- 卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。\"}",
      "用户拒绝的修改": "新增了自定义绘制能力：ArkTS卡片开放了Canvas画布组件，卡片可以使用自定义绘制构建更多样的显示和交互效果。",
      "注意事项": "修复冗余表达时应优先保持上下文格式一致性，避免修改原文中已存在的统一句式结构；需结合相邻条目判断重复成分是否为有意设计的并列关系，不可孤立处理单一句子。"
    },
    {
      "defect_id": 449198,
      "sentence": "针对ArkTS卡片开发，有以下相关实例可供参考：",
      "reference_sentence": "",
      "line_num": 92,
      "context": "{\"87\":\"\",\"88\":\"- 不支持setTimeOut。\",\"89\":\"\",\"90\":\"## 相关实例\",\"91\":\"\",\"92\":\"针对ArkTS卡片开发，有以下相关实例可供参考：\",\"93\":\"\",\"94\":\"- [Stage模型卡片JS与C++通信（ArkTS）（API10）](https://gitee.com/openharmony/applications_app_samples/tree/master/code/SuperFeature/Widget/FormGame)\"}",
      "用户拒绝的修改": "针对ArkTS卡片开发，以下实例可供参考：",
      "注意事项": "在修复冗余表达时需优先确认修改范围是否属于当前问题上下文，避免修改历史遗留问题；同时需评估修改必要性，确保简洁化处理不破坏原句语义完整性和技术文档规范性。"
    },
    {
      "defect_id": 447417,
      "sentence": "记录动效场景开始前，用户输入触发事件类型与时间。",
      "reference_sentence": "",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"## performanceMonitor.recordInputEventTime<sup>12+</sup>\",\"93\":\"\",\"94\":\"recordInputEventTime(type: ActionType, sourceType: SourceType, time: number): void\",\"95\":\"\",\"96\":\"记录动效场景开始前，用户输入触发事件类型与时间。\",\"97\":\"\",\"98\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"99\":\"\",\"100\":\"**参数：**\",\"101\":\"| 参数名 | 类型 | 必填 | 说明 |\"}",
      "用户拒绝的修改": "记录用户输入触发事件类型与时间。",
      "注意事项": "修复冗余表达时应优先区分技术文档中的必要上下文（如时间条件、操作阶段）与冗余修饰，确保关键限定信息（如“动效场景开始前”）不被误删，需结合参数说明（如方法参数含时间参数）及功能场景综合判断必要性。"
    },
    {
      "defect_id": 449188,
      "sentence": "router事件：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转应用内页面的交互功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。",
      "reference_sentence": "",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"**图4** 动态卡片事件实现原理  \",\"51\":\"![WidgetPostCardAction](figures/WidgetPostCardAction.png)\",\"52\":\"\",\"53\":\"动态卡片事件的主要使用场景如下：\",\"54\":\"- router事件：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转应用内页面的交互功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。\",\"55\":\"- call事件：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。\",\"56\":\"- message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。\",\"57\":\"\",\"58\":\"### 静态卡片\",\"59\":\"ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。\"}",
      "用户拒绝的修改": "router事件：跳转到指定UIAbility，完成点击卡片跳转应用内页面。非系统应用仅支持跳转到自己应用内的UIAbility。",
      "注意事项": "修复冗余表达时必须严格核对修改范围，仅处理当前反馈明确指出的问题语句，避免改动未被提及的上下文内容；同时需区分技术文档必要的术语重复和真正的冗余表达，优先保留技术准确性。"
    },
    {
      "defect_id": 450228,
      "sentence": "具体可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。",
      "reference_sentence": "",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口时，[overflowInfo](../reference/apis-form-kit/js-apis-app-form-formInfo.md#overflowinfo20)中描述的互动卡片动效渲染区域（矩形EFGH）需要满足：\",\"63\":\"1. 完整包含了卡片（矩形ABCD）。\",\"64\":\"2. 不超过矩形IJKL（矩形IJKL完整包含矩形EFGH）。<!--Del-->仅三方应用生效，系统应用不作限制。<!--DelEnd-->\",\"65\":\"\",\"66\":\"具体可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"67\":\"\",\"68\":\"### 功耗约束\",\"69\":\"1. 当设备进入省电模式时，互动卡片不响应动效请求。\",\"70\":\"2. 当设备热档位进入WARM时，不再响应非点击触发的动效请求，当热档位进入OVERHEATED时，不再响应所有动效请求。具体可参考[热档位信息](../reference/apis-basic-services-kit/js-apis-thermal.md#thermallevel)。\",\"71\":\"\"}",
      "用户拒绝的修改": "参考[场景动效类型互动卡片开发指导]。",
      "注意事项": "修复冗余表达时必须保留超链接的完整结构（显示文本+链接地址），避免破坏功能性元素；简化时应优先删除冗余修饰词而非技术文档的核心参考信息。"
    },
    {
      "defect_id": 449189,
      "sentence": "call事件：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。",
      "reference_sentence": "",
      "line_num": 55,
      "context": "{\"50\":\"**图4** 动态卡片事件实现原理  \",\"51\":\"![WidgetPostCardAction](figures/WidgetPostCardAction.png)\",\"52\":\"\",\"53\":\"动态卡片事件的主要使用场景如下：\",\"54\":\"- router事件：可以使用router事件跳转到指定UIAbility，以完成点击卡片跳转应用内页面的交互功能。对于非系统应用仅支持跳转到自己应用内的UIAbility。\",\"55\":\"- call事件：可以使用call事件拉起指定UIAbility到后台，再通过UIAbility申请对应后台长时任务完成音乐播放等功能。\",\"56\":\"- message事件：可以使用message拉起FormExtensionAbility，通过onFormEvent接口回调通知，以完成卡片内控件点击消息传递，从而更新卡片内容。\",\"57\":\"\",\"58\":\"### 静态卡片\",\"59\":\"ArkTS卡片提供FormLink静态卡片交互组件，用于静态卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件。\",\"60\":\"请参见[FormLink](../reference/apis-arkui/arkui-ts/ts-container-formlink.md)。\"}",
      "用户拒绝的修改": "call事件：拉起指定UIAbility到后台，通过UIAbility申请后台长时任务，完成音乐播放等功能。",
      "注意事项": "在修复冗余表达时，需优先确保修改内容与上下文句式结构一致（如保留同类事件的\"可以使用\"引导语），避免因局部优化破坏文档整体连贯性；同时需严格区分\"冗余\"与\"必要重复\"，若原句重复成分用于强调关键对象（如\"call事件\"），应保留其功能性而非机械删除。"
    },
    {
      "defect_id": 450155,
      "sentence": "**非激活态**：在此状态下，卡片与普通卡片行为无异，遵循既有的卡片开发规范，卡片UI由卡片提供方widgetCard.ets中的内容所承载。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"## 基本概念\",\"6\":\"\",\"7\":\"场景动效类型互动卡片主要包含两个状态：激活态和非激活态。在卡片生命周期，例如卡片数据定时或定点刷新，或者用户点击等用户主动与卡片交互的场景下，可以触发卡片动效，卡片切换至激活态，卡片动效结束，切回非激活态。\",\"8\":\"\",\"9\":\"**非激活态**：在此状态下，卡片与普通卡片行为无异，遵循既有的卡片开发规范，卡片UI由卡片提供方widgetCard.ets中的内容所承载。\",\"10\":\"\",\"11\":\"**激活态**： 表示互动卡片动效渲染状态，在此状态下，卡片UI由卡片提供方所开发的[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)对应page页面完成渲染。详细可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"12\":\"\",\"13\":\"**图1** 互动卡片状态切换说明\",\"14\":\"\"}",
      "用户拒绝的修改": "**非激活态**：卡片行为与普通卡片相同，UI由widgetCard.ets承载。",
      "注意事项": "修复冗余表达时需保留关键技术术语（如“卡片提供方”）和上下文关联信息（如“遵循既有的卡片开发规范”），避免过度简化导致技术准确性缺失；优先删除重复性描述而非功能性说明。"
    },
    {
      "defect_id": 447411,
      "sentence": "用于标记用户场景开始，用户场景开始时调用此接口。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"## performanceMonitor.begin\",\"48\":\"\",\"49\":\"begin(scene: string, startInputType: ActionType, note?: string): void\",\"50\":\"\",\"51\":\"用于标记用户场景开始，用户场景开始时调用此接口。\",\"52\":\"\",\"53\":\"\",\"54\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"55\":\"\",\"56\":\"**参数：** \"}",
      "用户拒绝的修改": "标记用户场景开始。",
      "注意事项": "修复冗余表达时需严格区分重复信息是否承载独立功能（如用途说明与调用时机），技术文档中应优先保留关键操作条件和上下文完整性，避免过度简化导致语义缺失。"
    },
    {
      "defect_id": 449117,
      "sentence": "允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"2. 卡片能力增强\",\"13\":\"\",\"14\":\"    - 新增了动效的能力：ArkTS卡片开放了[属性动画](../reference/apis-arkui/arkui-ts/ts-animatorproperty.md)和[显式动画](../reference/apis-arkui/arkui-ts/ts-explicit-animation.md)的能力，使卡片的交互更加友好。\",\"15\":\"    - 新增了自定义绘制的能力：ArkTS卡片开放了[Canvas](../reference/apis-arkui/arkui-ts/ts-components-canvas-canvas.md)画布组件的能力，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。\",\"16\":\"    - 允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。\",\"17\":\"\",\"18\":\"## 实现原理\",\"19\":\"\",\"20\":\"- 卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。\",\"21\":\"\"}",
      "用户拒绝的修改": "允许卡片中运行逻辑代码：开放逻辑代码运行后，很多业务逻辑可以在卡片内部自闭环，拓宽了业务适用场景。",
      "注意事项": "修复冗余表达时需严格限定修改范围为明确重复的修饰词，避免删除上下文必要的术语重复（如\"卡片\"在上下文中作为核心主语需保持一致性），并优先验证改动是否影响原意或引入歧义。"
    },
    {
      "defect_id": 447413,
      "sentence": "用户场景备注信息。长度限制30个字符，可以空缺不填，填写后性能指标上报会携带备注信息，不填无影响。",
      "reference_sentence": "",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"59\":\"| -- | -- | -- | -- |\",\"60\":\"| scene | string | 是 | 用户场景id。无长度限制，推荐字母大写且用下划线连接，例如LAUNCHER_APP_LAUNCH_FROM_ICON。 |\",\"61\":\"| startInputType | [ActionType](#actiontype)| 是 | 用户场景触发模式。 |\",\"62\":\"| note | string| 否 | 用户场景备注信息。长度限制30个字符，可以空缺不填，填写后性能指标上报会携带备注信息，不填无影响。 |\",\"63\":\"\",\"64\":\"**示例：** \",\"65\":\"\",\"66\":\"用户点击图标启动应用场景动效开始点，由离手事件LAST_UP触发。\",\"67\":\"  ```ts\"}",
      "用户拒绝的修改": "用户场景备注信息。长度限制30个字符。",
      "注意事项": "在技术文档场景中应保留参数行为的关键影响说明（如\"填写后性能指标上报会携带备注信息\"），避免将操作指引类信息误判为冗余成分。修改时应通过上下文确认参数\"必填/非必填\"状态是否已明确标注。"
    },
    {
      "defect_id": 447410,
      "sentence": "用户场景触发源类型枚举。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"| FIRST_MOVE | 2 | 用户首次滑动事件触发。 |\",\"30\":\"\",\"31\":\"\",\"32\":\"## SourceType<sup>12+</sup>\",\"33\":\"\",\"34\":\"用户场景触发源类型枚举。\",\"35\":\"\",\"36\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"37\":\"\",\"38\":\"| 名称 | 值 | 说明 |\",\"39\":\"| -- | -- | -- |\"}",
      "用户拒绝的修改": "枚举用户场景触发源类型。",
      "注意事项": "修复时应优先保留技术文档特有的术语结构和名词性短语形式，避免将专业表述转换为动词主导结构，确保修改后的表达既简洁又符合领域规范。"
    },
    {
      "defect_id": 450226,
      "sentence": "调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口时，[overflowInfo](../reference/apis-form-kit/js-apis-app-form-formInfo.md#overflowinfo20)中描述的互动卡片动效渲染区域（矩形EFGH）需要满足：",
      "reference_sentence": "",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"因此，以A点为原点，向右为X轴正方向，向下为Y轴正方向，图5中E点的合法坐标可以是（-20，-20），EF边长合法值可以是200vp，EH边长合法值可以是200vp。\",\"59\":\"\",\"60\":\"互动卡片可以通过调用[formProvided.getFormRect](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formprovidergetformrect20)接口获取卡片尺寸和在窗口内的位置信息。卡片提供方以此计算动效申请范围，坐标计算时，以上图A点为（0,0）点，计算矩形EFGH对应参数，单位为vp。\",\"61\":\"\",\"62\":\"调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口时，[overflowInfo](../reference/apis-form-kit/js-apis-app-form-formInfo.md#overflowinfo20)中描述的互动卡片动效渲染区域（矩形EFGH）需要满足：\",\"63\":\"1. 完整包含了卡片（矩形ABCD）。\",\"64\":\"2. 不超过矩形IJKL（矩形IJKL完整包含矩形EFGH）。<!--Del-->仅三方应用生效，系统应用不作限制。<!--DelEnd-->\",\"65\":\"\",\"66\":\"具体可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"67\":\"\"}",
      "用户拒绝的修改": "调用[formProvider.requestOverflow]接口时，[overflowInfo]中的互动卡片动效渲染区域（矩形EFGH）需满足：",
      "注意事项": "在修复冗余表达时需优先保留技术文档的准确性，避免删除必要限定词（如\"中描述的\"可能用于强调参数来源）；结合上下文判断信息密度，仅删除真正冗余成分（如重复说明），保持技术细节的完整性。"
    },
    {
      "defect_id": 450232,
      "sentence": "其他触发方式，例如通过卡片定时定数据刷新机制触发动效，遵循先到先得原则。系统只处理第一个合法动效请求。其他请求返回失败，同时不做缓存。",
      "reference_sentence": "",
      "line_num": 75,
      "context": "{\"70\":\"2. 当设备热档位进入WARM时，不再响应非点击触发的动效请求，当热档位进入OVERHEATED时，不再响应所有动效请求。具体可参考[热档位信息](../reference/apis-basic-services-kit/js-apis-thermal.md#thermallevel)。\",\"71\":\"\",\"72\":\"### 动效请求约束\",\"73\":\"1. 同一时刻，全局只有一个卡片执行场景动效。\",\"74\":\"2. 当用户通过点击等方式主动触发互动卡片动效时，优先响应此次动效触发请求。此时，当前卡片切换到激活态，执行动效，其他卡片立即强制切换到非激活态。\",\"75\":\"3. 其他触发方式，例如通过卡片定时定数据刷新机制触发动效，遵循先到先得原则。系统只处理第一个合法动效请求。其他请求返回失败，同时不做缓存。\",\"76\":\"4. 用户在桌面的其他有效操作（点击应用、卡片等，滑动翻页，下拉进入全搜、双中心、拖动卡片、长按卡片等）均会打断当前动效，卡片重新变成非激活态。<!--Del-->系统应用可以通过禁用手势配置项方式禁用用户在桌面的某些操作，可参考[场景动效类型互动卡片开发指导（系统应用）](arkts-ui-liveform-sceneanimation-development-sys.md)。<!--DelEnd-->\",\"77\":\"5. 互动卡片执行动效期间，超过卡片自身渲染范围（对应图5中的矩形ABCD）的交互事件，互动卡片不做响应。\",\"78\":\"6. 更多场景动效类型互动卡片激活态能力约束，可参考[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)中说明。\"}",
      "用户拒绝的修改": "其他触发方式遵循先到先得原则。系统处理第一个合法动效请求，其他请求返回失败，不做缓存。",
      "注意事项": "修复冗余表达时应优先保留具有说明价值的具体示例，避免过度简化导致技术细节丢失；需仔细评估上下文关联性，确保删除的冗余信息不包含关键限定条件或应用场景说明。"
    },
    {
      "defect_id": 450555,
      "sentence": "表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。",
      "reference_sentence": "",
      "line_num": 55,
      "context": "{\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\"}",
      "用户拒绝的修改": "表示卡片的默认外观规格，取值必须在supportDimensions列表中。",
      "注意事项": "确保修改后的表述与上下文术语使用完全一致，避免删除必要的限定词（如\"该卡片\"）导致指代不清；优先采用文档已有参数名称（如\"supportDimensions\"），若需简化应保持与原始定义（条目54）的对应关系。"
    },
    {
      "defect_id": 450568,
      "sentence": "表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。",
      "reference_sentence": "",
      "line_num": 68,
      "context": "{\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\"}",
      "用户拒绝的修改": "表示卡片是否使用模糊背板。true表示开启，false表示关闭。",
      "注意事项": "修复时应严格检查上下文格式一致性，避免破坏已有结构；优先确认用户实际修改需求，确保调整范围仅限于当前问题点，不涉及历史遗留冗余。"
    },
    {
      "defect_id": 450561,
      "sentence": "表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。",
      "reference_sentence": "",
      "line_num": 61,
      "context": "{\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\"}",
      "用户拒绝的修改": "表示卡片是否支持代理刷新。true表示支持，定时刷新和下次刷新不生效，但不影响定点刷新。false表示不支持。",
      "注意事项": "修复时应严格保留原有技术参数和功能关联的MD链接，避免过度合并导致关键信息丢失；优先通过拆分长句而非删除技术细节来优化冗余，确保修改不破坏原有参数间的逻辑关联性。"
    },
    {
      "defect_id": 450556,
      "sentence": "表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。",
      "reference_sentence": "",
      "line_num": 56,
      "context": "{\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\"}",
      "用户拒绝的修改": "表示卡片是否支持周期性刷新。true表示支持，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）中任选其一，定时刷新优先。false表示不支持。",
      "注意事项": "修复冗余表达时需严格保留关键条件说明（如\"当两者同时配置时\"），避免过度简化导致技术细节丢失；同时保持与上下文参数说明的术语一致性（如\"优先生效\"与后文\"优先级高于\"的对应关系）。"
    },
    {
      "defect_id": 450564,
      "sentence": "表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。",
      "reference_sentence": "",
      "line_num": 64,
      "context": "{\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\"}",
      "用户拒绝的修改": "表示卡片的显示形状，取值范围：rect（矩形卡片）、circle（圆形卡片）。",
      "注意事项": "修复冗余表达时需保持上下文格式一致性，优先沿用文档现有列表结构（如\"-&nbsp;值：描述\"格式），避免因简化句式破坏整体排版规范；修改前应检查相邻条目格式特征，确保不引入非必要的差异化表达。"
    },
    {
      "defect_id": 450570,
      "sentence": "表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。",
      "reference_sentence": "",
      "line_num": 70,
      "context": "{\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"74\":\"\",\"75\":\"### isDynamic标签\"}",
      "用户拒绝的修改": "表示卡片的多定点刷新时刻，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多24个时间。需要配合scheduledUpdateTime使用。",
      "注意事项": "修复时需严格区分新增修改与已有内容，避免改动未被标注的上下文信息；保留原始说明结构，仅精简明确冗余部分，确保不删除必要技术细节。"
    },
    {
      "defect_id": 450557,
      "sentence": "表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。",
      "reference_sentence": "",
      "line_num": 57,
      "context": "{\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\"}",
      "用户拒绝的修改": "表示卡片的定点刷新时刻，采用24小时制，精确到分钟。updateDuration优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration为准。",
      "注意事项": "修复冗余表达时需先核对上下文是否存在重复说明，避免删除已在其他参数说明中明确过的通用规则；简化时应保留必要技术细节，确保参数优先级关系的表述完整性不被破坏。"
    },
    {
      "defect_id": 450566,
      "sentence": "表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。",
      "reference_sentence": "",
      "line_num": 66,
      "context": "{\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\"}",
      "用户拒绝的修改": "表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片）。true表示通知，false表示不通知。",
      "注意事项": "修复冗余表达时需优先保持上下文格式一致性，避免破坏已有列表结构（如\"- true/false\"分点说明），确保修改仅针对冗余内容而非原有规范格式。"
    },
    {
      "defect_id": 450563,
      "sentence": "表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\"}",
      "用户拒绝的修改": "表示卡片字体是否支持跟随系统变化。true表示支持，false表示不支持。",
      "注意事项": "修改前需严格核对上下文条目的一致性表达模式，优先保持术语准确性而非过度简化；确认冗余成分是否为文档统一规范或关键信息，避免破坏原有技术表述的完整性。"
    },
    {
      "defect_id": 450554,
      "sentence": "表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\*&nbsp;4：表示6行4列的二十四宫格。",
      "reference_sentence": "",
      "line_num": 54,
      "context": "{\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\"}",
      "用户拒绝的修改": "表示卡片支持的外观规格：1*2（二宫格）、2*2（四宫格）、2*4（八宫格）、4*4（十六宫格）、6*4（二十四宫格）。1*1（圆形卡片）仅支持系统应用配置，且仅在锁屏场景下生效。",
      "注意事项": "修复时应严格保留文档注释标记（如<!--Del-->）和已删除内容的结构完整性，避免误删有效注释；修改范围需精准限定在冗余表达本身，确保不改变原有功能说明的上下文关联性。"
    },
    {
      "defect_id": 450567,
      "sentence": "表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。",
      "reference_sentence": "",
      "line_num": 67,
      "context": "{\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\"}",
      "用户拒绝的修改": "表示是否支持设置卡片背景透明度（仅对系统应用的ArkTS卡片）。true表示支持，false表示不支持。",
      "注意事项": "修复冗余表达时应优先保持原有条目结构的一致性，避免删除必要分点格式；修改需严格限定在冗余成分（如重复修饰语、冗长从句），确保不破坏上下文统一模板。"
    },
    {
      "defect_id": 450235,
      "sentence": "更多场景动效类型互动卡片激活态能力约束，可参考[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)中说明。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"1. 同一时刻，全局只有一个卡片执行场景动效。\",\"74\":\"2. 当用户通过点击等方式主动触发互动卡片动效时，优先响应此次动效触发请求。此时，当前卡片切换到激活态，执行动效，其他卡片立即强制切换到非激活态。\",\"75\":\"3. 其他触发方式，例如通过卡片定时定数据刷新机制触发动效，遵循先到先得原则。系统只处理第一个合法动效请求。其他请求返回失败，同时不做缓存。\",\"76\":\"4. 用户在桌面的其他有效操作（点击应用、卡片等，滑动翻页，下拉进入全搜、双中心、拖动卡片、长按卡片等）均会打断当前动效，卡片重新变成非激活态。<!--Del-->系统应用可以通过禁用手势配置项方式禁用用户在桌面的某些操作，可参考[场景动效类型互动卡片开发指导（系统应用）](arkts-ui-liveform-sceneanimation-development-sys.md)。<!--DelEnd-->\",\"77\":\"5. 互动卡片执行动效期间，超过卡片自身渲染范围（对应图5中的矩形ABCD）的交互事件，互动卡片不做响应。\",\"78\":\"6. 更多场景动效类型互动卡片激活态能力约束，可参考[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)中说明。\"}",
      "用户拒绝的修改": "参考[LiveFormExtensionAbility]中的说明。",
      "注意事项": "保留必要限定词确保参考链接的上下文关联性，避免过度删减导致信息指向不明确；需结合上下文判断\"冗余\"是否为关键信息（如规则条目间的并列结构或补充说明性质的内容）。"
    },
    {
      "defect_id": 450569,
      "sentence": "表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\t",
      "reference_sentence": "",
      "line_num": 69,
      "context": "{\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"74\":\"\"}",
      "用户拒绝的修改": "表示卡片的渲染模式，取值范围：autoColor（自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示）、fullColor（全色模式，桌面卡片中心/卡片管理内可以显示）、singleColor（单色模式，锁屏卡片中心内可以显示）。",
      "注意事项": "修复时应严格核对问题上下文，避免修改与当前问题无关的冗余结构；优先保持同类参数项表述格式统一，若相邻参数项保留\"的卡片\"后缀，则不应单独删除当前项的同类表述。"
    },
    {
      "defect_id": 450565,
      "sentence": "表示卡片预览图, 与配置项`supportDimensions`一一对应。",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\"}",
      "用户拒绝的修改": "表示卡片预览图，与支持的外观规格一一对应。",
      "注意事项": "修复时应严格限定修改范围，仅处理当前反馈指出的冗余问题，避免变更原有技术术语或配置项名称；需结合上下文判断术语是否属于必要技术概念，优先保留文档中已明确定义的专有名词。"
    },
    {
      "defect_id": 450552,
      "sentence": "表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。",
      "reference_sentence": "",
      "line_num": 50,
      "context": "{\"45\":\"   | forms | 表示应用的全部卡片配置信息。<br/>最多支持配置16个卡片，若超过16个，则保留配置的前16个。 | 数组 | 否 |\",\"46\":\"   | name | 表示卡片的名称，字符串最大长度为127字节。 | 字符串 | 否 |\",\"47\":\"   | displayName | 表示卡片的展示名称。主要在卡片管理页面显示，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。 | 字符串 | 否 |\",\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\",\"52\":\"   | isDefault | 表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。<br/>-&nbsp;true：默认卡片。<br/>-&nbsp;false：非默认卡片。 | 布尔值 | 否 |\",\"53\":\"   | colorMode<sup>(deprecated)</sup> | 表示卡片的主题样式，取值范围如下：<br/>-&nbsp;auto：跟随系统的颜色模式值选取主题。<br/>-&nbsp;dark：深色主题。<br/>-&nbsp;light：浅色主题。<br/>**说明：**<br/>从API version 20开始，该接口废弃，卡片主题样式统一跟随系统的颜色模式。 | 字符串 | 可缺省，缺省值为“auto”。 |\",\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\"}",
      "用户拒绝的修改": "表示卡片的类型，支持两种类型：arkts（ArkTS卡片）和hml（JS卡片）。",
      "注意事项": "修复冗余表达时需严格识别上下文已有信息，避免删除未冗余的关键限定词（如“当前”在上下文中可能用于区分版本或时效性），并确保修改不破坏原有格式规范（如列表项解释方式）。"
    },
    {
      "defect_id": 450560,
      "sentence": "表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。",
      "reference_sentence": "",
      "line_num": 60,
      "context": "{\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\"}",
      "用户拒绝的修改": "表示卡片的自定义信息，参考Metadata数组标签。",
      "注意事项": "修复时应严格区分文档链接的必要性，避免移除技术文档中必需的参考路径；需结合上下文确认修改范围，不处理与当前问题无关的冗余判断。"
    },
    {
      "defect_id": 450559,
      "sentence": "表示卡片的配置跳转链接，采用URI格式。",
      "reference_sentence": "",
      "line_num": 59,
      "context": "{\"54\":\"   | supportDimensions | 表示卡片支持的外观规格，取值范围：<br/>-&nbsp;1&nbsp;\\\\*&nbsp;2：表示1行2列的二宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;2：表示2行2列的四宫格。<br/>-&nbsp;2&nbsp;\\\\*&nbsp;4：表示2行4列的八宫格。<br/>-&nbsp;4&nbsp;\\\\*&nbsp;4：表示4行4列的十六宫格。<!--Del--><br/>-&nbsp;1&nbsp;\\\\*&nbsp;1：表示1行1列的圆形卡片，仅支持系统应用配置，且仅在锁屏场景下配置生效。<!--DelEnd--> <br/>-&nbsp;6&nbsp;\\\\*&nbsp;4：表示6行4列的二十四宫格。 | 字符串数组 | 否 |\",\"55\":\"   | defaultDimension | 表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。 | 字符串 | 否 |\",\"56\":\"   | updateEnabled | 表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：<br/>-&nbsp;true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。<br/>-&nbsp;false：表示不支持周期性刷新。 | 布尔类型 | 否 |\",\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\"}",
      "用户拒绝的修改": "表示卡片的配置跳转链接，格式为URI。",
      "注意事项": "修复时应严格核对问题上下文，仅修改用户明确指出的冗余部分，避免改动其他未提及的规范描述；优先保持同类参数表述一致性（如\"采用URI格式\"与上下文\"采用24小时制\"的动词统一性）。"
    },
    {
      "defect_id": 450549,
      "sentence": "表示卡片的名称，字符串最大长度为127字节。",
      "reference_sentence": "",
      "line_num": 46,
      "context": "{\"41\":\"   **表1** 卡片form_config.json配置文件\",\"42\":\"\",\"43\":\"   | 属性名称 | 含义 | 数据类型 | 是否可缺省 |\",\"44\":\"   | -------- | -------- | -------- | -------- |\",\"45\":\"   | forms | 表示应用的全部卡片配置信息。<br/>最多支持配置16个卡片，若超过16个，则保留配置的前16个。 | 数组 | 否 |\",\"46\":\"   | name | 表示卡片的名称，字符串最大长度为127字节。 | 字符串 | 否 |\",\"47\":\"   | displayName | 表示卡片的展示名称。主要在卡片管理页面显示，用于展示卡片信息，建议能够体现卡片的核心功能或用途。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最小长度为1字节，最大长度为30字节。 | 字符串 | 否 |\",\"48\":\"   | description | 表示卡片的描述。用于在卡片管理页面展示卡片功能描述。支持字符串或字符串资源索引，建议使用字符串资源索引方式声明，以支持完整多语言能力。字符串最大长度为255字节。 | 字符串 | 可缺省，缺省为空。 |\",\"49\":\"   | src | 表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：\\\"./ets/widget/pages/WidgetCard.ets\\\"。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：\\\"./js/widget/pages/WidgetCard\\\" | 字符串 | 否 |\",\"50\":\"   | uiSyntax | 表示该卡片的类型，当前支持如下两种类型：<br/>-&nbsp;arkts：当前卡片为ArkTS卡片。<br/>-&nbsp;hml：当前卡片为JS卡片。 | 字符串 | 可缺省，缺省值为“hml”。 |\",\"51\":\"   | [window](#window标签) | 用于定义与显示窗口相关的配置。<br/>**说明：**<br/>该字段仅对JS卡片生效。 | 对象 | 可缺省，缺省值见表2。 |\"}",
      "用户拒绝的修改": "表示卡片的名称，字符串最大长度127字节。",
      "注意事项": "在修复冗余表达时需严格核对上下文格式一致性，优先保留技术文档的标准化表述习惯，避免因过度简化破坏已有术语规范或格式统一性。"
    },
    {
      "defect_id": 450562,
      "sentence": "表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。",
      "reference_sentence": "",
      "line_num": 62,
      "context": "{\"57\":\"   | scheduledUpdateTime | 表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 字符串 | 可缺省，缺省时不进行定点刷新。 |\",\"58\":\"   | updateDuration | 表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。<br/>当取值为0时，表示该参数不生效。<br/>当取值为正整数N时，表示刷新周期为30\\\\*N分钟。<br/>**说明：**<br/>updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。 | 数值 | 可缺省，缺省值为“0”。 |\",\"59\":\"   | formConfigAbility | 表示卡片的配置跳转链接，采用URI格式。| 字符串 | 可缺省，缺省值为空。 |\",\"60\":\"   | metadata | 表示卡片的自定义信息，参考[Metadata](../reference/apis-ability-kit/js-apis-bundleManager-metadata.md)数组标签。 | 对象 | 可缺省，缺省值为空。 |\",\"61\":\"   | <!--DelRow-->dataProxyEnabled | 表示卡片是否支持[卡片代理刷新](./arkts-ui-widget-update-by-proxy.md)，取值范围：<br/>-&nbsp;true：表示支持代理刷新。<br/>-&nbsp;false：表示不支持代理刷新。<br/>设置为true时，[定时刷新和下次刷新](./arkts-ui-widget-passive-refresh.md#卡片定时刷新)不生效，但不影响[定点刷新](./arkts-ui-widget-passive-refresh.md#卡片定点刷新)。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"62\":\"   | [isDynamic](#isdynamic标签) | 表示此卡片是否为动态卡片（仅针对ArkTS卡片生效）。 <br/>-&nbsp;true：为动态卡片 。<br/>-&nbsp;false：为静态卡片。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"63\":\"   | fontScaleFollowSystem | 表示卡片使用方设置此卡片的字体是否支持跟随系统变化。 <br/>-&nbsp;true：支持跟随系统字体大小变化 。<br/>-&nbsp;false：不支持跟随系统字体大小变化。<br/>| 布尔类型 | 可缺省，缺省值为true。 |\",\"64\":\"   | supportShapes | 表示卡片的显示形状，取值范围如下：<br/>-&nbsp;rect：表示矩形卡片。<br/>-&nbsp;circle：表示圆形卡片。| 字符串数组 | 可缺省，缺省值为“rect”。 |\",\"65\":\"   | previewImages | 表示卡片预览图, 与配置项`supportDimensions`一一对应。| 字符串 | 可缺省，智能穿戴卡片必须配置，当前仅支持在智能穿戴上使用。 |\",\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\"}",
      "用户拒绝的修改": "表示卡片是否为动态卡片（仅针对ArkTS卡片）。true表示动态卡片，false表示静态卡片。",
      "注意事项": "修改冗余表达时需优先检查上下文格式一致性，确保不破坏原有条目结构；避免对已存在的标准表述模式（如分项列表）进行不必要的句式转换。"
    },
    {
      "defect_id": 450571,
      "sentence": "表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"   | <!--DelRow-->formVisibleNotify | 表示是否通知卡片提供方可见状态变化（仅对系统应用的卡片生效）。<br/>-&nbsp;true：通知卡片提供方可见状态变化。<br/>-&nbsp;false：不通知卡片提供方可见状态变化。 | 布尔类型 | 可缺省，缺省值为false。 |\",\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"74\":\"\",\"75\":\"### isDynamic标签\",\"76\":\"\"}",
      "用户拒绝的修改": "表示卡片的条件刷新（仅对系统应用的ArkTS卡片）。取值范围：network（支持网络刷新）。",
      "注意事项": "修复时应确保不删除括号内必要限定条件（如\"生效\"），并保持参数说明与上下文格式统一，避免因过度简化导致关键信息丢失。"
    },
    {
      "defect_id": 452174,
      "sentence": "Some internal server error occurs.",
      "reference_sentence": "",
      "line_num": 230,
      "context": "{\"225\":\"\",\"226\":\"## 2293761 内部服务错误\",\"227\":\"\",\"228\":\"**错误信息**\",\"229\":\"\",\"230\":\"Some internal server error occurs.\",\"231\":\"\",\"232\":\"**错误描述**\",\"233\":\"\",\"234\":\"系统执行当前请求时发生内部错误。\",\"235\":\"\"}",
      "用户拒绝的修改": "内部服务器错误。",
      "注意事项": "修复前必须确认问题句子是否属于用户当前修改范围，避免误改历史内容；优先核对上下文版本差异，确保冗余表达修复不涉及未变更的既有表述。"
    },
    {
      "defect_id": 450573,
      "sentence": "场景动效类型互动卡片扩展字段。",
      "reference_sentence": "",
      "line_num": 73,
      "context": "{\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"74\":\"\",\"75\":\"### isDynamic标签\",\"76\":\"\",\"77\":\"此标签标识卡片是否为动态卡片（仅针对ArkTS卡片生效）。\",\"78\":\"\"}",
      "用户拒绝的修改": "表示场景动效类型互动卡片的扩展字段。",
      "注意事项": "修复冗余表达前需确认上下文格式一致性，优先保持同类条目结构统一；修改时应严格区分历史遗留问题和本次新增问题，避免对已存在的规范表述进行不必要调整。"
    },
    {
      "defect_id": 452738,
      "sentence": "LiveFormExtensionAbility界面内容对象创建后调用。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"### onLiveFormCreate\",\"34\":\"\",\"35\":\"onLiveFormCreate(liveFormInfo: LiveFormInfo, session: UIExtensionContentSession): void\",\"36\":\"\",\"37\":\"LiveFormExtensionAbility界面内容对象创建后调用。\",\"38\":\"\",\"39\":\"**模型约束：** 此接口仅可在Stage模型下使用。\",\"40\":\"\",\"41\":\"**系统能力**：SystemCapability.Ability.Form\",\"42\":\"\"}",
      "用户拒绝的修改": "创建LiveFormExtensionAbility界面内容对象后调用。",
      "注意事项": "修复时应严格限定修改范围为用户明确指出的冗余问题，避免对原句进行无关的结构调整；优先确认修改后的表达是否在上下文语境中具备实质性的简洁性提升，而非单纯变换句式。"
    },
    {
      "defect_id": 452172,
      "sentence": "卡片不支持调用当前接口，系统会报此错误码。",
      "reference_sentence": "",
      "line_num": 216,
      "context": "{\"211\":\"\",\"212\":\"The form can not support this operation.\",\"213\":\"\",\"214\":\"**错误描述**\",\"215\":\"\",\"216\":\"卡片不支持调用当前接口，系统会报此错误码。\",\"217\":\"\",\"218\":\"**可能原因**\",\"219\":\"\",\"220\":\"普通卡片发起互动卡片动效请求，或者当前互动卡片配置错误。\",\"221\":\"\"}",
      "用户拒绝的修改": "卡片不支持调用当前接口，系统报错。",
      "注意事项": "修复冗余时必须严格保留原句的技术术语（如“错误码”）并检查上下文关联性，避免因过度简化导致信息丢失或与已有文档冲突。"
    },
    {
      "defect_id": 450572,
      "sentence": "趣味交互类型互动卡片扩展字段。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"   | <!--DelRow-->transparencyEnabled | 表示是否支持卡片使用方设置此卡片的背景透明度（仅对系统应用的ArkTS卡片生效）。 <br/>-&nbsp;true：支持设置背景透明度 。<br/>-&nbsp;false：不支持设置背景透明度。<br/>| 布尔类型 | 可缺省，缺省值为false。 |\",\"68\":\"   |enableBlurBackground|表示卡片是否使用模糊背板。<br/>-&nbsp;true：开启模糊背板。<br/>-&nbsp;false：关闭模糊背板。|布尔类型|可缺省，缺省值为false。|\",\"69\":\"   |renderingMode|表示卡片的渲染模式，取值范围如下：<br/>-&nbsp;autoColor：自动模式，锁屏卡片中心与桌面卡片中心/卡片管理内都可以显示的卡片。<br/>-&nbsp;fullColor：全色模式，桌面卡片中心/卡片管理内可以显示的卡片。<br/>-&nbsp;singleColor：单色模式，锁屏卡片中心内可以显示的卡片。\\t|字符串|可缺省，缺省值为“fullColor”。|\",\"70\":\"   |multiScheduledUpdateTime|表示卡片的多定点刷新的时刻，作为单点刷新的一个附加参数，采用24小时制，精确到分钟，多个时间用英文逗号分隔，最多写24个时间。<br/>**说明：**<br/>multiScheduledUpdateTime需要配合scheduledUpdateTime使用。|字符串|可缺省，缺省时不进行多定点刷新。|\",\"71\":\"   |conditionUpdate|表示卡片的支持的条件刷新（仅对系统应用的ArkTS卡片生效）。取值范围如下：<br/>-&nbsp;network：表示支持网络刷新。|字符串|可缺省，缺省值为空字符串。|\",\"72\":\"   |[funInteractionParams](#funinteractionparams标签)| 趣味交互类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"73\":\"   |[sceneAnimationParams](#sceneanimationparams标签)| 场景动效类型互动卡片扩展字段。| 对象 | 可缺省，缺省为空。funInteractionParams 和 sceneAnimationParams 同时配置时识别为趣味交互类型互动卡片。|\",\"74\":\"\",\"75\":\"### isDynamic标签\",\"76\":\"\",\"77\":\"此标签标识卡片是否为动态卡片（仅针对ArkTS卡片生效）。\"}",
      "用户拒绝的修改": "表示趣味交互类型互动卡片的扩展字段。",
      "注意事项": "修复时应严格遵循上下文条目结构一致性，避免添加其他字段未使用的冗余修饰词（如“表示”），并确认修改内容属于当前问题范围，不涉及无关历史条目。"
    },
    {
      "defect_id": 452159,
      "sentence": "当调用接口传入的入参过大时，进程间通信对数据校验失败。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"系统内为执行当前请求进行必要进程间通信时出错，系统会报此错误码。\",\"16\":\"\",\"17\":\"**可能原因**\",\"18\":\"\",\"19\":\"当调用接口传入的入参过大时，进程间通信对数据校验失败。\",\"20\":\"\",\"21\":\"**处理步骤**\",\"22\":\"\",\"23\":\"确认入参是否过长。\",\"24\":\"\"}",
      "用户拒绝的修改": "入参过大导致进程间通信数据校验失败。",
      "注意事项": "修复冗余表达时需严格保持原句核心因果/条件逻辑关系，避免因句式结构调整引入新的语义偏差，同时应核对上下文确保修改部分与相邻条目表述风格一致。"
    },
    {
      "defect_id": 452873,
      "sentence": "**系统能力：** SystemCapability.Ability.Form",
      "reference_sentence": "",
      "line_num": 294,
      "context": "{\"289\":\"\",\"290\":\"获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。\",\"291\":\"\",\"292\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"293\":\"\",\"294\":\"**系统能力：** SystemCapability.Ability.Form\",\"295\":\"\",\"296\":\"**参数：**\",\"297\":\"\",\"298\":\"| 参数名 | 类型    | 必填 | 说明    |\",\"299\":\"| ------ | ------ | ---- | ------- |\"}",
      "用户拒绝的修改": "该接口支持在原子化服务中使用。",
      "注意事项": "修复冗余表达时必须严格核对上下文是否已存在相同信息，避免重复添加；修改范围应精准限定在问题句子本身，不得改动其他正确且无关的上下文内容。"
    },
    {
      "defect_id": 452179,
      "sentence": "接口调用时存在无效入参。",
      "reference_sentence": "",
      "line_num": 272,
      "context": "{\"267\":\"\",\"268\":\"Invalid params received on operating form.\",\"269\":\"\",\"270\":\"**错误描述**\",\"271\":\"\",\"272\":\"接口调用时存在无效入参。\",\"273\":\"\",\"274\":\"**可能原因**\",\"275\":\"\",\"276\":\"1. 未传入必选参数。\",\"277\":\"2. 参数类型错误。\"}",
      "用户拒绝的修改": "接口调用时存在无效参数。",
      "注意事项": "修复冗余表达时必须优先检查上下文术语一致性（如技术文档中的\"入参\"是规范术语），并确认修改内容未超出当前问题范围（避免改动历史遗留表述）。"
    },
    {
      "defect_id": 452870,
      "sentence": "getFormsInfo(filter: formInfo.FormInfoFilter, callback: AsyncCallback<Array<formInfo.FormInfo>>): void",
      "reference_sentence": "",
      "line_num": 288,
      "context": "{\"283\":\"  console.error(`catch error, code: ${(error as BusinessError).code}, message: ${(error as BusinessError).message})`);\",\"284\":\"}\",\"285\":\"```\",\"286\":\"## formProvider.getFormsInfo\",\"287\":\"\",\"288\":\"getFormsInfo(filter: formInfo.FormInfoFilter, callback: AsyncCallback&lt;Array&lt;formInfo.FormInfo&gt;&gt;): void\",\"289\":\"\",\"290\":\"获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。\",\"291\":\"\",\"292\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"293\":\"\"}",
      "用户拒绝的修改": "getFormsInfo(filter, callback): void",
      "注意事项": "在修复冗余表达时必须严格区分文档规范与代码规范，类型声明在API接口定义中属于必要技术要素而非冗余内容，应保留参数类型信息确保接口契约的完整性，避免将代码语法优化与文档简洁性要求混淆。"
    },
    {
      "defect_id": 452864,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 187,
      "context": "{\"182\":\"\",\"183\":\"updateForm(formId: string, formBindingData: formBindingData.FormBindingData): Promise&lt;void&gt;\",\"184\":\"\",\"185\":\"更新指定的卡片，使用Promise异步回调。\",\"186\":\"\",\"187\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"188\":\"\",\"189\":\"**系统能力：** SystemCapability.Ability.Form\",\"190\":\"\",\"191\":\"**参数：**\",\"192\":\"\"}",
      "用户拒绝的修改": "该接口从API version 11开始支持在原子化服务中使用。",
      "注意事项": "确保修改仅针对明确的冗余成分，避免调整已符合技术文档规范的语序结构；在调整句式时需保持原句核心信息（如API版本号）的位置不变，避免改变原有技术说明的上下文关联性。"
    },
    {
      "defect_id": 452168,
      "sentence": "指定的卡片非当前应用所有。",
      "reference_sentence": "",
      "line_num": 127,
      "context": "{\"122\":\"\",\"123\":\"当前应用无法对指定卡片进行操作时，系统会报此错误码。\",\"124\":\"\",\"125\":\"**可能原因**\",\"126\":\"\",\"127\":\"指定的卡片非当前应用所有。\",\"128\":\"\",\"129\":\"**处理步骤**\",\"130\":\"\",\"131\":\"1. 检查传入卡片ID所有权。\",\"132\":\"2. 升级权限为SystemApp。\"}",
      "用户拒绝的修改": "卡片不属于当前应用。",
      "注意事项": "在修复冗余表达时，需保留原文关键限定词（如\"指定\"），避免因过度简化丢失上下文关联性；同时应验证修改内容是否与问题上下文中的术语（如\"指定卡片\"）及逻辑链一致，确保不破坏原有技术描述的准确性。"
    },
    {
      "defect_id": 452858,
      "sentence": "The ID of the form to be operated does not exist.",
      "reference_sentence": "",
      "line_num": 153,
      "context": "{\"148\":\"| 401 | Parameter error. Possible causes: 1.Mandatory parameters are left unspecified; 2.Incorrect parameter types; 3.Parameter verification failed. |\",\"149\":\"| 16500050 | IPC connection error. |\",\"150\":\"| 16500060 | Service connection error. |\",\"151\":\"| 16500100 | Failed to obtain the configuration information. |\",\"152\":\"| 16501000 | An internal functional error occurred. |\",\"153\":\"| 16501001 | The ID of the form to be operated does not exist. |\",\"154\":\"| 16501003 | The form cannot be operated by the current application. |\",\"155\":\"\",\"156\":\"**示例：**\",\"157\":\"\",\"158\":\"```ts\"}",
      "用户拒绝的修改": "操作的卡片ID不存在。",
      "注意事项": "修复冗余表达时应保持原有术语准确性，避免在简化修饰成分时误改已存在的正确翻译（如\"form\"不应改为\"卡片\"），需严格区分冗余修饰与专业术语的边界。"
    },
    {
      "defect_id": 452871,
      "sentence": "获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 290,
      "context": "{\"285\":\"```\",\"286\":\"## formProvider.getFormsInfo\",\"287\":\"\",\"288\":\"getFormsInfo(filter: formInfo.FormInfoFilter, callback: AsyncCallback&lt;Array&lt;formInfo.FormInfo&gt;&gt;): void\",\"289\":\"\",\"290\":\"获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。\",\"291\":\"\",\"292\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"293\":\"\",\"294\":\"**系统能力：** SystemCapability.Ability.Form\",\"295\":\"\"}",
      "用户拒绝的修改": "获取并筛选设备上当前应用程序的卡片信息，使用callback异步回调。",
      "注意事项": "在修复冗余表达前必须确认问题是否属于当前修改范围，优先核对上下文版本号和变更历史，避免修改未被用户明确指出的历史内容。"
    },
    {
      "defect_id": 452872,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 292,
      "context": "{\"287\":\"\",\"288\":\"getFormsInfo(filter: formInfo.FormInfoFilter, callback: AsyncCallback&lt;Array&lt;formInfo.FormInfo&gt;&gt;): void\",\"289\":\"\",\"290\":\"获取设备上当前应用程序的卡片信息，并筛选符合条件的信息，使用callback异步回调。\",\"291\":\"\",\"292\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"293\":\"\",\"294\":\"**系统能力：** SystemCapability.Ability.Form\",\"295\":\"\",\"296\":\"**参数：**\",\"297\":\"\"}",
      "用户拒绝的修改": "该接口支持在原子化服务中使用。",
      "注意事项": "修复冗余表达时必须先确认版本信息是否为必要上下文（如兼容性说明或历史变更记录），并严格区分本次修改范围与已有内容，避免误删非冗余的技术约束条件。"
    },
    {
      "defect_id": 452853,
      "sentence": "The ID of the form to be operated does not exist.",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"| 401 | Parameter error. Possible causes: 1.Mandatory parameters are left unspecified; 2.Incorrect parameter types; 3.Parameter verification failed. |\",\"98\":\"| 16500050 | IPC connection error. |\",\"99\":\"| 16500060 | Service connection error. |\",\"100\":\"| 16500100 | Failed to obtain the configuration information. |\",\"101\":\"| 16501000 | An internal functional error occurred. |\",\"102\":\"| 16501001 | The ID of the form to be operated does not exist. |\",\"103\":\"| 16501002 | The number of forms exceeds the maximum allowed. |\",\"104\":\"| 16501003 | The form cannot be operated by the current application. |\",\"105\":\"\",\"106\":\"**示例：**\",\"107\":\"\"}",
      "用户拒绝的修改": "操作的卡片ID不存在。",
      "注意事项": "修复前必须确认问题是否属于当前修改范围，并严格检查上下文术语一致性（如\"form\"应统一译为\"表单\"而非\"卡片\"），避免因术语错位或历史问题误判导致无效修改。"
    },
    {
      "defect_id": 452832,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"| minute | number | 是   | 指定卡片多久之后更新，取值范围：大于等于5，单位：min。     |\",\"31\":\"| callback | AsyncCallback&lt;void&gt; | 是 | 回调函数。 |\",\"32\":\"\",\"33\":\"**错误码：**\",\"34\":\"\",\"35\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"36\":\"\",\"37\":\"| 错误码ID | 错误信息 |\",\"38\":\"| -------- | -------- |\",\"39\":\"| 401 | Parameter error. Possible causes: 1.Mandatory parameters are left unspecified; 2.Incorrect parameter types; 3.Parameter verification failed. |\",\"40\":\"| 16500050 | IPC connection error. |\"}",
      "用户拒绝的修改": "错误码详情请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。",
      "注意事项": "修改前需确认上下文是否存在关联依赖，避免修改未被明确指出的历史内容；精简时应保留必要说明性词汇（如\"详细介绍\"），防止信息完整度降低。"
    },
    {
      "defect_id": 452875,
      "sentence": "getFormsInfo(filter?: formInfo.FormInfoFilter): Promise<Array<formInfo.FormInfo>>",
      "reference_sentence": "",
      "line_num": 339,
      "context": "{\"334\":\"}\",\"335\":\"```\",\"336\":\"\",\"337\":\"## formProvider.getFormsInfo\",\"338\":\"\",\"339\":\"getFormsInfo(filter?: formInfo.FormInfoFilter): Promise&lt;Array&lt;formInfo.FormInfo&gt;&gt;\",\"340\":\"\",\"341\":\"获取设备上当前应用程序的卡片信息，使用Promise异步回调。\",\"342\":\"\",\"343\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"344\":\"\"}",
      "用户拒绝的修改": "getFormsInfo(filter?): Promise<Array<formInfo.FormInfo>>",
      "注意事项": "在修复冗余表达时需严格区分必要类型声明与冗余信息，保留接口定义中影响开发者理解的关键类型标注（如参数类型和泛型结构），避免因过度简化破坏API文档的技术准确性。"
    },
    {
      "defect_id": 452831,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"setFormNextRefreshTime(formId: string, minute: number, callback: AsyncCallback&lt;void&gt;): void\",\"18\":\"\",\"19\":\"设置指定卡片的下一次更新时间，使用callback异步回调。\",\"20\":\"\",\"21\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"22\":\"\",\"23\":\"**系统能力：** SystemCapability.Ability.Form\",\"24\":\"\",\"25\":\"**参数：**\",\"26\":\"\"}",
      "用户拒绝的修改": "该接口从API version 11开始支持原子化服务。",
      "注意事项": "修复时应优先保留技术文档中版本变更的核心信息（如API version 11新增特性），避免因语序调整导致\"支持时间范围\"产生歧义；冗余优化需在确保不改变技术事实的前提下进行，可通过拆分句式而非删减关键修饰语实现（例：\"该接口自API version 11起支持原子化服务\"）。"
    },
    {
      "defect_id": 452878,
      "sentence": "**系统能力：** SystemCapability.Ability.Form",
      "reference_sentence": "",
      "line_num": 345,
      "context": "{\"340\":\"\",\"341\":\"获取设备上当前应用程序的卡片信息，使用Promise异步回调。\",\"342\":\"\",\"343\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"344\":\"\",\"345\":\"**系统能力：** SystemCapability.Ability.Form\",\"346\":\"\",\"347\":\"**参数：**\",\"348\":\"\",\"349\":\"| 参数名 | 类型    | 必填 | 说明    |\",\"350\":\"| ------ | ------ | ---- | ------- |\"}",
      "用户拒绝的修改": "该接口支持在原子化服务中使用。",
      "注意事项": "修复冗余表达时必须严格核对上下文，确保修改内容与当前版本变更直接相关，避免引入历史版本已存在的非新增信息；删除系统能力等声明性内容时需确认目标用户群体是否需要该技术参数作为必要开发依据。"
    },
    {
      "defect_id": 452877,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 343,
      "context": "{\"338\":\"\",\"339\":\"getFormsInfo(filter?: formInfo.FormInfoFilter): Promise&lt;Array&lt;formInfo.FormInfo&gt;&gt;\",\"340\":\"\",\"341\":\"获取设备上当前应用程序的卡片信息，使用Promise异步回调。\",\"342\":\"\",\"343\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"344\":\"\",\"345\":\"**系统能力：** SystemCapability.Ability.Form\",\"346\":\"\",\"347\":\"**参数：**\",\"348\":\"\"}",
      "用户拒绝的修改": "该接口支持在原子化服务中使用。",
      "注意事项": "在修复冗余表达时需严格区分必要技术细节（如API版本号）与冗余信息，避免删除关键上下文；修改前应交叉验证问题上下文和用户意图，确保变更范围精准对应反馈内容。"
    },
    {
      "defect_id": 452739,
      "sentence": "LiveFormExtensionAbility生命周期回调，在销毁时回调，执行资源清理等操作。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"### onLiveFormDestroy\",\"68\":\"\",\"69\":\"onLiveFormDestroy(liveFormInfo: LiveFormInfo): void\",\"70\":\"\",\"71\":\"LiveFormExtensionAbility生命周期回调，在销毁时回调，执行资源清理等操作。\",\"72\":\"\",\"73\":\"**模型约束：** 此接口仅可在Stage模型下使用。\",\"74\":\"\",\"75\":\"**系统能力**：SystemCapability.Ability.Form\",\"76\":\"\"}",
      "用户拒绝的修改": "在销毁时回调，执行资源清理操作。",
      "注意事项": "修复时应确保仅删除真正冗余的重复信息（如\"生命周期回调\"与\"在销毁时回调\"的语义重复），保留必要上下文术语（如\"LiveFormExtensionAbility\"），避免破坏文档结构统一性和技术概念完整性。"
    },
    {
      "defect_id": 452866,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 247,
      "context": "{\"242\":\"\",\"243\":\"getFormsInfo(callback: AsyncCallback&lt;Array&lt;formInfo.FormInfo&gt;&gt;): void\",\"244\":\"\",\"245\":\"获取设备上当前应用程序的卡片信息，使用callback异步回调。\",\"246\":\"\",\"247\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"248\":\"\",\"249\":\"**系统能力：** SystemCapability.Ability.Form\",\"250\":\"\",\"251\":\"**参数：**\",\"252\":\"\"}",
      "用户拒绝的修改": "该接口从API version 11开始支持在原子化服务中使用。",
      "注意事项": "修复冗余表达时应优先识别并删除真正冗余的修饰成分（如重复的功能描述），而非仅调整语序；需严格校验修改内容是否属于当前版本变更范围，避免改动历史版本声明等非冗余信息。"
    },
    {
      "defect_id": 452879,
      "sentence": "卡片信息过滤器, 默认为空，不进行过滤。",
      "reference_sentence": "",
      "line_num": 351,
      "context": "{\"346\":\"\",\"347\":\"**参数：**\",\"348\":\"\",\"349\":\"| 参数名 | 类型    | 必填 | 说明    |\",\"350\":\"| ------ | ------ | ---- | ------- |\",\"351\":\"| filter | [formInfo.FormInfoFilter](js-apis-app-form-formInfo.md#forminfofilter) | 否 | 卡片信息过滤器, 默认为空，不进行过滤。 |\",\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\",\"355\":\"| 类型          | 说明                                |\",\"356\":\"| :------------ | :---------------------------------- |\"}",
      "用户拒绝的修改": "卡片信息过滤器。",
      "注意事项": "修复冗余表达时需严格确认修改范围是否属于当前需求，并优先保留技术文档中必要的默认值说明，避免因过度简化导致关键信息缺失。"
    },
    {
      "defect_id": 452876,
      "sentence": "获取设备上当前应用程序的卡片信息，使用Promise异步回调。",
      "reference_sentence": "",
      "line_num": 341,
      "context": "{\"336\":\"\",\"337\":\"## formProvider.getFormsInfo\",\"338\":\"\",\"339\":\"getFormsInfo(filter?: formInfo.FormInfoFilter): Promise&lt;Array&lt;formInfo.FormInfo&gt;&gt;\",\"340\":\"\",\"341\":\"获取设备上当前应用程序的卡片信息，使用Promise异步回调。\",\"342\":\"\",\"343\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"344\":\"\",\"345\":\"**系统能力：** SystemCapability.Ability.Form\",\"346\":\"\"}",
      "用户拒绝的修改": "获取设备上当前应用程序的卡片信息，使用Promise回调。",
      "注意事项": "在修改技术文档时需优先确认术语规范性，若\"Promise回调\"在上下文中已明确包含异步特性，应保留原文表述；同时需核对API文档的术语使用惯例，避免因过度简化破坏与其他部分的术语一致性。"
    },
    {
      "defect_id": 452874,
      "sentence": "返回查询到符合条件的卡片信息。",
      "reference_sentence": "",
      "line_num": 301,
      "context": "{\"296\":\"**参数：**\",\"297\":\"\",\"298\":\"| 参数名 | 类型    | 必填 | 说明    |\",\"299\":\"| ------ | ------ | ---- | ------- |\",\"300\":\"| filter | [formInfo.FormInfoFilter](js-apis-app-form-formInfo.md#forminfofilter) | 是 | 卡片信息过滤器。 |\",\"301\":\"| callback | AsyncCallback&lt;Array&lt;[formInfo.FormInfo](js-apis-app-form-formInfo.md)&gt;&gt; | 是 | 回调函数。返回查询到符合条件的卡片信息。 |\",\"302\":\"\",\"303\":\"**错误码：**\",\"304\":\"\",\"305\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"306\":\"\"}",
      "用户拒绝的修改": "返回符合条件的卡片信息。",
      "注意事项": "修复冗余表达时必须严格验证技术术语的准确性，避免误删关键操作动词（如“查询”）；同时需确认修改范围仅限当前问题点，避免引入无关的历史上下文干扰。"
    },
    {
      "defect_id": 452880,
      "sentence": "Promise对象。返回查询到符合条件的卡片信息。",
      "reference_sentence": "",
      "line_num": 357,
      "context": "{\"352\":\"\",\"353\":\"**返回值：**\",\"354\":\"\",\"355\":\"| 类型          | 说明                                |\",\"356\":\"| :------------ | :---------------------------------- |\",\"357\":\"| Promise&lt;Array&lt;[formInfo.FormInfo](js-apis-app-form-formInfo.md)&gt;&gt; | Promise对象。返回查询到符合条件的卡片信息。 |\",\"358\":\"\",\"359\":\"**错误码：**\",\"360\":\"\",\"361\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"362\":\"\"}",
      "用户拒绝的修改": "返回符合条件的卡片信息。",
      "注意事项": "在修复冗余表达时需严格核对上下文结构，确保不误删与类型声明形成必要补充的说明内容；优先处理用户明确指出的当前问题范围，避免引入无关的历史冗余修正。"
    },
    {
      "defect_id": 453035,
      "sentence": "卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "{\"19\":\"**系统能力：** SystemCapability.Ability.Form\",\"20\":\"\",\"21\":\"| 名称        | 类型                 | 可读    | 可写    | 说明                                                         |\",\"22\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片所属模块的名称。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需严格检查上下文中的同类表述，确保修改后的句式结构与相邻条目保持格式统一；优先处理用户明确指出的冗余问题，避免擅自修改其他未被提及但存在类似模式的表述。"
    },
    {
      "defect_id": 453049,
      "sentence": "卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 38,
      "context": "{\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片配置ability。指定长按卡片弹出的选择框内编辑选项对应的ability。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时应严格区分内容属性，保持模板化语句的格式统一，避免修改与当前问题无关的标准化描述（如重复出现的API版本声明），确保修改范围仅限目标冗余部分。"
    },
    {
      "defect_id": 453042,
      "sentence": "卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片类型。支持JS卡片和ArkTS卡片。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复时应严格识别上下文中的重复模式，避免将文档规范中统一使用的标准描述误判为冗余；修改时需确保仅处理当前问题句子的特定冗余表达，不合并或删除跨条目的重复性规范说明。"
    },
    {
      "defect_id": 453043,
      "sentence": "js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 32,
      "context": "{\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "JS卡片的组件名。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时应严格区分重复性模板内容与当前修改对象，避免修改统一格式的重复性说明；需保持上下文格式一致性，仅针对用户标注的具体冗余部分进行简化。"
    },
    {
      "defect_id": 453050,
      "sentence": "卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片更新周期。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时应保持上下文一致性，避免修改其他条目中重复但未被请求的相同表述，确保改动范围仅限于当前问题句子且不破坏文档格式的统一性。"
    },
    {
      "defect_id": 453033,
      "sentence": "formInfo模块提供了卡片信息和状态等相关类型和枚举。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.app.form.formInfo (formInfo)\",\"2\":\"\",\"3\":\"formInfo模块提供了卡片信息和状态等相关类型和枚举。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\"\"}",
      "用户拒绝的修改": "formInfo模块提供卡片信息和状态类型及枚举。",
      "注意事项": "修复前需确认问题是否属于当前修改范围，优先处理用户明确指出的新增问题，避免修改历史遗留冗余内容；需结合上下文判断修改必要性，确保改动符合用户当前版本迭代的上下文意图。"
    },
    {
      "defect_id": 453034,
      "sentence": "卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"**系统能力：** SystemCapability.Ability.Form\",\"20\":\"\",\"21\":\"| 名称        | 类型                 | 可读    | 可写    | 说明                                                         |\",\"22\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片所属包的Bundle名称。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "保留原始文档的格式标记（如**原子化服务API：**）并确保修改仅针对冗余表述，避免破坏文档结构或影响其他规范要求的注释内容。"
    },
    {
      "defect_id": 453048,
      "sentence": "卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片更新时间。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复时应首先识别重复出现的标准化注释模板（如\"**原子化服务API：**\"），避免修改统一的结构性内容；在简化冗余表达前需检查上下文是否存在批量重复模式，确保修改不破坏文档的格式一致性。"
    },
    {
      "defect_id": 453039,
      "sentence": "卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片预览时标识卡片名称的ID。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需优先识别上下文中的重复模板（如统一API声明格式），避免合并标准化的固定表述；修改应严格限定在用户指定的问题句段，保留未标记部分的原始结构。"
    },
    {
      "defect_id": 453054,
      "sentence": "卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\",\"48\":\"\"}",
      "用户拒绝的修改": "卡片是否为动态卡片。仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时应确保不破坏原有API说明的标准化格式，优先保持与上下文参数说明结构的一致性（如保留**原子化服务API**的固定标识），避免因简化导致关键信息模块缺失或格式错位。"
    },
    {
      "defect_id": 453038,
      "sentence": "卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 27,
      "context": "{\"22\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片展示名称。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "在简化冗余表达时需保留重复性标准注释的完整结构，避免破坏文档统一性；修改前需确认上下文是否存在批量重复内容，优先保持同类注释的格式一致性而非单独优化单一条目。"
    },
    {
      "defect_id": 453052,
      "sentence": "卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "{\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\"}",
      "用户拒绝的修改": "卡片支持的规格。参考[FormDimension](#formdimension)。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "在修复冗余表达时需严格保持技术文档模板的固定句式结构，避免删除重复性模板内容（如\"**原子化服务API：**\"固定前缀），应仅针对非模板部分的冗余信息进行简化。"
    },
    {
      "defect_id": 452888,
      "sentence": "Capability not supported.function cancelOverflow can not work correctly due to limited device capabilities.",
      "reference_sentence": "",
      "line_num": 694,
      "context": "{\"689\":\"\",\"690\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"691\":\"\",\"692\":\"| 错误码ID | 错误信息 |\",\"693\":\"| -------- | -------- |\",\"694\":\"| 801 | Capability not supported.function cancelOverflow can not work correctly due to limited device capabilities. |\",\"695\":\"| 16500050 | IPC connection error. |\",\"696\":\"| 16500060 | Service connection error. |\",\"697\":\"| 16500100 | Failed to obtain the configuration information. |\",\"698\":\"| 16501000 | An internal functional error occurred. |\",\"699\":\"| 16501001 | The ID of the form to be operated does not exist. |\"}",
      "用户拒绝的修改": "设备能力不足。无法正确执行cancelOverflow功能。",
      "注意事项": "修复前必须验证问题句子的历史版本和上下文一致性，优先保留原有技术术语和项目特定表达方式，避免对非目标冗余内容进行过度修改。"
    },
    {
      "defect_id": 453046,
      "sentence": "卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片是否使能更新。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "在简化冗余表达时应优先保持文档模板的完整性，避免修改重复出现的标准化注释模板（如**原子化服务API**段落），仅针对当前句子的冗余部分进行局部优化。"
    },
    {
      "defect_id": 453036,
      "sentence": "卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"| 名称        | 类型                 | 可读    | 可写    | 说明                                                         |\",\"22\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片所属的Ability名称。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "保持文档中重复性注释结构的统一性，避免删除关键标记（如**原子化服务API**），若需简化应确保上下文格式一致性并保留版本声明要素。"
    },
    {
      "defect_id": 452885,
      "sentence": "打开卡片管理页面的请求中的want参数，需包含以下字段。",
      "reference_sentence": "",
      "line_num": 471,
      "context": "{\"466\":\"\",\"467\":\"**参数：**\",\"468\":\"\",\"469\":\"| 参数名  | 类型    | 必填 | 说明                                                                                                                                                                                                                                                                                                      |\",\"470\":\"|------| ------ | ---- |---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\",\"471\":\"| want     | [Want](../apis-ability-kit/js-apis-app-ability-want.md) | 是   | 打开卡片管理页面的请求中的want参数，需包含以下字段。<br>bundleName: 卡片所属应用的包名。<br>abilityName: 卡片所属的ability名称。<br>parameters:<br>- ohos.extra.param.key.form_dimension: [卡片尺寸](js-apis-app-form-formInfo.md#formdimension)。<br>- ohos.extra.param.key.form_name: 卡片名称。<br>- ohos.extra.param.key.module_name: 卡片所属的模块名称。 |\",\"472\":\"\",\"473\":\"**错误码：**\",\"474\":\"\",\"475\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[卡片错误码](errorcode-form.md)。\",\"476\":\"\"}",
      "用户拒绝的修改": "请求中的want参数需包含以下字段",
      "注意事项": "在删除冗余修饰成分前必须确认上下文是否存在关联引用，优先保留与参数定义场景直接相关的前置限定词，避免因过度简化导致技术文档的准确性受损。"
    },
    {
      "defect_id": 453044,
      "sentence": "卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片颜色模式。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需先确认修改范围是否涉及模板化重复内容，避免单独修改重复模板中的个别实例；若同一句式在上下文中批量出现，应保持表述一致性或建议全局替换方案。"
    },
    {
      "defect_id": 453047,
      "sentence": "卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片是否使能可见通知。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复时应严格限定修改范围，仅处理用户标注的冗余部分，避免改动重复性标准化注释的结构；保持同类语句的格式一致性，确保原子化服务API等固定表述的完整性不被破坏。"
    },
    {
      "defect_id": 453041,
      "sentence": "卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片描述ID。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "在修复冗余表达时需严格核对上下文重复模式，避免修改已存在的标准化表述；优先保持同类语句结构一致性，确保修改不破坏已有格式规范。"
    },
    {
      "defect_id": 453037,
      "sentence": "卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 26,
      "context": "{\"21\":\"| 名称        | 类型                 | 可读    | 可写    | 说明                                                         |\",\"22\":\"| ----------- | -------- | -------- | -------------------- | ------------------------------------------------------------ |\",\"23\":\"| bundleName  | string               | 是    | 否     | 卡片所属包的Bundle名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片名称。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需先检查上下文是否存在重复模式，确保修改后的表述与文档其他部分的语法结构完全一致；若涉及模板化内容（如多个条目共用相同说明），应保持修改后的格式统一性而非单独处理单个实例。"
    },
    {
      "defect_id": 453045,
      "sentence": "卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"35\":\"| updateEnabled  | boolean               | 是    | 否     | 卡片是否使能更新。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"36\":\"| formVisibleNotify  | boolean        | 是    | 否     | 卡片是否使能可见通知。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片是否是默认卡片。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修改重复内容时需检查所有相关实例确保一致性，避免局部修改导致上下文断裂；简化冗余表达前应确认修改范围是否涉及历史内容，优先保持已有结构的完整性。"
    },
    {
      "defect_id": 453053,
      "sentence": "卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"| scheduledUpdateTime        | string               | 是    | 否     | 卡片更新时间。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"38\":\"| formConfigAbility | string               | 是    | 否     | 卡片配置ability。指定长按卡片弹出的选择框内，编辑选项所对应的ability。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\"}",
      "用户拒绝的修改": "卡片用户数据。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需确保修改不破坏原有标记结构或跨字段格式一致性，优先检查上下文是否存在重复模板，避免因局部简化导致全局格式错乱。"
    },
    {
      "defect_id": 453040,
      "sentence": "卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"| moduleName  | string               | 是    | 否     | 卡片所属模块的模块名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"25\":\"| abilityName | string               | 是    | 否     | 卡片所属的Ability名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。  |\",\"26\":\"| name        | string               | 是    | 否     | 卡片名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"27\":\"| displayName<sup>11+</sup> | string               | 是    | 否     | 卡片展示名称。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"28\":\"| displayNameId<sup>11+</sup> | number               | 是    | 否     | 卡片预览时标识卡片名称的ID。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"29\":\"| description | string               | 是    | 否     | 卡片描述。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"30\":\"| descriptionId<sup>10+</sup>      | number               | 是    | 否     | 卡片描述id。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"31\":\"| type        | [FormType](#formtype)             | 是    | 否     | 卡片类型。当前支持JS卡片、ArkTS卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"32\":\"| jsComponentName      | string               | 是    | 否     | js卡片的组件名。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"33\":\"| colorMode<sup>(deprecated)</sup>  | [ColorMode](#colormodedeprecated) | 是    | 否     | 卡片颜色模式。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"34\":\"| isDefault    | boolean      | 是    | 否     | 卡片是否是默认卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "卡片描述。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需确保修改范围仅限于当前上下文，避免误改其他已存在的重复内容；同时应保留必要的关键词（如\"原子化服务API\"）以维持技术规范完整性，避免因过度简化丢失重要标记信息。"
    },
    {
      "defect_id": 453055,
      "sentence": "卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 44,
      "context": "{\"39\":\"| updateDuration        | number       | 是    | 否     | 卡片更新周期。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\",\"48\":\"\",\"49\":\"支持的卡片类型枚举。\"}",
      "用户拒绝的修改": "卡片是否支持设置背景透明度。ArkTS卡片由用户配置决定，JS卡片均不支持。支持从API version 11开始在原子化服务中使用。",
      "注意事项": "修复冗余表达时需保持上下文格式一致性，特别注意重复出现的标准化注释结构（如**原子化服务API：**前缀），避免破坏已有文档模式；优先简化用户明确指出的冗余部分，不擅自改动相邻未提及的规范表述。"
    },
    {
      "defect_id": 453082,
      "sentence": "表示卡片为不可见。 |",
      "reference_sentence": "",
      "line_num": 183,
      "context": "{\"178\":\"\",\"179\":\"| 名称        |  值   | 说明         |\",\"180\":\"| ----------- | ---- | ------------ |\",\"181\":\"| UNKNOWN<sup>10+</sup> | 0   | 表示卡片为未知。 |\",\"182\":\"| FORM_VISIBLE | 1   | 表示卡片为可见。 |\",\"183\":\"| FORM_INVISIBLE   | 2   | 表示卡片为不可见。 |\",\"184\":\"\",\"185\":\"\",\"186\":\"## LaunchReason<sup>10+</sup>\",\"187\":\"\",\"188\":\"卡片创建原因枚举。\"}",
      "用户拒绝的修改": "表示卡片为不可见。|",
      "注意事项": "修复前需确认问题是否属于当前修改范围，避免修改已存在的历史冗余；优先处理用户明确指出的问题，不擅自修改未被提及的上下文格式问题。"
    },
    {
      "defect_id": 453061,
      "sentence": "卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 112,
      "context": "{\"107\":\"**系统能力：** SystemCapability.Ability.Form\",\"108\":\"\",\"109\":\"| 名称        | 值   | 说明         |\",\"110\":\"| ----------- | ---- | ------------ |\",\"111\":\"| IDENTITY_KEY     | 'ohos.extra.param.key.form_identity'    | 卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"117\":\"| TEMPORARY_KEY          | 'ohos.extra.param.key.form_temporary'   | 临时卡片。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "卡片规格。参考[FormDimension](#formdimension)。从API version 11开始支持。",
      "注意事项": "修复冗余表达时需严格区分当前修改范围，避免修改其他条目中重复但结构化的标准描述，确保仅处理目标句子的冗余问题且不破坏文档格式一致性。"
    },
    {
      "defect_id": 452881,
      "sentence": "openFormEditAbility(abilityName: string, formId: string, isMainPage?: boolean): void",
      "reference_sentence": "",
      "line_num": 393,
      "context": "{\"388\":\"}\",\"389\":\"```\",\"390\":\"\",\"391\":\"## formProvider.openFormEditAbility<sup>18+</sup>\",\"392\":\"\",\"393\":\"openFormEditAbility(abilityName: string, formId: string, isMainPage?: boolean): void\",\"394\":\"\",\"395\":\"打开卡片编辑页。\",\"396\":\"\",\"397\":\"**系统能力：** SystemCapability.Ability.Form\",\"398\":\"\"}",
      "用户拒绝的修改": "openFormEditAbility(abilityName: string, formId: string, isMainPage: boolean = true): void",
      "注意事项": "修复冗余表达时必须严格区分语法结构差异（如可选参数`?:`与默认值参数的区别），并确认修改内容是否属于当前上下文的问题范围，避免引入非必要的语义变更。"
    },
    {
      "defect_id": 453080,
      "sentence": "表示卡片为未知。 |",
      "reference_sentence": "",
      "line_num": 181,
      "context": "{\"176\":\"\",\"177\":\"**系统能力：** SystemCapability.Ability.Form\",\"178\":\"\",\"179\":\"| 名称        |  值   | 说明         |\",\"180\":\"| ----------- | ---- | ------------ |\",\"181\":\"| UNKNOWN<sup>10+</sup> | 0   | 表示卡片为未知。 |\",\"182\":\"| FORM_VISIBLE | 1   | 表示卡片为可见。 |\",\"183\":\"| FORM_INVISIBLE   | 2   | 表示卡片为不可见。 |\",\"184\":\"\",\"185\":\"\",\"186\":\"## LaunchReason<sup>10+</sup>\"}",
      "用户拒绝的修改": "表示卡片为未知。|",
      "注意事项": "修复冗余表达时应严格区分内容冗余和格式问题，优先处理语义重复而非空格等格式调整；格式修改需单独标注说明，避免与内容修改混淆。"
    },
    {
      "defect_id": 453056,
      "sentence": "卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 45,
      "context": "{\"40\":\"| defaultDimension  | number | 是    | 否     | 卡片规格  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"41\":\"| supportDimensions    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的规格。具体可选规格参考[FormDimension](#formdimension) <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"42\":\"| customizeData    | Record\\\\<string, string>      | 是    | 否     | 卡片用户数据。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"43\":\"| isDynamic<sup>10+</sup>      | boolean               | 是    | 否     | 卡片是否为动态卡片。<br/>仅ArkTS卡片区分动静态卡片，JS卡片均为动态卡片。 <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"44\":\"| transparencyEnabled<sup>11+</sup>      | boolean               | 是    | 否     | 卡片是否支持设置背景透明度。<br/>ArkTS卡片由用户配置决定是否支持，JS卡片均不支持。  <br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"45\":\"| supportedShapes<sup>12+</sup>    | Array&lt;number&gt;      | 是    | 否     | 卡片支持的形状。具体可选形状参考[FormShape<sup>12+</sup>](#formshape12) <br>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。  |\",\"46\":\"\",\"47\":\"## FormType\",\"48\":\"\",\"49\":\"支持的卡片类型枚举。\",\"50\":\"\"}",
      "用户拒绝的修改": "卡片支持的形状。参考[FormShape<sup>12+</sup>](#formshape12)。支持从API version 12开始在原子化服务中使用。",
      "注意事项": "保持文档原有格式结构（如加粗标签、换行符等），确保修改仅针对冗余表达而不破坏已有标记规范；在简化重复说明时需核对上下文格式一致性，避免因格式差异被误判为非相关修改。"
    },
    {
      "defect_id": 454127,
      "sentence": "设置半模态不避让软键盘。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"13\":\"\",\"14\":\"| 名称           | 值   | 说明                         |\",\"15\":\"| ------------------------- | ---- | -------------------------------- |\",\"16\":\"| NONE | 0    | 设置半模态不避让软键盘。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。 |\",\"17\":\"| TRANSLATE_AND_RESIZE    | 1    | 设置半模态先上抬面板避让软键盘；<br/>当上抬至最大高度仍不足以避让软键盘时，则通过压缩整体内容完成避让。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"18\":\"| RESIZE_ONLY    | 2    | 设置半模态通过压缩整体内容避让软键盘。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"19\":\"| TRANSLATE_AND_SCROLL    | 3    | 设置半模态先上抬面板避让软键盘；<br/>当上抬至最大高度仍不足以避让软键盘时，则通过滚动内容完成避让。<br />**原子化服务API：** 从API version 13开始，该接口支持在原子化服务中使用。|\",\"20\":\"| POPUP_SHEET<sup>20+</sup>    | 4    | 设置半模态popup样式弹窗避让软键盘。<br /> 1. 避让软键盘时，在popup样式弹窗当前显示位置无法容纳弹窗尺寸的前提下，遵循先垂直翻转避让，后尝试90°水平旋转避让的规则调整显示位置，以预设方向为下方为例，调整避让顺序依次为：下、上、右、左。<br />2. 如果设置的对齐方式导致组件布局超出窗口范围，将根据该对齐方式在水平或垂直方向上进行位移，直至组件完全显示在窗口内。<br />3. 避让软键盘时，如果在四个方向上均无法容纳当前的popup样式弹窗，处理方式遵循开发者设置的placementOnTarget属性：<br />（1）若属性值为true，将依据设定的placement，向其镜像方向平移，直至弹窗能够完全显示。<br />（2）若属性值为false，则在四个方向中，选择能够完全展示弹窗宽度且剩余高度最大的方向，通过调整半模态高度以适应当前方向，确保弹窗能够放下，同时保持预设placement对应的对齐方式不变。<br />4. 若此时半模态不是跟手样式，则不具备避让软件盘能力。<br />**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。|\",\"21\":\"\"}",
      "用户拒绝的修改": "设置半模态不避让软键盘。",
      "注意事项": "在修复冗余表达时需严格区分技术文档中的规范段落（如API版本说明）与冗余修饰，确保不删除必要技术信息；需结合上下文确认同类条目是否存在统一结构，避免误判标准内容为冗余。"
    },
    {
      "defect_id": 453081,
      "sentence": "表示卡片为可见。 |",
      "reference_sentence": "",
      "line_num": 182,
      "context": "{\"177\":\"**系统能力：** SystemCapability.Ability.Form\",\"178\":\"\",\"179\":\"| 名称        |  值   | 说明         |\",\"180\":\"| ----------- | ---- | ------------ |\",\"181\":\"| UNKNOWN<sup>10+</sup> | 0   | 表示卡片为未知。 |\",\"182\":\"| FORM_VISIBLE | 1   | 表示卡片为可见。 |\",\"183\":\"| FORM_INVISIBLE   | 2   | 表示卡片为不可见。 |\",\"184\":\"\",\"185\":\"\",\"186\":\"## LaunchReason<sup>10+</sup>\",\"187\":\"\"}",
      "用户拒绝的修改": "表示卡片为可见。|",
      "注意事项": "修复时应严格限定修改范围为用户明确指出的冗余内容，避免处理无关格式问题（如多余空格需结合上下文确认是否属于当前任务）；修改前必须核对问题上下文确保改动精准对应反馈点。"
    },
    {
      "defect_id": 454334,
      "sentence": "资源管理错误信息。",
      "reference_sentence": "",
      "line_num": 245,
      "context": "{\"240\":\"**参数：**\",\"241\":\"\",\"242\":\"| 名称             | 类型      | 必填   | 说明                                       |\",\"243\":\"| -------------- | ---- | ---- | ---------------------------------------- |\",\"244\":\"| webResourceRequest | [WebResourceRequest](./arkts-basic-components-web-WebResourceRequest.md) | 是 | 网页请求的封装信息。      |\",\"245\":\"| error   | [WebResourceError](./arkts-basic-components-web-WebResourceError.md)    | 是 | 资源管理错误信息。 |\",\"246\":\"\",\"247\":\"**返回值：**\",\"248\":\"\",\"249\":\"| 类型      | 说明                       |\",\"250\":\"| ------- | ------------------------ |\"}",
      "用户拒绝的修改": "包含资源管理错误信息。",
      "注意事项": "在修复冗余表达时需优先保留技术文档的标准术语和规范表述，避免过度修改导致偏离行业惯例；同时应结合参数表的上下文结构（如参数名和类型已明确功能），确保说明字段保持简洁的名词短语形式，无需添加冗余动词。"
    },
    {
      "defect_id": 455984,
      "sentence": "设置SVG图源抗锯齿效果，仅对SVG图源生效。取值范围为$(0.333, 1.333]$，有效数字保留小数点后3位。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"### edgeAntialiasing<sup>11+</sup>\",\"30\":\"\",\"31\":\"edgeAntialiasing(value: number)\",\"32\":\"\",\"33\":\"设置SVG图源抗锯齿效果，仅对SVG图源生效。取值范围为$(0.333, 1.333]$，有效数字保留小数点后3位。\",\"34\":\"\",\"35\":\"适用于超低分辨率设备（PPI低于200的设备）的SVG图源的锯齿优化，存在一定的性能影响，请谨慎使用。\",\"36\":\"\",\"37\":\"**系统接口：** 此接口为系统接口。\",\"38\":\"\"}",
      "用户拒绝的修改": "设置SVG图源抗锯齿效果。仅对SVG图源生效。取值范围为(0.333, 1.333]。有效数字保留小数点后3位。",
      "注意事项": "在拆分长句时应优先保持技术参数说明的连贯性和专业惯例，避免机械拆分导致信息碎片化；需结合上下文判断是否属于冗余表达，若原句符合技术文档惯用表达方式则无需强制修改。"
    },
    {
      "defect_id": 453063,
      "sentence": "卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 114,
      "context": "{\"109\":\"| 名称        | 值   | 说明         |\",\"110\":\"| ----------- | ---- | ------------ |\",\"111\":\"| IDENTITY_KEY     | 'ohos.extra.param.key.form_identity'    | 卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"117\":\"| TEMPORARY_KEY          | 'ohos.extra.param.key.form_temporary'   | 临时卡片。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"118\":\"| ABILITY_NAME_KEY   | 'ohos.extra.param.key.ability_name'   | ability名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"119\":\"| BUNDLE_NAME_KEY    | 'ohos.extra.param.key.bundle_name'   | Bundle名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "卡片所属模块名称。从API version 11开始支持。",
      "注意事项": "修复时应严格保持上下文格式统一，避免删除未修改部分的重复模式（如多条目共用的**原子化服务API**标签）；修改范围需精准定位问题点，不破坏已有结构特征。"
    },
    {
      "defect_id": 453062,
      "sentence": "卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 113,
      "context": "{\"108\":\"\",\"109\":\"| 名称        | 值   | 说明         |\",\"110\":\"| ----------- | ---- | ------------ |\",\"111\":\"| IDENTITY_KEY     | 'ohos.extra.param.key.form_identity'    | 卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"117\":\"| TEMPORARY_KEY          | 'ohos.extra.param.key.form_temporary'   | 临时卡片。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"118\":\"| ABILITY_NAME_KEY   | 'ohos.extra.param.key.ability_name'   | ability名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "卡片名称。从API version 11开始支持。",
      "注意事项": "修复冗余表达时应优先识别重复的模板化内容（如统一存在的原子化服务API声明），避免修改用户未明确指定的标准化段落；需结合上下文确认修改范围，确保仅处理当前条目新增的冗余信息而非全局性重复内容。"
    },
    {
      "defect_id": 458270,
      "sentence": "通过Context属性可以获取当前应用、模块、UIAbility或ExtensionAbility的基本信息（例如资源管理对象、应用程序信息等），下面以UIAbility的信息获取为例：",
      "reference_sentence": "",
      "line_num": 253,
      "context": "{\"248\":\"\",\"249\":\"### 获取基本信息\",\"250\":\"\",\"251\":\"继承自[Context](../reference/apis-ability-kit/js-apis-inner-application-context.md)的不同类型Context，默认会继承父类的方法和属性，还会拥有自己独立的方法与属性。\",\"252\":\"\",\"253\":\"通过Context属性可以获取当前应用、模块、UIAbility或ExtensionAbility的基本信息（例如资源管理对象、应用程序信息等），下面以UIAbility的信息获取为例：\",\"254\":\"\",\"255\":\"如果需要跨包获取资源管理对象，可以参考[资源访问](../quick-start/resource-categories-and-access.md#资源访问)。\",\"256\":\"\",\"257\":\"  ```ts\",\"258\":\"  import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\"}",
      "用户拒绝的修改": "通过Context属性获取当前应用、模块、UIAbility或ExtensionAbility的基本信息。下面以UIAbility的信息获取为例：",
      "注意事项": "保留括号内关键示例说明以保持技术文档的清晰性，避免过度简化导致信息缺失；需区分冗余修饰词与必要补充说明，技术文档中括号内的具体资源类型属于有效信息补充。"
    },
    {
      "defect_id": 458180,
      "sentence": "[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)在基类Context的基础上提供了监听应用内应用组件的生命周期的变化、监听系统内存变化、监听应用内系统环境变化、设置应用语言、设置应用颜色模式、清除应用自身数据的同时撤销应用向用户申请的权限等能力，在[UIAbility](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md)、[ExtensionAbility](../reference/apis-ability-kit/js-apis-app-ability-extensionAbility.md)、[AbilityStage](../reference/apis-ability-kit/js-apis-app-ability-abilityStage.md)中均可以获取。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"开发者如果需要通过Context获取应用资源、应用路径等信息，或者使用Context提供的方法来实现应用跳转、设置环境变量、清理数据、获取权限等操作，需要先获取对应的Context。本节分别介绍不同类型Context的获取方法。\",\"31\":\"\",\"32\":\"### 获取ApplicationContext（应用级的Context）\",\"33\":\"\",\"34\":\"[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)在基类Context的基础上提供了监听应用内应用组件的生命周期的变化、监听系统内存变化、监听应用内系统环境变化、设置应用语言、设置应用颜色模式、清除应用自身数据的同时撤销应用向用户申请的权限等能力，在[UIAbility](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md)、[ExtensionAbility](../reference/apis-ability-kit/js-apis-app-ability-extensionAbility.md)、[AbilityStage](../reference/apis-ability-kit/js-apis-app-ability-abilityStage.md)中均可以获取。\",\"35\":\"\",\"36\":\"  ```ts\",\"37\":\"  import { UIAbility, AbilityConstant, Want } from '@kit.AbilityKit';\",\"38\":\"\",\"39\":\"  export default class EntryAbility extends UIAbility {\"}",
      "用户拒绝的修改": "[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)提供了监听应用组件生命周期、系统内存变化、系统环境变化、设置应用语言和颜色模式、清除应用数据和撤销权限等能力。在[UIAbility](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md)、[ExtensionAbility](../reference/apis-ability-kit/js-apis-app-ability-extensionAbility.md)、[AbilityStage](../reference/apis-ability-kit/js-apis-app-ability-abilityStage.md)中均可获取。",
      "注意事项": "修复时应保留关键上下文关联（如\"基类Context\"），避免过度简化导致技术信息断层；需明确区分功能描述与上下文定位（如\"应用级的Context\"），删除冗余时优先合并同类项而非直接移除技术限定词。"
    },
    {
      "defect_id": 458114,
      "sentence": "例如，[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)绑定了[setFontSizeScale](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md#applicationcontextsetfontsizescale13)方法，但[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)中没有此方法。因此，即使将UIAbilityContext强行转换为ApplicationContext，也无法调用setFontSizeScale方法。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"不同类型Context的获取方式与使用场景说明，如下表所示。\",\"13\":\"\",\"14\":\"> **说明：**\",\"15\":\">\",\"16\":\"> 不同类型的Context具有不同的能力，不可相互替代或强行转换。例如，[ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md)绑定了[setFontSizeScale](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md#applicationcontextsetfontsizescale13)方法，但[UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md)中没有此方法。因此，即使将UIAbilityContext强行转换为ApplicationContext，也无法调用setFontSizeScale方法。\",\"17\":\"\",\"18\":\"   **表1** 不同类型Context的说明\",\"19\":\"\",\"20\":\"  | Context类型 | 说明 | 获取方式 | 使用场景 |\",\"21\":\"  | -------- | -------- | -------- | -------- |\"}",
      "用户拒绝的修改": "例如，ApplicationContext绑定了setFontSizeScale方法，但UIAbilityContext中没有此方法。强行转换UIAbilityContext为ApplicationContext也无法调用setFontSizeScale方法。",
      "注意事项": "修复冗余表达时应保留关键术语的文档链接和必要上下文，避免过度简化导致技术细节丢失；需平衡简洁性与信息完整性，确保API名称和类名等重要元素不被省略。"
    },
    {
      "defect_id": 453060,
      "sentence": "卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 111,
      "context": "{\"106\":\"\",\"107\":\"**系统能力：** SystemCapability.Ability.Form\",\"108\":\"\",\"109\":\"| 名称        | 值   | 说明         |\",\"110\":\"| ----------- | ---- | ------------ |\",\"111\":\"| IDENTITY_KEY     | 'ohos.extra.param.key.form_identity'    | 卡片标识。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"112\":\"| DIMENSION_KEY      | 'ohos.extra.param.key.form_dimension'  | 卡片规格，规格尺寸参考[FormDimension](#formdimension)。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"113\":\"| NAME_KEY       | 'ohos.extra.param.key.form_name'   | 卡片名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"114\":\"| MODULE_NAME_KEY        | 'ohos.extra.param.key.module_name'   | 卡片所属模块名称。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"115\":\"| WIDTH_KEY        | 'ohos.extra.param.key.form_width'   | 卡片宽度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\",\"116\":\"| HEIGHT_KEY         | 'ohos.extra.param.key.form_height'   | 卡片高度。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。|\"}",
      "用户拒绝的修改": "卡片标识。从API version 11开始支持。",
      "注意事项": "修复冗余表达时需严格校验上下文格式一致性，若重复模式属于文档结构性要素(如多条目共用相同说明模板)，应优先保留原始格式框架而非强行合并，同时需确认修改范围是否涉及历史内容避免误判版本变更记录。"
    },
    {
      "defect_id": 458115,
      "sentence": "从API version 14开始，可以直接使用[getApplicationContext](../reference/apis-ability-kit/js-apis-app-ability-application.md#applicationgetapplicationcontext14)获取。<br>- API version 14以前版本，只能使用其他Context实例的[getApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-context.md#contextgetapplicationcontext)方法获取。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"\",\"18\":\"   **表1** 不同类型Context的说明\",\"19\":\"\",\"20\":\"  | Context类型 | 说明 | 获取方式 | 使用场景 |\",\"21\":\"  | -------- | -------- | -------- | -------- |\",\"22\":\"  | [ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md) | 应用的全局上下文，提供应用级别的信息和能力。| - 从API version 14开始，可以直接使用[getApplicationContext](../reference/apis-ability-kit/js-apis-app-ability-application.md#applicationgetapplicationcontext14)获取。<br>- API version 14以前版本，只能使用其他Context实例的[getApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-context.md#contextgetapplicationcontext)方法获取。 | - [获取当前应用的基本信息](#获取基本信息)。<br>- [获取应用级别的文件路径](#获取应用文件路径)。<br>- [获取和修改加密分区](#获取和修改加密分区)。<br>- [注册生命周期监听](#监听应用前后台变化)。 |\",\"23\":\"  | [AbilityStageContext](../reference/apis-ability-kit/js-apis-inner-application-abilityStageContext.md) | 模块级别的上下文，提供模块级别的信息和能力。| - 如果需要获取当前AbilityStage的Context，可以直接通过AbilityStage实例获取[context](../reference/apis-ability-kit/js-apis-app-ability-abilityStage.md#abilitystagecontext)属性。<br> - 如果需要获取同一应用中其他Module的Context，可以通过[createModuleContext](../reference/apis-ability-kit/js-apis-app-ability-application.md#applicationcreatemodulecontext12)方法。 | - 获取当前模块的基本信息。<br>- [获取模块的文件路径](#获取应用文件路径)。|\",\"24\":\"  | [UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md) | UIAbility组件对应的上下文，提供UIAbility对外的信息和能力。| - 通过UIAbility实例直接获取[context](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#属性)属性。<br>- 在UIAbility的窗口中加载的UI组件实例，需要使用UIContext的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)方法。 | - 获取当前UIAbility基本信息。<br>- 启动其他应用或原子化服务、连接/断连系统应用创建的ServiceExtensionAbility等。<br>- 销毁自身的UIAbility。 |\",\"25\":\"  | [ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md) | ExtensionAbility组件对应的上下文，每种类型的ExtensionContext提供不同的信息和能力。| 通过ExtensionAbility实例直接获取Context属性。 | 不同类型的ExtensionAbility对应的Context提供的能力不同。以输入法上下文[InputMethodExtensionContext](../reference/apis-ime-kit/js-apis-inputmethod-extension-context.md)为例，主要提供如下能力：<br>- 获取InputMethodExtensionAbility的基本信息。<br>- 销毁当前输入法。|\",\"26\":\"| [UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md) | ArkUI的UI实例上下文，提供UI操作相关的能力。与上述其他类型的Context无直接关系。 | - 在UI组件内获取UIContext，直接使用[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)方法。<br>- 在存在Window实例的情况下，使用Window提供的[getUIContext](../reference/apis-arkui/js-apis-window.md#getuicontext10)方法。 | 主要用于UI实例中UI相关操作，例如：<br>- 获取当前UI实例的字体。<br>- 显示不同类型的弹框。<br>- 设置软键盘弹出时UI避让模式。 |\",\"27\":\"\"}",
      "用户拒绝的修改": "从API version 14开始，可以直接使用getApplicationContext获取。API version 14以前版本，只能使用其他Context实例的getApplicationContext方法获取。",
      "注意事项": "修复冗余表达时需保留技术文档中的关键API链接，避免因删除超链导致开发者无法快速查阅方法定义；区分冗余文字（如重复说明）与必要技术细节（如版本差异和获取方式），确保信息完整性和可操作性。"
    },
    {
      "defect_id": 458117,
      "sentence": "通过UIAbility实例直接获取[context](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#属性)属性。<br>- 在UIAbility的窗口中加载的UI组件实例，需要使用UIContext的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)方法。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "{\"19\":\"\",\"20\":\"  | Context类型 | 说明 | 获取方式 | 使用场景 |\",\"21\":\"  | -------- | -------- | -------- | -------- |\",\"22\":\"  | [ApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-applicationContext.md) | 应用的全局上下文，提供应用级别的信息和能力。| - 从API version 14开始，可以直接使用[getApplicationContext](../reference/apis-ability-kit/js-apis-app-ability-application.md#applicationgetapplicationcontext14)获取。<br>- API version 14以前版本，只能使用其他Context实例的[getApplicationContext](../reference/apis-ability-kit/js-apis-inner-application-context.md#contextgetapplicationcontext)方法获取。 | - [获取当前应用的基本信息](#获取基本信息)。<br>- [获取应用级别的文件路径](#获取应用文件路径)。<br>- [获取和修改加密分区](#获取和修改加密分区)。<br>- [注册生命周期监听](#监听应用前后台变化)。 |\",\"23\":\"  | [AbilityStageContext](../reference/apis-ability-kit/js-apis-inner-application-abilityStageContext.md) | 模块级别的上下文，提供模块级别的信息和能力。| - 如果需要获取当前AbilityStage的Context，可以直接通过AbilityStage实例获取[context](../reference/apis-ability-kit/js-apis-app-ability-abilityStage.md#abilitystagecontext)属性。<br> - 如果需要获取同一应用中其他Module的Context，可以通过[createModuleContext](../reference/apis-ability-kit/js-apis-app-ability-application.md#applicationcreatemodulecontext12)方法。 | - 获取当前模块的基本信息。<br>- [获取模块的文件路径](#获取应用文件路径)。|\",\"24\":\"  | [UIAbilityContext](../reference/apis-ability-kit/js-apis-inner-application-uiAbilityContext.md) | UIAbility组件对应的上下文，提供UIAbility对外的信息和能力。| - 通过UIAbility实例直接获取[context](../reference/apis-ability-kit/js-apis-app-ability-uiAbility.md#属性)属性。<br>- 在UIAbility的窗口中加载的UI组件实例，需要使用UIContext的[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)方法。 | - 获取当前UIAbility基本信息。<br>- 启动其他应用或原子化服务、连接/断连系统应用创建的ServiceExtensionAbility等。<br>- 销毁自身的UIAbility。 |\",\"25\":\"  | [ExtensionContext](../reference/apis-ability-kit/js-apis-inner-application-extensionContext.md) | ExtensionAbility组件对应的上下文，每种类型的ExtensionContext提供不同的信息和能力。| 通过ExtensionAbility实例直接获取Context属性。 | 不同类型的ExtensionAbility对应的Context提供的能力不同。以输入法上下文[InputMethodExtensionContext](../reference/apis-ime-kit/js-apis-inputmethod-extension-context.md)为例，主要提供如下能力：<br>- 获取InputMethodExtensionAbility的基本信息。<br>- 销毁当前输入法。|\",\"26\":\"| [UIContext](../reference/apis-arkui/js-apis-arkui-UIContext.md) | ArkUI的UI实例上下文，提供UI操作相关的能力。与上述其他类型的Context无直接关系。 | - 在UI组件内获取UIContext，直接使用[getHostContext](../reference/apis-arkui/js-apis-arkui-UIContext.md#gethostcontext12)方法。<br>- 在存在Window实例的情况下，使用Window提供的[getUIContext](../reference/apis-arkui/js-apis-window.md#getuicontext10)方法。 | 主要用于UI实例中UI相关操作，例如：<br>- 获取当前UI实例的字体。<br>- 显示不同类型的弹框。<br>- 设置软键盘弹出时UI避让模式。 |\",\"27\":\"\",\"28\":\"## Context的获取方式\",\"29\":\"\"}",
      "用户拒绝的修改": "通过UIAbility实例直接获取context属性。在UIAbility的窗口中加载的UI组件实例，需要使用UIContext的getHostContext方法。",
      "注意事项": "在删除冗余链接时需保留关键API版本差异说明，确保技术文档的准确性。简化过程中要区分UIAbilityContext与ApplicationContext的获取方式差异，避免混淆不同上下文类型的使用场景。"
    },
    {
      "defect_id": 471323,
      "sentence": "Promise对象，返回当前自动启动画中画开关状态，true表示开启，false表示关闭。",
      "reference_sentence": "",
      "line_num": 861,
      "context": "{\"856\":\"\",\"857\":\"**返回值：**\",\"858\":\"\",\"859\":\"| 类型                   | 说明                  |\",\"860\":\"|----------------------|---------------------|\",\"861\":\"| Promise&lt;boolean&gt;  | Promise对象，返回当前自动启动画中画开关状态，true表示开启，false表示关闭。 |\",\"862\":\"\",\"863\":\"**错误码：**\",\"864\":\"\",\"865\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[窗口错误码](errorcode-window.md)。\",\"866\":\"\"}",
      "用户拒绝的修改": "返回当前自动启动画中画开关状态，true表示开启，false表示关闭。",
      "注意事项": "修复冗余表达时需优先检查上下文格式规范，确保与文档现有参数表、返回值类型声明等结构保持术语和表述统一，避免破坏技术文档的上下文呼应关系。"
    },
    {
      "defect_id": 470667,
      "sentence": "表示数据更新。",
      "reference_sentence": "",
      "line_num": 67,
      "context": "{\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\",\"71\":\"共享配置的数据结构。\",\"72\":\"\"}",
      "用户拒绝的修改": "数据更新。",
      "注意事项": "在删除冗余修饰词前必须检查上下文一致性，确保技术文档中表格或术语说明的格式统一性优先于局部简洁性，避免破坏原有结构规范。"
    },
    {
      "defect_id": 471322,
      "sentence": "从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 853,
      "context": "{\"848\":\"### getPiPSettingSwitch<sup>20+</sup>\",\"849\":\"getPiPSettingSwitch(): Promise&lt;boolean&gt;\",\"850\":\"\",\"851\":\"获取设置中自动启动画中画开关的状态，仅支持手机和pad设备。\",\"852\":\"\",\"853\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"854\":\"\",\"855\":\"**系统能力：** SystemCapability.Window.SessionManager\",\"856\":\"\",\"857\":\"**返回值：**\",\"858\":\"\"}",
      "用户拒绝的修改": "API version 20起，支持在原子化服务中使用。",
      "注意事项": "修复冗余表达时需优先检查上下文术语一致性（如“从API version X开始”为固定句式），避免擅自替换同义词破坏文档统一性；技术文档修改应以行业标准或项目规范为基准，而非单纯追求句式简洁。"
    },
    {
      "defect_id": 470661,
      "sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.data.dataShare (数据共享)\",\"2\":\"\",\"3\":\"**DataShare**用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。\",\"4\":\"\",\"5\":\"> **说明：** \",\"6\":\">\",\"7\":\"> - 本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\">\"}",
      "用户拒绝的修改": "DataShare管理应用数据，支持设备上不同应用间的数据共享。",
      "注意事项": "在技术文档中优先保留必要的限定词（如“其自身”）以确保技术含义的准确性，避免因过度简化导致关键信息丢失或歧义。"
    },
    {
      "defect_id": 471927,
      "sentence": "OpenHarmony JSVM-API是基于标准JS引擎提供的一套稳定的API，为开发者提供了较为完整的JS引擎能力，包括创建和销毁引擎，执行JS代码，JS/C++交互等关键能力。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# JSVM-API简介\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"OpenHarmony JSVM-API是基于标准JS引擎提供的一套稳定的API，为开发者提供了较为完整的JS引擎能力，包括创建和销毁引擎，执行JS代码，JS/C++交互等关键能力。\",\"6\":\"\",\"7\":\"OpenHarmony JSVM-API是C语言接口，遵循C99标准。\",\"8\":\"\",\"9\":\"通过JSVM-API，开发者可以在应用运行期间直接执行一段动态加载的JS代码。也可以选择将一些对性能、底层系统调用有较高要求的核心功能用C/C++实现并将C++方法注册到JS侧，在JS代码中直接调用，提高应用的执行效率。\",\"10\":\"\"}",
      "用户拒绝的修改": "OpenHarmony JSVM-API是基于标准JS引擎提供的一套稳定的API。它为开发者提供了完整的JS引擎能力，包括创建和销毁引擎、执行JS代码、JS/C++交互等关键能力。",
      "注意事项": "保留原文中关键限定词（如\"较为\"）以确保技术准确性，拆分长句时优先保持原意连贯性，避免因过度简化导致语义偏差。"
    },
    {
      "defect_id": 465187,
      "sentence": "订阅划词完成事件，使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"## on('selectionCompleted')\",\"18\":\"\",\"19\":\"on(type: 'selectionCompleted', callback: Callback\\\\<SelectionInfo>): void\",\"20\":\"\",\"21\":\"订阅划词完成事件，使用callback异步回调。\",\"22\":\"\",\"23\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"24\":\"\",\"25\":\"**参数：**\",\"26\":\"\"}",
      "用户拒绝的修改": "订阅划词完成事件。",
      "注意事项": "在技术文档场景中需保留与API参数或使用方式强相关的关键信息（如“callback异步回调”），避免过度简化导致功能说明不完整；修复前应结合上下文判断修饰成分是否属于必要的技术细节说明。"
    },
    {
      "defect_id": 470665,
      "sentence": "表示数据添加。",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\"}",
      "用户拒绝的修改": "数据添加。",
      "注意事项": "在技术文档表格中需保留\"表示\"等连接词以保持说明列的结构一致性，避免破坏表格语义完整性；优先识别领域特定表达惯例而非机械删除修饰成分。"
    },
    {
      "defect_id": 465258,
      "sentence": "本模块提供划词面板的属性信息和类型。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.selectionInput.SelectionPanel (划词面板)\",\"2\":\"\",\"3\":\"本模块提供划词面板的属性信息和类型。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\">本模块首批接口从API version 20开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\"\"}",
      "用户拒绝的修改": "本模块提供划词面板的属性和类型。",
      "注意事项": "在判断冗余表达时需优先验证技术术语的固定搭配，并结合上下文确认\"修饰成分\"是否实际影响信息准确性，避免将专业表述误判为冗余。"
    },
    {
      "defect_id": 465189,
      "sentence": "创建划词面板，仅支持带有划词功能的三方应用调用。使用promise异步回调。",
      "reference_sentence": "",
      "line_num": 90,
      "context": "{\"85\":\"\",\"86\":\"## createPanel\",\"87\":\"\",\"88\":\"createPanel(ctx: Context, info: PanelInfo): Promise\\\\<Panel>\",\"89\":\"\",\"90\":\"创建划词面板，仅支持带有划词功能的三方应用调用。使用promise异步回调。\",\"91\":\"\",\"92\":\"单个划词应用仅允许创建一个[主面板类型](./js-apis-selectionInput-selectionPanel.md)和[菜单面板类型](./js-apis-selectionInput-selectionPanel.md)的窗口。\",\"93\":\"\",\"94\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"95\":\"\"}",
      "用户拒绝的修改": "创建划词面板。",
      "注意事项": "修复冗余表达时应保留必要的技术限制（如“仅支持带有划词功能的三方应用调用”）和实现方式说明（如“使用promise异步回调”），避免过度删除API文档中关键的功能约束和调用规范。需结合上下文判断修饰成分是否属于技术规范而非冗余描述。"
    },
    {
      "defect_id": 471623,
      "sentence": "表示窗口动画类型为淡入。淡入动画在窗口显示过程中生效。",
      "reference_sentence": "",
      "line_num": 115,
      "context": "{\"110\":\"\",\"111\":\"**系统能力：**  SystemCapability.Window.SessionManager\",\"112\":\"\",\"113\":\"| 名称    | 值   | 说明                       |\",\"114\":\"| ------- | ---- | -------------------------- |\",\"115\":\"| FADE_IN | 1    | 表示窗口动画类型为淡入。淡入动画在窗口显示过程中生效。 |\",\"116\":\"\",\"117\":\"## SystemBarRegionTint<sup>8+</sup>\",\"118\":\"\",\"119\":\"单个导航栏或状态栏回调信息。\",\"120\":\"\"}",
      "用户拒绝的修改": "FADE_IN 表示窗口动画类型为淡入。",
      "注意事项": "修复冗余表达时需优先保留技术文档中必要的上下文信息，特别是当原句包含独立功能说明或生效条件时；应仔细分析表格/枚举项的结构特征，避免因过度简化破坏字段间的信息完整性。"
    },
    {
      "defect_id": 470666,
      "sentence": "表示数据删除。",
      "reference_sentence": "",
      "line_num": 66,
      "context": "{\"61\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"62\":\"\",\"63\":\"| 名称     | 值          | 说明          |\",\"64\":\"| ---------| ------------| --------------|\",\"65\":\"| INSERT   | 0           | 表示数据添加。|\",\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\",\"71\":\"共享配置的数据结构。\"}",
      "用户拒绝的修改": "数据删除。",
      "注意事项": "修复冗余表达时需优先检查上下文格式一致性，确保修改后的内容与相邻条目结构统一；若冗余成分（如“表示”）在上下文中承担统一语法功能，应保留以避免破坏表格或列表的规范性。"
    },
    {
      "defect_id": 465197,
      "sentence": "Promise对象，返回当前创建的划词面板对象。",
      "reference_sentence": "",
      "line_num": 106,
      "context": "{\"101\":\"| info    | [PanelInfo](./js-apis-selectionInput-selectionPanel.md)   | 是   | 划词面板信息。 |\",\"102\":\"\",\"103\":\"**返回值：**\",\"104\":\"| 类型   | 说明                                                                 |\",\"105\":\"| ------- | ------------------------------------------------------------------ |\",\"106\":\"| Promise\\\\<[Panel](#panel)> | Promise对象，返回当前创建的划词面板对象。  |\",\"107\":\"\",\"108\":\"**错误码：**\",\"109\":\"\",\"110\":\"以下错误码的详细介绍请参见[划词服务错误码](errorcode-selection.md)。\",\"111\":\"\"}",
      "用户拒绝的修改": "返回当前创建的划词面板对象。",
      "注意事项": "在技术文档中，需保留必要的技术术语作为主语（如\"Promise对象\"），避免因过度简化破坏技术准确性；应结合上下文类型定义（如表格已标注Promise类型），判断描述中重复类型名称是否属于必要的补充说明，而非冗余信息。"
    },
    {
      "defect_id": 465188,
      "sentence": "取消订阅划词完成事件。使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 58,
      "context": "{\"53\":\"\",\"54\":\"## off('selectionCompleted')\",\"55\":\"\",\"56\":\"off(type: 'selectionCompleted', callback?: Callback\\\\<SelectionInfo>): void\",\"57\":\"\",\"58\":\"取消订阅划词完成事件。使用callback异步回调。\",\"59\":\"\",\"60\":\"**系统能力：** SystemCapability.SelectionInput.Selection\",\"61\":\"\",\"62\":\"**参数：**\",\"63\":\"\"}",
      "用户拒绝的修改": "取消订阅划词完成事件。",
      "注意事项": "修复冗余表达时必须结合技术文档上下文，区分冗余修饰和必要接口说明，尤其要保留涉及参数类型（如callback）或异步机制等关键使用信息的描述。"
    },
    {
      "defect_id": 470663,
      "sentence": "Promise对象。返回DataProxyHandle实例。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"**返回值：**\",\"28\":\"\",\"29\":\"| 类型                                               | 说明                                   |\",\"30\":\"| -------------------------------------------------- | -------------------------------------- |\",\"31\":\"| Promise&lt;[DataProxyHandle](#dataproxyhandle20)&gt; | Promise对象。返回DataProxyHandle实例。 |\",\"32\":\"\",\"33\":\"**错误码：**\",\"34\":\"\",\"35\":\"错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。\",\"36\":\"\"}",
      "用户拒绝的修改": "返回DataProxyHandle实例。",
      "注意事项": "在删除冗余表达时需保留必要技术上下文，确保类型声明(Promise<DataProxyHandle>)与说明文本(\"返回DataProxyHandle实例\")的对应关系，避免因过度简化导致关键信息断层。"
    },
    {
      "defect_id": 465053,
      "sentence": "以下错误码的详细介绍请参见[元能力错误码](../apis-ability-kit/errorcode-ability.md)。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"| -------------- | ------------------------- |\",\"35\":\"| Promise\\\\<void> | Promise对象，无返回结果。 |\",\"36\":\"\",\"37\":\"**错误码：**\",\"38\":\"\",\"39\":\"以下错误码的详细介绍请参见[元能力错误码](../apis-ability-kit/errorcode-ability.md)。\",\"40\":\"\",\"41\":\"| 错误码ID | 错误信息                                                |\",\"42\":\"| -------- | ------------------------------------------------------- |\",\"43\":\"| 16000001 | The specified ability does not exist.                   |\",\"44\":\"| 16000002 | Incorrect ability type.                                 |\"}",
      "用户拒绝的修改": "错误码的详细信息请参见[元能力错误码](../apis-ability-kit/errorcode-ability.md)。",
      "注意事项": "在判断冗余表达时需区分必要指代和修饰成分，结合上下文确认\"以下\"等指示词是否具有明确指代功能，避免过度删除影响指代清晰度。"
    },
    {
      "defect_id": 471905,
      "sentence": "JSVM-API接口开发流程请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"| OH_JSVM_GetDateValue        | 获取给定JavaScript Date的时间值的Double基础类型值。  |\",\"21\":\"| OH_JSVM_IsDate               | 判断一个JavaScript对象是否为Date类型对象。|\",\"22\":\"\",\"23\":\"## 使用示例\",\"24\":\"\",\"25\":\"JSVM-API接口开发流程请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++相关代码。\",\"26\":\"\",\"27\":\"### OH_JSVM_CreateDate\",\"28\":\"\",\"29\":\"创建一个表示给定毫秒数的Date对象。\",\"30\":\"\"}",
      "用户拒绝的修改": "请参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文展示接口对应的C++代码。",
      "注意事项": "在删除冗余内容时应优先保留上下文衔接词(如\"JSVM-API接口开发流程\")确保段落连贯性，并谨慎处理\"仅\"等限定词以避免改变原意，同时需通过语气分析判断用户更重视简洁性还是自然语感。"
    },
    {
      "defect_id": 464886,
      "sentence": "是否开启抗锯齿效果。<br/>true：开启抗锯齿；false：关闭抗锯齿。<br/>默认值：true",
      "reference_sentence": "",
      "line_num": 278,
      "context": "{\"273\":\"\",\"274\":\"**参数：** \",\"275\":\"\",\"276\":\"| 参数名 | 类型    | 必填 | 说明                                  |\",\"277\":\"| ------ | ------- | ---- | ------------------------------------- |\",\"278\":\"| value  | boolean | 是   | 是否开启抗锯齿效果。<br/>true：开启抗锯齿；false：关闭抗锯齿。<br/>默认值：true |\",\"279\":\"\",\"280\":\"### mesh<sup>8+</sup>\",\"281\":\"\",\"282\":\"mesh(value: Array&lt;any&gt;, column: number, row: number)\",\"283\":\"\"}",
      "用户拒绝的修改": "是否开启抗锯齿效果。true：开启；false：关闭。默认值：true。",
      "注意事项": "修复冗余表达时需保留技术参数的必要上下文信息，避免因过度简化导致语义模糊；在技术文档中，参数值的说明需与参数名保持明确对应关系，确保功能描述完整性。"
    },
    {
      "defect_id": 470668,
      "sentence": "共享配置的数据结构。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"| DELETE   | 1           | 表示数据删除。|\",\"67\":\"| UPDATE   | 2           | 表示数据更新。|\",\"68\":\"\",\"69\":\"## ProxyData<sup>20+</sup>\",\"70\":\"\",\"71\":\"共享配置的数据结构。\",\"72\":\"\",\"73\":\"**系统能力：** SystemCapability.DistributedDataManager.DataShare.Consumer\",\"74\":\"\",\"75\":\"| 名称       | 类型                                                         | 必填 | 说明           |\",\"76\":\"| ---------- | ----------------------------------------------------------- | ---- | -------------- |\"}",
      "用户拒绝的修改": "定义共享配置的数据结构。",
      "注意事项": "修复冗余表达时应优先保留核心名词短语结构，避免机械添加冗余动词；需结合上下文判断是否属于技术文档的标题/说明性短句，此类场景允许省略谓语保持简洁性。"
    },
    {
      "defect_id": 472700,
      "sentence": "自由多窗下的可支持窗口模式可以采用多种方法进行配置，配置优先级为：通过[SetSupportedWindowModes](../reference/apis-arkui/arkts-apis-window-WindowStage.md#setsupportedwindowmodes15)接口配置 > 通过StartAbility配置[StartOption](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md#startoptions)中的SupportWindowMode > 使用metadata配置 > 配置module.json5中[abilities](../quick-start/module-configuration-file.md#abilities标签)标签下的SupportWindowMode属性。",
      "reference_sentence": "",
      "line_num": 38,
      "context": "{\"33\":\"        2. 使用[startOptions](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md)的supportWindowModes属性，且只配置FULL_SCREEN选项。\",\"34\":\"        3. 使用[module.json5](../quick-start/module-configuration-file.md#abilities标签)的supportWindowMode属性，且只配置fullscreen选项。\",\"35\":\"\",\"36\":\"4. 使用metadata配置[自由多窗](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-multi-window#section118295375110)下的可支持窗口模式。配置项为：name为ohos.ability.window.SupportWindowModeInFreeWindow，value取值为：fullscreen（表示全屏模式）、split（表示分屏模式）、floating（表示悬浮窗模式）。value取值为字符串，可以取多种模式，每个之间用逗号分隔开，不区分顺序，不添加空格，例如：fullscreen,split。仅在平板、PC/2in1设备上生效。\",\"37\":\"\",\"38\":\"   自由多窗下的可支持窗口模式可以采用多种方法进行配置，配置优先级为：通过[SetSupportedWindowModes](../reference/apis-arkui/arkts-apis-window-WindowStage.md#setsupportedwindowmodes15)接口配置 > 通过StartAbility配置[StartOption](../reference/apis-ability-kit/js-apis-app-ability-startOptions.md#startoptions)中的SupportWindowMode > 使用metadata配置 > 配置module.json5中[abilities](../quick-start/module-configuration-file.md#abilities标签)标签下的SupportWindowMode属性。\",\"39\":\"\",\"40\":\"   非自由多窗模式下只能通过配置module.json5中abilities标签下的SupportWindowMode属性配置窗口支持模式，其他配置方式均不生效。\",\"41\":\"\",\"42\":\"<!--Del-->\",\"43\":\"5. 使用metadata标签配置主窗边角以直角显示。配置项为：name为ohos.ability.window.isRightAngle，value取值为true或false，取值为true表示窗口边角以直角显示、取值为false则使用系统默认圆角，未配置时默认为false。主窗直角配置仅在PC/2in1设备上生效，且仅支持系统应用。<!--DelEnd-->\"}",
      "用户拒绝的修改": "自由多窗下的可支持窗口模式配置优先级：通过[SetSupportedWindowModes]接口配置 > 通过StartAbility配置[StartOption]中的SupportWindowMode > 使用metadata配置 > 配置module.json5中abilities标签下的SupportWindowMode属性。",
      "注意事项": "精简冗余修饰时应保留必要上下文引用（如接口名称和文档锚点），避免过度简化导致关键信息缺失；需结合文档前后结构判断已有解释的配置项是否可省略路径说明。"
    },
    {
      "defect_id": 472698,
      "sentence": "如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"1. 使用metadata标签配置主窗口的默认大小和位置（单位为vp）。其中name取值及对应含义如下：\",\"18\":\"\",\"19\":\"    * name取值为ohos.ability.window.height表示主窗口的默认高度，value表示高度大小。\",\"20\":\"    * name取值为ohos.ability.window.width表示主窗口的默认宽度，value表示宽度大小。\",\"21\":\"    * name取值为ohos.ability.window.left表示主窗口默认左边的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、left和right，默认值为left；当偏移量为0时可以省略。\",\"22\":\"    * name取值为ohos.ability.window.top表示主窗口顶部的位置。value表示配置格式，取值：对齐方式 +/- 偏移量。对齐方式包括center、top和bottom，默认值为top。如果对齐方式和偏移量同时省略，则按照系统默认的层叠规格处理。\",\"23\":\"\",\"24\":\"2. 使用metadata标签配置是否移除启动页。配置项为：name取值为enable.remove.starting.window，value取值为true或false，取值为true表示移除启动页、取值为false表示不移除启动页，未配置时默认为false。\",\"25\":\"\",\"26\":\"3. 使用metadata标签配置主窗启动时是否以最大化状态显示。配置项为：name为ohos.ability.window.isMaximize，value取值为true或false，取值为true表示最大化启动、取值为false表示不以最大化状态启动，未配置时默认为false。主窗最大化显示配置存在如下约束与限制：\",\"27\":\"\"}",
      "用户拒绝的修改": "省略对齐方式和偏移量时，按系统默认的层叠规格处理。",
      "注意事项": "在技术文档修改中，必须优先保留限定条件的关键词（如\"同时\"），即使存在表面冗余也要确保技术逻辑的准确性；删除修饰成分前需验证是否影响条件判断的完整性。"
    },
    {
      "defect_id": 474681,
      "sentence": "本接口当前仅支持2in1设备。",
      "reference_sentence": "",
      "line_num": 1948,
      "context": "{\"1943\":\"\",\"1944\":\"获取所有保活的AppServiceExtensionAbility应用信息，此信息由[KeepAliveBundleInfo](#keepalivebundleinfo14)定义。使用Promise异步回调。\",\"1945\":\"\",\"1946\":\"> **说明：**\",\"1947\":\">\",\"1948\":\"> - 本接口当前仅支持2in1设备。\",\"1949\":\"\",\"1950\":\"**需要权限**：ohos.permission.MANAGE_APP_KEEP_ALIVE\",\"1951\":\"\",\"1952\":\"**系统能力**：SystemCapability.Ability.AbilityRuntime.Core\",\"1953\":\"\"}",
      "用户拒绝的修改": "本接口支持2in1设备。",
      "注意事项": "在修复冗余表达时需严格区分时间/范围限定词（如“当前”“仅”）与冗余修饰语，保留必要的时间敏感性和功能限制信息，避免因过度简化导致技术准确性缺失。"
    },
    {
      "defect_id": 470792,
      "sentence": "回调函数。当有其他用户触发了变更通知时会回调该函数。",
      "reference_sentence": "",
      "line_num": 172,
      "context": "{\"167\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"168\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"169\":\"| event     | string                        | 是   | 订阅的事件/回调类型，支持的事件为'dataChange'，当有其他用户触发了变更通知时，触发该事件。 |\",\"170\":\"| uris     | string\\\\[]             | 是   | 表示要订阅的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"171\":\"| config      | [DataProxyConfig](#dataproxyconfig20)               | 是   | 表示数据代理操作的配置。 |\",\"172\":\"| callback | AsyncCallback&lt;[DataProxyChangeInfo](#dataproxychangeinfo20)\\\\[]&gt; | 是   | 回调函数。当有其他用户触发了变更通知时会回调该函数。|\",\"173\":\"\",\"174\":\"**返回值：**\",\"175\":\"\",\"176\":\"| 类型             | 说明                                                         |\",\"177\":\"| ---------------- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "回调函数。",
      "注意事项": "修复参数说明时应保留触发条件等关键技术细节，避免过度简化破坏文档完整性；需特别关注参数表中其他字段的说明规范，保持技术文档上下文风格一致性。"
    },
    {
      "defect_id": 470702,
      "sentence": "没有权限在该URI上执行此操作。",
      "reference_sentence": "",
      "line_num": 103,
      "context": "{\"98\":\"\",\"99\":\"| 名称       | 值                                                          | 说明           |\",\"100\":\"| ---------- | ----------------------------------------------------------| -------------- |\",\"101\":\"| SUCCESS        | 0                                                       | 表示操作成功。 |\",\"102\":\"| URI_NOT_EXIST  | 1                                                       | URI不存在或取消订阅一个未订阅过的URI。|\",\"103\":\"| NO_PERMISSION  | 2                                                       | 没有权限在该URI上执行此操作。 |\",\"104\":\"| OVER_LIMIT     | 3                                                       | 表示当前应用发布的配置超过32个配置的上限。  |\",\"105\":\"\",\"106\":\"## DataProxyResult<sup>20+</sup>\",\"107\":\"\",\"108\":\"配置共享批量操作结果的数据结构。\"}",
      "用户拒绝的修改": "在该URI上没有执行此操作的权限。",
      "注意事项": "修复冗余表达时应优先确保语义清晰度和上下文一致性，避免过度调整语序导致技术文档的术语连贯性受损；若原句已符合技术规范且无明显冗余成分，应保留原始表述。"
    },
    {
      "defect_id": 474941,
      "sentence": "拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。",
      "reference_sentence": "",
      "line_num": 125,
      "context": "{\"120\":\"\",\"121\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"122\":\"\",\"123\":\"| 名称 | 值  | 说明             |\",\"124\":\"| ---- | ---- | ------------------ |\",\"125\":\"| ACTION_INTERCEPT | 0 | 拦截当前组件接收的无障碍控制操作，回调处理结束后，不允许当前组件响应无障碍控制操作。 |\",\"126\":\"| ACTION_CONTINUE | 1 | 拦截当前组件接收的无障碍控制操作, 回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑。 |\",\"127\":\"| ACTION_RISE | 2 | 拦截执行当前组件接收的无障碍控制操作，回调处理结束后，仍然需要组件做出响应，执行当前组件的处理逻辑，并且将ACTION信息往父组件传递，传递到下一个使用了onAccessibilityActionIntercept的组件，触发当前组件中注册的回调，但不触发组件处理逻辑。处理完成后，可以继续使用RISE向父组件传递ACTION。 |\",\"128\":\"\",\"129\":\"## 示例\",\"130\":\"\"}",
      "用户拒绝的修改": "拦截无障碍控制操作，不允许组件响应。",
      "注意事项": "修复冗余表达时需保留关键限定条件（如\"当前组件\"）和必要时间顺序描述（如\"回调处理结束后\"），避免过度简化导致技术细节丢失，同时要结合上下文确保不同枚举项的差异化特征清晰可辨。"
    },
    {
      "defect_id": 476611,
      "sentence": "例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件只允许本进程读写，因此可以通过neverallow进行限制：",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"\",\"61\":\"## 使用neverallow对业务做安全防护\",\"62\":\"\",\"63\":\"neverallow可以阻止不合理的策略配置，作为安全防护手段，避免本业务的SELinux业务被恶意修改。\",\"64\":\"\",\"65\":\"例如，主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。按业务安全需要，该数据库文件只允许本进程读写，因此可以通过neverallow进行限制：\",\"66\":\"```text\",\"67\":\"neverallow { domain -accesstoken_service } accesstoken_data_file:file *;\",\"68\":\"```\",\"69\":\"表示不允许除了accesstoken_service以外的其他进程对accesstoken_data_file进行文件操作。\"}",
      "用户拒绝的修改": "主体进程accesstoken_service的数据库文件SELinux类型为accesstoken_data_file。为满足业务安全需要，该数据库文件只允许本进程读写，因此通过neverallow进行限制：",
      "注意事项": "修复冗余表达时应保持原句逻辑关系，避免改变\"业务要求\"与\"安全措施\"之间的因果关系；在技术文档中需特别注意专业表述的准确性，确保\"业务需要\"等核心概念不被错误重构为\"满足需要\"的目的性表达。"
    },
    {
      "defect_id": 470791,
      "sentence": "订阅的事件/回调类型，支持的事件为'dataChange'，当有其他用户触发了变更通知时，触发该事件。",
      "reference_sentence": "",
      "line_num": 169,
      "context": "{\"164\":\"\",\"165\":\"**参数：**\",\"166\":\"\",\"167\":\"| 参数名     | 类型                        | 必填 | 说明                    |\",\"168\":\"| -------- | ----------------------------- | ---- | ------------------------ |\",\"169\":\"| event     | string                        | 是   | 订阅的事件/回调类型，支持的事件为'dataChange'，当有其他用户触发了变更通知时，触发该事件。 |\",\"170\":\"| uris     | string\\\\[]             | 是   | 表示要订阅的共享配置对应的URI数组，数组最大长度为32。URI固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写，但同一应用内不允许重复，字符串长度不超过256个字节。 |\",\"171\":\"| config      | [DataProxyConfig](#dataproxyconfig20)               | 是   | 表示数据代理操作的配置。 |\",\"172\":\"| callback | AsyncCallback&lt;[DataProxyChangeInfo](#dataproxychangeinfo20)\\\\[]&gt; | 是   | 回调函数。当有其他用户触发了变更通知时会回调该函数。|\",\"173\":\"\",\"174\":\"**返回值：**\"}",
      "用户拒绝的修改": "订阅的事件/回调类型，支持的事件为'dataChange'。",
      "注意事项": "保留技术文档中关键触发条件和场景说明，避免过度删减影响功能理解；需结合上下文判断\"冗余\"是否属于必要的技术细节补充，而非单纯修饰成分。"
    },
    {
      "defect_id": 475491,
      "sentence": "APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"| -------- | -------- | -------- |\",\"13\":\"| normal | normal_hap_attr | normal_hap_data_file_attr |\",\"14\":\"| system_basic | system_basic_hap_attr | system_basic_hap_data_file_attr |\",\"15\":\"| system_core | system_core_hap_attr | system_core_hap_data_file_attr |\",\"16\":\"\",\"17\":\"APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。\",\"18\":\"\",\"19\":\"另外还有一个表示所有应用进程的attribute，名为hap_domain。\",\"20\":\"\",\"21\":\"配置的SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：\",\"22\":\"```text\"}",
      "用户拒绝的修改": "APL说明参考权限等级文档。",
      "注意事项": "保留文档中必要的跳转链接格式和路径信息，避免过度简化导致功能性元素丢失；在优化冗余表达时应优先维护技术文档的准确性和可导航性，不可仅依据句子长度进行简化。"
    },
    {
      "defect_id": 470830,
      "sentence": "以下错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。",
      "reference_sentence": "",
      "line_num": 236,
      "context": "{\"231\":\"| ---------------- | ------------------------------------------------------------ |\",\"232\":\"| [DataProxyResult](#dataproxyresult20)\\\\[] | 批量操作的结果数组。|\",\"233\":\"\",\"234\":\"**错误码：**\",\"235\":\"\",\"236\":\"以下错误码的详细介绍请参见[数据共享错误码](errorcode-datashare.md)。\",\"237\":\"\",\"238\":\"| 错误码ID | 错误信息              |\",\"239\":\"| -------- | -------------------- |\",\"240\":\"| 15700000 | Inner error. Possible causes: The service is not ready or is being restarted abnormally.|\",\"241\":\"\"}",
      "用户拒绝的修改": "请参见[数据共享错误码](errorcode-datashare.md)。",
      "注意事项": "在简化冗余表达时需保留必要上下文信息，确保删除内容不破坏原句与上下文的逻辑关联性，特别是当原句存在指代关系（如\"以下错误码\"）时，应保留关键指代词以维持语义完整性。"
    },
    {
      "defect_id": 476608,
      "sentence": "配置SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。\",\"18\":\"\",\"19\":\"另外还有一个表示所有应用进程的attribute，名为hap_domain。\",\"20\":\"\",\"21\":\"配置SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\",\"25\":\"表示允许以normal_hap为标签的应用进程和huks_service进行binder通信。考虑实际情况，huks_service会为所有应用提供huks能力，因此这里的normal_hap应该改为hap_domain，即\",\"26\":\"```text\"}",
      "用户拒绝的修改": "配置SELinux策略时，涉及应用的SELinux类型，需要根据实际开放范围做修改。例如，根据avc日志配置的策略是：",
      "注意事项": "修复冗余表达时需优先保留技术文档的准确性和条件限定词（如\"如果\"），避免过度简化导致语义模糊；删除重复修饰成分前应确认其是否影响操作指引的完整性或上下文逻辑。"
    },
    {
      "defect_id": 476770,
      "sentence": "2. 通过日志观察划词服务拉起划词ExtensionAbility过程",
      "reference_sentence": "",
      "line_num": 144,
      "context": "{\"139\":\"\",\"140\":\"- 从设置中打开划词开关\",\"141\":\"- 选择当前应用为划词应用\",\"142\":\"- 设置划词触发方式\",\"143\":\"\",\"144\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程\",\"145\":\"\",\"146\":\"- 使用DevEco Studio的Hilog窗口查看日志。\",\"147\":\"\",\"148\":\"3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口\"}",
      "用户拒绝的修改": "观察划词服务拉起划词ExtensionAbility过程",
      "注意事项": "修复冗余表达时需优先保留技术文档中明确操作方法和关键路径描述（如“通过日志”），避免因过度简化导致信息缺失；同时结合完整上下文判断句子结构问题，确保步骤说明的完整性和准确性。"
    },
    {
      "defect_id": 476767,
      "sentence": "2. 划词ExtensionAbility实现类介绍",
      "reference_sentence": "",
      "line_num": 132,
      "context": "{\"127\":\"        ]\",\"128\":\"      }\",\"129\":\"    }\",\"130\":\"    ```\",\"131\":\"\",\"132\":\"2. 划词ExtensionAbility实现类介绍\",\"133\":\"\",\"134\":\"    应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法进行生命周期管理。其中，`onConnect` 方法在用户划词并启动划词扩展时触发。\",\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\"}",
      "用户拒绝的修改": "介绍划词ExtensionAbility实现类",
      "注意事项": "修复时应优先识别上下文结构（如标题、列表项），避免将符合规范的简洁标题误判为结构不完整；同时需结合技术文档场景容忍无主谓的短语式表达，仅在正文段落中针对完整句子应用冗余规则。"
    },
    {
      "defect_id": 475492,
      "sentence": "另外还有一个表示所有应用进程的attribute，名为hap_domain。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"| system_basic | system_basic_hap_attr | system_basic_hap_data_file_attr |\",\"15\":\"| system_core | system_core_hap_attr | system_core_hap_data_file_attr |\",\"16\":\"\",\"17\":\"APL说明参考[权限等级说明](../../application-dev/security/AccessToken/app-permission-mgmt-overview.md#权限apl等级)。\",\"18\":\"\",\"19\":\"另外还有一个表示所有应用进程的attribute，名为hap_domain。\",\"20\":\"\",\"21\":\"配置的SELinux策略时，如果涉及应用的SELinux类型，需要根据实际的开放范围做对应的修改，例如根据avc日志配置的策略是：\",\"22\":\"```text\",\"23\":\"allow normal_hap huks_service:binder { call };\",\"24\":\"```\"}",
      "用户拒绝的修改": "还有一个表示所有应用进程的attribute，名为hap_domain。",
      "注意事项": "在删除\"另外\"等衔接词前必须检查上下文逻辑关系，保留必要的语义过渡词；优先维护作者的表达意图而非单纯缩短句子，若连接词承担上下文呼应功能则不应视为冗余。"
    },
    {
      "defect_id": 476769,
      "sentence": "1. 通过设置系统参数设置划词配置",
      "reference_sentence": "",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"    应用划词扩展类 `ServiceExtAbility` 继承自 `SelectionExtensionAbility`，实现 `onConnect` 和 `onDisconnect` 方法进行生命周期管理。其中，`onConnect` 方法在用户划词并启动划词扩展时触发。\",\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\",\"138\":\"1. 通过设置系统参数设置划词配置\",\"139\":\"\",\"140\":\"- 从设置中打开划词开关\",\"141\":\"- 选择当前应用为划词应用\",\"142\":\"- 设置划词触发方式\",\"143\":\"\"}",
      "用户拒绝的修改": "设置划词配置",
      "注意事项": "修复冗余表达时应优先保留必要操作路径和上下文信息，确保句子结构完整（如明确主语/谓语）且符合技术文档的指令规范，避免因过度精简影响步骤可操作性。"
    },
    {
      "defect_id": 478286,
      "sentence": "Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux支持MCS\",\"2\":\"\",\"3\":\"## MCS背景介绍\",\"4\":\"\",\"5\":\"Multi-Category Security(MCS)是SELinux强制访问控制的一种模式，通过类别(Category)划分资源访问权限，确保进程仅能访问与其类别相匹配的资源。\",\"6\":\"\",\"7\":\"## MCS开关配置\",\"8\":\"当前MCS默认为开启状态，需要关闭MCS时，可在selinux_adapter部件里配置selinux_adapter_mcs_enable=false。\",\"9\":\"\",\"10\":\"## MCS安全级别配置\"}",
      "用户拒绝的修改": "MCS是SELinux的强制访问控制模式，通过类别划分资源访问权限，确保进程访问匹配的资源。",
      "注意事项": "修复冗余表达时应优先保留核心术语全称（如\"Multi-Category Security\"）和关键限定词（如\"仅能\"），避免因过度简化损失技术文档的准确性；需结合上下文判断信息密度需求，背景介绍类段落应保持必要细节完整性。"
    },
    {
      "defect_id": 476765,
      "sentence": "1. 划词应用配置文件介绍",
      "reference_sentence": "",
      "line_num": 107,
      "context": "{\"102\":\"    selectionManager.destroyPanel(this.panel_);\",\"103\":\"    ```\",\"104\":\"\",\"105\":\"## 代码文件介绍\",\"106\":\"\",\"107\":\"1. 划词应用配置文件介绍\",\"108\":\"\",\"109\":\"    `module.json5`中需要在`requestPermissions`子项中添加应用所需权限，在`extensionAbilities`子项中指定划词扩展类文件路径。\",\"110\":\"\",\"111\":\"    ```json\",\"112\":\"    {\"}",
      "用户拒绝的修改": "介绍划词应用配置文件",
      "注意事项": "修复时应优先保留技术文档的列表项结构特征（编号+名词性短语），避免将标题式表达强行改为完整句子，需结合上下文判断是否存在真正的语法缺陷而非格式特征。"
    },
    {
      "defect_id": 476771,
      "sentence": "3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口",
      "reference_sentence": "",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程\",\"145\":\"\",\"146\":\"- 使用DevEco Studio的Hilog窗口查看日志。\",\"147\":\"\",\"148\":\"3. 使用鼠标左键单击选中文本，观察界面弹出划词窗口\"}",
      "用户拒绝的修改": "使用鼠标左键单击选中文本，界面弹出划词窗口",
      "注意事项": "在技术文档中保留必要的指导性动词（如\"观察\"）以确保操作步骤清晰明确，避免因过度追求语法完整性而忽略用户对验证动作的实际需求；修复前需结合上下文判断动词是否承担关键引导作用。"
    },
    {
      "defect_id": 478212,
      "sentence": "  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。",
      "reference_sentence": "",
      "line_num": 88,
      "context": "{\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\"}",
      "用户拒绝的修改": "`object`表示客体，通常为系统资源的SELinux类型",
      "注意事项": "在简化冗余表达时应优先保留有助于理解的具体示例，特别是当上下文存在同类结构时需保持示例的完整性；删除前需评估示例对概念解释的必要性，避免过度简化导致信息缺失。"
    },
    {
      "defect_id": 478211,
      "sentence": "- `subject`表示主体，通常为进程的SELinux类型，如`init`。",
      "reference_sentence": "",
      "line_num": 87,
      "context": "{\"82\":\"SELinux策略，又称SELinux规则，通常以allow或neverallow开头，表示允许或禁止某种行为。在设备上使能SELinux时，SELinux会拦截所有未经allow规则授权的行为，配置allow规则可以放行，neverallow规则主要是拦截危险规则的配置。通常allow规则如下:\",\"83\":\"```text\",\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\"}",
      "用户拒绝的修改": "`subject`表示主体，通常为进程的SELinux类型",
      "注意事项": "在简化冗余表达时需优先保留关键示例（如`init`），确保技术术语的示例说明不被误删；同时检查上下文示例一致性，避免因过度精简破坏知识传递完整性。"
    },
    {
      "defect_id": 478371,
      "sentence": "这里使用APL等级为normal的应用作为示例，其他APL等级的应用参考下表配置：",
      "reference_sentence": "",
      "line_num": 106,
      "context": "{\"101\":\"2. 在type.te中定义`permissionmanager_hap`和`permissionmanager_hap_data_file`，使`u:r:permissionmanager_hap:s0`和`u:object_r:permissionmanager_hap_data_file:s0`是合法的。\",\"102\":\"    ```text\",\"103\":\"    type permissionmanager_hap, normal_hap_attr, hap_domain, domain;\",\"104\":\"    type permissionmanager_hap_data_file, normal_hap_data_file_attr, hap_file_attr, data_file_attr, file_attr;\",\"105\":\"    ```\",\"106\":\"    这里使用APL等级为normal的应用作为示例，其他APL等级的应用参考下表配置：\",\"107\":\"\",\"108\":\"    **表1** APL等级与应用attribute归属对应关系\",\"109\":\"    | APL等级 | 应用进程attribute归属 | 应用数据目录attribute归属 |\",\"110\":\"    | -------- | -------- | -------- |\",\"111\":\"    | normal | normal_hap_attr | normal_hap_data_file_attr |\"}",
      "用户拒绝的修改": "这里使用APL等级为normal的应用作为示例。其他APL等级的应用参考下表配置：",
      "注意事项": "修复冗余表达时应结合上下文判断信息连贯性，避免仅依赖逗号数量等机械规则；技术文档优先保持专业表述完整性，修改前需确认用户是否存在隐性的格式规范或风格偏好。"
    },
    {
      "defect_id": 477993,
      "sentence": "3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\",\"38\":\"| contexts类型 | 加载方 | 用途 |\"}",
      "用户拒绝的修改": "3. 对contexts中间文件中使用的SELinux标签校验合法性。得到contexts文件。",
      "注意事项": "拆分长句时应确保拆分后的分句保持完整的技术逻辑链条，避免破坏步骤间的因果关系；优先保持原有信息密度，仅在确实存在理解障碍时进行句式调整。"
    },
    {
      "defect_id": 478920,
      "sentence": "Skip server certificate verification. The default value is `false`.",
      "reference_sentence": "",
      "line_num": 932,
      "context": "{\"927\":\"| header | Object |  No |  Yes  | Header carrying optional parameters in the request for establishing a WebSocket connection. You can customize the parameter or leave it unspecified.<br>**Atomic service API**: This API can be used in atomic services since API version 11.|\",\"928\":\"| caPath<sup>11+</sup> | string |  No |  Yes | Path of CA certificates. If a path is set, the system uses the CA certificates in this path. If a path is not set, the system uses the preset CA certificate, namely, **/etc/ssl/certs/cacert.pem**. This path is the sandbox mapping path, which can be obtained through **Global.getContext().filesDir**. Currently, only text certificates in PEM format are supported.|\",\"929\":\"| clientCert<sup>11+</sup> | [ClientCert](#clientcert11) |   No |  Yes  | Client certificate.|\",\"930\":\"| proxy<sup>12+</sup> | ProxyConfiguration |  No | Yes| Proxy configuration. By default, the system network proxy is used.|\",\"931\":\"| protocol<sup>12+</sup> | string |  No | Yes| Custom **Sec-WebSocket-Protocol** field. The default value is \\\"\\\".             |\",\"932\":\"| skipServerCertVerification<sup>20+</sup> | boolean |  No  | Yes | Skip server certificate verification. The default value is `false`.   |\",\"933\":\"\",\"934\":\"## ClientCert<sup>11+</sup>\",\"935\":\"\",\"936\":\"Defines the client certificate type.\",\"937\":\"\"}",
      "用户拒绝的修改": "跳过服务器证书验证。默认值为`false`。",
      "注意事项": "修复时必须严格保持原文语言（如英文），仅优化冗余表达而非翻译内容；技术文档需保留代码符号（如反引号）和默认值格式，避免破坏技术准确性。"
    },
    {
      "defect_id": 478907,
      "sentence": "Skip server certificate verification. The default is **false**.",
      "reference_sentence": "",
      "line_num": 932,
      "context": "{\"927\":\"| header | Object |  No |  Yes  | Header carrying optional parameters in the request for establishing a WebSocket connection. You can customize the parameter or leave it unspecified.<br>**Atomic service API**: This API can be used in atomic services since API version 11.|\",\"928\":\"| caPath<sup>11+</sup> | string |  No |  Yes | Path of CA certificates. If a path is set, the system uses the CA certificates in this path. If a path is not set, the system uses the preset CA certificate, namely, **/etc/ssl/certs/cacert.pem**. This path is the sandbox mapping path, which can be obtained through **Global.getContext().filesDir**. Currently, only text certificates in PEM format are supported.|\",\"929\":\"| clientCert<sup>11+</sup> | [ClientCert](#clientcert11) |   No |  Yes  | Client certificate.|\",\"930\":\"| proxy<sup>12+</sup> | ProxyConfiguration |  No | Yes| Proxy configuration. By default, the system network proxy is used.|\",\"931\":\"| protocol<sup>12+</sup> | string |  No | Yes| Custom **Sec-WebSocket-Protocol** field. The default value is \\\"\\\".             |\",\"932\":\"| skipServerCertVerification<sup>20+</sup> | boolean |  No  | Yes | Skip server certificate verification. The default is **false**.   |\",\"933\":\"\",\"934\":\"## ClientCert<sup>11+</sup>\",\"935\":\"\",\"936\":\"Defines the client certificate type.\",\"937\":\"\"}",
      "用户拒绝的修改": "跳过服务器证书验证。默认值为 **false**。",
      "注意事项": "修复冗余表达时需确保术语和布尔值（如**false**）与上下文语言一致，若上下文为中文且未特殊标注英文术语，应使用中文翻译（例如“**否**”或“**假**”）并添加必要注释说明。"
    },
    {
      "defect_id": 478269,
      "sentence": "3. 接口调用",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"    ```cpp\",\"30\":\"    #include \\\"policycoreutils.h\\\"\",\"31\":\"    ```\",\"32\":\"\",\"33\":\"3. 接口调用\",\"34\":\"\",\"35\":\"    以Restorecon接口为例：\",\"36\":\"    ```cpp\",\"37\":\"    // 更新/data路径标签：\",\"38\":\"    int ret = Restorecon(\\\"/data\\\");\"}",
      "用户拒绝的修改": "调用接口",
      "注意事项": "修复冗余表达时应优先保留技术文档中行业惯用的术语结构和标题格式，避免因过度简化破坏原意的准确性或违背上下文规范。"
    },
    {
      "defect_id": 477991,
      "sentence": "1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"![selinux_contexts](./figures/SELinux-contexts.png)\",\"28\":\"\",\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\"}",
      "用户拒绝的修改": "1. 分别遍历各类型的contexts文件。得到每个类型contexts的文件列表。",
      "注意事项": "修复时应优先保持技术步骤描述的连贯性，避免拆分存在逻辑关联的\"动作+结果\"结构；需结合上下文检查同类步骤的表述一致性，确保修改后的句式与文档整体风格匹配。"
    },
    {
      "defect_id": 478268,
      "sentence": "2. 头文件依赖添加",
      "reference_sentence": "",
      "line_num": 27,
      "context": "{\"22\":\"\",\"23\":\"    ```text\",\"24\":\"    external_deps += [ \\\"selinux_adapter:librestorecon\\\" ]\",\"25\":\"    ```\",\"26\":\"\",\"27\":\"2. 头文件依赖添加\",\"28\":\"\",\"29\":\"    ```cpp\",\"30\":\"    #include \\\"policycoreutils.h\\\"\",\"31\":\"    ```\",\"32\":\"\"}",
      "用户拒绝的修改": "添加头文件依赖",
      "注意事项": "修复冗余表达时应优先保持技术文档术语一致性，避免过度简化破坏专业语境；修改前需确认表述调整是否真正消除冗余而非主观判断的\"简化需求\"。"
    },
    {
      "defect_id": 478302,
      "sentence": "  安全上下文，也通常称为SELinux标签。OpenHarmony SELinux安全上下文的结构是`user:role:type:sensitivity[:category,...]- sensitivity [:category,...]`：",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"## 基本概念\",\"17\":\"\",\"18\":\"- **安全上下文**\",\"19\":\"\",\"20\":\"  安全上下文，也通常称为SELinux标签。OpenHarmony SELinux安全上下文的结构是`user:role:type:sensitivity[:category,...]- sensitivity [:category,...]`：\",\"21\":\"  - `user`：用户类型，比如`user u roles { r }`，定义user为u的用户，它属于`role r`。\",\"22\":\"  - `role`：角色标识符，角色限制了进程在进程上下文中基于角色标识符可转换的类型，其中文件、参数、SA服务、HDF服务等资源的用户类型使用`object_r`，进程的用户类型使用r。\",\"23\":\"  - `type`：SELinux类型，在SELinux规则语句中，使用类型定义规则。\",\"24\":\"  - `sensitivity`：分层安全级别，不同安全级别不能相互访问，目前OpenHarmony SELinux仅支持一层安全级别`s0`。\",\"25\":\"  - `category`：对特定`sensitivity`划分不分层的分类，目前OpenHarmony SELinux已经定义的分类为`c0-c1023`，目前的OpenHarmony SELinux策略上未对category进行区分。\"}",
      "用户拒绝的修改": "安全上下文，也称SELinux标签。OpenHarmony SELinux安全上下文的结构是`user:role:type:sensitivity[:category,...]- sensitivity [:category,...]`。",
      "注意事项": "修复冗余表达时需保留必要的过渡词（如\"通常\"）确保上下文衔接自然，避免因过度简化导致关键术语解释与后续内容脱节。"
    },
    {
      "defect_id": 477992,
      "sentence": "2. 对列表分别拼接去重，生成contexts中间文件。",
      "reference_sentence": "",
      "line_num": 32,
      "context": "{\"27\":\"![selinux_contexts](./figures/SELinux-contexts.png)\",\"28\":\"\",\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\"}",
      "用户拒绝的修改": "2. 对列表分别拼接去重。生成contexts中间文件。",
      "注意事项": "修复时应优先保持技术文档中流程步骤的表述结构一致性，避免拆分导致格式断层；需结合上下文判断拆分必要性，技术术语和固定搭配（如\"生成contexts中间文件\"）应保持完整避免割裂。"
    },
    {
      "defect_id": 478214,
      "sentence": "  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。",
      "reference_sentence": "",
      "line_num": 90,
      "context": "{\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\",\"95\":\"```\"}",
      "用户拒绝的修改": "`permissions`表示具体操作，如对文件file的open、read、write",
      "注意事项": "在技术文档中优先保留明确术语定义的修饰词（如\"要执行的\"），避免因过度简化导致关键上下文缺失；保持参数说明句式一致性，确保修改后的表达与上下文结构协调。"
    },
    {
      "defect_id": 479494,
      "sentence": "该错误码表示系统服务异常，可能原因如下：",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"The system service works abnormally.\",\"14\":\"\",\"15\":\"**可能原因**\",\"16\":\"\",\"17\":\"该错误码表示系统服务异常，可能原因如下：\",\"18\":\"1. 账号管理服务无法正常启动。\",\"19\":\"2. 账号管理的IPC对象无法获取。\",\"20\":\"3. 账号管理依赖的其他服务无法正常启动或者IPC对象无法获取。\",\"21\":\"4. 服务未初始化。\",\"22\":\"5. 磁盘空间不足。\"}",
      "用户拒绝的修改": "系统服务异常的可能原因：",
      "注意事项": "保留技术文档中关键术语（如\"错误码\"）的核心指代作用，在简化冗余表达时应优先确保关键信息不丢失，避免因过度删除导致技术逻辑链条断裂。"
    },
    {
      "defect_id": 478213,
      "sentence": "  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。",
      "reference_sentence": "",
      "line_num": 89,
      "context": "{\"84\":\"allow subject object:class permissions;\",\"85\":\"```\",\"86\":\"  表示允许`subject`对`object`进行`class`中的`permissions`操作，其中：\",\"87\":\"  - `subject`表示主体，通常为进程的SELinux类型，如`init`。\",\"88\":\"  - `object`表示客体，通常为系统资源的SELinux类型，如`data_file`。\",\"89\":\"  - `class`表示要执行的操作的类型，如文件操作file、目录操作dir、套接字操作socket。\",\"90\":\"  - `permissions`表示要执行的具体操作，如对文件file的open、read、write。\",\"91\":\"\",\"92\":\"同理，\",\"93\":\"```text\",\"94\":\"neverallow subject object:class permissions;\"}",
      "用户拒绝的修改": "`class`表示操作类型，如文件操作file、目录操作dir、套接字操作socket",
      "注意事项": "在简化冗余表达时需优先保留技术文档的关键限定词（如\"要执行的\"），确保术语解释的精确性和上下文一致性，避免因过度简化导致信息丢失或歧义。"
    },
    {
      "defect_id": 479364,
      "sentence": "为模糊半径，模糊半径越大越模糊，为0时不模糊。<br/>取值范围：[0, 1000]",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"**参数：** \",\"12\":\"\",\"13\":\"| 参数名  | 类型                                                         | 必填 | 说明                                                         |\",\"14\":\"| ------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"15\":\"| value   | number                                                       | 是   | 为模糊半径，模糊半径越大越模糊，为0时不模糊。<br/>取值范围：[0, 1000] |\",\"16\":\"| options | [LinearGradientBlurOptions](#lineargradientbluroptions12对象说明) | 是   | 设置线性渐变模糊效果。  <br/>线性梯度模糊包含两个部分fractionStops和direction。                                     |\",\"17\":\"\",\"18\":\"**返回值：**\",\"19\":\"\",\"20\":\"| 类型   | 说明                     |\"}",
      "用户拒绝的修改": "为模糊半径，取值范围：[0, 1000]。模糊半径越大越模糊，为0时不模糊。",
      "注意事项": "保持参数说明的完整性，避免在技术文档中过度拆分句子导致信息碎片化；优先保持参数定义与效果说明的逻辑连贯性，仅在明显影响可读性时拆分长句。"
    },
    {
      "defect_id": 478260,
      "sentence": "SELinux对外提供更新文件或目录SELinux标签的接口。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# OpenHarmony SELinux对外接口说明\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"\",\"5\":\"SELinux对外提供更新文件或目录SELinux标签的接口。\",\"6\":\"\",\"7\":\"## 接口说明\",\"8\":\"\",\"9\":\"所有接口均为Native C内部接口，仅提供底层能力，不对应用开放。相关接口列表如下：\",\"10\":\"\"}",
      "用户拒绝的修改": "SELinux提供更新文件或目录标签的接口。",
      "注意事项": "在技术文档中优先保留上下文关键术语（如\"对外\"可能区分接口类型），需结合文档结构判断修饰词是否属于必要限定而非冗余表达。"
    },
    {
      "defect_id": 477994,
      "sentence": "4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"### contexts编译\",\"30\":\"OpenHarmony SELinux contexts编译主要包括以下流程：\",\"31\":\"1. 分别遍历各类型的contexts文件，得到每个类型contexts的文件列表。\",\"32\":\"2. 对列表分别拼接去重，生成contexts中间文件。\",\"33\":\"3. 对contexts中间文件中使用的SELinux标签校验合法性，得到contexts文件。\",\"34\":\"4. 将contexts归档到`system.img`，位于`/system/etc/selinux/targeted/contexts/`。\",\"35\":\"\",\"36\":\"### contexts加载\",\"37\":\"OpenHarmony SELinux contexts加载按类型不同，加载方式不同：\",\"38\":\"| contexts类型 | 加载方 | 用途 |\",\"39\":\"| -------- | -------- | -------- |\"}",
      "用户拒绝的修改": "4. 将contexts归档到`system.img`。位于`/system/etc/selinux/targeted/contexts/`。",
      "注意事项": "拆分句子前需确认技术文档中路径信息是否属于必要补充说明，避免破坏原句\"归档位置+路径\"的完整技术语义关联，在列表项中应保持单句完整性以符合技术文档规范。"
    },
    {
      "defect_id": 479498,
      "sentence": "该错误码表示不支持多用户，可能原因如下：",
      "reference_sentence": "",
      "line_num": 118,
      "context": "{\"113\":\"\",\"114\":\"Multi-user is not supported.\",\"115\":\"\",\"116\":\"**可能原因**\",\"117\":\"\",\"118\":\"该错误码表示不支持多用户，可能原因如下：\",\"119\":\"当前设备不支持多用户，无法创建账号。\",\"120\":\"\",\"121\":\"**处理步骤**\",\"122\":\"\",\"123\":\"无法创建其他账号，请取消创建。\"}",
      "用户拒绝的修改": "不支持多用户的可能原因：",
      "注意事项": "修复冗余表达时必须保留关键术语（如“错误码”）以维持上下文关联性，优先精简次要描述而非删除核心信息载体。"
    },
    {
      "defect_id": 479496,
      "sentence": "该错误码表示操作的账号不存在，可能原因如下：",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"\",\"74\":\"The account does not exist.\",\"75\":\"\",\"76\":\"**可能原因**\",\"77\":\"\",\"78\":\"该错误码表示操作的账号不存在，可能原因如下：\",\"79\":\"1. 查询/激活/删除未创建的账号。\",\"80\":\"2. 查询/激活/删除已删除的账号。\",\"81\":\"3. 为已删除的账号设置约束/用户名/头像。\",\"82\":\"4. 更新未创建的账号。\",\"83\":\"5. 为不存在的账号设置/取消账号信息访问授权。\"}",
      "用户拒绝的修改": "操作的账号不存在的可能原因：",
      "注意事项": "修复冗余表达时必须优先保留技术文档中的核心要素（如错误码、参数名称等关键信息），避免因过度精简导致关键上下文丢失；需结合上下文判断冗余部分是否承担逻辑衔接功能，确保技术准确性不受影响。"
    },
    {
      "defect_id": 479552,
      "sentence": "该错误码表示用户认证密码个数达到上限，可能原因如下：",
      "reference_sentence": "",
      "line_num": 567,
      "context": "{\"562\":\"\",\"563\":\"**错误信息**\",\"564\":\"\",\"565\":\"The number of credentials reaches the upper limit.\",\"566\":\"\",\"567\":\"**可能原因**\",\"568\":\"\",\"569\":\"1. 身份认证服务出现未知错误。\",\"570\":\"2. 用户已有对应类型的密码，不能再添加密码。\",\"571\":\"\",\"572\":\"**处理步骤**\"}",
      "用户拒绝的修改": "该错误码表示密码个数达到上限。",
      "注意事项": "在删除冗余信息时必须保留关键限定词和专业术语，结合上下文确认\"密码\"的具体类型指向（如用户认证密码），避免因过度简化丢失核心业务概念。"
    },
    {
      "defect_id": 479511,
      "sentence": "当前应用向系统注册一个已经注册过的监听器，无法重复注册。",
      "reference_sentence": "",
      "line_num": 210,
      "context": "{\"205\":\"The event listener has been registered.\",\"206\":\"\",\"207\":\"**可能原因**\",\"208\":\"\",\"209\":\"该错误码表示监听器已注册，可能原因如下：\",\"210\":\"当前应用向系统注册一个已经注册过的监听器，无法重复注册。\",\"211\":\"\",\"212\":\"**处理步骤**\",\"213\":\"\",\"214\":\"请取消注册，或使用未注册过的监听器重新注册。\",\"215\":\"\"}",
      "用户拒绝的修改": "监听器已注册，无法重复注册。",
      "注意事项": "修复冗余表达时应保留关键技术动作和上下文信息(如\"当前应用向系统注册\")，避免过度简化导致技术细节丢失；需检查现有文档结构，确保修改后的描述与上下文既有内容形成互补而非重复。"
    },
    {
      "defect_id": 479514,
      "sentence": "2. 联网异常；",
      "reference_sentence": "",
      "line_num": 241,
      "context": "{\"236\":\"\",\"237\":\"**可能原因**\",\"238\":\"\",\"239\":\"该错误码表示网络异常，可能原因如下：\",\"240\":\"1. 未连接网络；\",\"241\":\"2. 联网异常；\",\"242\":\"3. 应用无联网权限；\",\"243\":\"4. 未知的网络错误；\",\"244\":\"\",\"245\":\"**处理步骤**\",\"246\":\"\"}",
      "用户拒绝的修改": "联网异常。",
      "注意事项": "修复冗余表达前需确认上下文条目间的实质性差异，避免误删必要信息；同时优先保持列表格式一致性（如标点符号统一），仅在内容重复且无歧义时进行精简。"
    },
    {
      "defect_id": 479497,
      "sentence": "该错误码表示账号已存在，可能原因如下：",
      "reference_sentence": "",
      "line_num": 103,
      "context": "{\"98\":\"\",\"99\":\"The account already exists.\",\"100\":\"\",\"101\":\"**可能原因**\",\"102\":\"\",\"103\":\"该错误码表示账号已存在，可能原因如下：\",\"104\":\"创建已存在的账号。\",\"105\":\"\",\"106\":\"**处理步骤**\",\"107\":\"\",\"108\":\"请取消创建，或使用其他账户号名重试。\"}",
      "用户拒绝的修改": "账号已存在的可能原因：",
      "注意事项": "修复冗余表达时需优先保留关键上下文信息（如错误码标识），避免过度简化导致技术文档的定位功能缺失；精简操作应严格区分\"重复累赘\"和\"必要技术术语\"，结合用户使用场景评估信息必要性。"
    },
    {
      "defect_id": 480067,
      "sentence": "创建IsolatedComponent组件，用于显示受限worker运行的Abc。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"\",\"43\":\"## 接口\",\"44\":\"\",\"45\":\"IsolatedComponent(options: IsolatedOptions)\",\"46\":\"\",\"47\":\"创建IsolatedComponent组件，用于显示受限worker运行的Abc。\",\"48\":\"\",\"49\":\"**系统接口：** 此接口为系统接口。\",\"50\":\"\",\"51\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"52\":\"\"}",
      "用户拒绝的修改": "创建IsolatedComponent组件，显示受限worker运行的Abc。",
      "注意事项": "修复技术文档冗余表达时需保留\"用于\"等介词明确功能指向性，优先保持术语完整性和句式规范性，避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 479495,
      "sentence": "该错误码表示传入无效的参数，可能原因如下：",
      "reference_sentence": "",
      "line_num": 40,
      "context": "{\"35\":\"\",\"36\":\"Invalid parameter.\",\"37\":\"\",\"38\":\"**可能原因**\",\"39\":\"\",\"40\":\"该错误码表示传入无效的参数，可能原因如下：\",\"41\":\"1. 用户名为空。\",\"42\":\"2. 系统账号用户名长度大于1024。\",\"43\":\"3. 分布式账号用户名长度大于256。\",\"44\":\"4. 系统账号id小于0、小于100或大于1099。\",\"45\":\"5. 分布式账号id长度大于512。\"}",
      "用户拒绝的修改": "传入无效参数的可能原因：",
      "注意事项": "修复冗余表达时需保留技术文档的关键主体（如\"错误码\"），避免过度删减导致信息脱钩；优先采用句式重组而非直接删除核心描述，确保逻辑主语与上下文一致。"
    },
    {
      "defect_id": 479515,
      "sentence": "3. 应用无联网权限；",
      "reference_sentence": "",
      "line_num": 242,
      "context": "{\"237\":\"**可能原因**\",\"238\":\"\",\"239\":\"该错误码表示网络异常，可能原因如下：\",\"240\":\"1. 未连接网络；\",\"241\":\"2. 联网异常；\",\"242\":\"3. 应用无联网权限；\",\"243\":\"4. 未知的网络错误；\",\"244\":\"\",\"245\":\"**处理步骤**\",\"246\":\"\",\"247\":\"1. 连接网络；\"}",
      "用户拒绝的修改": "应用无联网权限。",
      "注意事项": "修复冗余表达时必须明确识别具体冗余元素（如重复用词或冗余修饰语），同时严格保持技术文档列表项的结构一致性，避免将简洁的专业表述误判为冗余。"
    },
    {
      "defect_id": 479513,
      "sentence": "1. 未连接网络；",
      "reference_sentence": "",
      "line_num": 240,
      "context": "{\"235\":\"Network exception.\",\"236\":\"\",\"237\":\"**可能原因**\",\"238\":\"\",\"239\":\"该错误码表示网络异常，可能原因如下：\",\"240\":\"1. 未连接网络；\",\"241\":\"2. 联网异常；\",\"242\":\"3. 应用无联网权限；\",\"243\":\"4. 未知的网络错误；\",\"244\":\"\",\"245\":\"**处理步骤**\"}",
      "用户拒绝的修改": "未连接网络。",
      "注意事项": "修复冗余表达时应优先检查上下文格式一致性，避免破坏列表项标点统一性；区分必要结构符号与冗余内容，确保修改不影响文档结构性规范。"
    },
    {
      "defect_id": 480092,
      "sentence": "通过回调参数中的code、name和message获取错误信息并做处理。",
      "reference_sentence": "",
      "line_num": 127,
      "context": "{\"122\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"123\":\"\",\"124\":\"  // 对abc文件进行校验，并拷贝到指定沙箱路径下\",\"125\":\"  function VerifyAbc(abcPaths: Array<string>, deleteOriginalFiles: boolean) {\",\"126\":\"    try {\",\"127\":\"      bundleManager.verifyAbc(abcPaths, deleteOriginalFiles, (err) => {\",\"128\":\"        if (err) {\",\"129\":\"          console.error(\\\"VerifyAbc failed, error message: \\\" + err.message);\",\"130\":\"        } else {\",\"131\":\"          console.info(\\\"VerifyAbc successfully.\\\");\",\"132\":\"        }\"}",
      "用户拒绝的修改": "通过回调参数获取错误信息并处理。",
      "注意事项": "保留技术文档中必要的参数名称，避免过度简化导致关键信息丢失；需结合上下文判断参数枚举是否属于必要技术细节，而非简单视为冗余修饰。"
    },
    {
      "defect_id": 479502,
      "sentence": "该错误码表示账号已激活，可能原因如下：",
      "reference_sentence": "",
      "line_num": 178,
      "context": "{\"173\":\"\",\"174\":\"The account has been activated.\",\"175\":\"\",\"176\":\"**可能原因**\",\"177\":\"\",\"178\":\"该错误码表示账号已激活，可能原因如下：\",\"179\":\"激活已激活的账号。\",\"180\":\"\",\"181\":\"**处理步骤**\",\"182\":\"\",\"183\":\"当前账号已激活，请勿重复操作。\"}",
      "用户拒绝的修改": "账号已激活的可能原因：",
      "注意事项": "修复冗余表达时必须保留技术文档中的关键术语（如错误码/参数名），采用\"删结构不删关键词\"策略，例如将\"该错误码表示账号已激活，可能原因如下：\"优化为\"该错误码表示账号已激活的可能原因：\"，既消除冗余又保留核心要素。"
    },
    {
      "defect_id": 480387,
      "sentence": "getCustomDataSync(name: string, key: string): string;",
      "reference_sentence": "",
      "line_num": 1153,
      "context": "{\"1148\":\"  }\",\"1149\":\"  ```\",\"1150\":\"\",\"1151\":\"### getCustomDataSync<sup>9+</sup>\",\"1152\":\"\",\"1153\":\"getCustomDataSync(name: string, key: string): string;\",\"1154\":\"\",\"1155\":\"根据指定键名获取特定应用账号的自定义数据。使用同步方式返回结果。\",\"1156\":\"\",\"1157\":\"**系统能力：** SystemCapability.Account.AppAccount\",\"1158\":\"\"}",
      "用户拒绝的修改": "getCustomDataSync(name: string, key: string): string; 获取指定应用账号的自定义数据。",
      "注意事项": "修复时必须严格对照问题上下文中的现有描述，避免重复添加功能说明；补充参数描述时应聚焦于缺失的name/key参数定义，而非改写已有方法用途描述。"
    },
    {
      "defect_id": 480506,
      "sentence": "获取指定应用账号的额外信息（能转换成string类型的其它信息）。使用Promise异步回调。",
      "reference_sentence": "",
      "line_num": 3907,
      "context": "{\"3902\":\"\",\"3903\":\"### getAccountExtraInfo<sup>(deprecated)</sup>\",\"3904\":\"\",\"3905\":\"getAccountExtraInfo(name: string): Promise&lt;string&gt;\",\"3906\":\"\",\"3907\":\"获取指定应用账号的额外信息（能转换成string类型的其它信息）。使用Promise异步回调。\",\"3908\":\"\",\"3909\":\"> **说明：** \",\"3910\":\">\",\"3911\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getCustomData](#getcustomdata9-1)替代。\",\"3912\":\"\"}",
      "用户拒绝的修改": "获取指定应用账号的额外信息。",
      "注意事项": "在删除括号内容前需验证补充说明是否包含关键约束条件（如数据类型/返回值类型），同时检查问题上下文中的接口签名（Promise&lt;string&gt;）是否已隐含异步回调信息，避免因过度简化丢失技术文档必要的精确性。"
    },
    {
      "defect_id": 479884,
      "sentence": "组件模板，用于跟提供方定义的组件绑定。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"定义用于构造插件组件的选项。\",\"36\":\"\",\"37\":\"| 参数       | 类型   | 描述                        |\",\"38\":\"| ---------- | ------ | --------------------------- |\",\"39\":\"| template   | [PluginComponentTemplate](#plugincomponenttemplate9类型说明) | 组件模板，用于跟提供方定义的组件绑定。                |\",\"40\":\"| data       | any    | 传给插件组件提供方使用的数据。 |\",\"41\":\"\",\"42\":\"## PluginComponentTemplate<sup>9+</sup>类型说明\",\"43\":\"\",\"44\":\"| 参数       | 类型   | 描述                        |\"}",
      "用户拒绝的修改": "组件模板，绑定提供方组件。",
      "注意事项": "在修复冗余表达时需确保核心技术参数（如\"提供方定义的组件\"）的完整性，避免过度简化导致关键信息丢失；应结合上下文参数类型（PluginComponentTemplate）判断术语精确性，优先保留技术文档必要的描述清晰度。"
    },
    {
      "defect_id": 480503,
      "sentence": "获取指定应用账号的凭据。使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 3803,
      "context": "{\"3798\":\"\",\"3799\":\"### getAccountCredential<sup>(deprecated)</sup>\",\"3800\":\"\",\"3801\":\"getAccountCredential(name: string, credentialType: string, callback: AsyncCallback&lt;string&gt;): void\",\"3802\":\"\",\"3803\":\"获取指定应用账号的凭据。使用callback异步回调。\",\"3804\":\"\",\"3805\":\"> **说明：** \",\"3806\":\">\",\"3807\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getCredential](#getcredential9)替代。\",\"3808\":\"\"}",
      "用户拒绝的修改": "获取指定应用账号的凭据。使用callback回调。",
      "注意事项": "保留与API参数类型直接相关的关键术语（如\"AsyncCallback\"对应的\"异步\"描述），避免因术语不匹配触发工具校验；冗余判断需区分技术规范用词和普通修饰语，优先遵循接口定义中的命名一致性。"
    },
    {
      "defect_id": 479883,
      "sentence": "定义用于构造插件组件的选项。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"| ------- | ----------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"31\":\"| options | [PluginComponentOptions](#plugincomponentoptions18类型说明) | 是   | 定义用于构造插件组件的选项。 |\",\"32\":\"\",\"33\":\"## PluginComponentOptions<sup>18+</sup>类型说明\",\"34\":\"\",\"35\":\"定义用于构造插件组件的选项。\",\"36\":\"\",\"37\":\"| 参数       | 类型   | 描述                        |\",\"38\":\"| ---------- | ------ | --------------------------- |\",\"39\":\"| template   | [PluginComponentTemplate](#plugincomponenttemplate9类型说明) | 组件模板，用于跟提供方定义的组件绑定。                |\",\"40\":\"| data       | any    | 传给插件组件提供方使用的数据。 |\"}",
      "用户拒绝的修改": "定义构造插件组件的选项。",
      "注意事项": "修复技术文档冗余表达时应优先保留功能性介词结构（如\"用于\"），确保参数定义与上下文术语保持严格一致，避免过度简化导致用途描述不清晰。"
    },
    {
      "defect_id": 480377,
      "sentence": "回调函数。当获取凭据成功时，err为null，data为指定应用账号的凭据；否则为错误对象。",
      "reference_sentence": "",
      "line_num": 890,
      "context": "{\"885\":\"\",\"886\":\"| 参数名            | 类型                          | 必填   | 说明             |\",\"887\":\"| -------------- | --------------------------- | ---- | -------------- |\",\"888\":\"| name           | string                      | 是    | 应用账号的名称。        |\",\"889\":\"| credentialType | string                      | 是    | 凭据类型。 |\",\"890\":\"| callback       | AsyncCallback&lt;string&gt; | 是    | 回调函数。当获取凭据成功时，err为null，data为指定应用账号的凭据；否则为错误对象。 |\",\"891\":\"\",\"892\":\"**错误码：**\",\"893\":\"\",\"894\":\"| 错误码ID | 错误信息 |\",\"895\":\"| ------- | ------- |\"}",
      "用户拒绝的修改": "回调函数。成功时，err为null，data为凭据；失败时，返回错误对象。",
      "注意事项": "保留必要的技术限定词（如\"指定应用账号的\"），避免过度简化导致技术信息丢失；需结合参数表中credentialType字段上下文，确保修改后的描述仍能准确对应参数类型。"
    },
    {
      "defect_id": 480487,
      "sentence": "从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9)替代。",
      "reference_sentence": "",
      "line_num": 3232,
      "context": "{\"3227\":\"\",\"3228\":\"允许指定第三方应用账号名称对指定包名称的第三方应用进行访问。使用callback异步回调。\",\"3229\":\"\",\"3230\":\"> **说明：** \",\"3231\":\">\",\"3232\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9)替代。\",\"3233\":\"\",\"3234\":\"**系统能力：** SystemCapability.Account.AppAccount\",\"3235\":\"\",\"3236\":\"**参数：**\",\"3237\":\"\"}",
      "用户拒绝的修改": "从API version 7开始支持。从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9)。",
      "注意事项": "修复冗余表达时应优先保持原句逻辑连贯性，仅在确实存在重复用词或冗余结构时调整标点，避免将合理的长句拆分破坏技术文档的严谨性。修改前需确认标点改动是否真正提升可读性，而非机械拆分句子。"
    },
    {
      "defect_id": 480780,
      "sentence": "以下各项对应的系统能力均为SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 379,
      "context": "{\"374\":\"\",\"375\":\"## DistributedAccountStatus<sup>10+</sup>\",\"376\":\"\",\"377\":\"表示分布式账号状态枚举。\",\"378\":\"\",\"379\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.OsAccount\",\"380\":\"\",\"381\":\"| 名称  | 值 | 说明        |\",\"382\":\"| ---- | ------ | ----------- |\",\"383\":\"| NOT_LOGGED_IN   | 0  | 未登录状态。 |\",\"384\":\"| LOGGED_IN  | 1  | 已登录状态。 |\"}",
      "用户拒绝的修改": "各项系统能力均为SystemCapability.Account.OsAccount",
      "注意事项": "修复冗余表达时应保留必要的上下文衔接词（如\"以下各项对应的\"），避免因过度简化破坏文档结构指代关系，需结合具体语境判断信息完整性优先级。"
    },
    {
      "defect_id": 480526,
      "sentence": "表示OAuth令牌信息。",
      "reference_sentence": "",
      "line_num": 4849,
      "context": "{\"4844\":\"| token<sup>9+</sup>                | string         | 是    | 令牌的取值。       |\",\"4845\":\"| account<sup>9+</sup> | [AppAccountInfo](#appaccountinfo) | 否    | 令牌所属的账号信息，默认为空。|\",\"4846\":\"\",\"4847\":\"## OAuthTokenInfo<sup>(deprecated)</sup>\",\"4848\":\"\",\"4849\":\"表示OAuth令牌信息。\",\"4850\":\"\",\"4851\":\"> **说明：** \",\"4852\":\">\",\"4853\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[AuthTokenInfo](#authtokeninfo9)替代。\",\"4854\":\"\"}",
      "用户拒绝的修改": "表示OAuth令牌的信息。",
      "注意事项": "修复冗余表达时需优先保持专业术语的完整性，避免拆分固定搭配；同时要验证修改后的表述是否符合自动化工具的语法检测规范，防止因添加冗余助词导致工具扫描异常。"
    },
    {
      "defect_id": 480524,
      "sentence": "表示应用账号信息。",
      "reference_sentence": "",
      "line_num": 4826,
      "context": "{\"4821\":\"  });\",\"4822\":\"  ```\",\"4823\":\"\",\"4824\":\"## AppAccountInfo\",\"4825\":\"\",\"4826\":\"表示应用账号信息。\",\"4827\":\"\",\"4828\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4829\":\"\",\"4830\":\"| 名称   | 类型     | 必填   | 说明          |\",\"4831\":\"| ----- | ------ | ---- | ----------- |\"}",
      "用户拒绝的修改": "表示应用账号的信息。",
      "注意事项": "保持术语简洁性时需优先维护文档工具兼容性，确保修改后的表达既符合自然语言规范又能通过自动化检测，避免拆分行业通用复合词（如\"账号信息\"）。"
    },
    {
      "defect_id": 480530,
      "sentence": "表示隐式创建账号的选项。",
      "reference_sentence": "",
      "line_num": 4897,
      "context": "{\"4892\":\"| ------- | ------ | ---- | ---------- |\",\"4893\":\"| customData   | Record<string, string> | 否    | 自定义数据，默认为空。 |\",\"4894\":\"\",\"4895\":\"## CreateAccountImplicitlyOptions<sup>9+</sup>\",\"4896\":\"\",\"4897\":\"表示隐式创建账号的选项。\",\"4898\":\"\",\"4899\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4900\":\"\",\"4901\":\"| 名称     | 类型     | 必填   | 说明         |\",\"4902\":\"| ------- | ------ | ---- | ---------- |\"}",
      "用户拒绝的修改": "隐式创建账号的选项。",
      "注意事项": "在简化冗余表达时需优先保持技术文档的结构完整性，特别注意保留自动化工具扫描依赖的关键动词（如\"表示\"）和固定句式，避免破坏文档解析逻辑。"
    },
    {
      "defect_id": 480399,
      "sentence": "取消订阅账号信息变更事件。",
      "reference_sentence": "",
      "line_num": 1396,
      "context": "{\"1391\":\"\",\"1392\":\"### off('accountChange')<sup>9+</sup>\",\"1393\":\"\",\"1394\":\"off(type: 'accountChange', callback?: Callback&lt;Array&lt;AppAccountInfo&gt;&gt;): void\",\"1395\":\"\",\"1396\":\"取消订阅账号信息变更事件。\",\"1397\":\"\",\"1398\":\"**系统能力：** SystemCapability.Account.AppAccount\",\"1399\":\"\",\"1400\":\"**参数：**\",\"1401\":\"\"}",
      "用户拒绝的修改": "取消订阅账号信息变更。",
      "注意事项": "修复冗余表达时必须优先保留技术领域专有术语（如\"事件\"在API上下文中属于核心概念），并严格对照上下文代码中的方法命名（如'accountChange'）确保术语一致性。"
    },
    {
      "defect_id": 480486,
      "sentence": "从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)替代。",
      "reference_sentence": "",
      "line_num": 3195,
      "context": "{\"3190\":\"\",\"3191\":\"禁止指定第三方应用账号名称对指定包名称的第三方应用进行访问。使用Promise异步回调。\",\"3192\":\"\",\"3193\":\"> **说明：** \",\"3194\":\">\",\"3195\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)替代。\",\"3196\":\"\",\"3197\":\"**系统能力：** SystemCapability.Account.AppAccount\",\"3198\":\"\",\"3199\":\"**参数：**\",\"3200\":\"\"}",
      "用户拒绝的修改": "从API version 7开始支持。从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)。",
      "注意事项": "修复时应优先保持技术信息的连贯性，避免过度拆分紧密关联的API版本说明；调整标点前需确认上下文格式规范，确保技术文档中时间线表述的完整性优于句式简洁性。"
    },
    {
      "defect_id": 480525,
      "sentence": "表示Auth令牌信息。",
      "reference_sentence": "",
      "line_num": 4837,
      "context": "{\"4832\":\"| owner | string | 是    | 应用账号所有者的包名。 |\",\"4833\":\"| name  | string | 是    | 应用账号的名称。    |\",\"4834\":\"\",\"4835\":\"## AuthTokenInfo<sup>9+</sup>\",\"4836\":\"\",\"4837\":\"表示Auth令牌信息。\",\"4838\":\"\",\"4839\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4840\":\"\",\"4841\":\"| 名称               | 类型            | 必填  | 说明              |\",\"4842\":\"| -------------------- | -------------- | ----- | ---------------- |\"}",
      "用户拒绝的修改": "表示Auth令牌的信息。",
      "注意事项": "修复冗余表达时需严格检查技术文档的术语一致性，避免因添加助词（如“的”）破坏工具扫描规则；优先保留原文简洁性，仅在影响语义明确时调整措辞。"
    },
    {
      "defect_id": 480401,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types.",
      "reference_sentence": "",
      "line_num": 1455,
      "context": "{\"1450\":\"\",\"1451\":\"**错误码：**\",\"1452\":\"\",\"1453\":\"| 错误码ID | 错误信息|\",\"1454\":\"| ------- | -------|\",\"1455\":\"| 401 |Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. |\",\"1456\":\"| 12300001 | System service exception. |\",\"1457\":\"| 12300002 | Invalid name, owner or authType. |\",\"1458\":\"| 12300003 | Account not found. |\",\"1459\":\"| 12300010 | Account service busy. |\",\"1460\":\"| 12300113 | Authenticator service not found. |\"}",
      "用户拒绝的修改": "参数错误。可能原因：1. 必填参数未指定。2. 参数类型错误。",
      "注意事项": "在简化冗余表达时需优先保持技术术语的准确性，避免因过度精简导致语义偏差；修改前需核对上下文术语一致性，确保不破坏原有技术含义和文档规范。"
    },
    {
      "defect_id": 480528,
      "sentence": "表示认证结果信息。",
      "reference_sentence": "",
      "line_num": 4876,
      "context": "{\"4871\":\"| iconId  | number | 是    | 认证器的图标标识。  |\",\"4872\":\"| labelId | number | 是    | 认证器的标签标识。  |\",\"4873\":\"\",\"4874\":\"## AuthResult<sup>9+</sup>\",\"4875\":\"\",\"4876\":\"表示认证结果信息。\",\"4877\":\"\",\"4878\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4879\":\"\",\"4880\":\"| 名称     | 类型     | 必填   | 说明         |\",\"4881\":\"| ------- | ------ | ---- | ---------- |\"}",
      "用户拒绝的修改": "表示认证结果的信息。",
      "注意事项": "修复冗余表达时应优先保持术语一致性，避免添加冗余助词（如“的”）破坏工具扫描规则，需结合上下文确认是否属于固定名词短语或规范表述。"
    },
    {
      "defect_id": 480488,
      "sentence": "从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)替代。",
      "reference_sentence": "",
      "line_num": 3266,
      "context": "{\"3261\":\"\",\"3262\":\"允许指定第三方应用账号的名称对指定包名称的第三方应用进行访问。使用Promise异步回调。\",\"3263\":\"\",\"3264\":\"> **说明：** \",\"3265\":\">\",\"3266\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)替代。\",\"3267\":\"\",\"3268\":\"**系统能力：** SystemCapability.Account.AppAccount\",\"3269\":\"\",\"3270\":\"**参数：**\",\"3271\":\"\"}",
      "用户拒绝的修改": "从API version 7开始支持。从API version 9开始废弃。建议使用[setAppAccess](#setappaccess9-1)。",
      "注意事项": "修复冗余表达时应优先保持技术说明的语义连贯性，避免过度拆分导致上下文割裂；需准确区分复杂句与冗余表达，仅在确实存在重复信息或影响可读性时调整标点结构。"
    },
    {
      "defect_id": 480529,
      "sentence": "表示创建账号的选项。",
      "reference_sentence": "",
      "line_num": 4887,
      "context": "{\"4882\":\"| account   | [AppAccountInfo](#appaccountinfo) | 否    | 令牌所属的账号信息，默认为空。 |\",\"4883\":\"| tokenInfo  | [AuthTokenInfo](#authtokeninfo9) | 否    | 令牌信息，默认为空。  |\",\"4884\":\"\",\"4885\":\"## CreateAccountOptions<sup>9+</sup>\",\"4886\":\"\",\"4887\":\"表示创建账号的选项。\",\"4888\":\"\",\"4889\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4890\":\"\",\"4891\":\"| 名称     | 类型     | 必填   | 说明         |\",\"4892\":\"| ------- | ------ | ---- | ---------- |\"}",
      "用户拒绝的修改": "创建账号的选项。",
      "注意事项": "在简化冗余表达时需保留技术文档必要的术语完整性，特别注意\"表示\"在类/结构体定义中的规范性作用，同时验证修改后的表述是否符合自动化工具对API文档结构的扫描要求。"
    },
    {
      "defect_id": 480527,
      "sentence": "表示OAuth认证器信息。",
      "reference_sentence": "",
      "line_num": 4864,
      "context": "{\"4859\":\"| authType             | string         | 是    | 令牌的鉴权类型。   |\",\"4860\":\"| token                | string         | 是    | 令牌的取值。       |\",\"4861\":\"\",\"4862\":\"## AuthenticatorInfo<sup>8+</sup>\",\"4863\":\"\",\"4864\":\"表示OAuth认证器信息。\",\"4865\":\"\",\"4866\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4867\":\"\",\"4868\":\"| 名称     | 类型     | 必填   | 说明         |\",\"4869\":\"| ------- | ------ | ---- | ---------- |\"}",
      "用户拒绝的修改": "表示OAuth认证器的信息。",
      "注意事项": "保持技术文档术语的固定结构完整性，避免添加冗余助词破坏工具扫描规则；优先采用行业标准表述方式，修改时需验证是否符合自动化检测工具的词法规范。"
    },
    {
      "defect_id": 480533,
      "sentence": "表示用于设置属性的选项。",
      "reference_sentence": "",
      "line_num": 4933,
      "context": "{\"4928\":\"| parameters     | Record<string, Object> | 否    | 自定义参数对象，默认为空。 |\",\"4929\":\"\",\"4930\":\"\",\"4931\":\"## SetPropertiesOptions<sup>9+</sup>\",\"4932\":\"\",\"4933\":\"表示用于设置属性的选项。\",\"4934\":\"\",\"4935\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4936\":\"\",\"4937\":\"| 名称     | 类型                    | 必填  | 说明           |\",\"4938\":\"| ---------- | ---------------------- | ----- | -------------- |\"}",
      "用户拒绝的修改": "设置属性的选项。",
      "注意事项": "在简化冗余表达时需保留技术文档中的固定结构术语（如\"表示\"），避免破坏自动化工具依赖的语法模式，同时优先确保专业场景的规范性表达要求。"
    },
    {
      "defect_id": 482665,
      "sentence": "从上图可以看出，账号管理模块是以系统账号为核心，其他类型账号与系统账号存在关联关系。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"## 各类账号间的关系\",\"20\":\"\",\"21\":\"![account_er](figures/account_er.png)\",\"22\":\"\",\"23\":\"从上图可以看出，账号管理模块是以系统账号为核心，其他类型账号与系统账号存在关联关系。\",\"24\":\"\",\"25\":\"- 域账号与系统账号存在一对一关联关系，两者的生命周期一致。\",\"26\":\"- 分布式账号与系统账号存在一对多关联关系，用户可以在每个系统账号下绑定一个分布式账号；不同系统账号下，分布式账号可以重复。分布式账号的生命周期独立于系统账号。\",\"27\":\"- 应用账号与系统账号存在多对多关联关系，用户可以在不同系统账号下管理多个应用账号；不同系统账号下，应用账号可以重复。应用账号的生命周期独立于系统账号。\",\"28\":\"- 域账号、分布式账号和应用账号相互之间无直接关联关系。\"}",
      "用户拒绝的修改": "账号管理模块以系统账号为核心，其他类型账号与系统账号存在关联关系。",
      "注意事项": "在删除冗余表达时需保留必要上下文关联词（如\"从上图可以看出\"），确保图表引用关系不丢失；优先处理不影响信息源的冗余结构（如\"是以...为\"改为\"以...为\"）。"
    },
    {
      "defect_id": 480557,
      "sentence": "认证器Authenticator的远程对象。用于跨进程通信。",
      "reference_sentence": "",
      "line_num": 5347,
      "context": "{\"5342\":\"\",\"5343\":\"**返回值：**\",\"5344\":\"\",\"5345\":\"| 类型             | 说明                                                   |\",\"5346\":\"| ---------------- | ----------------------------------------------------- |\",\"5347\":\"| rpc.RemoteObject | 认证器Authenticator的远程对象。用于跨进程通信。          |\",\"5348\":\"\",\"5349\":\"**示例：**\",\"5350\":\"\",\"5351\":\"  <!--code_no_check-->\",\"5352\":\"  ```ts\"}",
      "用户拒绝的修改": "认证器的远程对象。用于跨进程通信。",
      "注意事项": "保留必要的技术术语完整性，当原文中的重复属于\"中文+英文\"的术语说明形式时，应使用括号标注（如\"认证器(Authenticator)\"），避免直接删除导致工具扫描依赖的类名/接口名丢失。"
    },
    {
      "defect_id": 481630,
      "sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.data.dataShare (数据共享)\",\"2\":\"\",\"3\":\"**DataShare**用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。\",\"4\":\"\",\"5\":\"> **说明：** \",\"6\":\">\",\"7\":\"> - 本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\">\"}",
      "用户拒绝的修改": "DataShare用于管理应用数据，支持同设备上的应用间数据共享。",
      "注意事项": "修复冗余表达时需优先核对上下文中的专业术语和系统接口定义，保留与官方文档保持一致的固定表述（如\"应用管理其自身数据\"），避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 480532,
      "sentence": "表示用于验证凭据的选项。",
      "reference_sentence": "",
      "line_num": 4920,
      "context": "{\"4915\":\"| allowedOwners   | Array&lt;string&gt;         | 否    | 允许的账号所有者数组，默认为空。 |\",\"4916\":\"| requiredLabels  | Array&lt;string&gt;         | 否    | 认证器的标签标识，默认为空。  |\",\"4917\":\"\",\"4918\":\"## VerifyCredentialOptions<sup>9+</sup>\",\"4919\":\"\",\"4920\":\"表示用于验证凭据的选项。\",\"4921\":\"\",\"4922\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4923\":\"\",\"4924\":\"| 名称          | 类型                   | 必填  | 说明           |\",\"4925\":\"| -------------- | ---------------------- | ----- | -------------- |\"}",
      "用户拒绝的修改": "验证凭据的选项。",
      "注意事项": "修复冗余表达时应优先保留文档上下文中的固定结构关键词（如“表示”），避免破坏自动化工具依赖的语法模板或占位符格式。"
    },
    {
      "defect_id": 480534,
      "sentence": "表示常量的枚举。",
      "reference_sentence": "",
      "line_num": 4944,
      "context": "{\"4939\":\"| properties | Record<string, Object> | 否    | 属性对象，默认为空。      |\",\"4940\":\"| parameters | Record<string, Object> | 否    | 自定义参数对象，默认为空。 |\",\"4941\":\"\",\"4942\":\"## Constants<sup>8+</sup>\",\"4943\":\"\",\"4944\":\"表示常量的枚举。\",\"4945\":\"\",\"4946\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4947\":\"\",\"4948\":\"| 名称                            | 值                    | 说明                   |\",\"4949\":\"| -------------------------------- | ---------------------- | ----------------------- |\"}",
      "用户拒绝的修改": "常量的枚举。",
      "注意事项": "在修复冗余表达时需优先确认术语完整性，避免删除工具依赖的关键词（如“表示”可能为自动化标记所需），并检查简化后的文本是否仍符合文档工具的结构化扫描规则。"
    },
    {
      "defect_id": 480531,
      "sentence": "表示用于选择账号的选项。",
      "reference_sentence": "",
      "line_num": 4908,
      "context": "{\"4903\":\"| requiredLabels   | Array&lt;string&gt; | 否    | 所需的标签，默认为空。 |\",\"4904\":\"| authType   | string | 否    | 鉴权类型，默认为空。 |\",\"4905\":\"| parameters   | Record<string, Object> | 否    | 自定义参数对象，默认为空。 |\",\"4906\":\"## SelectAccountsOptions<sup>9+</sup>\",\"4907\":\"\",\"4908\":\"表示用于选择账号的选项。\",\"4909\":\"\",\"4910\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\",\"4911\":\"\",\"4912\":\"| 名称          | 类型                         | 必填  | 说明                |\",\"4913\":\"| --------------- | --------------------------- | ----- | ------------------- |\"}",
      "用户拒绝的修改": "选择账号的选项。",
      "注意事项": "修复冗余表达时必须保留文档中术语定义的固定句式结构（如\"表示...\"），并提前验证修改后的文本是否符合工具链的自动化扫描规则（如占位符、关键词匹配等）。"
    },
    {
      "defect_id": 480552,
      "sentence": "表示返回码的枚举。",
      "reference_sentence": "",
      "line_num": 4970,
      "context": "{\"4965\":\"| KEY_REQUIRED_LABELS<sup>9+</sup> | 'requiredLabels'       | 表示键名，必需的标签。    |\",\"4966\":\"| KEY_BOOLEAN_RESULT<sup>9+</sup>  | 'booleanResult'        | 表示键名，布尔返回值。    |\",\"4967\":\"\",\"4968\":\"## ResultCode<sup>(deprecated)</sup>\",\"4969\":\"\",\"4970\":\"表示返回码的枚举。\",\"4971\":\"\",\"4972\":\"> **说明：**<br/>\",\"4973\":\"> 从API version 8开始支持，从API version 9开始废弃。相关信息建议查看[错误码文档](errorcode-account.md)替代。\",\"4974\":\"\",\"4975\":\"**系统能力：** 以下各项对应的系统能力均为SystemCapability.Account.AppAccount。\"}",
      "用户拒绝的修改": "表示返回码。",
      "注意事项": "修复冗余表达时需保留与上下文结构一致的关键术语（如“枚举”），避免破坏自动化工具依赖的文档格式或术语规范；优先检查相邻条目描述模式，确保修改后的句子与其他条目保持语法和术语统一性。"
    },
    {
      "defect_id": 482768,
      "sentence": "2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定分布式账号与当前系统账号绑定。",
      "reference_sentence": "",
      "line_num": 94,
      "context": "{\"89\":\"       id: '12345',\",\"90\":\"       event: 'Ohos.account.event.LOGIN',\",\"91\":\"   };\",\"92\":\"   ```\",\"93\":\"\",\"94\":\"2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定分布式账号与当前系统账号绑定。\",\"95\":\"\",\"96\":\"   ```ts\",\"97\":\"   distributedAccountAbility.setOsAccountDistributedInfoByLocalId(localId, distributedInfo).then(() => {\",\"98\":\"       console.log('setOsAccountDistributedInfoByLocalId successfully');\",\"99\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "2. 调用setOsAccountDistributedInfoByLocalId接口，绑定分布式账号",
      "注意事项": "修复冗余表达时应优先保留技术文档中必要的跳转链接格式（如[接口名](链接)），避免破坏API引用规范；简化修饰成分时需确保不删除关键上下文信息（如接口绑定对象）。"
    },
    {
      "defect_id": 482769,
      "sentence": "3. 在账号绑定之后，可以调用[getOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#getosaccountdistributedinfobylocalid10)接口查看分布式账号的登录信息。",
      "reference_sentence": "",
      "line_num": 104,
      "context": "{\"99\":\"   }).catch((err: BusinessError) => {\",\"100\":\"       console.error('setOsAccountDistributedInfoByLocalId exception: '  + JSON.stringify(err));\",\"101\":\"   });\",\"102\":\"   ```\",\"103\":\"\",\"104\":\"3. 在账号绑定之后，可以调用[getOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#getosaccountdistributedinfobylocalid10)接口查看分布式账号的登录信息。\",\"105\":\"\",\"106\":\"   ```ts\",\"107\":\"   distributedAccountAbility.getOsAccountDistributedInfoByLocalId(localId).then((data: distributedAccount.DistributedInfo) => {\",\"108\":\"       console.log('distributed information: ' + JSON.stringify(data));\",\"109\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "3. 调用getOsAccountDistributedInfoByLocalId接口，查看分布式账号信息",
      "注意事项": "修复冗余表达时必须保留文档中跳转链接的固定语法格式（如`[接口名](路径)`），避免因过度简化破坏技术文档的规范性和功能性。"
    },
    {
      "defect_id": 482733,
      "sentence": "3. 调用[getAuthToken](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getauthtoken9)接口，获取指定授权类型的授权令牌。",
      "reference_sentence": "",
      "line_num": 150,
      "context": "{\"145\":\"   }).catch((err: BusinessError) => {\",\"146\":\"       console.error('setAuthToken failed: ' + JSON.stringify(err));\",\"147\":\"   });\",\"148\":\"   ```\",\"149\":\"\",\"150\":\"3. 调用[getAuthToken](../../reference/apis-basic-services-kit/js-apis-appAccount.md#getauthtoken9)接口，获取指定授权类型的授权令牌。\",\"151\":\"\",\"152\":\"   ```ts\",\"153\":\"   appAccountManager.getAuthToken(name, owner, authType).then((data: string) => {\",\"154\":\"       console.log('getAuthToken successfully, data: ' + data);\",\"155\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "调用[getAuthToken]接口，获取授权令牌。",
      "注意事项": "保留技术文档中固定格式的超链接路径结构，避免因简化文本导致跳转功能失效；在消除冗余时应优先确保技术要素（如接口参数、引用路径）的完整性。"
    },
    {
      "defect_id": 482664,
      "sentence": "账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。按照使用场景，账号模块负责管理以下类别的账号：",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"系统支持在一台设备上创建多个本地系统账号，以允许多个用户使用同一台设备。多个用户的数据按系统账号进行隔离，以保证不同用户数据的安全性。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"账号是用户身份的标识，不同场景下用户身份存在差异，同一用户往往存在多种账号。按照使用场景，账号模块负责管理以下类别的账号：\",\"10\":\"\",\"11\":\"- 系统账号：表示用户在端侧设备上的身份标识，该标识在每个端侧设备上唯一。\",\"12\":\"\",\"13\":\"- 域账号：表示用户在特定域内（比如公司、学校等）的身份标识，该标识在特定域内唯一。\",\"14\":\"\"}",
      "用户拒绝的修改": "账号模块管理以下类别的用户身份标识：",
      "注意事项": "在简化冗余表达时应优先保留原文中具有解释功能的上下文信息（如\"不同场景下用户身份存在差异\"），避免过度删减导致概念定义不完整；需平衡简洁性与概念传达的完整性，确保专业术语（如\"用户身份标识\"）在首次出现时保留必要的前置说明。"
    },
    {
      "defect_id": 482732,
      "sentence": "2. 调用[setAuthToken](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setauthtoken9)接口，设置指定授权类型的授权令牌。",
      "reference_sentence": "",
      "line_num": 140,
      "context": "{\"135\":\"   let owner: string = 'com.example.accountjsdemo';\",\"136\":\"   let authType: string = 'getSocialData';\",\"137\":\"   let token: string = 'xxxxxx';\",\"138\":\"   ```\",\"139\":\"\",\"140\":\"2. 调用[setAuthToken](../../reference/apis-basic-services-kit/js-apis-appAccount.md#setauthtoken9)接口，设置指定授权类型的授权令牌。\",\"141\":\"\",\"142\":\"   ```ts\",\"143\":\"   appAccountManager.setAuthToken(name, authType, token).then(() => {\",\"144\":\"       console.log('setAuthToken successfully');\",\"145\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "调用[setAuthToken]接口，设置授权令牌。",
      "注意事项": "保留Markdown链接的完整路径和锚点信息，避免破坏文档跳转功能；在简化冗余表达时需区分技术文档固定格式与普通文本，优先保证API引用语法的正确性。"
    },
    {
      "defect_id": 482753,
      "sentence": "具体开发实例如下：",
      "reference_sentence": "",
      "line_num": 57,
      "context": "{\"52\":\"   });\",\"53\":\"   ```\",\"54\":\"\",\"55\":\"## 在当前系统账号上登出解绑分布式账号\",\"56\":\"\",\"57\":\"具体开发实例如下：\",\"58\":\"\",\"59\":\"1. 定义待登出的分布式账号信息。其中，登录场景下需将event指定为\\\"Ohos.account.event.LOGOUT\\\"。\",\"60\":\"\",\"61\":\"   ```ts\",\"62\":\"   let distributedInfo: distributedAccount.DistributedInfo = {\"}",
      "用户拒绝的修改": "开发实例：",
      "注意事项": "在精简冗余表达时需优先确认上下文衔接功能，避免因过度简化破坏文档结构连贯性；对于用户可能存在主观判断的表述（如“具体”等修饰词），应保留原句或提供多版本建议供选择。"
    },
    {
      "defect_id": 482766,
      "sentence": "## 在指定的系统账号上登录绑定分布式账号",
      "reference_sentence": "",
      "line_num": 79,
      "context": "{\"74\":\"   }).catch((err: BusinessError) => {\",\"75\":\"       console.error('setOsAccountDistributedInfo exception: '  + JSON.stringify(err));\",\"76\":\"   });\",\"77\":\"   ```\",\"78\":\"\",\"79\":\"## 在指定的系统账号上登录绑定分布式账号\",\"80\":\"\",\"81\":\"具体开发实例如下：\",\"82\":\"\",\"83\":\"1. 确定目标系统账号，并定义待登录的分布式账号信息。其中，登录场景下需将event指定为\\\"Ohos.account.event.LOGIN\\\"。\",\"84\":\"\"}",
      "用户拒绝的修改": "## 登录并绑定分布式账号",
      "注意事项": "修复冗余表达时应优先保留技术文档中的必要条件和关键操作前提（如\"指定的系统账号\"），避免因过度简化导致核心信息丢失；需结合上下文判断修饰成分是否影响技术准确性，不可仅凭语感删减。"
    },
    {
      "defect_id": 482669,
      "sentence": "域账号、分布式账号和应用账号相互之间无直接关联关系。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"从上图可以看出，账号管理模块是以系统账号为核心，其他类型账号与系统账号存在关联关系。\",\"24\":\"\",\"25\":\"- 域账号与系统账号存在一对一关联关系，两者的生命周期一致。\",\"26\":\"- 分布式账号与系统账号存在一对多关联关系，用户可以在每个系统账号下绑定一个分布式账号；不同系统账号下，分布式账号可以重复。分布式账号的生命周期独立于系统账号。\",\"27\":\"- 应用账号与系统账号存在多对多关联关系，用户可以在不同系统账号下管理多个应用账号；不同系统账号下，应用账号可以重复。应用账号的生命周期独立于系统账号。\",\"28\":\"- 域账号、分布式账号和应用账号相互之间无直接关联关系。\",\"29\":\"\",\"30\":\"删除系统账号后，与之关联的域账号、分布式账号和应用账号也随之删除。\",\"31\":\"\",\"32\":\"## 相关实例\",\"33\":\"\"}",
      "用户拒绝的修改": "域账号、分布式账号和应用账号无直接关联。",
      "注意事项": "修复冗余表达时需优先保持术语一致性（如\"关联关系\"为上下文固定搭配），并保留强调双向关系的\"相互之间\"等关键限定词避免语义模糊。"
    },
    {
      "defect_id": 482770,
      "sentence": "## 在指定系统账号上登出解绑分布式账号",
      "reference_sentence": "",
      "line_num": 114,
      "context": "{\"109\":\"   }).catch((err: BusinessError) => {\",\"110\":\"       console.error('getOsAccountDistributedInfoByLocalId exception: '  + JSON.stringify(err));\",\"111\":\"   });\",\"112\":\"   ```\",\"113\":\"\",\"114\":\"## 在指定系统账号上登出解绑分布式账号\",\"115\":\"\",\"116\":\"具体开发实例如下：\",\"117\":\"\",\"118\":\"1. 确定目标系统账号，并定义待登出的分布式账号信息。其中，登录场景下需将event指定为\\\"Ohos.account.event.LOGOUT\\\"。\",\"119\":\"\"}",
      "用户拒绝的修改": "## 登出并解绑分布式账号",
      "注意事项": "在简化冗余表达时应优先保留技术文档中的关键限定条件（如\"指定系统账号\"），避免因过度简化丢失必要的操作前提；处理技术标题时需结合上下文代码逻辑判断信息必要性，技术文档的准确性优先级高于语言简洁性。"
    },
    {
      "defect_id": 482901,
      "sentence": "2. 定义待更新凭据信息。",
      "reference_sentence": "",
      "line_num": 225,
      "context": "{\"220\":\"\",\"221\":\"具体开发实例如下：\",\"222\":\"\",\"223\":\"1. 认证PIN码，获取授权令牌authToken。\",\"224\":\"\",\"225\":\"2. 定义待更新凭据信息。\",\"226\":\"\",\"227\":\"   ```ts\",\"228\":\"   let credentialInfo: osAccount.CredentialInfo = {\",\"229\":\"     credType: osAccount.AuthType.PIN,\",\"230\":\"     credSubType: osAccount.AuthSubType.PIN_SIX,\"}",
      "用户拒绝的修改": "定义待更新凭据信息。",
      "注意事项": "修复冗余表达时必须保留结构性序号或格式标记，仅简化重复的实质性内容，避免破坏文档的列表层级和编号体系。"
    },
    {
      "defect_id": 482817,
      "sentence": "1. 定义域账号信息，指定域名、账号名、账号标识（可选）。",
      "reference_sentence": "",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"用户在设置中添加其他域账号，允许其他域账号用户使用同一设备。开发者可以使用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)完成此操作。\",\"51\":\"\",\"52\":\"具体开发实例如下：\",\"53\":\"\",\"54\":\"1. 定义域账号信息，指定域名、账号名、账号标识（可选）。\",\"55\":\"\",\"56\":\"   ```ts\",\"57\":\"   let domainInfo: osAccount.DomainAccountInfo = {\",\"58\":\"     domain: 'testDomain',\",\"59\":\"     accountName: 'testAccountName'\"}",
      "用户拒绝的修改": "定义域账号信息。指定域名、账号名、账号标识（可选）。",
      "注意事项": "保持原句逻辑连贯性，避免过度拆分导致信息碎片化；优先确认修改必要性，仅在明显冗余时调整句式结构。"
    },
    {
      "defect_id": 482897,
      "sentence": "2. 调用auth接口进行认证。",
      "reference_sentence": "",
      "line_num": 205,
      "context": "{\"200\":\"   let challenge: Uint8Array = new Uint8Array([1, 2, 3, 4, 5]);\",\"201\":\"   let authType: osAccount.AuthType = osAccount.AuthType.FACE;\",\"202\":\"   let authTrustLevel: osAccount.AuthTrustLevel = osAccount.AuthTrustLevel.ATL1;\",\"203\":\"   ```\",\"204\":\"\",\"205\":\"2. 调用auth接口进行认证。\",\"206\":\"\",\"207\":\"   ```ts\",\"208\":\"   let userAuth: osAccount.UserAuth = new osAccount.UserAuth();\",\"209\":\"   userAuth.auth(challenge, authType, authTrustLevel, {\",\"210\":\"     onResult: (result: number, extraInfo: osAccount.AuthResult) => {\"}",
      "用户拒绝的修改": "调用auth接口进行认证。",
      "注意事项": "修复冗余表达时需保留必要结构性元素（如步骤序号），避免破坏文档逻辑顺序；需结合上下文判断冗余范围，确保不误删功能性标记或关键格式符号。"
    },
    {
      "defect_id": 482899,
      "sentence": "具体开发实例如下：",
      "reference_sentence": "",
      "line_num": 221,
      "context": "{\"216\":\"\",\"217\":\"## 更新凭据\",\"218\":\"\",\"219\":\"用户可以修改系统账号的凭据。开发者可以使用[updateCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#updatecredential8)接口完成此操作。\",\"220\":\"\",\"221\":\"具体开发实例如下：\",\"222\":\"\",\"223\":\"1. 认证PIN码，获取授权令牌authToken。\",\"224\":\"\",\"225\":\"2. 定义待更新凭据信息。\",\"226\":\"\"}",
      "用户拒绝的修改": "开发实例如下：",
      "注意事项": "在判断冗余表达时需结合上下文确认重复词汇的实际功能（如结构标记或强调作用），避免将必要的限定词或引导词误判为冗余；若修改后可能导致语义模糊或破坏文档逻辑连贯性，应优先保留原表达。"
    },
    {
      "defect_id": 482902,
      "sentence": "3. 调用[updateCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#updatecredential8)更新凭据。",
      "reference_sentence": "",
      "line_num": 235,
      "context": "{\"230\":\"     credSubType: osAccount.AuthSubType.PIN_SIX,\",\"231\":\"     token: new Uint8Array([1, 2, 3, 4, 5])\",\"232\":\"   };\",\"233\":\"   ```\",\"234\":\"\",\"235\":\"3. 调用[updateCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#updatecredential8)更新凭据。\",\"236\":\"\",\"237\":\"   ```ts\",\"238\":\"   userIDM.updateCredential(credentialInfo, {\",\"239\":\"     onResult: (result: number, extraInfo: osAccount.RequestResult) => {\",\"240\":\"       console.log('updateCredential result = ' + result);\"}",
      "用户拒绝的修改": "调用[updateCredential]接口更新凭据。",
      "注意事项": "修复冗余表达时需优先保留技术文档中的固定链接格式和语法结构，避免修改跳转路径或锚点；精简时应聚焦删除冗余修饰语而非调整已有技术元素，确保符合文档规范。"
    },
    {
      "defect_id": 482908,
      "sentence": "以删除指纹凭据为例，具体开发实例如下：",
      "reference_sentence": "",
      "line_num": 268,
      "context": "{\"263\":\"\",\"264\":\"## 删除凭据\",\"265\":\"\",\"266\":\"删除凭据前，需要先进行[认证PIN码](#认证pin码)，并获取待删除凭据的标识（参考[查询凭据信息](#查询凭据信息)）。\",\"267\":\"\",\"268\":\"以删除指纹凭据为例，具体开发实例如下：\",\"269\":\"\",\"270\":\"1. 获取指纹类型的凭据信息。\",\"271\":\"\",\"272\":\"   ```ts\",\"273\":\"   let credentialId: Uint8Array = new Uint8Array([1, 2, 3, 4, 5]);\"}",
      "用户拒绝的修改": "删除指纹凭据的开发实例如下：",
      "注意事项": "修复冗余表达时需优先保留技术文档中常用的示例引导结构（如\"以...为例\"），避免过度简化导致上下文衔接断裂，同时应结合问题上下文确认用户是否对特定术语或句式有格式要求。"
    },
    {
      "defect_id": 482814,
      "sentence": "1. 定义待判断的域账号信息。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"在添加域账号之前，应该先判断域账号是否存在。开发者可以使用[hasAccount](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#hasaccount10)接口进行判断。\",\"26\":\"\",\"27\":\"具体开发实例如下：\",\"28\":\"\",\"29\":\"1. 定义待判断的域账号信息。\",\"30\":\"\",\"31\":\"   ```ts\",\"32\":\"   let domainAccountInfo: osAccount.DomainAccountInfo = {\",\"33\":\"     accountName: 'testAccountName',\",\"34\":\"     domain: 'testDomain'\"}",
      "用户拒绝的修改": "定义待判断的域账号信息。",
      "注意事项": "修复冗余表达时应结合上下文判断信息必要性，避免机械保留重复修饰词（如\"待判断的\"在已明确判断逻辑的上下文中冗余），优先采用\"定义域账号信息\"等简洁表达，确保技术文档的精准性和步骤描述的简洁性。"
    },
    {
      "defect_id": 482846,
      "sentence": "当插件不再使用时，开发者可以使用[unregisterPlugin](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#unregisterplugin9)接口注销插件。",
      "reference_sentence": "",
      "line_num": 164,
      "context": "{\"159\":\"   }\",\"160\":\"   ```\",\"161\":\"\",\"162\":\"## 注销插件\",\"163\":\"\",\"164\":\"当插件不再使用时，开发者可以使用[unregisterPlugin](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#unregisterplugin9)接口注销插件。\",\"165\":\"\",\"166\":\"具体开发实例如下：\",\"167\":\"\",\"168\":\"```ts\",\"169\":\"try {\"}",
      "用户拒绝的修改": "插件不再使用时，使用[unregisterPlugin](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#unregisterplugin9)接口注销插件。",
      "注意事项": "保留技术文档中必要的行为主体（如\"开发者\"），避免过度删除专业场景下的合理表述；区分冗余修饰与必要信息时应结合上下文判断，技术文档中明确行为主体的表述通常不属于冗余范畴。"
    },
    {
      "defect_id": 482906,
      "sentence": "2. 调用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口，获取指定类型的凭据信息（以指纹凭据为例）。",
      "reference_sentence": "",
      "line_num": 258,
      "context": "{\"253\":\"\",\"254\":\"   ```ts\",\"255\":\"   let enrolledCredInfoList: osAccount.EnrolledCredInfo[] = await userIDM.getAuthInfo();\",\"256\":\"   ```\",\"257\":\"\",\"258\":\"2. 调用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口，获取指定类型的凭据信息（以指纹凭据为例）。\",\"259\":\"\",\"260\":\"   ```ts\",\"261\":\"   let enrolledFingerCredInfoList: osAccount.EnrolledCredInfo[] = await userIDM.getAuthInfo(osAccount.AuthType.FINGERPRINT);\",\"262\":\"   ```\",\"263\":\"\"}",
      "用户拒绝的修改": "调用[getAuthInfo]接口，获取指定类型的凭据信息。",
      "注意事项": "修复时应保留Markdown链接完整结构（[描述文本](../../路径)），仅移除冗余的示例说明；技术文档修改需同时满足语言简洁性和格式规范性要求。"
    },
    {
      "defect_id": 482904,
      "sentence": "具体开发实例如下：",
      "reference_sentence": "",
      "line_num": 250,
      "context": "{\"245\":\"\",\"246\":\"## 查询凭据信息\",\"247\":\"\",\"248\":\"凭据管理界面需要向用户展示已录入的凭据信息；锁屏界面需要展示可认证的凭据类型。开发者可以使用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口查询已录入的凭据信息，实现前述业务场景功能。\",\"249\":\"\",\"250\":\"具体开发实例如下：\",\"251\":\"\",\"252\":\"1. 查询所有已录入的凭据信息。\",\"253\":\"\",\"254\":\"   ```ts\",\"255\":\"   let enrolledCredInfoList: osAccount.EnrolledCredInfo[] = await userIDM.getAuthInfo();\"}",
      "用户拒绝的修改": "开发实例如下：",
      "注意事项": "在简化冗余表达时，需优先确认被删除内容是否承担上下文逻辑衔接功能（如\"具体\"连接前文\"业务场景\"与后文\"实例\"），避免破坏段落语义连贯性；仅当重复内容无实际语法/逻辑作用时进行删除。"
    },
    {
      "defect_id": 482950,
      "sentence": "除了查询所有账号信息，还可以根据账号标识查询指定系统账号的详细信息。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"});\",\"68\":\"```\",\"69\":\"\",\"70\":\"## 查询指定系统账号信息\",\"71\":\"\",\"72\":\"除了查询所有账号信息，还可以根据账号标识查询指定系统账号的详细信息。\",\"73\":\"\",\"74\":\"具体开发实例如下：\",\"75\":\"\",\"76\":\"调用[queryOsAccountById](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#queryosaccountbyid)接口查询指定账号的详细信息。\",\"77\":\"\"}",
      "用户拒绝的修改": "可以查询所有账号信息，也可以根据账号标识查询指定系统账号的详细信息。",
      "注意事项": "修复时应严格区分语法冗余和合理语义强调，避免将有效逻辑关系误判为冗余；保留原句核心信息结构，仅删除重复或无实际功能的修饰成分。"
    },
    {
      "defect_id": 482818,
      "sentence": "2. 指定类型和域账号信息，调用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)接口在设备上创建一个域账号。",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"     domain: 'testDomain',\",\"59\":\"     accountName: 'testAccountName'\",\"60\":\"   };\",\"61\":\"   ```\",\"62\":\"\",\"63\":\"2. 指定类型和域账号信息，调用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)接口在设备上创建一个域账号。\",\"64\":\"\",\"65\":\"   ```ts\",\"66\":\"   try {\",\"67\":\"     osAccountMgr.createOsAccountForDomain(osAccount.OsAccountType.NORMAL, domainInfo,\",\"68\":\"     (err: BusinessError, osAccountInfo: osAccount.OsAccountInfo)=>{\"}",
      "用户拒绝的修改": "指定类型和域账号信息。调用[createOsAccountForDomain](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#createosaccountfordomain8)接口在设备上创建一个域账号。",
      "注意事项": "修复冗余表达时需优先确保技术文档中操作步骤的连贯性和逻辑完整性，避免将同一操作步骤的必要信息拆分为独立句子，导致语义断层或流程割裂；仅在明确存在重复或赘述时进行精简，不可仅因句子长度拆分技术动作描述。"
    },
    {
      "defect_id": 482905,
      "sentence": "1. 查询所有已录入的凭据信息。",
      "reference_sentence": "",
      "line_num": 252,
      "context": "{\"247\":\"\",\"248\":\"凭据管理界面需要向用户展示已录入的凭据信息；锁屏界面需要展示可认证的凭据类型。开发者可以使用[getAuthInfo](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#getauthinfo8)接口查询已录入的凭据信息，实现前述业务场景功能。\",\"249\":\"\",\"250\":\"具体开发实例如下：\",\"251\":\"\",\"252\":\"1. 查询所有已录入的凭据信息。\",\"253\":\"\",\"254\":\"   ```ts\",\"255\":\"   let enrolledCredInfoList: osAccount.EnrolledCredInfo[] = await userIDM.getAuthInfo();\",\"256\":\"   ```\",\"257\":\"\"}",
      "用户拒绝的修改": "查询所有已录入的凭据信息。",
      "注意事项": "保留必要的结构性序号或标记，在修改列表项或步骤说明时需确保不破坏原有编号体系；处理重复内容时应结合上下文判断是否属于功能示例的组成部分，避免误删关键标识。"
    },
    {
      "defect_id": 482772,
      "sentence": "2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定的分布式账号与目标系统账号解绑。",
      "reference_sentence": "",
      "line_num": 129,
      "context": "{\"124\":\"       id: '12345',\",\"125\":\"       event: 'Ohos.account.event.LOGOUT',\",\"126\":\"   };\",\"127\":\"   ```\",\"128\":\"\",\"129\":\"2. 调用[setOsAccountDistributedInfoByLocalId](../../reference/apis-basic-services-kit/js-apis-distributed-account-sys.md#setosaccountdistributedinfobylocalid10)接口，将指定的分布式账号与目标系统账号解绑。\",\"130\":\"\",\"131\":\"   ```ts\",\"132\":\"   distributedAccountAbility.setOsAccountDistributedInfoByLocalId(localId, distributedInfo).then(() => {\",\"133\":\"       console.log('setOsAccountDistributedInfoByLocalId successfully');\",\"134\":\"   }).catch((err: BusinessError) => {\"}",
      "用户拒绝的修改": "2. 调用setOsAccountDistributedInfoByLocalId接口，解绑分布式账号",
      "注意事项": "修复冗余表达时需保留技术文档中的固定跳转链接格式（如`[接口名](路径)`），仅精简冗余修饰词而非删除必要语法结构；同时需结合上下文确认接口描述是否需保留“目标系统账号”等关键技术细节。"
    },
    {
      "defect_id": 482844,
      "sentence": "1. 定义插件。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"域插件原型为[DomainPlugin](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#domainplugin9)，域插件开发者需要继承并实现插件原型中定义的接口。开发者可以使用[registerPlugin](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#registerplugin9)接口完成插件注册操作。\",\"26\":\"\",\"27\":\"具体开发实例如下：\",\"28\":\"\",\"29\":\"1. 定义插件。\",\"30\":\"\",\"31\":\"   ```ts\",\"32\":\"   let plugin: osAccount.DomainPlugin = {\",\"33\":\"     auth: (domainAccountInfo: osAccount.DomainAccountInfo, credential: Uint8Array,\",\"34\":\"            callback: osAccount.IUserAuthCallback) => {\"}",
      "用户拒绝的修改": "定义插件。",
      "注意事项": "修复冗余表达时应结合上下文判断必要性，避免在编号步骤等结构性语境中过度简化；需严格区分\"简洁性优化\"与\"规则性错误\"，仅当存在明确重复或赘述时才进行修改。"
    },
    {
      "defect_id": 482900,
      "sentence": "1. 认证PIN码，获取授权令牌authToken。",
      "reference_sentence": "",
      "line_num": 223,
      "context": "{\"218\":\"\",\"219\":\"用户可以修改系统账号的凭据。开发者可以使用[updateCredential](../../reference/apis-basic-services-kit/js-apis-osAccount-sys.md#updatecredential8)接口完成此操作。\",\"220\":\"\",\"221\":\"具体开发实例如下：\",\"222\":\"\",\"223\":\"1. 认证PIN码，获取授权令牌authToken。\",\"224\":\"\",\"225\":\"2. 定义待更新凭据信息。\",\"226\":\"\",\"227\":\"   ```ts\",\"228\":\"   let credentialInfo: osAccount.CredentialInfo = {\"}",
      "用户拒绝的修改": "认证PIN码，获取授权令牌。",
      "注意事项": "修复冗余表达时必须保留必要的结构性标记（如步骤序号），并严格检查上下文中的列表格式，避免破坏文档的步骤顺序和逻辑结构。"
    },
    {
      "defect_id": 483410,
      "sentence": "本模块首批接口从API version 7开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"本模块提供管理系统账号的基础能力，包括系统账号的添加、删除、查询、设置、订阅、启动等功能。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 本模块首批接口从API version 7开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\"\",\"9\":\"## 导入模块\",\"10\":\"\",\"11\":\"```ts\",\"12\":\"import { osAccount } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "本模块首批接口从API version 7开始支持。后续版本新增接口，使用上角标标记起始版本。",
      "注意事项": "修复冗余表达时应优先保留技术文档特有的规范术语和固定表述，避免将必要说明误判为冗余；仅在存在明确重复或赘述时进行简化，确保不改变原意或删除关键限定词（如“单独”）。"
    },
    {
      "defect_id": 483487,
      "sentence": "判断ID为100的系统账号是否处于激活状态",
      "reference_sentence": "",
      "line_num": 212,
      "context": "{\"207\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types. |\",\"208\":\"| 12300001 | The system service works abnormally. |\",\"209\":\"| 12300002 | Invalid localId.    |\",\"210\":\"| 12300003 | Account not found. |\",\"211\":\"\",\"212\":\"**示例：** 判断ID为100的系统账号是否处于激活状态\",\"213\":\"\",\"214\":\"  ```ts\",\"215\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"216\":\"  let accountManager: osAccount.AccountManager = osAccount.getAccountManager();\",\"217\":\"  let localId: number = 100;\"}",
      "用户拒绝的修改": "判断ID为100的系统账号是否激活",
      "注意事项": "修复技术文档时应优先保留专业术语的完整性，确认\"激活状态\"是否为系统定义状态名称；处理示例代码中的表述时需严格保持与API参数的对应关系，避免改变技术语义。"
    },
    {
      "defect_id": 483415,
      "sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。",
      "reference_sentence": "",
      "line_num": 136,
      "context": "{\"131\":\"\",\"132\":\"> **说明：**\",\"133\":\">\",\"134\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"135\":\"\",\"136\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"137\":\"\",\"138\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"139\":\"\",\"140\":\"**参数：**\",\"141\":\"\"}",
      "用户拒绝的修改": "ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS。仅系统应用可申请。",
      "注意事项": "保留必要的指代词确保指代明确，避免过度删除导致语义断裂（如\"以上权限\"删除后需确认上下文是否存在多权限场景）；优先采用\"删除重复主体+保留限定条件\"的修改模式（例：\"以上权限仅系统应用可申请\"→\"上述权限仅限系统应用申请\"）。"
    },
    {
      "defect_id": 483490,
      "sentence": "从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "",
      "line_num": 281,
      "context": "{\"276\":\"\",\"277\":\"判断指定系统账号是否具有指定约束。使用callback异步回调。\",\"278\":\"\",\"279\":\"> **说明：**\",\"280\":\">\",\"281\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"282\":\"\",\"283\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"284\":\"\",\"285\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"286\":\"\"}",
      "用户拒绝的修改": "从API version 9开始支持，从API version 11开始废弃。替代方法仅系统应用开放",
      "注意事项": "保留必要的介词确保语法准确性，避免过度简化导致语义偏差；修改前需结合上下文判断\"冗余\"是否影响技术文档的精确性，优先保持专业术语和固定表达的完整性。"
    },
    {
      "defect_id": 483416,
      "sentence": "回调函数。返回true表示账号已激活；返回false表示账号未激活。",
      "reference_sentence": "",
      "line_num": 145,
      "context": "{\"140\":\"**参数：**\",\"141\":\"\",\"142\":\"| 参数名   | 类型                         | 必填 | 说明                                                     |\",\"143\":\"| -------- | ---------------------------- | ---- | ------------------------------------------------------ |\",\"144\":\"| localId  | number                       | 是   | 系统账号ID。                                             |\",\"145\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示账号已激活；返回false表示账号未激活。 |\",\"146\":\"\",\"147\":\"**错误码：**\",\"148\":\"\",\"149\":\"| 错误码ID | 错误信息             |\",\"150\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "回调函数。返回true表示账号激活；返回false表示账号未激活。",
      "注意事项": "保持技术术语的准确性优先于简洁性，在状态描述中保留\"已/未\"等明确状态词；修改时需严格核对上下文术语一致性，避免破坏技术文档的严谨性。"
    },
    {
      "defect_id": 483517,
      "sentence": "获取已创建的系统账号数量。使用Promise异步回调。",
      "reference_sentence": "",
      "line_num": 722,
      "context": "{\"717\":\"\",\"718\":\"### getOsAccountCount<sup>9+</sup>\",\"719\":\"\",\"720\":\"getOsAccountCount(): Promise&lt;number&gt;\",\"721\":\"\",\"722\":\"获取已创建的系统账号数量。使用Promise异步回调。\",\"723\":\"\",\"724\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"725\":\"\",\"726\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"727\":\"\"}",
      "用户拒绝的修改": "获取已创建的系统账号数量。使用Promise。",
      "注意事项": "在技术文档中应优先保留行业标准术语（如\"Promise异步回调\"），避免过度简化导致语义偏差；修改前需结合上下文确认冗余部分是否属于必要技术表述。"
    },
    {
      "defect_id": 483512,
      "sentence": "从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "",
      "line_num": 581,
      "context": "{\"576\":\"\",\"577\":\"检查指定系统账号是否已验证。使用callback异步回调。\",\"578\":\"\",\"579\":\"> **说明：**\",\"580\":\">\",\"581\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"582\":\"\",\"583\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"584\":\"\",\"585\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"586\":\"\"}",
      "用户拒绝的修改": "从API version 9开始支持，从API version 11废弃。替代方法仅系统应用可用。",
      "注意事项": "保持技术文档的精确性优先于简洁性，保留版本变更的关键时间节点标记词（如\"开始\"）和权限授予关系的准确表述（如\"开放\"），避免因过度简化导致技术信息失真。"
    },
    {
      "defect_id": 483414,
      "sentence": "从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "",
      "line_num": 134,
      "context": "{\"129\":\"\",\"130\":\"判断指定系统账号是否处于激活状态。使用callback异步回调。\",\"131\":\"\",\"132\":\"> **说明：**\",\"133\":\">\",\"134\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"135\":\"\",\"136\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"137\":\"\",\"138\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"139\":\"\"}",
      "用户拒绝的修改": "从API version 9开始支持，API version 11开始废弃。替代方法仅系统应用可用。",
      "注意事项": "保持技术文档的术语准确性和结构对称性，避免在删除重复词时破坏原有句式平衡；优先使用上下文已明确的专业表述（如\"开放\"），不随意替换为近义词。"
    },
    {
      "defect_id": 483497,
      "sentence": "返回true表示已使能指定的约束；返回false表示未使能指定的约束。",
      "reference_sentence": "",
      "line_num": 350,
      "context": "{\"345\":\"\",\"346\":\"**返回值：**\",\"347\":\"\",\"348\":\"| 类型                   | 说明                                                                  |\",\"349\":\"| --------------------- | --------------------------------------------------------------------- |\",\"350\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示已使能指定的约束；返回false表示未使能指定的约束。 |\",\"351\":\"\",\"352\":\"**错误码：**\",\"353\":\"\",\"354\":\"| 错误码ID | 错误信息             |\",\"355\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回true表示已使能约束；返回false表示未使能约束。",
      "注意事项": "修复冗余表达时需优先保留技术术语的限定词（如\"指定的\"），避免因过度简化破坏专业表述的准确性；同时应结合上下文表格结构判断信息重复性，若参数说明已在列标题中明确，可适当精简单元格内容。"
    },
    {
      "defect_id": 483533,
      "sentence": "Invalid uid.",
      "reference_sentence": "",
      "line_num": 853,
      "context": "{\"848\":\"\",\"849\":\"| 错误码ID | 错误信息         |\",\"850\":\"| -------- | --------------- |\",\"851\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types.|\",\"852\":\"| 12300001 | The system service works abnormally. |\",\"853\":\"| 12300002 | Invalid uid.    |\",\"854\":\"\",\"855\":\"**示例：** 查询值为12345678的uid所属的系统账号的账号ID\",\"856\":\"\",\"857\":\"  ```ts\",\"858\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "无效的uid。",
      "注意事项": "保持技术术语的简洁性和一致性，避免添加冗余助词（如\"的\"），优先采用行业通用译法（如\"无效uid\"而非\"无效的uid\"），并严格遵循上下文格式规范。"
    },
    {
      "defect_id": 483531,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types.",
      "reference_sentence": "",
      "line_num": 851,
      "context": "{\"846\":\"\",\"847\":\"**错误码：**\",\"848\":\"\",\"849\":\"| 错误码ID | 错误信息         |\",\"850\":\"| -------- | --------------- |\",\"851\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified. 2. Incorrect parameter types.|\",\"852\":\"| 12300001 | The system service works abnormally. |\",\"853\":\"| 12300002 | Invalid uid.    |\",\"854\":\"\",\"855\":\"**示例：** 查询值为12345678的uid所属的系统账号的账号ID\",\"856\":\"\"}",
      "用户拒绝的修改": "参数错误。原因：1. 必填参数未指定。2. 参数类型错误。",
      "注意事项": "保留技术文档中关键限定词（如\"Possible\"），避免过度简化导致语义偏差；优先遵循领域规范表达，确保专业术语和可能性描述的准确性。"
    },
    {
      "defect_id": 483539,
      "sentence": "根据域账号信息，获取与其关联的系统账号ID。使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 962,
      "context": "{\"957\":\"\",\"958\":\"### getOsAccountLocalIdForDomain<sup>9+</sup>\",\"959\":\"\",\"960\":\"getOsAccountLocalIdForDomain(domainInfo: DomainAccountInfo, callback: AsyncCallback&lt;number&gt;): void\",\"961\":\"\",\"962\":\"根据域账号信息，获取与其关联的系统账号ID。使用callback异步回调。\",\"963\":\"\",\"964\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"965\":\"\",\"966\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"967\":\"\"}",
      "用户拒绝的修改": "根据域账号信息获取系统账号ID，使用callback回调。",
      "注意事项": "在修复冗余表达时需严格区分技术术语与修饰成分，保留对功能定义、权限说明有实质影响的关键词（如“异步”），避免因过度简化导致技术准确性丢失；删除冗余成分前应结合上下文确认其是否承担逻辑衔接或规范要求作用。"
    },
    {
      "defect_id": 483510,
      "sentence": "从API version 9开始支持，从API version 11开始废弃。建议使用[isOsAccountUnlocked](#isosaccountunlocked11)替代。",
      "reference_sentence": "",
      "line_num": 541,
      "context": "{\"536\":\"\",\"537\":\"检查当前系统账号是否已认证解锁。使用Promise异步回调。\",\"538\":\"\",\"539\":\"> **说明：**\",\"540\":\">\",\"541\":\"> 从API version 9开始支持，从API version 11开始废弃。建议使用[isOsAccountUnlocked](#isosaccountunlocked11)替代。\",\"542\":\"\",\"543\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"544\":\"\",\"545\":\"**返回值：**\",\"546\":\"\"}",
      "用户拒绝的修改": "从API version 9开始支持，从API version 11废弃。建议使用[isOsAccountUnlocked](#isosaccountunlocked11)。",
      "注意事项": "修复冗余表达时需优先保持技术术语和版本变更表述的完整性，避免破坏原有句式的平行结构（如\"开始支持\"与\"开始废弃\"的对应关系），技术文档中版本生命周期描述属于固定表达范式不可简化。"
    },
    {
      "defect_id": 483514,
      "sentence": "从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。",
      "reference_sentence": "",
      "line_num": 631,
      "context": "{\"626\":\"\",\"627\":\"检查指定系统账号是否已验证。使用Promise异步回调。\",\"628\":\"\",\"629\":\"> **说明：**\",\"630\":\">\",\"631\":\"> 从API version 9开始支持，从API version 11开始废弃。替代方法仅向系统应用开放。\",\"632\":\"\",\"633\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS或ohos.permission.INTERACT_ACROSS_LOCAL_ACCOUNTS，以上权限仅系统应用可申请。\",\"634\":\"\",\"635\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"636\":\"\"}",
      "用户拒绝的修改": "从API version 9开始支持，从API version 11废弃。替代方法仅系统应用可用。",
      "注意事项": "保留技术文档中固定表述和关键术语的完整性，避免过度简化导致语义偏差；修改前需核对上下文权限描述，确保\"开放\"与\"可用\"等权限类表述与系统应用能力说明保持严格一致。"
    },
    {
      "defect_id": 483538,
      "sentence": "返回指定uid对应的系统账号ID。",
      "reference_sentence": "",
      "line_num": 936,
      "context": "{\"931\":\"\",\"932\":\"**返回值：**\",\"933\":\"\",\"934\":\"| 类型                  | 说明                                     |\",\"935\":\"| --------------------- | --------------------------------------- |\",\"936\":\"| number | 返回指定uid对应的系统账号ID。 |\",\"937\":\"\",\"938\":\"**错误码：**\",\"939\":\"\",\"940\":\"| 错误码ID | 错误信息       |\",\"941\":\"| -------- | ------------- |\"}",
      "用户拒绝的修改": "返回指定uid的系统账号ID。",
      "注意事项": "修复冗余表达时需优先保留技术文档专用术语和固定搭配（如\"对应的\"在参数关联场景中具有明确语义），避免因过度简化破坏技术准确性；修改前需结合上下文确认修饰成分是否承担区分歧义或强调逻辑关系的作用。"
    },
    {
      "defect_id": 483537,
      "sentence": "根据uid查询对应的系统账号ID。使用同步方式返回结果。",
      "reference_sentence": "",
      "line_num": 922,
      "context": "{\"917\":\"\",\"918\":\"### getOsAccountLocalIdForUidSync<sup>10+</sup>\",\"919\":\"\",\"920\":\"getOsAccountLocalIdForUidSync(uid: number): number\",\"921\":\"\",\"922\":\"根据uid查询对应的系统账号ID。使用同步方式返回结果。\",\"923\":\"\",\"924\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"925\":\"\",\"926\":\"**参数：**\",\"927\":\"\"}",
      "用户拒绝的修改": "根据uid查询系统账号ID，使用同步方式。",
      "注意事项": "在删除修饰词前需确认其是否具有明确限定作用（如“对应的”可能强调关联性），并优先保留技术术语中的行业惯用表述；同时需结合上下文方法名中的“Sync”隐含信息，避免重复修正已明确的同步属性。"
    },
    {
      "defect_id": 483536,
      "sentence": "Promise&lt;number&gt; | Promise对象，返回指定uid对应的系统账号ID。",
      "reference_sentence": "",
      "line_num": 891,
      "context": "{\"886\":\"\",\"887\":\"**返回值：**\",\"888\":\"\",\"889\":\"| 类型                  | 说明                                     |\",\"890\":\"| --------------------- | --------------------------------------- |\",\"891\":\"| Promise&lt;number&gt; | Promise对象，返回指定uid对应的系统账号ID。 |\",\"892\":\"\",\"893\":\"**错误码：**\",\"894\":\"\",\"895\":\"| 错误码ID | 错误信息       |\",\"896\":\"| -------- | ------------- |\"}",
      "用户拒绝的修改": "Promise&lt;number&gt; | 返回指定uid对应的系统账号ID。",
      "注意事项": "修复冗余表达时需严格区分技术文档中必要的术语解释和重复赘述，保留对专业术语或类型系统的必要说明性内容，避免误删用于澄清概念的技术性重复表述。"
    },
    {
      "defect_id": 485560,
      "sentence": "上述'sample'字样仅为示例，此处由开发者根据实际工程目录自定义。",
      "reference_sentence": "",
      "line_num": 44,
      "context": "{\"39\":\"target_link_libraries(sample PUBLIC libnative_media_core.so)\",\"40\":\"```\",\"41\":\"\",\"42\":\"> **说明：**\",\"43\":\">\",\"44\":\"> 上述'sample'字样仅为示例，此处由开发者根据实际工程目录自定义。\",\"45\":\">\",\"46\":\"\",\"47\":\"### 开发步骤\",\"48\":\"\",\"49\":\"1. 添加头文件。\"}",
      "用户拒绝的修改": "上述'sample'字样由开发者根据实际工程目录自定义。",
      "注意事项": "在修复冗余表达时需结合上下文判断修饰成分是否承担解释功能，技术文档中强调示例性质的限定词（如\"仅为示例\"）通常具有明确提示作用，不宜直接删除，应优先保留关键说明信息。"
    },
    {
      "defect_id": 487322,
      "sentence": "回调函数，当监听事件取消成功时，err为undefined；否则返回错误对象。该参数为可选参数，若未填写，则取消所有相关会话的事件监听。",
      "reference_sentence": "",
      "line_num": 2208,
      "context": "{\"2203\":\"\",\"2204\":\"**参数：**\",\"2205\":\"\",\"2206\":\"| 参数名   | 类型                                                         | 必填 | 说明                                                         |\",\"2207\":\"| -------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\",\"2208\":\"| callback | (callback: [DeviceState](#DeviceState)) => void        | 否  | 回调函数，当监听事件取消成功时，err为undefined；否则返回错误对象。该参数为可选参数，若未填写，则取消所有相关会话的事件监听。 |\",\"2209\":\"\",\"2210\":\"**错误码：**\",\"2211\":\"\",\"2212\":\"以下错误码的详细介绍请参见[媒体会话管理错误码](errorcode-avsession.md)。\",\"2213\":\"\"}",
      "用户拒绝的修改": "回调函数，参数包含err。当取消成功时，err为undefined；否则返回错误对象。",
      "注意事项": "修复冗余表达时应优先保留参数可选性及未填写时的特殊行为说明，避免因过度简化导致技术细节丢失；修改后需确保语句仍包含上下文参数表中已标注的\"否\"字段对应的逻辑说明。"
    },
    {
      "defect_id": 485557,
      "sentence": "调用解封装能力解析网络播放路径，需要[声明权限](../../security/AccessToken/declare-permissions.md)：ohos.permission.INTERNET",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"详细的API说明参考[AVDemuxer](../../reference/apis-avcodec-kit/_a_v_demuxer.md)和[AVSource](../../reference/apis-avcodec-kit/_a_v_source.md)\",\"26\":\"\",\"27\":\"> **说明**\",\"28\":\">\",\"29\":\"> - 调用解封装能力解析网络播放路径，需要[声明权限](../../security/AccessToken/declare-permissions.md)：ohos.permission.INTERNET\",\"30\":\"> - 调用解封装能力解析本地文件，需要[向用户申请授权](../../security/AccessToken/request-user-authorization.md)：ohos.permission.READ_MEDIA\",\"31\":\"> - 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法请参考[ResourceManager API参考](../../reference/apis-localization-kit/js-apis-resource-manager.md#getrawfd9)\",\"32\":\"\",\"33\":\"### 在 CMake 脚本中链接动态库\",\"34\":\"\"}",
      "用户拒绝的修改": "解析网络播放路径时，需要声明权限：ohos.permission.INTERNET。",
      "注意事项": "修复冗余表达时需优先保持上下文格式一致性，避免破坏并列条目间的结构对称性；在技术文档中，特定术语（如\"调用解封装能力\"）若为上下文重复模式的关键组件，应保留其修饰作用而非简单删除。"
    },
    {
      "defect_id": 485559,
      "sentence": "如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法请参考[ResourceManager API参考](../../reference/apis-localization-kit/js-apis-resource-manager.md#getrawfd9)",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"\",\"27\":\"> **说明**\",\"28\":\">\",\"29\":\"> - 调用解封装能力解析网络播放路径，需要[声明权限](../../security/AccessToken/declare-permissions.md)：ohos.permission.INTERNET\",\"30\":\"> - 调用解封装能力解析本地文件，需要[向用户申请授权](../../security/AccessToken/request-user-authorization.md)：ohos.permission.READ_MEDIA\",\"31\":\"> - 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法请参考[ResourceManager API参考](../../reference/apis-localization-kit/js-apis-resource-manager.md#getrawfd9)\",\"32\":\"\",\"33\":\"### 在 CMake 脚本中链接动态库\",\"34\":\"\",\"35\":\"``` cmake\",\"36\":\"target_link_libraries(sample PUBLIC libnative_media_codecbase.so)\"}",
      "用户拒绝的修改": "使用ResourceManager.getRawFd打开HAP资源文件描述符时，参考[ResourceManager API参考](../../reference/apis-localization-kit/js-apis-resource-manager.md#getrawfd9)。",
      "注意事项": "修复时应优先保留技术文档中的条件性表述（如\"如果\"）和指引性术语（如\"使用方法\"），避免破坏技术说明的严谨性和上下文格式统一性，尤其在列表项中需保持句式结构一致性。"
    },
    {
      "defect_id": 487318,
      "sentence": "该接口为系统接口。",
      "reference_sentence": "",
      "line_num": 2168,
      "context": "{\"2163\":\"\",\"2164\":\"投播设备连接状态的回调函数。\",\"2165\":\"\",\"2166\":\"**系统能力：** SystemCapability.Multimedia.AVSession.AVCast\",\"2167\":\"\",\"2168\":\"**系统接口：** 该接口为系统接口。\",\"2169\":\"\",\"2170\":\"**参数：**\",\"2171\":\"\",\"2172\":\"| 参数名   | 类型                                                         | 必填 | 说明                                                         |\",\"2173\":\"| -------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "系统接口。",
      "注意事项": "修复冗余表达时需优先检查上下文格式一致性，保留文档模板中必要的重复性引导结构（如“**系统接口：**”后的完整说明句式）。"
    },
    {
      "defect_id": 485568,
      "sentence": "在监听到DRM信息后，也可主动调用获取DRM信息(uuid及对应pssh)接口。",
      "reference_sentence": "",
      "line_num": 171,
      "context": "{\"166\":\"   }\",\"167\":\"\",\"168\":\"   Demuxer_MediaKeySystemInfoCallback callback = &OnDrmInfoChangedWithObj;\",\"169\":\"   Drm_ErrCode ret = OH_AVDemuxer_SetDemuxerMediaKeySystemInfoCallback(demuxer, callback);\",\"170\":\"   ```\",\"171\":\"   在监听到DRM信息后，也可主动调用获取DRM信息(uuid及对应pssh)接口。\",\"172\":\"\",\"173\":\"   ```c++\",\"174\":\"   DRM_MediaKeySystemInfo mediaKeySystemInfo;\",\"175\":\"   OH_AVDemuxer_GetMediaKeySystemInfo(demuxer, &mediaKeySystemInfo);\",\"176\":\"   ```\"}",
      "用户拒绝的修改": "监听到DRM信息后，可主动调用获取DRM信息接口。",
      "注意事项": "在技术文档中保留括号内的参数说明（如uuid及pssh），这类内容属于接口核心信息而非冗余修饰；需结合代码上下文判断括号是否为必要技术规格，避免因过度精简导致关键数据丢失。"
    },
    {
      "defect_id": 487316,
      "sentence": "该接口为系统接口。",
      "reference_sentence": "",
      "line_num": 2151,
      "context": "{\"2146\":\"\",\"2147\":\"投播设备的连接状态。\",\"2148\":\"\",\"2149\":\"**系统能力：** SystemCapability.Multimedia.AVSession.AVCast\",\"2150\":\"\",\"2151\":\"**系统接口：** 该接口为系统接口。\",\"2152\":\"\",\"2153\":\"| 名称      | 类型   | 必填 | 说明         |\",\"2154\":\"| :-------- | :----- | :--- | :----------- |\",\"2155\":\"| deviceId       | string | 是   | 投播设备ID。       |\",\"2156\":\"| deviceState    | number | 是   | 投播设备连接状态码。 |\"}",
      "用户拒绝的修改": "系统接口。",
      "注意事项": "修复冗余表达时需优先检查上下文格式一致性，若原句承担的是定义/解释功能(如标签后的说明性文字)，应保留完整句式避免破坏文档结构完整性。"
    },
    {
      "defect_id": 485591,
      "sentence": "数据类型及详细取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。",
      "reference_sentence": "",
      "line_num": 431,
      "context": "{\"426\":\"\",\"427\":\"> **说明：**\",\"428\":\"> 正常解析时才可以获取对应属性数据；如果文件信息错误或缺失，将导致解析异常，无法获取数据。\",\"429\":\"> 辅助轨属性范围与实际媒体类型（音频、视频）保持一致。\",\"430\":\"> \",\"431\":\"> 数据类型及详细取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。\",\"432\":\"\",\"433\":\"**表2** 轨道级别属性支持范围\",\"434\":\"| 名称 | 描述 | 视频轨支持 | 音频轨支持 | 字幕轨支持 | 辅助轨支持 |\",\"435\":\"| -- | -- | -- | -- | -- | -- |\",\"436\":\"|OH_MD_KEY_CODEC_MIME|码流编解码器类型的键。|√|√|√|√|\"}",
      "用户拒绝的修改": "数据类型及取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。",
      "注意事项": "修复冗余表达时应结合上下文判断信息必要性，技术文档中\"详细\"等修饰词可能用于强调参数完整性，需保留专业术语的准确性而非机械删除形容词。"
    },
    {
      "defect_id": 485566,
      "sentence": "4. 注册[DRM信息监听函数](../../reference/apis-avcodec-kit/_a_v_demuxer.md#demuxer_mediakeysysteminfocallback)（可选，若非DRM码流或已获得[DRM信息](../../reference/apis-drm-kit/capi-drm-drm-mediakeysysteminfo.md)，可跳过此步）。",
      "reference_sentence": "",
      "line_num": 157,
      "context": "{\"152\":\"   if (demuxer == nullptr) {\",\"153\":\"      printf(\\\"create demuxer failed\\\");\",\"154\":\"      return;\",\"155\":\"   }\",\"156\":\"   ```\",\"157\":\"4. 注册[DRM信息监听函数](../../reference/apis-avcodec-kit/_a_v_demuxer.md#demuxer_mediakeysysteminfocallback)（可选，若非DRM码流或已获得[DRM信息](../../reference/apis-drm-kit/capi-drm-drm-mediakeysysteminfo.md)，可跳过此步）。\",\"158\":\"\",\"159\":\"   设置DRM信息监听的接口，回调函数支持返回解封装器实例，适用于多个解封装器场景。\",\"160\":\"\",\"161\":\"   ```c++\",\"162\":\"   // DRM信息监听回调OnDrmInfoChangedWithObj实现。\"}",
      "用户拒绝的修改": "4. 注册DRM信息监听函数（可选，若非DRM码流或已获得DRM信息，可跳过此步）。",
      "注意事项": "修复冗余表达时应保留必要的技术术语和文档链接，避免误删关键信息；需结合上下文判断修饰成分是否影响技术准确性，优先确保专业文档的完整性和可参考性。"
    },
    {
      "defect_id": 485553,
      "sentence": "播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"**适用场景**：\",\"10\":\"\",\"11\":\"- 播放\",\"12\":\"  \",\"13\":\"  播放媒体文件时，需要先对媒体流进行解封装，然后使用解封装获取的sample进行解码和播放。\",\"14\":\"\",\"15\":\"- 音视频编辑\",\"16\":\"  \",\"17\":\"  编辑媒体文件时，需要先对媒体流进行解封装，获取到指定sample进行编辑。\",\"18\":\"\"}",
      "用户拒绝的修改": "播放媒体文件时，先解封装媒体流，再解码和播放sample。",
      "注意事项": "修复冗余表达时需优先保留技术文档中关键术语和操作逻辑的完整性，避免过度简化导致步骤间依赖关系模糊；结合上下文判断修饰成分是否影响核心信息传递，对流程描述类句子应侧重保持动作链清晰而非单纯删除介词结构。"
    },
    {
      "defect_id": 483589,
      "sentence": "Promise对象，返回分布式虚拟设备ID。",
      "reference_sentence": "",
      "line_num": 1452,
      "context": "{\"1447\":\"\",\"1448\":\"**返回值：**\",\"1449\":\"\",\"1450\":\"| 类型                  | 说明                              |\",\"1451\":\"| --------------------- | --------------------------------- |\",\"1452\":\"| Promise&lt;string&gt; | Promise对象，返回分布式虚拟设备ID。 |\",\"1453\":\"\",\"1454\":\"**错误码：**\",\"1455\":\"\",\"1456\":\"| 错误码ID | 错误信息             |\",\"1457\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回分布式虚拟设备ID。",
      "注意事项": "在技术文档中保留必要的技术术语（如\"Promise对象\"），确保与上下文中的参数类型定义保持一致，避免因过度简化导致关键信息缺失；优先验证用户是否将特定术语视为冗余或必要说明。"
    },
    {
      "defect_id": 483573,
      "sentence": "Promise对象，返回当前进程所属的系统账号信息。",
      "reference_sentence": "",
      "line_num": 1296,
      "context": "{\"1291\":\"\",\"1292\":\"**返回值：**\",\"1293\":\"\",\"1294\":\"| 类型                                           | 说明                                       |\",\"1295\":\"| ---------------------------------------------- | ----------------------------------------- |\",\"1296\":\"| Promise&lt;[OsAccountInfo](#osaccountinfo)&gt; | Promise对象，返回当前进程所属的系统账号信息。 |\",\"1297\":\"\",\"1298\":\"**错误码：**\",\"1299\":\"\",\"1300\":\"| 错误码ID | 错误信息             |\",\"1301\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回当前进程所属的系统账号信息。",
      "注意事项": "保留技术文档中明确标识返回类型的关键术语（如\"Promise对象\"），避免在表格说明字段中删除与类型列形成补充说明的必要技术要素；需结合上下文判断是否属于冗余信息，当术语与表格数据类型存在对应关系时应优先保持表述完整性。"
    },
    {
      "defect_id": 485569,
      "sentence": "9. 开始解封装，循环获取sample（以含音频、视频两轨的文件为例）。",
      "reference_sentence": "",
      "line_num": 313,
      "context": "{\"308\":\"   // 2. ogg格式文件使用OH_AVDemuxer_SeekToTime功能时，会跳转到传入时间millisecond所在时间间隔(秒)的起始处，可能会导致一定数量的帧误差。\",\"309\":\"   // 3. demuxer的seek处理只针对解码行为一致的码流进行处理，如果seek后需要解码器重新配置参数，或者需要重新送入参数集的数据才可以正确解码的码流，seek后可能会出现花屏、解码卡死等问题。\",\"310\":\"   OH_AVDemuxer_SeekToTime(demuxer, 0, OH_AVSeekMode::SEEK_MODE_CLOSEST_SYNC);\",\"311\":\"   ```\",\"312\":\"\",\"313\":\"9. 开始解封装，循环获取sample（以含音频、视频两轨的文件为例）。\",\"314\":\"\",\"315\":\"   BufferAttr包含的属性：\",\"316\":\"   - size：sample尺寸；\",\"317\":\"   - offset：数据在AVBuffer中的偏移，一般为0；\",\"318\":\"   - pts：文件封装的显示时间戳；\"}",
      "用户拒绝的修改": "9. 开始解封装，循环获取sample（以音频和视频两轨文件为例）。",
      "注意事项": "在技术文档中优先保留明确说明包含关系的修饰词（如\"含\"），避免因过度简化导致示例范围模糊；需结合上下文判断括号内补充说明的准确性要求，确保专业术语的完整性。"
    },
    {
      "defect_id": 485556,
      "sentence": "详细的API说明参考[AVDemuxer](../../reference/apis-avcodec-kit/_a_v_demuxer.md)和[AVSource](../../reference/apis-avcodec-kit/_a_v_source.md)",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"  媒体文件格式转换时，需要先对媒体流进行解封装，然后按需将媒体流封装至新的格式文件内。\",\"22\":\"\",\"23\":\"## 开发指导\",\"24\":\"\",\"25\":\"详细的API说明参考[AVDemuxer](../../reference/apis-avcodec-kit/_a_v_demuxer.md)和[AVSource](../../reference/apis-avcodec-kit/_a_v_source.md)\",\"26\":\"\",\"27\":\"> **说明**\",\"28\":\">\",\"29\":\"> - 调用解封装能力解析网络播放路径，需要[声明权限](../../security/AccessToken/declare-permissions.md)：ohos.permission.INTERNET\",\"30\":\"> - 调用解封装能力解析本地文件，需要[向用户申请授权](../../security/AccessToken/request-user-authorization.md)：ohos.permission.READ_MEDIA\"}",
      "用户拒绝的修改": "API说明请参考[AVDemuxer](../../reference/apis-avcodec-kit/_a_v_demuxer.md)和[AVSource](../../reference/apis-avcodec-kit/_a_v_source.md)。",
      "注意事项": "修复冗余表达时应结合上下文判断修饰词是否具有实际语义价值，在技术文档场景下需保留\"详细\"等强调性修饰语用于突出API说明的完整性特征，避免机械删除行业术语中的合理限定词。"
    },
    {
      "defect_id": 483583,
      "sentence": "Promise对象，返回当前进程所属的系统账号的账号类型。",
      "reference_sentence": "",
      "line_num": 1372,
      "context": "{\"1367\":\"\",\"1368\":\"**返回值：**\",\"1369\":\"\",\"1370\":\"| 类型                                           | 说明                                             |\",\"1371\":\"| ---------------------------------------------- | ----------------------------------------------- |\",\"1372\":\"| Promise&lt;[OsAccountType](#osaccounttype)&gt; | Promise对象，返回当前进程所属的系统账号的账号类型。 |\",\"1373\":\"\",\"1374\":\"**错误码：**\",\"1375\":\"\",\"1376\":\"| 错误码ID | 错误信息             |\",\"1377\":\"| -------- | ------------------- |\"}",
      "用户拒绝的修改": "返回当前进程所属的系统账号类型。",
      "注意事项": "在技术文档修改中，需优先保留与上下文表格形成补充说明的关键信息（如\"Promise对象\"），避免因过度精简破坏技术参数描述的完整性；当类型声明已存在于表格时，应重点处理纯文字部分的冗余成分而非表格关联内容。"
    },
    {
      "defect_id": 485586,
      "sentence": "数据类型及详细取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。",
      "reference_sentence": "",
      "line_num": 405,
      "context": "{\"400\":\"\",\"401\":\"> **说明：**\",\"402\":\"> 正常解析时才可以获取对应属性数据，如果文件信息错误或缺失，将导致解析异常，无法获取数据。\",\"403\":\"> 当前GBK格式字符集数据会转换为UTF8提供，其他类型字符集如果需要转换为UTF8格式使用，需要调用方自行转换，参考[icu4c](../../reference/native-lib/icu4c.md)。\",\"404\":\"> \",\"405\":\"> 数据类型及详细取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。\",\"406\":\"\",\"407\":\"**表1** 文件级别属性支持范围\",\"408\":\"| 名称 | 描述 |\",\"409\":\"| -- | -- |\",\"410\":\"|OH_MD_KEY_TITLE|文件标题的键|\"}",
      "用户拒绝的修改": "数据类型及取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。",
      "注意事项": "在修复冗余表达时需优先保留修饰词的技术准确性（如\"详细\"可能强调数据粒度），并结合上下文判断是否属于必要限定信息；技术文档应谨慎处理可能影响参数说明完整性的形容词。"
    },
    {
      "defect_id": 485558,
      "sentence": "调用解封装能力解析本地文件，需要[向用户申请授权](../../security/AccessToken/request-user-authorization.md)：ohos.permission.READ_MEDIA",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"详细的API说明参考[AVDemuxer](../../reference/apis-avcodec-kit/_a_v_demuxer.md)和[AVSource](../../reference/apis-avcodec-kit/_a_v_source.md)\",\"26\":\"\",\"27\":\"> **说明**\",\"28\":\">\",\"29\":\"> - 调用解封装能力解析网络播放路径，需要[声明权限](../../security/AccessToken/declare-permissions.md)：ohos.permission.INTERNET\",\"30\":\"> - 调用解封装能力解析本地文件，需要[向用户申请授权](../../security/AccessToken/request-user-authorization.md)：ohos.permission.READ_MEDIA\",\"31\":\"> - 如果使用ResourceManager.getRawFd打开HAP资源文件描述符，使用方法请参考[ResourceManager API参考](../../reference/apis-localization-kit/js-apis-resource-manager.md#getrawfd9)\",\"32\":\"\",\"33\":\"### 在 CMake 脚本中链接动态库\",\"34\":\"\",\"35\":\"``` cmake\"}",
      "用户拒绝的修改": "解析本地文件时，需要向用户申请授权：ohos.permission.READ_MEDIA。",
      "注意事项": "修复冗余表达时需优先检查上下文术语一致性，避免误删关键限定词（如\"解封装能力\"在上下文中与其他条目保持平行结构）；同时需确认技术文档中重复性表述是否属于必要的规范术语，而非冗余修饰。"
    },
    {
      "defect_id": 485589,
      "sentence": "辅助轨属性范围与实际媒体类型（音频、视频）保持一致。",
      "reference_sentence": "",
      "line_num": 429,
      "context": "{\"424\":\"\",\"425\":\"### 轨道级别属性支持范围\",\"426\":\"\",\"427\":\"> **说明：**\",\"428\":\"> 正常解析时才可以获取对应属性数据；如果文件信息错误或缺失，将导致解析异常，无法获取数据。\",\"429\":\"> 辅助轨属性范围与实际媒体类型（音频、视频）保持一致。\",\"430\":\"> \",\"431\":\"> 数据类型及详细取值范围参考[媒体数据键值对](../../reference/apis-avcodec-kit/_codec_base.md#媒体数据键值对)。\",\"432\":\"\",\"433\":\"**表2** 轨道级别属性支持范围\",\"434\":\"| 名称 | 描述 | 视频轨支持 | 音频轨支持 | 字幕轨支持 | 辅助轨支持 |\"}",
      "用户拒绝的修改": "辅助轨属性与实际媒体类型一致。",
      "注意事项": "在修复冗余表达时需确认上下文是否隐含技术术语或限定范围（如“范围”可能关联文档中的属性支持表），避免误删关键限定词或示例说明（如括号内的“音频、视频”可能用于明确媒体类型）。"
    },
    {
      "defect_id": 483623,
      "sentence": "返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。",
      "reference_sentence": "",
      "line_num": 1919,
      "context": "{\"1914\":\"\",\"1915\":\"**返回值：**\",\"1916\":\"\",\"1917\":\"| 类型                   | 说明                                                                      |\",\"1918\":\"| ---------------------- | ------------------------------------------------------------------------ |\",\"1919\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。 |\",\"1920\":\"\",\"1921\":\"**示例：**\",\"1922\":\"\",\"1923\":\"  ```ts\",\"1924\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "返回true表示当前账号为测试账号；返回false表示非测试账号。",
      "注意事项": "保持技术术语的完整性和一致性，避免在简化冗余表达时省略必要的主语或关键限定词，确保修改后的表述在技术文档中保持明确无歧义。"
    },
    {
      "defect_id": 487321,
      "sentence": "该接口为系统接口。",
      "reference_sentence": "",
      "line_num": 2202,
      "context": "{\"2197\":\"\",\"2198\":\"取消投播设备连接状态的监听。\",\"2199\":\"\",\"2200\":\"**系统能力：** SystemCapability.Multimedia.AVSession.AVCast\",\"2201\":\"\",\"2202\":\"**系统接口：** 该接口为系统接口。\",\"2203\":\"\",\"2204\":\"**参数：**\",\"2205\":\"\",\"2206\":\"| 参数名   | 类型                                                         | 必填 | 说明                                                         |\",\"2207\":\"| -------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "系统接口。",
      "注意事项": "修复冗余表达时必须优先检查上下文格式一致性（如标签后的完整句结构），避免因过度简化破坏文档规范或已有模板的完整性。"
    },
    {
      "defect_id": 483612,
      "sentence": "判断ID为100的系统账号是否处于激活状态",
      "reference_sentence": "",
      "line_num": 1779,
      "context": "{\"1774\":\"\",\"1775\":\"| 类型                   | 说明                                                        |\",\"1776\":\"| --------------------- | ----------------------------------------------------------- |\",\"1777\":\"| Promise&lt;boolean&gt; | Promise对象。返回true表示账号已激活；返回false表示账号未激活。 |\",\"1778\":\"\",\"1779\":\"**示例：** 判断ID为100的系统账号是否处于激活状态\",\"1780\":\"\",\"1781\":\"  ```ts\",\"1782\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"1783\":\"  let accountManager: osAccount.AccountManager = osAccount.getAccountManager();\",\"1784\":\"  let localId: number = 100;\"}",
      "用户拒绝的修改": "判断ID为100的系统账号是否激活。",
      "注意事项": "在修复冗余表达时需优先核对上下文术语一致性，确保\"激活状态\"等专业表述符合文档规范，避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 483605,
      "sentence": "从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9-1)。",
      "reference_sentence": "",
      "line_num": 1695,
      "context": "{\"1690\":\"\",\"1691\":\"判断是否支持多系统账号。使用Promise异步回调。\",\"1692\":\"\",\"1693\":\"> **说明：**\",\"1694\":\">\",\"1695\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9-1)。\",\"1696\":\"\",\"1697\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1698\":\"\",\"1699\":\"**返回值：**\",\"1700\":\"\"}",
      "用户拒绝的修改": "从API version 7开始支持，API version 9废弃。建议使用[checkMultiOsAccountEnabled](#checkmultiosaccountenabled9-1)。",
      "注意事项": "修复技术文档冗余表达时需优先验证是否为固定术语或标准结构（如\"开始支持/废弃\"可能属于版本管理规范表述），避免将规范性重复误判为冗余信息，修改前应核查上下文是否包含行业特定表达惯例。"
    },
    {
      "defect_id": 483607,
      "sentence": "**示例：** 判断ID为100的系统账号是否处于激活状态",
      "reference_sentence": "",
      "line_num": 1738,
      "context": "{\"1733\":\"| 参数名   | 类型                         | 必填 | 说明                                                     |\",\"1734\":\"| -------- | ---------------------------- | ---- | ------------------------------------------------------ |\",\"1735\":\"| localId  | number                       | 是   | 系统账号ID。                                            |\",\"1736\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示账号已激活；返回false表示账号未激活。 |\",\"1737\":\"\",\"1738\":\"**示例：** 判断ID为100的系统账号是否处于激活状态\",\"1739\":\"\",\"1740\":\"  ```ts\",\"1741\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"1742\":\"  let accountManager: osAccount.AccountManager = osAccount.getAccountManager();\",\"1743\":\"  let localId: number = 100;\"}",
      "用户拒绝的修改": "**示例：** 判断系统账号是否激活，ID为100。",
      "注意事项": "修复冗余表达时必须保留技术参数的关键位置和明确指向性，避免因语序调整导致参数与上下文说明产生歧义。优先确保示例与API文档参数名称、调用顺序的严格对应关系。"
    },
    {
      "defect_id": 483625,
      "sentence": "回调函数。当获取成功时，err为null，data为已创建的系统账号的数量；否则为错误对象。",
      "reference_sentence": "",
      "line_num": 2059,
      "context": "{\"2054\":\"\",\"2055\":\"**参数：**\",\"2056\":\"\",\"2057\":\"| 参数名   | 类型                        | 必填 | 说明                                                                         |\",\"2058\":\"| -------- | --------------------------- | ---- | -------------------------------------------------------------------------- |\",\"2059\":\"| callback | AsyncCallback&lt;number&gt; | 是   | 回调函数。当获取成功时，err为null，data为已创建的系统账号的数量；否则为错误对象。 |\",\"2060\":\"\",\"2061\":\"**示例：**\",\"2062\":\"\",\"2063\":\"  ```ts\",\"2064\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "回调函数。成功时返回已创建的系统账号数量，失败时返回错误对象。",
      "注意事项": "修复冗余表达时需优先保留技术参数的关键描述（如err/data），避免因过度简化丢失API接口规范的关键信息；需结合上下文参数类型定义（如AsyncCallback<number>）保持技术准确性，不应改变回调函数的标准错误处理范式。"
    },
    {
      "defect_id": 483624,
      "sentence": "返回true表示指定账号已验证；返回false表示指定账号未验证。",
      "reference_sentence": "",
      "line_num": 1951,
      "context": "{\"1946\":\"\",\"1947\":\"**参数：**\",\"1948\":\"\",\"1949\":\"| 参数名   | 类型                         | 必填 | 说明                                                            |\",\"1950\":\"| -------- | ---------------------------- | ---- | ------------------------------------------------------------- |\",\"1951\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示指定账号已验证；返回false表示指定账号未验证。 |\",\"1952\":\"\",\"1953\":\"**示例：**\",\"1954\":\"\",\"1955\":\"  ```ts\",\"1956\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "返回true表示指定账号已验证；返回false表示未验证。",
      "注意事项": "在技术文档中处理冗余表达时，必须保留必要的限定词（如\"指定账号\"）以确保指代明确性，避免因过度简化导致参数描述与上下文参数名失去关联。"
    },
    {
      "defect_id": 483658,
      "sentence": "**系统能力：** SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 2455,
      "context": "{\"2450\":\"  }).catch((err: BusinessError) => {\",\"2451\":\"    console.error('queryActivatedOsAccountIds err: ' + JSON.stringify(err));\",\"2452\":\"  });\",\"2453\":\"  ```\",\"2454\":\"\",\"2455\":\"### queryCurrentOsAccount<sup>(deprecated)</sup>\",\"2456\":\"\",\"2457\":\"queryCurrentOsAccount(callback: AsyncCallback&lt;OsAccountInfo&gt;): void\",\"2458\":\"\",\"2459\":\"查询当前进程所属的系统账号的信息。使用callback异步回调。\",\"2460\":\"\"}",
      "用户拒绝的修改": "删除该行，因为相同内容在其他地方已经出现。",
      "注意事项": "在判断冗余表达时必须严格验证上下文重复性，特别注意系统能力声明等元数据在不同接口中的必要性，避免误删具有独立功能标识作用的专属字段。"
    },
    {
      "defect_id": 483656,
      "sentence": "**系统能力：** SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 2400,
      "context": "{\"2395\":\"\",\"2396\":\"> **说明：**\",\"2397\":\">\",\"2398\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9)。\",\"2399\":\"\",\"2400\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2401\":\"\",\"2402\":\"**参数：**\",\"2403\":\"\",\"2404\":\"| 参数名   | 类型                                     | 必填 | 说明                                                   |\",\"2405\":\"| -------- | ---------------------------------------- | ---- | ------------------------------------------------------ |\"}",
      "用户拒绝的修改": "删除该行，因为相同内容在其他地方已经出现。",
      "注意事项": "修复冗余表达时必须严格验证上下文语义关联性，若相同内容出现在不同功能模块或API说明中，即使文本重复也需保留独立声明，确保技术文档的模块化完整性。"
    },
    {
      "defect_id": 483613,
      "sentence": "ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。",
      "reference_sentence": "",
      "line_num": 1802,
      "context": "{\"1797\":\"\",\"1798\":\"> **说明：**\",\"1799\":\">\",\"1800\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"1801\":\"\",\"1802\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。\",\"1803\":\"\",\"1804\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"1805\":\"\",\"1806\":\"**参数：**\",\"1807\":\"\"}",
      "用户拒绝的修改": "需要权限：ohos.permission.MANAGE_LOCAL_ACCOUNTS。仅系统应用可申请。",
      "注意事项": "保留必要指代词（如\"该权限\"）确保上下文连贯性，避免将关联信息拆分为不连贯的独立短句，优先使用精简句式而非碎片化改写。"
    },
    {
      "defect_id": 483655,
      "sentence": "**系统能力：** SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 2363,
      "context": "{\"2358\":\">\",\"2359\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"2360\":\"\",\"2361\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。\",\"2362\":\"\",\"2363\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2364\":\"\",\"2365\":\"**参数：**\",\"2366\":\"\",\"2367\":\"| 参数名  | 类型   | 必填 | 说明         |\",\"2368\":\"| ------- | ------ | ---- | ------------ |\"}",
      "用户拒绝的修改": "删除该行，因为相同内容在其他地方已经出现。",
      "注意事项": "在判断冗余表达时，必须结合上下文确认重复内容是否属于同一功能模块或不同函数定义，避免因忽略文档结构层级（如跨函数/参数说明）而误删必要信息。"
    },
    {
      "defect_id": 483657,
      "sentence": "**系统能力：** SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 2435,
      "context": "{\"2430\":\">\",\"2431\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9-1)。\",\"2432\":\"\",\"2433\":\"查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。\",\"2434\":\"\",\"2435\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2436\":\"\",\"2437\":\"**返回值：**\",\"2438\":\"\",\"2439\":\"| 类型                               | 说明                                               |\",\"2440\":\"| ---------------------------------- | ------------------------------------------------- |\"}",
      "用户拒绝的修改": "删除该行，因为相同内容在其他地方已经出现。",
      "注意事项": "修复冗余表达时需确认上下文是否属于结构性重复（如多个API独立声明相同系统能力），避免将必要的内容误判为冗余；应保留文档规范要求的关键信息重复，即使内容表面相似。"
    },
    {
      "defect_id": 483646,
      "sentence": "**示例：** 获取ID为100的系统账号的全部约束",
      "reference_sentence": "",
      "line_num": 2336,
      "context": "{\"2331\":\"| 参数名   | 类型                                     | 必填 | 说明                                                                                             |\",\"2332\":\"| -------- | ---------------------------------------- | ---- | ---------------------------------------------------------------------------------------------- |\",\"2333\":\"| localId  | number                                   | 是   | 系统账号ID。                                                                                    |\",\"2334\":\"| callback | AsyncCallback&lt;Array&lt;string&gt;&gt; | 是   | 回调函数。如果获取成功，err为null，data为指定系统账号的全部[约束](#系统账号约束列表)；否则为错误对象。 |\",\"2335\":\"\",\"2336\":\"**示例：** 获取ID为100的系统账号的全部约束\",\"2337\":\"\",\"2338\":\"  ```ts\",\"2339\":\"  import { BusinessError } from '@kit.BasicServicesKit';\",\"2340\":\"  let accountManager: osAccount.AccountManager = osAccount.getAccountManager();\",\"2341\":\"  let localId: number = 100;\"}",
      "用户拒绝的修改": "**示例：** 获取ID为100的系统账号约束",
      "注意事项": "修复冗余表达时必须严格核对上下文术语一致性，技术文档中的限定词（如\"全部\"）可能属于接口定义的关键参数，不可仅凭语感主观删除。"
    },
    {
      "defect_id": 483630,
      "sentence": "从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalId](#getosaccountlocalid9-1)。",
      "reference_sentence": "",
      "line_num": 2147,
      "context": "{\"2142\":\"\",\"2143\":\"获取当前进程所属的系统账号ID，使用Promise异步回调。\",\"2144\":\"\",\"2145\":\"> **说明：**\",\"2146\":\">\",\"2147\":\"> 从API version 7开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalId](#getosaccountlocalid9-1)。\",\"2148\":\"\",\"2149\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2150\":\"\",\"2151\":\"**返回值：**\",\"2152\":\"\"}",
      "用户拒绝的修改": "从API version 7开始支持，从API version 9开始废弃。建议使用getOsAccountLocalId。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的功能性标记（如超链接、代码引用），避免因过度简化破坏文档导航或功能指引的完整性；需严格区分冗余修饰与必要技术要素，修改前需确认元素是否承担特定技术语义。"
    },
    {
      "defect_id": 483622,
      "sentence": "返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。",
      "reference_sentence": "",
      "line_num": 1887,
      "context": "{\"1882\":\"\",\"1883\":\"**参数：**\",\"1884\":\"\",\"1885\":\"| 参数名   | 类型                         | 必填 | 说明                                                                   |\",\"1886\":\"| -------- | ---------------------------- | ---- | --------------------------------------------------------------------- |\",\"1887\":\"| callback | AsyncCallback&lt;boolean&gt; | 是   | 回调函数。返回true表示当前账号为测试账号；返回false表示当前账号非测试账号。 |\",\"1888\":\"\",\"1889\":\"**示例：**\",\"1890\":\"\",\"1891\":\"  ```ts\",\"1892\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "返回true表示当前账号为测试账号；返回false表示非测试账号。",
      "注意事项": "保持参数说明的对称结构，避免省略关键主语导致歧义。技术文档中\"false\"对应的解释应保持\"当前账号\"主语完整，确保信息完整性优先于句式简洁。"
    },
    {
      "defect_id": 483668,
      "sentence": "Promise对象，返回当前进程所属的系统账号信息。",
      "reference_sentence": "",
      "line_num": 2507,
      "context": "{\"2502\":\"\",\"2503\":\"**返回值：**\",\"2504\":\"\",\"2505\":\"| 类型                                           | 说明                                       |\",\"2506\":\"| ---------------------------------------------- | ------------------------------------------ |\",\"2507\":\"| Promise&lt;[OsAccountInfo](#osaccountinfo)&gt; | Promise对象，返回当前进程所属的系统账号信息。 |\",\"2508\":\"\",\"2509\":\"**示例：**\",\"2510\":\"\",\"2511\":\"  ```ts\",\"2512\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "返回当前进程所属的系统账号信息。",
      "注意事项": "在技术文档中需保留明确标识返回类型的关键术语（如\"Promise对象\"），避免因过度精简导致类型说明与上下文表格信息脱节；需结合字段类型定义判断修饰成分是否冗余，优先确保参数类型与描述语义的完整对应。"
    },
    {
      "defect_id": 483660,
      "sentence": "从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9-1)。",
      "reference_sentence": "",
      "line_num": 2431,
      "context": "{\"2426\":\"\",\"2427\":\"queryActivatedOsAccountIds(): Promise&lt;Array&lt;number&gt;&gt;\",\"2428\":\"\",\"2429\":\"> **说明：**\",\"2430\":\">\",\"2431\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9-1)。\",\"2432\":\"\",\"2433\":\"查询当前处于激活状态的系统账号的ID列表。使用Promise异步回调。\",\"2434\":\"\",\"2435\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2436\":\"\"}",
      "用户拒绝的修改": "从API version 8开始支持，从API version 9废弃。建议使用[getActivatedOsAccountLocalIds](#getactivatedosaccountlocalids9-1)。",
      "注意事项": "在技术文档中处理版本变更描述时，需严格保留\"开始支持/废弃\"的固定表述结构，避免破坏技术术语的准确性；简化冗余时应优先确保关键信息（如版本号、动作起始点）的完整传达，而非机械删除重复字词。"
    },
    {
      "defect_id": 483663,
      "sentence": "系统能力：SystemCapability.Account.OsAccount",
      "reference_sentence": "",
      "line_num": 2467,
      "context": "{\"2462\":\">\",\"2463\":\"> 从API version 7开始支持，从API version 9开始废弃。替代方法仅向系统应用开放。\",\"2464\":\"\",\"2465\":\"**需要权限：** ohos.permission.MANAGE_LOCAL_ACCOUNTS，该权限仅系统应用可申请。\",\"2466\":\"\",\"2467\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2468\":\"\",\"2469\":\"**参数：**\",\"2470\":\"\",\"2471\":\"| 参数名   | 类型                                                 | 必填 | 说明                                           |\",\"2472\":\"| -------- | ---------------------------------------------------- | ---- | ---------------------------------------------- |\"}",
      "用户拒绝的修改": "系统能力：SystemCapability.Account.OsAccount。",
      "注意事项": "在修复冗余表达时需严格区分格式规范与内容冗余，优先处理重复性描述或冗余修饰语，避免对符合文档格式要求的标点符号进行误判和多余修改。"
    },
    {
      "defect_id": 491624,
      "sentence": "基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。",
      "reference_sentence": "",
      "line_num": 209,
      "context": "{\"204\":\"```\",\"205\":\"ArkUI_NodeHandle(* ArkUI_NativeNodeAPI_1::createNode) (ArkUI_NodeType type)\",\"206\":\"```\",\"207\":\"**描述：**\",\"208\":\"\",\"209\":\"基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。\",\"210\":\"\",\"211\":\"**参数:**\",\"212\":\"\",\"213\":\"| 名称 | 描述 | \",\"214\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "生成对应节点并返回节点对象指针。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的关键参数名称和API引用（如\"[ArkUI_NodeType]\"），避免因过度简化导致技术信息丢失；需结合上下文判断参数描述是否属于必要技术规范，不可仅凭语言简洁性进行删减。"
    },
    {
      "defect_id": 483685,
      "sentence": "指示新域账号信息。",
      "reference_sentence": "",
      "line_num": 2930,
      "context": "{\"2925\":\"**参数：**\",\"2926\":\"\",\"2927\":\"| 参数名      | 类型                                    | 必填 | 说明             |\",\"2928\":\"| ---------- | --------------------------------------- | ---- | --------------- |\",\"2929\":\"| oldAccountInfo   | [DomainAccountInfo](#domainaccountinfo8)  | 是   | 指示旧域账号信息。|\",\"2930\":\"| newAccountInfo   | [DomainAccountInfo](#domainaccountinfo8)  | 是   | 指示新域账号信息。|\",\"2931\":\"\",\"2932\":\"**返回值：**\",\"2933\":\"\",\"2934\":\"| 类型                      | 说明                     |\",\"2935\":\"| :------------------------ | ----------------------- |\"}",
      "用户拒绝的修改": "新域账号信息。",
      "注意事项": "在修复技术文档冗余表达时，需优先保留功能性动词（如“指示”）以明确参数用途，避免因过度简化破坏术语准确性；应结合上下文判断是否为行业规范用语，而非仅依赖主观语感。"
    },
    {
      "defect_id": 488995,
      "sentence": "访问在线网页时需添加网络权限：ohos.permission.INTERNET，具体申请方式请参考[声明权限](../security/AccessToken/declare-permissions.md)。",
      "reference_sentence": "",
      "line_num": 1300,
      "context": "{\"1295\":\"\",\"1296\":\"预渲染适用于Web页面启动和跳转等场景。通过结合BuilderNode，可以将ArkWeb组件提前离线预渲染，组件不会立即挂载到页面，而是在需要时通过NodeController动态挂载和显示。这样能够提升页面切换的流畅度和用户体验。\",\"1297\":\"\",\"1298\":\"> **说明**\",\"1299\":\">\",\"1300\":\"> 访问在线网页时需添加网络权限：ohos.permission.INTERNET，具体申请方式请参考[声明权限](../security/AccessToken/declare-permissions.md)。\",\"1301\":\"\",\"1302\":\"1. 创建载体，并创建ArkWeb组件。\",\"1303\":\"   ```typescript\",\"1304\":\"   // 载体Ability\",\"1305\":\"   // EntryAbility.ets\"}",
      "用户拒绝的修改": "访问在线网页需添加网络权限：ohos.permission.INTERNET。",
      "注意事项": "在删除冗余表达时应保留必要的技术指引（如权限申请链接），同时需结合上下文判断\"时\"等时间状语是否影响技术文档的准确性要求，避免过度简化导致关键信息丢失。"
    },
    {
      "defect_id": 483684,
      "sentence": "指示旧域账号信息。",
      "reference_sentence": "",
      "line_num": 2929,
      "context": "{\"2924\":\"\",\"2925\":\"**参数：**\",\"2926\":\"\",\"2927\":\"| 参数名      | 类型                                    | 必填 | 说明             |\",\"2928\":\"| ---------- | --------------------------------------- | ---- | --------------- |\",\"2929\":\"| oldAccountInfo   | [DomainAccountInfo](#domainaccountinfo8)  | 是   | 指示旧域账号信息。|\",\"2930\":\"| newAccountInfo   | [DomainAccountInfo](#domainaccountinfo8)  | 是   | 指示新域账号信息。|\",\"2931\":\"\",\"2932\":\"**返回值：**\",\"2933\":\"\",\"2934\":\"| 类型                      | 说明                     |\"}",
      "用户拒绝的修改": "旧域账号信息。",
      "注意事项": "修复冗余表达时应优先保留关键动词以确保参数说明的明确性，避免过度简化导致语义模糊；需结合参数表上下文判断术语的特定用途，谨慎删除可能承担专业功能的词汇。"
    },
    {
      "defect_id": 483679,
      "sentence": "如果获取成功，err为null，data为与该系统账号关联的SN码；否则为错误对象。",
      "reference_sentence": "",
      "line_num": 2737,
      "context": "{\"2732\":\"**参数：**\",\"2733\":\"\",\"2734\":\"| 参数名   | 类型                        | 必填 | 说明                                                                         |\",\"2735\":\"| -------- | --------------------------- | ---- | --------------------------------------------------------------------------- |\",\"2736\":\"| localId  | number                      | 是   | 系统账号ID。                                                                 |\",\"2737\":\"| callback | AsyncCallback&lt;number&gt; | 是   | 回调函数。如果获取成功，err为null，data为与该系统账号关联的SN码；否则为错误对象。 |\",\"2738\":\"\",\"2739\":\"**示例：** 获取ID为100的系统账号关联的SN码\",\"2740\":\"\",\"2741\":\"  ```ts\",\"2742\":\"  import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "如果获取成功，err为null，data为SN码。否则为错误对象。",
      "注意事项": "修复冗余表达时应优先保留技术文档必需的限定词（如\"与该系统账号关联的\"），避免因过度简化造成关键信息丢失；需结合参数上下文判断\"冗余\"内容是否实际为必要的技术约束条件。"
    },
    {
      "defect_id": 491663,
      "sentence": "注册节点事件函数。",
      "reference_sentence": "",
      "line_num": 943,
      "context": "{\"938\":\"```\",\"939\":\"int32_t(* ArkUI_NativeNodeAPI_1::registerNodeEvent) (ArkUI_NodeHandle node, ArkUI_NodeEventType eventType, int32_t targetId, void *userData)\",\"940\":\"```\",\"941\":\"**描述：**\",\"942\":\"\",\"943\":\"注册节点事件函数。\",\"944\":\"\",\"945\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"946\":\"\",\"947\":\"**参数:**\",\"948\":\"\"}",
      "用户拒绝的修改": "注册节点事件。",
      "注意事项": "在技术文档中，需优先保留专业术语完整性（如\"函数\"在API描述中具有明确类型指向性），避免过度简化导致语义模糊；修复前应结合上下文判断词汇是否属于技术概念而非冗余成分。"
    },
    {
      "defect_id": 491619,
      "sentence": "在节点上添加节点事件回调函数，用于接受该节点产生的节点事件。",
      "reference_sentence": "",
      "line_num": 166,
      "context": "{\"161\":\"```\",\"162\":\"int32_t(* ArkUI_NativeNodeAPI_1::addNodeEventReceiver) (ArkUI_NodeHandle node, void(*eventReceiver)(ArkUI_NodeEvent *event))\",\"163\":\"```\",\"164\":\"**描述：**\",\"165\":\"\",\"166\":\"在节点上添加节点事件回调函数，用于接受该节点产生的节点事件。\",\"167\":\"\",\"168\":\"不同于registerNodeEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"169\":\"\",\"170\":\"该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。\",\"171\":\"\"}",
      "用户拒绝的修改": "在节点上添加节点事件回调函数。",
      "注意事项": "在技术文档中处理冗余表达时，需优先保留关键限定词（如“该节点产生的”），避免因过度简化丢失技术细节或引发歧义；若原句后半部分用于区分上下文同类功能（如与全局回调函数对比），则不可删除。"
    },
    {
      "defect_id": 483697,
      "sentence": "Promise对象，返回获取的域服务器配置。",
      "reference_sentence": "",
      "line_num": 3193,
      "context": "{\"3188\":\"\",\"3189\":\"**返回值：**\",\"3190\":\"\",\"3191\":\"| 类型                      | 说明                     |\",\"3192\":\"| :------------------------ | ----------------------- |\",\"3193\":\"| Promise&lt;[DomainServerConfig](#domainserverconfig18)&gt; | Promise对象，返回获取的域服务器配置。 |\",\"3194\":\"\",\"3195\":\"**错误码：**\",\"3196\":\"\",\"3197\":\"| 错误码ID | 错误信息                     |\",\"3198\":\"| -------- | --------------------------- |\"}",
      "用户拒绝的修改": "返回获取的域服务器配置。",
      "注意事项": "修复冗余表达时需严格区分技术文档中必要的术语重复（如接口说明与类型定义间的呼应）和真正的冗余，优先保留与上下文参数类型相呼应的关键术语（如\"Promise对象\"），避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 491621,
      "sentence": "该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。",
      "reference_sentence": "",
      "line_num": 170,
      "context": "{\"165\":\"\",\"166\":\"在节点上添加节点事件回调函数，用于接受该节点产生的节点事件。\",\"167\":\"\",\"168\":\"不同于registerNodeEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"169\":\"\",\"170\":\"该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。\",\"171\":\"\",\"172\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"173\":\"\",\"174\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"175\":\"\"}",
      "用户拒绝的修改": "监听回调函数先于全局回调函数触发。",
      "注意事项": "保留必要技术术语和限定条件（如\"该函数添加的\"和\"registerNodeEventReceiver注册的\"），避免过度简化导致技术细节丢失；需结合上下文判断术语是否具有特定指代作用，技术文档中精确性优先于简洁性。"
    },
    {
      "defect_id": 491616,
      "sentence": "该函数添加的监听回调函数触发时机会先于registerNodeCustomEventReceiver注册的全局回调函数。",
      "reference_sentence": "",
      "line_num": 128,
      "context": "{\"123\":\"\",\"124\":\"在节点上添加自定义事件回调函数，用于接受该节点产生的自定义事件（如布局事件，绘制事件）。\",\"125\":\"\",\"126\":\"不同于registerNodeCustomEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"127\":\"\",\"128\":\"该函数添加的监听回调函数触发时机会先于registerNodeCustomEventReceiver注册的全局回调函数。\",\"129\":\"\",\"130\":\"避免直接保存ArkUI_NodeCustomEvent对象指针，数据会在回调结束后销毁。\",\"131\":\"\",\"132\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"133\":\"\"}",
      "用户拒绝的修改": "监听回调函数先于全局回调函数触发。",
      "注意事项": "在简化冗余表达时应优先保留技术文档特有的函数名称（如registerNodeCustomEventReceiver）和关键限定词（如\"该函数添加的\"），避免因过度简化导致技术细节丢失或上下文关联断裂。"
    },
    {
      "defect_id": 491525,
      "sentence": "基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"## 组件创建销毁\",\"6\":\"\",\"7\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\",\"8\":\"| -------- | ------- | ------- | ------- |  \",\"9\":\"| [ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle)(\\\\* [createNode](#createnode) )([ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype) type) | 基于[ArkUI_NodeType](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodetype)生成对应的节点并返回节点对象指针。  | 支持 | 支持在任意线程调用。 |\",\"10\":\"| void(\\\\* [disposeNode](#disposenode) )([ArkUI_NodeHandle](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_nodehandle) node) | 销毁节点指针指向的节点对象。  | 支持 | 在非UI线程中操作不符合要求的节点时，接口调用不生效。 |\",\"11\":\"\",\"12\":\"## 组件属性读写\",\"13\":\"\",\"14\":\"| 接口名 | 描述 | 非UI线程调用 | 多线程规格 |\"}",
      "用户拒绝的修改": "生成对应的节点并返回节点对象指针。",
      "注意事项": "在技术文档中保留必要的参数类型说明和上下文关联信息，避免删除关键技术参数（如ArkUI_NodeType），需区分技术性说明与冗余修饰，确保接口描述保持参数关联性和功能完整性。"
    },
    {
      "defect_id": 488724,
      "sentence": "DataShare用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# @ohos.data.dataShare (数据共享)\",\"2\":\"\",\"3\":\"**DataShare**用于应用管理其自身数据，同时支持同个设备上不同应用间的数据共享。\",\"4\":\"\",\"5\":\"> **说明：** \",\"6\":\">\",\"7\":\"> - 本模块首批接口从API version 9开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。\",\"8\":\">\"}",
      "用户拒绝的修改": "DataShare管理应用数据，支持同设备上不同应用间的数据共享。",
      "注意事项": "在删除修饰成分前需确认是否为系统接口的标准术语或已有固定表述，优先保持与上下文已有描述的一致性，避免破坏技术准确性。"
    },
    {
      "defect_id": 491670,
      "sentence": "注册事件回调统一入口函数。",
      "reference_sentence": "",
      "line_num": 985,
      "context": "{\"980\":\"```\",\"981\":\"void(* ArkUI_NativeNodeAPI_1::registerNodeEventReceiver) (void(*eventReceiver)(ArkUI_NodeEvent *event))\",\"982\":\"```\",\"983\":\"**描述：**\",\"984\":\"\",\"985\":\"注册事件回调统一入口函数。\",\"986\":\"\",\"987\":\"ArkUI框架会统一收集过程中产生的组件事件并通过注册的eventReceiver函数回调给开发者。\",\"988\":\"\",\"989\":\"重复调用时会覆盖前一次注册的函数。\",\"990\":\"\"}",
      "用户拒绝的修改": "注册事件回调函数",
      "注意事项": "修复冗余表达时需优先保留专业术语的完整性，技术文档中的限定词（如\"统一入口\"）可能承载关键技术含义，需结合上下文判断是否属于必要技术规范而非冗余表达。"
    },
    {
      "defect_id": 483677,
      "sentence": "> 从API version 8开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalIdForSerialNumber](#getosaccountlocalidforserialnumber9)。",
      "reference_sentence": "",
      "line_num": 2657,
      "context": "{\"2652\":\"\",\"2653\":\"通过SN码查询与其关联的系统账号的账号ID。使用callback异步回调。\",\"2654\":\"\",\"2655\":\"> **说明：**\",\"2656\":\">\",\"2657\":\"> 从API version 8开始支持，从API version 9开始废弃。建议使用[getOsAccountLocalIdForSerialNumber](#getosaccountlocalidforserialnumber9)。\",\"2658\":\"\",\"2659\":\"**系统能力：** SystemCapability.Account.OsAccount\",\"2660\":\"\",\"2661\":\"**参数：**\",\"2662\":\"\"}",
      "用户拒绝的修改": "> 从API version 8开始支持，API version 9废弃。建议使用[getOsAccountLocalIdForSerialNumber](#getosaccountlocalidforserialnumber9)。",
      "注意事项": "在技术文档中需优先保留版本变更的固定表述结构（如\"开始支持/废弃\"），避免将行业标准术语误判为冗余修饰；修改时应区分重复用词与必要语义强调，确保版本时间节点表述的准确性。"
    },
    {
      "defect_id": 491631,
      "sentence": "返回[ArkUI_IntSize](../reference/apis-arkui/_ark_u_i___int_size.md) 节点的宽高。",
      "reference_sentence": "",
      "line_num": 446,
      "context": "{\"441\":\"| -------- | -------- |\",\"442\":\"| node | 目标节点对象。  | \",\"443\":\"\",\"444\":\"**返回：**\",\"445\":\"\",\"446\":\"[ArkUI_IntSize](../reference/apis-arkui/_ark_u_i___int_size.md) 节点的宽高。\",\"447\":\"\",\"448\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，接口返回ArkUI_IntSize默认值{0, 0}。\",\"449\":\"\",\"450\":\"**示例：**\",\"451\":\"```\"}",
      "用户拒绝的修改": "返回节点宽高。",
      "注意事项": "修复冗余表达时需保留必要的技术术语和超链接，避免因过度简化导致文档准确性下降（如删除类型名称或参考链接）；需结合上下文判断冗余成分是否承载关键信息（如类型关联性、API约束条件）。"
    },
    {
      "defect_id": 491615,
      "sentence": "不同于registerNodeCustomEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。",
      "reference_sentence": "",
      "line_num": 126,
      "context": "{\"121\":\"```\",\"122\":\"**描述：**\",\"123\":\"\",\"124\":\"在节点上添加自定义事件回调函数，用于接受该节点产生的自定义事件（如布局事件，绘制事件）。\",\"125\":\"\",\"126\":\"不同于registerNodeCustomEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"127\":\"\",\"128\":\"该函数添加的监听回调函数触发时机会先于registerNodeCustomEventReceiver注册的全局回调函数。\",\"129\":\"\",\"130\":\"避免直接保存ArkUI_NodeCustomEvent对象指针，数据会在回调结束后销毁。\",\"131\":\"\"}",
      "用户拒绝的修改": "允许在节点上添加多个事件接受器。",
      "注意事项": "在简化冗余表达时需保留必要的技术对比和上下文（如\"不同于registerNodeCustomEventReceiver\"的对比关系），避免因过度删减导致关键区别信息丢失；技术文档中涉及API差异说明时，不可省略功能参照对象。"
    },
    {
      "defect_id": 491622,
      "sentence": "避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。",
      "reference_sentence": "",
      "line_num": 172,
      "context": "{\"167\":\"\",\"168\":\"不同于registerNodeEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"169\":\"\",\"170\":\"该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。\",\"171\":\"\",\"172\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"173\":\"\",\"174\":\"在非UI线程调用函数操作已挂载到UI树上的节点时，函数返回错误码。\",\"175\":\"\",\"176\":\"**参数:**\",\"177\":\"\"}",
      "用户拒绝的修改": "避免保存事件对象指针。",
      "注意事项": "修复冗余表达时应优先保留技术术语和关键条件（如\"ArkUI_NodeEvent\"和\"直接\"），避免过度简化导致技术细节丢失；需结合上下文判断专业名词是否承担特定技术含义，不可仅凭语句长度进行简化。"
    },
    {
      "defect_id": 490067,
      "sentence": "从图像源中读取图片的EXIF方向信息。",
      "reference_sentence": "",
      "line_num": 2008,
      "context": "{\"2003\":\"    this.getFileBuffer(context).then((buf: ArrayBuffer | undefined) => {\",\"2004\":\"      let imageSource = image.createImageSource(buf);\",\"2005\":\"      if (!imageSource) {\",\"2006\":\"        return;\",\"2007\":\"      }\",\"2008\":\"      // 从图像源中读取图片的EXIF方向信息。\",\"2009\":\"      imageSource.getImageProperty(image.PropertyKey.ORIENTATION).then((orientation) => {\",\"2010\":\"        this.rotateOrientation = this.getOrientation(orientation);\",\"2011\":\"        this.text1 = this.text1 + orientation;\",\"2012\":\"        let options: image.DecodingOptions = {\",\"2013\":\"          'editable': true,\"}",
      "用户拒绝的修改": "从图像源读取EXIF方向信息。",
      "注意事项": "在修复冗余表达时需优先保留技术术语的完整性和上下文准确性，避免因过度简化导致关键信息丢失（如“图像源”作为变量名需保留介词结构）；同时应结合代码上下文判断术语指代是否明确，避免误删必要限定词（如“图片的”可能用于区分其他类型EXIF信息）。"
    },
    {
      "defect_id": 491620,
      "sentence": "不同于registerNodeEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。",
      "reference_sentence": "",
      "line_num": 168,
      "context": "{\"163\":\"```\",\"164\":\"**描述：**\",\"165\":\"\",\"166\":\"在节点上添加节点事件回调函数，用于接受该节点产生的节点事件。\",\"167\":\"\",\"168\":\"不同于registerNodeEventReceiver的全局注册函数，该函数允许在同一个节点上添加多个事件接受器。\",\"169\":\"\",\"170\":\"该函数添加的监听回调函数触发时机会先于registerNodeEventReceiver注册的全局回调函数。\",\"171\":\"\",\"172\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"173\":\"\"}",
      "用户拒绝的修改": "允许在节点上添加多个事件接受器。",
      "注意事项": "保留原文中关键的技术对比和上下文信息，避免过度简化导致功能差异说明丢失；在修复冗余表达前需确认\"冗余\"部分是否承担了区分概念或强调特性的重要功能。"
    },
    {
      "defect_id": 491671,
      "sentence": "ArkUI框架会统一收集过程中产生的组件事件并通过注册的eventReceiver函数回调给开发者。",
      "reference_sentence": "",
      "line_num": 987,
      "context": "{\"982\":\"```\",\"983\":\"**描述：**\",\"984\":\"\",\"985\":\"注册事件回调统一入口函数。\",\"986\":\"\",\"987\":\"ArkUI框架会统一收集过程中产生的组件事件并通过注册的eventReceiver函数回调给开发者。\",\"988\":\"\",\"989\":\"重复调用时会覆盖前一次注册的函数。\",\"990\":\"\",\"991\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"992\":\"\"}",
      "用户拒绝的修改": "ArkUI框架收集组件事件并通过注册的eventReceiver函数回调给开发者",
      "注意事项": "在技术文档场景下，需优先保留描述框架行为的关键限定词（如\"统一收集过程中产生的\"），避免将技术性流程描述误判为冗余；修改前应确认上下文是否存在隐性技术逻辑依赖，必要时通过追问澄清用户意图。"
    },
    {
      "defect_id": 491678,
      "sentence": "成功。",
      "reference_sentence": "",
      "line_num": 1031,
      "context": "{\"1026\":\"| -------- | -------- |\",\"1027\":\"| parent | 目标节点对象。  | \",\"1028\":\"\",\"1029\":\"**返回：**\",\"1030\":\"\",\"1031\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"1032\":\"\",\"1033\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)函数参数异常。\",\"1034\":\"\",\"1035\":\"[ARKUI_ERROR_CODE_ON_INVALID_THREAD](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止在非UI线程调用此函数操作已挂载到UI树上的节点。\",\"1036\":\"\"}",
      "用户拒绝的修改": "成功",
      "注意事项": "在技术文档中保留标点符号以维持结构一致性（如错误码描述后的句号），避免因过度精简破坏格式规范；修改前需确认上下文是否存在统一标点模式，优先遵循现有格式而非单纯追求语言简洁。"
    },
    {
      "defect_id": 491679,
      "sentence": "函数参数异常。",
      "reference_sentence": "",
      "line_num": 1033,
      "context": "{\"1028\":\"\",\"1029\":\"**返回：**\",\"1030\":\"\",\"1031\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"1032\":\"\",\"1033\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)函数参数异常。\",\"1034\":\"\",\"1035\":\"[ARKUI_ERROR_CODE_ON_INVALID_THREAD](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止在非UI线程调用此函数操作已挂载到UI树上的节点。\",\"1036\":\"\",\"1037\":\"**示例：**\",\"1038\":\"```\"}",
      "用户拒绝的修改": "函数参数异常",
      "注意事项": "修复冗余表达时需准确识别真正冗余成分，避免误删必要标点或破坏技术文档格式规范；在错误代码描述等标准化内容中，应优先保持原文结构完整性，仅在明确存在语义重复时进行简化。"
    },
    {
      "defect_id": 491667,
      "sentence": "系统中未找到Native接口的动态实现库。",
      "reference_sentence": "",
      "line_num": 963,
      "context": "{\"958\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"959\":\"\",\"960\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)函数参数异常。\",\"961\":\"\",\"962\":\"[ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED](../reference/apis-arkui/_ark_u_i___native_module.\",\"963\":\"md#arkui_errorcode)系统中未找到Native接口的动态实现库。\",\"964\":\"\",\"965\":\"[ARKUI_ERROR_CODE_NOT_SUPPORTED_FOR_ARKTS_NODE](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止对BuilderNode生成的节点， 进行设置属性、重置属性、设置事件与新增或修改子节点操作。\",\"966\":\"\",\"967\":\"[ARKUI_ERROR_CODE_ON_INVALID_THREAD](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止在非UI线程操作已挂载到UI树上的节点。\",\"968\":\"\"}",
      "用户拒绝的修改": "未找到Native接口的动态实现库",
      "注意事项": "在删除冗余表达前需确认技术术语的完整性（如\"系统中\"可能用于区分系统级/应用级错误），并检查上下文格式一致性（如错误码描述是否统一采用主谓结构）。"
    },
    {
      "defect_id": 491672,
      "sentence": "重复调用时会覆盖前一次注册的函数。",
      "reference_sentence": "",
      "line_num": 989,
      "context": "{\"984\":\"\",\"985\":\"注册事件回调统一入口函数。\",\"986\":\"\",\"987\":\"ArkUI框架会统一收集过程中产生的组件事件并通过注册的eventReceiver函数回调给开发者。\",\"988\":\"\",\"989\":\"重复调用时会覆盖前一次注册的函数。\",\"990\":\"\",\"991\":\"避免直接保存ArkUI_NodeEvent对象指针，数据会在回调结束后销毁。\",\"992\":\"\",\"993\":\"如果需要和组件实例绑定，可以使用addNodeEventReceiver函数接口。\",\"994\":\"\"}",
      "用户拒绝的修改": "重复调用会覆盖前一次注册的函数",
      "注意事项": "在技术文档中优先保留逻辑连接词（如\"时\"）以确保条件关系清晰，避免过度简化破坏专业表述的严谨性；需结合上下文判断冗余成分是否实际承担语法功能。"
    },
    {
      "defect_id": 491682,
      "sentence": "解注册事件回调统一入口函数。",
      "reference_sentence": "",
      "line_num": 1077,
      "context": "{\"1072\":\"```\",\"1073\":\"void(* ArkUI_NativeNodeAPI_1::unregisterNodeEventReceiver) ()\",\"1074\":\"```\",\"1075\":\"**描述：**\",\"1076\":\"\",\"1077\":\"解注册事件回调统一入口函数。\",\"1078\":\"\",\"1079\":\"在非UI线程调用函数不生效。\",\"1080\":\"\",\"1081\":\"**示例：**\",\"1082\":\"```\"}",
      "用户拒绝的修改": "解注册事件回调函数",
      "注意事项": "修复冗余表达时应优先保留专业术语和上下文关键信息，避免删除具有特定技术含义的限定词（如\"统一入口\"），需结合函数声明和文档架构判断术语必要性。"
    },
    {
      "defect_id": 491686,
      "sentence": "成功。",
      "reference_sentence": "",
      "line_num": 1111,
      "context": "{\"1106\":\"| parent | 父节点对象。  | \",\"1107\":\"| child | 子节点对象。  | \",\"1108\":\"\",\"1109\":\"**返回：**\",\"1110\":\"\",\"1111\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"1112\":\"\",\"1113\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)函数参数异常。\",\"1114\":\"\",\"1115\":\"[ARKUI_ERROR_CODE_NOT_SUPPORTED_FOR_ARKTS_NODE](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止对BuilderNode生成的节点， 进行设置属性、重置属性、设置事件与新增或修改子节点操作。\",\"1116\":\"\"}",
      "用户拒绝的修改": "成功",
      "注意事项": "保留技术文档必需的标点规范（如句号结尾），优先维护格式一致性；在上下文存在标准化表述模板时，避免对符合模板的简洁表达进行\"冗余修复\"。"
    },
    {
      "defect_id": 491681,
      "sentence": "解注册节点自定义事件回调统一入口函数。",
      "reference_sentence": "",
      "line_num": 1055,
      "context": "{\"1050\":\"```\",\"1051\":\"void(* ArkUI_NativeNodeAPI_1::unregisterNodeCustomEventReceiver) ()\",\"1052\":\"```\",\"1053\":\"**描述：**\",\"1054\":\"\",\"1055\":\"解注册节点自定义事件回调统一入口函数。\",\"1056\":\"\",\"1057\":\"在非UI线程调用函数不生效。\",\"1058\":\"\",\"1059\":\"**示例：**\",\"1060\":\"```\"}",
      "用户拒绝的修改": "解注册节点自定义事件回调函数",
      "注意事项": "在技术文档中优先保留行业专用术语和API命名中的核心限定词（如\"统一入口\"），即使存在表面冗余也应通过上下文判断其必要性，避免因过度简化损害技术准确性。"
    },
    {
      "defect_id": 492415,
      "sentence": "   规避方案：使用reg2或reg3替换reg1。",
      "reference_sentence": "",
      "line_num": 106,
      "context": "{\"101\":\"   console.log(\\\"JSON.stringify(res) = \\\" + JSON.stringify(res));\",\"102\":\"   // 期望输出: JSON.stringify(res) = [\\\"ax\\\"]\",\"103\":\"   // 实际输出: JSON.stringify(res) = null\",\"104\":\"   ```\",\"105\":\"\",\"106\":\"   规避方案：使用reg2或reg3替换reg1。\",\"107\":\"\",\"108\":\"   ```ts\",\"109\":\"   let reg1 = /a(?:|x)$/;\",\"110\":\"   let reg2 = /a(?:x)?$/;\",\"111\":\"   let reg3 = /a(?:x){0,1}$/;\"}",
      "用户拒绝的修改": "使用reg2或reg3替换。",
      "注意事项": "修复冗余表达时应优先保留技术文档中明确指向的操作对象（如reg1），避免因过度简化导致关键信息丢失或操作指向模糊，确保技术准确性高于句式简洁性。"
    },
    {
      "defect_id": 491794,
      "sentence": "在测算回调函数中设置节点测算完成后的宽和高。",
      "reference_sentence": "",
      "line_num": 1368,
      "context": "{\"1363\":\"```\",\"1364\":\"int32_t(* ArkUI_NativeNodeAPI_1::setMeasuredSize) (ArkUI_NodeHandle node, int32_t width, int32_t height)\",\"1365\":\"```\",\"1366\":\"**描述：**\",\"1367\":\"\",\"1368\":\"在测算回调函数中设置节点测算完成后的宽和高。\",\"1369\":\"\",\"1370\":\"在非UI线程调用函数返回错误码。\",\"1371\":\"\",\"1372\":\"**参数:**\",\"1373\":\"\"}",
      "用户拒绝的修改": "设置节点测算完成后的宽和高。",
      "注意事项": "在技术文档中保留必要的上下文限定词（如“在测算回调函数中”），避免因过度简化导致关键操作场景信息丢失；优先确保专业术语和API调用上下文的准确性，而非单纯追求句式简洁。"
    },
    {
      "defect_id": 492410,
      "sentence": "   规避方案：暂无。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"   console.log(\\\"res = \\\" + res);\",\"13\":\"   // 期望输出: res = ♂\",\"14\":\"   // 实际输出: res = /♂/\",\"15\":\"   ```\",\"16\":\"\",\"17\":\"   规避方案：暂无。\",\"18\":\"   > **说明：**\",\"19\":\"   > \",\"20\":\"   > 正则匹配\\\\b（单词边界）遇到某些ASCII编码之外的字符时，会将其当成ASCII字符来处理，从而将不是单词边界匹配识别成单词边界。\",\"21\":\"\",\"22\":\"### 方舟正则运算对于先行断言((?=pattern)或(?!pattern)) 嵌套在后行断言((?<=pattern)或(?<!pattern))内部的场景与预期不一致\"}",
      "用户拒绝的修改": "暂无规避方案。",
      "注意事项": "修复时应优先保持原文的文档结构和上下文一致性，避免破坏固定标题格式（如\"规避方案：\"作为独立标题）；仅在修饰成分明确冗余且不影响技术表述时调整语序，避免过度修正导致语义重心偏移。"
    },
    {
      "defect_id": 491680,
      "sentence": "禁止在非UI线程调用此函数操作已挂载到UI树上的节点。",
      "reference_sentence": "",
      "line_num": 1035,
      "context": "{\"1030\":\"\",\"1031\":\"[ARKUI_ERROR_CODE_NO_ERROR](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)成功。\",\"1032\":\"\",\"1033\":\"[ARKUI_ERROR_CODE_PARAM_INVALID](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)函数参数异常。\",\"1034\":\"\",\"1035\":\"[ARKUI_ERROR_CODE_ON_INVALID_THREAD](../reference/apis-arkui/_ark_u_i___native_module.md#arkui_errorcode)禁止在非UI线程调用此函数操作已挂载到UI树上的节点。\",\"1036\":\"\",\"1037\":\"**示例：**\",\"1038\":\"```\",\"1039\":\"ArkUI_NativeNodeAPI_1 *multiThreadNodeApi = nullptr;\",\"1040\":\"OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeApi);\"}",
      "用户拒绝的修改": "禁止在非UI线程调用此函数操作已挂载到UI树上的节点",
      "注意事项": "修复冗余表达时应精准识别冗余元素(如重复动词或冗余修饰语)，避免误判技术文档中必要的限定词；优先保持术语准确性，仅在确保信息完整性的前提下删除重复表述。"
    },
    {
      "defect_id": 492411,
      "sentence": "   > **说明：**\r   > \r   > 正则匹配\\b（单词边界）遇到某些ASCII编码之外的字符时，会将其当成ASCII字符来处理，从而将不是单词边界匹配识别成单词边界。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "{\"13\":\"   // 期望输出: res = ♂\",\"14\":\"   // 实际输出: res = /♂/\",\"15\":\"   ```\",\"16\":\"\",\"17\":\"   规避方案：暂无。\",\"18\":\"   > **说明：**\",\"19\":\"   > \",\"20\":\"   > 正则匹配\\\\b（单词边界）遇到某些ASCII编码之外的字符时，会将其当成ASCII字符来处理，从而将不是单词边界匹配识别成单词边界。\",\"21\":\"\",\"22\":\"### 方舟正则运算对于先行断言((?=pattern)或(?!pattern)) 嵌套在后行断言((?<=pattern)或(?<!pattern))内部的场景与预期不一致\",\"23\":\"\"}",
      "用户拒绝的修改": "正则匹配\\b遇到某些ASCII编码之外的字符时，会将其当成ASCII字符来处理，导致非单词边界被识别成单词边界。",
      "注意事项": "修复冗余表达时应优先保留术语解释性括号（如“（单词边界）”），避免过度简化导致技术概念模糊；在技术文档场景下，需平衡简洁性与术语准确性，确认删除内容是否影响关键信息传递。"
    },
    {
      "defect_id": 492409,
      "sentence": "如果使用方舟正则运算时结果与期望不符，请检查以下场景。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS运行时常见问题\",\"2\":\"\",\"3\":\"## 方舟正则运算与预期输出结果不一致场景\",\"4\":\"\",\"5\":\"如果使用方舟正则运算时结果与期望不符，请检查以下场景。\",\"6\":\"\",\"7\":\"### 方舟正则运算对于\\\\b处理与预期不一致\",\"8\":\"\",\"9\":\"   ```ts\",\"10\":\"   let str = \\\"\\\\u2642\\\";\"}",
      "用户拒绝的修改": "检查方舟正则运算结果与期望不符的场景。",
      "注意事项": "在简化冗余表达时应优先保留原句的指导性动词和条件逻辑结构，避免破坏技术文档中关键操作指引的明确性；需结合上下文判断句式转换是否影响问题排查的流程引导，确保修改后的表述同时满足简洁性和操作指导性要求。"
    },
    {
      "defect_id": 492412,
      "sentence": "   规避方案：使用/(?<=abcd)ef/代替/(?<=ab(?=c)cd)ef/。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"   console.log('res:${\\\"abcdef\\\".match(/(?<=ab(?=c)cd)ef/)}');\",\"26\":\"   // 期望输出: res:ef\",\"27\":\"   // 实际输出: res:null\",\"28\":\"   ```\",\"29\":\"\",\"30\":\"   规避方案：使用/(?<=abcd)ef/代替/(?<=ab(?=c)cd)ef/。\",\"31\":\"\",\"32\":\"### 方舟正则运算对于大小写的处理与预期不一致\",\"33\":\"\",\"34\":\"   ```ts\",\"35\":\"   let res = /\\\\u{10400}/ui.test(\\\"\\\\u{10428}\\\");\"}",
      "用户拒绝的修改": "使用/(?<=abcd)ef/代替。",
      "注意事项": "修复冗余表达时应先确认用户是否存在特殊测试意图或依赖特定语法结构，避免在未验证功能等效性时直接简化正则表达式；优先保留用户原始逻辑并通过注释说明优化建议，而非强制替换。"
    },
    {
      "defect_id": 492417,
      "sentence": "   > **注意：**\r   > \r   > 注意必须在Async函数内部，外部无法捕获Async函数内部的异常，外部只能通过errorManager.on()监听。",
      "reference_sentence": "",
      "line_num": 132,
      "context": "{\"127\":\"      })\",\"128\":\"   ```\",\"129\":\"\",\"130\":\"2. 在Async函数内部，针对可能发生异常的代码块添加try-catch逻辑，直接捕获可能出现的异常。\",\"131\":\"\",\"132\":\"> **注意：**\",\"133\":\"> \",\"134\":\"> 注意必须在Async函数内部，外部无法捕获Async函数内部的异常，外部只能通过errorManager.on()监听。\",\"135\":\"\",\"136\":\"\",\"137\":\"**查看Async函数内部是否有异常的方式**\"}",
      "用户拒绝的修改": "注意：必须在Async函数内部捕获异常，外部只能通过errorManager.on()监听。",
      "注意事项": "修复冗余表达时应优先保留技术文档中必要的重复强调（如\"外部\"的双重说明），并严格遵循原文段落结构（注意提示符与换行格式）来保持上下文一致性。"
    },
    {
      "defect_id": 492166,
      "sentence": "- 调用[OH_ArkUI_GetModuleInterface](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_getmoduleinterface)接口，入参传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。例如：",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"通过这次升级，开发者能专注于业务逻辑实现，无需关注并发与线程切换等底层细节。在复杂场景下，开发者将获得更加可预测、高性能的界面创建体验。\",\"20\":\"\",\"21\":\"## 使用场景\",\"22\":\"\",\"23\":\"- 调用[OH_ArkUI_GetModuleInterface](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_getmoduleinterface)接口，入参传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。例如：\",\"24\":\"\",\"25\":\"  ```cpp\",\"26\":\"  ArkUI_NativeNodeAPI_1 *multiThreadNodeAPI = nullptr;\",\"27\":\"  OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeAPI);\",\"28\":\"  ```\"}",
      "用户拒绝的修改": "- 调用[OH_ArkUI_GetModuleInterface]接口，传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。例如：",
      "注意事项": "保留技术文档中必要的参数类型说明（如\"入参\"）和完整接口链接路径，避免过度简化影响术语准确性和文档可查性，技术语境下冗余修饰可能具有明确指示作用。"
    },
    {
      "defect_id": 492597,
      "sentence": "供应商标识号。",
      "reference_sentence": "",
      "line_num": 600,
      "context": "{\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\",\"603\":\"\",\"604\":\"## DeviceConnectionType<sup>20+</sup>\",\"605\":\"\"}",
      "用户拒绝的修改": "供应商标识号表示设备供应商的标识号。",
      "注意事项": "修复时应严格遵循上下文格式规范，优先保持名词短语的简洁性，避免在属性描述中添加冗余的主谓结构。"
    },
    {
      "defect_id": 498917,
      "sentence": "[heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\r以windows为例:\rD:\\> ...\\rawheap_translator.exe ...\\example.rawheap 命令中，需要保证“D:\\”路径具有读写权限。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"| -------- | ----------------- | ---------------------------------- |\",\"67\":\"| \\\\<rawheap_file\\\\> | 必选参数，OOM时生成的rawheap文件路径：<br>/data/log/reliability/resource_leak/memory_leak | 解析指定目录（如：D:\\\\temp\\\\rawheap）下的rawheap文件：<br>rawheap_translator D:\\\\temp\\\\rawheap\\\\xxx.rawheap<br>解析当前目录下的rawheap文件：<br>rawheap_translator xxx.rawheap |\",\"68\":\"| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；<br>不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot | 解析当前目录下的rawheap文件，并在指定路径（如：D:\\\\temp）下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap D:\\\\temp\\\\xxx.heapsnapshot<br>解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap xxx.heapsnapshot |\",\"69\":\"> **注意：**\",\"70\":\">\",\"71\":\"> [heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\",\"72\":\"> 以windows为例:\",\"73\":\"> D:\\\\> ...\\\\rawheap_translator.exe ...\\\\example.rawheap 命令中，需要保证“D:\\\\”路径具有读写权限。\",\"74\":\"\",\"75\":\"## 解析命令示例\",\"76\":\"\"}",
      "用户拒绝的修改": "[heapsnapshot_file] 需要指向具有读写权限的路径。如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。例如，在Windows中，命令D:\\> ...\\rawheap_translator.exe ...\\example.rawheap需要保证“D:\\”路径具有读写权限。",
      "注意事项": "保留原始技术细节和示例的完整性，避免过度简化导致关键信息丢失；优先通过分句或调整标点优化可读性，而非直接删除用户认为重要的修饰成分。"
    },
    {
      "defect_id": 492592,
      "sentence": "以太网设备信息。",
      "reference_sentence": "",
      "line_num": 588,
      "context": "{\"583\":\"| LAN_STATIC<sup>11+</sup>| 2    | LAN连接静态配置网络信息。    |\",\"584\":\"| LAN_DHCP<sup>11+</sup>  | 3    | LAN连接动态配置网络信息。    |\",\"585\":\"\",\"586\":\"## EthernetDeviceInfos<sup>20+</sup>\",\"587\":\"\",\"588\":\"以太网设备信息。\",\"589\":\"\",\"590\":\"**系统接口**：此接口为系统接口。\",\"591\":\"\",\"592\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"593\":\"\"}",
      "用户拒绝的修改": "以太网设备信息包含设备的基本属性。",
      "注意事项": "修复时应优先保持原文的名词短语属性，仅在上下文明确需要完整句子时补充主谓结构，避免过度扩展简洁的术语性表述。"
    },
    {
      "defect_id": 492595,
      "sentence": "设备连接模式。",
      "reference_sentence": "",
      "line_num": 598,
      "context": "{\"593\":\"\",\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\",\"603\":\"\"}",
      "用户拒绝的修改": "设备连接模式表示设备的连接类型。",
      "注意事项": "修复时应优先保持技术文档属性说明的简洁性，避免添加冗余的主谓结构；需结合上下文判断字段说明是否需要完整句子，表格类文档通常只需名词短语或术语解释。"
    },
    {
      "defect_id": 499783,
      "sentence": "**系统接口：** 此接口为系统接口。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"## HdrScreenshotOptions<sup>20+</sup>\",\"34\":\"\",\"35\":\"设置截取HDR图像的信息。\",\"36\":\"\",\"37\":\"**系统接口：** 此接口为系统接口。\",\"38\":\"\",\"39\":\"**系统能力：** SystemCapability.WindowManager.WindowManager.Core\",\"40\":\"\",\"41\":\"| 名称                 | 类型          | 必填 | 说明                                                         |\",\"42\":\"| ---------------------- | ------------- | ---- | ------------------------------------------------------------ |\"}",
      "用户拒绝的修改": "此接口为系统接口。",
      "注意事项": "修复冗余表达时应保留必要格式标记（如**系统接口：**），避免误删关键信息标签；优先简化重复内容而非直接删除整句，确保文档结构完整性。"
    },
    {
      "defect_id": 499784,
      "sentence": "**系统能力：** SystemCapability.WindowManager.WindowManager.Core",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"设置截取HDR图像的信息。\",\"36\":\"\",\"37\":\"**系统接口：** 此接口为系统接口。\",\"38\":\"\",\"39\":\"**系统能力：** SystemCapability.WindowManager.WindowManager.Core\",\"40\":\"\",\"41\":\"| 名称                 | 类型          | 必填 | 说明                                                         |\",\"42\":\"| ---------------------- | ------------- | ---- | ------------------------------------------------------------ |\",\"43\":\"| displayId<sup>8+</sup> | number        | 否   | 表示截取图像的显示设备[Display](js-apis-display.md#display)的ID号，该参数应为整数。 |\",\"44\":\"| isNotificationNeeded<sup>14+</sup>| boolean        | 否   | 表示截取图像之后是否发送截屏通知，true表示发送截屏通知，false表示不发送截屏通知，默认值为true。截屏通知可以通过[captureStatusChange](js-apis-display.md#displayoncapturestatuschange12)接口监听。   |\"}",
      "用户拒绝的修改": "系统能力：SystemCapability.WindowManager.WindowManager.Core",
      "注意事项": "修复冗余表达时需确保技术文档中固定术语（如\"SystemCapability\"字段）的完整性，避免过度简化导致关键信息丢失；需区分重复冗余与技术规范固定格式，优先保留API文档特有的标准化表述结构。"
    },
    {
      "defect_id": 498923,
      "sentence": "原因：当前工具版本低于rawheap文件版本，升级工具可解决。",
      "reference_sentence": "",
      "line_num": 200,
      "context": "{\"195\":\"[INFO ] SetBitField             set Length offset 8\",\"196\":\"[INFO ] SetBitField             set Data offset 16\",\"197\":\"[INFO ] ReadVersion             current rawheap version is 1.0.0\",\"198\":\"[ERROR] ParseRawheap            The rawheap file's version 1.1.0 is not matched the current rawheap translator, please use the newest version of the translator!\",\"199\":\"```\",\"200\":\"原因：当前工具版本低于rawheap文件版本，升级工具可解决。\",\"201\":\"\",\"202\":\"### 文件没有权限\",\"203\":\"工具解析时，提示：open file failed\",\"204\":\"```bash\",\"205\":\"[INFO ] ParseVersion            current metadata version is 1.0.0\"}",
      "用户拒绝的修改": "原因：工具版本低于rawheap文件版本，升级工具解决。",
      "注意事项": "在删除\"冗余表达\"前需确认修饰词是否承载关键上下文信息（如\"当前\"强调版本时效性），避免过度简化导致技术细节丢失；保留建议性语气词（如\"可\"）以维持解决方案的可行性提示。"
    },
    {
      "defect_id": 492593,
      "sentence": "网络接口名。",
      "reference_sentence": "",
      "line_num": 596,
      "context": "{\"591\":\"\",\"592\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"593\":\"\",\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\"}",
      "用户拒绝的修改": "网络接口名表示网络接口的名称。",
      "注意事项": "修复时应优先保持属性描述的简洁性，避免在表格说明等特定格式中强行添加主谓结构；需明确区分完整句子与属性短语的使用场景，仅在上下文缺失主谓时补充必要成分。"
    },
    {
      "defect_id": 492596,
      "sentence": "供应商名称。",
      "reference_sentence": "",
      "line_num": 599,
      "context": "{\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\",\"603\":\"\",\"604\":\"## DeviceConnectionType<sup>20+</sup>\"}",
      "用户拒绝的修改": "供应商名称表示设备供应商的名称。",
      "注意事项": "修复时应优先识别上下文格式规范（如表格属性说明通常使用名词短语），避免添加冗余主谓结构；严格遵循\"属性名称=属性说明\"的简洁表达原则，保持文档格式统一性。"
    },
    {
      "defect_id": 500274,
      "sentence": "开发者通过引入[lowpower_audio_sink_base.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-base-h.md)、[lowpower_audio_sink.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md)、[lowpower_video_sink.h](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md)、 [lowpower_video_sink_base.h](../../reference/apis-media-kit/capi-lowpower-video-sink-base-h.md) 头文件，使用音视频播放相关API。",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"    libohaudio.so\",\"61\":\")\",\"62\":\"target_link_libraries(sample PUBLIC ${BASE_LIBRARY})\",\"63\":\"```\",\"64\":\"\",\"65\":\"开发者通过引入[lowpower_audio_sink_base.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-base-h.md)、[lowpower_audio_sink.h](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md)、[lowpower_video_sink.h](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md)、 [lowpower_video_sink_base.h](../../reference/apis-media-kit/capi-lowpower-video-sink-base-h.md) 头文件，使用音视频播放相关API。\",\"66\":\"\",\"67\":\"1. 创建播放器<br>\",\"68\":\"根据实际情况，可通过[OH_AVSource_CreateWithDataSource()](../../reference/apis-avcodec-kit/_a_v_source.md#oh_avsource_createwithdatasource)/[OH_AVSource_CreateWithFD()](../../reference/apis-avcodec-kit/_a_v_source.md#oh_avsource_createwithfd)/[OH_AVSource_CreateWithURI()](../../reference/apis-avcodec-kit/_a_v_source.md#oh_avsource_createwithuri)来创建[OH_AVSource](../../reference/apis-avcodec-kit/_a_v_source.md#oh_avsource) ，通过`OH_AVSource`调用[OH_AVDemuxer_CreateWithSource()](../../reference/apis-avcodec-kit/_a_v_demuxer.md#oh_avdemuxer_createwithsource)，创建解封装器，获取视频的元信息。根据以上信息，调用  [OH_LowPowerAudioSink_CreateByMime](../../reference/apis-media-kit/capi-lowpower-audio-sink-h.md#oh_lowpoweraudiosink_createbymime)或[OH_LowPowerVideoSink_CreateByMime](../../reference/apis-media-kit/capi-lowpower-video-sink-h.md#oh_lowpowervideosink_createbymime)来创建播放器。\",\"69\":\"    ```\",\"70\":\"    source_ = OH_AVSource_CreateWithFD(info.inputFd, info.inputFileOffset, info.inputFileSize);\"}",
      "用户拒绝的修改": "引入头文件，使用音视频播放API",
      "注意事项": "在技术文档中保留具体头文件/API名称等关键技术要素，仅精简重复性描述；当列举多个技术组件时，优先保留完整列表而非完全删除，可通过折叠格式优化可读性。"
    },
    {
      "defect_id": 492598,
      "sentence": "产品名称。",
      "reference_sentence": "",
      "line_num": 601,
      "context": "{\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\",\"603\":\"\",\"604\":\"## DeviceConnectionType<sup>20+</sup>\",\"605\":\"\",\"606\":\"以太网设备连接模式。\"}",
      "用户拒绝的修改": "产品名称表示设备的产品名称。",
      "注意事项": "修复冗余表达时应优先保持参数表的简洁属性描述风格，避免强行补全主谓结构破坏格式统一；需结合上下文识别技术文档的特定写作规范，在语法完整性和领域惯例间保持平衡。"
    },
    {
      "defect_id": 492600,
      "sentence": "以太网设备连接模式。",
      "reference_sentence": "",
      "line_num": 606,
      "context": "{\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\",\"603\":\"\",\"604\":\"## DeviceConnectionType<sup>20+</sup>\",\"605\":\"\",\"606\":\"以太网设备连接模式。\",\"607\":\"\",\"608\":\"**系统接口**：此接口为系统接口。\",\"609\":\"\",\"610\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"611\":\"\"}",
      "用户拒绝的修改": "以太网设备连接模式定义设备的连接类型。",
      "注意事项": "修复时应优先保留原文简洁属性描述，仅在上下文需要完整句子时补充主谓结构；特别关注表格/参数说明场景下条目化短语的语法特征(无主谓)，避免过度语法补全。"
    },
    {
      "defect_id": 498916,
      "sentence": "<rawheap_file> 必选参数，OOM时生成的rawheap文件路径：<br>/data/log/reliability/resource_leak/memory_leak | 解析指定目录（如：D:\\temp\\rawheap）下的rawheap文件：<br>rawheap_translator D:\\temp\\rawheap\\xxx.rawheap<br>解析当前目录下的rawheap文件：<br>rawheap_translator xxx.rawheap",
      "reference_sentence": "",
      "line_num": 67,
      "context": "{\"62\":\"```\",\"63\":\"### 参数列表\",\"64\":\"\",\"65\":\"| 选项 | 描述 | 举例 |\",\"66\":\"| -------- | ----------------- | ---------------------------------- |\",\"67\":\"| \\\\<rawheap_file\\\\> | 必选参数，OOM时生成的rawheap文件路径：<br>/data/log/reliability/resource_leak/memory_leak | 解析指定目录（如：D:\\\\temp\\\\rawheap）下的rawheap文件：<br>rawheap_translator D:\\\\temp\\\\rawheap\\\\xxx.rawheap<br>解析当前目录下的rawheap文件：<br>rawheap_translator xxx.rawheap |\",\"68\":\"| [heapsnapshot_file] | 可选参数，指定生成的文件名称和路径，后缀名必须是heapsnapshot；<br>不指定则默认为当前路径，生成的文件名如：hprof_2024-11-19-21-13-20.heapsnapshot | 解析当前目录下的rawheap文件，并在指定路径（如：D:\\\\temp）下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap D:\\\\temp\\\\xxx.heapsnapshot<br>解析当前目录下的rawheap文件，并在当前路径下生成的heapsnapshot：<br>rawheap_translator xxx.rawheap xxx.heapsnapshot |\",\"69\":\"> **注意：**\",\"70\":\">\",\"71\":\"> [heapsnapshot_file] 需要指向具有读写权限的路径，如果未指定参数，需要保证当前执行cmd命令时所在目录具有读写权限。<br>\",\"72\":\"> 以windows为例:\"}",
      "用户拒绝的修改": "<rawheap_file> 必选参数，OOM时生成的rawheap文件路径。例如：/data/log/reliability/resource_leak/memory_leak。解析指定目录下的rawheap文件：rawheap_translator D:\\temp\\rawheap\\xxx.rawheap。解析当前目录下的rawheap文件：rawheap_translator xxx.rawheap。",
      "注意事项": "保留技术文档中必要的路径格式示例和具体使用场景说明，避免过度简化导致关键操作指引缺失；区分冗余修饰语和有效信息，优先删除重复性描述而非具体用例。"
    },
    {
      "defect_id": 492594,
      "sentence": "设备名称。",
      "reference_sentence": "",
      "line_num": 597,
      "context": "{\"592\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"593\":\"\",\"594\":\"| 名称           | 类型                    | 必填 | 说明                                                         |\",\"595\":\"| ------------   | ----------------------- | ---|------------------------------------------------------------ |\",\"596\":\"| ifaceName      | string                  | 是 | 网络接口名。      |\",\"597\":\"| deviceName     | string                  | 是 | 设备名称。    |\",\"598\":\"| connectionMode | [DeviceConnectionType](#deviceconnectiontype20)  | 是 | 设备连接模式。 |\",\"599\":\"| supplierName   | string                  | 是 | 供应商名称。 |\",\"600\":\"| supplierId     | string                  | 是 | 供应商标识号。 |\",\"601\":\"| productName    | string                  | 是 | 产品名称。 |\",\"602\":\"| maximumRate    | string                  | 是 | 最大连接速率。 |\"}",
      "用户拒绝的修改": "设备名称表示设备的名称。",
      "注意事项": "修复表格属性说明时应保持名词短语结构，避免添加主谓成分；需根据上下文识别技术文档的特定格式要求，优先保持术语简洁性而非强制补全句子结构。"
    },
    {
      "defect_id": 492167,
      "sentence": "详情请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"  ```cpp\",\"26\":\"  ArkUI_NativeNodeAPI_1 *multiThreadNodeAPI = nullptr;\",\"27\":\"  OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeAPI);\",\"28\":\"  ```\",\"29\":\"\",\"30\":\"  详情请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。\",\"31\":\"\",\"32\":\"- 使用[OH_ArkUI_PostAsyncUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postasyncuitask)接口将任务调度到系统线程池中执行。\",\"33\":\"\",\"34\":\"- 当开发者在自己维护的非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。\",\"35\":\"  \"}",
      "用户拒绝的修改": "详情参见[多线程NDK接口说明]。",
      "注意事项": "维护技术文档时应优先保留规范术语和功能性超链接，避免过度简化导致信息缺失；修改前需确认上下文是否存在特殊格式要求或行业惯例。"
    },
    {
      "defect_id": 492602,
      "sentence": "以太网设备为外接连接模式。",
      "reference_sentence": "",
      "line_num": 615,
      "context": "{\"610\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"611\":\"\",\"612\":\"| 名称                  | 值   | 说明                        |\",\"613\":\"| --------------------- | ---- | -------------------------- |\",\"614\":\"| BUILT_IN              | 0    | 以太网设备为内置连接模式。 |\",\"615\":\"| EXTERNAL              | 1    | 以太网设备为外接连接模式。 |\"}",
      "用户拒绝的修改": "以太网设备为外接连接模式表示设备外接连接。",
      "注意事项": "修复表格属性说明时应保留简洁的短语结构，避免强行补全主谓成分；优先识别上下文格式要求（如表格项需用名词性短语而非完整句子）。"
    },
    {
      "defect_id": 492158,
      "sentence": "在多线程环境中使用NDK创建UI组件的开发指南",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# NDK支持多线程创建组件\",\"2\":\"\",\"3\":\"在多线程环境中使用NDK创建UI组件的开发指南\",\"4\":\"\",\"5\":\"## 概述\",\"6\":\"\",\"7\":\"在当前版本NDK中，组件的创建与初始化必须在UI线程中执行。这要求开发者在使用接口时要切换回UI线程，增加了代码复杂度，限制了组件创建过程的灵活性与性能。\",\"8\":\"\"}",
      "用户拒绝的修改": "NDK在多线程环境中创建UI组件的指南",
      "注意事项": "保留技术文档特有的关键术语和结构惯例，在精简冗余表达时需优先确保核心信息完整性和领域术语准确性，避免过度简化导致专业表述缺失。"
    },
    {
      "defect_id": 492601,
      "sentence": "以太网设备为内置连接模式。",
      "reference_sentence": "",
      "line_num": 614,
      "context": "{\"609\":\"\",\"610\":\"**系统能力**：SystemCapability.Communication.NetManager.Ethernet\",\"611\":\"\",\"612\":\"| 名称                  | 值   | 说明                        |\",\"613\":\"| --------------------- | ---- | -------------------------- |\",\"614\":\"| BUILT_IN              | 0    | 以太网设备为内置连接模式。 |\",\"615\":\"| EXTERNAL              | 1    | 以太网设备为外接连接模式。 |\"}",
      "用户拒绝的修改": "以太网设备为内置连接模式表示设备内置连接。",
      "注意事项": "修复表格属性说明时应保持短语化表述，避免添加冗余的主谓结构；需优先遵循技术文档中\"值-说明\"列使用名词短语而非完整句子的行业惯例。"
    },
    {
      "defect_id": 492170,
      "sentence": "- 尽管UI框架提供了线程安全的组件创建与属性设置接口，单个组件内部仍然不是线程安全的。请避免在多个线程中同时操作同一组件或同一组件树，否则可能出现不可预测的结果。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"\",\"38\":\"## 调用规范与线程安全\",\"39\":\"\",\"40\":\"- 多线程接口使用规范请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。调用接口时必须检查返回值，在非UI线程中不合法调用接口将返回错误码。\",\"41\":\"\",\"42\":\"- 尽管UI框架提供了线程安全的组件创建与属性设置接口，单个组件内部仍然不是线程安全的。请避免在多个线程中同时操作同一组件或同一组件树，否则可能出现不可预测的结果。\",\"43\":\"\",\"44\":\"- 在多线程接口中，组件有以下两种状态：\",\"45\":\"\",\"46\":\"  - **Free（游离状态）：** 组件未挂载到UI主树，不参与UI流水线，属性可安全更新。\",\"47\":\"  - **Attached（已挂载状态）：** 组件已挂载，交由UI流水线管理，属性更新必须在UI线程中调用，否则将返回错误码。\"}",
      "用户拒绝的修改": "- 尽管UI框架提供了线程安全的接口，单个组件内部仍不是线程安全的。请避免在多个线程中同时操作同一组件或组件树，否则可能出现不可预测的结果。",
      "注意事项": "修复冗余表达时需优先保留技术文档中的核心术语和必要限定词（如\"组件创建与属性设置\"），避免因过度简化导致关键信息丢失；对重复用词（如\"同一\"）的修改需结合上下文判断是否为必要强调，在技术规范类文本中重复可能具有明确语义的作用。"
    },
    {
      "defect_id": 492202,
      "sentence": "通过示例展示如何通过多线程NDK接口实现UI组件并行化创建，从而提升用户体验。",
      "reference_sentence": "",
      "line_num": 351,
      "context": "{\"346\":\"2. 建议将UI线程中执行的组件创建任务拆分成更细粒度的任务，分派给不同工作线程执行，以降低主线程负载，提高页面启动与更新的流畅度。\",\"347\":\"\",\"348\":\"3. 在后台线程预先创建常用组件树，提升性能敏感场景的用户体验。\",\"349\":\"\",\"350\":\"## 最佳实践\",\"351\":\"通过示例展示如何通过多线程NDK接口实现UI组件并行化创建，从而提升用户体验。\",\"352\":\"\",\"353\":\"[最佳实践源码地址](https://gitee.com/openharmony/applications_app_samples/tree/master/code/UI/NdkBuildOnMultiThread/README.md)\"}",
      "用户拒绝的修改": "通过示例展示如何通过多线程NDK接口实现UI组件并行化创建。",
      "注意事项": "修复冗余表达时需结合上下文判断信息必要性，保留总结性短语(如\"从而提升用户体验\")与前后建议形成逻辑呼应，避免破坏技术文档中\"最佳实践\"章节强调结果价值的行文惯例。"
    },
    {
      "defect_id": 492418,
      "sentence": "若开发者仅需要查看Async函数内部是否产生异常，首先需要在DevEco Studio终端执行以下hilog命令开启debug级别日志打印：",
      "reference_sentence": "",
      "line_num": 139,
      "context": "{\"134\":\"> 注意必须在Async函数内部，外部无法捕获Async函数内部的异常，外部只能通过errorManager.on()监听。\",\"135\":\"\",\"136\":\"\",\"137\":\"**查看Async函数内部是否有异常的方式**\",\"138\":\"\",\"139\":\"若开发者仅需要查看Async函数内部是否产生异常，首先需要在DevEco Studio终端执行以下hilog命令开启debug级别日志打印：\",\"140\":\"\",\"141\":\"```shell\",\"142\":\"   hilog -b D\",\"143\":\"```\",\"144\":\"\"}",
      "用户拒绝的修改": "若查看Async函数内部异常，需在DevEco Studio终端执行以下hilog命令开启debug日志。",
      "注意事项": "在简化冗余表达时应优先保留技术文档中的关键限定词（如\"级别\"）和逻辑连接词（如\"首先\"），避免因过度删除影响操作步骤的准确性和指导性；需结合上下文判断\"冗余\"成分是否承载重要技术含义或流程指示作用。"
    },
    {
      "defect_id": 492168,
      "sentence": "- 当开发者在自己维护的非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"  详情请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。\",\"31\":\"\",\"32\":\"- 使用[OH_ArkUI_PostAsyncUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postasyncuitask)接口将任务调度到系统线程池中执行。\",\"33\":\"\",\"34\":\"- 当开发者在自己维护的非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。\",\"35\":\"  \",\"36\":\"- 另提供[OH_ArkUI_PostUITaskAndWait](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitaskandwait)接口，接口将组件挂载到UI树的任务提交到UI线程执行后，调用线程会阻塞等待UI线程任务结束。此接口可能导致调用线程长时间阻塞，不推荐频繁使用。\",\"37\":\"\",\"38\":\"## 调用规范与线程安全\",\"39\":\"\"}",
      "用户拒绝的修改": "- 开发者在非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask]接口将挂载任务提交到UI线程执行。",
      "注意事项": "精简冗余表达时应优先保留技术性限定词（如\"自己维护的非UI线程\"）和具体操作对象（如\"组件挂载到UI树的任务\"），避免因过度简化导致关键信息丢失或技术准确性受损，同时需保持与上下文同类表述的格式一致性。"
    },
    {
      "defect_id": 492198,
      "sentence": "框架将打印以下日志提示：",
      "reference_sentence": "",
      "line_num": 331,
      "context": "{\"326\":\"\",\"327\":\"- 在非UI线程调用不支持多线程的接口将返回错误码。\",\"328\":\"- 挂载到UI主树后，在非UI线程中调用多线程接口将返回错误码。\",\"329\":\"- 在Native节点下树前，必须先卸载嵌套的ArkTs节点，以避免在非UI线程中遍历节点树时访问ArkTS节点导致崩溃。\",\"330\":\"\",\"331\":\"框架将打印以下日志提示：\",\"332\":\"\",\"333\":\"```\",\"334\":\"CheckIsThreadSafeNodeTree failed. thread safe node tree contains unsafe node: ${nodeid}\",\"335\":\"```\",\"336\":\"\"}",
      "用户拒绝的修改": "框架将打印日志提示。",
      "注意事项": "修复冗余表达时需优先确认指示性词汇（如“以下”）是否承担上下文衔接功能，避免因过度简化破坏文档逻辑连贯性；结合具体语境判断冗余性，保留必要的前后指代关系。"
    },
    {
      "defect_id": 499782,
      "sentence": "设置截取HDR图像的信息。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"| isNotificationNeeded<sup>14+</sup>| boolean        | 否   | 表示截取图像之后是否发送截屏通知，true表示发送截屏通知，false表示不发送截屏通知，默认值为true。截屏通知可以通过[captureStatusChange](js-apis-display.md#displayoncapturestatuschange12)接口监听。   |\",\"31\":\"| isCaptureFullOfScreen<sup>19+</sup> | boolean        | 否   | 表示是否截取当前Screen上的所有display。对于一个Screen上有多个display的场景，为true表示截取整个Screen，false则只截取displayId所在逻辑屏的区域，默认值为false。 |\",\"32\":\"\",\"33\":\"## HdrScreenshotOptions<sup>20+</sup>\",\"34\":\"\",\"35\":\"设置截取HDR图像的信息。\",\"36\":\"\",\"37\":\"**系统接口：** 此接口为系统接口。\",\"38\":\"\",\"39\":\"**系统能力：** SystemCapability.WindowManager.WindowManager.Core\",\"40\":\"\"}",
      "用户拒绝的修改": "用于设置HDR图像截取信息。",
      "注意事项": "修复时应优先使用直接描述核心功能的动词（如\"截取\"），避免保留\"设置...信息\"等冗余结构；确保修改后的表述与上下文功能描述句式（如\"表示是否截取...\"）保持术语和语法风格一致。"
    },
    {
      "defect_id": 507291,
      "sentence": "对包含在此对象中的所有键值对进行排序。排序顺序是根据键的Unicode代码点。该方法使用稳定的排序算法（保留具有相等键的键值对之间的相对顺序）。",
      "reference_sentence": "",
      "line_num": 360,
      "context": "{\"355\":\"\",\"356\":\"### sort<sup>9+</sup>\",\"357\":\"\",\"358\":\"sort(): void\",\"359\":\"\",\"360\":\"对包含在此对象中的所有键值对进行排序。排序顺序是根据键的Unicode代码点。该方法使用稳定的排序算法（保留具有相等键的键值对之间的相对顺序）。\",\"361\":\"\",\"362\":\"**原子化服务API**：从API version 11开始，该接口支持在原子化服务中使用。\",\"363\":\"\",\"364\":\"**系统能力：** SystemCapability.Utils.Lang\",\"365\":\"\"}",
      "用户拒绝的修改": "对对象中的所有键值对进行排序。排序依据键的Unicode代码点。该方法使用稳定排序算法。",
      "注意事项": "保留括号内的技术性补充说明以确保准确性，优先通过拆分句子结构（如分号或列表）而非删除关键信息来简化冗余表达。"
    },
    {
      "defect_id": 504126,
      "sentence": "Free（游离状态）：组件未挂载到UI主树，不参与UI流水线，属性可安全更新。",
      "reference_sentence": "",
      "line_num": 46,
      "context": "{\"41\":\"\",\"42\":\"- 尽管UI框架提供了线程安全的组件创建与属性设置接口，单个组件内部仍然不是线程安全的。请避免在多个线程中同时操作同一组件或同一组件树，否则可能出现不可预测的结果。\",\"43\":\"\",\"44\":\"- 在多线程接口中，组件有以下两种状态：\",\"45\":\"\",\"46\":\"  - **Free（游离状态）：** 组件未挂载到UI主树，不参与UI流水线，属性可安全更新。\",\"47\":\"  - **Attached（已挂载状态）：** 组件已挂载，交由UI流水线管理，属性更新必须在UI线程中调用，否则将返回错误码。\",\"48\":\"\",\"49\":\"## 示例\",\"50\":\"\",\"51\":\"以下是接口使用示例。为简化编程和工程管理，在编写并行化组件创建代码前，请先参考[接入ArkTS页面](ndk-access-the-arkts-page.md)指导文档，在native侧使用面向对象的方式对将ArkUI_NodeHandle封装为ArkUINode对象。\"}",
      "用户拒绝的修改": "Free状态：组件未挂载到UI主树，属性可安全更新。",
      "注意事项": "修复冗余表达时需优先保留关键术语和上下文对比信息，避免删除技术文档中用于区分概念的核心描述（如“不参与UI流水线”是解释Free状态的重要特征，与Attached状态形成明确对比）。"
    },
    {
      "defect_id": 503325,
      "sentence": "该属性仅对CustomBuilder类型的背景生效。如果设置了ignoresLayoutSafeAreaEdges，则背景的布局区域为包含了扩展安全区的范围。默认值：Alignment.Center",
      "reference_sentence": "",
      "line_num": 75,
      "context": "{\"70\":\"\",\"71\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"72\":\"\",\"73\":\"| 名称          | 类型   | 必填 | 说明                                                         |\",\"74\":\"| ------------- | ------ | ---- | ------------------------------------------------------------ |\",\"75\":\"| align<sup>10+</sup>          | [Alignment](ts-appendix-enums.md#alignment) | 否   | 自定义背景与组件的对齐方式。该属性仅对CustomBuilder类型的背景生效。如果设置了ignoresLayoutSafeAreaEdges，则背景的布局区域为包含了扩展安全区的范围。<br/>默认值：Alignment.Center<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。 |\",\"76\":\"| ignoresLayoutSafeAreaEdges | Array<[LayoutSafeAreaEdge](ts-types.md#layoutsafeareaedge12)> | 否   | 配置背景要扩展到的安全区。未配置该属性时，CustomBuilder背景不扩展，ResourceColor背景扩展至父组件全部安全区。<br/> 默认值：[] <br/>**说明：**<br/>动态调整该属性会按照设置的扩展区域重新生成背景。<br/>默认值：LayoutSafeAreaEdge.All<br>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"77\":\"\",\"78\":\"> **说明：**\",\"79\":\">\",\"80\":\"> 背景设置ignoreLayoutSafeArea之后生效的条件为父组件设置了对应方向的[safeAreaPadding](./ts-universal-attributes-size.md#safeareapadding14)。\"}",
      "用户拒绝的修改": "该属性仅对CustomBuilder类型的背景生效。设置ignoresLayoutSafeAreaEdges时，背景布局区域包含扩展安全区。默认值：Alignment.Center",
      "注意事项": "修复技术文档时应优先保留条件逻辑的完整性（如\"如果...则...\"结构），避免过度简化导致技术准确性受损；需结合上下文判断冗余修饰是否为必要术语（如\"范围\"），确保核心参数和逻辑关系不被模糊化。"
    },
    {
      "defect_id": 508697,
      "sentence": "发生错误时提供的数据。",
      "reference_sentence": "",
      "line_num": 146,
      "context": "{\"141\":\">\",\"142\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"143\":\"\",\"144\":\"| 参数       | 类型   | 描述                        |\",\"145\":\"| ---------- | ------ | -------------------------- |\",\"146\":\"| errcode    | number | 错误码。                    |\",\"147\":\"| msg        | string | 错误信息。                  |\",\"148\":\"\",\"149\":\"错误码1为默认错误码，错误信息和处理建议详见下表：\",\"150\":\"\",\"151\":\"| 错误信息   | 描述                        | 处理建议 |\"}",
      "用户拒绝的修改": "发生错误时提供数据。",
      "注意事项": "修复冗余表达时需优先确保句子主谓结构完整，结合上下文判断是否属于技术文档中的必要限定描述（如\"的数据\"可能强调数据来源），避免因过度简化破坏原意或语法准确性。"
    },
    {
      "defect_id": 504122,
      "sentence": "使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"  详情请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。\",\"31\":\"\",\"32\":\"- 使用[OH_ArkUI_PostAsyncUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postasyncuitask)接口将任务调度到系统线程池中执行。\",\"33\":\"\",\"34\":\"- 当开发者在自己维护的非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。\",\"35\":\"  \",\"36\":\"- 另提供[OH_ArkUI_PostUITaskAndWait](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitaskandwait)接口，接口将组件挂载到UI树的任务提交到UI线程执行后，调用线程会阻塞等待UI线程任务结束。此接口可能导致调用线程长时间阻塞，不推荐频繁使用。\",\"37\":\"\",\"38\":\"## 调用规范与线程安全\",\"39\":\"\"}",
      "用户拒绝的修改": "使用[OH_ArkUI_PostUITask]接口将组件挂载到UI树的任务提交到UI线程执行。",
      "注意事项": "在技术文档中保留接口完整链接格式以确保引用准确性，当上下文存在多接口对比或首次出现时需保持完整格式；避免过度简化关键操作描述，优先保留技术术语完整性而非单纯缩短句子长度。"
    },
    {
      "defect_id": 506032,
      "sentence": "声明ArkWeb NDK接口异常错误码。\r",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# arkweb_error_code.h\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"\",\"5\":\"声明ArkWeb NDK接口异常错误码。\",\"6\":\"\",\"7\":\"**库：** libohweb.so\",\"8\":\"\",\"9\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"10\":\"\"}",
      "用户拒绝的修改": "声明ArkWeb NDK接口异常错误码。",
      "注意事项": "修复前需严格区分内容冗余与格式问题（如换行符），优先检查上下文中的特殊符号标记而非直接修改文本内容；当用户反馈\"工具误报\"时，应重新核对问题类型与修复目标的匹配性。"
    },
    {
      "defect_id": 504121,
      "sentence": "使用[OH_ArkUI_PostAsyncUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postasyncuitask)接口将任务调度到系统线程池中执行。",
      "reference_sentence": "",
      "line_num": 32,
      "context": "{\"27\":\"  OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeAPI);\",\"28\":\"  ```\",\"29\":\"\",\"30\":\"  详情请参考[多线程NDK接口说明](./ndk-build-on-multi-thread-api.md)。\",\"31\":\"\",\"32\":\"- 使用[OH_ArkUI_PostAsyncUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postasyncuitask)接口将任务调度到系统线程池中执行。\",\"33\":\"\",\"34\":\"- 当开发者在自己维护的非UI线程中创建UI组件时，使用[OH_ArkUI_PostUITask](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitask)接口将组件挂载到UI树的任务提交到UI线程执行。\",\"35\":\"  \",\"36\":\"- 另提供[OH_ArkUI_PostUITaskAndWait](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_postuitaskandwait)接口，接口将组件挂载到UI树的任务提交到UI线程执行后，调用线程会阻塞等待UI线程任务结束。此接口可能导致调用线程长时间阻塞，不推荐频繁使用。\",\"37\":\"\"}",
      "用户拒绝的修改": "使用[OH_ArkUI_PostAsyncUITask]接口将任务调度到系统线程池中执行。",
      "注意事项": "在修复冗余表达时，需优先检查上下文是否已存在相同链接的完整引用格式（如问题上下文第32/34/36行均保留完整路径），若上下文存在统一规范，应保持格式一致性而非单纯缩短文本长度。"
    },
    {
      "defect_id": 504119,
      "sentence": "调用[OH_ArkUI_GetModuleInterface](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_getmoduleinterface)接口，入参传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。例如：",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"通过这次升级，开发者能专注于业务逻辑实现，无需关注并发与线程切换等底层细节。在复杂场景下，开发者将获得更加可预测、高性能的界面创建体验。\",\"20\":\"\",\"21\":\"## 使用场景\",\"22\":\"\",\"23\":\"- 调用[OH_ArkUI_GetModuleInterface](../reference/apis-arkui/_ark_u_i___native_module.md#oh_arkui_getmoduleinterface)接口，入参传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。例如：\",\"24\":\"\",\"25\":\"  ```cpp\",\"26\":\"  ArkUI_NativeNodeAPI_1 *multiThreadNodeAPI = nullptr;\",\"27\":\"  OH_ArkUI_GetModuleInterface(ARKUI_MULTI_THREAD_NATIVE_NODE, ArkUI_NativeNodeAPI_1, multiThreadNodeAPI);\",\"28\":\"  ```\"}",
      "用户拒绝的修改": "调用[OH_ArkUI_GetModuleInterface]接口，入参传入 `ARKUI_MULTI_THREAD_NATIVE_NODE` 获取多线程NDK接口集合。",
      "注意事项": "保留技术文档中必要的完整引用路径信息，避免因过度简化导致开发者无法准确定位源码或接口；优先核查用户是否在上下文中明确依赖特定格式（如超链接结构），确保技术术语和接口名称的完整性。"
    },
    {
      "defect_id": 508699,
      "sentence": "检查PluginComponentTemplate参数中source字段是否有误。",
      "reference_sentence": "",
      "line_num": 153,
      "context": "{\"148\":\"\",\"149\":\"错误码1为默认错误码，错误信息和处理建议详见下表：\",\"150\":\"\",\"151\":\"| 错误信息   | 描述                        | 处理建议 |\",\"152\":\"| ------ | -------------------------- | ----------------- |\",\"153\":\"| package path is empty. | 包路径为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"154\":\"| Query Active OsAccountIds failed! | 获取激活的用户ID失败。 | 检查Account服务是否异常，或检查应用是否具备用户ID查询权限。    |\",\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\"}",
      "用户拒绝的修改": "检查PluginComponentTemplate参数中的source字段。",
      "注意事项": "修复冗余表达时需保留必要的技术术语完整性，避免删除关键操作动词（如\"是否有误\"），特别注意技术文档中检查类指令的完整性要求，优先保持功能表述清晰性而非单纯追求句式简洁。"
    },
    {
      "defect_id": 504186,
      "sentence": "通过示例展示如何通过多线程NDK接口实现UI组件并行化创建，从而提升用户体验。",
      "reference_sentence": "",
      "line_num": 351,
      "context": "{\"346\":\"2. 建议将UI线程中执行的组件创建任务拆分成更细粒度的任务，分派给不同工作线程执行，以降低主线程负载，提高页面启动与更新的流畅度。\",\"347\":\"\",\"348\":\"3. 在后台线程预先创建常用组件树，提升性能敏感场景的用户体验。\",\"349\":\"\",\"350\":\"## 最佳实践\",\"351\":\"通过示例展示如何通过多线程NDK接口实现UI组件并行化创建，从而提升用户体验。\",\"352\":\"\",\"353\":\"[最佳实践源码地址](https://gitee.com/openharmony/applications_app_samples/tree/master/code/UI/NdkBuildOnMultiThread/README.md)\"}",
      "用户拒绝的修改": "通过示例展示如何使用多线程NDK接口实现UI组件并行化创建，以提升用户体验。",
      "注意事项": "修复时应优先保留技术文档特有的术语严谨性和句式规范，避免过度简化破坏技术细节的准确性；修改前需结合上下文判断是否真正存在冗余，技术场景中\"通过\"和\"使用\"存在语义差异时不宜强行替换。"
    },
    {
      "defect_id": 508707,
      "sentence": "根据模型类型，将对应的[Plugin组件工具代码](#plugin组件工具)拷贝至项目的`ets/pages/plugin_component.js`文件中。",
      "reference_sentence": "",
      "line_num": 227,
      "context": "{\"222\":\"      .width('100%')\",\"223\":\"      .height('100%')\",\"224\":\"    }\",\"225\":\"  }\",\"226\":\"  ```\",\"227\":\"- 根据模型类型，将对应的[Plugin组件工具代码](#plugin组件工具)拷贝至项目的`ets/pages/plugin_component.js`文件中。\",\"228\":\"- 在`module.json5`配置文件中增加`requestPermissions`标签，允许使用方查询其他应用信息：\",\"229\":\"  ```json\",\"230\":\"  \\\"requestPermissions\\\": [\",\"231\":\"    {\",\"232\":\"      \\\"name\\\": \\\"ohos.permission.GET_BUNDLE_INFO_PRIVILEGED\\\",\"}",
      "用户拒绝的修改": "将对应的[Plugin组件工具代码](#plugin组件工具)拷贝至`ets/pages/plugin_component.js`文件中。",
      "注意事项": "在删除\"冗余表达\"前需确认是否包含关键限定条件（如\"根据模型类型\"），技术文档中条件和路径的精确性优先于简洁性；结合上下文判断\"项目的\"等修饰词是否影响路径唯一性。"
    },
    {
      "defect_id": 508701,
      "sentence": "检查PluginComponentTemplate参数中source字段是否有误。",
      "reference_sentence": "",
      "line_num": 155,
      "context": "{\"150\":\"\",\"151\":\"| 错误信息   | 描述                        | 处理建议 |\",\"152\":\"| ------ | -------------------------- | ----------------- |\",\"153\":\"| package path is empty. | 包路径为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"154\":\"| Query Active OsAccountIds failed! | 获取激活的用户ID失败。 | 检查Account服务是否异常，或检查应用是否具备用户ID查询权限。    |\",\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\",\"159\":\"| Bms moduleResPaths is empty. | 插件包moduleResPaths属性为空。 |  检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常                   |\",\"160\":\"| Bms get hapPath failed! Cannot find hap according to BundleName and ModuleName! | 获取hapPath失败。  |   检查PluginComponentTemplate参数中bundleName字段是否有误，检查bundleName字段对应的模块是否已正确安装。               |\"}",
      "用户拒绝的修改": "检查PluginComponentTemplate参数中的source字段。",
      "注意事项": "保留技术文档中必要的限定词（如\"是否有误\"），避免过度简化导致语义模糊；需结合上下文判断重复信息是否属于技术术语或必要说明，确保修改后建议保持明确的操作指导性。"
    },
    {
      "defect_id": 508703,
      "sentence": "检查PluginComponentTemplate参数中bundleName字段是否有误。",
      "reference_sentence": "",
      "line_num": 157,
      "context": "{\"152\":\"| ------ | -------------------------- | ----------------- |\",\"153\":\"| package path is empty. | 包路径为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"154\":\"| Query Active OsAccountIds failed! | 获取激活的用户ID失败。 | 检查Account服务是否异常，或检查应用是否具备用户ID查询权限。    |\",\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\",\"159\":\"| Bms moduleResPaths is empty. | 插件包moduleResPaths属性为空。 |  检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常                   |\",\"160\":\"| Bms get hapPath failed! Cannot find hap according to BundleName and ModuleName! | 获取hapPath失败。  |   检查PluginComponentTemplate参数中bundleName字段是否有误，检查bundleName字段对应的模块是否已正确安装。               |\",\"161\":\"\",\"162\":\"\"}",
      "用户拒绝的修改": "检查PluginComponentTemplate参数中的bundleName字段。",
      "注意事项": "修复时应优先保持技术文档中检查项的完整性，确认\"是否有误\"等表述是否为必要操作指引；同时需结合上下文检查同类条目表达模式，确保修改后与其他条目保持术语和结构一致性。"
    },
    {
      "defect_id": 508705,
      "sentence": "检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常",
      "reference_sentence": "",
      "line_num": 159,
      "context": "{\"154\":\"| Query Active OsAccountIds failed! | 获取激活的用户ID失败。 | 检查Account服务是否异常，或检查应用是否具备用户ID查询权限。    |\",\"155\":\"| Template source is empty. | 模板source为空。 | 检查PluginComponentTemplate参数中source字段是否有误。  |\",\"156\":\"| Bms bundleManager is nullptr. | 获取BundleManager失败。 |  检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                  |\",\"157\":\"| App bundleName is empty. | 应用包名为空。  | 检查PluginComponentTemplate参数中bundleName字段是否有误。                   |\",\"158\":\"| Bms get bundleName failed! | 获取包名失败。  |  检查PluginComponentTemplate参数中bundleName字段是否有误，或检查bundleName字段对应的包是否已正确安装，或检查BMS服务是否异常，或检查应用是否具备ohos.permission.GET_BUNDLE_INFO_PRIVILEGED,ohos.permission.GET_BUNDLE_INFO,ohos.permission.REQUIRE_FORM权限。                |\",\"159\":\"| Bms moduleResPaths is empty. | 插件包moduleResPaths属性为空。 |  检查bundleName字段对应的包的moduleResPaths属性是否异常，或检查BMS服务是否异常                   |\",\"160\":\"| Bms get hapPath failed! Cannot find hap according to BundleName and ModuleName! | 获取hapPath失败。  |   检查PluginComponentTemplate参数中bundleName字段是否有误，检查bundleName字段对应的模块是否已正确安装。               |\",\"161\":\"\",\"162\":\"\",\"163\":\"## 示例（加载PluginComponent）\",\"164\":\"\"}",
      "用户拒绝的修改": "检查bundleName字段对应的包的moduleResPaths属性，或BMS服务是否异常。",
      "注意事项": "保持并列结构的完整性，避免合并不同检查对象导致的歧义；删除冗余动词时需确保语法连贯性，优先保留\"是否异常\"等关键判断条件。"
    },
    {
      "defect_id": 508694,
      "sentence": "回调函数，组件加载完成时触发的回调。",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"\",\"98\":\"**参数：**\",\"99\":\"\",\"100\":\"| 参数名  | 类型                                                     | 必填 | 说明                                                     |\",\"101\":\"| ------- | ----------------------------------------------------------- | ---- | ------------------------------------------------------------ |\",\"102\":\"| callback | [VoidCallback](../../apis-basic-services-kit/js-apis-base.md#callback) | 是   | 回调函数，组件加载完成时触发的回调。 |\",\"103\":\"\",\"104\":\"### onError\",\"105\":\"\",\"106\":\"onError(callback:&nbsp;PluginErrorCallback)\",\"107\":\"\"}",
      "用户拒绝的修改": "回调函数。",
      "注意事项": "修复冗余表达时应优先保留技术参数的具体说明，避免删除具有明确触发条件的关键信息；需结合上下文判断重复内容是否为必要解释，表格参数说明中的\"回调函数\"作为术语定义，后续补充说明属于有效技术细节而非冗余。"
    },
    {
      "defect_id": 508583,
      "sentence": "为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。",
      "reference_sentence": "",
      "line_num": 201,
      "context": "{\"196\":\"\",\"197\":\"用于封装被拉起的Ability发送的数据。\",\"198\":\"\",\"199\":\"> **说明：**\",\"200\":\">\",\"201\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"202\":\"\",\"203\":\"**系统接口：** 此接口为系统接口。\",\"204\":\"\",\"205\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"206\":\"\"}",
      "用户拒绝的修改": "API 18版本修改了匿名对象的定义，保留了历史版本信息，不影响接口使用。",
      "注意事项": "修复冗余表达时应优先保留关键技术细节（如版本号差异说明），避免过度简化导致信息缺失；需结合上下文判断\"修饰成分\"是否承担重要说明功能，特别是涉及版本兼容性等开发者敏感信息时不应删除。"
    },
    {
      "defect_id": 511420,
      "sentence": "TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, ischecked?: boolean, checkAction?: (isChecked: boolean) => void, onCheckedChange?: Callback<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"不支持[通用属性](ts-component-general-attributes.md)。\",\"26\":\"\",\"27\":\"## TipsDialog\",\"28\":\"\",\"29\":\"\",\"30\":\"TipsDialog({controller: CustomDialogController, imageRes: ResourceStr | PixelMap, imageSize?: SizeOptions, title?: ResourceStr, content?: ResourceStr, checkTips?: ResourceStr, ischecked?: boolean, checkAction?: (isChecked: boolean) => void, onCheckedChange?: Callback\\\\<boolean>, primaryButton?: ButtonOptions, secondaryButton?: ButtonOptions, theme?: Theme | CustomTheme, themeColorMode?: ThemeColorMode})\",\"31\":\"\",\"32\":\"\",\"33\":\"提示弹出框，即为带图形确认框，必要时可通过图形化方式展现确认框。\",\"34\":\"\",\"35\":\"\"}",
      "用户拒绝的修改": "TipsDialog 接受多个参数，包括 controller、imageRes、imageSize、title、content、checkTips、ischecked、checkAction、onCheckedChange、primaryButton、secondaryButton、theme 和 themeColorMode。",
      "注意事项": "在技术文档中区分必要参数列表与冗余表达，保留函数签名的完整性；拆分长句时应优先采用结构化排版（如换行/分项列举）而非直接删除技术细节。"
    },
    {
      "defect_id": 508595,
      "sentence": "为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。",
      "reference_sentence": "",
      "line_num": 265,
      "context": "{\"260\":\"\",\"261\":\"用于在双方建立连接成功后，组件使用方向被拉起的Ability发送数据的场景，提供异步发送数据。\",\"262\":\"\",\"263\":\"> **说明：**\",\"264\":\">\",\"265\":\"> 为规范匿名对象的定义，API 18版本修改了此处的元素定义。其中，保留了历史匿名对象的起始版本信息，会出现外层元素@since版本号高于内层元素版本号的情况，但这不影响接口的使用。\",\"266\":\"\",\"267\":\"**系统接口：** 此接口为系统接口。\",\"268\":\"\",\"269\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"270\":\"\"}",
      "用户拒绝的修改": "API 18版本修改了匿名对象的定义，不影响接口使用。",
      "注意事项": "修复冗余表达时应优先保留关键技术细节（如版本兼容性说明），避免过度简化导致重要上下文丢失；需结合注释场景判断\"不影响使用\"等结论性表述是否需要保留支撑性论据。"
    },
    {
      "defect_id": 512866,
      "sentence": "必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLodaIntercpt中使用。需在webviewController与web组件绑定之后才能使用。",
      "reference_sentence": "",
      "line_num": 341,
      "context": "{\"336\":\"获取页面本次加载无白屏预测信息，并启用本次加载过渡帧生成，应用根据此信息确定是否需要启用无白屏加载，具体见返回值说明。\",\"337\":\"\",\"338\":\"\",\"339\":\"> **说明：**\",\"340\":\">\",\"341\":\"> - 必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLodaIntercpt中使用。需在webviewController与web组件绑定之后才能使用。\",\"342\":\"> - 如果发现相似度极低，请确认key值是否传递正确。\",\"343\":\"> - 本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。\",\"344\":\"> - 开销说明：配置开启无白屏加载的页面会有一定的资源开销，开销多少和web组件分辨率相关，假定分辨率宽高分别为：w,h。\",\"345\":\"> - 1. 页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。\",\"346\":\"> - 2. 增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\"}",
      "用户拒绝的修改": "必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用。需在触发加载页面的接口前或onLodaIntercpt中使用。需在webviewController与web组件绑定后使用。",
      "注意事项": "拆分长句时应优先保留技术文档中多条件间的逻辑关联词（如“且”），避免将必要复合结构误判为冗余；需结合上下文判断拆分是否影响技术要点的准确性或一致性。"
    },
    {
      "defect_id": 512875,
      "sentence": "页面的加载必须在调用本套接口的组件加载。",
      "reference_sentence": "",
      "line_num": 379,
      "context": "{\"374\":\"设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。\",\"375\":\"\",\"376\":\"> **说明：**\",\"377\":\">\",\"378\":\"> - 必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。\",\"379\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"380\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"381\":\"\",\"382\":\"**起始版本：** 20\",\"383\":\"\",\"384\":\"**参数：**\"}",
      "用户拒绝的修改": "页面加载必须在调用本接口的组件中进行。",
      "注意事项": "在技术文档中需优先保留专业术语和配套接口的准确指代（如\"本套接口\"），避免将必要的技术规范表述误判为冗余；修改前应结合上下文确认修饰成分是否影响核心语义表达。"
    },
    {
      "defect_id": 513237,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[通知错误码](./errorcode-notification.md)。",
      "reference_sentence": "",
      "line_num": 4820,
      "context": "{\"4815\":\"|-----------------|-------------------------|\",\"4816\":\"| Promise\\\\<void\\\\> | Promise对象，无返回结果。 | \",\"4817\":\"\",\"4818\":\"**错误码**：\",\"4819\":\"\",\"4820\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[通知错误码](./errorcode-notification.md)。\",\"4821\":\"\",\"4822\":\"| 错误码ID | 错误信息                                                     |\",\"4823\":\"| -------- | ------------------------------------------------------------ |\",\"4824\":\"| 201      | Permission denied.     |  \",\"4825\":\"| 202      | Not system application to call the interface.                                      |  \"}",
      "用户拒绝的修改": "错误码详情见[通用错误码](../errorcode-universal.md)和[通知错误码](./errorcode-notification.md)。",
      "注意事项": "简化时应保留必要指代关系（如\"以下\"）确保上下文衔接，避免过度删除关键限定词导致信息模糊。"
    },
    {
      "defect_id": 508553,
      "sentence": "将事件经过坐标转换后传递给对端Ability处理。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"## 事件\",\"48\":\"\",\"49\":\"不支持[点击](ts-universal-events-click.md)等通用事件。\",\"50\":\"\",\"51\":\"将事件经过坐标转换后传递给对端Ability处理。\",\"52\":\"\",\"53\":\"支持以下事件：\",\"54\":\"\",\"55\":\"### onRemoteReady\",\"56\":\"\"}",
      "用户拒绝的修改": "事件经过坐标转换后传递给对端Ability。",
      "注意事项": "修复冗余表达时需结合技术上下文判断术语必要性，避免误删关键动作（如\"处理\"在技术流程中可能隐含特定操作，不可省略）。"
    },
    {
      "defect_id": 508593,
      "sentence": "窗口Mode跟随策略，用于设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。",
      "reference_sentence": "",
      "line_num": 242,
      "context": "{\"237\":\"| FOLLOW_HOST_DPI                  | 0   | 表示DPI跟随宿主。 |\",\"238\":\"| FOLLOW_UI_EXTENSION_ABILITY_DPI  | 1   | 表示DPI跟随UIExtensionAbility。 |\",\"239\":\"\",\"240\":\"## WindowModeFollowStrategy<sup>18+</sup>\",\"241\":\"\",\"242\":\"窗口Mode跟随策略，用于设置窗口Mode，使其能够跟随宿主或UIExtensionAbility。\",\"243\":\"\",\"244\":\"**系统接口：** 此接口为系统接口。\",\"245\":\"\",\"246\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"247\":\"\"}",
      "用户拒绝的修改": "设置窗口Mode，使其跟随宿主或UIExtensionAbility。",
      "注意事项": "在技术文档中保留必要的术语定义和上下文关联，避免过度简化导致信息缺失；修复冗余表达时需结合上下文判断修饰成分是否属于规范术语或关键说明，优先保留技术概念完整性。"
    },
    {
      "defect_id": 512837,
      "sentence": "根据历史加载首屏的耗时估计本次加载的耗时，单位ms，范围>0。",
      "reference_sentence": "",
      "line_num": 173,
      "context": "{\"168\":\"\",\"169\":\"| 名称        | 类型   | 只读 | 可选 |说明                 |\",\"170\":\"| ----------- | ------ | -----|------|------------------- |\",\"171\":\"| errCode | WebBlanklessErrorCode | 否   | 否   | 见[WebBlanklessErrorCode](#webblanklesserrorcode20)定义。 |\",\"172\":\"| similarity | number | 否   | 否   | 无白屏加载的快照相似度，根据历史加载首屏快照计算相似度，范围0~1.0，1.0为完全一致，越接近1，越相似。该值会有滞后性，本地加载的相似性在下次加载时才能反映。建议当相似度为0时，应用不是能插帧功能。 |\",\"173\":\"| loadingTime | int | 否   | 否   | 根据历史加载首屏的耗时估计本次加载的耗时，单位ms，范围>0。 |\",\"174\":\"\",\"175\":\"## WebBlanklessErrorCode<sup>20+</sup>\",\"176\":\"\",\"177\":\"无白屏加载相关的异常错误码。\",\"178\":\"\"}",
      "用户拒绝的修改": "根据历史加载首屏的耗时估计本次加载的耗时，单位ms。",
      "注意事项": "在技术文档中保留数值范围等关键约束条件，避免将技术规范误判为冗余修饰；需严格区分\"修饰成分\"和\"技术参数\"，当数值限定条件（如>0）直接影响接口使用时不可删除。"
    },
    {
      "defect_id": 512539,
      "sentence": "设置无白屏加载是否启用，本接口必须与[getBlanklessInfoWithKey](#getblanklessinfowithkey20)接口成对使用。",
      "reference_sentence": "",
      "line_num": 9498,
      "context": "{\"9493\":\"\",\"9494\":\"## setBlanklessLoadingWithKey<sup>20+</sup>\",\"9495\":\"\",\"9496\":\"setBlanklessLoadingWithKey(key: string, isStart: bool): WebBlanklessErrorCode\",\"9497\":\"\",\"9498\":\"设置无白屏加载是否启用，本接口必须与[getBlanklessInfoWithKey](#getblanklessinfowithkey20)接口成对使用。\",\"9499\":\"\",\"9500\":\"> **说明：**\",\"9501\":\">\",\"9502\":\"> - 需在触发页面加载的接口之后调用，其他约束同[getBlanklessInfoWithKey](#getblanklessinfowithkey20)。\",\"9503\":\"> - 页面的加载必须在调用本套接口的组件加载。\"}",
      "用户拒绝的修改": "设置无白屏加载，必须与[getBlanklessInfoWithKey](#getblanklessinfowithkey20)接口成对使用。",
      "注意事项": "在技术文档中需优先保留明确参数说明和接口主体指向性词汇（如\"是否启用\"、\"本接口\"），避免将关键操作指示误判为冗余表达；应结合上下文判断术语是否承担技术含义，确保信息完整性和准确性。"
    },
    {
      "defect_id": 511622,
      "sentence": "if (this.textState && !this.isRunning && this.progressIndex < 100) {",
      "reference_sentence": "",
      "line_num": 132,
      "context": "{\"127\":\"            progress: this.progressIndex,\",\"128\":\"            progressButtonWidth: this.buttonWidth,\",\"129\":\"            content: this.textState,\",\"130\":\"            isEnabled: this.enableState,\",\"131\":\"            onClicked: () => {\",\"132\":\"              if (this.textState && !this.isRunning && this.progressIndex < 100) {\",\"133\":\"                this.textState = '继续';\",\"134\":\"              }\",\"135\":\"              this.isRunning = !this.isRunning;\",\"136\":\"              let timer = setInterval(() => {\",\"137\":\"                if (this.isRunning) {\"}",
      "用户拒绝的修改": "if (!this.isRunning && this.progressIndex < 100) {",
      "注意事项": "修复冗余条件时必须验证被删除变量是否影响后续逻辑（如this.textState在上下文被赋值或依赖），避免仅基于局部判断忽略全局状态依赖。"
    },
    {
      "defect_id": 508854,
      "sentence": "优化方式：改为如下的代码写法，跳过中间的依赖路径，直接依赖变量对应的模块。",
      "reference_sentence": "",
      "line_num": 403,
      "context": "{\"398\":\"1. 如果main.ets只需要依赖har中的NumberString模块，import xxx from \\\"har\\\"的写法会导致har整条链路上的模块被解析、执行，**导致模块解析及执行耗时增加**。上述例子中的har/Index、OtherModule1、OtherModule2、Utils、OtherModule3、OtherModule4、NumberString模块均会被解析、执行。\",\"399\":\"\",\"400\":\"2. 在模块解析阶段会通过深度优先遍历的方式建立变量的绑定关系，main.ets中使用的har.One变量是由har/src/main/ets/NumberString.ets导出的，而由于使用了export *的写法，建立变量的绑定关系时需要递归去进行变量名的匹配，**导致模块解析耗时增加**。\",\"401\":\"在上述例子中，会先查找 `har/Index.ets` 文件。该文件中有多个 `export *` 语句，因此会依次检查 `OtherModule1` 和 `OtherModule2` 是否导出 `One` 变量。接着，找到 `Utils` 模块，该模块也有 `export *` 语句，因此会继续检查 `OtherModule3` 和 `OtherModule4`，最终确定 `One` 变量是从 `NumberString` 模块导出的。\",\"402\":\"\",\"403\":\"优化方式：改为如下的代码写法，跳过中间的依赖路径，直接依赖变量对应的模块。\",\"404\":\"\",\"405\":\"```typescript\",\"406\":\"// main.ets\",\"407\":\"import { One } from \\\"har/src/main/ets/NumberString\\\"\",\"408\":\"console.info(One);\"}",
      "用户拒绝的修改": "优化方式：跳过中间的依赖路径，直接依赖变量对应的模块。",
      "注意事项": "修复时应保留必要的上下文衔接词（如\"改为如下的代码写法\"），避免过度删除导致技术指引与示例脱节；需区分\"冗余修饰\"与\"逻辑引导\"，优先保留影响技术理解的关键过渡语句。"
    },
    {
      "defect_id": 508550,
      "sentence": "通常用于有进程隔离诉求的模块化开发场景。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# UIExtensionComponent (系统接口)\",\"2\":\"\",\"3\":\"UIExtensionComponent用于支持在本页面内嵌入其他应用提供的UI。展示的内容在另外一个进程中运行，本应用并不参与其中的布局和渲染。\",\"4\":\"\",\"5\":\"通常用于有进程隔离诉求的模块化开发场景。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 该组件从API Version 10开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\",\"10\":\">\"}",
      "用户拒绝的修改": "用于有进程隔离诉求的模块化开发。",
      "注意事项": "需区分修饰词是否影响技术准确性，\"通常\"等限定词在技术文档中可能具有重要语义功能；保留领域专用术语完整性，避免过度删除技术场景描述中的必要限定词。"
    },
    {
      "defect_id": 512705,
      "sentence": "数组最大长度为256，超过256的部分不生效。数组中每个元素为应用的[appIdentifier](../quick-start/common_problem_of_application.md#什么是appidentifier)，单个appIdentifier为只包含数字的字符串，最大长度为128字节，超过128字节的appIdentifier不会生效。可使用[getBundleInfoForSelf](../reference/apis-ability-kit/js-apis-bundleManager.md#bundlemanagergetbundleinfoforself)接口来获取当前应用的appIdentifier。",
      "reference_sentence": "",
      "line_num": 66,
      "context": "{\"61\":\"\",\"62\":\"| 属性名称 | 含义 | 数据类型 | 必填 |\",\"63\":\"| ------- | ------- | ------- | ------- |\",\"64\":\"| uri | 共享配置项的全局唯一标识，同一应用内不允许重复。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写。uri最大长度为256个字节。 | 字符串 | 是 |\",\"65\":\"| value | 共享配置项的值，最大长度为4096字节。 | 字符串 | 是 |\",\"66\":\"| allowList | 允许访问该共享配置项的应用程序列表。数组最大长度为256，超过256的部分不生效。数组中每个元素为应用的[appIdentifier](../quick-start/common_problem_of_application.md#什么是appidentifier)，单个appIdentifier为只包含数字的字符串，最大长度为128字节，超过128字节的appIdentifier不会生效。可使用[getBundleInfoForSelf](../reference/apis-ability-kit/js-apis-bundleManager.md#bundlemanagergetbundleinfoforself)接口来获取当前应用的appIdentifier。 | 字符串数组 | 是 |\",\"67\":\"\",\"68\":\"```json\",\"69\":\"{\",\"70\":\"    \\\"crossAppSharedConfig\\\": [\",\"71\":\"        {\"}",
      "用户拒绝的修改": "数组最大长度为256，超过256的部分不生效。数组中每个元素为应用的appIdentifier。单个appIdentifier为只包含数字的字符串，最大长度为128字节。超过128字节的appIdentifier不会生效。可使用getBundleInfoForSelf接口来获取当前应用的appIdentifier。",
      "注意事项": "在拆分长句时需优先保持技术文档的上下文连贯性，避免过度分段导致信息碎片化，特别是在表格等结构化场景中应保留必要的信息密度；需结合相邻条目格式判断拆分必要性，确保修改后与文档整体风格统一。"
    },
    {
      "defect_id": 508549,
      "sentence": "UIExtensionComponent用于支持在本页面内嵌入其他应用提供的UI。展示的内容在另外一个进程中运行，本应用并不参与其中的布局和渲染。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# UIExtensionComponent (系统接口)\",\"2\":\"\",\"3\":\"UIExtensionComponent用于支持在本页面内嵌入其他应用提供的UI。展示的内容在另外一个进程中运行，本应用并不参与其中的布局和渲染。\",\"4\":\"\",\"5\":\"通常用于有进程隔离诉求的模块化开发场景。\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\"}",
      "用户拒绝的修改": "UIExtensionComponent支持在本页面内嵌入其他应用提供的UI。UI在另一个进程中运行，本应用不参与布局和渲染。",
      "注意事项": "在消除冗余表达时应优先保留技术文档特有的精准表述，避免将功能性描述误判为冗余（如\"展示的内容\"改为\"UI\"可能造成语义偏移），同时需结合上下文判断\"用于\"等介词是否承载重要语法功能。"
    },
    {
      "defect_id": 512704,
      "sentence": "uri最大长度为256个字节。",
      "reference_sentence": "",
      "line_num": 64,
      "context": "{\"59\":\"共享配置文件shared_config.json的文件名\\\"shared_config\\\"可自定义，根节点名称为crossAppSharedConfig，为对象数组，标识当前共享配置项的数量。（一个应用最多可以发布32个配置项，这个数量是静态配置与动态配置的总和，静态配置项数量超过上限时只解析前32个，其余的配置不生效）<br/>\",\"60\":\"crossAppSharedConfig字段配置说明：\",\"61\":\"\",\"62\":\"| 属性名称 | 含义 | 数据类型 | 必填 |\",\"63\":\"| ------- | ------- | ------- | ------- |\",\"64\":\"| uri | 共享配置项的全局唯一标识，同一应用内不允许重复。固定格式为`\\\"datashareproxy://{bundleName}/{path}\\\"`，其中bundleName为配置发布方应用的bundleName，path可随意填写。uri最大长度为256个字节。 | 字符串 | 是 |\",\"65\":\"| value | 共享配置项的值，最大长度为4096字节。 | 字符串 | 是 |\",\"66\":\"| allowList | 允许访问该共享配置项的应用程序列表。数组最大长度为256，超过256的部分不生效。数组中每个元素为应用的[appIdentifier](../quick-start/common_problem_of_application.md#什么是appidentifier)，单个appIdentifier为只包含数字的字符串，最大长度为128字节，超过128字节的appIdentifier不会生效。可使用[getBundleInfoForSelf](../reference/apis-ability-kit/js-apis-bundleManager.md#bundlemanagergetbundleinfoforself)接口来获取当前应用的appIdentifier。 | 字符串数组 | 是 |\",\"67\":\"\",\"68\":\"```json\",\"69\":\"{\"}",
      "用户拒绝的修改": "uri最大长度为256字节。",
      "注意事项": "在简化冗余表达时需优先保留技术文档的专业性和准确性，避免过度省略导致关键信息模糊（如单位前的量词“个”在部分场景中可省略，但需确认上下文是否影响理解）。"
    },
    {
      "defect_id": 512877,
      "sentence": "清除指定key值页面无白屏优化缓存，本接口只清除缓存。",
      "reference_sentence": "",
      "line_num": 406,
      "context": "{\"401\":\"void OH_NativeArkWeb_ClearBlanklessLoadingCache(const char* key[])\",\"402\":\"```\",\"403\":\"\",\"404\":\"**描述：**\",\"405\":\"\",\"406\":\"清除指定key值页面无白屏优化缓存，本接口只清除缓存。\",\"407\":\"\",\"408\":\"适用场景：主要针对小程序或者web应用场景下加载页面会出现变化较大的时候，会出现1次比较大的跳变，如果介意这次跳变可以使用该接口清除页面的缓存。\",\"409\":\"\",\"410\":\"> **说明：**\",\"411\":\">\"}",
      "用户拒绝的修改": "清除指定key值页面的无白屏优化缓存。",
      "注意事项": "在技术文档场景中需优先保留功能性限定词（如\"本接口只清除缓存\"），避免将关键操作范围说明误判为冗余表达；处理复合专业术语（如\"无白屏优化缓存\"）时应保持术语完整性，拆分前需确认是否存在实际语义重复。"
    },
    {
      "defect_id": 518979,
      "sentence": "Worker instance is not running.",
      "reference_sentence": "",
      "line_num": 1630,
      "context": "{\"1625\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\",\"1631\":\"| 10200005 | The invoked API is not supported in workers. |\",\"1632\":\"\",\"1633\":\"**示例：**\",\"1634\":\"\",\"1635\":\"```ts\"}",
      "用户拒绝的修改": "Worker 实例未运行。",
      "注意事项": "修复冗余表达前需优先检查术语一致性，确保技术文档中的错误码描述、API名称等专有名词与SDK/代码库保持严格统一，避免因过度优化可读性破坏上下文关联性。"
    },
    {
      "defect_id": 518977,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。",
      "reference_sentence": "",
      "line_num": 1625,
      "context": "{\"1620\":\"| ------------------------------------- | ------------------------------- |\",\"1621\":\"| void&nbsp;\\\\|&nbsp;Promise&lt;void&gt; | 无返回值或者以Promise形式返回。 |\",\"1622\":\"\",\"1623\":\"**错误码：**\",\"1624\":\"\",\"1625\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\"}",
      "用户拒绝的修改": "错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。",
      "注意事项": "修复冗余表达时需先确认上下文是否存在结构性呼应（如表格/列表后的\"以下\"指代），避免破坏文档统一性；优先保留与全文格式一致的指示性词汇。"
    },
    {
      "defect_id": 521135,
      "sentence": "// 两个message都为object类型，但其构造函数不同，属于不同类型",
      "reference_sentence": "",
      "line_num": 380,
      "context": "{\"375\":\"6. 从API version 20开始，支持跨BuilderNode配对\\\\@Provide/\\\\@Consume。在BuildNode上树时，\\\\@Consume通过key匹配找到最近的\\\\@Provide，两者类型需要一致，如果不一致，则会抛出运行时报错。\",\"376\":\"需要注意类型不相等判断包括类实例的判断，比如：\",\"377\":\"```ts\",\"378\":\"class A {}\",\"379\":\"class B {}\",\"380\":\"// 两个message都为object类型，但其构造函数不同，属于不同类型\",\"381\":\"@Provide message: A = new A();\",\"382\":\"@Consume message: B = new B();\",\"383\":\"```\",\"384\":\"在非BuilderNode上树场景，配对的\\\\@Provide/\\\\@Consume类型仍建议相同，虽不会有运行时的强校验，但会在\\\\@Consume装饰的变量初始化的时候被隐式转换成\\\\@Provide装饰变量的类型。\",\"385\":\"```ts\"}",
      "用户拒绝的修改": "// 两个message构造函数不同，类型不同",
      "注意事项": "修复冗余表达时必须优先保留关键类型信息，确保技术准确性不被破坏；需区分冗余修饰语与必要技术限定条件，避免因过度简化导致语义缺失。"
    },
    {
      "defect_id": 518978,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "reference_sentence": "",
      "line_num": 1629,
      "context": "{\"1624\":\"\",\"1625\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\",\"1631\":\"| 10200005 | The invoked API is not supported in workers. |\",\"1632\":\"\",\"1633\":\"**示例：**\",\"1634\":\"\"}",
      "用户拒绝的修改": "参数错误。可能原因：1. 必填参数未指定；2. 参数类型错误；3. 参数验证失败。",
      "注意事项": "修复冗余表达时需优先核对SDK/代码库中已定义的术语规范，保留与系统内错误码描述完全一致的固定表述（如\"Mandatory parameters\"对应\"必选参数\"而非\"必填参数\"），不可仅根据语法规则简化已有技术术语。"
    },
    {
      "defect_id": 518980,
      "sentence": "The invoked API is not supported in workers.",
      "reference_sentence": "",
      "line_num": 1631,
      "context": "{\"1626\":\"\",\"1627\":\"| 错误码ID | 错误信息                                   |\",\"1628\":\"| -------- | -------------------------------------------- |\",\"1629\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"1630\":\"| 10200004 | Worker instance is not running.          |\",\"1631\":\"| 10200005 | The invoked API is not supported in workers. |\",\"1632\":\"\",\"1633\":\"**示例：**\",\"1634\":\"\",\"1635\":\"```ts\",\"1636\":\"import { worker, Event } from \\\"@kit.ArkTS\\\"\"}",
      "用户拒绝的修改": "调用的 API 在 Worker 中不支持。",
      "注意事项": "修复冗余表达前必须优先核对上下文术语一致性（如SDK错误码原文），避免因过度简化破坏与官方文档的术语对齐；技术翻译需保留固定表述，禁止擅自调整API名称、错误信息等核心短语结构。"
    },
    {
      "defect_id": 521618,
      "sentence": "将typedArray[index]赋值为value，并返回该值。",
      "reference_sentence": "",
      "line_num": 575,
      "context": "{\"570\":\"\",\"571\":\"## store\",\"572\":\"\",\"573\":\"static store(typedArray: smalltypeArray, index: number, value: number): number  \",\"574\":\"\",\"575\":\"将typedArray[index]赋值为value，并返回该值。\",\"576\":\"\",\"577\":\"**参数：**\",\"578\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"579\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\",\"580\":\"| typedArray | smalltypeArray                         | 是   | 要操作的数组。     |\"}",
      "用户拒绝的修改": "将typedArray[index]赋值为value并返回。",
      "注意事项": "修复冗余表达时需优先保留技术文档中返回值指向的关键信息（如“该值”），避免因过度简化导致语义模糊；在API描述等严谨场景中，应确保动作主体与返回对象的对应关系始终明确。"
    },
    {
      "defect_id": 520940,
      "sentence": "表示时间戳，默认值为-1。参数应为非负整数，否则返回错误码1300003。",
      "reference_sentence": "",
      "line_num": 153,
      "context": "{\"148\":\"  | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"149\":\"  | action     | [OH_Input_SetTouchEventAction](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventaction) | 表示事件行为，默认值为0。<br>当前只支持0-3的行为，分别表示为：<br>- 0：cancel，表示取消事件。<br>- 1：down，表示按下事件。<br/>- 2：move，表示移动事件。<br/>- 3：up，表示抬起事件。<br/>- 其他行为会返回错误码1300003。 |\",\"150\":\"  | id         | [OH_Input_SetTouchEventFingerId](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventfingerid) | 表示手指ID，默认值为0。<br>应为大于等于0的整数，否则返回错误码1300003。 |\",\"151\":\"  | displayX   | [OH_Input_SetTouchEventDisplayX](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventdisplayx) | 表示事件落点相对于屏幕的横坐标，默认值为0。<br>参数应为非负整数，否则返回错误码1300003。建议与windowX保持对应关系，即使不一致也不会返回错误码，仅校验入参合法范围。转换方法推荐使用[getWindowProperties()](../reference/apis-arkui/arkts-apis-window-Window.md#getwindowproperties9)方法获取windowRect属性，通过displayX减去windowRect中窗口左上角横坐标计算对应的windowX。 |\",\"152\":\"  | displayY   | [OH_Input_SetTouchEventDisplayY](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventdisplayy) | 表示事件落点相对于屏幕的纵坐标，默认值为0。<br/>参数应为非负整数，否则返回错误码1300003。建议与windowY保持对应关系，即使不一致也不会返回错误码，仅校验入参合法范围。转换方法推荐使用[getWindowProperties()](../reference/apis-arkui/arkts-apis-window-Window.md#getwindowproperties9)方法获取windowRect属性，通过displayY减去windowRect中窗口左上角横坐标计算对应的windowY。 |\",\"153\":\"  | actionTime | [OH_Input_SetTouchEventActionTime](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventactiontime) | 表示时间戳，默认值为-1。参数应为非负整数，否则返回错误码1300003。 |\",\"154\":\"  | windowId   | [OH_Input_SetTouchEventWindowId](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventwindowid) | 表示事件注入窗口ID，默认值为-1。若参数不为默认值且不等于[OH_WindowManager_InjectTouchEvent](../reference/apis-arkui/capi-oh-window-h.md#oh_windowmanager_injecttouchevent)接口参数windowId，将校验传入参数错误。 |\",\"155\":\"  | displayId  | [OH_Input_SetTouchEventDisplayId](../reference/apis-input-kit/capi-oh-input-manager-h.md#oh_input_settoucheventdisplayid) | 表示事件注入屏幕ID，默认值为-1。无限制，但是应该尽量保证与[OH_WindowManager_InjectTouchEvent](../reference/apis-arkui/capi-oh-window-h.md#oh_windowmanager_injecttouchevent)接口参数windowId有相互对应关系，推荐使用[getWindowProperties()](../reference/apis-arkui/arkts-apis-window-Window.md#getwindowproperties9)方法获取displayId属性。 |\",\"156\":\"\",\"157\":\"### 示例代码\",\"158\":\"\"}",
      "用户拒绝的修改": "表示时间戳。默认值为-1。参数应为非负整数，否则返回错误码1300003。",
      "注意事项": "修复冗余表达时需优先保持上下文标点规范一致性，若相邻条目采用逗号分隔说明内容，应避免强行拆分句子破坏格式统一；同时需结合参数类型特点判断\"参数应为\"等补充说明是否属于必要技术约束，而非冗余信息。"
    },
    {
      "defect_id": 521578,
      "sentence": "返回typedArray[index]的值。",
      "reference_sentence": "",
      "line_num": 353,
      "context": "{\"348\":\"\",\"349\":\"## load\",\"350\":\"\",\"351\":\"static load(typedArray: smalltypeArray, index: number): number  \",\"352\":\"\",\"353\":\"返回typedArray[index]的值。  \",\"354\":\"此方法确保在typedArray[index]被加载之前，typedArray[index]不会发生其他线程的读写操作。  \",\"355\":\"\",\"356\":\"**参数：**\",\"357\":\"| 名称     | 类型                                    | 必填 | 说明                   |\",\"358\":\"| -------- | --------------------------------------- | ---- | ---------------------- |\"}",
      "用户拒绝的修改": "此方法返回typedArray[index]的值。",
      "注意事项": "在添加主语时需结合上下文确认是否已有隐含主语（如方法描述中\"此方法\"可能冗余），优先遵循文档惯例保持简洁性，避免过度补充已知信息。"
    },
    {
      "defect_id": 523048,
      "sentence": "参数说明：",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"```\",\"14\":\"ark_disasm.exe [options] input_file output_file\",\"15\":\"```\",\"16\":\"\",\"17\":\"参数说明：\",\"18\":\"\",\"19\":\"| 参数 | 是否可缺省 | 描述 |\",\"20\":\"| -------- | -------- | -------- |\",\"21\":\"| [options] | 可缺省 | 命令选项，详见下文options选项说明。 |\",\"22\":\"| input_file | 不可缺省 | 待反汇编的方舟字节码文件路径。 |\"}",
      "用户拒绝的修改": "说明参数：",
      "注意事项": "修复时应优先识别文档结构特性（如标题/表格语境允许省略主谓），避免机械套用语法规则破坏行业惯用表述格式。"
    },
    {
      "defect_id": 523049,
      "sentence": "options选项说明：",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"| -------- | -------- | -------- |\",\"21\":\"| [options] | 可缺省 | 命令选项，详见下文options选项说明。 |\",\"22\":\"| input_file | 不可缺省 | 待反汇编的方舟字节码文件路径。 |\",\"23\":\"| output_file | 不可缺省 | 反汇编内容的输出文件路径。 |\",\"24\":\"\",\"25\":\"options选项说明：\",\"26\":\"\",\"27\":\"| 选项 | 必填 | 存在入参 | 描述 |\",\"28\":\"| -------- | -------- | -------- | -------- |\",\"29\":\"| --debug | 否  | 否  | 使能输出调试信息，默认输出到屏幕。 |\",\"30\":\"| --debug-file | 否 | 是 | 如果使能了--debug，指定调试信息的输出文件。 |\"}",
      "用户拒绝的修改": "说明options选项：",
      "注意事项": "修复时应优先保留符合技术文档惯例的术语结构（如\"选项说明\"作为固定标题），避免过度追求语法完整而破坏上下文一致性；需结合表格标题的简洁性要求，允许在特定语境下省略主谓结构。"
    },
    {
      "defect_id": 522811,
      "sentence": "以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 191,
      "context": "{\"186\":\"|-------|--------|----|------------------------------------------------------------|\",\"187\":\"| bytes | number | 是  | 设置的缓存上限。默认值为104857600B（即100MB），最大值不超过4294967296B（即4GB）。 |\",\"188\":\"\",\"189\":\"**错误码：**\",\"190\":\"\",\"191\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。\",\"192\":\"\",\"193\":\"| 错误码ID    | 错误信息                                                                                                                                      |\",\"194\":\"|----------|-------------------------------------------------------------------------------------------------------------------------------------------|\",\"195\":\"| 401      | parameter error. Possible causes: 1. Missing mandatory parameters. 2. Incorrect parameter type. 3. Parameter verification failed. |\",\"196\":\"\"}",
      "用户拒绝的修改": "请参见[通用错误码说明文档](../errorcode-universal.md)以获取错误码的详细信息。",
      "注意事项": "在修复冗余表达前必须检查上下文一致性，若原文存在重复的固定表达格式，应优先保持文档整体风格统一而非单纯追求句式优化。"
    },
    {
      "defect_id": 522284,
      "sentence": "通过ForeignMethod的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。",
      "reference_sentence": "",
      "line_num": 115,
      "context": "{\"110\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。 |\",\"111\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"112\":\"\",\"113\":\"> **注意：**\",\"114\":\"> \",\"115\":\"> 通过ForeignMethod的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"116\":\"\",\"117\":\"\",\"118\":\"### ClassIndex\",\"119\":\"ClassIndex结构的作用是通过名称快速地定位到Class的定义。\",\"120\":\"\"}",
      "用户拒绝的修改": "通过ForeignMethod的偏移量可以找到IndexHeader以解析`class_idx`。",
      "注意事项": "在简化冗余表达时，需优先保留关键限定条件（如“偏移量所在的”），避免因过度删除导致技术逻辑缺失；区分重复数据和必要修饰，确保简化后的句子仍能准确指向上下文中的特定对象。"
    },
    {
      "defect_id": 522281,
      "sentence": "字节码版本号由4个部分组成，格式为：`主版本号.次版本号.特性版本号.编译版本号`。",
      "reference_sentence": "",
      "line_num": 79,
      "context": "{\"74\":\"| `num_index_regions` | `uint32_t`       | [IndexSection](#indexsection)结构中元素的数量，即文件中[IndexHeader](#indexheader)的数量。 |\",\"75\":\"| `index_section_off` | `uint32_t`       | 偏移量，指向[IndexSection](#indexsection)。 |\",\"76\":\"\",\"77\":\"\",\"78\":\"### Version\",\"79\":\"字节码版本号由4个部分组成，格式为：`主版本号.次版本号.特性版本号.编译版本号`。\",\"80\":\"\",\"81\":\"| **名称** | **格式** | **说明**                                             |\",\"82\":\"| -------------- | -------------- | ---------------------------------------------------------- |\",\"83\":\"| 主版本号       | `uint8_t`        | 标识整体架构调整引入的字节码文件格式变更。                 |\",\"84\":\"| 次版本号       | `uint8_t`        | 标识局部架构调整或者重大特性调整引入的字节码文件格式变更。 |\"}",
      "用户拒绝的修改": "字节码版本号格式为：`主版本号.次版本号.特性版本号.编译版本号`。",
      "注意事项": "在简化冗余表达时需优先保留关键数量信息（如\"4个部分\"），确保技术文档的精确性和上下文对应关系，避免因过度简化导致核心说明要素缺失。"
    },
    {
      "defect_id": 522997,
      "sentence": "2. 使用c语言编译工具（这里使用g++）编译动态库。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"       // 开发者可以在这里读取abc_path对应的方舟字节码文件，然后根据方舟字节码的格式去修改相关数据，然后再重新生成方舟字节码文件\",\"29\":\"       return 0;\",\"30\":\"   }\",\"31\":\"   ```\",\"32\":\"\",\"33\":\"2. 使用c语言编译工具（这里使用g++）编译动态库。\",\"34\":\"\",\"35\":\"   Windows平台：\",\"36\":\"\",\"37\":\"   ```\",\"38\":\"   g++ --shared -o example.dll example.cpp\"}",
      "用户拒绝的修改": "2. 使用g++编译动态库。",
      "注意事项": "保留括号内具有解释说明功能的补充信息，特别是当括号内容用于澄清术语或提供具体示例时，需优先保障技术文档的明确性而非绝对简洁。"
    },
    {
      "defect_id": 522261,
      "sentence": "本文内容基于方舟字节码版本号12.0.6.0（版本号为方舟编译器内部保留字段，开发者无需关注，仅供准确对照之用）。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# 方舟字节码文件格式\",\"2\":\"本文详细介绍了方舟字节码文件的格式，旨在帮助开发者深入了解构成字节码文件的各个部分，从而指导开发者进行字节码的分析和修改工作。\",\"3\":\"\",\"4\":\"\",\"5\":\"## 约束\",\"6\":\"本文内容基于方舟字节码版本号12.0.6.0（版本号为方舟编译器内部保留字段，开发者无需关注，仅供准确对照之用）。\",\"7\":\"\",\"8\":\"\",\"9\":\"## 字节码文件数据类型\",\"10\":\"方舟字节码使用了多种基础和复合数据类型，以下为常见类型的定义和说明。\",\"11\":\"\"}",
      "用户拒绝的修改": "本文内容基于方舟字节码版本号12.0.6.0，仅供准确对照之用。",
      "注意事项": "修复技术文档时应优先保留括号内的补充说明（特别是涉及版本限制或免责声明的内容），严格区分冗余修饰与必要技术说明，确保关键限制性信息不丢失。"
    },
    {
      "defect_id": 522927,
      "sentence": "原函数名代表函数在源代码中的名字，匿名函数则为空字符串。同样的，如果源码中相同作用域下出现了同名的函数，重名的名称后面会加上重名序号（包括匿名函数）。",
      "reference_sentence": "",
      "line_num": 58,
      "context": "{\"53\":\"namespace A {\",\"54\":\"    function foo() { }                      // foo的函数名为\\\"#&A^1*#foo\\\"，其中\\\"^1\\\" 为重名序号\",\"55\":\"}\",\"56\":\"```\",\"57\":\"### 原函数名\",\"58\":\"原函数名代表函数在源代码中的名字，匿名函数则为空字符串。同样的，如果源码中相同作用域下出现了同名的函数，重名的名称后面会加上重名序号（包括匿名函数）。\",\"59\":\"\",\"60\":\"```ts\",\"61\":\"function foo() {}                           // 原函数名为\\\"foo\\\"\",\"62\":\"() => { }                                   // 原函数名为\\\"\\\"\",\"63\":\"() => { }                                   // 原函数名为\\\"^1\\\"\"}",
      "用户拒绝的修改": "原函数名代表函数在源代码中的名字，匿名函数则为空字符串。如果源码中相同作用域下出现了同名的函数，重名的名称后面会加上重名序号，包括匿名函数。",
      "注意事项": "保留必要技术细节时优先维持括号补充说明的准确性，避免机械删除限定条件；严格区分冗余重复和关键限定信息，技术文档中括号内的\"包括...\"结构具有强调特殊情况的语义功能。"
    },
    {
      "defect_id": 522929,
      "sentence": "如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"#### 特殊情况\",\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。比如下面的例子：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么它的原函数名则是这个属性名。\",\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\"}",
      "用户拒绝的修改": "如果匿名函数在对象字面量中被赋值给一个字面量属性：",
      "注意事项": "确保删除的冗余成分不影响原句技术条件的完整性，避免过度简化导致关键信息丢失（例如保留“对象字面量中”的上下文限定）；优先删除纯修饰性重复（如“定义并且被赋值”可合并为“被赋值”），但需保留必要动作描述。"
    },
    {
      "defect_id": 522998,
      "sentence": "3. 在DevEco Studio中配置build-profile.json5的transformLib选项（以windows环境为例）。",
      "reference_sentence": "",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"   ```\",\"50\":\"   g++ --shared -o example.so example.cpp\",\"51\":\"   ```\",\"52\":\"\",\"53\":\"3. 在DevEco Studio中配置build-profile.json5的transformLib选项（以windows环境为例）。\",\"54\":\"\",\"55\":\"   选项中配置的路径为步骤2生成的链接库文件在项目中的路径（这里是dll目录下）。\",\"56\":\"\",\"57\":\"   ![zh-cn_image_0000002079773605](figures/zh-cn_image_0000002079773605.png)\",\"58\":\"\"}",
      "用户拒绝的修改": "3. 在DevEco Studio中配置build-profile.json5的transformLib选项（适用于Windows环境）。",
      "注意事项": "保留技术文档中具有明确示例说明功能的固定表达结构（如\"以...为例\"），避免将技术性举例表述误判为冗余修饰，修改时应优先确保专业术语和惯用表达的准确性。"
    },
    {
      "defect_id": 522926,
      "sentence": "模块加载时被执行的函数，名称固定为`func_main_0`。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中[Method](arkts-bytecode-file-format.md#method)的`name_off`字段指向的字符串的命名规则，该规则从方舟字节码文件版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时被执行的函数，名称固定为`func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构如下：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\"}",
      "用户拒绝的修改": "模块加载时执行的函数名称固定为`func_main_0`。",
      "注意事项": "在技术文档中优先保留被动语态和必要修饰词，避免因过度简化破坏原句强调的被动执行关系；需结合上下文判断\"冗余\"成分是否承载技术含义（如\"被执行\"特指系统触发行为），而非单纯语法冗余。"
    },
    {
      "defect_id": 522505,
      "sentence": "无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。",
      "reference_sentence": "",
      "line_num": 403,
      "context": "{\"398\":\"状态机（State machine）的作用是产生[DebugInfo](#debuginfo)信息。状态机中有以下的寄存器：\",\"399\":\"\",\"400\":\"| **名称**    | **初始值**                                             | **说明**                                               |\",\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\"}",
      "用户拒绝的修改": "无符号整数，对应源码中的行号，从1开始编号。",
      "注意事项": "修复冗余表达时需优先保留关键约束条件（如\"寄存器的值不能小于1\"），确保技术准确性；注意因果关系连词（如\"因此\"）承载的逻辑关系，避免破坏原句的严谨性。"
    },
    {
      "defect_id": 522431,
      "sentence": "TryBlock的大小，以字节为单位。",
      "reference_sentence": "",
      "line_num": 286,
      "context": "{\"281\":\"- 格式：\",\"282\":\"\",\"283\":\"| **名称** | **格式** | **说明**                                               |\",\"284\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"285\":\"| `start_pc`       | `uleb128`        | TryBlock的第一条指令距离其所在[Code](#code)的`instructions`的起始位置的偏移量。 |\",\"286\":\"| `length`         | `uleb128`        | TryBlock的大小，以字节为单位。                               |\",\"287\":\"| `num_catches`    | `uleb128`        | 与TryBlock关联的[CatchBlock](#catchblock)的数量，值为1。 |\",\"288\":\"| `catch_blocks`   | `CatchBlock[]`   | 与TryBlock关联的CatchBlock的数组，数组中有且仅有一个可以捕获所有类型的异常的CatchBlock。 |\",\"289\":\"\",\"290\":\"\",\"291\":\"### CatchBlock\"}",
      "用户拒绝的修改": "TryBlock的大小，以字节计。",
      "注意事项": "在技术文档中优先保留\"以...为单位\"等规范计量表述，避免过度简化导致专业术语缺失；修改前需确认原句是否为领域标准表达，确保准确性优先于简洁性。"
    },
    {
      "defect_id": 523500,
      "sentence": "If the input parameter invalid. Possible causes: 1.Incorrect parameter types; 2.Parameter verification failed.",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"40\":\"\",\"41\":\"| 错误码ID | 错误信息 |\",\"42\":\"| -------- | ---------------------------------------- |\",\"43\":\"| 401 | If the input parameter invalid. Possible causes: 1.Incorrect parameter types; 2.Parameter verification failed.                 |\",\"44\":\"\",\"45\":\"**示例：**\",\"46\":\"  ```json\",\"47\":\"  // 资源文件路径: src/main/resources/base/element/string.json\",\"48\":\"  {\"}",
      "用户拒绝的修改": "Invalid input parameter. Possible causes: 1. Incorrect parameter types; 2. Parameter verification failed.",
      "注意事项": "在修正冗余表达前必须核对技术文档的规范格式要求，优先保持错误码描述的标准化结构，避免因过度简化破坏技术信息的完整性和行业通用性。"
    },
    {
      "defect_id": 522506,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。",
      "reference_sentence": "",
      "line_num": 405,
      "context": "{\"400\":\"| **名称**    | **初始值**                                             | **说明**                                               |\",\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\"}",
      "用户拒绝的修改": "一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息，寄存器的值是0。",
      "注意事项": "修复冗余表达时需优先检查上下文是否存在重复定义，保留必要超链接但避免重复解释已明确定义的术语（如\"[Class](#class)\"在表格前文已说明）。"
    },
    {
      "defect_id": 522445,
      "sentence": "不同的值类型，有不同的值编码格式，包括INTEGER, LONG, FLOAT, DOUBLE, ID。",
      "reference_sentence": "",
      "line_num": 355,
      "context": "{\"350\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示注解元素的名称。 |\",\"351\":\"| `value`          | `uint32_t`       | 注解元素的值，若值的宽度不超过32位，则此处存储值本身。否则，此处存储的值为指向[Value formats](#value-formats)格式的偏移量。 |\",\"352\":\"\",\"353\":\"\",\"354\":\"### Value formats\",\"355\":\"不同的值类型，有不同的值编码格式，包括INTEGER, LONG, FLOAT, DOUBLE, ID。\",\"356\":\"\",\"357\":\"| **名称** | **格式** | **说明**                                               |\",\"358\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"359\":\"| `INTEGER`        | `uint32_t`       | 有符号的四字节整数值。                                       |\",\"360\":\"| `LONG`           | `uint64_t`       | 有符号的八字节整数值。                                       |\"}",
      "用户拒绝的修改": "不同的值类型有各自的编码格式，包括 INTEGER, LONG, FLOAT, DOUBLE, ID。",
      "注意事项": "修复冗余表达时需优先保留技术文档中强调\"一一对应\"关系的必要重复，确保关键术语的明确性不被削弱；在涉及规范定义时，应谨慎处理修饰成分的删减，避免破坏专业表述的完整性。"
    },
    {
      "defect_id": 522507,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。",
      "reference_sentence": "",
      "line_num": 406,
      "context": "{\"401\":\"| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\",\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\"}",
      "用户拒绝的修改": "一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，值为0。",
      "注意事项": "修复时应优先保持上下文术语一致性，检查相邻条目中相同语义的表述方式（例如\"寄存器的值\"在前文多次出现），避免因局部简化破坏文档整体统一性。"
    },
    {
      "defect_id": 522322,
      "sentence": "一个偏移量，指向[字符串](#字符串)，表示方法名称。",
      "reference_sentence": "",
      "line_num": 216,
      "context": "{\"211\":\"\",\"212\":\"| **名称** | **格式** | **说明**                                               |\",\"213\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"214\":\"| `class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。 |\",\"215\":\"| `reserved`       | `uint16_t`       | 方舟字节码文件内部使用的保留字段。                           |\",\"216\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。 |\",\"217\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"218\":\"| `method_data`    | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[MethodTag](#methodtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"219\":\"\",\"220\":\"> **注意：**\",\"221\":\"> \"}",
      "用户拒绝的修改": "一个指向方法名称的偏移量。",
      "注意事项": "在消除冗余表达时需确保保留所有必要的技术细节（如数据结构指向），避免因过度简化导致关键信息丢失；应明确区分数据类型说明和语义描述，优先保持技术文档的精确性。"
    },
    {
      "defect_id": 522778,
      "sentence": "一个数组，数组中每个元素的值是一个偏移量，指向方法、字符串或者字面量数组。数组长度由[IndexHeader](#indexheader)中的`method_string_literal_idx_size`指定。",
      "reference_sentence": "",
      "line_num": 512,
      "context": "{\"507\":\"- 对齐方式：4个字节。\",\"508\":\"- 格式：\",\"509\":\"\",\"510\":\"| **名称** | **格式** | **说明**                                               |\",\"511\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"512\":\"| `offsets`      | `uint32_t[]`   | 一个数组，数组中每个元素的值是一个偏移量，指向方法、字符串或者字面量数组。数组长度由[IndexHeader](#indexheader)中的`method_string_literal_region_idx_size`指定。 |\",\"513\":\"\",\"514\":\"\",\"515\":\"### LiteralArray\",\"516\":\"描述字节码文件中的字面量数组。\",\"517\":\"\"}",
      "用户拒绝的修改": "一个数组，每个元素是一个偏移量，指向方法、字符串或字面量数组。数组长度由[IndexHeader](#indexheader)中的`method_string_literal_idx_size`指定。",
      "注意事项": "修复冗余表达时必须严格保留关键术语的完整拼写（如`method_string_literal_region_idx_size`），避免因过度简化而误删技术参数名称中的特定字段（例如\"region\"）；修改后需逐字核对原文技术细节，确保参数名、引用标签与上下文完全一致。"
    },
    {
      "defect_id": 522323,
      "sentence": "不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[MethodTag](#methodtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。",
      "reference_sentence": "",
      "line_num": 218,
      "context": "{\"213\":\"| -------------- | -------------- | ------------------------------------------------------------ |\",\"214\":\"| `class_idx`      | `uint16_t`       | 一个指向该方法所从属的类的索引，指向一个在[ClassRegionIndex](#classregionindex)中的位置，该位置的值是[Type](#type)类型，是一个指向[Class](#class)的偏移量。 |\",\"215\":\"| `reserved`       | `uint16_t`       | 方舟字节码文件内部使用的保留字段。                           |\",\"216\":\"| `name_off`       | `uint32_t`       | 一个偏移量，指向[字符串](#字符串)，表示方法名称。 |\",\"217\":\"| `index_data`     | `uleb128`        | 方法的[MethodIndexData](#methodindexdata)数据。 |\",\"218\":\"| `method_data`    | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[MethodTag](#methodtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"219\":\"\",\"220\":\"> **注意：**\",\"221\":\"> \",\"222\":\"> 通过Method的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"223\":\"\"}",
      "用户拒绝的修改": "不定长度的数组，每个元素都是[TaggedValue](#taggedvalue)类型，标记为[MethodTag](#methodtag)，按标记递增排序（`0x00`标记除外）。",
      "注意事项": "修复时应确保上下文指代连贯性，避免因过度简化导致\"数组中的元素\"等关键信息缺失；需保持技术文档的精确性，不能因消除重复而省略必要的限定条件（如排序规则中的`0x00`例外说明）。"
    },
    {
      "defect_id": 524049,
      "sentence": "设置缓存上限。默认值为104857600字节（100MB），最大值为4294967296字节（4GB）。",
      "reference_sentence": "",
      "line_num": 187,
      "context": "{\"182\":\"\",\"183\":\"**参数：**\",\"184\":\"\",\"185\":\"| 参数名   | 类型     | 必填 | 说明                                                         |\",\"186\":\"|-------|--------|----|------------------------------------------------------------|\",\"187\":\"| bytes | number | 是 | 设置缓存上限。默认值为104857600字节（100MB），最大值为4294967296字节（4GB）。 |\",\"188\":\"\",\"189\":\"**错误码：**\",\"190\":\"\",\"191\":\"请参见[通用错误码说明文档](../errorcode-universal.md)以获取错误码的详细信息。\",\"192\":\"\"}",
      "用户拒绝的修改": "设置缓存上限，默认100MB，最大4GB。",
      "注意事项": "在技术参数说明中保留原始数值和常用单位换算（如104857600字节/100MB），避免因过度简化导致关键信息丢失；优先考虑技术文档的精确性需求而非单纯追求语言简洁。"
    },
    {
      "defect_id": 526221,
      "sentence": "Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "reference_sentence": "",
      "line_num": 98,
      "context": "{\"93\":\"\",\"94\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"95\":\"\",\"96\":\"| 错误码ID | 错误信息 |\",\"97\":\"| -------- | -------- |\",\"98\":\"| 401 | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"99\":\"\",\"100\":\"**示例：**\",\"101\":\"\",\"102\":\"```ts\",\"103\":\"import { JSON } from '@kit.ArkTS';\"}",
      "用户拒绝的修改": "Parameter error: 1. Mandatory parameters missing; 2. Incorrect parameter types; 3. Parameter verification failed.",
      "注意事项": "修复冗余表达时应优先保留技术文档中的关键术语和结构引导词（如\"Possible causes:\"），避免过度简化导致信息缺失或上下文连贯性破坏；在缩短长句时需确保分项列举的格式一致性，使用统一分隔符（如分号）并维持平行结构。"
    },
    {
      "defect_id": 523594,
      "sentence": "共享词法环境是一类特殊的词法环境。与一般词法环境的区别在于，共享词法环境中的每个词法变量都是[sendable对象](arkts-sendable.md)。方舟编译器通过共享词法环境实现词法变量在多线程的共享。",
      "reference_sentence": "",
      "line_num": 195,
      "context": "{\"190\":\"指令*newlexenv 0x1*：创建一个槽位数为1的词法环境，将其存放到acc中，并进入该词法环境；<br>\",\"191\":\"指令*stlexvar 0x0, 0x0*：将acc中的值存放到0个层次外的词法环境的0号槽位上；<br>\",\"192\":\"指令*ldlexvar 0x0, 0x0*：将0个层次外的词法环境的0号槽位上的值存放到acc中。\",\"193\":\"\",\"194\":\"#### 共享词法环境\",\"195\":\"共享词法环境是一类特殊的词法环境。与一般词法环境的区别在于，共享词法环境中的每个词法变量都是[sendable对象](arkts-sendable.md)。方舟编译器通过共享词法环境实现词法变量在多线程的共享。\",\"196\":\"\",\"197\":\"示例代码：\",\"198\":\"```ets\",\"199\":\"@Sendable\",\"200\":\"class A { }\"}",
      "用户拒绝的修改": "共享词法环境是一类特殊的词法环境，其中每个词法变量都是[sendable对象](arkts-sendable.md)。方舟编译器通过共享词法环境实现词法变量在多线程中的共享。",
      "注意事项": "修复冗余表达时需同时检查介词结构冗余（如\"多线程中的共享\"应简化为\"多线程中共享\"），并保持单句信息密度适中，避免合并分句后产生新的复杂短语结构。"
    },
    {
      "defect_id": 526227,
      "sentence": "指定缩进用的空格或字符串或空字符串，用于美化输出。当参数是数字时表示有多少个空格；当参数是字符串时，该字符串被当作空格；当参数没有提供时，将没有空格。默认值是空字符串。",
      "reference_sentence": "",
      "line_num": 227,
      "context": "{\"222\":\"\",\"223\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"224\":\"| -------- | -------- | -------- | -------- |\",\"225\":\"| value | Object | 是 | ArkTS对象或数组，支持线性容器的转换，不支持非线性容器。|\",\"226\":\"| replacer | [Transformer](#transformer) | 否 | 在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理。默认值是undefined。|\",\"227\":\"| space | string \\\\| number | 否 | 指定缩进用的空格或字符串或空字符串，用于美化输出。当参数是数字时表示有多少个空格；当参数是字符串时，该字符串被当作空格；当参数没有提供时，将没有空格。默认值是空字符串。|\",\"228\":\"\",\"229\":\"**返回值：**\",\"230\":\"\",\"231\":\"| 类型 | 说明 |\",\"232\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "指定缩进用的空格或字符串，用于美化输出。当参数是数字时表示缩进的空格数；当参数是字符串时，该字符串被用作缩进；默认值是空字符串。",
      "注意事项": "在简化冗余表达时必须保留所有关键条件（特别是参数未提供时的默认行为），确保技术参数说明的完整性优先于句式简洁性，避免因过度删减导致信息缺失。"
    },
    {
      "defect_id": 529233,
      "sentence": "返回设置了提亮效果参数的HdrBrightnessBlender。",
      "reference_sentence": "",
      "line_num": 64,
      "context": "{\"59\":\"\",\"60\":\"**返回值：**\",\"61\":\"\",\"62\":\"| 类型                                     | 说明                     |\",\"63\":\"| ---------------------------------------- | ----------------------- |\",\"64\":\"| [HdrBrightnessBlender](#hdrbrightnessblender20) | 返回设置了提亮效果参数的HdrBrightnessBlender。 |\",\"65\":\"\",\"66\":\"**示例：**\",\"67\":\"\",\"68\":\"```ts\",\"69\":\"import { uiEffect } from \\\"@kit.ArkGraphics2D\\\"\"}",
      "用户拒绝的修改": "返回设置了提亮参数的HdrBrightnessBlender。",
      "注意事项": "修复冗余表达前需优先核对上下文术语一致性，保留参数/方法在文档中的完整官方命名，避免因过度简化破坏技术准确性。"
    },
    {
      "defect_id": 529078,
      "sentence": "当id为tab1的TabContent隐藏的时候，通过uniqueId设置该节点的冻结状态为true。",
      "reference_sentence": "",
      "line_num": 309,
      "context": "{\"304\":\"        .id('tab1')\",\"305\":\"        .onWillHide(() => {\",\"306\":\"          //通过id查询以获取对应节点的uniqueId。\",\"307\":\"          const node = this.getUIContext().getFrameNodeById('tab1');\",\"308\":\"          const uniqueId = node?.getUniqueId();\",\"309\":\"          //当id为tab1的TabContent隐藏的时候，通过uniqueId设置该节点的冻结状态为true。\",\"310\":\"          this.getUIContext().freezeUINode(uniqueId, true);\",\"311\":\"        })\",\"312\":\"        .onWillShow(() => {\",\"313\":\"          //通过id查询以获取对应节点的uniqueId。\",\"314\":\"          const node = this.getUIContext().getFrameNodeById('tab1');\"}",
      "用户拒绝的修改": "当id为tab1的TabContent隐藏时，设置该节点的冻结状态为true。",
      "注意事项": "保留关键接口参数说明（如\"通过uniqueId\"），避免过度简化导致技术细节丢失；需结合上下文判断\"冗余\"成分是否承载接口调用规范等重要信息。"
    },
    {
      "defect_id": 528626,
      "sentence": "可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"40\":\"\",\"41\":\"| 名称 | 类型 | 必填 | 装饰器类型 | 说明 |\",\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\"}",
      "用户拒绝的修改": "可以使用组件组合来自定义拉起原子化服务前的占位图标。点击占位组件后，将拉起原子化服务。从API version 12开始，该接口支持在原子化服务中使用。",
      "注意事项": "在删除修饰成分前需确认是否为必要功能说明（如\"实现类似大桌面应用图标的效果\"属于关键应用场景示例），并保持技术文档中API版本说明的独立分段格式（避免与功能描述合并）。"
    },
    {
      "defect_id": 529079,
      "sentence": "当id为tab1的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。",
      "reference_sentence": "",
      "line_num": 316,
      "context": "{\"311\":\"        })\",\"312\":\"        .onWillShow(() => {\",\"313\":\"          //通过id查询以获取对应节点的uniqueId。\",\"314\":\"          const node = this.getUIContext().getFrameNodeById('tab1');\",\"315\":\"          const uniqueId = node?.getUniqueId();\",\"316\":\"          //当id为tab1的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。\",\"317\":\"          this.getUIContext().freezeUINode(uniqueId, false)\",\"318\":\"        })\",\"319\":\"\",\"320\":\"        TabContent() {\",\"321\":\"          Column()\"}",
      "用户拒绝的修改": "当id为tab1的TabContent显示时，设置该节点的冻结状态为false。",
      "注意事项": "保留接口调用等关键技术细节，避免过度简化导致信息缺失。在消除冗余时应结合上下文判断\"通过uniqueId\"等介词结构是否承载接口规范等重要技术语义。"
    },
    {
      "defect_id": 529358,
      "sentence": "开发者尝试调整目标FrameNode节点的跨语言属性设置权限。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"当前FrameNode节点不支持跨语言属性设置，无法调整其跨语言的属性设置权限。\",\"34\":\"\",\"35\":\"**可能原因**\",\"36\":\"\",\"37\":\"开发者尝试调整目标FrameNode节点的跨语言属性设置权限。\",\"38\":\"\",\"39\":\"**处理步骤**\",\"40\":\"\",\"41\":\"NA\",\"42\":\"\"}",
      "用户拒绝的修改": "开发者尝试调整FrameNode节点的跨语言属性设置。",
      "注意事项": "在技术文档中删除修饰词前需确认其是否承担关键语义（如“目标”可能用于排除其他节点，“权限”可能涉及安全属性），优先保留上下文关联的术语（如问题根源为“权限”缺失时不可省略）。"
    },
    {
      "defect_id": 529238,
      "sentence": "**系统能力：** SystemCapability.Graphics.Drawing",
      "reference_sentence": "",
      "line_num": 832,
      "context": "{\"827\":\"\",\"828\":\"type Blender = BrightnessBlender | HdrBrightnessBlender\",\"829\":\"\",\"830\":\"混合器类型，用于描述混合效果。\",\"831\":\"\",\"832\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"833\":\"\",\"834\":\"**系统接口：** 此接口为系统接口。\",\"835\":\"\",\"836\":\"| 类型                          | 说明                                               |\",\"837\":\"| ----------------------------- | ------------------------------------------------- |\"}",
      "用户拒绝的修改": "系统能力：SystemCapability.Graphics.Drawing",
      "注意事项": "修复冗余表达时需严格区分标准术语标签与冗余内容，保留文档规范中规定的固定字段格式（如\"**系统能力：**\"），仅对冒号后的解释性内容进行冗余处理。"
    },
    {
      "defect_id": 529080,
      "sentence": "当id为tab2的TabContent显示的时候，通过uniqueId设置id为tab1的节点的冻结状态为true。通过状态变量改变id为tab1的节点内部Column节点的宽度。由于id为tab1的节点冻结状态为true，标脏至该TabContent的时候终止标记，同时不从该节点开始触发布局。",
      "reference_sentence": "",
      "line_num": 339,
      "context": "{\"334\":\"        })\",\"335\":\"        .onWillShow(() => {\",\"336\":\"          //通过id查询以获取对应节点的uniqueId。\",\"337\":\"          const node = this.getUIContext().getFrameNodeById('tab1');\",\"338\":\"          const uniqueId = node?.getUniqueId();\",\"339\":\"          //当id为tab2的TabContent显示的时候，通过uniqueId设置id为tab1的节点的冻结状态为true。\",\"340\":\"          //通过状态变量改变id为tab1的节点内部Column节点的宽度。由于id为tab1的节点冻结状态为true，标脏至该TabContent的时候终止标记，同时不从该节点开始触发布局。\",\"341\":\"          this.getUIContext().freezeUINode(uniqueId, true);\",\"342\":\"          this.columnWidth1 = '50%';\",\"343\":\"\",\"344\":\"          //设置延时任务。\"}",
      "用户拒绝的修改": "当id为tab2的TabContent显示时，设置id为tab1的节点冻结状态为true，并通过状态变量改变其内部Column节点的宽度。节点冻结后，标脏至该TabContent时终止标记，不触发布局。",
      "注意事项": "在简化技术文档冗余表达时，需优先保留关键操作路径和因果关系，避免过度删除必要的技术细节（如\"通过uniqueId设置\"中的uniqueId），同时区分代码逻辑说明和普通文本的简化标准。"
    },
    {
      "defect_id": 528627,
      "sentence": "需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->",
      "reference_sentence": "",
      "line_num": 44,
      "context": "{\"39\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"40\":\"\",\"41\":\"| 名称 | 类型 | 必填 | 装饰器类型 | 说明 |\",\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\"}",
      "用户拒绝的修改": "需要拉起的原子化服务appId，这是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。",
      "注意事项": "在技术文档中需保留必要的术语重复以确保定义清晰性，避免过度修改导致语义模糊；修改前应结合上下文判断重复是否属于强调关键参数的合理用法，优先保持技术准确性而非单纯追求句式简洁。"
    },
    {
      "defect_id": 529356,
      "sentence": "避免对不可修改的节点进行修改性操作。可通过try catch捕捉并处理错误，避免影响其他逻辑。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"开发者尝试对声明式节点进行修改性操作，例如，设置属性、增删子节点、绑定控制器。\",\"20\":\"\",\"21\":\"**处理步骤**\",\"22\":\"\",\"23\":\"避免对不可修改的节点进行修改性操作。可通过try catch捕捉并处理错误，避免影响其他逻辑。\",\"24\":\"\",\"25\":\"## 100022 FrameNode节点的组件类型不支持调整跨语言的属性设置权限\",\"26\":\"\",\"27\":\"**错误信息**\",\"28\":\"\"}",
      "用户拒绝的修改": "避免对不可修改的节点进行修改性操作。使用try catch捕捉并处理错误，防止影响其他逻辑。",
      "注意事项": "保持技术文档的术语准确性和上下文连贯性，优先保留专业表述的完整性，仅在确实存在冗余成分时进行最小化修改，避免改变原句的技术含义或操作指引力度。"
    },
    {
      "defect_id": 529076,
      "sentence": "以下错误码详细介绍请参考[通用错误码](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 158,
      "context": "{\"153\":\"| id | string | 是 | 组件的id。|\",\"154\":\"| isFrozen | boolean | 是 | 是否设置冻结。<br/>true表示设置冻结，false表示设置不冻结。<br/>默认值为false。|\",\"155\":\"\",\"156\":\"**错误码：**\",\"157\":\"\",\"158\":\"以下错误码详细介绍请参考[通用错误码](../errorcode-universal.md)。\",\"159\":\"\",\"160\":\"| 错误码ID | 错误信息 |\",\"161\":\"| -------- | -------- |\",\"162\":\"| 202 | The caller is not a system application. |\",\"163\":\"\"}",
      "用户拒绝的修改": "以下错误码详情请参考[通用错误码](../errorcode-universal.md)。",
      "注意事项": "修改冗余表达时需优先检查上下文术语一致性（如\"详情\"与\"详细介绍\"的用法统一性），并确认简化后的词汇是否完整保留技术文档要求的准确性（如\"详情\"可能弱化\"详细说明\"的强调意图）。"
    },
    {
      "defect_id": 528628,
      "sentence": "被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 46,
      "context": "{\"41\":\"| 名称 | 类型 | 必填 | 装饰器类型 | 说明 |\",\"42\":\"| -------- | -------- | -------- | -------- | -------- |\",\"43\":\"| content | Callback\\\\<void> | 是 | \\\\@BuilderParam | 可以使用组件组合来自定义拉起原子化服务前的占位图标，实现类似大桌面应用图标的效果。点击占位组件后，将拉起原子化服务。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。|\",\"44\":\"| appId | string | 是 | - |  需要拉起的原子化服务appId，appId是原子化服务的唯一标识。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。<!--RP1--><!--RP1End-->|\",\"45\":\"| options | [AtomicServiceOptions](../../apis-ability-kit/js-apis-app-ability-atomicServiceOptions.md) | 否 | - | 拉起原子化服务参数。<br/>**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。 |\",\"46\":\"| onError<sup>18+<sup> | [ErrorCallback](../../apis-basic-services-kit/js-apis-base.md#errorcallback) | 否 | - | 被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。可通过回调参数中的code、name和message获取错误信息并做处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"47\":\"| onTerminated<sup>18+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<[TerminationInfo](ts-container-embedded-component.md#terminationinfo)> | 否 | - | 被拉起的嵌入式运行原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)或者[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)正常退出时，触发本回调函数。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。 |\",\"48\":\"| onReceive<sup>20+<sup> | [Callback](../../apis-basic-services-kit/js-apis-base.md#callback)\\\\<Record<string, Object>> | 否 | - | 被拉起的嵌入式运行原子化服务通过[Window](../../../windowmanager/application-window-stage.md)调用API时，触发本回调。<br/>**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。 |\",\"49\":\"\",\"50\":\"> **说明：**\",\"51\":\">\"}",
      "用户拒绝的修改": "被拉起的嵌入式运行原子化服务在运行过程中发生异常时触发本回调。回调参数中的code、name和message可用于获取错误信息并处理。<br/>**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。",
      "注意事项": "在技术文档中保留功能性词汇（如\"可\"）以明确操作权限，避免过度简化导致语义模糊；优先保持技术术语的连贯性，仅在明显重复或冗余时调整句式结构。"
    },
    {
      "defect_id": 529081,
      "sentence": "当id为tab3的TabContent隐藏时，通过uniqueId将该节点的冻结状态设置为true。",
      "reference_sentence": "",
      "line_num": 364,
      "context": "{\"359\":\"        .id('tab3')\",\"360\":\"        .onWillHide(() => {\",\"361\":\"          //通过id查询以获取对应节点的uniqueId。\",\"362\":\"          const node = this.getUIContext().getFrameNodeById('tab3');\",\"363\":\"          const uniqueId = node?.getUniqueId();\",\"364\":\"          //当id为tab3的TabContent隐藏时，通过uniqueId将该节点的冻结状态设置为true。\",\"365\":\"          this.getUIContext().freezeUINode(uniqueId, true);\",\"366\":\"        })\",\"367\":\"        .onWillShow(() => {\",\"368\":\"          //通过id查询以获取对应节点的uniqueId。\",\"369\":\"          const node = this.getUIContext().getFrameNodeById('tab3');\"}",
      "用户拒绝的修改": "当TabContent隐藏时，通过uniqueId将节点的冻结状态设置为true。",
      "注意事项": "修复冗余表达时需保留必要的上下文限定词（如\"id为tab3\"），避免删除与代码上下文强关联的标识符；技术文档中的\"该节点\"等指示代词具有明确指代作用，不宜简化。"
    },
    {
      "defect_id": 529082,
      "sentence": "当id为tab3的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。",
      "reference_sentence": "",
      "line_num": 371,
      "context": "{\"366\":\"        })\",\"367\":\"        .onWillShow(() => {\",\"368\":\"          //通过id查询以获取对应节点的uniqueId。\",\"369\":\"          const node = this.getUIContext().getFrameNodeById('tab3');\",\"370\":\"          const uniqueId = node?.getUniqueId();\",\"371\":\"          //当id为tab3的TabContent显示的时候，通过uniqueId设置该节点的冻结状态为false。\",\"372\":\"          this.getUIContext().freezeUINode(uniqueId, false);\",\"373\":\"        })\",\"374\":\"\",\"375\":\"      }\",\"376\":\"      .vertical(false)\"}",
      "用户拒绝的修改": "当id为tab3的TabContent显示时，设置该节点的冻结状态为false。",
      "注意事项": "保留关键参数传递和技术细节（如\"通过uniqueId\"），避免过度简化导致技术信息丢失；确保修改后的表述与代码上下文中的变量引用保持严格对应关系。"
    },
    {
      "defect_id": 534305,
      "sentence": "查询设备域名过滤规则，仅支持IPv4。",
      "reference_sentence": "",
      "line_num": 755,
      "context": "{\"750\":\"\",\"751\":\"## networkManager.getDomainFilterRules\",\"752\":\"\",\"753\":\"getDomainFilterRules(admin: Want): Array\\\\<DomainFilterRule>\",\"754\":\"\",\"755\":\"查询设备域名过滤规则，仅支持IPv4。\",\"756\":\"\",\"757\":\"**需要权限：** ohos.permission.ENTERPRISE_MANAGE_NETWORK\",\"758\":\"\",\"759\":\"**系统能力：** SystemCapability.Customization.EnterpriseDeviceManager\",\"760\":\"\"}",
      "用户拒绝的修改": "查询设备域名过滤规则。",
      "注意事项": "在修复冗余表达时需严格区分冗余修饰与关键限制条件，优先保留影响功能准确性的技术规格（如协议类型、版本限制等），并通过上下文判断信息必要性。"
    },
    {
      "defect_id": 535070,
      "sentence": "**返回值：**",
      "reference_sentence": "",
      "line_num": 317,
      "context": "{\"312\":\"\",\"313\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"314\":\"\",\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\",\"317\":\"**返回值：**\",\"318\":\"| 类型     | 说明      |\",\"319\":\"| ------ | ------- |\",\"320\":\"| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域对象。 |\",\"321\":\"\",\"322\":\"**示例：**\"}",
      "用户拒绝的修改": "**返回值**",
      "注意事项": "在技术文档中保留必要的结构符号（如冒号），确保标题与后续内容的格式一致性；修复冗余表达时需结合上下文判断是否为固定模板或规范格式，避免破坏文档结构性语义。"
    },
    {
      "defect_id": 535069,
      "sentence": "**系统能力：** SystemCapability.Global.I18n",
      "reference_sentence": "",
      "line_num": 315,
      "context": "{\"310\":\"\",\"311\":\"获取系统当前设置的区域对象。\",\"312\":\"\",\"313\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"314\":\"\",\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\",\"317\":\"**返回值：**\",\"318\":\"| 类型     | 说明      |\",\"319\":\"| ------ | ------- |\",\"320\":\"| [Intl.Locale](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale) | 系统区域对象。 |\"}",
      "用户拒绝的修改": "**系统能力:** SystemCapability.Global.I18n",
      "注意事项": "修复冗余表达时需严格区分文档固定格式（如标题后的冒号）与冗余内容，优先保留技术文档中约定俗成的结构符号（如**字段标签:**），避免将规范格式误判为语言冗余。"
    },
    {
      "defect_id": 535068,
      "sentence": "**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 313,
      "context": "{\"308\":\"\",\"309\":\"static getSystemLocaleInstance(): Intl.Locale;\",\"310\":\"\",\"311\":\"获取系统当前设置的区域对象。\",\"312\":\"\",\"313\":\"**原子化服务API：** 从API version 20开始，该接口支持在原子化服务中使用。\",\"314\":\"\",\"315\":\"**系统能力：** SystemCapability.Global.I18n\",\"316\":\"\",\"317\":\"**返回值：**\",\"318\":\"| 类型     | 说明      |\"}",
      "用户拒绝的修改": "**原子化服务API：** 从API version 20开始支持在原子化服务中使用。",
      "注意事项": "在技术文档中删除指代性成分时需确保上下文清晰，保留必要术语避免歧义；优先维护技术准确性而非过度简化，特别注意\"该接口\"等指代词在上下文中的必要性。"
    },
    {
      "defect_id": 538126,
      "sentence": "  - 不支持undefined和null：返回自身，不做任何处理。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"  ```\",\"31\":\"\",\"32\":\"## 限制条件\",\"33\":\"\",\"34\":\"- makeObserved仅支持非空的对象类型传参。\",\"35\":\"  - 不支持undefined和null：返回自身，不做任何处理。\",\"36\":\"  - 非Object类型：编译拦截报错。\",\"37\":\"\",\"38\":\"  ```ts\",\"39\":\"  import { UIUtils } from '@kit.ArkUI';\",\"40\":\"  let res1 = UIUtils.makeObserved(2); // 非法类型入参，错误用法，编译报错\"}",
      "用户拒绝的修改": "  - 不支持undefined和null。",
      "注意事项": "修复冗余表达时必须保留关键行为描述（如\"返回自身\"），同时确保条目间结构一致性，避免因过度简化导致信息缺失。"
    },
    {
      "defect_id": 539708,
      "sentence": "为组件内容提供基于mask的转场效果。",
      "reference_sentence": "",
      "line_num": 642,
      "context": "{\"637\":\"```\",\"638\":\"\",\"639\":\"### maskTransition<sup>20+</sup>\",\"640\":\"maskTransition(alphaMask: Mask, factor?: number, inverse?: boolean): Filter\",\"641\":\"\",\"642\":\"为组件内容提供基于mask的转场效果。\",\"643\":\"\",\"644\":\"**系统能力：** SystemCapability.Graphics.Drawing\",\"645\":\"\",\"646\":\"**系统接口：** 此接口为系统接口。\",\"647\":\"\"}",
      "用户拒绝的修改": "提供基于mask的转场效果。",
      "注意事项": "在删除冗余表达前必须确认被删成分是否承担关键语义角色（如明确动作受体\"为组件内容\"），技术文档修改需优先保留专业术语的完整性，避免破坏主谓结构导致信息缺失。"
    },
    {
      "defect_id": 538127,
      "sentence": "  - 非Object类型：编译拦截报错。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"\",\"32\":\"## 限制条件\",\"33\":\"\",\"34\":\"- makeObserved仅支持非空的对象类型传参。\",\"35\":\"  - 不支持undefined和null：返回自身，不做任何处理。\",\"36\":\"  - 非Object类型：编译拦截报错。\",\"37\":\"\",\"38\":\"  ```ts\",\"39\":\"  import { UIUtils } from '@kit.ArkUI';\",\"40\":\"  let res1 = UIUtils.makeObserved(2); // 非法类型入参，错误用法，编译报错\",\"41\":\"  let res2 = UIUtils.makeObserved(undefined); // 非法类型入参，错误用法，返回自身，res2 === undefined\"}",
      "用户拒绝的修改": "  - 非Object类型：编译报错。",
      "注意事项": "在删除修饰成分前需确认其是否承担技术性含义，确保\"编译拦截报错\"这类复合技术动作的完整性，避免过度简化导致语义缺失。建议优先保留技术文档特有的精准动词（如\"拦截\"），仅删除纯修饰性词汇。"
    },
    {
      "defect_id": 538133,
      "sentence": "该场景仅适用于ArkTS1.1。",
      "reference_sentence": "",
      "line_num": 174,
      "context": "{\"169\":\"\",\"170\":\"## 使用场景\",\"171\":\"\",\"172\":\"### makeObserved和@Sendable装饰的class配合使用\",\"173\":\"\",\"174\":\"**该场景仅适用于ArkTS1.1。**\",\"175\":\"\",\"176\":\"[@Sendable](../arkts-utils/arkts-sendable.md)主要是为了处理应用场景中的并发任务。将makeObserved和@Sendable配合使用是为了满足一般应用开发中，在子线程做大数据处理，在UI线程做ViewModel的显示和观察数据的需求。@Sendable具体内容可参考[并发任务文档](../arkts-utils/multi-thread-concurrency-overview.md)。\",\"177\":\"\",\"178\":\"本章节将说明下面的场景：\",\"179\":\"- makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。\"}",
      "用户拒绝的修改": "该功能仅适用于ArkTS1.1。",
      "注意事项": "保持原文核心术语一致性，优先使用上下文已明确的专业表述（如\"场景\"）；在确保不改变原意的前提下进行简化，避免过度替换关键概念导致信息偏差。"
    },
    {
      "defect_id": 541039,
      "sentence": "OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。它提供了一组稳定的、跨平台的API，可以在不同的操作系统上使用。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# Node-API简介\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。它提供了一组稳定的、跨平台的API，可以在不同的操作系统上使用。\",\"6\":\"\",\"7\":\"本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\"}",
      "用户拒绝的修改": "OpenHarmony Node-API基于Node.js 12.x LTS的Node-API规范扩展开发，提供ArkTS/JS与C/C++模块的交互能力，支持跨平台的稳定API。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的规范引用和跨平台特性等关键细节，避免过度简化导致信息缺失；合并句子时需确保不改变原文的技术准确性，特别注意保留外部链接和操作系统适配等核心说明。"
    },
    {
      "defect_id": 538986,
      "sentence": "此接口为系统接口。",
      "reference_sentence": "",
      "line_num": 740,
      "context": "{\"735\":\"\",\"736\":\"static getSystemMeasurements(): Map&lt;string, string&gt;\",\"737\":\"\",\"738\":\"获取系统支持的度量衡及名称。\",\"739\":\"\",\"740\":\"**系统接口**：此接口为系统接口。\",\"741\":\"\",\"742\":\"**系统能力**：SystemCapability.Global.I18n\",\"743\":\"\",\"744\":\"**返回值：**\",\"745\":\"\"}",
      "用户拒绝的修改": "此接口是系统接口。",
      "注意事项": "修复冗余表达时需优先检查句子结构完整性，确保主语明确且不破坏上下文逻辑；避免机械替换词汇，应结合技术文档特性判断是否需简化句式或补充必要信息。"
    },
    {
      "defect_id": 538355,
      "sentence": "该方法仅能调用一次。",
      "reference_sentence": "",
      "line_num": 714,
      "context": "{\"709\":\"\",\"710\":\"setHapticsRamp(duration: number, startIntensity: number, endIntensity: number): Promise&lt;void&gt;\",\"711\":\"\",\"712\":\"设置音振协同播放器渐变播放，使用Promise进行异步回调。\",\"713\":\"该方法必须在音振协同播放器播放前后以及销毁前使用。\",\"714\":\"该方法仅能调用一次。\",\"715\":\"\",\"716\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"717\":\"\",\"718\":\"**参数**\",\"719\":\"\"}",
      "用户拒绝的修改": "该方法只能调用一次。",
      "注意事项": "避免机械性同义词替换，优先确保修改后确实缩短表达长度或简化结构；在技术文档中需保留术语一致性（如“仅能”可能为固定搭配），若替换未显著优化可维持原句。"
    },
    {
      "defect_id": 538989,
      "sentence": "此接口为系统接口。",
      "reference_sentence": "",
      "line_num": 777,
      "context": "{\"772\":\"\",\"773\":\"static getUsingMeasurement(): string\",\"774\":\"\",\"775\":\"获取系统当前使用的度量衡。\",\"776\":\"\",\"777\":\"**系统接口**：此接口为系统接口。\",\"778\":\"\",\"779\":\"**系统能力**：SystemCapability.Global.I18n\",\"780\":\"\",\"781\":\"**返回值：**\",\"782\":\"\"}",
      "用户拒绝的修改": "此接口是系统接口。",
      "注意事项": "修复冗余表达时需结合上下文判断信息必要性，优先删除重复内容而非仅替换用词；若原句存在成分缺失，应补充完整主语或关键描述而非简单调整句式。"
    },
    {
      "defect_id": 538990,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 789,
      "context": "{\"784\":\"| ---------------------- | ----- |\",\"785\":\"| string | 系统当前使用的度量衡。 |\",\"786\":\"\",\"787\":\"**错误码：**\",\"788\":\"\",\"789\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)。\",\"790\":\"\",\"791\":\"| 错误码ID  | 错误信息                   |\",\"792\":\"| ------ | ---------------------- |\",\"793\":\"| 202 | Permission verification failed. A non-system application calls a system API. |\",\"794\":\"\"}",
      "用户拒绝的修改": "请参见[通用错误码](../errorcode-universal.md)以获取错误码的详细介绍。",
      "注意事项": "修复时应优先保留原文的关键指示词（如\"以下\"），确保上下文关联性；在调整语序时需注意技术文档的格式规范，避免破坏表格与说明文字的逻辑对应关系。"
    },
    {
      "defect_id": 538991,
      "sentence": "此接口为系统接口。",
      "reference_sentence": "",
      "line_num": 814,
      "context": "{\"809\":\"\",\"810\":\"static setSystemMeasurement(identifier: string): void\",\"811\":\"\",\"812\":\"设置系统的度量衡。\",\"813\":\"\",\"814\":\"**系统接口**：此接口为系统接口。\",\"815\":\"\",\"816\":\"**需要权限**：ohos.permission.UPDATE_CONFIGURATION\",\"817\":\"\",\"818\":\"**系统能力**：SystemCapability.Global.I18n\",\"819\":\"\"}",
      "用户拒绝的修改": "此接口是系统接口。",
      "注意事项": "修复冗余表达时应优先检查句子结构完整性（如补充缺失主语），并确保技术文档的准确性比单纯简化更重要，需结合上下文判断是否需保留专业术语或特定表述。"
    },
    {
      "defect_id": 541642,
      "sentence": "是一个枚举数据类型，表示Node-API接口返回的状态信息。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## Node-API的数据类型\",\"4\":\"\",\"5\":\"### napi_status\",\"6\":\"\",\"7\":\"是一个枚举数据类型，表示Node-API接口返回的状态信息。\",\"8\":\"\",\"9\":\"每当调用一个Node-API函数，都会返回该值，表示操作成功与否的相关信息。\",\"10\":\"\",\"11\":\"```c\",\"12\":\"typedef enum {\"}",
      "用户拒绝的修改": "napi_status 是一个枚举数据类型，表示 Node-API 接口返回的状态信息。",
      "注意事项": "修复时应优先检查上下文标题是否已作为隐含主语，避免重复添加冗余主语；采用\"该+名词\"或代词指代等简洁表达替代完整名词重复，保持技术文档的上下文连贯性。"
    },
    {
      "defect_id": 542007,
      "sentence": "### bigint相关",
      "reference_sentence": "",
      "line_num": 414,
      "context": "{\"409\":\"| napi_get_value_uint32 | 获取给定JS number对应的C uint32值。 |\",\"410\":\"| napi_get_value_int64 | 获取给定JS number对应的C int64值。 |\",\"411\":\"| napi_get_value_double | 获取给定JS number对应的C double值。 |\",\"412\":\"|napi_get_value_bool|获取给定js Boolean对应的C bool值。|\",\"413\":\"\",\"414\":\"### bigint相关\",\"415\":\"\",\"416\":\"| 接口 | 功能说明 |\",\"417\":\"| -------- | -------- |\",\"418\":\"| napi_create_bigint_int64 | 通过一个C的int64数据创建JS BigInt。 |\",\"419\":\"| napi_create_bigint_uint64 | 通过一个C的uint64数据创建JS BigInt。 |\"}",
      "用户拒绝的修改": "### bigint",
      "注意事项": "在删除冗余词前需全面检查文档上下文，确保标题层级和术语使用与其他章节保持统一；优先保留核心关键词的完整性，避免因过度简化影响技术概念的准确表达。"
    },
    {
      "defect_id": 542103,
      "sentence": "从给定的callback info中获取有关调用的详细信息，如参数和this指针。",
      "reference_sentence": "",
      "line_num": 489,
      "context": "{\"484\":\"### 函数调用\",\"485\":\"\",\"486\":\"| 接口 | 功能说明 |\",\"487\":\"| -------- | -------- |\",\"488\":\"| napi_call_function | 在C/C++侧调用JS方法。 |\",\"489\":\"| napi_get_cb_info | 从给定的callback info中获取有关调用的详细信息，如参数和this指针。 |\",\"490\":\"\",\"491\":\"### 环境生命周期\",\"492\":\"\",\"493\":\"| 接口 | 功能说明 |\",\"494\":\"| -------- | -------- |\"}",
      "用户拒绝的修改": "从callback info中获取调用的详细信息，如参数和this指针。",
      "注意事项": "修复冗余表达时需优先保留技术文档中的关键限定词（如“给定的”），避免过度删减影响术语准确性；需结合上下文判断修饰成分是否承载必要技术含义，而非单纯删除\"冗余\"词汇。"
    },
    {
      "defect_id": 541648,
      "sentence": "napi_handle_scope数据类型是用来管理ArkTS/JS对象的生命周期的。它允许ArkTS/JS对象在一定范围内保持活动状态，以便在ArkTS/JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的ArkTS/JS对象都会保持活动状态，直到scope被关闭。这样可以做到ArkTS/JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。",
      "reference_sentence": "",
      "line_num": 115,
      "context": "{\"110\":\"\",\"111\":\"Node-API包含以下内存管理类型：\",\"112\":\"\",\"113\":\"#### napi_handle_scope\",\"114\":\"\",\"115\":\"napi_handle_scope数据类型是用来管理ArkTS/JS对象的生命周期的。它允许ArkTS/JS对象在一定范围内保持活动状态，以便在ArkTS/JS代码中使用。在创建napi_handle_scope时，所有在该范围内创建的ArkTS/JS对象都会保持活动状态，直到scope被关闭。这样可以做到ArkTS/JS对象生命周期最小化，[避免发生内存泄漏问题](napi-guidelines.md#生命周期管理)。同时，napi_handle_scope也可参考[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。\",\"116\":\"\",\"117\":\"#### napi_escapable_handle_scope\",\"118\":\"\",\"119\":\"- 由napi_open_escapable_handle_scope接口创建，由napi_close_escapable_handle_scope接口关闭。\",\"120\":\"\"}",
      "用户拒绝的修改": "napi_handle_scope数据类型用于管理ArkTS/JS对象的生命周期。它确保这些对象在一定范围内保持活动状态，直到scope被关闭，从而避免内存泄漏。具体注意事项可参考[生命周期管理](napi-guidelines.md#生命周期管理)和[生命周期类问题注意事项](../dfx/cppcrash-guidelines.md#案例4生命周期类问题)。",
      "注意事项": "修复冗余表达时需优先保留原文核心术语（如\"用来\"）避免过度替换，同时确保技术细节和参考链接的完整性与位置准确性，不可因删减丢失关键信息或破坏文档结构。"
    },
    {
      "defect_id": 543257,
      "sentence": "使用napi_set_element方法对JSArray存储值类型数据（如int32）时，同样会涉及到与运行时的交互，造成不必要的开销。",
      "reference_sentence": "",
      "line_num": 228,
      "context": "{\"223\":\"\",\"224\":\"**【建议】** 存储值类型数据时，使用ArrayBuffer代替JSArray来提高应用性能。\",\"225\":\"\",\"226\":\"使用JSArray作为容器储存数据，支持几乎所有的JS数据类型。\",\"227\":\"\",\"228\":\"使用napi_set_element方法对JSArray存储值类型数据（如int32）时，同样会涉及到与运行时的交互，造成不必要的开销。\",\"229\":\"\",\"230\":\"ArrayBuffer进行增改是直接对缓冲区进行更改，具有远优于使用napi_set_element操作JSArray的性能表现。\",\"231\":\"\",\"232\":\"因此此种场景下，更推荐使用napi_create_arraybuffer接口创建的ArrayBuffer对象。\",\"233\":\"\"}",
      "用户拒绝的修改": "使用napi_set_element方法存储值类型数据（如int32）时，会涉及运行时交互，增加开销。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的关键术语（如\"JSArray\"）和上下文关联信息，避免过度简化导致技术准确性受损；需结合上下文判断修饰成分是否必要，确保修改后的句子在缩短长度的同时不丢失核心技术细节。"
    },
    {
      "defect_id": 543256,
      "sentence": "本规则旨在强调napi_value生命周期情况，若只想往JS线程抛任务，**不推荐**使用uv_queue_work方法。如有抛任务的需要，请使用[napi_threadsafe_function系列](./use-napi-thread-safety.md)接口。",
      "reference_sentence": "",
      "line_num": 148,
      "context": "{\"143\":\"\",\"144\":\"使用uv_queue_work方法，不会走Node-API框架，此时需要开发者自己合理使用napi_handle_scope来管理napi_value的生命周期。\",\"145\":\"\",\"146\":\"> **说明**\",\"147\":\">\",\"148\":\"> 本规则旨在强调napi_value生命周期情况，若只想往JS线程抛任务，**不推荐**使用uv_queue_work方法。如有抛任务的需要，请使用[napi_threadsafe_function系列](./use-napi-thread-safety.md)接口。\",\"149\":\"\",\"150\":\"**正确示例**：\",\"151\":\"\",\"152\":\"```cpp\",\"153\":\"void CallbackTest(CallbackContext* context)\"}",
      "用户拒绝的修改": "本规则强调napi_value的生命周期管理。若只需向JS线程抛任务，不推荐使用uv_queue_work方法。如有需要，请使用[napi_threadsafe_function系列](./use-napi-thread-safety.md)接口。",
      "注意事项": "修复冗余表达时需优先保留技术术语和关键动作的明确性（如\"生命周期情况\"\"抛任务\"），避免过度简化导致技术细节丢失；同时需尊重用户对重复结构的偏好（如\"抛任务的需要\"），仅在修饰性成分上精简。"
    },
    {
      "defect_id": 544406,
      "sentence": "2.在停止操作前，检查闪控球是否已停止。",
      "reference_sentence": "",
      "line_num": 373,
      "context": "{\"368\":\"\",\"369\":\"**处理步骤**\",\"370\":\"\",\"371\":\"1.在启动操作前，检查闪控球是否已启动。\",\"372\":\"\",\"373\":\"2.在停止操作前，检查闪控球是否已停止。\",\"374\":\"\",\"375\":\"3.在注册闪控球回调操作前，判断回调是否已注册。\",\"376\":\"\",\"377\":\"## 1300023 闪控球内部错误\",\"378\":\"\"}",
      "用户拒绝的修改": "2.在停止操作前，检查闪控球状态。",
      "注意事项": "修复冗余表达时应保留必要限定词确保操作指向明确性，技术文档需优先保持术语一致性，修改前需核对上下文相邻步骤的表述逻辑。"
    },
    {
      "defect_id": 545748,
      "sentence": "Repeated floating Ball operation.",
      "reference_sentence": "",
      "line_num": 139,
      "context": "{\"134\":\"|------------|------------|\",\"135\":\"| 201 | Permission verification failed, usually returned by VerifyAccessToken. |\",\"136\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"137\":\"| 1300020 | Failed to create the floating Ball window. |\",\"138\":\"| 1300021 | Failed to start multiple floating Ball windows. |\",\"139\":\"| 1300022 | Repeated floating Ball operation. |\",\"140\":\"| 1300023 | Floating ball internal error. |\",\"141\":\"| 1300024 | The floating ball window state is abnormal. |\",\"142\":\"| 1300025 | The floating ball state does not support this operation. |\",\"143\":\"\",\"144\":\"**示例：**\"}",
      "用户拒绝的修改": "Repeated floating ball operation.",
      "注意事项": "在修复术语冗余前必须优先核对上下文术语一致性（如\"Ball\"在上下文中作为专有名词需保持首字母大写），并尊重用户标注的\"已评审内容无需修改\"要求，避免破坏已有术语规范。"
    },
    {
      "defect_id": 545756,
      "sentence": "Updating static template-based floating balls is not supported.",
      "reference_sentence": "",
      "line_num": 197,
      "context": "{\"192\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"193\":\"| 1300023 | Floating ball internal error. |\",\"194\":\"| 1300024 | The floating ball window state is abnormal. |\",\"195\":\"| 1300025 | The floating ball state does not support this operation. |\",\"196\":\"| 1300027 | When updating the floating ball, the template type cannot be changed. |\",\"197\":\"| 1300028 | Updating static template-based floating balls is not supported. |\",\"198\":\"\",\"199\":\"**示例：**\",\"200\":\"\",\"201\":\"```ts\",\"202\":\"let updateParams: floatingBall.FloatingBallParams = {\"}",
      "用户拒绝的修改": "Updating static template-based floating ball is not supported.",
      "注意事项": "在修复单复数冗余前必须确认上下文术语一致性，优先尊重用户已评审的术语规范，避免机械修改已核准的英文技术表达。"
    },
    {
      "defect_id": 544396,
      "sentence": "1.启动闪控球时参数有误。",
      "reference_sentence": "",
      "line_num": 319,
      "context": "{\"314\":\"\",\"315\":\"创建闪控球窗口失败。\",\"316\":\"\",\"317\":\"**可能原因**\",\"318\":\"\",\"319\":\"1.启动闪控球时参数有误。\",\"320\":\"\",\"321\":\"2.在不支持的设备上启动闪控球。\",\"322\":\"\",\"323\":\"3.应用在后台时启动闪控球。\",\"324\":\"\"}",
      "用户拒绝的修改": "1.参数有误。",
      "注意事项": "在技术文档的列举项中，需保留明确指向具体操作步骤的状语成分（如\"启动闪控球时\"），避免过度简化导致情境信息丢失；当多个并列条目共享相同操作主体时，应保持句式结构一致性而非孤立处理单一条目。"
    },
    {
      "defect_id": 544420,
      "sentence": "1.点击后5秒内未拉起应用窗口。",
      "reference_sentence": "",
      "line_num": 461,
      "context": "{\"456\":\"\",\"457\":\"**可能原因**\",\"458\":\"\",\"459\":\"1.传入参数有误。\",\"460\":\"\",\"461\":\"2.点击后5秒内未拉起应用窗口。\",\"462\":\"\",\"463\":\"3.拉起非本应用的窗口。\",\"464\":\"\",\"465\":\"**处理步骤**\",\"466\":\"\"}",
      "用户拒绝的修改": "1.点击后未拉起应用窗口。",
      "注意事项": "修复冗余表达时必须保留技术参数和时间限制等关键信息，优先验证被删除内容是否属于问题诊断或操作步骤的必要条件，特别是涉及量化指标时要保持原有时效性描述。"
    },
    {
      "defect_id": 545752,
      "sentence": "Wrong parameters for operating the floating ball.",
      "reference_sentence": "",
      "line_num": 192,
      "context": "{\"187\":\"| 错误码ID | 错误信息 |\",\"188\":\"|------------|------------|\",\"189\":\"| 1300002 | This window state is abnormal. |\",\"190\":\"| 1300003 | This window manager service works abnormally. |\",\"191\":\"| 1300004 | Unauthorized operation. |\",\"192\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"193\":\"| 1300023 | Floating ball internal error. |\",\"194\":\"| 1300024 | The floating ball window state is abnormal. |\",\"195\":\"| 1300025 | The floating ball state does not support this operation. |\",\"196\":\"| 1300027 | When updating the floating ball, the template type cannot be changed. |\",\"197\":\"| 1300028 | Updating static template-based floating balls is not supported. |\"}",
      "用户拒绝的修改": "Wrong parameters for operating the floating icon.",
      "注意事项": "修复冗余表达前需优先确认术语一致性，若目标词汇在上下文多次出现且属于专有名词（如\"floating ball\"在错误码体系中为固定术语），应保留原词避免破坏技术文档的统一性。"
    },
    {
      "defect_id": 544417,
      "sentence": "2.进行查询闪控球窗口信息操作时，检查闪控球是否已启动。",
      "reference_sentence": "",
      "line_num": 441,
      "context": "{\"436\":\"\",\"437\":\"**处理步骤**\",\"438\":\"\",\"439\":\"1.进行更新操作前，检查闪控球是否已启动。\",\"440\":\"\",\"441\":\"2.进行查询闪控球窗口信息操作时，检查闪控球是否已启动。\",\"442\":\"\",\"443\":\"3.进行拉起应用窗口操作时，检查闪控球是否已启动。\",\"444\":\"\",\"445\":\"4.等待回调闪控球停止状态后，再次启动闪控球。\",\"446\":\"\"}",
      "用户拒绝的修改": "2.查询闪控球窗口信息时，检查闪控球是否已启动。",
      "注意事项": "修复冗余表达时需优先保留操作动词的明确性，确保省略后不影响步骤的上下文连贯性；需结合相邻步骤的句式结构统一性判断是否属于必要修饰，避免因过度简化导致动作主体或执行条件模糊。"
    },
    {
      "defect_id": 544402,
      "sentence": "1.闪控球在启动状态下再次启动。",
      "reference_sentence": "",
      "line_num": 363,
      "context": "{\"358\":\"\",\"359\":\"重复操作闪控球。\",\"360\":\"\",\"361\":\"**可能原因**\",\"362\":\"\",\"363\":\"1.闪控球在启动状态下再次启动。\",\"364\":\"\",\"365\":\"2.闪控球停止后，再次停止无效。\",\"366\":\"\",\"367\":\"3.避免重复注册闪控球回调。\",\"368\":\"\"}",
      "用户拒绝的修改": "1.闪控球再次启动。",
      "注意事项": "修复冗余表达时必须保留关键限定条件（如\"在启动状态下\"），避免因省略必要状态信息导致歧义，需结合上下文判断修饰成分是否影响核心语义完整性。"
    },
    {
      "defect_id": 545755,
      "sentence": "When updating the floating ball, the template type cannot be changed.",
      "reference_sentence": "",
      "line_num": 196,
      "context": "{\"191\":\"| 1300004 | Unauthorized operation. |\",\"192\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"193\":\"| 1300023 | Floating ball internal error. |\",\"194\":\"| 1300024 | The floating ball window state is abnormal. |\",\"195\":\"| 1300025 | The floating ball state does not support this operation. |\",\"196\":\"| 1300027 | When updating the floating ball, the template type cannot be changed. |\",\"197\":\"| 1300028 | Updating static template-based floating balls is not supported. |\",\"198\":\"\",\"199\":\"**示例：**\",\"200\":\"\",\"201\":\"```ts\"}",
      "用户拒绝的修改": "When updating the floating ball, the template type cannot be modified.",
      "注意事项": "修复前需确认\"冗余表达\"是否真实存在（如原句实际未重复\"ball\"），并优先保留已通过评审的术语（如\"changed\"已被确认无需替换为\"modified\"）。"
    },
    {
      "defect_id": 545751,
      "sentence": "This window manager service works abnormally.",
      "reference_sentence": "",
      "line_num": 190,
      "context": "{\"185\":\"以下错误码的详细介绍请参见[窗口错误码](errorcode-window.md)。\",\"186\":\"\",\"187\":\"| 错误码ID | 错误信息 |\",\"188\":\"|------------|------------|\",\"189\":\"| 1300002 | This window state is abnormal. |\",\"190\":\"| 1300003 | This window manager service works abnormally. |\",\"191\":\"| 1300004 | Unauthorized operation. |\",\"192\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"193\":\"| 1300023 | Floating ball internal error. |\",\"194\":\"| 1300024 | The floating ball window state is abnormal. |\",\"195\":\"| 1300025 | The floating ball state does not support this operation. |\"}",
      "用户拒绝的修改": "Window manager service works abnormally.",
      "注意事项": "修复前需确认上下文是否存在统一指代格式，优先保持文档现有表达一致性；对于已通过专业评审的英文内容，若非必要应避免修改已确认的语法结构。"
    },
    {
      "defect_id": 544409,
      "sentence": "2.闪控球控制器异常，可能是控制器为空。",
      "reference_sentence": "",
      "line_num": 391,
      "context": "{\"386\":\"\",\"387\":\"**可能原因**\",\"388\":\"\",\"389\":\"1.闪控球依赖的窗口异常，可能为空。\",\"390\":\"\",\"391\":\"2.闪控球控制器异常，可能是控制器为空。\",\"392\":\"\",\"393\":\"**处理步骤**\",\"394\":\"\",\"395\":\"1.检查闪控球的窗口，确保其非空。\",\"396\":\"\"}",
      "用户拒绝的修改": "2.闪控球控制器异常，控制器为空。",
      "注意事项": "修复冗余表达时必须保留关键限定词（如“可能”），避免将推测性描述误判为冗余修饰，确保语义完整性和逻辑准确性。"
    },
    {
      "defect_id": 543285,
      "sentence": "napi_create_external系列接口创建出来的JS对象仅允许在当前线程传递和使用，跨线程传递（如使用worker的post_message）将会导致应用crash。若需跨线程传递绑定有Native对象的JS对象，请使用napi_coerce_to_native_binding_object接口绑定JS对象和Native对象。",
      "reference_sentence": "",
      "line_num": 403,
      "context": "{\"398\":\"}\",\"399\":\"```\",\"400\":\"\",\"401\":\"## 正确的使用napi_create_external系列接口创建的JS Object\",\"402\":\"\",\"403\":\"**【规则】** napi_create_external系列接口创建出来的JS对象仅允许在当前线程传递和使用，跨线程传递（如使用worker的post_message）将会导致应用crash。若需跨线程传递绑定有Native对象的JS对象，请使用napi_coerce_to_native_binding_object接口绑定JS对象和Native对象。\",\"404\":\"\",\"405\":\"**错误示例**\",\"406\":\"\",\"407\":\"```cpp\",\"408\":\"static void MyFinalizeCB(napi_env env, void *finalize_data, void *finalize_hint) { return; };\"}",
      "用户拒绝的修改": "napi_create_external系列接口创建的JS对象仅限当前线程使用，跨线程传递将导致应用崩溃。若需跨线程传递，应使用napi_coerce_to_native_binding_object接口绑定JS对象和Native对象。",
      "注意事项": "修复冗余表达时应优先保留关键性技术细节和示例（如\"worker的post_message\"），避免过度简化导致语义模糊；需区分修饰成分是否承载重要限制条件，技术文档中的具体场景说明通常具有指导价值不可随意删除。"
    },
    {
      "defect_id": 544397,
      "sentence": "2.在不支持的设备上启动闪控球。",
      "reference_sentence": "",
      "line_num": 321,
      "context": "{\"316\":\"\",\"317\":\"**可能原因**\",\"318\":\"\",\"319\":\"1.启动闪控球时参数有误。\",\"320\":\"\",\"321\":\"2.在不支持的设备上启动闪控球。\",\"322\":\"\",\"323\":\"3.应用在后台时启动闪控球。\",\"324\":\"\",\"325\":\"**处理步骤**\",\"326\":\"\"}",
      "用户拒绝的修改": "2.在不支持的设备启动闪控球。",
      "注意事项": "修复冗余表达时必须优先确保上下文结构一致性，并严格验证修饰成分是否真正冗余（如删除后是否可能引发歧义或破坏平行结构），避免过度简化破坏技术文档的严谨性。"
    },
    {
      "defect_id": 545747,
      "sentence": "Failed to start multiple floating Ball windows.",
      "reference_sentence": "",
      "line_num": 138,
      "context": "{\"133\":\"| 错误码ID | 错误信息 |\",\"134\":\"|------------|------------|\",\"135\":\"| 201 | Permission verification failed, usually returned by VerifyAccessToken. |\",\"136\":\"| 1300019 | Wrong parameters for operating the floating ball. |\",\"137\":\"| 1300020 | Failed to create the floating Ball window. |\",\"138\":\"| 1300021 | Failed to start multiple floating Ball windows. |\",\"139\":\"| 1300022 | Repeated floating Ball operation. |\",\"140\":\"| 1300023 | Floating ball internal error. |\",\"141\":\"| 1300024 | The floating ball window state is abnormal. |\",\"142\":\"| 1300025 | The floating ball state does not support this operation. |\",\"143\":\"\"}",
      "用户拒绝的修改": "Failed to start multiple floating windows.",
      "注意事项": "在修复冗余表达前必须优先核对上下文术语一致性，若\"Ball\"属于产品功能专有名词组成部分（如\"floating Ball\"为固定功能名称），应保留原始术语而非机械删除重复词汇。"
    },
    {
      "defect_id": 544403,
      "sentence": "2.闪控球停止后，再次停止无效。",
      "reference_sentence": "",
      "line_num": 365,
      "context": "{\"360\":\"\",\"361\":\"**可能原因**\",\"362\":\"\",\"363\":\"1.闪控球在启动状态下再次启动。\",\"364\":\"\",\"365\":\"2.闪控球停止后，再次停止无效。\",\"366\":\"\",\"367\":\"3.避免重复注册闪控球回调。\",\"368\":\"\",\"369\":\"**处理步骤**\",\"370\":\"\"}",
      "用户拒绝的修改": "2.闪控球停止后，停止无效。",
      "注意事项": "修复冗余表达时必须保留关键限定词（如\"再次\"），优先结合上下文确认删除后是否影响条件判断或导致多重解读，避免因过度简化破坏原句的排他性逻辑。"
    },
    {
      "defect_id": 544408,
      "sentence": "1.闪控球依赖的窗口异常，可能为空。",
      "reference_sentence": "",
      "line_num": 389,
      "context": "{\"384\":\"\",\"385\":\"闪控球内部错误。\",\"386\":\"\",\"387\":\"**可能原因**\",\"388\":\"\",\"389\":\"1.闪控球依赖的窗口异常，可能为空。\",\"390\":\"\",\"391\":\"2.闪控球控制器异常，可能是控制器为空。\",\"392\":\"\",\"393\":\"**处理步骤**\",\"394\":\"\"}",
      "用户拒绝的修改": "1.闪控球依赖的窗口异常。",
      "注意事项": "修复时必须区分冗余修饰与必要限定条件，技术文档中推测性描述（如\"可能为空\"）需保留以保持诊断完整性，删除前需结合上下文判断信息是否影响问题定位。"
    },
    {
      "defect_id": 544421,
      "sentence": "2.拉起非本应用的窗口。",
      "reference_sentence": "",
      "line_num": 463,
      "context": "{\"458\":\"\",\"459\":\"1.传入参数有误。\",\"460\":\"\",\"461\":\"2.点击后5秒内未拉起应用窗口。\",\"462\":\"\",\"463\":\"3.拉起非本应用的窗口。\",\"464\":\"\",\"465\":\"**处理步骤**\",\"466\":\"\",\"467\":\"1.检查应用窗口的拉起参数。\",\"468\":\"\"}",
      "用户拒绝的修改": "2.拉起非本应用窗口。",
      "注意事项": "在技术文档中优先保留行业术语和固定搭配，避免过度删除必要修饰词；修改前需结合上下文判断冗余成分是否影响表意准确性，保留用户认知习惯中的合理表达。"
    },
    {
      "defect_id": 545775,
      "sentence": "| callback | Callback&lt;void&gt; | 是 | 回调函数。当点击闪控球事件发生时的回调。该回调函数不返回任何参数。 |",
      "reference_sentence": "",
      "line_num": 343,
      "context": "{\"338\":\"**参数：**\",\"339\":\"\",\"340\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"341\":\"|------------|------------|------------|------------|\",\"342\":\"| type | string | 是 | 监听事件，固定为'click'，即闪控球点击的监听。 |\",\"343\":\"| callback | Callback&lt;void&gt; | 是 | 回调函数。当点击闪控球事件发生时的回调。该回调函数不返回任何参数。 |\",\"344\":\"\",\"345\":\"**错误码：**\",\"346\":\"\",\"347\":\"以下错误码的详细介绍请参见[窗口错误码](errorcode-window.md)。\",\"348\":\"\"}",
      "用户拒绝的修改": "| callback | Callback&lt;void&gt; | 是 | 回调函数，当点击闪控球事件发生时触发。该回调不返回任何参数。 |",
      "注意事项": "修复冗余表达时应优先关注语义重复而非单纯标点数量，确保修改后的语句在保持技术准确性的前提下精简重复词汇（如\"回调函数\"和\"回调\"），避免机械式拆分句子导致用户理解成本增加。"
    },
    {
      "defect_id": 551632,
      "sentence": "设置触摸事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3956,
      "context": "{\"3951\":\"void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)\",\"3952\":\"```\",\"3953\":\"\",\"3954\":\"**描述**\",\"3955\":\"\",\"3956\":\"设置触摸事件的触摸位置距离主屏幕左上角的X坐标。\",\"3957\":\"\",\"3958\":\"**起始版本：** 20\",\"3959\":\"\",\"3960\":\"**参数：**\",\"3961\":\"\"}",
      "用户拒绝的修改": "设置触摸事件的触摸位置，使其距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应优先保持技术术语的简洁性和参数描述的完整性，避免强行拆分核心名词结构（如\"X坐标\"）；在补充主谓语时需确保不破坏原句的上下文关联性，尤其是函数参数说明场景下，通常允许省略主谓语直接使用名词短语。"
    },
    {
      "defect_id": 543135,
      "sentence": "napi_coerce_to_native_binding_object | 用于给ArkTS对象绑定回调和回调所需的参数，其作用是为了给ArkTS对象携带Native信息。 |",
      "reference_sentence": "",
      "line_num": 322,
      "context": "{\"317\":\"\",\"318\":\"### 接口描述\",\"319\":\"\",\"320\":\"| 接口 | 描述 |\",\"321\":\"| -------- | -------- |\",\"322\":\"| napi_coerce_to_native_binding_object | 用于给ArkTS对象绑定回调和回调所需的参数，其作用是为了给ArkTS对象携带Native信息。 |\",\"323\":\"\",\"324\":\"### 使用示例\",\"325\":\"\",\"326\":\"#### napi_coerce_to_native_binding_object\",\"327\":\"\"}",
      "用户拒绝的修改": "napi_coerce_to_native_binding_object | 用于给ArkTS对象绑定回调和参数，携带Native信息。 |",
      "注意事项": "保留必要技术限定词（如\"回调所需的参数\"），优先通过调整句式结构（如将\"其作用是为了\"改为\"使\"）而非直接删除关键信息来消除冗余，确保技术准确性不受损。"
    },
    {
      "defect_id": 543163,
      "sentence": "将指定优先级和入队方式的任务投递到ArkTS主线程。",
      "reference_sentence": "",
      "line_num": 752,
      "context": "{\"747\":\"\",\"748\":\"### 接口描述\",\"749\":\"\",\"750\":\"| 接口 | 描述 |\",\"751\":\"| -------- | -------- |\",\"752\":\"| napi_call_threadsafe_function_with_priority | 将指定优先级和入队方式的任务投递到ArkTS主线程。 |\",\"753\":\"\",\"754\":\"### 使用示例\",\"755\":\"\",\"756\":\"#### napi_call_threadsafe_function_with_priority\",\"757\":\"\"}",
      "用户拒绝的修改": "将指定优先级和入队方式的任务投递到ArkTS主线程的主体。",
      "注意事项": "修复时应优先保持技术文档的接口描述简洁性，避免在隐含主语明确（如接口本身即执行主体）时强行补全语法结构，需结合上下文判断是否需要显式主语。"
    },
    {
      "defect_id": 549526,
      "sentence": "调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。",
      "reference_sentence": "",
      "line_num": 9217,
      "context": "{\"9212\":\"> **说明：**\",\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9221\":\"\",\"9222\":\"**参数：**\"}",
      "用户拒绝的修改": "调用本接口后，启用页面加载快照检测及生成过渡帧，会产生一定的资源开销。",
      "注意事项": "在技术文档中需严格区分技术术语和冗余修饰语，保留关键操作动词（如\"计算\"）避免改变原意；修改前应结合上下文确认被删除成分是否属于特定功能的技术实现环节。"
    },
    {
      "defect_id": 551631,
      "sentence": "使用全局坐标注入触摸事件。",
      "reference_sentence": "",
      "line_num": 3932,
      "context": "{\"3927\":\"int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)\",\"3928\":\"```\",\"3929\":\"\",\"3930\":\"**描述**\",\"3931\":\"\",\"3932\":\"使用全局坐标注入触摸事件。\",\"3933\":\"\",\"3934\":\"**起始版本：** 20\",\"3935\":\"\",\"3936\":\"**参数：**\",\"3937\":\"\"}",
      "用户拒绝的修改": "该函数使用全局坐标注入触摸事件。",
      "注意事项": "修复时应优先保持技术文档的简洁性，在上下文已明确主语（如函数名）的情况下，避免机械补充语法成分导致冗余；需区分完整句子与文档片段的使用场景，遵循领域特定写作规范。"
    },
    {
      "defect_id": 543102,
      "sentence": "| napi_load_module | 用于在Node-API模块中将abc文件作为模块加载，返回模块的命名空间，适用于需要在运行时动态加载模块或资源的应用程序，从而实现灵活的扩展和定制。 |",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"### 接口描述\",\"12\":\"\",\"13\":\"| 接口 | 描述 |\",\"14\":\"| -------- | -------- |\",\"15\":\"| napi_load_module | 用于在Node-API模块中将abc文件作为模块加载，返回模块的命名空间，适用于需要在运行时动态加载模块或资源的应用程序，从而实现灵活的扩展和定制。 |\",\"16\":\"| napi_load_module_with_info | 用于在Node-API中进行模块的加载，当模块加载出来之后，可以使用函数napi_get_property获取模块导出的变量，也可以使用napi_get_named_property获取模块导出的函数，该函数可以在[新创建的ArkTS基础运行时环境](use-napi-ark-runtime.md)中使用。 |\",\"17\":\"| napi_module_register | 有些功能可能需要通过Node-API模块来实现以获得更好的性能，通过将这些功能实现为自定义模块并注册到ArkTS环境中，可以在一定程度上提高整体的性能。 |\",\"18\":\"\",\"19\":\"### 使用示例\",\"20\":\"\"}",
      "用户拒绝的修改": "| napi_load_module | 用于在Node-API模块中加载abc文件，返回模块的命名空间。适用于需要在运行时动态加载模块或资源的应用程序。 |",
      "注意事项": "避免机械拆分导致信息重复，需确保修复后的短句在语义上独立且互补；同时需结合上下文检查相邻条目是否存在重复表述，保持全局一致性。"
    },
    {
      "defect_id": 551626,
      "sentence": "通过全局坐标注入鼠标事件。",
      "reference_sentence": "",
      "line_num": 3823,
      "context": "{\"3818\":\"int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)\",\"3819\":\"```\",\"3820\":\"\",\"3821\":\"**描述**\",\"3822\":\"\",\"3823\":\"通过全局坐标注入鼠标事件。\",\"3824\":\"\",\"3825\":\"**起始版本：** 20\",\"3826\":\"\",\"3827\":\"**参数：**\",\"3828\":\"\"}",
      "用户拒绝的修改": "该函数通过全局坐标注入鼠标事件。",
      "注意事项": "补充主语时应优先使用上下文明确的主体（如函数名称或功能主体），避免使用模糊指代；确保谓语动词与上下文逻辑匹配，在技术文档中优先采用\"实现/提供/执行+功能描述\"的主动结构。 \n\n示例正确修复：\"OH_Input_InjectMouseEventGlobal函数通过全局坐标实现鼠标事件注入\" 或 \"该接口用于注入基于全局坐标的鼠标事件\"。"
    },
    {
      "defect_id": 551628,
      "sentence": "查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3865,
      "context": "{\"3860\":\"int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)\",\"3861\":\"```\",\"3862\":\"\",\"3863\":\"**描述**\",\"3864\":\"\",\"3865\":\"查询鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。\",\"3866\":\"\",\"3867\":\"**起始版本：** 20\",\"3868\":\"\",\"3869\":\"**参数：**\",\"3870\":\"\"}",
      "用户拒绝的修改": "此函数查询鼠标事件中鼠标光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应优先保持API文档的语法惯例（动词开头的无主语句式），避免机械添加主语导致上下文重复冗余，同时需准确识别句子在文档结构中的定位属性（如参数/返回值/功能描述）。"
    },
    {
      "defect_id": 551629,
      "sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 3889,
      "context": "{\"3884\":\"void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)\",\"3885\":\"```\",\"3886\":\"\",\"3887\":\"**描述**\",\"3888\":\"\",\"3889\":\"设置鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。\",\"3890\":\"\",\"3891\":\"**起始版本：** 20\",\"3892\":\"\",\"3893\":\"**参数：**\",\"3894\":\"\"}",
      "用户拒绝的修改": "设置鼠标事件的光标位置，使其距离主屏幕左上角的Y坐标为指定值。",
      "注意事项": "修复冗余表达时需优先保留技术文档的核心参数名称（如\"globalY\"），避免过度简化导致术语不一致；确保句法调整后仍能准确映射到代码上下文（如函数参数），维持技术描述的精确性和可追溯性。"
    },
    {
      "defect_id": 543133,
      "sentence": "napi_queue_async_work_with_qos | 用于将异步工作对象加入队列，让开发者能够根据QoS优先级来管理和调度异步工作的执行，从而更好地满足程序的性能和响应需求。 |",
      "reference_sentence": "",
      "line_num": 304,
      "context": "{\"299\":\"\",\"300\":\"### 接口描述\",\"301\":\"\",\"302\":\"| 接口 | 描述 |\",\"303\":\"| -------- | -------- |\",\"304\":\"| napi_queue_async_work_with_qos | 用于将异步工作对象加入队列，让开发者能够根据QoS优先级来管理和调度异步工作的执行，从而更好地满足程序的性能和响应需求。 |\",\"305\":\"\",\"306\":\"### 使用示例\",\"307\":\"\",\"308\":\"#### napi_queue_async_work_with_qos\",\"309\":\"\"}",
      "用户拒绝的修改": "napi_queue_async_work_with_qos | 将异步工作对象加入队列，按QoS优先级管理和调度，提升程序性能和响应。 |",
      "注意事项": "保留核心功能性描述（如\"用于\"等关键操作指引），避免过度删除开发者操作主体和接口用途说明，确保技术术语和用户指引的准确性。"
    },
    {
      "defect_id": 549524,
      "sentence": "持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。",
      "reference_sentence": "",
      "line_num": 9215,
      "context": "{\"9210\":\"获取页面首屏加载预测信息（详细说明见[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)），并开始本次加载过渡帧生成，应用根据此信息确定是否需要启用无白屏加载。必须与[setBlanklessLoadingWithKey](#setblanklessloadingwithkey20)接口配套使用，并且必须在触发加载页面的接口之前或在 `onLoadIntercept` 中调用。需在 `WebViewController` 与Web组件绑定后才能使用。\",\"9211\":\"\",\"9212\":\"> **说明：**\",\"9213\":\">\",\"9214\":\"> - 当前仅支持手机设备。\",\"9215\":\"> - 持久缓存容量：默认大小为30MB（约30页），可以通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置缓存容量，具体见该接口说明。超过容量时根据LRU（Least Recently Used，淘汰不常用缓存的策略）机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。\",\"9216\":\"> - 如果发现快照相似度（即[BlanklessInfo](./arkts-apis-webview-i.md#blanklessinfo20)中的similarity）极低，请确认key值是否传递正确。\",\"9217\":\"> - 调用本接口后，将启用页面加载快照检测及生成过渡帧计算，会产生一定的资源开销。\",\"9218\":\"> - 启用无白屏加载的页面会带来一定的资源开销，开销的大小与Web组件的分辨率相关。假设分辨率的宽度和高度分别为：w, h。页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9219\":\"\",\"9220\":\"**系统能力：** SystemCapability.Web.Webview.Core\"}",
      "用户拒绝的修改": "持久缓存容量默认为30MB（约30页），可通过[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)接口设置。超过容量时，根据LRU机制更新缓存。自动清理超过7天的持久缓存数据，缓存清除后第三次加载页面开始有优化效果。",
      "注意事项": "修复冗余表达时需优先保留关键术语的解释（如“LRU机制”）和必要操作指引（如“具体见该接口说明”），避免因过度简化导致技术信息缺失；应通过拆分长句而非直接删除技术细节来提升简洁性。"
    },
    {
      "defect_id": 551627,
      "sentence": "设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3846,
      "context": "{\"3841\":\"void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)\",\"3842\":\"```\",\"3843\":\"\",\"3844\":\"**描述**\",\"3845\":\"\",\"3846\":\"设置鼠标事件的鼠标光标位置距离主屏幕左上角的X坐标。\",\"3847\":\"\",\"3848\":\"**起始版本：** 20\",\"3849\":\"\",\"3850\":\"**参数：**\",\"3851\":\"\"}",
      "用户拒绝的修改": "该函数设置鼠标事件中鼠标光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应优先补全句子核心成分（主谓宾），避免机械添加冗余定语；技术文档需保持参数描述的简洁性，结合上下文确认主语是否已通过函数名隐含。"
    },
    {
      "defect_id": 551633,
      "sentence": "获取触摸事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3975,
      "context": "{\"3970\":\"int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)\",\"3971\":\"```\",\"3972\":\"\",\"3973\":\"**描述**\",\"3974\":\"\",\"3975\":\"获取触摸事件的触摸位置距离主屏幕左上角的X坐标。\",\"3976\":\"\",\"3977\":\"**起始版本：** 20\",\"3978\":\"\",\"3979\":\"**参数：**\",\"3980\":\"\"}",
      "用户拒绝的修改": "获取触摸事件的触摸位置与主屏幕左上角的X坐标距离。",
      "注意事项": "修复冗余表达时应优先保持原句的核心主谓结构和技术术语准确性，避免过度调整导致语义断裂；修改后需确保技术参数（如X坐标）的修饰关系清晰，避免将关键量词转化为抽象名词造成理解障碍。"
    },
    {
      "defect_id": 551630,
      "sentence": "获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 3908,
      "context": "{\"3903\":\"int32_t OH_Input_GetMouseEventGlobalY(const struct Input_MouseEvent* mouseEvent)\",\"3904\":\"```\",\"3905\":\"\",\"3906\":\"**描述**\",\"3907\":\"\",\"3908\":\"获取鼠标事件的鼠标光标位置距离主屏幕左上角的Y坐标。\",\"3909\":\"\",\"3910\":\"**起始版本：** 20\",\"3911\":\"\",\"3912\":\"**参数：**\",\"3913\":\"\"}",
      "用户拒绝的修改": "获取鼠标事件中鼠标光标距离主屏幕左上角的Y坐标。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的核心术语（如“位置”），避免因过度简化导致关键信息丢失；需结合上下文确保修改后的句子在技术准确性、语法完整性和用户理解度之间取得平衡。"
    },
    {
      "defect_id": 551634,
      "sentence": "设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 3999,
      "context": "{\"3994\":\"void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)\",\"3995\":\"```\",\"3996\":\"\",\"3997\":\"**描述**\",\"3998\":\"\",\"3999\":\"设置触摸事件的触摸位置距离主屏幕左上角的Y坐标。\",\"4000\":\"\",\"4001\":\"**起始版本：** 20\",\"4002\":\"\",\"4003\":\"**参数：**\",\"4004\":\"\"}",
      "用户拒绝的修改": "设置触摸事件的触摸位置，使其距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应优先保留技术术语的准确性和上下文连贯性，避免机械补全语法结构导致语义断裂；修改后需确保句子符合领域规范（如函数描述常用\"设置XX参数的YY值\"句式），而非强行添加冗余代词或谓语。"
    },
    {
      "defect_id": 552608,
      "sentence": "Called from Non-System applications. Return by promise.",
      "reference_sentence": "",
      "line_num": 189,
      "context": "{\"184\":\"**错误码：**\",\"185\":\"\",\"186\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)和[媒体错误码](errorcode-media.md)\",\"187\":\"| 错误码ID | 错误信息                                    |\",\"188\":\"| -------- | ------------------------------------------- |\",\"189\":\"| 202      | Called from Non-System applications. Return by promise.               |\",\"190\":\"| 5400109  | Sessions not exist. Return by promise.               |\",\"191\":\"\",\"192\":\"**示例：**\",\"193\":\"\",\"194\":\"```ts\"}",
      "用户拒绝的修改": "Called from Non-System applications. Returns a promise.",
      "注意事项": "修复冗余表达时必须优先保持技术文档的术语一致性，错误信息等规范内容应严格遵循原文格式；拆分句子前需确认上下文是否存在统一句式模板，避免破坏错误码表格的结构化呈现。"
    },
    {
      "defect_id": 556467,
      "sentence": "使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "reference_sentence": "",
      "line_num": 3964,
      "context": "{\"3959\":\"\",\"3960\":\"**参数：**\",\"3961\":\"\",\"3962\":\"| 参数项 | 描述 |\",\"3963\":\"| -- | -- |\",\"3964\":\"| const struct [Input_TouchEvent](capi-input-input-touchevent.md)* touchEvent | 触屏事件对象，通过[OH_Input_CreateTouchEvent](#oh_input_createtouchevent)接口可以创建触屏事件对象。<br>使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。 | \",\"3965\":\"| int32_t globalX | 触摸位置距离主屏幕左上角的X坐标。 |\",\"3966\":\"\",\"3967\":\"### OH_Input_GetTouchEventGlobalX()\",\"3968\":\"\",\"3969\":\"```\"}",
      "用户拒绝的修改": "使用完毕后，需调用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "注意事项": "修复冗余表达时应优先保留技术文档中已确立的术语（如\"使用接口\"而非\"调用接口\"），并确保修改后的表述与上下文风格及用户习惯保持一致。"
    },
    {
      "defect_id": 552609,
      "sentence": "Sessions not exist. Return by promise.",
      "reference_sentence": "",
      "line_num": 190,
      "context": "{\"185\":\"\",\"186\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)和[媒体错误码](errorcode-media.md)\",\"187\":\"| 错误码ID | 错误信息                                    |\",\"188\":\"| -------- | ------------------------------------------- |\",\"189\":\"| 202      | Called from Non-System applications. Return by promise.               |\",\"190\":\"| 5400109  | Sessions not exist. Return by promise.               |\",\"191\":\"\",\"192\":\"**示例：**\",\"193\":\"\",\"194\":\"```ts\",\"195\":\"import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "用户拒绝的修改": "Sessions do not exist. Return by promise.",
      "注意事项": "在修复技术文档（如错误码说明）时，优先保留原始错误信息的固定格式和术语表述，避免修改系统级错误提示的固有表达方式；拆分句子前需确认上下文是否为代码/接口规范等需要严格保持原样的技术内容。"
    },
    {
      "defect_id": 551639,
      "sentence": "获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 4117,
      "context": "{\"4112\":\"Input_Result OH_Input_GetAxisEventGlobalY(const Input_AxisEvent* axisEvent, int32_t* globalY)\",\"4113\":\"```\",\"4114\":\"\",\"4115\":\"**描述**\",\"4116\":\"\",\"4117\":\"获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。\",\"4118\":\"\",\"4119\":\"**起始版本：** 20\",\"4120\":\"\",\"4121\":\"**参数：**\",\"4122\":\"\"}",
      "用户拒绝的修改": "该函数获取轴事件的触屏或鼠标光标位置距离主屏幕左上角的Y坐标。",
      "注意事项": "在技术文档语境中优先保持简洁的动宾结构，避免在函数描述等上下文明确的位置强行补全主谓成分；需区分语法完整性和文档惯例，遵循API描述常用省略句式规范。"
    },
    {
      "defect_id": 551635,
      "sentence": "获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 4018,
      "context": "{\"4013\":\"int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)\",\"4014\":\"```\",\"4015\":\"\",\"4016\":\"**描述**\",\"4017\":\"\",\"4018\":\"获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。\",\"4019\":\"\",\"4020\":\"**起始版本：** 20\",\"4021\":\"\",\"4022\":\"**参数：**\",\"4023\":\"\"}",
      "用户拒绝的修改": "此函数获取触摸事件的触摸位置距离主屏幕左上角的Y坐标。",
      "注意事项": "保持技术文档的简洁性，在函数描述中优先使用动宾短语而非完整句式；避免添加冗余主语（如\"此函数\"），需结合上下文判断函数名是否已隐含动作主体。"
    },
    {
      "defect_id": 552602,
      "sentence": "此接口仅提供给创建弹窗的系统应用调用。",
      "reference_sentence": "",
      "line_num": 166,
      "context": "{\"161\":\"\",\"162\":\"从服务器获取用户可以更改的系统隐私保护和应用隐私保护配置。使用Promise异步回调。\",\"163\":\"\",\"164\":\">**注意：**\",\"165\":\">\",\"166\":\"> 此接口仅提供给创建弹窗的系统应用调用。\",\"167\":\"\",\"168\":\"**系统接口：** 该接口为系统接口\",\"169\":\"\",\"170\":\"**系统能力：** SystemCapability.Multimedia.Media.AVScreenCapture\",\"171\":\"\"}",
      "用户拒绝的修改": "此接口仅限系统应用调用。",
      "注意事项": "在简化冗余表达时必须保留关键限定词（如“创建弹窗的”），避免丢失技术场景的精确性；优先确保技术文档的准确性，再考虑句式简洁性。"
    },
    {
      "defect_id": 556464,
      "sentence": "使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "reference_sentence": "",
      "line_num": 3897,
      "context": "{\"3892\":\"\",\"3893\":\"**参数：**\",\"3894\":\"\",\"3895\":\"| 参数项 | 描述 |\",\"3896\":\"| -- | -- |\",\"3897\":\"| const struct [Input_MouseEvent](capi-input-input-mouseevent.md)* mouseEvent | 鼠标事件对象，通过[OH_Input_CreateMouseEvent](#oh_input_createmouseevent)接口可以创建鼠标事件对象。<br>使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。 |\",\"3898\":\"| int32_t globalY | 鼠标光标位置距离主屏幕左上角的Y坐标。 |\",\"3899\":\"\",\"3900\":\"### OH_Input_GetMouseEventGlobalY()\",\"3901\":\"\",\"3902\":\"```\"}",
      "用户拒绝的修改": "使用后需调用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "注意事项": "修复冗余表达时应优先保留技术文档中的固定术语（如\"使用\"在接口操作中的惯用表述），避免因替换近义词破坏技术准确性；需结合上下文判断修饰成分是否承担明确语义功能，不可机械简化。"
    },
    {
      "defect_id": 556466,
      "sentence": "使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "reference_sentence": "",
      "line_num": 3940,
      "context": "{\"3935\":\"\",\"3936\":\"**参数：**\",\"3937\":\"\",\"3938\":\"| 参数项 | 描述 |\",\"3939\":\"| -- | -- |\",\"3940\":\"| const struct [Input_TouchEvent](capi-input-input-touchevent.md)* touchEvent | 触屏事件对象，通过[OH_Input_CreateTouchEvent](#oh_input_createtouchevent)接口可以创建触屏事件对象。<br>使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。 | \",\"3941\":\"\",\"3942\":\"**返回：**\",\"3943\":\"\",\"3944\":\"| 类型 | 说明 |\",\"3945\":\"| -- | -- |\"}",
      "用户拒绝的修改": "使用完需调用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)销毁触屏事件对象。",
      "注意事项": "在简化冗余表达时需优先保留技术文档中的核心术语（如\"接口\"），避免因过度简化破坏上下文术语一致性或关键信息完整性。"
    },
    {
      "defect_id": 556468,
      "sentence": "使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "reference_sentence": "",
      "line_num": 3983,
      "context": "{\"3978\":\"\",\"3979\":\"**参数：**\",\"3980\":\"\",\"3981\":\"| 参数项 | 描述 |\",\"3982\":\"| -- | -- |\",\"3983\":\"| const struct [Input_TouchEvent](capi-input-input-touchevent.md)* touchEvent | 触屏事件对象，通过[OH_Input_CreateTouchEvent](#oh_input_createtouchevent)接口可以创建触屏事件对象。<br>使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。 | \",\"3984\":\"\",\"3985\":\"**返回：**\",\"3986\":\"\",\"3987\":\"| 类型 | 说明 |\",\"3988\":\"| -- | -- |\"}",
      "用户拒绝的修改": "使用完需调用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)销毁触屏事件对象。",
      "注意事项": "修复冗余表达时需优先保留技术文档中已明确定义的接口名称（如\"接口销毁触屏事件对象\"），避免过度简化导致术语准确性丢失；修改前应结合上下文确认用户是否将特定动词（如\"使用\"）作为固定搭配使用。"
    },
    {
      "defect_id": 551637,
      "sentence": "获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 4067,
      "context": "{\"4062\":\"Input_Result OH_Input_GetAxisEventGlobalX(const Input_AxisEvent* axisEvent, int32_t* globalX)\",\"4063\":\"```\",\"4064\":\"\",\"4065\":\"**描述**\",\"4066\":\"\",\"4067\":\"获取轴事件的触屏/鼠标光标位置距离主屏幕左上角的X坐标。\",\"4068\":\"\",\"4069\":\"**起始版本：** 20\",\"4070\":\"\",\"4071\":\"**参数：**\",\"4072\":\"\"}",
      "用户拒绝的修改": "该函数获取轴事件的触屏或鼠标光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应保留技术文档的专业表述习惯，在函数描述场景中允许省略主语（函数名），避免添加\"该函数\"等冗余成分破坏原有语境完整性；需结合代码注释的文体特征，优先确保术语准确性和行业通用性，而非过度追求语法完整性。"
    },
    {
      "defect_id": 556462,
      "sentence": "使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "reference_sentence": "",
      "line_num": 3854,
      "context": "{\"3849\":\"\",\"3850\":\"**参数：**\",\"3851\":\"\",\"3852\":\"| 参数项 | 描述 |\",\"3853\":\"| -- | -- |\",\"3854\":\"| const struct [Input_MouseEvent](capi-input-input-mouseevent.md)* mouseEvent | 鼠标事件对象，通过[OH_Input_CreateMouseEvent](#oh_input_createmouseevent)接口可以创建鼠标事件对象。<br>使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。 |\",\"3855\":\"| int32_t globalX | 鼠标光标位置距离主屏幕左上角的X坐标。 |\",\"3856\":\"\",\"3857\":\"### OH_Input_GetMouseEventGlobalX()\",\"3858\":\"\",\"3859\":\"```\"}",
      "用户拒绝的修改": "使用完毕后需调用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "注意事项": "修复冗余表达时应优先保持技术术语的上下文一致性，避免因替换同义词破坏原有接口调用关系的准确性；需结合文档整体风格判断\"冗余\"边界，技术文档中必要的操作动词（如\"调用\"）不宜过度简化。"
    },
    {
      "defect_id": 556465,
      "sentence": "使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "reference_sentence": "",
      "line_num": 3916,
      "context": "{\"3911\":\"\",\"3912\":\"**参数：**\",\"3913\":\"\",\"3914\":\"| 参数项 | 描述 |\",\"3915\":\"| -- | -- |\",\"3916\":\"| const struct [Input_MouseEvent](capi-input-input-mouseevent.md)* mouseEvent | 鼠标事件对象，通过[OH_Input_CreateMouseEvent](#oh_input_createmouseevent)接口可以创建鼠标事件对象。<br>使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。 | \",\"3917\":\"\",\"3918\":\"**返回：**\",\"3919\":\"\",\"3920\":\"| 类型 | 说明 |\",\"3921\":\"| -- | -- |\"}",
      "用户拒绝的修改": "使用后需调用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "注意事项": "在简化冗余表达时需优先保留技术术语的准确性，避免替换与上下文一致的动词（如\"使用\"改为\"调用\"可能改变技术动作描述），同时应区分时间状态词（如\"使用完\"强调动作完成阶段，不宜简化为\"使用后\"）。"
    },
    {
      "defect_id": 556469,
      "sentence": "使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "reference_sentence": "",
      "line_num": 4007,
      "context": "{\"4002\":\"\",\"4003\":\"**参数：**\",\"4004\":\"\",\"4005\":\"| 参数项 | 描述 |\",\"4006\":\"| -- | -- |\",\"4007\":\"| const struct [Input_TouchEvent](capi-input-input-touchevent.md)* touchEvent | 触屏事件对象，通过[OH_Input_CreateTouchEvent](#oh_input_createtouchevent)接口可以创建触屏事件对象。<br>使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。 | \",\"4008\":\"| int32_t globalY | 触摸位置距离主屏幕左上角的Y坐标。 |\",\"4009\":\"\",\"4010\":\"### OH_Input_GetTouchEventGlobalY()\",\"4011\":\"\",\"4012\":\"```\"}",
      "用户拒绝的修改": "使用后需调用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "注意事项": "修复冗余表达时应优先确保技术术语的准确性和上下文一致性，避免过度简化导致关键动作（如“使用”与“调用”）或时序逻辑（如“使用完”隐含的操作完成状态）的语义偏差。"
    },
    {
      "defect_id": 551638,
      "sentence": "设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 4092,
      "context": "{\"4087\":\"Input_Result OH_Input_SetAxisEventGlobalY(struct Input_AxisEvent* axisEvent, int32_t globalY)\",\"4088\":\"```\",\"4089\":\"\",\"4090\":\"**描述**\",\"4091\":\"\",\"4092\":\"设置轴事件的触屏/鼠标光标位置距离主屏幕左上角的Y坐标。\",\"4093\":\"\",\"4094\":\"**起始版本：** 20\",\"4095\":\"\",\"4096\":\"**参数：**\",\"4097\":\"\"}",
      "用户拒绝的修改": "设置轴事件的触屏或鼠标光标位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复冗余表达时应优先保持技术文档惯用符号（如\"/\"）的专业性，避免机械替换为自然语言连接词；同时需确保语法结构完整，必要时补充主语或调整句式而非仅修改连接方式。"
    },
    {
      "defect_id": 556771,
      "sentence": "使用全局坐标注入鼠标事件。",
      "reference_sentence": "",
      "line_num": 3823,
      "context": "{\"3818\":\"int32_t OH_Input_InjectMouseEventGlobal(const struct Input_MouseEvent* mouseEvent)\",\"3819\":\"```\",\"3820\":\"\",\"3821\":\"**描述**\",\"3822\":\"\",\"3823\":\"使用全局坐标注入鼠标事件。\",\"3824\":\"\",\"3825\":\"**起始版本：** 20\",\"3826\":\"\",\"3827\":\"**参数：**\",\"3828\":\"\"}",
      "用户拒绝的修改": "该函数使用全局坐标注入鼠标事件。",
      "注意事项": "保留技术文档特有的简洁表达惯例（如动宾结构），在上下文已明确主语的情况下避免机械补充主谓宾结构，优先维护专业领域惯用表述的连贯性。"
    },
    {
      "defect_id": 556463,
      "sentence": "使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "reference_sentence": "",
      "line_num": 3873,
      "context": "{\"3868\":\"\",\"3869\":\"**参数：**\",\"3870\":\"\",\"3871\":\"| 参数项 | 描述 |\",\"3872\":\"| -- | -- |\",\"3873\":\"| const struct [Input_MouseEvent](capi-input-input-mouseevent.md)* mouseEvent | 鼠标事件对象，通过[OH_Input_CreateMouseEvent](#oh_input_createmouseevent)接口可以创建鼠标事件对象。<br>使用完需使用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。 | \",\"3874\":\"\",\"3875\":\"**返回：**\",\"3876\":\"\",\"3877\":\"| 类型 | 说明 |\",\"3878\":\"| -- | -- |\"}",
      "用户拒绝的修改": "使用后需调用[OH_Input_DestroyMouseEvent](#oh_input_destroymouseevent)接口销毁鼠标事件对象。",
      "注意事项": "修复冗余表达时应优先确保技术术语与上下文一致性，避免替换用户明确认可的专业动作描述（如\"使用接口\"）；保留必要的时间状态词（如\"使用完\"）以维持操作时序的准确性。"
    },
    {
      "defect_id": 556772,
      "sentence": "设置鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3846,
      "context": "{\"3841\":\"void OH_Input_SetMouseEventGlobalX(struct Input_MouseEvent* mouseEvent, int32_t globalX)\",\"3842\":\"```\",\"3843\":\"\",\"3844\":\"**描述**\",\"3845\":\"\",\"3846\":\"设置鼠标事件的光标位置距离主屏幕左上角的X坐标。\",\"3847\":\"\",\"3848\":\"**起始版本：** 20\",\"3849\":\"\",\"3850\":\"**参数：**\",\"3851\":\"\"}",
      "用户拒绝的修改": "该函数用于设置鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "保持技术文档的简洁性和上下文一致性，优先保留原句核心信息，避免强行补全主谓宾导致语义重复（如\"该函数用于\"在上下文明示函数作用时冗余）。"
    },
    {
      "defect_id": 556470,
      "sentence": "使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "reference_sentence": "",
      "line_num": 4026,
      "context": "{\"4021\":\"\",\"4022\":\"**参数：**\",\"4023\":\"\",\"4024\":\"| 参数项 | 描述 |\",\"4025\":\"| -- | -- |\",\"4026\":\"| const struct [Input_TouchEvent](capi-input-input-touchevent.md)* touchEvent | 触屏事件对象，通过[OH_Input_CreateTouchEvent](#oh_input_createtouchevent)接口可以创建触屏事件对象。<br>使用完需使用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。 | \",\"4027\":\"\",\"4028\":\"**返回：**\",\"4029\":\"\",\"4030\":\"| 类型 | 说明 |\",\"4031\":\"| -- | -- |\"}",
      "用户拒绝的修改": "使用后需调用[OH_Input_DestroyTouchEvent](#oh_input_destroytouchevent)接口销毁触屏事件对象。",
      "注意事项": "在简化冗余表达时应优先保留技术动作的准确性，避免替换关键动词（如\"使用\"→\"调用\"可能改变操作语义），并确保时间状语（如\"使用完\"→\"使用后\"）的修改不会弱化原句隐含的时序必要性。"
    },
    {
      "defect_id": 556773,
      "sentence": "获取鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3865,
      "context": "{\"3860\":\"int32_t OH_Input_GetMouseEventGlobalX(const struct Input_MouseEvent* mouseEvent)\",\"3861\":\"```\",\"3862\":\"\",\"3863\":\"**描述**\",\"3864\":\"\",\"3865\":\"获取鼠标事件的光标位置距离主屏幕左上角的X坐标。\",\"3866\":\"\",\"3867\":\"**起始版本：** 20\",\"3868\":\"\",\"3869\":\"**参数：**\",\"3870\":\"\"}",
      "用户拒绝的修改": "该函数用于获取鼠标事件的光标位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应优先保留技术文档特有的简洁动宾结构，避免过度补全主谓破坏领域表达惯例；需特别警惕\"获取/设置\"等高频API动词引导的短句，此类结构在技术文档中属于规范表达而非冗余。"
    },
    {
      "defect_id": 556774,
      "sentence": "设置鼠标事件的光标位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 3889,
      "context": "{\"3884\":\"void OH_Input_SetMouseEventGlobalY(struct Input_MouseEvent* mouseEvent, int32_t globalY)\",\"3885\":\"```\",\"3886\":\"\",\"3887\":\"**描述**\",\"3888\":\"\",\"3889\":\"设置鼠标事件的光标位置距离主屏幕左上角的Y坐标。\",\"3890\":\"\",\"3891\":\"**起始版本：** 20\",\"3892\":\"\",\"3893\":\"**参数：**\",\"3894\":\"\"}",
      "用户拒绝的修改": "该函数设置鼠标事件的光标位置距离主屏幕左上角的Y坐标。",
      "注意事项": "在技术文档场景中优先保留行业惯用的动宾结构描述方式，即使语法结构不完整也应尊重上下文隐含主语的专业表达习惯，避免机械补全主谓宾导致信息冗余。"
    },
    {
      "defect_id": 556775,
      "sentence": "使用全局坐标注入触屏事件。",
      "reference_sentence": "",
      "line_num": 3932,
      "context": "{\"3927\":\"int32_t OH_Input_InjectTouchEventGlobal(const struct Input_TouchEvent* touchEvent)\",\"3928\":\"```\",\"3929\":\"\",\"3930\":\"**描述**\",\"3931\":\"\",\"3932\":\"使用全局坐标注入触屏事件。\",\"3933\":\"\",\"3934\":\"**起始版本：** 20\",\"3935\":\"\",\"3936\":\"**参数：**\",\"3937\":\"\"}",
      "用户拒绝的修改": "该函数使用全局坐标注入触屏事件。",
      "注意事项": "修复时应优先保持技术文档的简洁性和上下文一致性，在函数描述等特定语境下允许无主语的短语结构，仅在句子确实存在歧义时补充主语。"
    },
    {
      "defect_id": 556776,
      "sentence": "设置触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3956,
      "context": "{\"3951\":\"void OH_Input_SetTouchEventGlobalX(struct Input_TouchEvent* touchEvent, int32_t globalX)\",\"3952\":\"```\",\"3953\":\"\",\"3954\":\"**描述**\",\"3955\":\"\",\"3956\":\"设置触屏事件的触摸位置距离主屏幕左上角的X坐标。\",\"3957\":\"\",\"3958\":\"**起始版本：** 20\",\"3959\":\"\",\"3960\":\"**参数：**\",\"3961\":\"\"}",
      "用户拒绝的修改": "设置触屏事件的触摸位置时，距离主屏幕左上角的X坐标。",
      "注意事项": "修复时应优先保留与API参数直接对应的核心动词（如\"设置X坐标\"），避免因过度拆分主谓结构导致技术术语断层；在技术文档场景下，准确性高于语法完整性，需确保修改后的句子仍能精准映射代码元素（如globalX参数）。"
    },
    {
      "defect_id": 556779,
      "sentence": "获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 4018,
      "context": "{\"4013\":\"int32_t OH_Input_GetTouchEventGlobalY(const struct Input_TouchEvent* touchEvent)\",\"4014\":\"```\",\"4015\":\"\",\"4016\":\"**描述**\",\"4017\":\"\",\"4018\":\"获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。\",\"4019\":\"\",\"4020\":\"**起始版本：** 20\",\"4021\":\"\",\"4022\":\"**参数：**\",\"4023\":\"\"}",
      "用户拒绝的修改": "该函数获取触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "注意事项": "修复时应优先保留技术文档的惯用动宾结构，避免强行补全主谓导致信息冗余；需结合上下文判断是否已通过函数名/类名隐含主语，确保修改后符合行业文档规范而非单纯语法完整。"
    },
    {
      "defect_id": 556778,
      "sentence": "设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "reference_sentence": "",
      "line_num": 3999,
      "context": "{\"3994\":\"void OH_Input_SetTouchEventGlobalY(struct Input_TouchEvent* touchEvent, int32_t globalY)\",\"3995\":\"```\",\"3996\":\"\",\"3997\":\"**描述**\",\"3998\":\"\",\"3999\":\"设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。\",\"4000\":\"\",\"4001\":\"**起始版本：** 20\",\"4002\":\"\",\"4003\":\"**参数：**\",\"4004\":\"\"}",
      "用户拒绝的修改": "该函数用于设置触屏事件的触摸位置距离主屏幕左上角的Y坐标。",
      "注意事项": "保持技术文档的简洁性，在上下文已明确函数用途时优先使用动宾结构（如\"设置X坐标\"），避免强行补全主谓宾导致语义重复；修复时应结合代码注释的行业惯例，确保修改后的表达既符合语法规范又适配技术文档特有的精简风格。"
    },
    {
      "defect_id": 556777,
      "sentence": "获取触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "reference_sentence": "",
      "line_num": 3975,
      "context": "{\"3970\":\"int32_t OH_Input_GetTouchEventGlobalX(const struct Input_TouchEvent* touchEvent)\",\"3971\":\"```\",\"3972\":\"\",\"3973\":\"**描述**\",\"3974\":\"\",\"3975\":\"获取触屏事件的触摸位置距离主屏幕左上角的X坐标。\",\"3976\":\"\",\"3977\":\"**起始版本：** 20\",\"3978\":\"\",\"3979\":\"**参数：**\",\"3980\":\"\"}",
      "用户拒绝的修改": "该函数获取触屏事件的触摸位置距离主屏幕左上角的X坐标。",
      "注意事项": "修复冗余表达时需优先保留技术文档的简洁性惯例，在上下文已明确主语（如函数描述场景）时允许省略主谓结构，避免过度补全语法成分导致信息重复。"
    },
    {
      "defect_id": 557052,
      "sentence": "默认构造函数创建一个异步锁。",
      "reference_sentence": "",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"#### constructor\",\"135\":\"\",\"136\":\"constructor()\",\"137\":\"\",\"138\":\"默认构造函数创建一个异步锁。\",\"139\":\"\",\"140\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"141\":\"\",\"142\":\"**系统能力：** SystemCapability.Utils.Lang\",\"143\":\"\"}",
      "用户拒绝的修改": "构造函数创建一个异步锁。",
      "注意事项": "修复冗余表达时必须保留关键限定词（如“默认”），避免因过度简化而改变技术含义；修改后需结合上下文验证术语准确性，确保不破坏原有功能描述。"
    },
    {
      "defect_id": 557877,
      "sentence": "记录动效场景开始前，用户输入触发事件类型与时间。",
      "reference_sentence": "",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"## performanceMonitor.recordInputEventTime<sup>12+</sup>\",\"93\":\"\",\"94\":\"recordInputEventTime(type: ActionType, sourceType: SourceType, time: number): void\",\"95\":\"\",\"96\":\"记录动效场景开始前，用户输入触发事件类型与时间。\",\"97\":\"\",\"98\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"99\":\"\",\"100\":\"**参数：**\",\"101\":\"| 参数名 | 类型 | 必填 | 说明 |\"}",
      "用户拒绝的修改": "记录用户输入的事件类型与时间。",
      "注意事项": "在删除修饰成分前需严格评估其技术必要性，结合上下文判断是否属于关键限定条件（如时间点、场景前提），避免因过度简化导致语义模糊或功能描述不准确。"
    }
  ],
  "反面示例": [
    {
      "defect_id": 1965,
      "sentence": "即align属性中Alignment.TopStart、Alignment.Top、Alignment.TopEnd效果相同，控制内容在顶部，Alignment.Start、Alignment.Center、Alignment.End效果相同，控制内容垂直居中，Alignment.BottomStart、Alignment.Bottom、Alignment.BottomEnd效果相同，控制内容在底部。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "",
      "修改建议": "重复描述了多个属性的效果，可以简化",
      "更改后示例": "即align属性中的Alignment.TopStart、Alignment.Top、Alignment.TopEnd均控制内容在顶部；Alignment.Start、Alignment.Center、Alignment.End均控制内容垂直居中；Alignment.BottomStart、Alignment.Bottom、Alignment.BottomEnd均控制内容在底部。",
      "触发条件": "当同一功能/效果被多个并列属性重复描述，且每个属性后跟随相同效果说明时触发。识别模式为存在多个\"属性A、属性B、属性C效果相同，控制内容在X位置\"的重复句式结构。"
    },
    {
      "defect_id": 13993,
      "sentence": "- 应用的全局配置信息，包含应用的Bundle名称、开发厂商、版本号等基本信息。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "- 应用的全局配置信息，包括Bundle名称、开发厂商、版本号。",
      "触发条件": "当句子在列举后使用冗余的总结词（如“等基本信息”）或存在重复性说明（如“包含”与“等”语义叠加）时触发。识别模式需检测“包含/包括...等+重复性抽象名词”结构，并判断总结词是否未提供额外信息。"
    },
    {
      "defect_id": 18829,
      "sentence": "在应用module.json5文件中配置metadata指向快捷方式的配置文件。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "",
      "修改建议": "包含无意义的词语。",
      "更改后示例": "在module.json5文件中配置metadata指向快捷方式文件。",
      "触发条件": "检测到名词前存在冗余限定词（如上下文已明确的“应用”）或重复修饰成分（如“配置文件”中的“配置”与“文件”语义重叠）。\n\n识别模式：  \n1. **冗余限定词**：当名词本身已隐含上下文信息（如module.json5文件默认属于应用），额外添加“应用”等限定词时触发。  \n2. **重复修饰**：当“的”字结构（如“快捷方式的配置”）中修饰语与核心词存在语义重复（配置→文件）时触发。"
    },
    {
      "defect_id": 13975,
      "sentence": "开发者将应用上架应用市场后，终端设备用户可以在终端设备上使用应用市场进行应用的安装和卸载。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "开发者上架应用后，终端用户使用应用市场安装和卸载应用。",
      "触发条件": "当句子出现重复修饰成分（如\"终端设备用户\"中的设备）、上下文已明确的冗余信息（如重复提及\"应用市场\"）、或存在可简化的动词结构（如\"进行...的安装和卸载\"）时触发。\n\n识别模式：\n1. 检查名词前是否有同义/重复修饰词（如\"终端设备\"→\"终端\"）\n2. 验证介词结构是否传递冗余信息（如\"将应用上架应用市场\"→\"上架应用\"）\n3. 发现\"进行+动名词\"等间接表达时（如\"进行安装\"→\"安装\"）\n4. 上下文已包含的信息重复出现（如前后两次出现\"应用市场\"）"
    },
    {
      "defect_id": 12984,
      "sentence": "HSP不支持在设备上单独安装/运行，需要与依赖该HSP的HAP一起安装/运行。HAP的版本号须大于等于HSP版本号。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "",
      "修改建议": "句子过长，信息量大。",
      "更改后示例": "HSP不支持单独安装/运行，需与HAP一起安装/运行。HAP版本号须大于等于HSP版本号。",
      "触发条件": "同一句子中重复使用相同/近义动词短语（如\"安装/运行\"连续出现），或存在可删除而不影响技术准确性的修饰语（如\"在设备上\"\"依赖该HSP的\"）。  \n\n识别模式：  \n1. 动词短语重复：检查连续出现的\"动词/动词\"结构是否可合并  \n2. 冗余限定词：验证介词短语（如\"在...上\"）、定语从句（如\"依赖该HSP的\"）是否必要  \n3. 信息密度检测：当单句超过25字且含多个技术术语时，触发冗余审查"
    },
    {
      "defect_id": 22039,
      "sentence": "待计算哈希值文件的应用沙箱路径。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "文件的应用沙箱路径。",
      "触发条件": "名词短语中存在多个前置修饰语且上下文已隐含部分信息时，或修饰成分与核心名词构成重复性技术术语时。\n\n识别模式：当名词中心语（如\"路径\"）被两个及以上技术性定语（如\"待计算哈希值文件的应用沙箱\"）修饰，且通过上下文/领域知识可推断出部分修饰语属于固有属性（如\"应用沙箱路径\"本身已隐含文件存储位置特性）时，判定存在冗余修饰。"
    },
    {
      "defect_id": 17663,
      "sentence": "每个应用项目必须在项目的代码目录下加入配置文件，这些配置文件会向编译工具、操作系统和应用市场提供描述应用的基本信息。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "",
      "修改建议": "句子过长，包含多个并列信息，可以拆分。",
      "更改后示例": "每个应用项目必须在代码目录下添加配置文件。配置文件提供应用的基本信息，用于编译工具、操作系统和应用市场。",
      "触发条件": "句子包含多个并列信息点或重复指代（如代词复指前文主语），导致结构冗余或信息密度过高。具体表现为长句内存在逗号分隔的补充说明，且后半句主语与前文重复。"
    },
    {
      "defect_id": 13040,
      "sentence": "其中`router.pushUrl`方法的入参中`url`的内容为：",
      "reference_sentence": "",
      "line_num": 356,
      "context": "",
      "修改建议": "原文有冗余信息。",
      "更改后示例": "`router.pushUrl`方法的`url`参数内容为：",
      "触发条件": "句子中存在明确提及方法参数时仍使用冗余修饰词（如“的入参中”“的内容为”）或重复性上下文说明。\n\n识别模式：检测到“的入参中[参数名]”“[参数名]的内容为”等结构，且上下文已明确方法名与参数关系时，判定为冗余表达。"
    },
    {
      "defect_id": 18828,
      "sentence": "开发者若要配置静态快捷方式，可以在某个模块的/resources/base/profile/目录下配置[快捷方式的配置文件](module-configuration-file.md#shortcuts标签)，如shortcuts_config.json。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "",
      "修改建议": "包含无意义的词语。",
      "更改后示例": "在模块的/resources/base/profile/目录下配置快捷方式文件，如shortcuts_config.json。",
      "触发条件": "当名词短语中包含与上下文动词重复的动作描述（如\"配置\"+\"配置文件\"），或存在不必要的不确定限定词（如\"某个\"）时触发。识别模式为：检查\"动词+的+名词\"结构中是否出现动词词根重复（如\"配置\"与\"配置文件\"），以及是否存在模糊指代词（如\"某个\"\"该\"等上下文已明确的限定词）。"
    },
    {
      "defect_id": 11717,
      "sentence": "6. 错误码请参见[WIFI错误码](../../reference/apis-connectivity-kit/errorcode-wifi.md)。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "",
      "修改建议": "句子简洁但可以更直接。",
      "更改后示例": "错误码参见[WIFI错误码](../../reference/apis-connectivity-kit/errorcode-wifi.md)。",
      "触发条件": "检测到句子中存在\"请+参见/参阅\"等冗余礼貌用语与引用动词连用结构，且上下文不需要特别强调礼貌请求时。"
    },
    {
      "defect_id": 13978,
      "sentence": "新版本应用通过应用市场上架后，应用市场通知终端用户该应用有新版本，终端用户可以根据通知到应用市场（客户端）进行应用升级。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "新版本应用上架后，应用市场通知终端用户，用户可在应用市场升级应用。",
      "触发条件": "同一名词或短语在相邻分句中重复出现，或存在可合并、简化的介词结构、修饰成分（如括号补充）。识别时需检查是否通过上下文隐含信息可删除重复指代，或替换为代词/更简洁表达。"
    },
    {
      "defect_id": 3040,
      "sentence": "全局HTTP代理的主机名和端口号。主机名和端口号由冒号':'分隔。",
      "reference_sentence": "",
      "line_num": 123,
      "context": "",
      "修改建议": "解释重复且冗余",
      "更改后示例": "全局HTTP代理的主机名和端口号，格式为：主机名:端口号。",
      "触发条件": "当相邻语句重复同一名词短语，且后续语句仅通过语法结构解释其组合方式时触发。\n\n具体识别模式：\n1. 前句包含\"A和B\"结构（如\"主机名和端口号\"）\n2. 后句重复\"A和B\"并附加格式说明（如\"由冒号分隔\"）\n3. 前后句未提供新信息增量，仅重复解释同一概念\n4. 可通过合并为\"格式为：A:B\"的简洁表达替代\n\n关键判断点：是否存在\"概念重复解释\"而非\"信息增量补充\"，当格式说明可被结构化符号替代时即构成冗余。"
    },
    {
      "defect_id": 19935,
      "sentence": "在成功连接服务后，可以通过onConnect回调拿到服务端的代理对象proxy，通过proxy可以发送信息给服务端。 客户端在onConnect回调里接收到代理对象，调用proxy对象的[sendMessageRequest](../reference/apis-ipc-kit/js-apis-rpc.md#sendmessagerequest9-2)方法发起请求给服务端，等服务端处理请求并返回数据时，可在期约（用于表示一个异步操作的成功/失败的结果值）里接收结果。",
      "reference_sentence": "",
      "line_num": 155,
      "context": "",
      "修改建议": "包含多个信息点，句子过长。",
      "更改后示例": "连接成功后，通过onConnect回调获取proxy。客户端通过proxy的[sendMessageRequest]方法发送请求，服务端处理后返回结果，客户端在期约中接收。",
      "触发条件": "当相邻句子重复使用同一名词/短语（如\"proxy\"），或单个句子包含超过两个信息点导致结构臃肿时触发。识别模式为检测连续重复的关键词（如\"proxy\"出现3次）及长句拆分需求（如原句54字分拆为两短句）。"
    },
    {
      "defect_id": 13992,
      "sentence": "[app.json5配置文件](app-configuration-file.md)主要包含以下内容：",
      "reference_sentence": "",
      "line_num": 10,
      "context": "",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "[app.json5配置文件](app-configuration-file.md)包含以下内容：",
      "触发条件": "句子中同时存在表示核心/关键内容的修饰词（如“主要”“关键”）与概括性结构（如“包含以下内容”“如下所示”），且修饰词未提供额外有效信息时触发。\n\n识别模式：检测“主要/关键 + 动词（包含/包括/涉及） + 概括性结构”的句式组合，若删除修饰词后语义完整度不变且更简洁，则判定为冗余表达。"
    },
    {
      "defect_id": 10159,
      "sentence": "注意，在实现耳返功能时，开发者需要同时控制录制流和播放流，保障二者的同步。",
      "reference_sentence": "",
      "line_num": 212,
      "context": "",
      "修改建议": "原文包含不必要的修饰词。",
      "更改后示例": "实现耳返功能时，开发者需同时控制录制流和播放流，确保同步。",
      "触发条件": "当句子中存在不影响核心信息的多余引导词（如“注意”）、重复动词结构（如“需要”+动词）或冗余修饰短语（如“二者的”）时触发。  \n\n识别模式：  \n1. **引导词冗余**：句首出现非必要提示词（如“注意”“请确保”），删除后不影响技术逻辑；  \n2. **动词重复**：动词短语含重复语义（如“需要控制”可简化为“控制”）；  \n3. **修饰冗余**：名词后附加多余限定词（如“二者的同步”中“二者的”可省略）。"
    },
    {
      "defect_id": 2981,
      "sentence": "如果访问的数据项没有获取到值，表示当前系统应用没有将该数据项的值添加到数据库。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "",
      "修改建议": "语句中存在冗余表达",
      "更改后示例": "如果访问的数据项没有值，表示当前系统应用未将该数据项添加到数据库。",
      "触发条件": "当句子中同时出现重复的动词-名词结构（如\"获取到值\"与\"值\"）或存在冗余修饰成分（如\"数据项的值\"中重复限定属性）时触发。具体表现为同一语义元素在动词和宾语中重复出现（获取+值），或名词被其固有属性重复修饰（数据项+值）。"
    },
    {
      "defect_id": 13036,
      "sentence": "HSP开发者可以控制自己需要导出的资源，不需要对外暴露的资源可以不用导出。",
      "reference_sentence": "",
      "line_num": 142,
      "context": "",
      "修改建议": "原文有冗余信息。",
      "更改后示例": "HSP开发者可以控制导出的资源。",
      "触发条件": "句子中存在多个分句或短语表达同一语义内容（如正反双向描述同一逻辑关系），且删除冗余部分后不影响核心信息完整性。\n\n识别模式：  \n1. 出现同义重复结构（如\"可以控制X，不需要的Y可以不用X\"）；  \n2. 包含双向否定/反向补充（如\"需要A可以B，不需要A可以不B\"），且后项未提供新信息。"
    },
    {
      "defect_id": 13974,
      "sentence": "开发者可以通过调试命令进行应用的安装和卸载，可参考[编译发布与上架部署流程图](./application-package-structure-stage.md#发布态包结构)。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "开发者使用调试命令安装和卸载应用。",
      "触发条件": "句子中出现“进行+动词名词化”结构（如“进行安装”）或存在可合并的复合修饰成分（如“通过...方式”），导致表达冗余、句式冗长。  \n\n识别模式：  \n1. 检测“进行/执行/做+(的)+动词性名词”结构，判断是否可替换为直接动词形式（如“进行安装”→“安装”）；  \n2. 分析长句中是否存在重复说明同一动作的介词短语（如“通过调试命令”与“可参考...”），优先保留核心操作描述。"
    },
    {
      "defect_id": 19934,
      "sentence": "其次，构造变量connect，指定连接成功、连接失败、断开连接时的回调函数。",
      "reference_sentence": "",
      "line_num": 82,
      "context": "",
      "修改建议": "句子过长，包含多个信息点，不易理解。",
      "更改后示例": "构造变量connect，指定连接成功、失败及断开时的回调。",
      "触发条件": "当句子中出现三个及以上具有相同语义成分的并列结构(如\"连接成功、连接失败、断开连接\")，且存在可合并的重复性前缀/后缀时触发。\n\n识别模式：\n1. 检测连续逗号分隔的并列短语(至少3项)\n2. 分析短语结构特征，识别重复用词模式(如\"连接X\"的重复前缀)\n3. 判断是否可通过保留首项完整形式+后续简写形式(如\"成功、失败及断开\")进行语义压缩\n4. 验证简化后是否保持原意且提升可读性"
    },
    {
      "defect_id": 2983,
      "sentence": "是否自动从网络获取日期、时间和时区。 <br>- 值为true表示自动从网络获取信息。<br/>- 值为false表示不自动获取信息。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "",
      "修改建议": "语句中存在冗余表达",
      "更改后示例": "是否自动从网络获取日期、时间和时区。<br>- 值为true表示自动获取。<br/>- 值为false表示不自动获取。",
      "触发条件": "当选项说明重复主句已明确的信息源/对象时（如\"从网络\"在前文已出现），或使用冗余限定词（如\"信息\"在前文已具体说明）时触发。\n\n识别模式：\n1. 检查选项说明是否重复主句的介词短语（如\"从网络\"）\n2. 验证名词是否可被前文具体指代对象替代（如\"信息\"可被\"日期、时间和时区\"替代）\n3. 判断重复内容是否为必要补充信息（若无补充作用则判定冗余）"
    },
    {
      "defect_id": 18854,
      "sentence": "主应用和分身应用共享同一个应用。例如，当主应用更新/升级时，主应用与分身应用都会同步更新，包括应用的图标（icon）和名称（label）、应用特性本身的新特性等。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "",
      "修改建议": "句子过长，且包含不必要的修饰成分。",
      "更改后示例": "主应用和分身应用共享同一个应用。主应用更新时，分身应用也会同步更新，包括图标和名称。",
      "触发条件": "句子中存在重复名词（如“主应用”多次提及）、同义并列结构（如“更新/升级”）或冗余修饰成分（如“应用特性本身的新特性”），导致信息重复或表述臃肿时触发。识别模式为检测连续重复主语、斜杠分隔的同义词组，以及可合并的修饰语（如括号补充、重复属性描述）。"
    },
    {
      "defect_id": 13041,
      "sentence": "页面返回`router.back`方法的入参中`url`说明：",
      "reference_sentence": "",
      "line_num": 429,
      "context": "",
      "修改建议": "原文为引导句，没有实质信息。",
      "更改后示例": "`router.back`方法的`url`参数说明：",
      "触发条件": "当句子包含引导性短语或过渡句（如“页面返回”、“入参中”），且未提供新增技术信息时触发；或上下文已明确主体（如方法名`router.back`）后仍重复提及冗余限定词时触发。\n\n识别模式：检查是否存在可被上下文/主谓结构直接隐含的修饰词（如“页面返回”）、或非必要的介词结构（如“入参中”），若删除后核心信息（`url参数说明`）无损且更简洁，则判定为冗余。"
    },
    {
      "defect_id": 24560,
      "sentence": "推荐只配置一个wants元素。",
      "reference_sentence": "",
      "line_num": 553,
      "context": "",
      "修改建议": "句子信息不够直接。",
      "更改后示例": "推荐配置一个wants元素。",
      "触发条件": "当句子中同时使用强调限制的副词（如\"只\"）和明确的数量词（如\"一个\"）构成重复限制时，或存在多个语义重叠的限定成分时触发。识别模式为：检测\"副词+数量词\"组合结构（如\"只+一个\"）或同义限定词连续出现（如\"必须需要\"），判定为冗余强调需简化。"
    },
    {
      "defect_id": 9506,
      "sentence": "delayMs参数设置后调用sync接口时延时时间以delayMs的时长为准，未设置时以[setSyncParam](#setsyncparam)设置的时长为准。",
      "reference_sentence": "",
      "line_num": 4982,
      "context": "",
      "修改建议": "句子过长，包含不必要的信息。",
      "更改后示例": "设置delayMs后，调用sync接口时延时时间为delayMs。未设置时，以setSyncParam设置的时长为准。",
      "触发条件": "同一语义成分在句子中重复出现（如\"delayMs参数\"+\"delayMs的时长\"），或存在可合并的冗余修饰词（如\"时长\"在时间参数后冗余）。识别模式为检测名词短语中重复的限定词（参数名称+的+同义词）及上下文已有明确指代时的重复说明。"
    },
    {
      "defect_id": 24589,
      "sentence": "标识权限限制类别，可选值如下：<br/>-&nbsp;system_core：系统核心权限。<br/>-&nbsp;system_basic：系统基础权限。<br/>-&nbsp;normal：普通权限。所有应用允许申请的权限。",
      "reference_sentence": "",
      "line_num": 1056,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "标识权限限制类别，可选值为system_core（系统核心权限）、system_basic（系统基础权限）、normal（普通权限，所有应用允许申请）。",
      "触发条件": "当同一术语在多个列表项中重复出现（如\"权限\"），或存在可合并的重复解释性内容（如权限类型与括号说明存在语义重叠）时触发。通过识别连续列表项中的重复核心名词及括号内外语义重复成分进行判断。"
    },
    {
      "defect_id": 13994,
      "sentence": "- [应用组件](../application-models/stage-model-development-overview.md)信息，包含UIAbility组件和ExtensionAbility组件的描述信息。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "- [应用组件](../application-models/stage-model-development-overview.md)信息，包括UIAbility组件和ExtensionAbility组件的描述。",
      "触发条件": "检测到句子中存在同义重复的名词短语（如\"描述信息\"），或使用\"包含\"+\"的\"+冗余名词结构（如\"包含...的描述信息\"）时触发。\n\n识别模式：当动词（包含/包括/含有等）后接\"的\"+复合名词（A+B），且B词（如\"信息\"）与前置内容存在语义重复时，判定为冗余表达。典型特征为B词可删除而不影响原意（如\"描述信息\"→\"描述\"）。"
    },
    {
      "defect_id": 10135,
      "sentence": "需要注意的是，应用设置的低时延模式并不一定能生效。在如下的场景下，系统会忽略应用设置的低时延模式，使用普通模式输出：1）输出音频的采样率非48K，当前低时延音频仅支持48K采样率输出；2）系统低时延资源已经被全部占用；3）当前的输出设备不支持低时延模式。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "",
      "修改建议": "原文包含不必要的说明，且使用了双重否定。",
      "更改后示例": "应用设置的低时延模式可能不生效。系统在以下情况下使用普通模式：1）采样率非48K；2）低时延资源已用尽；3）输出设备不支持低时延。",
      "触发条件": "文本中存在冗余引导词（如“需要注意的是”）、重复性说明（如同时使用否定与解释性条件）或双重否定结构（如“并不一定能”）时触发。  \n\n识别模式：  \n1. **冗余引导词**：检测如“需要注意的是”、“应当注意”等无信息量的开篇短语。  \n2. **重复解释**：同一信息在主干句和分项中重复（如“采样率非48K”与“仅支持48K”并存）。  \n3. **双重否定**：包含否定词叠加的表达（如“并不一定”可简化为“可能不”）。"
    },
    {
      "defect_id": 24585,
      "sentence": "标识环境变量的值。取值为长度不超过4096字节的字符串。",
      "reference_sentence": "",
      "line_num": 1029,
      "context": "",
      "修改建议": "句子结构复杂，包含不必要的修饰词。",
      "更改后示例": "标识环境变量值。取值为字符串，长度不超过4096字节。",
      "触发条件": "1) 当名词短语包含连续前置的技术性修饰词（如\"长度不超过4096字节的\"）导致结构臃肿时；2) 存在可合并的冗余结构（如\"环境变量的值\"中的\"的\"字）且不影响核心语义时。\n\n识别模式：\n- 检测\"的\"字连续堆叠结构（如\"XX的值的参数\"→\"XX值参数\"）\n- 识别技术参数与核心名词的修饰顺序（如将\"长度不超过N的字符串\"拆解为\"字符串，长度不超过N\"）\n- 判断前置定语是否超过两层修饰（如\"长度不超过4096字节的字符串\"含3层修饰）"
    },
    {
      "defect_id": 24584,
      "sentence": "标识环境变量的变量名称。取值为长度不超过4096字节的字符串。",
      "reference_sentence": "",
      "line_num": 1028,
      "context": "",
      "修改建议": "句子结构复杂，包含不必要的修饰词。",
      "更改后示例": "标识环境变量名称。取值为字符串，长度不超过4096字节。",
      "触发条件": "当句子中出现同一核心名词被重复修饰（如\"变量名称\"被\"环境变量\"和\"变量\"双重限定），或分句间存在可合并的复合结构（如将类型说明与长度限制拆分为两个独立短语）时触发。\n\n识别模式：\n1. 检测\"名词A+的+名词B\"结构，当名词B本身已隐含名词A属性时（如\"环境变量名称\"已包含\"变量\"属性）\n2. 发现分句间存在主谓宾重复（如\"取值为...字符串\"与\"长度不超过...\"本属同一语义单元）"
    },
    {
      "defect_id": 24577,
      "sentence": "标识跳转页面的名称。取值为长度不超过1023字节的字符串。",
      "reference_sentence": "",
      "line_num": 920,
      "context": "",
      "修改建议": "句子结构复杂，包含不必要的修饰词。",
      "更改后示例": "标识跳转页面名称。取值为字符串，长度不超过1023字节。",
      "触发条件": "当句子中出现\"的\"字连接的复合名词结构（如\"XX的YY\"可简化为\"XXYY\"），或存在可分离的前置修饰语（如\"长度不超过N的字符串\"可拆分为\"字符串，长度不超过N\"）时触发。"
    },
    {
      "defect_id": 22712,
      "sentence": "Permission denied. A non-system application is not allowed to call a system API.",
      "reference_sentence": "",
      "line_num": 690,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "非系统应用不能调用系统API。",
      "触发条件": "检测到句子中存在可被更简洁结构替代的冗长表达（如被动语态、多重否定或重复性修饰词）时触发。识别模式需聚焦于冗余否定结构（如\"is not allowed to\"→\"不能\"）和重复限定成分（如\"non-system application\"与\"system API\"的显性对立关系）。"
    },
    {
      "defect_id": 24597,
      "sentence": "该标签指向一个profile文件资源，用于指定UIAbility组件启动页面的配置文件，在开发视图的resources/base/profile下面定义配置文件start_window.json，如果配置该字段，startWindowIcon和startWindowBackground字段均不生效。",
      "reference_sentence": "",
      "line_num": 1193,
      "context": "",
      "修改建议": "原文过于啰嗦，包含多个逗号",
      "更改后示例": "该标签指向一个profile文件资源，用于指定UIAbility组件启动页面的配置文件。定义在resources/base/profile下的start_window.json。配置该字段后，startWindowIcon和startWindowBackground字段无效。",
      "触发条件": "当句子包含三个及以上逗号分隔的独立分句，或存在上下文已明确的冗余地点/条件描述（如\"在开发视图的resources/base/profile下面定义\"）时触发。\n\n识别模式：通过检测长句中标点密度（逗号数量/句子长度＞0.3）和位置状语重复（如\"在...下面定义\"与后文\"定义在...\"语义重叠），结合技术文档上下文已知信息（如resources路径已在其他章节说明）进行判断。"
    },
    {
      "defect_id": 24587,
      "sentence": "标识权限的名称，该标签最大长度为255字节。",
      "reference_sentence": "",
      "line_num": 1054,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "标识权限名称，最大长度255字节。",
      "触发条件": "当句子中存在重复限定成分（如冗余指示代词\"该\"）或可合并的\"的\"字结构（如\"X的名称\"→\"X名称\"），且删除后不影响核心信息传达时触发。\n\n识别模式：1. 检查名词前是否出现非必要的限定词（该/此/上述） 2. 验证\"的\"字结构是否可压缩为复合名词 3. 确认修饰成分与上下文存在重复指代关系"
    },
    {
      "defect_id": 24563,
      "sentence": "该标签从API10及以后版本开始生效，API9及以前版本使用distroFilter标签。",
      "reference_sentence": "",
      "line_num": 647,
      "context": "",
      "修改建议": "原文中使用了不必要的修饰成分。",
      "更改后示例": "该标签从API10开始生效，API9及以前版本使用distroFilter标签。",
      "触发条件": "当表述时间范围或版本区间时，同时存在明确起始点（如\"API10\"）和冗余的后缀范围说明（如\"及以后版本\"），且起始点已隐含范围指向性时。\n\n识别模式：检测\"从X开始生效/使用\"类结构后是否叠加了\"及以后版本/及以上\"等显性范围描述，或\"X及以前版本\"中\"版本\"是否可省略（如\"API9以前\"已隐含版本概念）。通过语义分析判断修饰成分是否重复了主句已传递的版本递进关系。"
    },
    {
      "defect_id": 24579,
      "sentence": "标识被@Builder修饰的函数，该函数描述页面的UI。取值为长度不超过1023字节的字符串。",
      "reference_sentence": "",
      "line_num": 922,
      "context": "",
      "修改建议": "句子结构复杂，包含不必要的修饰词。",
      "更改后示例": "标识@Builder修饰的函数，描述页面UI。取值为字符串，长度不超过1023字节。",
      "触发条件": "句子中同时存在被动语态（如\"被修饰\"）和重复指代（如\"该函数\"），或出现冗余限定词（如\"取值为长度\"中的\"长度\"）。\n\n识别模式：\n1. 检测\"被/由...修饰\"等被动结构 + 后续重复的\"该/此...\"指代\n2. 发现名词前存在隐含重复的限定词（如\"长度\"在\"不超过1023字节\"前冗余）\n3. 存在可合并的分离式描述（如将\"描述页面的UI\"直接衔接主谓结构）"
    },
    {
      "defect_id": 24590,
      "sentence": "标识权限是否支持证书方式申请权限，包括高级别的权限。配置为true标识开发者可以通过provision方式申请权限。",
      "reference_sentence": "",
      "line_num": 1057,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "标识权限是否支持证书方式申请。配置为true表示开发者可以通过provision方式申请。",
      "触发条件": "当句子中同一核心名词在相邻分句重复出现（如\"权限\"），或包含不提供新信息的限定性说明（如\"包括高级别的权限\"）时触发。\n\n识别模式：\n1. 名词重复检测：检查主宾语位置是否在相邻分句重复同一名词（如\"申请权限\"与\"标识权限\"）\n2. 修饰语必要性判断：通过依存句法分析识别补充说明成分（如\"包括...\"），验证其是否为前文已包含的已知信息"
    },
    {
      "defect_id": 24591,
      "sentence": "标识权限的简短描述，配置为对描述内容的资源索引。",
      "reference_sentence": "",
      "line_num": 1059,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "标识权限简短描述，配置为描述内容的资源索引。",
      "触发条件": "当句子中出现冗余介词（如\"对\"）或重复修饰成分（如\"的\"+名词重复出现），且删除后不影响语义完整性时触发。\n\n识别模式：检查名词短语前是否存在可简化的\"的+修饰语\"结构，或动词后是否存在不必要的介词框架（如\"为对...\"），重点识别\"的\"+属性词、\"对\"+动名词等易冗余搭配。"
    },
    {
      "defect_id": 37045,
      "sentence": "Promise形式返回当前应用是否是默认应用，true表示是默认应用，false表示不是默认应用。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "",
      "修改建议": "原文使用了不必要的修饰成分。",
      "更改后示例": "返回当前应用是否为默认应用，true表示是默认应用，false表示不是默认应用。",
      "触发条件": "当句子中存在重复说明已知信息或添加不必要限定词（如\"形式\"等冗余修饰成分），且删除后不影响核心语义时触发。识别模式为检测\"形式返回\"类结构中的修饰词是否与上下文存在重复说明关系。"
    },
    {
      "defect_id": 24179,
      "sentence": "Promise对象，返回true表示当前应用组件为使能状态，返回false表示当前应用组件为禁用状态。",
      "reference_sentence": "",
      "line_num": 2899,
      "context": "",
      "修改建议": "句子较长，含有不必要的修饰成分。",
      "更改后示例": "返回true表示使能状态，返回false表示禁用状态。",
      "触发条件": "当句子中出现重复修饰成分（如\"当前应用组件为\"）且主语已明确时，或存在可合并的并列冗余结构（如\"使能状态\"/\"禁用状态\"前的重复限定语）时触发。\n\n识别模式：\n1. 检测并列结构中的重复限定语（如\"返回X表示[重复短语]+状态描述\"）\n2. 验证上下文是否已明确主语（本例前文已说明\"Promise对象\"作为主语）\n3. 判断修饰成分是否提供必要信息（\"当前应用组件为\"未增加新信息）\n4. 识别对称句式中的冗余部分（两个分句共享相同语境时可精简）"
    },
    {
      "defect_id": 24159,
      "sentence": "值为true表示使能，值为false表示禁用。",
      "reference_sentence": "",
      "line_num": 2140,
      "context": "",
      "修改建议": "句子结构可以简化。",
      "更改后示例": "true表示使能，false表示禁用。",
      "触发条件": "同一句子中多个分句重复使用相同冗余短语（如\"值为\"），且删除冗余短语后不影响语义完整性。  \n\n识别模式：检测到句式结构为「重复前缀+关键值+解释说明」（如\"值为X表示Y\"连续出现），且前缀成分可被删除而不改变核心逻辑时触发规则。"
    },
    {
      "defect_id": 24185,
      "sentence": "以同步方法获取指定组件的禁用或使能状态。",
      "reference_sentence": "",
      "line_num": 3017,
      "context": "",
      "修改建议": "句子结构可以简化，去掉不必要的修饰。",
      "更改后示例": "获取指定组件的禁用或使能状态。",
      "触发条件": "句子中存在可移除的介词短语修饰（如\"以...方法\"）且核心动词短语（如\"获取状态\"）已完整表达核心语义时触发；或修饰语表达的方式/条件在上下文中属于默认/隐含信息时触发。\n\n识别模式：检查句子中是否包含\"以/通过/基于...(方式)\"类介词结构，且该结构修饰的动词短语本身已具备完整语义（如\"获取状态\"）。若删除介词结构后不影响功能描述准确性，则判定为冗余。"
    },
    {
      "defect_id": 24583,
      "sentence": "customData对象内部，可以填入任意类型的自定义数据。",
      "reference_sentence": "",
      "line_num": 991,
      "context": "",
      "修改建议": "句子结构复杂，包含不必要的修饰词。",
      "更改后示例": "customData对象内部可以填入任意类型的自定义数据。",
      "触发条件": "句子中存在因多余标点（如逗号）导致的主谓分隔或冗余修饰词（如重复性限定词），使结构复杂化且未增加有效信息。"
    },
    {
      "defect_id": 24233,
      "sentence": "获取指定的共享包信息，使用Promise异步回调。",
      "reference_sentence": "",
      "line_num": 3948,
      "context": "",
      "修改建议": "原文包含不必要的修饰词。",
      "更改后示例": "获取指定共享包信息，使用Promise回调。",
      "触发条件": "句中存在可被上下文或术语隐含的冗余修饰词（如\"异步\"在\"Promise\"场景），或形容词结构可简化为名词/动词短语（如\"指定的\"→\"指定\"）。通过识别术语隐含属性及\"的\"字冗余结构触发规则。"
    },
    {
      "defect_id": 24250,
      "sentence": "表示用户ID，默认值：调用方所在用户，取值范围：大于等于0，可以通过接口[getOsAccountLocalId](../apis-basic-services-kit/js-apis-osAccount.md#getosaccountlocalid9)获取当前设备上的用户ID。",
      "reference_sentence": "",
      "line_num": 4221,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "表示用户ID，默认值为调用方所在用户，取值范围大于等于0。",
      "触发条件": "句子中存在多个逗号分隔的独立信息点（如参数说明、取值范围、外部引用），且部分内容可通过句式简化（如替换冒号为动词结构）或删除冗余信息（如非必要的接口引用）实现语义压缩。"
    },
    {
      "defect_id": 37602,
      "sentence": "本模块提供应用域名校验能力，支持查询应用与域名之间的映射关系。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "本模块提供应用域名校验能力，支持查询应用与域名的映射关系。",
      "触发条件": "当句子中出现\"与...之间的\"等冗余介词结构，且存在多个并列信息点导致句式臃肿时触发。  \n\n识别模式：  \n1. 检测\"与/和/同...之间的\"类短语结构  \n2. 判断是否可通过删除\"之间\"或合并\"的\"结构简化表达（如\"应用与域名之间的映射\"→\"应用与域名的映射\"）  \n3. 结合上下文检查句子是否承载超过两个信息单元（本例含\"提供能力\"+\"支持查询\"+\"映射关系\"三重信息）"
    },
    {
      "defect_id": 22856,
      "sentence": "以下各项对应的系统能力均为SystemCapability.BundleManager.BundleFramework.AppControl。",
      "reference_sentence": "",
      "line_num": 831,
      "context": "",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "各项系统能力均为SystemCapability.BundleManager.BundleFramework.AppControl。",
      "触发条件": "当句子出现重复指示范围/对象的冗余词汇（如\"以下\"+\"对应的\"）且主谓关系明确时，或存在可合并的递进式限定词导致信息密度过低时触发。\n\n具体识别模式：\n1. 连续使用两个及以上指示性短语（如\"以下XX的对应YY\"）\n2. 存在可删除的位置限定词（如\"以下\"）和关系限定词（如\"对应的\"）双重修饰\n3. 核心信息(SystemCapability)重复出现相同表述\n4. 句子结构符合\"范围指示词+关联词+重复内容\"的嵌套模式"
    },
    {
      "defect_id": 24206,
      "sentence": "获取指定bundleName、moduleName和abilityName的label，使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 3484,
      "context": "",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "获取指定组件的label，使用异步回调。",
      "触发条件": "句子中存在可被上位词概括的具体列举项，或包含与核心术语重复的修饰成分（如\"callback异步回调\"中的冗余限定）。需同时满足语义完整性和上下文可推导性。"
    },
    {
      "defect_id": 39767,
      "sentence": "Array形式返回[ShortcutInfo](js-apis-bundleManager-shortcutInfo-sys.md)信息。",
      "reference_sentence": "",
      "line_num": 194,
      "context": "",
      "修改建议": "句子可更简洁。",
      "更改后示例": "返回[ShortcutInfo](js-apis-bundleManager-shortcutInfo-sys.md)数组。",
      "触发条件": "当句子中同时出现\"Array形式\"与\"数组\"等中英文术语重复表述，或存在\"信息\"等冗余抽象名词时触发。\n\n识别模式：\n1. 检测到技术术语存在中英文冗余组合（如\"Array形式数组\"）\n2. 发现抽象名词（如\"信息\"）与后续具体数据结构描述形成语义重复\n3. 动词后接双重类型说明（如\"形式返回...数组\"）产生表达累赘"
    },
    {
      "defect_id": 39861,
      "sentence": "模块名称。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "",
      "修改建议": "原文中存在不必要的修饰成分。",
      "更改后示例": "模块名。",
      "触发条件": "检测到名词短语中包含重复或隐含同义修饰词（如“名称”与“名”叠加），且其中一个成分已完整表达核心语义。\n\n识别模式：  \n1. 复合词结构（XX+名称/类型/形式等），其中“XX”本身隐含后缀成分的语义（如“模块名”已含“名称”属性）；  \n2. 存在可独立表意的核心词（如“名”），冗余词（如“称”）仅起重复修饰作用。"
    },
    {
      "defect_id": 39045,
      "sentence": "async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "",
      "修改建议": "句子过长，含有多个逗号。",
      "更改后示例": "async/await简化异步代码。使用async声明异步函数，await等待Promise解析。",
      "触发条件": "当句子结构复杂（如包含多个逗号分隔的独立分句）且存在重复/递进式表达时触发，常见于技术文档中解释性段落。\n\n识别模式：\n1. 长度特征：单句超过30字且含2个以上逗号\n2.重复信号：同义词重复（如\"异步操作\"与\"Promise解析\"）、结构重复（如连续\"使用...关键字\"句式）\n3. 递进标记：存在\"使得\"、\"通过\"等引导的附加说明性分句\n4. 信息密度：核心概念（如async/await）被多角度重复解释"
    },
    {
      "defect_id": 39862,
      "sentence": "ability名称。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "",
      "修改建议": "原文中存在不必要的修饰成分。",
      "更改后示例": "ability名。",
      "触发条件": "名词短语中包含可省略的冗余限定词（如\"名称\"中的\"称\"），或存在通过上下文即可推断的重复修饰成分。\n\n识别模式：\n1. 检查复合名词中是否包含同义字组合（如\"名称\"=\"名+称\"）\n2. 验证修饰成分的必要性：当删除某字词后核心含义不变（如\"名称\"→\"名\"仍保持指代能力）\n3. 特别关注行业术语中常见的冗余构词（如\"PIN号码\"应简化为\"PIN\"）"
    },
    {
      "defect_id": 40394,
      "sentence": "根据给定的resourceFlags获取所有应用的BundleResourceInfo。使用callback异步回调。",
      "reference_sentence": "",
      "line_num": 162,
      "context": "",
      "修改建议": "原文使用了不必要的修饰成分。",
      "更改后示例": "根据resourceFlags获取所有应用的BundleResourceInfo，使用callback回调。",
      "触发条件": "当句子中名词短语包含冗余限定词（如“给定的”、“当前的”）或动词/名词存在重复隐含语义的修饰成分（如“异步回调”中“异步”冗余）时触发。"
    },
    {
      "defect_id": 40176,
      "sentence": "并发模型是用来实现不同应用场景中并发任务的编程模型，常见的并发模型分为基于内存共享的并发模型和基于消息通信的并发模型。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "并发模型用于实现不同应用场景中的并发任务。常见的并发模型有基于内存共享的模型和基于消息通信的模型。",
      "触发条件": "句子包含由多个逗号连接的复合结构，且在相邻分句中重复出现相同核心名词（如\"并发模型\"）时触发。\n\n识别模式：\n1. 语法结构分析：检测长句是否由逗号连接两个及以上完整分句构成\n2. 语义重复检测：识别后置分句中重复出现前置分句的核心术语（需建立领域术语库），如案例中第二个\"并发模型\"与前文重复\n3. 冗余度评估：当重复术语可被代词/简写替代（如\"模型\"）且不影响理解时，判定为冗余表达"
    },
    {
      "defect_id": 41169,
      "sentence": "Promise不支持跨线程传递，如果TaskPool返回pending或rejected状态的Promise，会返回失败；对于fulfilled状态的Promise，TaskPool会解析返回的结果，如果结果可以跨线程传递，则返回成功。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "Promise不支持跨线程传递。TaskPool返回pending或rejected状态的Promise时失败，返回fulfilled状态的Promise时成功。",
      "触发条件": "句子包含多个并列条件分句（使用逗号/分号连接）且存在重复性动词结构（如连续出现\"返回\"）或冗余条件描述（如不必要的\"如果...则\"结构）时触发。\n\n识别模式：\n1. 结构特征：检测超过2个分句的复合句（通常由逗号/分号连接）\n2. 冗余标记：识别重复动词（如连续出现\"返回\"）、重复条件引导词（如多个\"如果\"）、以及可合并的同类项（如\"pending或rejected状态\"可简化为非成功状态）\n3. 信息密度：判断是否存在可删除的已知前提（如\"结果可以跨线程传递\"在上下文中已隐含）"
    },
    {
      "defect_id": 39889,
      "sentence": "获取当前应用的信息。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "",
      "修改建议": "原文为简单的主谓宾结构，但是可以进一步简化。",
      "更改后示例": "获取应用信息。",
      "触发条件": "句子为简单主谓宾结构，且存在可删除的修饰词（如时间/范围限定词）或冗余助词（如\"的\"字结构）时触发。\n\n识别模式：\n1. 主谓结构后接\"的+名词\"组合（如\"的信息\"），且删除\"的\"字后语义不变\n2. 宾语前存在默认隐含的修饰词（如\"当前\"在无时间上下文时冗余）\n3. 通过成分删除测试：移除修饰成分后仍保持完整语义且更简洁"
    },
    {
      "defect_id": 41410,
      "sentence": "查询包是否已安装时的选项。",
      "reference_sentence": "",
      "line_num": 68,
      "context": "",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "查询包是否已安装的选项。",
      "触发条件": "当名词短语被含冗余时间状语（如“时”）的定语从句修饰，且该时间限定不改变核心语义时触发。具体表现为\"动词短语+时+的+名词\"结构，其中\"时\"字可删除而不影响表意（如\"查询时的选项\"→\"查询的选项\"）。"
    },
    {
      "defect_id": 41317,
      "sentence": "ElementName信息,最大数组长度为10。",
      "reference_sentence": "",
      "line_num": 168,
      "context": "",
      "修改建议": "表达冗长，可以简化。",
      "更改后示例": "ElementName数组，最大长度为10。",
      "触发条件": "句子中名词后存在冗余的泛用词（如\"信息\"\"数据\"），或属性描述包含上下文已明确的重复限定词（如\"数组长度\"→\"长度\"）。  \n识别模式：检测\"名词+信息/数据\"结构，或复合型量词（XX长度/XX类型）中前半部分已被上下文覆盖的情况。"
    },
    {
      "defect_id": 39046,
      "sentence": "async函数是一个返回Promise对象的函数，用于表示一个异步操作。在async函数内部，可以使用await关键字等待一个Promise对象的解析，并返回其解析值。如果一个async函数抛出异常，那么该函数返回的Promise对象将被拒绝，并且异常信息会被传递给Promise对象的onRejected()方法。",
      "reference_sentence": "",
      "line_num": 53,
      "context": "",
      "修改建议": "句子过长，信息量大。",
      "更改后示例": "async函数返回Promise对象。内部使用await等待Promise解析。抛出异常时，Promise被拒绝。",
      "触发条件": "当句子包含重复概念（如多次提及同一对象/行为）或存在可合并/简化的独立子句时触发。\n\n识别模式：\n1. 同一核心概念被不同表述重复强调（如案例中\"返回Promise对象\"在多个分句重复出现）\n2. 包含超过两个并列的说明性子句（原句用三个分号分隔的独立说明）\n3. 存在可推导的隐含信息（如\"用于表示异步操作\"已隐含在async函数定义中）\n4. 使用超过必要层级的语法结构（如\"并且异常信息会被传递给...\"可通过\"被拒绝\"隐含）"
    },
    {
      "defect_id": 41422,
      "sentence": "应用程序的安装目录。不能拼接路径访问资源文件，请使用[资源管理接口](../apis-localization-kit/js-apis-resource-manager.md)访问资源。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "应用程序的安装目录。使用资源管理接口访问资源。",
      "触发条件": "同一句子中同时包含否定性错误做法和替代性正确方案时，且两者指向同一操作目标（如\"不能拼接路径\"与\"使用接口访问资源\"均针对资源访问场景）。  \n\n识别模式：当检测到\"不能/不要/禁止...[错误方法]\"与\"请使用/应采用...[正确方法]\"的并列结构，且两者动词指向同一操作对象（如\"访问资源文件\"和\"访问资源\"）时，应触发冗余规则。"
    },
    {
      "defect_id": 41487,
      "sentence": "判断Ability是否可以被其他应用调用，取值为true表示Ability可以被其他应用调用，取值为false表示Ability不可以被其他应用调用。",
      "reference_sentence": "",
      "line_num": 27,
      "context": "",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "是否可以被其他应用调用。true表示可以，false表示不可以。",
      "触发条件": "当句子中存在重复解释同一主语/条件的布尔值定义（如\"true表示...，false表示...\"），且后续取值说明重复使用完整主谓结构时触发。\n\n识别模式：\n1. 包含\"取值为X表示Y，取值为Z表示¬Y\"的平行结构\n2. 在取值说明中重复出现前文已明确的主语（如案例中的\"Ability\"）和完整条件（如\"可以被其他应用调用\"）\n3. 存在可替换为代词/省略重复成分的冗余表达（如用\"可以\"替代\"Ability可以被其他应用调用\"）"
    },
    {
      "defect_id": 39041,
      "sentence": "Promise有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）。Promise对象创建后处于pending状态，并在异步操作完成后转换为fulfilled或rejected状态。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "",
      "修改建议": "信息重复，可以简化。",
      "更改后示例": "Promise有三种状态：pending、fulfilled和rejected。创建后处于pending状态，异步操作完成后转换为fulfilled或rejected。",
      "触发条件": "当同一术语存在括号内同义解释（如\"pending（进行中）\"），且该解释在上下文或领域常识中已明确时；或出现冗余限定词（如\"Promise对象\"中的\"对象\"）且前文已明确主体时。\n\n识别模式：\n1. 括号内解释检测：匹配「中文括号+同义词」结构（如\"已完成\"对应\"fulfilled\"）\n2. 冗余限定词识别：当名词短语中的限定成分（如\"对象\"）与前文主体重复且无歧义风险时\n3. 上下文验证：检查前文是否已明确定义相关概念，或术语是否属于领域常识（如Promise状态）"
    },
    {
      "defect_id": 40370,
      "sentence": "指定返回的BundleResourceInfo所包含的信息。",
      "reference_sentence": "",
      "line_num": 66,
      "context": "",
      "修改建议": "句子结构简单，但可以更简洁。",
      "更改后示例": "指定返回的BundleResourceInfo信息。",
      "触发条件": "当句子中出现“名词A+所包含的+信息/内容”结构，且名词A本身已隐含该信息属性时，需触发冗余规则。例如检测到“BundleResourceInfo所包含的信息”中“所包含的”与“信息”形成语义重复。"
    },
    {
      "defect_id": 39860,
      "sentence": "应用的包名。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "",
      "修改建议": "原文中存在不必要的修饰成分。",
      "更改后示例": "包名。",
      "触发条件": "名词短语中的修饰成分（如“应用”）可通过上下文或常识明确推断，且未提供额外必要信息时。  \n\n识别模式：检查是否存在“修饰语+的+中心名词”结构（如“应用的包名”），若修饰语与中心名词关系隐含（如“包名”默认属于应用）或重复已知信息，则判定为冗余。"
    },
    {
      "defect_id": 41423,
      "sentence": "访问应用程序所需的权限。<br />通过调用[bundle.getApplicationInfo](js-apis-Bundle.md#bundlegetapplicationinfodeprecated)接口时，传入GET_APPLICATION_INFO_WITH_PERMISSION获取。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "访问应用程序所需的权限。通过调用bundle.getApplicationInfo接口获取。",
      "触发条件": "句子中包含接口参数、实现细节等非必要修饰成分，且未提供额外信息价值时触发；存在重复或冗余的技术描述（如内部参数、弃用链接）干扰核心信息传达时触发。  \n\n识别模式：通过检查是否存在可移除的接口参数（如`GET_APPLICATION_INFO_WITH_PERMISSION`）、冗余的技术说明（如弃用标记的链接）或重复步骤（如“传入…获取”与上下文重复），同时核心语义（如“调用接口获取权限”）是否已完整表达。"
    },
    {
      "defect_id": 41486,
      "sentence": "从API version 9开始不再维护，建议使用[bundleManager-AbilityInfo](js-apis-bundleManager-abilityInfo.md)替代。",
      "reference_sentence": "",
      "line_num": 10,
      "context": "",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "从API version 9开始不再维护，建议使用[bundleManager-AbilityInfo]替代。",
      "触发条件": "检测到文档链接中包含与显示文本重复的冗余路径信息，或链接格式导致修饰成分过长且不影响目标定位。  \n识别方式：当Markdown链接的URL部分（如`(js-apis-X.md)`）与显示文本（如`[X]`）核心内容重复时，判定为冗余表达，需删除URL保留关键标识。"
    },
    {
      "defect_id": 39048,
      "sentence": "需要注意的是，由于要等待异步操作完成，因此需要将整个操作包在async函数中，并搭配await关键字使用。除了在async函数中使用await外，还可以使用try/catch块来捕获异步操作中的异常。",
      "reference_sentence": "",
      "line_num": 92,
      "context": "",
      "修改建议": "句子过长，信息量大。",
      "更改后示例": "等待异步操作时，需将操作包在async函数中，并使用await。可使用try/catch捕获异常。",
      "触发条件": "句子包含冗余引导词（如\"需要注意的是\"\"由于...因此...\"）或重复性解释相同概念，导致信息密度过高且存在可合并的简化空间。当句子长度超过25字且含多个连词/分句时优先触发。"
    },
    {
      "defect_id": 40055,
      "sentence": "本模块首批接口从API version 8 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "本模块从API version 8开始支持。新增接口标记起始版本。",
      "触发条件": "同一句子或相邻句子中重复出现时间/版本修饰词（如“首批接口”和“后续版本的新增接口”），或存在可合并的冗余限定词（如“采用上角标单独标记”中的双重修饰）。"
    },
    {
      "defect_id": 41424,
      "sentence": "应用程序的自定义元信息。<br />通过调用[bundle.getApplicationInfo](js-apis-Bundle.md#bundlegetapplicationinfodeprecated)接口时，传入GET_APPLICATION_INFO_WITH_METADATA获取。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "应用程序的自定义元信息。通过调用bundle.getApplicationInfo接口获取。",
      "触发条件": "句子中包含接口调用方法的具体参数或实现细节（如可选标志、内部链接），且这些信息对理解核心功能无必要或已在其他部分说明。  \n\n识别方式：检查是否存在非必要的修饰成分（如传入参数、URL锚点）或重复步骤，导致句子冗长且核心信息模糊。"
    },
    {
      "defect_id": 41453,
      "sentence": "本模块首批接口从API version 7 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "",
      "修改建议": "句子包含过多的修饰成分，信息过于冗长。",
      "更改后示例": "本模块从API version 7开始支持。后续版本的新增接口，使用上角标标记起始版本。",
      "触发条件": "当句子中出现重复限定词（如“首批接口”与“后续新增接口”的隐性重复）或动词短语包含冗余修饰成分（如“单独标记”隐含多余描述）时触发。\n\n识别模式：\n1. **重复限定词**：检查同一语义范畴内是否存在显性/隐性重复描述（如“首批”与“后续”形成版本范围对比时，前者可被模块主体隐含）；\n2. **冗余修饰语**：识别动词短语中可删除的副词/形容词（如“单独标记”中“单独”未提供增量信息）。"
    },
    {
      "defect_id": 41274,
      "sentence": "本模块首批接口从API version 9 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "",
      "修改建议": "句子过长，信息量大，应拆分为两个独立的句子。",
      "更改后示例": "本模块首批接口从API version 9 开始支持。后续版本的新增接口将使用上角标标记起始版本。",
      "触发条件": "同一分句内存在多个动词短语（如“采用”与“标记”）或重复性限定词（如“单独”“接口的”），导致语义重叠或句式冗余。\n\n识别模式：当句子包含连续动作描述（动词+宾语+修饰语）且上下文已隐含逻辑关系时，需检查是否存在可合并的动词结构（例：“采用...标记”简化为“使用...标记”）或可删除的冗余限定词（例：“接口的”在“新增接口”后无需重复）。"
    },
    {
      "defect_id": 41457,
      "sentence": "是否压缩应用包的本地库，取值为true表示压缩应用包的本地库，取值为false表示不压缩应用包的本地库。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "",
      "修改建议": "句子包含过多的修饰成分，信息过于冗长。",
      "更改后示例": "是否压缩应用包的本地库。true表示压缩，false表示不压缩。",
      "触发条件": "当参数取值说明重复主句核心宾语（如\"应用包的本地库\"），或相邻分句重复相同名词短语时触发。具体表现为参数true/false解释中重复出现主句已明确的对象。\n\n识别模式：检测\"取值为X表示...，取值为Y表示...\"结构，若发现解释性分句重复主句宾语（通常伴随动宾结构重复），则判定为冗余。例如动词\"压缩\"后的宾语在主句和分句中完全重复时需简化。"
    },
    {
      "defect_id": 41357,
      "sentence": "标识自定义数据项的键名称。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "",
      "修改建议": "原文中包含不必要的修饰成分。",
      "更改后示例": "自定义数据项的键名称。",
      "触发条件": "当名词短语中的动词或形容词修饰语所表达的含义已被中心名词本身隐含或涵盖时（如“键名称”已隐含“标识”功能，“编写方法”中“方法”已隐含创建行为）。"
    },
    {
      "defect_id": 41358,
      "sentence": "标识自定义数据项的值名称。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "",
      "修改建议": "原文中包含不必要的修饰成分。",
      "更改后示例": "自定义数据项的值名称。",
      "触发条件": "当句子中存在可删除的动词/形容词修饰成分，且该成分不提供新信息、仅重复后续名词隐含语义时。\n\n识别模式：检查是否存在「动词+名词」结构中，名词本身已隐含动词含义的情况（如「标识名称」中「名称」自带标识属性），或形容词与名词存在语义重叠（如「圆形形状」）。通过语义分析确认修饰成分是否冗余。"
    },
    {
      "defect_id": 41468,
      "sentence": "应用运行时需向系统申请的权限集合的详细信息。",
      "reference_sentence": "",
      "line_num": 46,
      "context": "",
      "修改建议": "句子较长，且有不必要的修饰成分。",
      "更改后示例": "应用运行时需申请的权限集合。",
      "触发条件": "句子中存在可被删除而不影响核心语义的重复性修饰成分（如冗余介词短语、冗余限定词）或同义重复结构。\n\n识别模式：检查是否包含以下情况——① 介词短语（如“向系统”）与上下文存在隐含重复；② 抽象名词（如“集合”）后叠加说明性名词短语（如“详细信息”）；③ 动词（如“申请”）已隐含动作对象时仍添加说明性状语。"
    },
    {
      "defect_id": 44158,
      "sentence": "应用程序分身的索引。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "",
      "修改建议": "使用了不必要的修饰成分。",
      "更改后示例": "分身索引。",
      "触发条件": "名词短语中存在可被上下文或核心名词隐含的不必要修饰词时触发，例如当修饰成分与核心名词存在语义重复（如\"应用程序分身\"中\"应用程序\"可被\"分身\"隐含），或修饰词在特定场景下冗余时。"
    },
    {
      "defect_id": 41469,
      "sentence": "以下各项对应的系统能力均为SystemCapability.BundleManager.BundleFramework",
      "reference_sentence": "",
      "line_num": 12,
      "context": "",
      "修改建议": "句子较长，且有不必要的修饰成分。",
      "更改后示例": "系统能力：SystemCapability.BundleManager.BundleFramework",
      "触发条件": "句子中包含引导性冗余短语（如“以下各项对应的”）或重复性判断词（如“均为”），且核心信息（如系统能力名称）可通过直接陈述简化表达时触发。\n\n识别模式：  \n1. **冗余引导结构**：检测类似“以下...对应的...均为”的模板化长句引导语。  \n2. **重复判断词**：存在“均为”“均为同一”等冗余判断词，且后接唯一/重复内容。  \n3. **复合句式简化可能**：核心信息（如系统能力）在复合结构中重复出现，可被提取为“关键词: 值”的简洁格式。"
    },
    {
      "defect_id": 41458,
      "sentence": "Entry是否支持免安装，取值为true表示支持免安装，取值为false表示不支持免安装。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "",
      "修改建议": "句子包含过多的修饰成分，信息过于冗长。",
      "更改后示例": "Entry是否支持免安装。true表示支持，false表示不支持。",
      "触发条件": "句子中重复使用同一名词或短语解释布尔值含义，或在解释取值时冗余复述前文已明确的信息。  \n\n识别模式：当出现“取值为X表示...(重复前文名词)”或“X表示...(冗余复述前文完整描述)”结构时，需删除重复成分（如“取值为”“免安装”）并保留核心逻辑（如“true表示支持”）。"
    },
    {
      "defect_id": 43133,
      "sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "",
      "修改建议": "句子较长，信息量大，应简化。",
      "更改后示例": "权限等级参考权限APL等级说明。",
      "触发条件": "当句子中存在内部文档链接且链接文本已完整涵盖引用内容的关键信息时，或链接锚点描述与上下文形成重复解释时。  \n识别模式：检测到Markdown超链接语法，且链接文本本身已具备自解释性（如含专业术语/文档标题），同时链接指向同一文档内部章节补充说明。"
    },
    {
      "defect_id": 41359,
      "sentence": "标识用户自定义数据格式，标签值为标识该数据的资源的索引值。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "",
      "修改建议": "原文中包含不必要的修饰成分。",
      "更改后示例": "用户自定义数据格式，标签值为资源的索引值。",
      "触发条件": "当句子中出现重复限定同一名词的修饰成分（如“标识该数据的资源”中“标识该数据的”与上下文隐含信息重复），或存在可通过前置语境推断的冗余描述时触发。"
    },
    {
      "defect_id": 42831,
      "sentence": "type  | string | 是    | 要重置的应用类型，取[ApplicationType](js-apis-defaultAppManager.md#defaultappmanagerapplicationtype)中的值，或者符合媒体类型格式的文件类型，或者[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)类型。       |",
      "reference_sentence": "",
      "line_num": 642,
      "context": "",
      "修改建议": "说明部分过长，且包含不必要的修饰。",
      "更改后示例": "type | string | 是 | 应用类型，取值见[ApplicationType](js-apis-defaultAppManager.md#defaultappmanagerapplicationtype)或[UniformDataType](../apis-arkdata/js-apis-data-uniformTypeDescriptor.md)。",
      "触发条件": "参数描述中存在冗余的动词短语修饰（如\"要重置的\"）、重复的选项说明（如\"或者...\"多级并列结构），或可合并的外部引用链接时触发。\n\n识别模式：\n1. 存在非必要的动词短语（如\"要...的\"结构）\n2. 出现多个\"或\"连接的重复选项类型\n3. 包含可被引用文档覆盖的细节描述（如媒体类型格式说明）\n4. 同一参数关联多个外部链接但未合并说明"
    },
    {
      "defect_id": 44067,
      "sentence": "权限的标签ID。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "",
      "修改建议": "原文可以更简洁。",
      "更改后示例": "权限标签ID。",
      "触发条件": "名词短语中存在冗余结构助词\"的\"字，且删除后能保持原意并提升简洁性。具体表现为：当中心词(如\"标签ID\")的前置修饰语(如\"权限\")本身可直接构成复合名词时，应删除\"的\"字结构。"
    },
    {
      "defect_id": 44064,
      "sentence": "本模块首批接口从API version 9 开始支持。后续版本的新增接口，采用上角标单独标记接口的起始版本。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "",
      "修改建议": "原文过于啰嗦，且包含不必要的修饰成分。",
      "更改后示例": "本模块接口从API version 9开始支持，新增接口用上角标标记起始版本。",
      "触发条件": "同一概念被重复说明（如\"首批接口\"与\"新增接口\"构成冗余对比），或存在可合并的修饰成分（如\"采用上角标单独标记\"中的冗余副词）。\n\n识别模式：\n1. 检查是否存在同义/近义重复结构（如\"首批...后续新增...\"）\n2. 分析修饰成分必要性（如\"单独\"在标记动作中无实际语义增量）\n3. 验证信息密度是否过低（原文用2句表达可用1句涵盖的内容）"
    },
    {
      "defect_id": 44066,
      "sentence": "权限的授予模式。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "",
      "修改建议": "原文可以更简洁。",
      "更改后示例": "权限授予模式。",
      "触发条件": "当名词短语中出现冗余结构助词「的」（如「A的B」可简化为「AB」复合名词），且删除后语义不变时触发。  \n\n识别模式：  \n1. 检测「的」字前后均为名词性成分（如「权限的授予」→「权限授予」）  \n2.验证简化后复合名词是否符合领域术语习惯（如技术文档常用「权限授予」而非带「的」结构）"
    },
    {
      "defect_id": 44146,
      "sentence": "快捷方式的目标moduleName。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "",
      "修改建议": "使用了不必要的修饰成分。",
      "更改后示例": "目标moduleName。",
      "触发条件": "名词前存在冗余修饰成分（如重复属性、上下文已隐含信息），且删除后不影响核心语义。\n\n识别模式：\n1. **结构检测**：定位“核心名词+的+属性名词”或“修饰语+核心名词”组合（如“目标moduleName”）。\n2. **语义验证**：修饰成分与核心名词存在隐含重复（如“快捷方式”的用途已隐含“目标”属性），或上下文已明确相关属性（如全局讨论moduleName时无需强调“目标”）。"
    },
    {
      "defect_id": 43852,
      "sentence": "标识[路由表配置文件](../../quick-start/module-configuration-file.md#routermap标签)中的字符串自定义数据，即data字段的信息，该字段已由系统解析，无需开发者自行解析。",
      "reference_sentence": "",
      "line_num": 75,
      "context": "",
      "修改建议": "句子过长，可以简化。",
      "更改后示例": "标识路由表配置文件中的字符串自定义数据。",
      "触发条件": "句子包含重复解释性内容（如“该字段已由系统解析”），或存在可通过上下文/技术常识推断的冗余技术细节（如“无需自行解析”）。"
    },
    {
      "defect_id": 42762,
      "sentence": "当前页面仅包含本模块的系统接口，其他公开接口参见[`@ohos.bundle.defaultAppManager`](js-apis-defaultAppManager.md)。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "",
      "修改建议": "句子过长，信息过多。",
      "更改后示例": "当前页面包含本模块的系统接口。其他公开接口参见文档。",
      "触发条件": "句子中同时存在限定词（如“仅”“只”）与补充说明信息，且两者形成冗余或矛盾；或单句包含多个信息层导致结构臃肿。"
    },
    {
      "defect_id": 43131,
      "sentence": "本模块提供免安装相关的设置和查询能力，支持BundlePackInfo、DispatchInfo等信息的查询。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "",
      "修改建议": "句子较长，信息量大，应简化。",
      "更改后示例": "本模块提供免安装设置和查询，支持BundlePackInfo和DispatchInfo查询。",
      "触发条件": "当句子中出现冗余的名词修饰语（如“相关的”“等信息”）或动词后附加抽象名词（如“能力”）时，或存在可简化的并列结构（如顿号列举+“等信息”）时触发。识别模式需检测“相关+的”“等+信息”“支持/提供+抽象名词”等句式，以及冗余补充说明的列举结构。"
    },
    {
      "defect_id": 44068,
      "sentence": "描述权限的ID。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "",
      "修改建议": "原文可以更简洁。",
      "更改后示例": "权限描述ID。",
      "触发条件": "名词短语中存在动词或动名词修饰结构（如“描述权限”），且后续叠加另一名词（如“ID”）形成冗余层级时。  \n\n识别模式：  \n1. **结构检测**：识别“动词/动名词+名词1+名词2”组合（如“描述权限的ID”），其中动词/动名词修饰名词1，而名词1与名词2存在从属关系。  \n2. **冗余判断**：若动词/动名词可转换为名词性修饰语（如“权限描述”直接修饰“ID”），则判定为冗余，需合并为复合名词结构（如“权限描述ID”）。"
    },
    {
      "defect_id": 44145,
      "sentence": "快捷方式的目标bundleName。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "",
      "修改建议": "使用了不必要的修饰成分。",
      "更改后示例": "目标bundleName。",
      "触发条件": "名词短语中存在冗余修饰成分，即修饰语与中心词在语义或上下文中存在重复、隐含关系，导致信息冗余。\n\n识别模式：\n1. 中心词已包含修饰语的核心属性（如\"目标\"已隐含归属关系）\n2. 上下文环境已明确修饰语指代对象（如系统仅处理快捷场景时，\"快捷方式的\"无需显式声明）\n3. 修饰语与中心词构成同义反复结构（如\"圆形形状\"→\"形状\"）\n4. 使用通用限定词+专业术语组合时（如\"最终的结束时间\"→\"结束时间\"）"
    },
    {
      "defect_id": 42763,
      "sentence": "权限等级参考[权限APL等级说明](../../security/AccessToken/app-permission-mgmt-overview.md#权限机制中的基本概念)。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "",
      "修改建议": "句子过长，信息过多。",
      "更改后示例": "权限等级详见文档。",
      "触发条件": "当句子中存在详细引用（如超链接/文档路径）且伴随冗余描述（重复链接文本核心信息），或链接前的描述性文字与链接锚文本形成语义重复时触发。\n\n识别模式：\n1. 结构特征：出现超链接标记或文档路径引用\n2.语义特征：链接前文字与链接锚文本存在重复核心词（如案例中\"权限等级\"与\"权限APL等级说明\"）\n3.冗余表现：链接描述性文字可被\"详见文档\"等通用表述替代而不影响信息完整性"
    },
    {
      "defect_id": 43738,
      "sentence": "三方应用可以通过[bundleManager.getBundleInfoForSelf](js-apis-bundleManager.md#bundlemanagergetbundleinfoforself)获取自身的ExtensionAbility信息，其中入参[bundleFlags](js-apis-bundleManager.md#bundleflag)至少包含GET_BUNDLE_INFO_WITH_HAP_MODULE和GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "三方应用通过[bundleManager.getBundleInfoForSelf](js-apis-bundleManager.md#bundlemanagergetbundleinfoforself)获取自身的ExtensionAbility信息。入参[bundleFlags]至少包含GET_BUNDLE_INFO_WITH_HAP_MODULE和GET_BUNDLE_INFO_WITH_EXTENSION_ABILITY。",
      "触发条件": "当单句包含两个及以上独立信息点（如操作步骤+参数说明）且使用连词/逗号连接时，或句子长度超过25词并存在分项说明结构（如\"其中...\"）时触发。"
    },
    {
      "defect_id": 49034,
      "sentence": "为了实现[Sendable数据](#sendable支持的数据类型)在不同并发实例间的引用传递，Sendable共享对象会分配在共享堆中，以实现跨并发实例的内存共享。",
      "reference_sentence": "",
      "line_num": 99,
      "context": "",
      "修改建议": "原文过于啰嗦，包含不必要的修饰成分。",
      "更改后示例": "Sendable共享对象分配在共享堆中，实现跨并发实例的内存共享。",
      "触发条件": "句子中包含重复或冗余的目的状语（如“为了实现...”与“以实现...”）或修饰成分，导致同一功能被多次说明。  \n\n识别模式：检查是否存在前后重复的状语结构（如“为了X，...以实现X”），或修饰语与核心信息重复（如“共享对象”与“共享堆”）。若删除冗余部分后核心语义未损失，则需修复。"
    },
    {
      "defect_id": 49038,
      "sentence": "允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，@Sendable装饰的函数或类对象内还支持访问本文件导出的变量。",
      "reference_sentence": "",
      "line_num": 123,
      "context": "",
      "修改建议": "原文包含不必要的修饰成分，且句子过长。",
      "更改后示例": "允许使用local变量、入参和通过import引入的变量。禁止使用闭包变量，定义在顶层的Sendable class和Sendable function除外。从API version 18开始，支持访问本文件导出的变量。",
      "触发条件": "当句子包含可被上下文推断的重复修饰成分（如\"@Sendable装饰的函数或类对象内还\"），或通过多个语法嵌套/并列结构表达单一限制条件时触发。识别模式需满足以下任意特征：\n1. 存在与上下文重复的限定词（如装饰器/作用域说明）\n2. 使用\"还支持/例外情况\"等递进表述时未删除前文已覆盖的限制条件\n3. 同一语义单元包含超过2个逻辑层级（如时间条件+作用域条件+访问权限条件）"
    },
    {
      "defect_id": 48986,
      "sentence": "跨线程传输时可以直接复用同一个C++对象，相比于JS对象的拷贝模式，传输效率较高。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "跨线程传输时复用同一个C++对象，传输效率高。",
      "触发条件": "当句子包含超过两个逗号分隔的独立信息单元，且存在可合并/删除的对比结构（如\"相比于...\"）或冗余限定词（如\"可以直接\"\"较高\"）时触发。\n\n识别模式：1) 通过标点统计识别多逗号长句 2) 检测对比连词（相比/相较于）和重复语义成分（如\"复用\"已隐含\"直接\"含义）3) 定位冗余程度副词（较/非常）与重复结论（效率较高→效率高）。"
    },
    {
      "defect_id": 48934,
      "sentence": "可以使用[@Sendable装饰器](./arkts-sendable.md#sendable装饰器)标识为Sendable类，类实例对象跨线程传递后，可携带类方法。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "",
      "修改建议": "句子内容可以更简洁。",
      "更改后示例": "使用[@Sendable装饰器](./arkts-sendable.md#sendable装饰器)标识类，类实例跨线程传递后可携带方法。",
      "触发条件": "当句子中存在重复修饰词（如\"类实例对象\"中的\"对象\"）或上下文已隐含的冗余限定词（如\"Sendable类\"在装饰器名称已明确时），且删除后不影响语义完整性时触发。  \n\n识别模式：检测名词短语中是否存在语义重复成分（如\"类方法\"→\"方法\"）或修饰词与上下文存在显性重复（如\"标识为Sendable类\"→\"标识类\"），同时验证删除冗余词后逻辑是否仍自洽。"
    },
    {
      "defect_id": 45558,
      "sentence": "HAP存放路径，支持当前应用程序的绝对路径和数据目录沙箱路径。",
      "reference_sentence": "",
      "line_num": 620,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "支持当前应用程序的绝对路径和数据目录沙箱路径。",
      "触发条件": "当句子中重复出现同一核心名词短语（如\"路径\"），或存在可被更简洁结构替代的冗余修饰成分（如重复说明同一主题的引导语）时触发。\n\n识别模式：\n1. 前导名词短语与后续解释内容存在语义重叠（如\"存放路径\"与\"绝对路径/沙箱路径\"）\n2. 存在可删除的引导性短语而不影响核心信息完整性（如删除\"HAP存放路径\"后语义依然完整）"
    },
    {
      "defect_id": 42882,
      "sentence": "需要频繁取消的任务。例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "需要频繁取消的任务，例如图库大图浏览，滑动时取消缓存任务，使用TaskPool。",
      "触发条件": "句子包含多个逗号分隔的冗余修饰成分（如场景描述、技术细节、目的说明），或存在可合并/删除的非必要信息块。  \n\n识别模式：  \n1. 逗号数量≥3且存在嵌套因果/目的描述（如\"为提升体验，会...\"）  \n2. 包含可简化的具体数值说明（如\"各2张图片\"）或重复场景关键词（如\"图库大图浏览场景\"中的\"场景\"冗余）"
    },
    {
      "defect_id": 48988,
      "sentence": "常见的共享模式NativeBinding对象包括Context，Context对象包含应用程序组件的上下文信息，它提供了一种访问系统服务和资源的方式，使得应用程序组件可以与系统进行交互。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "常见的共享模式NativeBinding对象包括Context。Context对象包含应用程序组件的上下文信息，提供访问系统服务和资源的方式。",
      "触发条件": "句子中包含由多个逗号连接的独立分句，且存在重复指代同一主体的名词/代词（如\"Context，Context对象\"连续出现）。  \n\n识别模式：  \n1. 连续分句检测：通过标点统计识别超过2个逗号的长复合句  \n2. 重复指代检测：相邻分句中出现相同主体名词及其代词化表达（如\"Context\"→\"它\"）  \n3. 功能词验证：伴随\"使得\"\"提供了一种...的方式\"等冗余连接结构"
    },
    {
      "defect_id": 43555,
      "sentence": "注册onAllErrors回调，可以捕获Worker线程的onmessage回调、timer回调以及文件执行等流程产生的全局异常，在宿主线程执行",
      "reference_sentence": "",
      "line_num": 227,
      "context": "",
      "修改建议": "原句包含不必要的修饰成分。",
      "更改后示例": "注册onAllErrors回调，捕获Worker线程的全局异常，在宿主线程执行。",
      "触发条件": "当句子中出现用并列结构列举具体示例，且这些示例已被前文的高层次概念完全涵盖时（如\"全局异常\"已隐含包含\"onmessage回调、timer回调\"等具体场景），触发冗余表达规则。"
    },
    {
      "defect_id": 48985,
      "sentence": "Transferable对象（也称为NativeBinding对象）指的是一个JS对象，绑定了一个C++对象，且主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "Transferable对象，也称为NativeBinding对象，是指绑定C++对象的JS对象，主体功能由C++提供。JS对象壳分配在虚拟机本地堆。",
      "触发条件": "句子包含超过两个逗号分隔的独立信息点，且存在可拆分的复合结构（如定义+别名+功能描述+位置说明）。通过检测长句内多层级修饰关系、重复逻辑连接词（如\"且\"\"其\"）或超过3个分句的堆叠式表达进行识别。"
    },
    {
      "defect_id": 42881,
      "sentence": "需要设置优先级的任务。在API version 18 之前，Worker不支持设置调度优先级，需要使用TaskPool。从API version 18 开始，Worker支持设置调度优先级，开发者可以根据使用场景和任务特性选择使用TaskPool或Worker。例如图库直方图绘制场景，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，且任务相对独立，推荐使用TaskPool。",
      "reference_sentence": "",
      "line_num": 45,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "需要设置优先级的任务，API version 18 之前使用TaskPool，之后Worker也支持。例如图库直方图绘制，后台计算的数据用于前台显示，推荐使用TaskPool。",
      "触发条件": "当句子结构复杂（如多个逗号分隔的长句）且包含重复信息或冗余修饰（如版本对比、场景重复说明）时触发。  \n\n识别模式：  \n1. **结构复杂**：检查是否使用超过三个逗号分隔的独立语义片段，导致理解负担。  \n2. **冗余内容**：识别重复的时间/版本对比（如“API version X之前/之后”）、场景重复解释（如任务特性与示例内容重叠）或非必要的修饰词（如“影响用户体验”隐含在上下文中）。"
    },
    {
      "defect_id": 49024,
      "sentence": "而开发者仍然还有大量对象并发通信的诉求，这个问题在业界的JS引擎实现上并没有得到解决。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中未得到解决。",
      "触发条件": "句子中出现重复副词叠加（如\"仍然还有\"）或冗余修饰结构（如\"在...实现上\"），导致表达冗余累赘时触发；当专业术语存在更简洁的同义表达（如\"诉求\"→\"需求\"）且不影响语义时触发。"
    },
    {
      "defect_id": 49033,
      "sentence": "对象字面量、数组字面量在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，对象字面量和数组字面量不是Sendable类型。",
      "reference_sentence": "",
      "line_num": 94,
      "context": "",
      "修改建议": "原文过于啰嗦，包含不必要的修饰成分。",
      "更改后示例": "对象字面量和数组字面量在并发实例间传递时遵循结构化克隆算法，因此不是Sendable类型。",
      "触发条件": "当同一概念被不同表达方式重复说明（如\"跨线程行为是拷贝传递\"与\"遵循结构化克隆算法\"），或存在不影响核心信息的冗余修饰成分（如\"并发实例间的传递\"与\"跨线程行为\"双重修饰）时触发。\n\n识别模式：\n1. 相邻分句存在语义重叠（如算法描述+行为描述指向同一机制）\n2. 出现重复限定词（如\"对象字面量和数组字面量\"在前后分句重复出现）\n3. 修饰成分未增加新信息（如\"拷贝传递\"未超出\"结构化克隆算法\"的语义范畴）"
    },
    {
      "defect_id": 49035,
      "sentence": "各个并发实例间的LocalHeap是隔离的，SharedHeap是进程级别的堆，可以被所有的并发实例引用。但是SharedHeap不能引用LocalHeap中的对象。",
      "reference_sentence": "",
      "line_num": 108,
      "context": "",
      "修改建议": "原文包含不必要的修饰成分，且句子过长。",
      "更改后示例": "各个并发实例的LocalHeap是隔离的，SharedHeap是进程级别的堆，可以被所有并发实例引用，但不能引用LocalHeap中的对象。",
      "触发条件": "句子中出现重复性限定词（如\"各个\"+\"所有\"）或冗余转折词（如\"但是\"+\"不能\"），且存在可合并的复合句结构时触发。\n\n识别模式：\n1. 检测相邻分句存在同范畴复数限定词（如\"各个\"与\"所有\"指向同一对象群）\n2. 识别转折连词后接否定表达时，检查前文是否已隐含逻辑转折关系\n3. 分析句子结构复杂度（本例从2个独立句合并为1个复合句，减少7字）\n4. 验证修饰成分必要性（如\"的LocalHeap\"在上下文明确时可省略所属格）"
    },
    {
      "defect_id": 49178,
      "sentence": "Sendable对象布局及原型链不可变，非Sendable对象可以通过特殊方式修改布局，不允许互相继承。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "Sendable对象布局及原型链不可变。非Sendable对象可以通过特殊方式修改布局。不允许互相继承。",
      "触发条件": "当单句包含≥2个独立信息点且使用连接词/标点合并时，或句子结构复杂度超过单一主谓宾框架时触发。\n\n识别模式：\n1. 存在多个无逻辑从属关系的独立陈述（如\"A规则成立，B方法可用，C行为禁止\"）\n2. 使用非必要连接词（及/并且/同时等）或标点强行合并独立语义单元\n3. 出现≥2个互不隶属的主语-谓语结构（如\"X不可变，Y可修改，Z不允许\"）"
    },
    {
      "defect_id": 48987,
      "sentence": "因此，可共享或转移的NativeBinding对象也被称为Transferable对象。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "",
      "修改建议": "句子可以简化。",
      "更改后示例": "因此，可共享或转移的NativeBinding对象称为Transferable对象。",
      "触发条件": "句子中出现冗余副词（如“也”）与“称为”等命名类动词连用，且上下文未强调对比或补充关系时触发。\n\n识别模式：当检测到“也被称为”“还称作”等结构时，需判断“也/还”是否必要。若删除后句意不变且更简洁（如无其他命名对象对比），则判定为冗余表达。"
    },
    {
      "defect_id": 43563,
      "sentence": "需要注意多级Worker生命周期的正确管理。若用户销毁父Worker时未能结束其子Worker的运行，会产生不可预期的结果。",
      "reference_sentence": "",
      "line_num": 351,
      "context": "",
      "修改建议": "原文表述过于冗长，可以简化。",
      "更改后示例": "确保多级Worker生命周期管理正确。销毁父Worker前，先销毁所有子Worker。",
      "触发条件": "当句子同时存在冗余引导词(如\"需要注意\")+复杂条件从句(\"若...未能...，会...\")结构时触发，或同一语义通过主从句重复表达时触发。\n\n识别模式：\n1. 前导句使用抽象建议动词(\"需注意/应当保证\")，后续句展开具体场景\n2. 包含\"若...未能...，会...\"的条件-结果嵌套结构\n3. 主从复合句表达单一因果关系，可用单句合并(如改为\"确保...先...\")"
    },
    {
      "defect_id": 43556,
      "sentence": "当Worker对象接收到一条无法被序列化的消息时被调用，在宿主线程执行",
      "reference_sentence": "",
      "line_num": 232,
      "context": "",
      "修改建议": "原句包含不必要的修饰成分。",
      "更改后示例": "当Worker对象接收到无法序列化的消息时被调用，在宿主线程执行。",
      "触发条件": "当句子中存在可省略而不影响原意的量词（如\"一条\"）或被动结构中的冗余助词（如\"被\"）时触发，需满足删除后语义完整且表达更简洁。"
    },
    {
      "defect_id": 49156,
      "sentence": "以下Node-API接口通常在Node-API模块中操作ArrayBuffer类型的数据。以下是一些可能的使用场景：",
      "reference_sentence": "",
      "line_num": 14,
      "context": "",
      "修改建议": "重复信息。",
      "更改后示例": "以下Node-API接口用于操作ArrayBuffer类型的数据。",
      "触发条件": "相邻语句或分句中出现重复的主题词（如\"Node-API接口\"）且后续内容未提供新信息，或存在结构性重复短语（如连续使用\"以下...\"开头的引导句）。识别需检测语句中重复的名词短语、相同句式结构及语义重叠（如功能描述与应用场景说明的冗余组合）。"
    },
    {
      "defect_id": 49181,
      "sentence": "Sendable数据不能持有非Sendable数据，因此Sendable数据的成员属性必须为Sendable数据。",
      "reference_sentence": "",
      "line_num": 104,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "Sendable数据的成员属性必须为Sendable数据。",
      "触发条件": "句子中同时包含因果关系表述（如\"因此\"）和重复结论，且结论部分可独立成立无需前置说明时触发。\n\n识别模式：1.存在\"因此/所以\"等因果连词连接两个语义重复的分句 2.后半句结论本身已隐含前半句的前提条件（如本例中\"必须为Sendable\"已隐含\"不能持有非Sendable\"）3.删除原因分句后核心规则表述依然完整且更简洁。"
    },
    {
      "defect_id": 43558,
      "sentence": "当Worker线程收到来自其宿主线程通过postMessage接口发送的消息时被调用，在Worker线程执行",
      "reference_sentence": "",
      "line_num": 261,
      "context": "",
      "修改建议": "原句包含不必要的修饰成分。",
      "更改后示例": "当Worker线程收到来自宿主线程的消息时被调用，在Worker线程执行。",
      "触发条件": "当句子中存在重复指代（如\"其宿主线程\"中的冗余所有格）或已知技术细节（如\"postMessage接口发送\"的隐含行为）的冗余修饰成分时触发。\n\n识别模式：\n1. 重复指代：检查所有格代词是否与上下文存在重复指代（如\"宿主线程\"本身已隐含所属关系）\n2.技术冗余：识别特定技术场景中可省略的接口/机制说明（如postMessage作为标准通信接口的常识性） \n3.修饰成分必要性：通过删除测试验证短语核心语义是否完整（如删除\"通过postMessage接口发送的\"后仍保持技术准确性）"
    },
    {
      "defect_id": 49179,
      "sentence": "由于非Sendable对象可以通过特殊方式修改布局，因此不允许互相继承。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "非Sendable对象可以通过特殊方式修改布局。不允许互相继承。",
      "触发条件": "复合句中使用因果连接词（如\"由于...因此\"）连接两个独立信息点，且分句间逻辑关系可通过拆分独立陈述更清晰表达时。\n\n识别模式：\n1. 存在\"因为/由于...所以/因此\"等因果连接结构\n2. 前后分句表达独立语义单元（如\"特性描述+行为规范\"）\n3. 拆分后句子仍保持完整语义且衔接自然\n4. 总字数超过25字或包含多层嵌套结构（附加条件）"
    },
    {
      "defect_id": 49415,
      "sentence": "由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中仅支持异步锁（非阻塞式锁）。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "",
      "修改建议": "句子结构复杂，修饰成分过多。",
      "更改后示例": "ArkTS支持异步操作，仅使用异步锁，避免死锁。",
      "触发条件": "句子包含因果连词（如“由于”“因此”）导致结构冗余，或存在重复解释同一概念（如括号补充说明）。识别模式为：因果复合句可简化为单句，或修饰语与核心信息重复（如“异步锁”与“非阻塞式锁”）。"
    },
    {
      "defect_id": 42883,
      "sentence": "大量或者调度点较分散的任务。例如大型应用的多个模块包含多个耗时任务，不方便使用Worker去做负载管理，推荐采用TaskPool。",
      "reference_sentence": "",
      "line_num": 49,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "大量或调度点分散的任务，例如大型应用的多个模块包含多个耗时任务，推荐使用TaskPool。",
      "触发条件": "句子中存在冗余连词（如“或者”替代“或”）或冗余修饰词（如“较”），且由多个逗号分隔的长句导致表意重复。  \n识别模式：检测并列连词冗余（例如“或者”可简化为“或”）、形容词前冗余程度副词（如“较分散”可简化为“分散”），并判断长句是否因多从句结构产生冗余信息。"
    },
    {
      "defect_id": 49182,
      "sentence": "Sendable对象的布局不可变，计算属性不能静态确定对象布局，因此不支持。",
      "reference_sentence": "",
      "line_num": 158,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "Sendable对象的布局不可变。不支持使用计算属性。",
      "触发条件": "句子包含两个及以上独立信息点且使用冗余因果/并列连词合并，或同一语义重复出现在不同分句中。识别模式为长复合句含多个逗号分隔的独立逻辑单元，并存在\"因此\"\"所以\"等显性推导词。"
    },
    {
      "defect_id": 49186,
      "sentence": "对象字面量/数组字面量是非Sendable类型，Sendable数据类型只能通过Sendable类型的new表达式创建。",
      "reference_sentence": "",
      "line_num": 318,
      "context": "",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "对象字面量/数组字面量是非Sendable类型。Sendable数据类型只能通过Sendable类型的new表达式创建。",
      "触发条件": "句子中包含由逗号连接的多个独立信息点（如不同规则或概念），且缺乏逻辑连接词导致结构冗余；或单句长度过长导致可读性下降。  \n\n识别模式：通过检测逗号分隔的独立子句（如“A是X类型，B只能通过Y创建”）、检查是否存在多个无关联的主谓结构，并结合句长阈值判断是否需要拆分。"
    },
    {
      "defect_id": 92174,
      "sentence": "从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "该接口从API version 11开始支持在原子化服务中使用。",
      "触发条件": "句子中存在由逗号分隔的多个独立分句，且状语成分（如时间/条件状语）可融入主句结构。识别模式为：逗号分割导致信息断层，状语前置造成主谓分离。"
    },
    {
      "defect_id": 50955,
      "sentence": "返回系统配置信息，当获取的系统配置不存在时，返回-1。",
      "reference_sentence": "",
      "line_num": 538,
      "context": "",
      "修改建议": "句子过长，包含过多的逗号。",
      "更改后示例": "返回系统配置信息。如果配置不存在，返回-1。",
      "触发条件": "句子包含由逗号连接的多个独立分句（特别是存在条件状语分句），且分句间逻辑关系可通过拆分短句/简化连词优化时；或使用\"当...时\"等冗余引导词替代更简洁的条件表达结构。"
    },
    {
      "defect_id": 102409,
      "sentence": "以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 586,
      "context": "",
      "修改建议": "原文信息过多，可以简化。",
      "更改后示例": "错误码详情见[通用错误码说明文档](../errorcode-universal.md)。",
      "触发条件": "当句子中存在不影响核心信息的冗余修饰词（如\"以下\"、\"详细\"等）或重复性指示结构（如\"请参见\"），且删除后能提升表达简洁性时触发。识别模式应检测\"请+动词\"的礼貌冗余结构及同义重复（如\"详情\"与\"详细\"同时出现）。"
    },
    {
      "defect_id": 53173,
      "sentence": "constructor是URI的构造函数。",
      "reference_sentence": "",
      "line_num": 137,
      "context": "",
      "修改建议": "原文不够简洁，可以更直接陈述。",
      "更改后示例": "构造函数用于创建URI对象。",
      "触发条件": "句子中同时出现同一概念的中英文术语重复（如“constructor”和“构造函数”），或使用冗余修饰结构（如“X是Y的构造函数”中隐含双重定义）。  \n\n识别模式：  \n1. **术语重复**：检测中英文术语并列（如“URI的构造函数”前出现“constructor”）；  \n2. **冗余修饰**：判断句式是否包含“是...的...”结构且主语与宾语存在语义重叠（如“构造函数是创建函数”）。"
    },
    {
      "defect_id": 50850,
      "sentence": "用于解析JSON字符串生成对应ArkTS对象或null。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "",
      "修改建议": "句子过于冗长，包含不必要的修饰。",
      "更改后示例": "解析JSON字符串生成ArkTS对象或null。",
      "触发条件": "句子中出现不影响核心语义的冗余介词（如“用于”）或重复性修饰词（如“对应”），导致表达臃肿且可被更简洁结构替代。"
    },
    {
      "defect_id": 50000,
      "sentence": "Sendable对象可以在不同并发实例间通过引用传递。通过引用传递方式传输对象相比序列化方式更加高效，同时不会丢失class上携带的成员方法。",
      "reference_sentence": "",
      "line_num": 2,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "Sendable对象可在不同并发实例间通过引用传递，比序列化方式更高效，不会丢失类方法。",
      "触发条件": "同一句子或相邻句子中存在重复描述同一概念的不同表达方式，或使用多个逗号分隔的复杂结构导致信息冗余时触发。\n\n识别模式：\n1. 重复性关键词检测：如\"通过引用传递方式传输对象\"与前半句\"通过引用传递\"构成重复\n2. 冗余对比结构：存在\"相比X方式更...\"的二次说明时，需检查前文是否已隐含比较对象\n3. 分句数量判断：单句超过2个逗号分隔的并列成分，且存在可合并的语义重复\n4. 信息重叠验证：后句主语与前句宾语重复（如\"对象\"重复出现），且未添加新信息维度"
    },
    {
      "defect_id": 50883,
      "sentence": "在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "",
      "修改建议": "句子过长，信息繁杂。",
      "更改后示例": "序列化时，每个属性都会经过该函数的转换处理。",
      "触发条件": "句子中存在可通过合并、简化或删除的重复修饰成分（如冗余介词短语、同义动词/名词并列）导致信息冗余或冗长时触发。\n\n具体识别模式：1）介词结构（如“在...过程中”）可替换为更简洁的时间状语（如“时”）；2）并列近义词（如“转换和处理”）；3）重复限定词（如“被序列化的值的”在前文已隐含主语时可删减）。"
    },
    {
      "defect_id": 49416,
      "sentence": "同时，异步锁还可以用于保证单线程内的异步任务时序一致性，防止异步任务时序不确定导致的同步问题。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "",
      "修改建议": "句子结构复杂，修饰成分过多。",
      "更改后示例": "异步锁保证单线程内的异步任务时序一致性，防止同步问题。",
      "触发条件": "句子中重复出现功能性动词短语（如“可以用于保证”）或存在多层嵌套修饰成分（如原因、目的、方式状语）导致语义冗余。  \n主谓结构被冗余介词框架（如“用于...”“通过...实现”）包裹，且核心动作与修饰成分存在语义重复时触发。  \n\n识别模式：  \n1. 功能性动词冗余：检测“用于做...”“用来实现...”等结构是否与后续核心动词重复（例：“可以用于保证”→直接保留“保证”）；  \n2. 修饰成分堆砌：定位连续因果关系描述（如“防止A导致的B”可简化为“防止B”）或重复限定词（如“异步任务时序不确定导致的”隐含在“同步问题”中）。"
    },
    {
      "defect_id": 50005,
      "sentence": "由于序列化传输实例对象时会丢失方法，在必须调用实例方法的场景中，需使用引用传递方式进行开发。在数据处理过程中有需要解析的数据，可使用[ASON工具](ason-parsing-generation.md)进行数据解析。",
      "reference_sentence": "",
      "line_num": 109,
      "context": "",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "序列化传输实例对象会丢失方法。在需要调用实例方法时，使用引用传递。数据处理中需要解析的数据，可使用[ASON工具](ason-parsing-generation.md)解析。",
      "触发条件": "句子包含连续逗号分隔的复杂从句结构，且存在重复性语义成分（如\"由于...时会\"双重因果表述、\"需使用...方式进行开发\"中动名词冗余）或可合并的相邻语义单元（如\"在数据处理过程中有需要解析的数据\"含嵌套定语结构）。"
    },
    {
      "defect_id": 101463,
      "sentence": "返回一个迭代器，迭代器的每一项都是一个 JavaScript 对象，并返回该对象。",
      "reference_sentence": "",
      "line_num": 863,
      "context": "",
      "修改建议": "原文存在冗余信息，建议简化。",
      "更改后示例": "返回一个迭代器，每一项都是一个JavaScript对象。",
      "触发条件": "同一句子或分句中重复提及相同主语/宾语且无新增语义成分，或存在同义动词短语的叠加使用。\n\n具体识别模式：\n1. 结构重复：前句已明确主体对象（如\"迭代器\"），后句重复使用相同主语限定词（如\"迭代器的\"）\n2. 动作冗余：使用相同动词（如\"返回\"）重复描述同一行为\n3. 信息闭环：后句未提供新信息，仅复述前句已说明的内容（如\"该对象\"指代前文已定义的JavaScript对象）"
    },
    {
      "defect_id": 102408,
      "sentence": "以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 541,
      "context": "",
      "修改建议": "原文信息过多，可以简化。",
      "更改后示例": "错误码详情见[通用错误码说明文档](../errorcode-universal.md)。",
      "触发条件": "当句子中存在可被更简洁术语替代的冗长表达（如\"详细介绍请参见\"→\"详情见\"），或包含非必要的礼貌用语（如\"请\"）时触发。识别模式需检测冗余修饰词（如\"详细\"+\"介绍\"）、重复语义（如\"以下\"在上下文中已隐含）及非技术性礼貌措辞。"
    },
    {
      "defect_id": 102407,
      "sentence": "以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。",
      "reference_sentence": "",
      "line_num": 502,
      "context": "",
      "修改建议": "原文信息过多，可以简化。",
      "更改后示例": "错误码详情见[通用错误码说明文档](../errorcode-universal.md)。",
      "触发条件": "当句子中存在冗余引导结构（如\"以下...请参见\"）或重复修饰语（如\"详细介绍\"与\"详情\"语义重复）时触发。\n\n识别模式：检测到\"以下...请参见\"引导句式，且同时存在\"详细\"+\"详情\"这类同义重复表达时，应判定为冗余结构。主要特征包括前置限定词冗余（\"以下\"）、请求式动词冗余（\"请\"）以及修饰语重复（\"详细\"+\"详情\"）。"
    },
    {
      "defect_id": 103668,
      "sentence": "用户登出事件。目前不支持订阅。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1022,
      "context": "",
      "修改建议": "原文使用了不必要的修饰成分和多个逗号。",
      "更改后示例": "用户登出事件。不支持订阅。",
      "触发条件": "句子中存在可省略的时间/状态修饰词（如“目前”）或冗余逗号分隔的短句结构，导致信息重复或松散表达。\n\n识别模式：\n1. 时间/状态冗余：当句子包含“当前”“目前”等词，但上下文已隐含时间范围（如API版本声明）时触发；\n2. 结构冗余：多个逗号连接的短句缺乏必要逻辑关联词，且核心信息可通过删除分隔符直接合并（如“目前不支持订阅”简化为“不支持订阅”）。"
    },
    {
      "defect_id": 103669,
      "sentence": "分布式服务启动事件。目前不支持订阅。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1023,
      "context": "",
      "修改建议": "原文使用了不必要的修饰成分和多个逗号。",
      "更改后示例": "分布式服务启动事件。不支持订阅。",
      "触发条件": "检测到存在不影响核心语义的时间状语(如\"目前\")或冗余程度副词，或出现多余逗号导致句子结构松散时触发。识别模式为：1) 时间状语+否定结构构成冗余(如\"目前不支持\")；2) 使用逗号分隔本应独立成句的短句(如事件描述与功能说明未恰当分段)。"
    },
    {
      "defect_id": 103667,
      "sentence": "用户登录事件。目前不支持订阅。<br>**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 1021,
      "context": "",
      "修改建议": "原文使用了不必要的修饰成分和多个逗号。",
      "更改后示例": "用户登录事件。不支持订阅。",
      "触发条件": "检测到句子中存在冗余时间状语（如“目前”“当前”）或重复性修饰成分，且删除后语义完整度不变；或出现多个逗号分割的复杂结构导致表达冗余。"
    },
    {
      "defect_id": 105617,
      "sentence": "获取内存分配器统计的进程业务分配的堆内存大小。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "获取内存分配器统计的堆内存大小。",
      "触发条件": "1) 名词短语中存在多层同范畴修饰语（如\"内存分配器统计的\"已隐含统计主体）2) 修饰成分未提供新的区分信息（如\"进程业务分配的\"未改变核心名词\"堆内存大小\"的语义指向）\n\n识别模式：检查连续出现的名词修饰结构（A的B的C），当内层修饰语（B）与外层修饰语（A）存在语义包含关系，或修饰语（B）未产生实际限定作用时，判定为冗余表达。"
    },
    {
      "defect_id": 105618,
      "sentence": "获取内存分配器持有的缓存内存大小。",
      "reference_sentence": "",
      "line_num": 63,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "获取内存分配器的缓存内存大小。",
      "触发条件": "句子中存在冗余修饰成分（如形容词、动词短语或介词短语），且该修饰成分与中心名词存在语义重复或隐含关系时触发。\n\n识别模式：  \n1. 检查名词前修饰语是否与名词本身的定义/属性重叠（如“缓存内存”隐含“被持有”，无需叠加“持有的”）。  \n2. 判断修饰成分是否未提供新信息（如“持有的”未改变核心语义“缓存内存大小”）。"
    },
    {
      "defect_id": 105681,
      "sentence": "用户自定义的profiling文件名，根据传入的`filename`，将在应用的`files`目录生成`filename.json`文件。",
      "reference_sentence": "",
      "line_num": 272,
      "context": "",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "用户自定义的profiling文件名，生成`filename.json`文件。",
      "触发条件": "句子中存在可被上下文推断的修饰成分（如\"根据传入的`filename`\"），或存在不影响核心信息的重复性位置描述（如\"在应用的`files`目录\"）。\n\n识别模式：\n1. 核心动作（如\"生成文件\"）已被明确，但被冗余的介词结构（\"根据...\"、\"在...目录\"）过度修饰；\n2. 修饰成分仅重复已知技术细节（如参数名、固定存储路径），未提供新信息。"
    },
    {
      "defect_id": 105660,
      "sentence": "文件描述符，该接口会往该fd中写入数据。",
      "reference_sentence": "",
      "line_num": 217,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "文件描述符，接口会向该fd写入数据。",
      "触发条件": "当句子中连续使用重复指代成分（如\"该接口\"中的冗余指示代词）或存在冗余介词结构（如\"往...中\"的方位词冗余）时触发。  \n\n识别模式：通过检测相邻分句/短语是否存在同主体重复指代（如\"该\"+\"接口\"双重限定），以及介词结构是否包含可省略的方位词（如\"往fd中\"简化为\"向fd\"），判断是否存在无实际语义价值的修饰成分。"
    },
    {
      "defect_id": 107142,
      "sentence": "下文将展示如何在应用内增加一个按钮，并单击该按钮以调用hidebug接口。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "在应用内增加按钮并调用hidebug接口。",
      "触发条件": "句子包含预告性引导短语（如\"下文将展示如何\"）或重复指代已提及的名词（如\"该按钮\"），且删除后不影响操作指导完整性。\n\n识别模式：\n1. 检测引导用户阅读路径的元话语（meta-discourse）结构\n2. 分析名词重复指代必要性，当后续动作与前置宾语存在明确逻辑关联时，\"该/此+名词\"通常冗余\n3. 验证删除修饰成分后核心操作步骤是否保持完整语义（本例保留\"增加按钮→调用接口\"的核心指令链）"
    },
    {
      "defect_id": 105709,
      "sentence": "用户自定义的虚拟机堆文件名，根据传入的`filename`，将在应用的`files`目录生成`filename.heapsnapshot`文件。",
      "reference_sentence": "",
      "line_num": 425,
      "context": "",
      "修改建议": "原文包含不必要的修饰成分，如“用户自定义的”、“根据传入的”等。",
      "更改后示例": "虚拟机堆文件名，将在应用的`files`目录生成`filename.heapsnapshot`文件。",
      "触发条件": "当句子中存在重复说明或可通过上下文/参数名直接推断的修饰成分（如冗余的所有者限定、显式参数来源说明）时触发。\n\n识别模式：  \n1. 检查形容词/介词结构是否与已知逻辑重复（如\"用户自定义的\"在参数场景中冗余）  \n2. 识别显式说明参数来源的介词结构（如\"根据传入的X\"在参数名已包含X时冗余）  \n3. 验证修饰成分删除后是否仍能保持技术准确性"
    },
    {
      "defect_id": 47142,
      "sentence": "Task对象及其挂载回调函数会在调用remove方法后释放并被系统自动回收。",
      "reference_sentence": "",
      "line_num": 2614,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分，且使用了过多的逗号。",
      "更改后示例": "调用remove方法后，Task对象及其挂载回调函数会被释放并自动回收。",
      "触发条件": "1)句子中存在重复语义的修饰成分（如\"被系统自动\"中的冗余主体）2)连续使用相同逻辑关系的连接词（如\"并\"）导致结构冗余\n\n识别模式：\n1. 检测被动语态中是否包含多余施动者（如\"被系统\"可简化为\"被\"）\n2. 分析并列结构中是否存在重复语义成分（\"释放\"已隐含系统行为，\"自动回收\"无需重复说明执行主体）\n3. 识别连续使用相同逻辑连接词（如两个\"并\"）造成的句式臃肿\n4. 判断逗号分割的语义单元是否存在主次关系混乱（原句主谓结构被状语切割）"
    },
    {
      "defect_id": 121869,
      "sentence": "**相关模块：**[HiDebug](_hi_debug.md)",
      "reference_sentence": "",
      "line_num": 14,
      "context": "",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "相关模块：[HiDebug](_hi_debug.md)",
      "触发条件": "当链接文本或模块名称被冗余的格式符号（如双星号**）包裹，且该格式未提供额外语义价值时。\n\n识别模式：检测方括号内的链接文本是否包含纯装饰性标记（如**、__等强调符号），同时结合上下文判断该格式是否与当前文档层级/风格规范冲突。"
    },
    {
      "defect_id": 154856,
      "sentence": "2. 对XML文件编码后调用XmlPullParser。\r",
      "reference_sentence": "",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"    ```ts\",\"102\":\"    import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文件编码\",\"103\":\"    ```\",\"104\":\"\",\"105\":\"2. 对XML文件编码后调用XmlPullParser。\",\"106\":\"\",\"107\":\"    ```ts\",\"108\":\"    let strXml: string =\",\"109\":\"      '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>' +\",\"110\":\"        '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\"}",
      "修改建议": "行尾的换行符可以删除",
      "更改后示例": "2. 对XML文件编码后调用XmlPullParser。",
      "触发条件": "当文档列表项或段落末尾存在多余换行符，导致与后续代码块/结构间产生非必要空行时触发。通过检测行尾换行符与下文内容类型（如代码块起始标记）的间距异常进行识别。"
    },
    {
      "defect_id": 107146,
      "sentence": "新增一个方法调用hidebug接口，本文以hidebug.getSystemCpuUsage()为例，其他接口可参考[API参考文档](../reference/apis-performance-analysis-kit/js-apis-hidebug.md)。",
      "reference_sentence": "",
      "line_num": 49,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "新增方法调用hidebug接口，示例如下。",
      "触发条件": "句子中包含可删除的限定词（如\"一个\"/\"本文\"等自我指涉词）或重复性说明成分，且删除后核心信息无损失。典型模式为\"新增一个[可数对象]\"或\"本文以...为例\"类冗余修饰结构。"
    },
    {
      "defect_id": 105661,
      "sentence": "系统服务的Dump接口所对应的参数列表。",
      "reference_sentence": "",
      "line_num": 218,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "系统服务的Dump接口参数列表。",
      "触发条件": "当句子中存在由\"所\"、\"之\"等虚词引导的冗余修饰短语（如\"所对应的\"），且该短语删除后不影响核心名词（如\"参数列表\"）与主体（如\"Dump接口\"）的逻辑关系时触发。\n\n识别模式：\n1. 检测\"所+动词+的\"结构（如\"所对应的\"）\n2. 验证修饰成分是否重复表达已知关系（接口与参数列表本身已隐含对应关系）\n3. 判断删除后是否保持语义完整性（主体+核心名词可直接构成有效偏正结构）"
    },
    {
      "defect_id": 107150,
      "sentence": "此时窗口将显示通过hidebug.getSystemCpuUsage()接口获取的CPU使用率的相关日志。",
      "reference_sentence": "",
      "line_num": 90,
      "context": "",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "窗口显示通过hidebug.getSystemCpuUsage()接口获取的CPU使用率日志。",
      "触发条件": "当句子中存在与核心名词存在重复或隐含关系的冗余修饰词（如\"相关\"）或冗余时间状语（如\"此时\"），且删除后不影响语义完整性时触发。\n\n识别模式：\n1. 检查\"的\"字结构后是否出现\"相关/对应/有关\"等无实义修饰词（例：X的相关日志→X日志）\n2. 验证时间/空间状语（此时/当前/在此处）是否在上下文中已隐含\n3. 确认核心动作（显示）与修饰成分（通过...获取）之间是否存在必要关联词"
    },
    {
      "defect_id": 135966,
      "sentence": "11400104 - 系统内部错误。",
      "reference_sentence": "",
      "line_num": 691,
      "context": "{\"686\":\"\",\"687\":\"0 - 接口获取成功。\",\"688\":\"\",\"689\":\"401 - 无效参数，所传递参数为空指针。\",\"690\":\"\",\"691\":\"11400104 - 系统内部错误。\",\"692\":\"\",\"693\":\"\",\"694\":\"### OH_HiDebug_GetSystemCpuUsage()\",\"695\":\"\",\"696\":\"```\"}",
      "修改建议": "包含不必要的修饰成分。",
      "更改后示例": "11400104 - 内部错误。",
      "触发条件": "错误描述中存在可被更广泛术语替代的特定名词（如\"系统\"），或上下文已隐含修饰成分时触发。当错误代码/编号已明确归属范围（如11400104），且修饰语（如\"系统\"）未提供增量信息时，应判定为冗余。"
    },
    {
      "defect_id": 214956,
      "sentence": "IPC实现不同进程间Proxy和Stub的通信，IPC CAPI是IPC Kit提供的C语言接口。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"\",\"4\":\"## 场景介绍\",\"5\":\"\",\"6\":\"\",\"7\":\"IPC实现不同进程间Proxy和Stub的通信，IPC CAPI是IPC Kit提供的C语言接口。\",\"8\":\"IPC CAPI接口不直接提供获取通信代理对象的能力，该功能由[Ability Kit](../application-models/abilitykit-overview.md)提供。\",\"9\":\"\",\"10\":\"![图](./figures/_i_p_c_architecture_diagram.png)\",\"11\":\"\",\"12\":\"进程间IPC通道建立，详情参考[Native子进程开发指导（C/C++）](../application-models/capi_nativechildprocess_development_guideline.md)，本文重点阐述IPC CAPI部分使用说明。\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "IPC实现不同进程间Proxy和Stub的通信。IPC CAPI是IPC Kit提供的C语言接口。",
      "触发条件": "句子中通过逗号连接多个独立信息点（如不同功能模块或技术术语定义），导致信息密度过高或结构冗余。  \n\n识别模式：检查是否存在由逗号分隔的多个完整子句（如主谓宾结构），且子句间无逻辑递进关系，仅并列陈述不同内容（如“A实现B功能，C是D提供的接口”）。"
    },
    {
      "defect_id": 174671,
      "sentence": "应用沙箱提供了一个完全隔离的环境，使用户可以安全地访问应用文件。",
      "reference_sentence": "",
      "line_num": 50,
      "context": "{\"45\":\"\",\"46\":\"## 亮点/特征\",\"47\":\"\",\"48\":\"- 沙箱隔离：\",\"49\":\"访问和管理应用文件，对于每个应用，系统会在内部存储空间映射出一个专属的“[应用沙箱目录](app-sandbox-directory.md#应用沙箱目录)”，它是“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。有以下优点：\",\"50\":\"  - 隔离性：应用沙箱提供了一个完全隔离的环境，使用户可以安全地访问应用文件。\",\"51\":\"  - 安全性：应用沙箱限制了应用可见的数据的最小范围，保护了应用文件的安全。\",\"52\":\"- 应用分享：\",\"53\":\"应用之间可以通过分享URI（Uniform Resource Identifier）或文件描述符FD（File Descriptor）的方式，进行文件共享。有以下优点：\",\"54\":\"  - 便携性：应用之间进行文件分享，省去了用户在多个应用间切换的麻烦，简化了操作步骤，提高了效率。\",\"55\":\"  - 高效性：应用间的文件分享能够更快地完成文件的传输，减少了因多次跳转和等待而浪费的时间。\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "应用沙箱提供隔离的环境，确保应用文件的安全访问。",
      "触发条件": "当句子中存在冗余修饰语（如\"完全\"、\"安全地\"等副词/形容词）且核心名词已隐含该属性时，或当动词短语可被更简洁的名词化结构替代时（如\"使用户可以访问\"→\"确保访问\"）。\n\n识别模式：\n1. 检测\"完全+名词\"结构，当名词本身已具备绝对属性（如\"隔离\"隐含完全性）\n2. 识别\"使...可以...\"类动词结构，判断是否可用\"确保/实现+名词短语\"简化\n3. 验证修饰成分删除后是否保持技术准确性，如\"隔离环境\"在技术语境下已包含完全性"
    },
    {
      "defect_id": 214563,
      "sentence": "使用IPC&RPC跨进程通信时，需要先调用元能力的连接服务接口获取到proxy对象。以下为IPC与RPC的典型使用场景：",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"|Server  |Server                      |服务端       |服务端，提供服务的一端，也成为Stub。|\",\"11\":\"\",\"12\":\"\",\"13\":\"> **说明：**\",\"14\":\">\",\"15\":\">- 使用IPC&RPC跨进程通信时，需要先调用元能力的连接服务接口获取到proxy对象。以下为IPC与RPC的典型使用场景：\",\"16\":\">\",\"17\":\">- IPC典型使用场景在后台服务，应用的后台服务通过IPC机制提供跨进程的服务调用能力。\",\"18\":\">\",\"19\":\">- RPC典型使用场景在<!--Del-->[<!--DelEnd-->多端协同<!--Del-->](../application-models/hop-multi-device-collaboration.md)<!--DelEnd-->，多端协同通过RPC机制提供远端接口调用与数据传递能力。\",\"20\":\"\"}",
      "修改建议": "原文较为冗长，可以更加简洁地表达。",
      "更改后示例": "使用IPC&RPC跨进程通信时，需要先调用元能力的连接服务接口获取proxy对象。IPC与RPC的典型使用场景如下：",
      "触发条件": "句子中出现动词后冗余的助词（如“到”）或使用冗长引导词（如“以下为”）时触发，需满足语义重复且删除后不影响原意。\n\n识别模式：\n1. 动词+冗余助词结构：检测\"获取到\"类组合，当助词\"到/得/了\"可删除且保留核心动词即可完整表意时（如\"获取→获取到\"）\n2. 引导语冗余：识别\"以下为/如下为\"等引导词，当存在更简洁的\"如下\"替代方案时（\"以下为\"→\"如下\"）"
    },
    {
      "defect_id": 174672,
      "sentence": "应用沙箱限制了应用可见的数据的最小范围，保护了应用文件的安全。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "{\"46\":\"## 亮点/特征\",\"47\":\"\",\"48\":\"- 沙箱隔离：\",\"49\":\"访问和管理应用文件，对于每个应用，系统会在内部存储空间映射出一个专属的“[应用沙箱目录](app-sandbox-directory.md#应用沙箱目录)”，它是“[应用文件目录](app-sandbox-directory.md#应用文件目录与应用文件路径)”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。有以下优点：\",\"50\":\"  - 隔离性：应用沙箱提供了一个完全隔离的环境，使用户可以安全地访问应用文件。\",\"51\":\"  - 安全性：应用沙箱限制了应用可见的数据的最小范围，保护了应用文件的安全。\",\"52\":\"- 应用分享：\",\"53\":\"应用之间可以通过分享URI（Uniform Resource Identifier）或文件描述符FD（File Descriptor）的方式，进行文件共享。有以下优点：\",\"54\":\"  - 便携性：应用之间进行文件分享，省去了用户在多个应用间切换的麻烦，简化了操作步骤，提高了效率。\",\"55\":\"  - 高效性：应用间的文件分享能够更快地完成文件的传输，减少了因多次跳转和等待而浪费的时间。\",\"56\":\"  - 数据一致性：应用间的文件分享能够确保数据的完整性和一致性，避免数据在传输过程中出现损坏或丢失的情况。\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "应用沙箱限制了应用可见的数据范围，保护应用文件的安全。",
      "触发条件": "当句子中存在与核心名词（如“范围”）在语义上重复或矛盾的冗余修饰词（如“最小”），且删除后不影响原意或逻辑更通顺时触发。  \n\n识别模式：检查形容词或副词（如“最小”）是否与上下文动词（如“限制”）隐含的语义冲突（“限制”已包含范围缩小的逻辑，“最小”反而冗余）。"
    },
    {
      "defect_id": 51268,
      "sentence": "以整数形式或者浮点数的形式获取当前RationalNumber对象的值。",
      "reference_sentence": "",
      "line_num": 1466,
      "context": "",
      "修改建议": "句子中含有不必要的修饰成分。",
      "更改后示例": "获取当前RationalNumber对象的整数或浮点数值。",
      "触发条件": "当句子中存在重复的修饰结构（如并列项共用相同冗余修饰语）或可用更简洁的同义词替换的冗余成分时触发。具体表现为\"X形式或Y形式\"类重复框架结构，或\"的\"字冗余限定（如\"浮点数的形式\"→\"浮点形式\"）。"
    },
    {
      "defect_id": 221593,
      "sentence": "指一个设备内的进程间通信。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"\",\"4\":\"## 基本概念\",\"5\":\"\",\"6\":\"|缩写    |全称                        |中文描述     |说明  |\",\"7\":\"| -------|----------------------------|-------------|------|\",\"8\":\"|IPC     |Inter Process Communication |进程间通信   |指一个设备内的进程间通信。|\",\"9\":\"|RPC     |Remote Procedure Call       |远程过程调用 |指两个设备间的进程间通信。|\",\"10\":\"|Client  |Client                      |客户端       |请求服务的一端，也称为代理（Proxy）。|\",\"11\":\"|Server  |Server                      |服务端       |提供服务的一端，也称为Stub。|\",\"12\":\"\",\"13\":\"\"}",
      "修改建议": "存在不必要的修饰成分，且使用了表示程度的词。",
      "更改后示例": "指设备内的进程间通信。",
      "触发条件": "当名词短语中存在可被上下文推断或已隐含的数量限定词（如\"一个\"）时，或使用非必要程度副词修饰明确概念时。\n\n识别模式：\n1. 检测\"的\"字结构前是否出现孤立数量词（如：一个/多个+Noun+的）\n2. 匹配程度副词白名单（如：非常/完全/绝对）修饰已隐含限定关系的名词短语\n3. 结合上下文验证修饰成分是否重复定义已明确的范围（如表格中IPC/RPC已形成设备内/跨设备对比）"
    },
    {
      "defect_id": 221594,
      "sentence": "指两个设备间的进程间通信。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"## 基本概念\",\"5\":\"\",\"6\":\"|缩写    |全称                        |中文描述     |说明  |\",\"7\":\"| -------|----------------------------|-------------|------|\",\"8\":\"|IPC     |Inter Process Communication |进程间通信   |指一个设备内的进程间通信。|\",\"9\":\"|RPC     |Remote Procedure Call       |远程过程调用 |指两个设备间的进程间通信。|\",\"10\":\"|Client  |Client                      |客户端       |请求服务的一端，也称为代理（Proxy）。|\",\"11\":\"|Server  |Server                      |服务端       |提供服务的一端，也称为Stub。|\",\"12\":\"\",\"13\":\"\",\"14\":\"> **说明：**\"}",
      "修改建议": "存在不必要的修饰成分，且使用了表示程度的词。",
      "更改后示例": "指设备间的进程间通信。",
      "触发条件": "当名词短语中存在明确数量限定词（如\"两个\"）或程度修饰词，且上下文已隐含该信息或无需具体量化时触发。\n\n识别模式：检查修饰成分是否与上下文定义范围重复（如表格中IPC已限定设备内通信，RPC跨设备无需重复\"两个\"），或是否使用\"多个/各种/不同\"等泛化量词而未提供有效信息。优先处理限定词位于核心概念前（如\"XX间的通信\"）且删除后语义无损的情况。"
    },
    {
      "defect_id": 51063,
      "sentence": "对异步函数处理并返回一个promise的版本。",
      "reference_sentence": "",
      "line_num": 461,
      "context": "",
      "修改建议": "原文中主谓宾结构不明显，表述可以更加直接。",
      "更改后示例": "处理异步函数并返回promise版本。",
      "触发条件": "当句子出现冗余介词结构（如“对...进行”）或不必要助词（如“的”），导致主谓宾关系弱化时触发。\n\n识别模式：\n1. 检测「介词+名词+动词」组合（如“对...处理”），优先采用「动词+宾语」直接结构\n2. 识别名词前冗余的「的」字结构（如“的版本”），当删除后不影响语义时需优化\n3. 判断句子是否通过被动式/处置式弱化动作主体，存在更简洁的主动表达可能"
    },
    {
      "defect_id": 213305,
      "sentence": "IPC的主要工作是让运行在不同进程的Proxy和Stub互相通信，而IPC CAPI是IPC Kit提供的一组C语言接口。\r",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# IPC与RPC通信开发指导(C/C++)\",\"2\":\"\",\"3\":\"\",\"4\":\"## 场景介绍\",\"5\":\"\",\"6\":\"IPC的主要工作是让运行在不同进程的Proxy和Stub互相通信，而IPC CAPI是IPC Kit提供的一组C语言接口。\",\"7\":\"IPC CAPI接口不直接提供获取通信Proxy代理对象的能力，这部分能力由[Ability Kit](../application-models/abilitykit-overview.md)提供。\",\"8\":\"\",\"9\":\"![图](./figures/_i_p_c_architecture_diagram.png)\",\"10\":\"\",\"11\":\"进程间IPC通道建立，详情参考[Native子进程开发指导（C/C++)](../application-models/capi_nativechildprocess_development_guideline.md)，本文重点阐述IPC CAPI部分使用说明。\"}",
      "修改建议": "原文包含过多的修饰成分。",
      "更改后示例": "IPC用于不同进程的Proxy和Stub通信，IPC CAPI是IPC Kit提供的C语言接口。",
      "触发条件": "当句子中存在重复说明功能/用途的动词结构（如\"的主要工作是让运行在\"）或冗余量词（如\"一组\"），且删除后不影响核心信息传递时触发。\n\n识别模式：\n1. 检测\"让运行在\"类嵌套动词结构，可简化为\"用于\"等直接表达\n2. 识别\"一组/多个\"等非必要量词，当名词本身已隐含数量概念时（如接口集合）\n3. 判断修饰语是否与上下文重复（如前文已说明IPC作用时，\"主要工作\"成为冗余）"
    },
    {
      "defect_id": 221595,
      "sentence": "请求服务的一端，也称为代理（Proxy）。",
      "reference_sentence": "",
      "line_num": 10,
      "context": "{\"5\":\"\",\"6\":\"|缩写    |全称                        |中文描述     |说明  |\",\"7\":\"| -------|----------------------------|-------------|------|\",\"8\":\"|IPC     |Inter Process Communication |进程间通信   |指一个设备内的进程间通信。|\",\"9\":\"|RPC     |Remote Procedure Call       |远程过程调用 |指两个设备间的进程间通信。|\",\"10\":\"|Client  |Client                      |客户端       |请求服务的一端，也称为代理（Proxy）。|\",\"11\":\"|Server  |Server                      |服务端       |提供服务的一端，也称为Stub。|\",\"12\":\"\",\"13\":\"\",\"14\":\"> **说明：**\",\"15\":\">\"}",
      "修改建议": "存在不必要的修饰成分，且使用了表示程度的词。",
      "更改后示例": "请求服务的一端，称为代理（Proxy）。",
      "触发条件": "1.存在冗余修饰词（如\"也\"、\"还\"等无实际补充意义的副词）与核心动词连用 2.使用表示补充说明的冗余短语（如\"被称为\"+\"也\"）造成重复表述\n\n识别模式应检测以下结构：\n1. [动词短语] + \"也\" + [重复/补充说明]（如\"称为...，也称为...\"）\n2. 修饰词+核心动词的组合是否产生语义重复（如\"也被称为\"中\"也\"与\"被\"的冗余叠加）\n3. 上下文是否已存在明确指代，使补充说明失去必要性"
    },
    {
      "defect_id": 238687,
      "sentence": "创建需要富文本显示的数字格式化的对象时，可选的配置项。",
      "reference_sentence": "",
      "line_num": 3306,
      "context": "{\"3301\":\"  }\",\"3302\":\"  ```\",\"3303\":\"\",\"3304\":\"## StyledNumberFormatOptions<sup>18+</sup>\",\"3305\":\"\",\"3306\":\"创建需要富文本显示的数字格式化的对象时，可选的配置项。\",\"3307\":\"\",\"3308\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"3309\":\"\",\"3310\":\"**系统能力**：SystemCapability.Global.I18n\",\"3311\":\"\"}",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "创建富文本显示的数字格式化对象时的可选配置项。",
      "触发条件": "句子中存在可删除的冗余限定词（如\"需要\"）或重复性修饰结构（如\"的\"字嵌套），导致主谓关系模糊时触发。具体表现为：当动词短语包含隐含必要性的冗余表述（如\"创建需要X的Y\"可简化为\"创建X的Y\"）时，应删除冗余限定词并优化属格结构。"
    },
    {
      "defect_id": 302723,
      "sentence": "具体恢复过程和关键示例代码片段如下，完整示例代码请结合关系型数据库的备份、重建等上下文进行实现。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"## 关系型数据库数据恢复\",\"40\":\"\",\"41\":\"关系型数据库调用OH_Rdb_Backup接口可以实现备份数据库，通过OH_Rdb_Restore接口可以实现恢复数据库。\",\"42\":\"\",\"43\":\"具体恢复过程和关键示例代码片段如下，完整示例代码请结合关系型数据库的备份、重建等上下文进行实现。\",\"44\":\"\",\"45\":\"调用OH_Rdb_Restore接口实现数据库恢复。示例如下：\",\"46\":\"\",\"47\":\"```cpp\",\"48\":\"OH_Rdb_ConfigV2* config2 = OH_Rdb_CreateConfig();\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "具体恢复过程和关键示例代码如下。完整示例代码请结合关系型数据库的备份、重建等上下文实现。",
      "触发条件": "当句子包含超过两个逗号分隔的独立分句，且存在可合并/删除的冗余词汇（如重复性名词、冗余助词）时触发。\n\n识别模式：  \n1. **结构冗余**：检查是否用逗号强行连接多个本可独立表达的分句（如原句将\"关键示例代码片段如下\"和\"完整示例代码需结合上下文实现\"合并为单句）  \n2. **词汇冗余**：识别名词前的重复限定词（如\"代码片段\"→\"代码\"）或动词前的冗余助词（如\"进行实现\"→\"实现\"）"
    },
    {
      "defect_id": 284585,
      "sentence": "通过ApplicationContext可以获取distributedfiles目录或base下的files、cache、preferences、temp等目录的应用文件路径，应用全局信息可以存放在这些目录下。",
      "reference_sentence": "",
      "line_num": 81,
      "context": "{\"76\":\"   > 开发者可通过监听[COMMON_EVENT_USER_UNLOCKED](../reference/apis-basic-services-kit/common_event/commonEventManager-definitions.md#common_event_user_unlocked)事件感知当前用户首次认证完成。\",\"77\":\"   >\",\"78\":\"   > 切换应用文件加密类型目录的方法请参见[获取和修改加密分区](../application-models/application-context-stage.md#获取和修改加密分区)。\",\"79\":\"\",\"80\":\"4. 四级、五级目录：\",\"81\":\"   通过ApplicationContext可以获取distributedfiles目录或base下的files、cache、preferences、temp等目录的应用文件路径，应用全局信息可以存放在这些目录下。\",\"82\":\"\",\"83\":\"   通过UIAbilityContext、AbilityStageContext、ExtensionContext可以获取HAP级别应用文件路径。HAP信息可以存放在这些目录下，存放在此目录的文件会跟随HAP的卸载而删除，不会影响App级别目录下的文件。在开发态，一个应用包含一个或者多个HAP，详见[Stage模型应用程序包结构](../quick-start/application-package-structure-stage.md)。\",\"84\":\"\",\"85\":\"   应用文件路径具体说明及生命周期如下表所示。\",\"86\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "通过ApplicationContext获取distributedfiles目录或base下的files、cache、preferences、temp等目录的路径，应用全局信息存放在这些目录下。",
      "触发条件": "同一句子中重复使用能指代同一事物的不同表达方式，或存在冗余的助动词/修饰语（如\"可以\"+动词结构后接重复的能力性描述）。\n\n具体识别模式：当句子同时包含\"获取X路径\"的动作描述和\"存放在这些目录下\"的结果描述时，\"应用文件路径\"与\"这些目录\"形成重复指代；同时\"可以获取\"中的助动词与后文\"可以存放\"形成冗余的能力性修饰，构成双重冗余表达。"
    },
    {
      "defect_id": 265139,
      "sentence": "设置连线的颜色。",
      "reference_sentence": "",
      "line_num": 128,
      "context": "{\"123\":\"\",\"124\":\"### pathColor\",\"125\":\"\",\"126\":\"pathColor(value: ResourceColor)\",\"127\":\"\",\"128\":\"设置连线的颜色。\",\"129\":\"\",\"130\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"131\":\"\",\"132\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"133\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "设置连线颜色。",
      "触发条件": "当句子中存在由结构助词\"的\"连接的可合并名词短语（如\"X的Y\"可简化为\"XY\"），且上下文为技术参数/属性描述时触发。"
    },
    {
      "defect_id": 247545,
      "sentence": "相较于原有onClick接口，新增distanceThreshold参数作为点击事件移动阈值，当手指的移动距离超出所设置的点击手势移动阈值时，点击手势识别失败。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"\",\"13\":\"点击动作触发该回调。\",\"14\":\"\",\"15\":\"触发点击事件的设备类型为键盘或手柄时，事件的SourceTool值为Unknown。\",\"16\":\"\",\"17\":\"相较于原有onClick接口，新增distanceThreshold参数作为点击事件移动阈值，当手指的移动距离超出所设置的点击手势移动阈值时，点击手势识别失败。\",\"18\":\"对于点击时手指移动距离没有限制的场景，建议采用原有接口。若要求点击时手指在一定区域范围内，建议使用该接口。\",\"19\":\"\",\"20\":\"**卡片能力：** 从API version 12开始，该接口支持在ArkTS卡片中使用。\",\"21\":\"\",\"22\":\">  **说明：**\"}",
      "修改建议": "原文较长且复杂，应简化。",
      "更改后示例": "新增distanceThreshold参数，设置点击手势移动阈值。手指移动超出阈值时，点击手势识别失败。",
      "触发条件": "同一句子中重复使用不同术语指代同一概念（如\"点击事件移动阈值\"与\"点击手势移动阈值\"），或通过复杂句式（如从句嵌套）重复传递相同语义信息时触发。"
    },
    {
      "defect_id": 219374,
      "sentence": "设置多选框是否选中。",
      "reference_sentence": "",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"### select\",\"50\":\"\",\"51\":\"select(value: boolean)\",\"52\":\"\",\"53\":\"设置多选框是否选中。\",\"54\":\"\",\"55\":\"从API version 10开始，该属性支持[$$](../../../ui/state-management/arkts-two-way-sync.md)双向绑定变量。\",\"56\":\"从API version 18开始，该属性支持[!!](../../../ui/state-management/arkts-new-binding.md#系统组件参数双向绑定)双向绑定变量。\",\"57\":\"\",\"58\":\"**卡片能力：** 从API version 9开始，该接口支持在ArkTS卡片中使用。\"}",
      "修改建议": "句子无实际意义。",
      "更改后示例": "设置多选框选中状态。",
      "触发条件": "当句子中出现“设置”类动词（如设置、配置）后接“是否”引导的冗余判断结构（如“是否选中”）时触发，需将“是否X”改为明确的状态描述（如“X状态”）。  \n识别模式：检测“动词（设置/配置/调整）+ 是否 + 动作/状态”句式，且上下文为单向操作（非条件判断）。"
    },
    {
      "defect_id": 264931,
      "sentence": "文本最小显示字号，与maxFontSize配合使用，当设置minFontSize与maxFontSize时，font中的size设置不生效，默认最大行数为1，默认自适应高度方式为MIN_FONT_SIZE_FIRST。",
      "reference_sentence": "",
      "line_num": 343,
      "context": "{\"338\":\"\",\"339\":\"| 参数名   | 类型                                     | 必填   | 说明                      |\",\"340\":\"| ----- | ---------------------------------------- | ---- | ------------------------- |\",\"341\":\"| color | [ResourceColor](ts-types.md#resourcecolor) | 否    | 文本颜色。                     |\",\"342\":\"| font  | [Font](ts-types.md#font)                 | 否    | 文本样式。 |\",\"343\":\"| minFontSize  | number&nbsp;\\\\|&nbsp;string&nbsp;\\\\|&nbsp;[Resource](ts-types.md#resource) | 否    | 文本最小显示字号，与maxFontSize配合使用，当设置minFontSize与maxFontSize时，font中的size设置不生效，默认最大行数为1，默认自适应高度方式为MIN_FONT_SIZE_FIRST。                     |\",\"344\":\"| maxFontSize  | number&nbsp;\\\\|&nbsp;string&nbsp;\\\\|&nbsp;[Resource](ts-types.md#resource) | 否    | 文本最大显示字号。                     |\",\"345\":\"|  overflow   |   [TextOverflow](ts-appendix-enums.md#textoverflow) | 否    | 文本截断方式，设置为MARQUEE时不生效。                     |\",\"346\":\"\",\"347\":\"## 示例\",\"348\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "文本最小显示字号，与maxFontSize配合使用。设置minFontSize与maxFontSize时，font中的size不生效。默认最大行数为1，自适应高度方式为MIN_FONT_SIZE_FIRST。",
      "触发条件": "当技术文档中出现由多个逗号连接的并列说明项，且包含重复性引导词（如\"默认\"）或冗余条件状语（如\"当设置...时\"）时触发。\n\n识别模式：检查句子是否包含超过三个信息点且缺乏有效分隔，同时存在可简化的复句结构（如将条件状语改写为独立短句）和重复的默认值说明（如连续使用\"默认\"修饰不同参数）。"
    },
    {
      "defect_id": 243969,
      "sentence": "设置图标填充颜色。 <br />**说明：**<br />仅针对svg图源生效。",
      "reference_sentence": "",
      "line_num": 97,
      "context": "{\"92\":\"| 名称         | 类型                                                         | 必填 | 说明                             |\",\"93\":\"| ------------ | ------------------------------------------------------------ | ---- | ---------------------------------- |\",\"94\":\"| image        | [ResourceStr](ts-types.md#resourcestr)                       | 是   | 设置图标内容。                     |\",\"95\":\"| width        | [Dimension](ts-types.md#dimension10)                         | 否   | 设置图标宽度。<br />默认值：32VP |\",\"96\":\"| height       | [Dimension](ts-types.md#dimension10)                         | 否   | 设置图标高度。<br />默认值：32VP |\",\"97\":\"| fillColor    | [ResourceColor](ts-types.md#resourcecolor)                   | 否   | 设置图标填充颜色。 <br />**说明：**<br />仅针对svg图源生效。|\",\"98\":\"| borderRadius | [Length](ts-types.md#length) \\\\| [BorderRadiuses](ts-types.md#borderradiuses9) | 否   | 设置图标圆角。<br />默认值：`$r('sys.float.ohos_id_corner_radius_default_s')`  |\",\"99\":\"\",\"100\":\"## 示例\",\"101\":\"\",\"102\":\"### 示例1（设置气泡样式）\"}",
      "修改建议": "句子中有不必要的换行，可以简化。",
      "更改后示例": "设置图标填充颜色。仅针对svg图源生效。",
      "触发条件": "当文本中存在使用HTML换行标签（<br />）分隔同一语义内容，并伴随重复性说明性标记（如\"**说明：**\"）时触发。\n\n识别模式：\n1. 检查相邻句子是否被<br />强行分割但属于同一逻辑单元（如主描述+限制条件）\n2. 检测是否存在格式标记与内容语义重复（如用\"说明：\"标签后又重复说明内容）\n3. 验证分割后的片段是否可自然合并为连贯单句（如本例中主操作\"设置颜色\"与限制条件\"仅对svg生效\"的连贯性）"
    },
    {
      "defect_id": 243942,
      "sentence": "建议开发者结合[Popup控制](ts-universal-attributes-popup.md)中提供的自定义气泡功能一起使用。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\">  **说明：**\",\"6\":\">\",\"7\":\">  - 该组件从API version 11开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\",\"8\":\">- 该组件不支持在Wearable设备上使用。\",\"9\":\">  - 建议开发者结合[Popup控制](ts-universal-attributes-popup.md)中提供的自定义气泡功能一起使用。\",\"10\":\"\",\"11\":\"## 导入模块\",\"12\":\"\",\"13\":\"```ts\",\"14\":\"import { Popup, PopupOptions, PopupTextOptions, PopupButtonOptions, PopupIconOptions } from '@kit.ArkUI';\"}",
      "修改建议": "句子结构可以更简洁。",
      "更改后示例": "建议结合[Popup控制](ts-universal-attributes-popup.md)中的自定义气泡功能。",
      "触发条件": "当句子中存在与上下文重复的主语（如\"开发者\"）或冗余动作描述（如\"一起使用\"中的\"一起\"），且删除后不影响语义完整性时触发。\n\n识别模式：\n1. 检查主语是否在上下文已明确（如技术文档默认面向开发者）\n2. 识别\"动词+冗余副词\"结构（如\"结合...一起使用\"）\n3. 检测重复性动词短语（如\"提供的\"与\"中\"存在语义重复）"
    },
    {
      "defect_id": 252235,
      "sentence": "当手指在组件上按下、滑动、抬起时触发。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# 触摸事件\",\"2\":\"\",\"3\":\"当手指在组件上按下、滑动、抬起时触发。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 从API version 7开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。\",\"8\":\"\"}",
      "修改建议": "句子中包含过多的修饰成分，可以简化。",
      "更改后示例": "手指在组件上按下、滑动、抬起时触发。",
      "触发条件": "句子中出现\"当...时\"引导的时间状语从句，且主句动词为\"触发/发生\"等直接关联动词时，应删除冗余连词\"当\"。识别模式为时间状语与触发动词存在双重时间指示，形成\"当X时，触发Y\"→\"X时触发Y\"的结构冗余。"
    },
    {
      "defect_id": 268538,
      "sentence": "与[textStyle](#textstyle10)<sup>10+</sup>相比，style参数新增了对undefined类型的支持。",
      "reference_sentence": "",
      "line_num": 174,
      "context": "{\"169\":\"\",\"170\":\"### textStyle<sup>18+</sup>\",\"171\":\"\",\"172\":\"textStyle(style: Optional\\\\<PickerTextStyle>)\",\"173\":\"\",\"174\":\"设置所有选项中除了最上、最下及选中项以外的文本样式。与[textStyle](#textstyle10)<sup>10+</sup>相比，style参数新增了对undefined类型的支持。\",\"175\":\"\",\"176\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"177\":\"\",\"178\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"179\":\"\"}",
      "修改建议": "原文过于啰嗦，应简洁明了。",
      "更改后示例": "与[textStyle](#textstyle10)<sup>10+</sup>相比，style参数支持undefined类型。",
      "触发条件": "当句子中出现\"新增/增加/添加了...的支持\"结构时，且上下文已隐含版本变更语义（如存在版本对比标记<sup>10+</sup>或\"与...相比\"短语），需触发冗余表达规则。识别模式为动词短语嵌套（如\"新增+对...支持\"）造成语义重复。"
    },
    {
      "defect_id": 265136,
      "sentence": "设置宫格圆点在“未选中”状态的填充颜色。",
      "reference_sentence": "",
      "line_num": 80,
      "context": "{\"75\":\"\",\"76\":\"### regularColor\",\"77\":\"\",\"78\":\"regularColor(value: ResourceColor)\",\"79\":\"\",\"80\":\"设置宫格圆点在“未选中”状态的填充颜色。\",\"81\":\"\",\"82\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"83\":\"\",\"84\":\"**系统能力：** SystemCapability.ArkUI.ArkUI.Full\",\"85\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "设置宫格圆点未选中状态的填充颜色。",
      "触发条件": "检测到使用引号或介词结构（如\"在...状态\"）修饰名词，且该结构可简化为直接的名词定语（如\"未选中状态\"）时触发。具体表现为存在冗余的介词短语或标点符号分割状态描述。"
    },
    {
      "defect_id": 302753,
      "sentence": "关系型数据库通过调用OH_Rdb_SetEncrypted方法来设置是否加密。isEncrypted参数为true时表示加密，为false时表示不加密，默认不加密。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"加密后的数据库只能通过接口进行访问，无法通过其它方式打开数据库文件。数据库的加密属性在创建数据库时确认，无法变更。\",\"15\":\"\",\"16\":\"## 关系型数据库加密\",\"17\":\"\",\"18\":\"关系型数据库通过调用OH_Rdb_SetEncrypted方法来设置是否加密。isEncrypted参数为true时表示加密，为false时表示不加密，默认不加密。\",\"19\":\"\",\"20\":\"当encrypt为true时，支持开发者通过调用OH_Rdb_SetCryptoParam方法设置自定义的加密/解密密钥和算法等参数。\",\"21\":\"\",\"22\":\"针对是否配置自定义加密/解密参数，有如下两种场景：\",\"23\":\"\"}",
      "修改建议": "句子过长，含有多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "关系型数据库通过OH_Rdb_SetEncrypted方法设置加密。isEncrypted参数为true表示加密，为false表示不加密，默认不加密。",
      "触发条件": "句子包含冗余动词（如\"调用\"）或时间状语（如\"时\"）且存在重复性默认值说明，同时句长超过25字或含3+逗号分割成分。\n\n识别模式：\n1. 检测\"通过调用XX方法\"结构，可简化为\"通过XX方法\"（动词冗余）\n2. 识别\"参数为true/false时\"句式，可删除\"时\"（时间状语冗余）\n3. 当默认值已在参数false解释中明示，再次强调\"默认不加密\"构成重复说明\n4. 结合句长和标点复杂度（原句38字/3逗号）作为辅助判断指标"
    },
    {
      "defect_id": 361817,
      "sentence": "未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，我们后续会重新考虑。\",\"17\":\"\",\"18\":\"ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。\",\"19\":\"\",\"20\":\"未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。\",\"21\":\"\",\"22\":\"如需深入了解ArkTS语言，可参考[ArkTS具体指南](../arkts-utils/arkts-overview.md)。\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗余。",
      "更改后示例": "未来，ArkTS会持续演进，提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。",
      "触发条件": "当句子出现连续逗号分隔的多个并列修饰成分，且存在语义重复的介词短语或副词结构时触发。\n\n具体识别模式：\n1. 结构特征：包含\"结合...需求/场景\"类介词短语 + 多个逗号分隔的并列成分(3个及以上)\n2. 冗余特征：存在可合并的语义重复(如\"持续演进\"与\"逐步提供\"存在时间维度重复，\"结合需求\"与\"持续演进\"存在因果逻辑重复)\n3. 长度特征：单句超过40字且包含3个以上逗号分隔的复杂结构"
    },
    {
      "defect_id": 221596,
      "sentence": "提供服务的一端，也称为Stub。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"|缩写    |全称                        |中文描述     |说明  |\",\"7\":\"| -------|----------------------------|-------------|------|\",\"8\":\"|IPC     |Inter Process Communication |进程间通信   |指一个设备内的进程间通信。|\",\"9\":\"|RPC     |Remote Procedure Call       |远程过程调用 |指两个设备间的进程间通信。|\",\"10\":\"|Client  |Client                      |客户端       |请求服务的一端，也称为代理（Proxy）。|\",\"11\":\"|Server  |Server                      |服务端       |提供服务的一端，也称为Stub。|\",\"12\":\"\",\"13\":\"\",\"14\":\"> **说明：**\",\"15\":\">\",\"16\":\">- 使用IPC和RPC进行跨进程通信时，需要先调用元能力的连接服务接口获取Proxy对象。IPC和RPC的典型使用场景包括：\"}",
      "修改建议": "存在不必要的修饰成分，且使用了表示程度的词。",
      "更改后示例": "提供服务的一端，称为Stub。",
      "触发条件": "当句子中出现\"也称为\"等附加命名结构但上下文未提及其他别称时，或存在\"不必要的副词（如：也）+ 称为\"的修饰组合时。\n\n识别模式：\n1. 检测到\"也称为\"/\"亦称为\"等双重命名结构\n2. 上下文验证未出现其他别称（如本案例表格仅列Stub一个别称）\n3. 存在冗余副词修饰动词（\"也\"字未提供有效附加信息）"
    },
    {
      "defect_id": 302676,
      "sentence": "分布式数据管理对数据实施分类分级保护，提供基于数据安全标签以及设备安全等级的访问控制机制。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"#include \\\"database/rdb/relational_store.h\\\"\",\"7\":\"```\",\"8\":\"\",\"9\":\"## 基本概念\",\"10\":\"\",\"11\":\"分布式数据管理对数据实施分类分级保护，提供基于数据安全标签以及设备安全等级的访问控制机制。\",\"12\":\"\",\"13\":\"数据安全标签和设备安全等级越高，加密措施和访问控制措施越严格，数据安全性越高。\",\"14\":\"\",\"15\":\"\",\"16\":\"### 数据安全标签\"}",
      "修改建议": "句子较为冗长，可以简化。",
      "更改后示例": "分布式数据管理实施分类分级保护，提供基于数据安全标签和设备安全等级的访问控制。",
      "触发条件": "句子中出现冗余介词结构（如“对数据”）或冗余连接词（如“以及”替代“和”），且存在可删除的抽象名词（如“机制”）而不影响核心语义时触发。  \n识别模式：  \n1. **冗余动作对象**：动词（如“实施”）已隐含宾语，前置介词结构（如“对数据”）无必要；  \n2. **冗余连接词**：使用“以及”连接并列成分，可替换为更简洁的“和”；  \n3. **冗余抽象名词**：句末添加“机制”“方式”等泛化词汇，删除后语义更聚焦（如“访问控制机制”→“访问控制”）。"
    },
    {
      "defect_id": 219408,
      "sentence": "触发多选框选中状态变化。<br/>为true时，表示从未选中变为选中。为false时，表示从选中变为未选中。",
      "reference_sentence": "",
      "line_num": 328,
      "context": "{\"323\":\"\",\"324\":\"| 名称 | 类型    |    只读    |    可选      |  说明              |\",\"325\":\"| ------ | ------ | ------ |-------------------------------- |-------------------------------- |\",\"326\":\"| name | string | 否 | 否 |当前多选框名称。 |\",\"327\":\"| selected | boolean| 否 | 否 | 指示多选框是否被选中。</br>如果select属性没有设置默认值是false。</br>如果设置select属性，此值与设置select属性的值相同。 |\",\"328\":\"| triggerChange |Callback\\\\<boolean>| 否 | 否 |触发多选框选中状态变化。<br/>为true时，表示从未选中变为选中。为false时，表示从选中变为未选中。 |\",\"329\":\"\",\"330\":\"## 示例\",\"331\":\"\",\"332\":\"### 示例1（设置多选框形状）\",\"333\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "触发多选框选中状态变化。true表示从未选中变为选中，false表示从选中变为未选中。",
      "触发条件": "当句子中存在重复的引导结构（如\"为...时，表示\"）或冗余的条件状语成分，导致同一语义层级被重复修饰时触发。\n\n识别模式：检查是否在解释布尔值含义时，出现\"当X时，表示Y\"的冗余句式，且前后分句存在重复的条件指向（如true/false与其对应状态变化）。典型特征为条件状语与主句动词\"表示\"形成双重引导，可通过删除\"为...时\"直接建立布尔值与状态的映射关系来优化。"
    },
    {
      "defect_id": 362997,
      "sentence": "`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。",
      "reference_sentence": "",
      "line_num": 302,
      "context": "{\"297\":\"\",\"298\":\"### 语句\",\"299\":\"\",\"300\":\"#### `If`语句\",\"301\":\"\",\"302\":\"`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。\",\"303\":\"`else`部分也可能包含`if`语句。\",\"304\":\"\",\"305\":\"`if`语句如下所示：\",\"306\":\"\",\"307\":\"```typescript\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "`if`语句根据逻辑条件执行不同语句。",
      "触发条件": "当句子包含重复的修饰成分（如\"需要\"\"对应\"\"否则执行另一组语句（如果有的话）\"），或对已知概念（如if语句的分支逻辑）进行冗余解释时触发。\n\n识别模式：\n1. **修饰词冗余**：存在可删除的限定词（如\"需要根据\"\"对应的\"\"如果有的话\"）\n2. **逻辑复述**：对基础机制（如\"当...为真时执行A，否则执行B\"）进行展开描述，而非聚焦核心功能\n3. **结构重复**：主句与从句重复表达同一概念（如首句已说明\"根据条件执行不同语句\"，后续仍解释条件成立时的具体行为）"
    },
    {
      "defect_id": 363001,
      "sentence": "2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  ",
      "reference_sentence": "",
      "line_num": 396,
      "context": "{\"391\":\"```\",\"392\":\"\",\"393\":\"`for`语句的执行流程如下：\",\"394\":\"\",\"395\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"396\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"397\":\"3、 执行循环主体的语句。  \",\"398\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"399\":\"5、 回到步骤2。  \",\"400\":\"\",\"401\":\"示例：\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "2、 计算`condition`。如果为真值，执行循环主体的语句；如果为假值，终止`for`循环。",
      "触发条件": "当句子中重复出现上下文已明确的解释性成分（如括号补充说明），或存在可合并的重复句式结构（如\"如果...则...\"的对称表述）时触发。"
    },
    {
      "defect_id": 363027,
      "sentence": "闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。",
      "reference_sentence": "",
      "line_num": 720,
      "context": "{\"715\":\"let sum2 = (x: number, y: number) => x + y\",\"716\":\"```\",\"717\":\"\",\"718\":\"### 闭包\",\"719\":\"\",\"720\":\"闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。\",\"721\":\"\",\"722\":\"在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。\",\"723\":\"\",\"724\":\"```typescript\",\"725\":\"function f(): () => number {\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "闭包由函数及声明该函数的环境组合而成。环境包含闭包创建时作用域内的局部变量。",
      "触发条件": "当句子出现冗余指示词（如\"该\"）、绝对化词汇（如\"任何\"）或\"是...的\"被动结构，且上下文已明确指代对象时触发；或存在连续逗号分隔的复杂句式导致信息重复时触发。"
    },
    {
      "defect_id": 363002,
      "sentence": "3、 执行循环主体的语句。  ",
      "reference_sentence": "",
      "line_num": 397,
      "context": "{\"392\":\"\",\"393\":\"`for`语句的执行流程如下：\",\"394\":\"\",\"395\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"396\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"397\":\"3、 执行循环主体的语句。  \",\"398\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"399\":\"5、 回到步骤2。  \",\"400\":\"\",\"401\":\"示例：\",\"402\":\"\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "3、 执行循环主体。",
      "触发条件": "当句子中存在可被上下文或领域常识隐含的冗余修饰成分（如重复前文已明确指代的内容），且删除后语义完整性和准确性不受影响时触发。例如：名词短语中已包含核心概念（如“循环主体”），仍叠加其下位概念（如“语句”）作为冗余限定。"
    },
    {
      "defect_id": 363005,
      "sentence": "使用`break`语句可以终止循环语句或`switch`。",
      "reference_sentence": "",
      "line_num": 470,
      "context": "{\"465\":\"} while (i < 10)\",\"466\":\"```\",\"467\":\"\",\"468\":\"#### `Break`语句\",\"469\":\"\",\"470\":\"使用`break`语句可以终止循环语句或`switch`。\",\"471\":\"\",\"472\":\"示例：\",\"473\":\"\",\"474\":\"```typescript\",\"475\":\"let x = 0;\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "使用`break`语句终止循环或`switch`。",
      "触发条件": "当句子中存在可省略的助动词（如\"可以\"）或重复的名词修饰词（如\"循环语句\"中的\"语句\"），且删除后不影响语义完整性时触发；当并列结构中存在冗余术语（如\"循环\"与\"switch\"共用不必要的修饰成分\"语句\"）时触发。"
    },
    {
      "defect_id": 363035,
      "sentence": "关键字`super`可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：",
      "reference_sentence": "",
      "line_num": 1040,
      "context": "{\"1035\":\"}\",\"1036\":\"```\",\"1037\":\"\",\"1038\":\"#### 父类访问\",\"1039\":\"\",\"1040\":\"关键字`super`可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：\",\"1041\":\"\",\"1042\":\"```typescript\",\"1043\":\"class RectangleSize {\",\"1044\":\"  protected height: number = 0;\",\"1045\":\"  protected width: number = 0;\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "关键字`super`可用于访问父类的实例字段、实例方法和构造函数。实现子类功能时，通过该关键字从父类中获取所需接口。",
      "触发条件": "当句子包含多个逗号分隔的独立分句且存在重复性功能描述时（例如\"在...时，可以...\"与\"通过...获取...\"双重状语结构），或出现冗余介词（如\"在\"）导致句式松散时触发。\n\n识别模式：\n1. 结构特征：检测连续逗号分隔的状语/同位语结构（如\"..., 在..., ...\"）\n2. 语义冗余：识别同一语义主体被不同句式重复表达（如原句\"通过该关键字\"与前半句\"super可用于\"形成语义重叠）\n3. 介词冗余：定位无实际语法作用的介词（如案例中删除的\"在\"字）"
    },
    {
      "defect_id": 363029,
      "sentence": "可以通过编写重载，指定函数的不同调用方式。具体方法是，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。",
      "reference_sentence": "",
      "line_num": 738,
      "context": "{\"733\":\"z(); // 返回：2\",\"734\":\"```\",\"735\":\"\",\"736\":\"### 函数重载\",\"737\":\"\",\"738\":\"可以通过编写重载，指定函数的不同调用方式。具体方法是，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。\",\"739\":\"\",\"740\":\"```typescript\",\"741\":\"function foo(x: number): void;            /* 第一个函数定义 */\",\"742\":\"function foo(x: string): void;            /* 第二个函数定义 */\",\"743\":\"function foo(x: number | string): void {  /* 函数实现 */\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "可以通过编写重载，指定函数的不同调用方式。为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。",
      "触发条件": "当句子中出现\"具体方法是\"等冗余引导短语，且后续分句已直接呈现具体方法时；或当长句包含多个逗号分隔的同类信息且存在重复性解释结构时。"
    },
    {
      "defect_id": 362998,
      "sentence": "`else`部分也可能包含`if`语句。",
      "reference_sentence": "",
      "line_num": 303,
      "context": "{\"298\":\"### 语句\",\"299\":\"\",\"300\":\"#### `If`语句\",\"301\":\"\",\"302\":\"`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。\",\"303\":\"`else`部分也可能包含`if`语句。\",\"304\":\"\",\"305\":\"`if`语句如下所示：\",\"306\":\"\",\"307\":\"```typescript\",\"308\":\"if (condition1) {\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "`else`部分可包含`if`语句。",
      "触发条件": "句子中出现冗余限定词（如\"可能\"、\"也\"等）与已知事实构成重复，或使用\"可能\"类模糊表述描述确定性语法特性时触发\n\n识别模式：当检测到\"可能\"、\"可以\"、\"能够\"等模态动词与确定性技术事实共存，或\"也\"、\"还\"等副词与上下文已知信息重复时，判定为冗余修饰。典型特征为删除这些词后技术准确性不受影响且表达更简洁。"
    },
    {
      "defect_id": 363012,
      "sentence": "函数类型通常用于定义回调函数：",
      "reference_sentence": "",
      "line_num": 687,
      "context": "{\"682\":\"console.log(x);\",\"683\":\"```\",\"684\":\"\",\"685\":\"### 函数类型\",\"686\":\"\",\"687\":\"函数类型通常用于定义回调函数：\",\"688\":\"\",\"689\":\"```typescript\",\"690\":\"type trigFunc = (x: number) => number // 这是一个函数类型\",\"691\":\"\",\"692\":\"function do_action(f: trigFunc) {\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "函数类型用于定义回调函数。",
      "触发条件": "句子中存在可删除的副词/形容词（如\"通常\"\"一般\"等），且该修饰词在上下文未提供必要限定信息时触发；或当上下文已隐含所述场景的普适性，添加修饰词反而弱化表述准确性时触发。\n\n识别模式：\n1. 定位\"通常/一般/可能\"等非必要限定副词\n2. 验证上下文是否已明确场景的普适性（如示例中函数类型的核心用途就是定义回调函数）\n3. 确认删除修饰词后核心语义不变且更精准（如\"用于\"比\"通常用于\"更具确定性）"
    },
    {
      "defect_id": 363007,
      "sentence": "`continue`语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。",
      "reference_sentence": "",
      "line_num": 501,
      "context": "{\"496\":\"}\",\"497\":\"```\",\"498\":\"\",\"499\":\"#### `Continue`语句\",\"500\":\"\",\"501\":\"`continue`语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。\",\"502\":\"\",\"503\":\"示例：\",\"504\":\"\",\"505\":\"```typescript\",\"506\":\"let sum = 0;\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "`continue`语句停止当前迭代，传递控制给下一个迭代。",
      "触发条件": "当句子中存在重复的上下文已知信息（如\"循环迭代\"中\"循环\"在前文已明确）或可被更简洁词汇替代的冗余结构（如\"将控制传递给\"→\"传递控制给\"）时触发。\n\n识别模式：\n1. 名词短语含冗余修饰（如\"当前循环迭代的执行\"→\"当前迭代\"）\n2. 动词结构存在语义重复（如\"停止...的执行\"→\"停止\"）\n3. 介词短语可简化（如\"将控制传递给\"→\"传递控制给\"）"
    },
    {
      "defect_id": 362999,
      "sentence": "`for`语句会被重复执行，直到循环退出语句值为`false`。",
      "reference_sentence": "",
      "line_num": 383,
      "context": "{\"378\":\"let message = Math.random() > 0.5 ? 'Valid' : 'Failed';\",\"379\":\"```\",\"380\":\"\",\"381\":\"#### `For`语句\",\"382\":\"\",\"383\":\"`for`语句会被重复执行，直到循环退出语句值为`false`。\",\"384\":\"\",\"385\":\"`for`语句如下所示：\",\"386\":\"\",\"387\":\"```typescript\",\"388\":\"for ([init]; [condition]; [update]) {\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "`for`语句重复执行，直到条件为`false`。",
      "触发条件": "句子中存在可替换为通用术语的特定技术表述，或使用冗余被动结构导致表述累赘。\n\n识别模式：1) 检查技术术语是否能用更简洁的同义词替代（如\"循环退出语句\"→\"条件\"）2) 识别被动语态中的冗余助动词（如\"会被\"中的\"被\"字）3) 发现重复语义的修饰成分（如\"语句值为false\"可简化为\"条件为false\"）"
    },
    {
      "defect_id": 363003,
      "sentence": "4、 如果有`update`表达式，则执行该表达式。  ",
      "reference_sentence": "",
      "line_num": 398,
      "context": "{\"393\":\"`for`语句的执行流程如下：\",\"394\":\"\",\"395\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"396\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"397\":\"3、 执行循环主体的语句。  \",\"398\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"399\":\"5、 回到步骤2。  \",\"400\":\"\",\"401\":\"示例：\",\"402\":\"\",\"403\":\"```typescript\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "4、 执行`update`表达式。",
      "触发条件": "当句子中存在显式条件分句（如\"如果有...\"）但上下文已隐含该条件，或动作本身已包含条件逻辑时触发。具体表现为条件状语与操作行为的语义重复，且前置流程已确保该条件成立。"
    },
    {
      "defect_id": 363009,
      "sentence": "如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。",
      "reference_sentence": "",
      "line_num": 663,
      "context": "{\"658\":\"\",\"659\":\"### 函数的作用域\",\"660\":\"\",\"661\":\"函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。\",\"662\":\"\",\"663\":\"如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。\",\"664\":\"\",\"665\":\"### 函数调用\",\"666\":\"\",\"667\":\"调用函数以执行其函数体，实参值会赋值给函数的形参。\",\"668\":\"\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "函数内的局部变量覆盖外部同名变量。",
      "触发条件": "当句子出现显式条件结构（如\"如果...则...\"）但上下文已隐含该条件，或存在重复修饰成分（如\"定义的变量\"与\"已有实例\"）导致语义重复时触发。\n\n识别模式：\n1. 检测条件状语从句结构（特别是技术文档中已隐含作用域规则时）\n2. 识别同义重复成分（如变量定义行为的双重描述）\n3. 验证冗余成分删除后是否保持原义完整（如\"覆盖\"已隐含作用域冲突的必然性）"
    },
    {
      "defect_id": 363030,
      "sentence": "不允许重载函数有相同的名字和参数列表，否则将导致编译错误。",
      "reference_sentence": "",
      "line_num": 750,
      "context": "{\"745\":\"\",\"746\":\"foo(123);     //  OK，使用第一个定义\",\"747\":\"foo('aa'); // OK，使用第二个定义\",\"748\":\"```\",\"749\":\"\",\"750\":\"不允许重载函数有相同的名字和参数列表，否则将导致编译错误。\",\"751\":\"\",\"752\":\"## 类\",\"753\":\"\",\"754\":\"类声明引入一个新类型，并定义其字段、方法和构造函数。\",\"755\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "不允许重载函数有相同的名字和参数列表，否则导致编译错误。",
      "触发条件": "当句子包含由逗号连接的多个因果关系分句，且存在冗余助动词（如\"将\"）导致表达累赘时触发。\n\n识别模式：1) 句子结构为\"[原因], 否则 [结果]\"，其中结果分句含冗余时间助动词；2) 在技术规范语境中，因果关系表达可简化而不影响语义准确性。"
    },
    {
      "defect_id": 363010,
      "sentence": "调用函数以执行其函数体，实参值会赋值给函数的形参。",
      "reference_sentence": "",
      "line_num": 667,
      "context": "{\"662\":\"\",\"663\":\"如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。\",\"664\":\"\",\"665\":\"### 函数调用\",\"666\":\"\",\"667\":\"调用函数以执行其函数体，实参值会赋值给函数的形参。\",\"668\":\"\",\"669\":\"如果函数定义如下：\",\"670\":\"\",\"671\":\"```typescript\",\"672\":\"function join(x: string, y: string): string {\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "调用函数执行其函数体，实参赋值给形参。",
      "触发条件": "当句子中存在冗余介词结构（如\"以...\"）、重复的名词修饰语（如\"实参值\"中的\"值\"）或冗余所属关系（如\"函数的形参\"中的\"函数的\"）时触发。\n\n识别模式：\n1. 检测\"以+动词\"结构是否可简化为直接动词（如\"以执行\"→\"执行\"）\n2. 检查名词前是否存在冗余限定词（如\"实参值\"→\"实参\"）\n3. 识别重复所属关系（如\"函数的形参\"→\"形参\"）\n4. 判断修饰成分是否影响信息密度（如\"执行其函数体\"保留核心动词+宾语结构）"
    },
    {
      "defect_id": 363028,
      "sentence": "在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。",
      "reference_sentence": "",
      "line_num": 722,
      "context": "{\"717\":\"\",\"718\":\"### 闭包\",\"719\":\"\",\"720\":\"闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。\",\"721\":\"\",\"722\":\"在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。\",\"723\":\"\",\"724\":\"```typescript\",\"725\":\"function f(): () => number {\",\"726\":\"  let count = 0;\",\"727\":\"  let g = (): number => { count++; return count; };\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "在下例中，`f`函数返回一个闭包，捕获`count`变量。每次调用`z`，`count`值递增。",
      "触发条件": "当句子包含两个及以上由逗号连接的独立语义单元，且存在重复主语指代或可合并的因果关系描述时。\n\n识别模式：\n1. 结构特征：单句超过12个单词，包含两个及以上逗号分隔的语义单元\n2.语义特征：存在重复指代（如\"它捕获了\"中的\"它\"）和隐性因果关系（闭包特性已隐含状态保留，无需显式说明\"会被保留\"）\n3.冗余标记：使用\"并\"连接本可独立呈现的关联动作，或包含可删除的被动语态（\"被保留\"）"
    },
    {
      "defect_id": 363036,
      "sentence": "子类可以重写其父类中定义的方法的实现。重写的方法必须具有与原始方法相同的参数类型和相同或派生的返回类型。",
      "reference_sentence": "",
      "line_num": 1073,
      "context": "{\"1068\":\"}\",\"1069\":\"```\",\"1070\":\"\",\"1071\":\"#### 方法重写\",\"1072\":\"\",\"1073\":\"子类可以重写其父类中定义的方法的实现。重写的方法必须具有与原始方法相同的参数类型和相同或派生的返回类型。\",\"1074\":\"\",\"1075\":\"```typescript\",\"1076\":\"class RectangleSize {\",\"1077\":\"  // ...\",\"1078\":\"  area(): number {\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "子类可以重写父类方法的实现。重写的方法必须具有相同的参数类型和相同或派生的返回类型。",
      "触发条件": "句子中存在重复的所属关系修饰语（如\"其父类中定义的\"）或冗余的同位语（如\"与原始方法\"），且上下文已隐含被修饰对象时触发。识别模式需检测名词短语前是否出现双重限定（所属关系+定义关系）或重复指代前文已明确的主体。"
    },
    {
      "defect_id": 363034,
      "sentence": "包含`implements`子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。",
      "reference_sentence": "",
      "line_num": 1024,
      "context": "{\"1019\":\"    return this.salary * 0.42;\",\"1020\":\"  }\",\"1021\":\"}\",\"1022\":\"```\",\"1023\":\"\",\"1024\":\"包含`implements`子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。\",\"1025\":\"\",\"1026\":\"```typescript\",\"1027\":\"interface DateInterface {\",\"1028\":\"  now(): string;\",\"1029\":\"}\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "包含`implements`子句的类必须实现列出的接口中定义的所有方法，但默认实现的方法除外。",
      "触发条件": "当句子包含多个逗号分隔的从句，且存在重复限定词（如\"使用...定义的\"与\"默认实现\"语义重叠）时触发。识别模式为：检查长句中是否出现\"定义的方法\"等冗余表达，并存在可合并的介词结构（如\"使用...定义的\"可简化为\"默认实现的\"）。"
    },
    {
      "defect_id": 363013,
      "sentence": "函数可以定义为箭头函数，例如：",
      "reference_sentence": "",
      "line_num": 701,
      "context": "{\"696\":\"do_action(Math.sin); // 将函数作为参数传入\",\"697\":\"```\",\"698\":\"\",\"699\":\"### 箭头函数（又名Lambda函数）\",\"700\":\"\",\"701\":\"函数可以定义为箭头函数，例如：\",\"702\":\"\",\"703\":\"```typescript\",\"704\":\"let sum = (x: number, y: number): number => {\",\"705\":\"  return x + y;\",\"706\":\"}\"}",
      "修改建议": "原文过于冗长，包含不必要的修饰成分。",
      "更改后示例": "函数可定义为箭头函数。",
      "触发条件": "当句子在上下文中已明确展示示例（如代码块）时，仍使用冗余的引导语（如\"例如：\"），或包含可删除的修饰词（如\"可以\"）导致语义重复。"
    },
    {
      "defect_id": 363111,
      "sentence": "假设模块具有路径“./utils”和导出实体“X”和“Y”。",
      "reference_sentence": "",
      "line_num": 1682,
      "context": "{\"1677\":\"* 导入路径，用于指定导入的模块；\",\"1678\":\"* 导入绑定，用于定义导入的模块中的可用实体集和使用形式（限定或不限定使用）。\",\"1679\":\"\",\"1680\":\"导入绑定可以有几种形式。\",\"1681\":\"\",\"1682\":\"假设模块具有路径“./utils”和导出实体“X”和“Y”。\",\"1683\":\"\",\"1684\":\"导入绑定`* as A`表示绑定名称“A”，通过`A.name`可访问从导入路径指定的模块导出的所有实体：\",\"1685\":\"\",\"1686\":\"```typescript\",\"1687\":\"import * as Utils from './utils';\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "假设模块路径为“./utils”，导出实体为“X”和“Y”。",
      "触发条件": "当句子中存在多个并列属性描述（如路径、导出实体等），且使用重复的动词结构（如\"具有...和...\"）导致冗余时触发。识别模式为：检测到\"具有X和Y\"结构，其中X/Y为模块属性，且上下文存在更简洁的分号/逗号分隔表达可能性。"
    },
    {
      "defect_id": 363089,
      "sentence": "换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。",
      "reference_sentence": "",
      "line_num": 1583,
      "context": "{\"1578\":\"\",\"1579\":\"### 空值合并运算符\",\"1580\":\"\",\"1581\":\"空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\",\"1582\":\"\",\"1583\":\"换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。\",\"1584\":\"\",\"1585\":\"在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。\",\"1586\":\"\",\"1587\":\"```typescript\",\"1588\":\"class Person {\"}",
      "修改建议": "句子结构过于复杂。",
      "更改后示例": "`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。",
      "触发条件": "当句子包含冗余引导词（如\"换句话说\"）且上下文已明确解释概念，或代码示例中存在可简化的重复逻辑（如同时检查null和undefined）时触发。"
    },
    {
      "defect_id": 363136,
      "sentence": "子类不会继承基类的注解和基类方法的注解。",
      "reference_sentence": "",
      "line_num": 2182,
      "context": "{\"2177\":\"@MyAnno({name: \\\"321\\\", value: 654}) // 编译错误：不允许重复注释\",\"2178\":\"class C {\",\"2179\":\"  // ...\",\"2180\":\"}\",\"2181\":\"```\",\"2182\":\"子类不会继承基类的注解和基类方法的注解。\",\"2183\":\"\",\"2184\":\"#### 注解和抽象类、抽象方法\",\"2185\":\"不支持对抽象类和抽象方法使用注解，否则会有编译报错。\",\"2186\":\"```typescript\",\"2187\":\"@MyAnno // 编译错误：不允许在抽象类和抽象方法上使用注解\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "子类不会继承基类的注解。",
      "触发条件": "当句子中存在并列结构且后半部分信息可通过上下文推断，或修饰成分与核心内容存在语义重复时触发。识别模式为检查\"和/以及\"连接的并列项是否属于同一逻辑层级，并验证后项是否在上下文中已隐含或冗余。"
    },
    {
      "defect_id": 363114,
      "sentence": "顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。",
      "reference_sentence": "",
      "line_num": 1760,
      "context": "{\"1755\":\"\",\"1756\":\"<!--RP2--><!--RP2End-->\",\"1757\":\"\",\"1758\":\"### 顶层语句\",\"1759\":\"\",\"1760\":\"顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。\",\"1761\":\"\",\"1762\":\"## 关键字\",\"1763\":\"\",\"1764\":\"### this\",\"1765\":\"\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "顶层语句是在模块最外层编写的语句，不被包裹在任何函数、类、块级作用域中。包括变量声明、函数声明、表达式等。",
      "触发条件": "当相邻句子重复使用相同主语或名词短语进行解释，且后续句子可通过合并结构或删除重复指代来简化时触发。\n\n具体识别模式：\n1. 主语重复模式：前句结尾使用\"这些X\"指代主语，后句再次重复相同主语（如\"顶层语句包括...\"）\n2. 冗余修饰检测：存在可合并的限定词（如\"直接编写\"→\"编写\"）或重复解释同一概念（如\"最外层\"已隐含\"不被包裹在...\"的语义）\n3. 结构对称性：两个分句采用相同语法结构描述同一主题，可通过分号/连接词合并（如\"是...，包括...\"替代\"是...。包括...\"）"
    },
    {
      "defect_id": 363127,
      "sentence": "可以在.d.ets文件中用环境声明（ambient declaration）来声明注解。",
      "reference_sentence": "",
      "line_num": 2063,
      "context": "{\"2058\":\"}\",\"2059\":\"```\",\"2060\":\"\",\"2061\":\"#### .d.ets文件中的注解\",\"2062\":\"注解可以出现在.d.ets文件中。\",\"2063\":\"可以在.d.ets文件中用环境声明（ambient declaration）来声明注解。\",\"2064\":\"```typescript\",\"2065\":\"ambientAnnotationDeclaration:\",\"2066\":\"  'declare' userDefinedAnnotationDeclaration\",\"2067\":\"  ;\",\"2068\":\"```\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "可以在.d.ets文件中用环境声明来声明注解。",
      "触发条件": "当句子中存在括号内重复解释已明确定义的术语（如\"环境声明（ambient declaration）\"），且上下文已确保术语唯一性时触发。识别模式为检测\"中文术语（英文直译/同义解释）\"结构，并验证该术语是否在文档前文或领域常识中已建立明确对应关系。"
    },
    {
      "defect_id": 363104,
      "sentence": "可选链可以任意长，可以包含任意数量的`?.`运算符。",
      "reference_sentence": "",
      "line_num": 1623,
      "context": "{\"1618\":\"}\",\"1619\":\"```\",\"1620\":\"\",\"1621\":\"**说明**：`getSpouseNick`的返回类型必须为`string | null | undefined`，因为该方法在某些情况下会返回`null`或`undefined`。\",\"1622\":\"\",\"1623\":\"可选链可以任意长，可以包含任意数量的`?.`运算符。\",\"1624\":\"\",\"1625\":\"在以下示例中，如果`Person`实例的`spouse`属性不为空，并且`spouse`的`nick`属性也不为空时，输出`spouse.nick`。否则，输出`undefined`。\",\"1626\":\"\",\"1627\":\"```typescript\",\"1628\":\"class Person {\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "可选链可以包含任意数量的`?.`运算符。",
      "触发条件": "同一句子中出现语义重复的并列分句，且存在可通过单一表述完整覆盖的冗余信息时触发。\n\n识别模式：1. 句子结构包含并列连词（如\"可以...，可以...\"） 2. 前后分句表达相同核心语义（\"任意长\"与\"任意数量`?.`运算符\"存在逻辑等价关系）3. 存在可删除的重复限定词（\"任意长\"被\"任意数量\"完全包含）"
    },
    {
      "defect_id": 363110,
      "sentence": "导入绑定可以有几种形式。",
      "reference_sentence": "",
      "line_num": 1680,
      "context": "{\"1675\":\"导入声明用于导入从其他模块导出的实体，并在当前模块中提供其绑定。导入声明由两部分组成：\",\"1676\":\"\",\"1677\":\"* 导入路径，用于指定导入的模块；\",\"1678\":\"* 导入绑定，用于定义导入的模块中的可用实体集和使用形式（限定或不限定使用）。\",\"1679\":\"\",\"1680\":\"导入绑定可以有几种形式。\",\"1681\":\"\",\"1682\":\"假设模块具有路径“./utils”和导出实体“X”和“Y”。\",\"1683\":\"\",\"1684\":\"导入绑定`* as A`表示绑定名称“A”，通过`A.name`可访问从导入路径指定的模块导出的所有实体：\",\"1685\":\"\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "导入绑定有几种形式。",
      "触发条件": "当句子中出现\"可以\"等冗余助动词且删除后不影响语义完整性时，或存在\"能够\"\"可能\"等非必要情态动词用于陈述客观事实时触发。识别模式需满足：1) 存在\"可以有\"等冗余结构 2) 上下文为技术定义性描述(非假设场景) 3) 删除情态动词后语义更简洁准确。"
    },
    {
      "defect_id": 363085,
      "sentence": "默认情况下，ArkTS中的所有类型都不允许为空，这类似于TypeScript的(`strictNullChecks`)模式，但规则更严格。",
      "reference_sentence": "",
      "line_num": 1543,
      "context": "{\"1538\":\"foo<number>();\",\"1539\":\"```\",\"1540\":\"\",\"1541\":\"## 空安全\",\"1542\":\"\",\"1543\":\"默认情况下，ArkTS中的所有类型都不允许为空，这类似于TypeScript的(`strictNullChecks`)模式，但规则更严格。\",\"1544\":\"\",\"1545\":\"在下面的示例中，所有行都会导致编译时错误：\",\"1546\":\"\",\"1547\":\"```typescript\",\"1548\":\"let x: number = null;    // 编译时错误\"}",
      "修改建议": "句子结构过于复杂。",
      "更改后示例": "默认情况下，ArkTS中的所有类型都不允许为空，类似于TypeScript的`strictNullChecks`模式，但规则更严格。",
      "触发条件": "当句子中存在\"这\"等冗余指代词引导解释性从句，或使用非必要括号包裹术语时，触发冗余表达规则。识别模式为：检查\"这+类似/如同\"结构，或术语被(` `)包裹而非标准反引号的情况。"
    },
    {
      "defect_id": 363037,
      "sentence": "通过重载签名，指定方法的不同调用。具体方法为，为同一个方法写入多个同名但签名不同的方法头，方法实现紧随其后。",
      "reference_sentence": "",
      "line_num": 1093,
      "context": "{\"1088\":\"}\",\"1089\":\"```\",\"1090\":\"\",\"1091\":\"#### 方法重载签名\",\"1092\":\"\",\"1093\":\"通过重载签名，指定方法的不同调用。具体方法为，为同一个方法写入多个同名但签名不同的方法头，方法实现紧随其后。\",\"1094\":\"\",\"1095\":\"```typescript\",\"1096\":\"class C {\",\"1097\":\"  foo(x: number): void;            /* 第一个签名 */\",\"1098\":\"  foo(x: string): void;            /* 第二个签名 */\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "通过重载签名，指定方法的不同调用。为同一个方法写入多个同名但签名不同的方法头，方法实现紧随其后。",
      "触发条件": "当同一句子或相邻句子中出现重复的解释性短语（如\"具体方法为\"）且存在多个逗号分隔的冗长结构时，或当相邻分句重复说明同一操作步骤导致信息冗余时。\n\n识别模式：\n1. 存在冗余引导词：前后句使用\"具体方法为\"等重复性解释短语\n2. 结构重复：分号/逗号分隔的并列结构重复描述同一操作（如\"为同一个方法写入...方法头，方法实现...\"的重复性说明）\n3. 信息密度异常：单句超过15字且包含3个以上逗号，同时存在可拆分的重复语义单元"
    },
    {
      "defect_id": 363189,
      "sentence": "本文适用于使用ArkTS编写代码的开发场景。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 目标和适用范围\",\"4\":\"\",\"5\":\"本文参考业界标准及实践，结合ArkTS语言特点，为提高代码的规范、安全、性能提供编码指南。\",\"6\":\"\",\"7\":\"本文适用于使用ArkTS编写代码的开发场景。\",\"8\":\"\",\"9\":\"## 规则来源\",\"10\":\"\",\"11\":\"ArkTS在保持TypeScript基本语法风格的基础上，进一步强化静态检查和分析。本文部分规则筛选自《[OpenHarmony应用TS&JS编程指南](https://gitee.com/openharmony/docs/blob/master/zh-cn/contribute/OpenHarmony-Application-Typescript-JavaScript-coding-guide.md)》，为ArkTS语言新增的语法添加了规则，旨在提高代码可读性、执行性能。\",\"12\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，影响可读性。",
      "更改后示例": "本文适用于使用ArkTS编写代码的场景。",
      "触发条件": "句子中存在冗余的名词修饰语（如\"开发场景\"中的\"开发\"），或存在可被更简洁词汇替代的复合名词结构（如\"编写代码的开发场景\"可简化为\"编写代码的场景\"）。具体通过识别\"名词A+名词B\"结构中名词A已被上下文动作（如\"编写代码\"）隐含时触发。"
    },
    {
      "defect_id": 363116,
      "sentence": "如果在使用位置无法访问注解名称，则会发生编译错误。",
      "reference_sentence": "",
      "line_num": 1834,
      "context": "{\"1829\":\"对于要使用的注解，其名称必须以符号`@`（例如：@MyAnno）为前缀。符号`@`和名称之间不允许有空格和行分隔符。\",\"1830\":\"```typescript\",\"1831\":\"ClassAuthor({authorName: \\\"Bob\\\"}) // 编译错误：注解需要'@'为前缀\",\"1832\":\"@ ClassAuthor({authorName: \\\"Bob\\\"}) // 编译错误：符号`@`和名称之间不允许有空格和行分隔符\",\"1833\":\"```\",\"1834\":\"如果在使用位置无法访问注解名称，则会发生编译错误。\",\"1835\":\"注解声明可以导出并在其他文件中使用。\",\"1836\":\"\",\"1837\":\"多个注解可以应用于同一个声明（注解间的先后顺序不影响使用）。\",\"1838\":\"```typescript\",\"1839\":\"@MyAnno()\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "如果无法访问注解名称，将发生编译错误。",
      "触发条件": "当句子中的条件状语（如“在使用位置”）在上下文中已隐含或冗余，且主句存在“则”等冗余连接词时触发。  \n识别模式：检查条件从句是否包含上下文已知的位置/场景描述（如问题上下文已明确讨论注解使用位置），并观察是否可通过删除状语和替换连接词（如“则会发生”→“将发生”）实现语义不变的精简表达。"
    },
    {
      "defect_id": 363068,
      "sentence": "只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：",
      "reference_sentence": "",
      "line_num": 1320,
      "context": "{\"1315\":\"\",\"1316\":\"#### 抽象方法\",\"1317\":\"\",\"1318\":\"带有`abstract`修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。\",\"1319\":\"\",\"1320\":\"只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：\",\"1321\":\"\",\"1322\":\"```typescript\",\"1323\":\"class Y {\",\"1324\":\"  abstract method(p: string)  //编译时错误：抽象方法只能在抽象类内。\",\"1325\":\"}\"}",
      "修改建议": "句子结构过于复杂。",
      "更改后示例": "只有抽象类可以有抽象方法。非抽象类具有抽象方法会导致编译错误。",
      "触发条件": "同一句子中同时使用正反条件重复说明同一规则，或使用\"如果...则...\"结构复述前文已明确的条件关系。识别模式为：当出现\"只有A才能B，如果非A则C\"这类正反双重表达时，应合并简化为单一陈述。"
    },
    {
      "defect_id": 363065,
      "sentence": "尝试创建抽象类的实例会导致编译错误：",
      "reference_sentence": "",
      "line_num": 1286,
      "context": "{\"1281\":\"\",\"1282\":\"### 抽象类 \",\"1283\":\"\",\"1284\":\"带有`abstract`修饰符的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。\",\"1285\":\"\",\"1286\":\"尝试创建抽象类的实例会导致编译错误：\",\"1287\":\"\",\"1288\":\"```typescript\",\"1289\":\"abstract class X {\",\"1290\":\"  field: number;\",\"1291\":\"  constructor(p: number) {\"}",
      "修改建议": "句子结构过于复杂。",
      "更改后示例": "创建抽象类的实例会导致编译错误。",
      "触发条件": "当句子包含\"尝试/试图+动词\"结构且后接负面结果（如错误/失败）时，或存在可省略的动作前置说明（如\"尝试创建\"简化为\"创建\"）时触发冗余表达规则。识别模式为检测\"尝试/试图\"与负面结果动词（导致/引发/出现）的共现句式。"
    },
    {
      "defect_id": 363194,
      "sentence": "控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。",
      "reference_sentence": "",
      "line_num": 232,
      "context": "{\"227\":\"\",\"228\":\"**【描述】**\",\"229\":\"\",\"230\":\"代码行宽不宜过长，否则不利于阅读。\",\"231\":\"\",\"232\":\"控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。\",\"233\":\"建议每行字符数不超过120个，除非需要显著增加可读性（超过120个），且不会隐藏信息。\",\"234\":\"例外：如果一行注释包含了超过120个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；预处理的error信息在一行便于阅读和理解，即使超过120个字符。\",\"235\":\"\",\"236\":\"### 条件语句和循环语句的实现必须使用大括号\",\"237\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，影响可读性。",
      "更改后示例": "控制行宽可以引导程序员缩短函数、变量命名，减少嵌套层数，精炼注释，提升代码可读性。",
      "触发条件": "当句子中出现冗余副词（如\"间接的\"）、重复介词（如\"去\"）或结构助词（如\"的层数\"中的\"的\"）导致语义重复，且存在超过三个逗号分隔的并列结构时触发。识别模式需检测连续修饰词+动词结构（如\"去缩短\"）、冗余副词修饰（如\"间接的引导\"）以及助词冗余（如\"的命名\"vs\"命名\"）。"
    },
    {
      "defect_id": 363128,
      "sentence": "环境声明的注解和class类似，也可以被import使用。",
      "reference_sentence": "",
      "line_num": 2086,
      "context": "{\"2081\":\"export declare @interface NameAnno{name: string = \\\"\\\"}\",\"2082\":\"\",\"2083\":\"// a.ets\",\"2084\":\"export @interface NameAnno{name: string = \\\"\\\"} // ok\",\"2085\":\"```\",\"2086\":\"环境声明的注解和class类似，也可以被import使用。\",\"2087\":\"```typescript\",\"2088\":\"// a.d.ets\",\"2089\":\"export declare @interface MyAnno {}\",\"2090\":\"\",\"2091\":\"// b.ets\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "环境声明的注解可以被import使用。",
      "触发条件": "句子中存在与上下文已明确信息重复的类比结构（如“和...类似”）或冗余补充说明（如“也可以...”），且该成分不提供新信息时触发。\n\n识别模式：  \n1. 包含显性类比（如“和X类似”）但上下文已隐含或强调过该类比关系；  \n2. 使用补充性连接词（如“也可以”）表达已知能力，且前后逻辑可独立成立。  \n（示例：上下文已说明注解与class特性相似，则“和class类似”成为冗余修饰）"
    },
    {
      "defect_id": 363193,
      "sentence": "布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。",
      "reference_sentence": "",
      "line_num": 150,
      "context": "{\"145\":\"\",\"146\":\"**【级别】建议**\",\"147\":\"\",\"148\":\"**【描述】**\",\"149\":\"\",\"150\":\"布尔型的局部变量建议加上表达是非意义的前缀，比如is，也可以是has、can、should等。但是，当使用逻辑非运算符，并出现双重否定时，会出现理解问题，比如!isNotError，意味着什么，不是很好理解。因此，应避免定义否定的布尔变量名。\",\"151\":\"\",\"152\":\"**【反例】**\",\"153\":\"\",\"154\":\"```\",\"155\":\"let isNoError = true;\"}",
      "修改建议": "句子过长，包含多个逗号，影响可读性。",
      "更改后示例": "布尔型的局部变量建议加上表达是非意义的前缀，如is、has、can、should等。避免使用逻辑非运算符时出现双重否定，如!isNotError，应避免定义否定的布尔变量名。",
      "触发条件": "当句子中存在由三个及以上逗号连接的独立子句，或出现重复语义的举例结构（如\"比如...也可以是...\"）时触发。\n\n识别模式：\n1. 结构冗余：通过标点统计识别连续逗号分割的复合句式（如原句包含5个逗号）\n2. 语义重复：检测\"比如\"与\"也可以是\"等双重举例结构，或否定词嵌套（如\"否定的布尔变量名\"）\n3. 逻辑复杂度：识别包含双重否定场景描述的句式（如\"当...并...\"的并列条件从句）"
    },
    {
      "defect_id": 363192,
      "sentence": "- 能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名",
      "reference_sentence": "",
      "line_num": 49,
      "context": "{\"44\":\"### 为标识符取一个好名字，提高代码可读性\",\"45\":\"\",\"46\":\"**【描述】**\",\"47\":\"\",\"48\":\"好的标识符命名应遵循以下原则：\",\"49\":\" - 能清晰的表达意图，避免使用单个字母、未成惯例的缩写来命名\",\"50\":\" - 使用正确的英文单词并符合英文语法，不要使用中文拼音\",\"51\":\" - 能区分出意思，避免造成误导\",\"52\":\"\",\"53\":\"### 类名、枚举名、命名空间名采用UpperCamelCase风格\",\"54\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，影响可读性。",
      "更改后示例": "- 能清晰表达意图，避免使用单个字母或未成惯例的缩写来命名",
      "触发条件": "当句子中使用顿号连接逻辑上应为选择关系的并列成分（如替代性选项），或存在冗余助词（如\"的\"）导致句式臃肿时触发。\n\n识别模式：\n1. 检测并列结构中是否存在逻辑上的互斥选项（如\"单个字母\"与\"未成惯例的缩写\"）\n2. 分析连接词合理性，判断顿号是否应替换为\"或\"等选择型连词\n3. 识别\"形容词+的+动词\"结构中可省略的助词（如\"清晰的表达\"→\"清晰表达\"）"
    },
    {
      "defect_id": 363039,
      "sentence": "可以通过编写重载签名，指定构造函数的不同调用方式。具体方法是，为同一个构造函数写入多个同名但签名不同的构造函数头，构造函数实现紧随其后。",
      "reference_sentence": "",
      "line_num": 1152,
      "context": "{\"1147\":\"}\",\"1148\":\"```\",\"1149\":\"\",\"1150\":\"#### 构造函数重载签名\",\"1151\":\"\",\"1152\":\"可以通过编写重载签名，指定构造函数的不同调用方式。具体方法是，为同一个构造函数写入多个同名但签名不同的构造函数头，构造函数实现紧随其后。\",\"1153\":\"\",\"1154\":\"```typescript\",\"1155\":\"class C {\",\"1156\":\"  constructor(x: number)             /* 第一个签名 */\",\"1157\":\"  constructor(x: string)             /* 第二个签名 */\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "可以通过编写重载签名，指定构造函数的不同调用方式。为同一个构造函数写入多个同名但签名不同的构造函数头，构造函数实现紧随其后。",
      "触发条件": "句子中出现由引导词（如\"具体方法是\"）引入的冗余分句，或相邻句子存在重复性结构表达相同语义内容时。\n\n识别模式：\n1. 引导词检测：匹配\"具体方法是/即/例如\"等提示性短语，其后内容与前文存在语义重复\n2. 结构重复检测：相邻句子采用相同语法结构（如\"为...写入...，...紧随其后\"）且核心信息重叠\n3. 长句特征：单句超过2个逗号分隔的并列分句，且分句间存在解释性关系而非递进关系"
    },
    {
      "defect_id": 363077,
      "sentence": "抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；",
      "reference_sentence": "",
      "line_num": 1437,
      "context": "{\"1432\":\"\",\"1433\":\"抽象类与接口都无法实例化。抽象类是类的抽象，抽象类用来捕捉子类的通用特性，接口是行为的抽象。在ArkTS中抽象类与接口的区别如下：\",\"1434\":\"\",\"1435\":\"* 一个类只能继承一个抽象类，而一个类可以实现一个或多个接口；\",\"1436\":\"* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；\",\"1437\":\"* 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；\",\"1438\":\"* 抽象类可以有构造函数，而接口不能有构造函数。\",\"1439\":\"\",\"1440\":\"## 泛型类型和函数\",\"1441\":\"\",\"1442\":\"泛型类型和函数支持代码在多种类型上运行，而不仅限于单一类型。\"}",
      "修改建议": "缺少句号。",
      "更改后示例": "抽象类可以有方法的实现，但接口完全抽象，没有方法实现。",
      "触发条件": "当句子中存在冗余的位置限定词（如\"里面\"）或重复性副词（如\"完全都是\"），且删除后不影响语义完整性时触发该规则。识别模式需检测名词后是否带有冗余方位词（类+里面）、以及是否使用双重强调副词（完全+都是）。"
    },
    {
      "defect_id": 363084,
      "sentence": "泛型类型的类型参数可以设置默认值，这样无需指定实际类型实参，直接使用泛型类型名称即可。以下示例展示了类和函数的这一特性。",
      "reference_sentence": "",
      "line_num": 1523,
      "context": "{\"1518\":\"last([1, 2, 3]);\",\"1519\":\"```\",\"1520\":\"\",\"1521\":\"### 泛型默认值\",\"1522\":\"\",\"1523\":\"泛型类型的类型参数可以设置默认值，这样无需指定实际类型实参，直接使用泛型类型名称即可。以下示例展示了类和函数的这一特性。\",\"1524\":\"\",\"1525\":\"```typescript\",\"1526\":\"class SomeType {}\",\"1527\":\"interface Interface <T1 = SomeType> { }\",\"1528\":\"class Base <T2 = SomeType> { }\"}",
      "修改建议": "句子结构过于复杂。",
      "更改后示例": "泛型类型的类型参数可以设置默认值，这样无需指定实际类型实参，直接使用泛型类型名称即可。以下示例展示了这一特性。",
      "触发条件": "当句子中存在重复指代前文已明确概念的限定词（如\"类和函数的\"），且上下文示例已自然涵盖多个应用场景时触发。\n\n识别模式：检查指示代词（如\"这一特性\"）前的修饰成分是否与代码示例/前文存在重复说明，若修饰词所指内容已通过示例类型（类/接口/函数）或上下文自然呈现，则判定为冗余表达。"
    },
    {
      "defect_id": 363088,
      "sentence": "空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。",
      "reference_sentence": "",
      "line_num": 1581,
      "context": "{\"1576\":\"}\",\"1577\":\"```\",\"1578\":\"\",\"1579\":\"### 空值合并运算符\",\"1580\":\"\",\"1581\":\"空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\",\"1582\":\"\",\"1583\":\"换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。\",\"1584\":\"\",\"1585\":\"在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。\",\"1586\":\"\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "空值合并二元运算符`??`用于检查左侧表达式是否等于`null`或`undefined`。如果是，结果为右侧表达式；否则，结果为左侧表达式。",
      "触发条件": "当句子包含可删除的冗余步骤描述（如\"求值是否等于\"中的动词重复）或重复信息（如\"表达式的结果\"中名词重复）时触发。\n\n识别模式：\n1. 存在隐含行为的显式描述（如\"检查表达式的求值\"可简化为\"检查表达式\"）\n2. 同一语义元素重复出现（如\"表达式的结果为右侧表达式\"可删除第一个\"表达式\"）"
    },
    {
      "defect_id": 363113,
      "sentence": "那么，可以像下面这样进行动态导入：",
      "reference_sentence": "",
      "line_num": 1742,
      "context": "{\"1737\":\"export function bye() {\",\"1738\":\"  console.log('Bye');\",\"1739\":\"}\",\"1740\":\"```\",\"1741\":\"\",\"1742\":\"那么，可以像下面这样进行动态导入：\",\"1743\":\"\",\"1744\":\"```typescript\",\"1745\":\"async function test() {\",\"1746\":\"  let ns = await import('./say');\",\"1747\":\"  let hi = ns.hi;\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "可以像下面这样进行动态导入。",
      "触发条件": "当句子中存在冗余的过渡词（如\"那么\"、\"因此\"等）且删除后不影响上下文逻辑连贯性时触发，常见于技术文档中衔接代码示例的引导性语句。"
    },
    {
      "defect_id": 363191,
      "sentence": "参考了《OpenHarmony应用TS&JS编程指南》中的规则，对其中ArkTS语言不涉及的部分作了去除，为ArkTS语言新增的语法添加了规则。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"### 编程实践\",\"20\":\"\",\"21\":\"包含声明与初始化、数据类型、运算与表达式、异常等。\",\"22\":\"\",\"23\":\"参考了《OpenHarmony应用TS&JS编程指南》中的规则，对其中ArkTS语言不涉及的部分作了去除，为ArkTS语言新增的语法添加了规则。\",\"24\":\"\",\"25\":\"## 术语和定义\",\"26\":\"\",\"27\":\"|  术语   | 缩略语  | 中文解释 |\",\"28\":\"|  ----  | ----  |  ----|\"}",
      "修改建议": "句子过长，包含多个逗号，影响可读性。",
      "更改后示例": "参考了《OpenHarmony应用TS&JS编程指南》中的规则，去除了ArkTS不涉及的部分，为新增语法添加了规则。",
      "触发条件": "当句子中连续出现重复的名词修饰语（如\"ArkTS语言\"）或存在可合并的被动语态结构（如\"作了去除\"）时触发。\n\n识别模式：\n1. 重复修饰检测：匹配\"X语言不涉及的部分\"和\"X语言新增的语法\"类重复限定结构（X为技术名词）\n2. 冗余动词结构：识别\"对...作了去除\"类被动表达，可替换为\"去除...\"主动结构\n3. 上下文冗余：当同一名词（如ArkTS）在相邻分句重复出现全称时，后续出现可省略修饰词"
    },
    {
      "defect_id": 363239,
      "sentence": "如果可以保证在运行时，只有`string`类型的值（不会是其他值，例如`null`或者`undefined`）可以被传入函数`notify`呢？在这种情况下，因为可以确保没有其他边界情况，像`__internal_tostring`的检查就是多余的了。对于这个场景，这样的机制叫做“null-safety”，也就是说，保证`null`不是一个合法的`string`类型变量的值。如果ArkTS有了这个特性，类型不符合的代码将无法编译。作为交换，此类代码为ArkTS引擎提供了更多信息和关于值的类型保证，有助于优化性能。",
      "reference_sentence": "",
      "line_num": 118,
      "context": "{\"113\":\"}\",\"114\":\"```\",\"115\":\"\",\"116\":\"现在想象一下，如果函数`notify`是某些复杂的负载场景中的一部分，而不仅仅是打印日志，那么在运行时执行像`__internal_tostring`的类型检查将会是一个性能问题。\",\"117\":\"\",\"118\":\"如果可以保证在运行时，只有`string`类型的值（不会是其他值，例如`null`或者`undefined`）可以被传入函数`notify`呢？在这种情况下，因为可以确保没有其他边界情况，像`__internal_tostring`的检查就是多余的了。对于这个场景，这样的机制叫做“null-safety”，也就是说，保证`null`不是一个合法的`string`类型变量的值。如果ArkTS有了这个特性，类型不符合的代码将无法编译。\",\"119\":\"\",\"120\":\"```typescript\",\"121\":\"function notify(who: string, what: string) {\",\"122\":\"  console.log(`Dear ${who}, a message for you: ${what}`)\",\"123\":\"}\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "如果保证在运行时，只有`string`类型的值可以传入函数`notify`，像`__internal_tostring`的检查就多余了。这种机制称为“null-safety”，保证`null`不是合法的`string`类型变量的值。ArkTS有了这个特性，类型不符合的代码将无法编译。作为交换，此类代码为ArkTS引擎提供类型保证，优化性能。",
      "触发条件": "当句子包含重复性解释（如用不同表述重复同一概念）或存在可合并/删除的冗余修饰成分（如\"也就是说\"、\"作为交换\"等连接词引导的同义内容），且上下文已提供足够类型安全保证时触发。\n\n识别模式：\n1. 同义反复：出现\"也就是说\"、\"换句话说\"等引导词+重复前文概念\n2. 冗余修饰：存在可简化的复合修饰结构（如\"更多信息和关于值的类型保证\"→\"类型保证\"）\n3. 多重条件堆砌：使用超过3个逗号分隔的从句描述单一逻辑点\n4. 存在类型安全上下文：前文已明确说明类型约束机制（如null-safety）"
    },
    {
      "defect_id": 363199,
      "sentence": "通常情况下，建议使用单引号。",
      "reference_sentence": "",
      "line_num": 429,
      "context": "{\"424\":\"\",\"425\":\"**【级别】建议**\",\"426\":\"\",\"427\":\"**【描述】**\",\"428\":\"\",\"429\":\"通常情况下，建议使用单引号。\",\"430\":\"\",\"431\":\"**【反例】**\",\"432\":\"\",\"433\":\"```\",\"434\":\"let message = \\\"world\\\";\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "建议使用单引号。",
      "触发条件": "句子中存在不提供关键限制信息的修饰性副词/短语（如\"通常情况下\"），且删除后不影响建议的准确性或适用范围。\n\n识别模式：\n1. 检测修饰性短语（如\"通常/一般情况下\"\"建议\"\"可以\"等）\n2. 验证该修饰语是否未定义特殊场景/例外情况\n3. 确认删除后核心建议的适用范围未发生实质性变化\n4. 判断保留修饰语是否会导致建议强度弱化或产生歧义"
    },
    {
      "defect_id": 363198,
      "sentence": "这种方式更便于添加变量声明，无需考虑将分号改为逗号，以免引入错误。此外，每个语句只声明一个变量，使用调试器逐个调试也很方便，而不是一次跳过所有变量。",
      "reference_sentence": "",
      "line_num": 317,
      "context": "{\"312\":\"**【级别】要求**\",\"313\":\"\",\"314\":\"**【描述】**\",\"315\":\"\",\"316\":\"每个语句的变量声明都应只声明一个变量。\",\"317\":\"这种方式更便于添加变量声明，无需考虑将分号改为逗号，以免引入错误。此外，每个语句只声明一个变量，使用调试器逐个调试也很方便，而不是一次跳过所有变量。\",\"318\":\"\",\"319\":\"**【反例】**\",\"320\":\"\",\"321\":\"```\",\"322\":\"let maxCount = 10, isCompleted = false;\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "这种方式便于添加变量声明，避免引入错误。每个语句只声明一个变量，便于调试。",
      "触发条件": "句子包含多个并列分句或重复解释同一概念，存在可合并的冗余修饰成分（如\"更便于...无需考虑...以免\"嵌套结构）或同义重复（如\"使用调试器逐个调试\"与\"便于调试\"）。  \n\n识别模式：  \n1. 长句含3个以上逗号分隔的补充说明  \n2. 出现\"无需考虑...以免\"等防御性解释结构  \n3. 前后分句存在语义重叠（如\"逐个调试\"与\"而不是一次跳过\"形成对立解释）  \n4. 修饰词冗余（如\"更便于\"可简化为\"便于\"）"
    },
    {
      "defect_id": 363200,
      "sentence": "对象字面量的属性应保持一致的格式：要么每个属性都换行，要么所有属性都在同一行。当对象字面量的属性超过4个时，建议统一换行。",
      "reference_sentence": "",
      "line_num": 451,
      "context": "{\"446\":\"\",\"447\":\"**【级别】建议**\",\"448\":\"\",\"449\":\"**【描述】**\",\"450\":\"\",\"451\":\"对象字面量的属性应保持一致的格式：要么每个属性都换行，要么所有属性都在同一行。当对象字面量的属性超过4个时，建议统一换行。\",\"452\":\"\",\"453\":\"**【反例】**\",\"454\":\"\",\"455\":\"```\",\"456\":\"interface I {\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "对象字面量的属性应保持一致格式。当属性超过4个时，建议换行。",
      "触发条件": "同一主语或结构重复出现，或存在多个分句/逗号导致语义重复，且包含非必要的修饰成分（如\"都/所有/统一\"等强调词）。"
    },
    {
      "defect_id": 363201,
      "sentence": "编写条件语句时，建议将`else`放在`if`代码块关闭括号的同一行。同样，编写异常处理语句时，建议将`catch`放在`try`代码块关闭括号的同一行。",
      "reference_sentence": "",
      "line_num": 496,
      "context": "{\"491\":\"\",\"492\":\"**【级别】建议**\",\"493\":\"\",\"494\":\"**【描述】**\",\"495\":\"\",\"496\":\"编写条件语句时，建议将`else`放在`if`代码块关闭括号的同一行。同样，编写异常处理语句时，建议将`catch`放在`try`代码块关闭括号的同一行。\",\"497\":\"\",\"498\":\"**【反例】**\",\"499\":\"\",\"500\":\"```\",\"501\":\"if (isOk) {\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "编写条件语句时，将`else`放在`if`代码块关闭括号的同一行。编写异常处理语句时，将`catch`放在`try`代码块关闭括号的同一行。",
      "触发条件": "当句子包含重复的建议性措辞（如\"建议\"）或使用冗余引导词（如\"同样\"）连接相似结构的分句时触发，特别是存在超过两个逗号分隔的独立语法建议时。\n\n识别模式：\n1. 重复出现\"建议\"等非必要修饰词 + 分号/句号分隔的平行结构\n2. 使用\"同样\"等连接词引导的复合句，且前后分句呈现\"当...时，建议...\"的相同句式\n3. 单句包含超过两个逗号分隔的独立语法规范说明（如原句用逗号连接条件语句和异常处理两个独立场景）"
    },
    {
      "defect_id": 363204,
      "sentence": "ArkTS中，浮点值包含一个小数点，不要求小数点之前或之后必须有一个数字。在小数点前面和后面都添加数字可以提高代码的可读性。",
      "reference_sentence": "",
      "line_num": 607,
      "context": "{\"602\":\"\",\"603\":\"**【级别】建议**\",\"604\":\"\",\"605\":\"**【描述】**\",\"606\":\"\",\"607\":\"ArkTS中，浮点值包含一个小数点，不要求小数点之前或之后必须有一个数字。在小数点前面和后面都添加数字可以提高代码的可读性。\",\"608\":\"\",\"609\":\"**【反例】**\",\"610\":\"\",\"611\":\"```\",\"612\":\"const num = .5;\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "ArkTS中，浮点值包含一个小数点。在小数点前后添加数字可以提高代码的可读性。",
      "触发条件": "当句子中存在重复性解释（如\"小数点之前或之后\"与\"前面和后面\"双重表述）或冗余修饰成分（如\"不要求...必须\"的否定式补充说明），且导致句式结构松散时触发。\n\n识别模式：\n1. 检查同一语义是否被拆分到多个分句重复表达（如否定条件+正向建议）\n2. 定位可合并的方位词组合（如\"前面和后面\"→\"前后\"）\n3. 识别非必要的否定式补充说明（如\"不要求...必须\"在已有正向建议时冗余）"
    },
    {
      "defect_id": 364336,
      "sentence": "异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"并发是指在同一时间内，存在多个任务同时执行的情况。对于多核设备，这些任务可以在不同CPU上并行执行。对于单核设备，尽管多个并发任务不会在同一时刻并行执行，但CPU会在某个任务休眠或进行I/O操作时切换任务，调度执行其他任务，从而提高CPU的资源利用率。\",\"4\":\"\",\"5\":\"为了提升应用的响应速度与帧率，避免耗时任务影响UI主线程，ArkTS提供了异步并发和多线程并发两种处理策略。\",\"6\":\"\",\"7\":\"- 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。\",\"8\":\"\",\"9\":\"- 多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。\",\"10\":\"\",\"11\":\"\",\"12\":\"在并发多线程场景下，不同线程间需要进行数据通信。不同类别的对象采用不同的传输方式，如拷贝或内存共享。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "异步并发指异步代码执行到一定程度后暂停，未来继续执行。同一时间只有一段代码执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务。详细请参见[使用异步并发能力](async-concurrency-overview.md)。",
      "触发条件": "当句子包含重复性解释（如\"这种情况下\"复指前文）、冗余修饰语（如\"的开发场景\"中不必要的\"开发\"）或可简化的被动结构（如\"会被暂停\"）时触发。\n\n识别模式：检查是否存在1) 复指性短语重复上下文信息 2) 形容词/名词组合中可删除的限定词 3) 可简化为主动语态的被动句式 4) 超过两个逗号分隔的长复合句结构。需结合上下文判断信息重复性，如第7段\"开发场景\"与第9段\"耗时任务\"场景形成冗余限定。"
    },
    {
      "defect_id": 363231,
      "sentence": "ArkTS在保留TypeScript（简称TS）基本语法风格的基础上，进一步通过规范强化了静态检查和分析，使得在程序开发阶段能够检测出更多错误，提升程序的稳定性和运行性能。本文将详细解释为什么建议将TS代码适配为ArkTS代码。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS语法适配背景\",\"2\":\"\",\"3\":\"ArkTS在保留TypeScript（简称TS）基本语法风格的基础上，进一步通过规范强化了静态检查和分析，使得在程序开发阶段能够检测出更多错误，提升程序的稳定性和运行性能。本文将详细解释为什么建议将TS代码适配为ArkTS代码。\",\"4\":\"\",\"5\":\"## 程序稳定性\",\"6\":\"\",\"7\":\"动态类型语言如JavaScript（简称JS）虽能提升开发效率，但也容易在运行时引发非预期错误。例如未检查的`undefined`值可能导致程序崩溃，这类问题若能在开发阶段发现将显著提升稳定性。TypeScript（TS）通过类型标注机制，使编译器能在编译时检测出多数类型错误，但其非强制类型系统仍存在局限。例如未标注类型的变量会阻碍完整编译检查。ArkTS通过强制静态类型系统克服这一缺陷，实施更严格的类型验证机制，从而最大限度减少运行时错误的发生。\",\"8\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "ArkTS保留TS基本语法风格，强化静态检查和分析，提升程序稳定性和运行性能。本文解释将TS代码适配为ArkTS代码的原因。",
      "触发条件": "句子包含超过两个逗号分隔的复杂结构，且存在可删除的冗余修饰成分（如\"进一步通过规范\"\"使得在程序开发阶段能够\"等介词/动词短语）或重复语义表达。"
    },
    {
      "defect_id": 363207,
      "sentence": "因此，必须使用`Number.isNaN()`函数来测试一个值是否是`Number.NaN`。",
      "reference_sentence": "",
      "line_num": 633,
      "context": "{\"628\":\"\",\"629\":\"**【描述】**\",\"630\":\"\",\"631\":\"在ArkTS中，`Number.NaN`是`Number`类型的一个特殊值。它被用来表示非数值，这里的数值是指在IEEE浮点数算术标准中定义的双精度64位格式的值。\",\"632\":\"在ArkTS中，`Number.NaN`的独特之处在于它不等于任何值，包括其本身。与`Number.NaN`进行比较时，结果是令人困惑的：`Number.NaN !== Number.NaN` 和 `Number.NaN != Number.NaN` 的值都是 `true`。\",\"633\":\"因此，必须使用`Number.isNaN()`函数来测试一个值是否是`Number.NaN`。\",\"634\":\"\",\"635\":\"**【反例】**\",\"636\":\"\",\"637\":\"```\",\"638\":\"if (foo == Number.NaN) {\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "必须使用`Number.isNaN()`函数来测试一个值是否是`Number.NaN`。",
      "触发条件": "当句子中存在重复说明因果关系的连接词（如\"因此\"）且上下文已明确逻辑关系时，或出现语义重复的修饰成分（如\"必须\"+\"需要\"）时触发。\n\n识别模式：\n1. 检测因果连接词（因此/所以）后接已知结论性内容\n2. 验证前文是否已建立完整逻辑链条\n3. 检查修饰语与核心动词是否存在语义重叠（如\"需要必须\"）\n4. 确认删除连接词后不影响技术准确性且提升简洁性"
    },
    {
      "defect_id": 363341,
      "sentence": "使用额外的语义重载语言运算符会增加语言规范的复杂度，而且，开发者还被迫牢记所有可能的例外情况及对应的处理规则。在特定情况下，这会导致不必要的运行时开销。",
      "reference_sentence": "",
      "line_num": 145,
      "context": "{\"140\":\"// 一元运算符`+`只能作用于数值类型：\",\"141\":\"let t = +42;   // 合法运算\",\"142\":\"let s = +'42'; // 编译时错误\",\"143\":\"```\",\"144\":\"\",\"145\":\"使用额外的语义重载语言运算符会增加语言规范的复杂度，而且，开发者还被迫牢记所有可能的例外情况及对应的处理规则。在特定情况下，这会导致不必要的运行时开销。\",\"146\":\"\",\"147\":\"当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作，并且，通过重构能使代码更清晰、具备更高性能。\",\"148\":\"\",\"149\":\"### 不支持 structural typing\",\"150\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有修饰成分。",
      "更改后示例": "使用额外的语义重载语言运算符会增加语言规范的复杂度。开发者还被迫牢记所有可能的例外情况及对应的处理规则。在特定情况下，这会导致不必要的运行时开销。",
      "触发条件": "当复合句使用并列连词（如\"而且\"、\"并且\"）连接多个独立分句，且存在冗余连接词时触发；当单句超过两个逗号分隔的修饰成分，导致语义密度过高时触发。\n\n识别模式：\n1. 检测\"而且/并且/同时\"等并列连词后接完整独立分句的结构\n2. 识别超过两个逗号分隔的复杂修饰语（如原句\"增加...，而且，开发者...，在...情况下...\"）\n3. 判断连接词是否可删除而不影响语义连贯性（如修复后删除\"而且\"仍保持逻辑递进）\n4. 验证分句独立性（修复后的两个分句均可独立成句）"
    },
    {
      "defect_id": 363233,
      "sentence": "下面这个例子展示了ArkTS通过强制严格的类型检查来提高代码稳定性和正确性。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"## 程序稳定性\",\"6\":\"\",\"7\":\"动态类型语言如JavaScript（简称JS）虽能提升开发效率，但也容易在运行时引发非预期错误。例如未检查的`undefined`值可能导致程序崩溃，这类问题若能在开发阶段发现将显著提升稳定性。TypeScript（TS）通过类型标注机制，使编译器能在编译时检测出多数类型错误，但其非强制类型系统仍存在局限。例如未标注类型的变量会阻碍完整编译检查。ArkTS通过强制静态类型系统克服这一缺陷，实施更严格的类型验证机制，从而最大限度减少运行时错误的发生。\",\"8\":\"\",\"9\":\"下面这个例子展示了ArkTS通过强制严格的类型检查来提高代码稳定性和正确性。\",\"10\":\"\",\"11\":\"\",\"12\":\"**显式初始化类的属性**\",\"13\":\"\",\"14\":\"ArkTS要求类的所有属性在声明时或者在构造函数中显式地初始化，这和TS中的`strictPropertyInitialization`检查一致。以下的代码片段是非严格模式下的TS代码。\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "下面的例子展示ArkTS通过严格类型检查提高代码稳定性和正确性。",
      "触发条件": "句子中存在重复或近义的修饰词（如“强制严格”双重强调），或使用冗余结构（如“通过...来...”的冗长表达）导致语义重复时触发。\n\n识别模式：\n1. **重复修饰检测**：连续出现语义重叠的形容词/副词组合（如“强制”+“严格”）；\n2. **冗余结构识别**：包含“通过...来...”等可简化的介词结构，或动词短语（如“展示了...提高”中“了”与“提高”的时态冗余）。"
    },
    {
      "defect_id": 363242,
      "sentence": "根据工程的compatibleSdkVersion，具体策略如下：",
      "reference_sentence": "",
      "line_num": 136,
      "context": "{\"131\":\"\",\"132\":\"## .ets代码兼容性\",\"133\":\"\",\"134\":\"在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，明确定义ArkTS的语法规则，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。\",\"135\":\"\",\"136\":\"根据工程的compatibleSdkVersion，具体策略如下：\",\"137\":\"\",\"138\":\"  - compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。\",\"139\":\"  - compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。\",\"140\":\"\",\"141\":\"## 支持与TS/JS的交互\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "根据compatibleSdkVersion，策略如下：",
      "触发条件": "当句子中的名词前存在冗余所属关系（如上下文已明确的“工程的”）或重复的限定词（如“具体”），且删除后不影响语义完整性时触发。\n\n识别模式：\n1. 检查名词前是否存在上下文已覆盖的所属关系（如前文已提及“工程”属性，此处“工程的compatibleSdkVersion”可简化为“compatibleSdkVersion”）\n2. 识别冗余形容词（如“具体策略”中的“具体”），当后续内容已明确策略细节且该词无实际信息增量时，判定为冗余修饰成分"
    },
    {
      "defect_id": 363365,
      "sentence": "ArkTS不支持`this`类型，改用显式具体类型。",
      "reference_sentence": "",
      "line_num": 615,
      "context": "{\"610\":\"\",\"611\":\"**级别：错误**\",\"612\":\"\",\"613\":\"**错误码：10605021**\",\"614\":\"\",\"615\":\"ArkTS不支持`this`类型，改用显式具体类型。\",\"616\":\"\",\"617\":\"**TypeScript**\",\"618\":\"\",\"619\":\"```typescript\",\"620\":\"interface ListItem {\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "不支持`this`类型，改用显式具体类型。",
      "触发条件": "当句子中的主语（如技术名称）在上下文（如错误码、前文）中已明确提及，导致重复冗余时；或修饰成分（如\"ArkTS\"）对核心信息无实质补充且可被上下文覆盖时。  \n\n识别方式：检查句子中是否存在与上下文已明确信息重复的名词或限定词，若删除后不影响语义完整性且更简洁，则判定为冗余表达。"
    },
    {
      "defect_id": 363336,
      "sentence": "ArkTS规范约束了TypeScript（简称TS）中影响开发正确性或增加运行时开销的特性。本文罗列了ArkTS中限制的TS特性，并提供重构代码的建议。ArkTS保留了TS大部分语法特性，未在本文中约束的TS特性，ArkTS完全支持。例如，ArkTS支持自定义装饰器，语法与TS一致。按本文约束进行代码重构后，代码仍为合法有效的TS代码。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# 从TypeScript到ArkTS的适配规则\",\"2\":\"\",\"3\":\"ArkTS规范约束了TypeScript（简称TS）中影响开发正确性或增加运行时开销的特性。本文罗列了ArkTS中限制的TS特性，并提供重构代码的建议。ArkTS保留了TS大部分语法特性，未在本文中约束的TS特性，ArkTS完全支持。例如，ArkTS支持自定义装饰器，语法与TS一致。按本文约束进行代码重构后，代码仍为合法有效的TS代码。\",\"4\":\"\",\"5\":\"**示例**\",\"6\":\"\",\"7\":\"包含关键字`var`的原始TypeScript代码：\",\"8\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有修饰成分。",
      "更改后示例": "ArkTS规范约束了影响开发正确性或增加运行时开销的TS特性。本文罗列了ArkTS中限制的TS特性，并提供重构代码的建议。ArkTS保留了TS大部分语法特性。未在本文中约束的TS特性，ArkTS完全支持。例如，ArkTS支持自定义装饰器，语法与TS一致。按本文约束进行代码重构后，代码仍为合法有效的TS代码。",
      "触发条件": "句子中重复使用已定义的术语全称（如\"TypeScript（简称TS）\"后仍出现冗余全称）或相邻分句重复相同主语（如连续使用\"ArkTS\"作为主语），且存在由多个逗号分隔的复杂修饰成分导致句子冗长。"
    },
    {
      "defect_id": 363240,
      "sentence": "TS通过启用编译选项`strictNullChecks`实现此特性。虽然TS被编译成JS，但因为JS没有这个特性，所以严格`null`检查仅在编译时起效。从程序稳定性和性能的角度考虑，ArkTS将“null-safety”视为一个重要的特性。因此，ArkTS强制进行严格`null`检查，在ArkTS中上述代码将始终编译失败。作为交换，此类代码为ArkTS引擎提供了更多信息和关于值的类型保证，有助于优化性能。",
      "reference_sentence": "",
      "line_num": 129,
      "context": "{\"124\":\"\",\"125\":\"notify('Jack', 'You look great today')\",\"126\":\"notify(null, undefined) // 编译时错误\",\"127\":\"```\",\"128\":\"\",\"129\":\"TS通过启用编译选项`strictNullChecks`实现此特性。虽然TS被编译成JS，但因为JS没有这个特性，所以严格`null`检查仅在编译时起效。从程序稳定性和性能的角度考虑，ArkTS将“null-safety”视为一个重要的特性。因此，ArkTS强制进行严格`null`检查，在ArkTS中上述代码将始终编译失败。作为交换，此类代码为ArkTS引擎提供了更多信息和关于值的类型保证，有助于优化性能。\",\"130\":\"\",\"131\":\"\",\"132\":\"## .ets代码兼容性\",\"133\":\"\",\"134\":\"在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，明确定义ArkTS的语法规则，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "TS通过编译选项`strictNullChecks`实现此特性。TS编译成JS，但JS没有这个特性，严格`null`检查仅在编译时起效。从稳定性和性能考虑，ArkTS将“null-safety”视为重要特性。因此，ArkTS强制严格`null`检查，上述代码将编译失败。作为交换，此类代码为ArkTS引擎提供类型保证，优化性能。",
      "触发条件": "句子中存在冗余动词（如“启用”、“进行”）、重复因果连接词（如“虽然...但因为...”）、或冗余修饰成分（如“程序”“更多信息和”），且句式结构复杂导致信息重复或冗长。"
    },
    {
      "defect_id": 363244,
      "sentence": "  - compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。",
      "reference_sentence": "",
      "line_num": 139,
      "context": "{\"134\":\"在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，明确定义ArkTS的语法规则，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。\",\"135\":\"\",\"136\":\"根据工程的compatibleSdkVersion，具体策略如下：\",\"137\":\"\",\"138\":\"  - compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。\",\"139\":\"  - compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。\",\"140\":\"\",\"141\":\"## 支持与TS/JS的交互\",\"142\":\"\",\"143\":\"ArkTS支持与TS/JS的高效互操作。在当前版本中，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互时，将TS/JS的数据和对象作为ArkTS的数据和对象使用，可能会绕过ArkTS的静态编译检查，导致非预期的行为或增加额外的开销。\",\"144\":\"\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "  - compatibleSdkVersion < 10 为兼容模式。违反ArkTS语法的.ets文件代码以warning形式提示。尽管违反ArkTS语法的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。",
      "触发条件": "同一句子中重复提及已明确的上下文信息（如“在该模式下”），或使用冗余修饰成分（如“所有代码”）导致语义重复。  \n\n识别模式：  \n1. **重复性指代**：当句子前半部分已明确前提条件（如“兼容模式”），后续分句再次使用“在该模式下”等指代时，视为冗余。  \n2. **冗余修饰语**：存在可合并的限定词（如“违反ArkTS语法规则的所有代码”中“所有”多余，因前文已限定范围）。"
    },
    {
      "defect_id": 363358,
      "sentence": "在ArkTS中，对象布局在编译时确定，不可在运行时更改，因此不支持`Symbol()`API。该API在静态类型语言中通常没有实际意义。",
      "reference_sentence": "",
      "line_num": 262,
      "context": "{\"257\":\"\",\"258\":\"**级别：错误**\",\"259\":\"\",\"260\":\"**错误码：10605002**\",\"261\":\"\",\"262\":\"在ArkTS中，对象布局在编译时确定，不可在运行时更改，因此不支持`Symbol()`API。该API在静态类型语言中通常没有实际意义。\",\"263\":\"\",\"264\":\"ArkTS只支持`Symbol.iterator`。\",\"265\":\"\",\"266\":\"### 不支持以`#`开头的私有字段\",\"267\":\"\"}",
      "修改建议": "句子包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "对象布局在编译时确定，不可在运行时更改，因此不支持`Symbol()`API。静态类型语言中该API通常没有实际意义。",
      "触发条件": "当句子包含由多个逗号连接的独立分句，且存在重复性指代（如\"该API\"重复前文主语）或冗余修饰成分（如重复强调上下文已知的限定条件\"在静态类型语言中\"）时触发。"
    },
    {
      "defect_id": 364337,
      "sentence": "多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"为了提升应用的响应速度与帧率，避免耗时任务影响UI主线程，ArkTS提供了异步并发和多线程并发两种处理策略。\",\"6\":\"\",\"7\":\"- 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。\",\"8\":\"\",\"9\":\"- 多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。\",\"10\":\"\",\"11\":\"\",\"12\":\"在并发多线程场景下，不同线程间需要进行数据通信。不同类别的对象采用不同的传输方式，如拷贝或内存共享。\",\"13\":\"\",\"14\":\"并发能力广泛应用于多种场景，包括[异步并发任务](async-concurrency-overview.md)、[耗时任务](time-consuming-task-overview.md)（如[CPU密集型任务](cpu-intensive-task-development.md)、[I/O密集型任务](io-intensive-task-development.md)和[同步任务](sync-task-development.md)等）、[长时任务](long-time-task-overview.md)、[常驻任务](resident-task-overview.md)等。开发者可以根据不同的任务诉求和场景，选择相应的并发策略进行优化和开发，具体案例可以参见[应用多线程开发实践案例](batch-database-operations-guide.md)。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "多线程并发允许同时执行多段代码。UI主线程继续响应用户操作和更新UI，后台线程执行耗时操作，避免应用卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于耗时任务等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。",
      "触发条件": "当句子中存在重复语义的词汇（如\"同一时间段内同时\"）或冗余修饰成分（如\"在...的同时\"、\"从而\"等连接词），且删除后不影响核心信息传达时触发。\n\n识别模式：检查是否包含以下特征①同义叠用（时间/状态副词重复）②复合句式结构（多个分句+连接词）③非必要的状语/介词结构（如\"在...下\"框架）④因果关系词冗余（如\"从而\"），同时结合句子长度（超过30字）和逗号数量（超过3个）作为辅助判断指标。"
    },
    {
      "defect_id": 363337,
      "sentence": "静态类型是ArkTS的重要特性之一。当程序使用静态类型时，所有类型在编译时已知，这有助于开发者理解代码中的数据结构。编译器可以提前验证代码的正确性，减少运行时的类型检查，从而提升性能。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"\",\"43\":\"本节罗列了ArkTS不支持或部分支持的TypeScript特性。完整的列表以及详细的代码示例和重构建议，请参考[约束说明](#约束说明)。更多案例请参考[适配指导案例](arkts-more-cases.md)。\",\"44\":\"\",\"45\":\"### 强制使用静态类型\",\"46\":\"\",\"47\":\"静态类型是ArkTS的重要特性之一。当程序使用静态类型时，所有类型在编译时已知，这有助于开发者理解代码中的数据结构。编译器可以提前验证代码的正确性，减少运行时的类型检查，从而提升性能。\",\"48\":\"\",\"49\":\"基于上述考虑，ArkTS中禁止使用`any`类型。\",\"50\":\"\",\"51\":\"**示例**\",\"52\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有修饰成分。",
      "更改后示例": "静态类型是ArkTS的重要特性。使用静态类型时，所有类型在编译时已知。这有助于开发者理解代码中的数据结构。编译器可以提前验证代码的正确性，减少运行时的类型检查，从而提升性能。",
      "触发条件": "当句子包含由多个逗号连接的复合结构，且存在可拆分的长修饰成分（如\"之一\"或从句）时触发。识别模式需检测超过2个分句的连续陈述，并存在重复/非必要限定词。"
    },
    {
      "defect_id": 363357,
      "sentence": "在ArkTS中，对象的属性名不能为数字或字符串。例外：ArkTS支持属性名为字符串字面量和枚举中的字符串值。通过属性名访问类的属性，通过数值索引访问数组元素。",
      "reference_sentence": "",
      "line_num": 212,
      "context": "{\"207\":\"\",\"208\":\"**级别：错误**\",\"209\":\"\",\"210\":\"**错误码：10605001**\",\"211\":\"\",\"212\":\"在ArkTS中，对象的属性名不能为数字或字符串。例外：ArkTS支持属性名为字符串字面量和枚举中的字符串值。通过属性名访问类的属性，通过数值索引访问数组元素。\",\"213\":\"\",\"214\":\"**TypeScript**\",\"215\":\"\",\"216\":\"```typescript\",\"217\":\"var x = { 'name': 'x', 2: '3' };\"}",
      "修改建议": "句子包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "对象的属性名不能为数字或字符串。支持属性名为字符串字面量和枚举中的字符串值。通过属性名访问类的属性，通过数值索引访问数组元素。",
      "触发条件": "句子包含多个逗号分隔的独立陈述，且存在重复性主语（如\"ArkTS\"）或冗余连接词（如\"例外：\"）导致语义重复。"
    },
    {
      "defect_id": 365548,
      "sentence": "异步语法是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"\",\"8\":\"- 任务轻量且无 CPU 阻塞​​：单次任务执行时间短。\",\"9\":\"\",\"10\":\"- 逻辑依赖清晰​​：任务有明确的顺序或并行关系。\",\"11\":\"\",\"12\":\"异步语法是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，可以继续执行其他操作。\",\"13\":\"\",\"14\":\"## Promise\",\"15\":\"\",\"16\":\"Promise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一个状态机制来管理异步操作的不同阶段，并提供了一些方法来注册回调函数以处理异步操作的成功或失败的结果。\",\"17\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且存在不必要的修饰成分。",
      "更改后示例": "异步语法允许程序在执行某些操作时继续执行其他操作。",
      "触发条件": "句子包含多个逗号分隔的补充说明，且存在可被主谓结构直接表达的核心语义重复（如\"不必等待其完成\"与\"继续执行其他操作\"的因果关系重复）。\n\n识别模式：\n1. 长句结构：含2个及以上逗号分隔的补充成分\n2. 语义重叠：后置修饰语与主干存在隐性重复（如原因描述\"不必等待\"与结果描述\"继续执行\"）\n3. 上下文冗余：主谓结构已隐含特征说明（如上下文已明确异步语法是编程语言特性时，首句定义性表述可删除）"
    },
    {
      "defect_id": 363342,
      "sentence": "当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作，并且，通过重构能使代码更清晰、具备更高性能。",
      "reference_sentence": "",
      "line_num": 147,
      "context": "{\"142\":\"let s = +'42'; // 编译时错误\",\"143\":\"```\",\"144\":\"\",\"145\":\"使用额外的语义重载语言运算符会增加语言规范的复杂度，而且，开发者还被迫牢记所有可能的例外情况及对应的处理规则。在特定情况下，这会导致不必要的运行时开销。\",\"146\":\"\",\"147\":\"当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作，并且，通过重构能使代码更清晰、具备更高性能。\",\"148\":\"\",\"149\":\"### 不支持 structural typing\",\"150\":\"\",\"151\":\"假设两个不相关的类`T`和`U`拥有相同的`public`API：\",\"152\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有修饰成分。",
      "更改后示例": "当前只有不到1%的代码库使用该特性。因此，尽管限制运算符的语义需要重构代码，但重构量很小且非常容易操作。通过重构能使代码更清晰、具备更高性能。",
      "触发条件": "当句子中存在由连词（如\"并且\"）连接的多个独立分句，且分句间逻辑关系可拆分时；或当单句包含超过两个逗号分隔的修饰成分导致信息密度过高时。\n\n识别模式：\n1. 检测并列连词（尤其句末的\"并且/而且\"）连接两个完整语义单元\n2. 分析逗号数量及修饰成分层级（原句\"重构量很小且非常容易操作，并且，通过...\"包含三层修饰）\n3. 判断分句独立性（如\"通过重构...\"可独立成句）\n4. 验证拆分后是否保持逻辑连贯性（修复后保留\"因此\"因果链）"
    },
    {
      "defect_id": 363243,
      "sentence": "- compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。",
      "reference_sentence": "",
      "line_num": 138,
      "context": "{\"133\":\"\",\"134\":\"在API version 10之前，ArkTS（.ets文件）完全采用了标准TS的语法。从API version 10 Release起，明确定义ArkTS的语法规则，同时，SDK增加了在编译流程中对.ets文件的ArkTS语法检查，通过编译告警或编译失败提示开发者适配新的ArkTS语法。\",\"135\":\"\",\"136\":\"根据工程的compatibleSdkVersion，具体策略如下：\",\"137\":\"\",\"138\":\"  - compatibleSdkVersion >= 10 为标准模式。在该模式下，对.ets文件，违反ArkTS语法规则的代码会导致工程编译失败，需要完全适配ArkTS语法后方可编译成功。\",\"139\":\"  - compatibleSdkVersion < 10 为兼容模式。在该模式下，对.ets文件以warning形式提示违反ArkTS语法规则的所有代码。尽管违反ArkTS语法规则的工程在兼容模式下仍可编译成功，但需完全适配ArkTS语法后方可在标准模式下编译成功。\",\"140\":\"\",\"141\":\"## 支持与TS/JS的交互\",\"142\":\"\",\"143\":\"ArkTS支持与TS/JS的高效互操作。在当前版本中，ArkTS运行时兼容动态类型对象语义。在与TS/JS交互时，将TS/JS的数据和对象作为ArkTS的数据和对象使用，可能会绕过ArkTS的静态编译检查，导致非预期的行为或增加额外的开销。\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "- compatibleSdkVersion >= 10 为标准模式。违反ArkTS语法的.ets文件代码会导致编译失败，需完全适配ArkTS语法后方可编译成功。",
      "触发条件": "当句子中存在重复限定条件（如\"在该模式下\"）或冗余修饰成分（如\"对.ets文件\"），且上下文已明确隐含该信息时触发。\n\n识别模式需检测以下特征：\n1. 存在重复性介词结构（如\"在...模式下\"/\"对...文件\"）\n2. 修饰成分所指对象已在前置主句/上下文中明确（如标准模式已隐含适用对象）\n3. 删除冗余成分后不影响技术准确性且提升简洁性（如修复后保留核心因果链\"违反语法→编译失败→适配需求\"）"
    },
    {
      "defect_id": 363587,
      "sentence": "在`test.d.ets`中，`I`定义在namespace中。在ets文件中，先导入namespace，再通过名称获取相应的类型。",
      "reference_sentence": "",
      "line_num": 751,
      "context": "{\"746\":\"```\",\"747\":\"\",\"748\":\"**原因**\",\"749\":\"\",\"750\":\"对象字面量缺少类型，根据`test.foo`分析可以得知，`option`的类型来源于声明文件，那么只需要将类型导入即可。\",\"751\":\"在`test.d.ets`中，`I`定义在namespace中。在ets文件中，先导入namespace，再通过名称获取相应的类型。\",\"752\":\"\",\"753\":\"### object literal传参给Object类型\",\"754\":\"\",\"755\":\"**应用代码**\",\"756\":\"\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "在`test.d.ets`中，`I`定义在namespace中。导入namespace并获取类型。",
      "触发条件": "同一上下文中重复提及相同文件或操作步骤，且存在可分步合并的冗余描述。\n\n识别模式：\n1. 相邻句子/段落中多次出现相同文件名（如`test.d.ets`）或实体（如namespace/I类型）\n2. 连续动作描述可合并（如\"先导入A再通过A获取B\" → \"导入A并获取B\"）\n3. 存在显性流程指示词（如\"先...再...\"）但未增加新信息时"
    },
    {
      "defect_id": 363389,
      "sentence": "初始化具有`any`、`Object`或`object`类型的任何对象",
      "reference_sentence": "",
      "line_num": 1012,
      "context": "{\"1007\":\"\",\"1008\":\"在ArkTS中，需要显式标注对象字面量的类型，否则，将发生编译时错误。在某些场景下，编译器可以根据上下文推断出字面量的类型。\",\"1009\":\"\",\"1010\":\"在以下上下文中不支持使用字面量初始化类和接口：\",\"1011\":\"\",\"1012\":\"* 初始化具有`any`、`Object`或`object`类型的任何对象\",\"1013\":\"* 初始化带有方法的类或接口\",\"1014\":\"* 初始化包含自定义含参数的构造函数的类\",\"1015\":\"* 初始化带`readonly`字段的类\",\"1016\":\"\",\"1017\":\"**例子1**\"}",
      "修改建议": "原文过于啰嗦，建议简化。",
      "更改后示例": "初始化具有`any`、`Object`或`object`类型的对象",
      "触发条件": "当句子中同时包含“具有...类型的”和“任何对象”的限定结构时（如“具有`any`/`Object`/`object`类型的任何对象”），且“任何”与类型限定形成语义重复。识别模式为“具有[类型列表]类型的任何对象”的固定句式，其中“任何”可被类型限定隐含而无须显式表达。"
    },
    {
      "defect_id": 363685,
      "sentence": "使用具体类型（如number, string）或接口代替模糊的ESObject。",
      "reference_sentence": "",
      "line_num": 2196,
      "context": "{\"2191\":\"}\",\"2192\":\"```\",\"2193\":\"\",\"2194\":\"## arkts-limited-esobj\",\"2195\":\"\",\"2196\":\"使用具体类型（如number, string）或接口代替模糊的ESObject。\",\"2197\":\"\",\"2198\":\"**应用代码**\",\"2199\":\"\",\"2200\":\"```typescript\",\"2201\":\"// lib.d.ts\"}",
      "修改建议": "句子过长，包含多个动作。",
      "更改后示例": "使用具体类型或接口代替模糊的ESObject。",
      "触发条件": "当文档中存在多个并列的同类建议（如同时列举\"具体类型\"和\"接口\"作为替代方案），且未通过\"或\"等连接词合并表达时触发；或当同一操作建议被拆分为多个语法成分导致句子结构冗余时触发。"
    },
    {
      "defect_id": 363739,
      "sentence": "根据业务需求，将函数参数声明为必选参数。可以考虑使用默认参数。",
      "reference_sentence": "",
      "line_num": 123,
      "context": "{\"118\":\"  }\",\"119\":\"  return undefined;\",\"120\":\"}\",\"121\":\"```\",\"122\":\"\",\"123\":\"根据业务需求，将函数参数声明为必选参数。可以考虑使用默认参数。\",\"124\":\"``` TypeScript\",\"125\":\"function add(left: number = 0, right: number = 0): number {\",\"126\":\"  return left + right;\",\"127\":\"}\",\"128\":\"```\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "根据业务需求，将函数参数声明为必选参数。考虑使用默认参数。",
      "触发条件": "当句子中存在不影响核心语义的冗余修饰词（如\"可以\"等助动词）与核心动词（如\"考虑\"）叠加使用时，或当建议性表述包含重复的可能性暗示时。\n\n识别模式：检测\"可以+动词\"结构中助动词是否必要（特别是当上下文已隐含可能性时），判断删除后是否保持语义完整且表达更简练。"
    },
    {
      "defect_id": 365990,
      "sentence": "查看反汇编文件的内容。",
      "reference_sentence": "",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"```\",\"51\":\"ark_disasm.exe test.abc test.txt\",\"52\":\"```\",\"53\":\"\",\"54\":\"查看反汇编文件的内容。\",\"55\":\"\",\"56\":\"\",\"57\":\"```\",\"58\":\"cat test.txt\",\"59\":\"```\"}",
      "修改建议": "原文包含不必要的修饰成分，可以简化。",
      "更改后示例": "查看反汇编文件。",
      "触发条件": "当名词（如“文件”）被冗余的泛用性修饰语（如“的内容”）限定时，且该修饰语未提供额外有效信息时触发。\n\n识别模式：\n1. 检查名词后是否存在“的内容”“的信息”“的详情”等泛用性后缀；\n2. 验证删除修饰语后核心语义是否完整（如“查看文件”已隐含查看内容的行为）；\n3. 结合上下文判断修饰语必要性（如示例中前文已通过命令行生成文件，无需再强调“内容”）。"
    },
    {
      "defect_id": 363735,
      "sentence": "本文提供应用性能敏感场景下的高性能编程建议，帮助开发者编写高性能应用。高性能编程实践是在开发过程中总结的一些高性能写法和建议。在实现业务功能时，应同步思考并理解高性能写法的原理，并将其应用于代码逻辑中。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# ArkTS高性能编程实践\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"\",\"5\":\"\",\"6\":\"本文提供应用性能敏感场景下的高性能编程建议，帮助开发者编写高性能应用。高性能编程实践是在开发过程中总结的一些高性能写法和建议。在实现业务功能时，应同步思考并理解高性能写法的原理，并将其应用于代码逻辑中。关于ArkTS编程规范，请参考[ArkTS编程规范](./arkts-coding-style-guide.md)。\",\"7\":\"\",\"8\":\"## 声明与表达式\",\"9\":\"\",\"10\":\"### 使用`const`声明不变的变量\",\"11\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "本文提供应用性能敏感场景下的高性能编程建议，帮助开发者编写高性能应用。在实现业务功能时，应理解高性能写法的原理并应用于代码逻辑中。",
      "触发条件": "同一段落或相邻句子中重复使用相同/近义术语（如\"高性能编程建议\"与\"高性能编程实践\"），且存在可合并或删除的重复性解释（如对\"高性能编程实践\"的二次定义说明）。"
    },
    {
      "defect_id": 363442,
      "sentence": "在ArkTS中，导入是编译时而非运行时行为，不支持在模块名中使用通配符。",
      "reference_sentence": "",
      "line_num": 2738,
      "context": "{\"2733\":\"\",\"2734\":\"**级别：错误**\",\"2735\":\"\",\"2736\":\"**错误码：10605129**\",\"2737\":\"\",\"2738\":\"在ArkTS中，导入是编译时而非运行时行为，不支持在模块名中使用通配符。\",\"2739\":\"\",\"2740\":\"**TypeScript**\",\"2741\":\"\",\"2742\":\"```typescript\",\"2743\":\"// 声明\"}",
      "修改建议": "句子过长，信息复杂",
      "更改后示例": "在ArkTS中，导入是编译时行为，不支持模块名中的通配符。",
      "触发条件": "句子中存在通过对比结构（如\"而非\"）重复强调同一概念的不同方面，且其中一个方面已能独立传达必要信息时；或存在可被上下文推断的冗余解释导致信息密度降低时。"
    },
    {
      "defect_id": 365952,
      "sentence": "介绍如何修改字节码文件的内容。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\",\"9\":\"- 方舟字节码函数命名规则：介绍字节码文件中函数名字的字符串的命名规则。\",\"10\":\"\",\"11\":\"- 编译期自定义修改方舟字节码：介绍如何修改字节码文件的内容。\"}",
      "修改建议": "句子结构复杂，包含不必要的修饰成分。",
      "更改后示例": "介绍修改字节码文件的内容。",
      "触发条件": "句子中动词后存在冗余的“如何”或“怎样”等疑问词引导的从句结构，且该从句主干已包含明确动宾关系时触发。  \n识别模式：当检测到“动词（如介绍/说明/描述）+ 如何/怎样 + 动词短语（如修改...）”结构，且删除疑问词后语义完整度≥95%时，判定为冗余表达。"
    },
    {
      "defect_id": 363438,
      "sentence": "在ArkTS中，命名空间用于定义标识符的可见范围，仅在编译时有效。因此，命名空间中不支持非声明语句。可以将非声明语句写在函数中。",
      "reference_sentence": "",
      "line_num": 2615,
      "context": "{\"2610\":\"\",\"2611\":\"**级别：错误**\",\"2612\":\"\",\"2613\":\"**错误码：10605116**\",\"2614\":\"\",\"2615\":\"在ArkTS中，命名空间用于定义标识符的可见范围，仅在编译时有效。因此，命名空间中不支持非声明语句。可以将非声明语句写在函数中。\",\"2616\":\"\",\"2617\":\"**TypeScript**\",\"2618\":\"\",\"2619\":\"```typescript\",\"2620\":\"namespace A {\"}",
      "修改建议": "句子过长，信息复杂",
      "更改后示例": "在ArkTS中，命名空间仅在编译时有效，不支持非声明语句。将非声明语句写在函数中。",
      "触发条件": "当句子中存在重复的语义内容（如\"命名空间用于定义标识符的可见范围\"与\"命名空间仅在编译时有效\"），且通过因果关系词（如\"因此\"）连接本可合并的同类信息时触发。\n\n识别模式：1) 检测到同一主语（如\"命名空间\"）被多个分句重复描述核心属性 2) 存在可通过逻辑合并消除的衔接词（如\"因此\"）+重复限定条件（如\"编译时有效\"）3) 分句间存在可压缩的因果关系结构。"
    },
    {
      "defect_id": 365988,
      "sentence": "假设已存在方舟字节码文件：test.abc，其源代码如下：",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"| --verbose | 否 | 否 | 使能输出额外信息（字节位置、方舟字节码格式、操作码）。 |\",\"35\":\"| --version | 否 | 否 | 显示配套方舟字节码文件版本号以及最低支持的方舟字节码文件版本。 |\",\"36\":\"\",\"37\":\"## 使用示例\",\"38\":\"\",\"39\":\"假设已存在方舟字节码文件：test.abc，其源代码如下：\",\"40\":\"\",\"41\":\"```\",\"42\":\"let i = 99;\",\"43\":\"function show(){return i;}\",\"44\":\"show();\"}",
      "修改建议": "原文包含不必要的修饰成分，可以简化。",
      "更改后示例": "假设已存在方舟字节码文件test.abc。",
      "触发条件": "当句子中存在用标点符号（如冒号）分隔的重复说明结构（\"文件名+修饰语+后续解释\"），且后续内容已明确展示所述对象时触发。\n\n识别模式：检测到\"文件名：其源代码如下\"类结构时，判定冒号后的修饰成分（如\"其源代码如下\"）与上下文代码块形成语义重复，应简化为\"文件名+直接描述\"的紧凑表达。"
    },
    {
      "defect_id": 365951,
      "sentence": "介绍字节码文件中函数名字的字符串的命名规则。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"- 方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和依赖关系。\",\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\",\"9\":\"- 方舟字节码函数命名规则：介绍字节码文件中函数名字的字符串的命名规则。\",\"10\":\"\",\"11\":\"- 编译期自定义修改方舟字节码：介绍如何修改字节码文件的内容。\"}",
      "修改建议": "句子结构复杂，包含不必要的修饰成分。",
      "更改后示例": "介绍字节码文件中函数名字的命名规则。",
      "触发条件": "句子出现多层名词修饰结构（如连续\"的\"字结构）且存在概念重复时，或修饰成分已被核心概念隐含时触发\n\n识别模式需同时满足：\n1. 存在连续名词修饰（例：\"函数名字的字符串的命名规则\"含3层\"的\"字结构）\n2. 修饰成分存在语义重叠（例：\"命名规则\"已隐含\"字符串\"属性）\n3. 删除冗余修饰后核心语义不变（例：删除\"字符串\"后仍准确传达技术概念）"
    },
    {
      "defect_id": 363449,
      "sentence": "对于`Partial<T>`类型，泛型参数T必须为类或者接口类型。",
      "reference_sentence": "",
      "line_num": 2930,
      "context": "{\"2925\":\"\",\"2926\":\"**错误码：10605138**\",\"2927\":\"\",\"2928\":\"ArkTS仅支持`Partial`、`Required`、`Readonly`和`Record`，不支持TypeScript中其他的`Utility Types`。\",\"2929\":\"\",\"2930\":\"对于`Partial<T>`类型，泛型参数T必须为类或者接口类型。\",\"2931\":\"\",\"2932\":\"对于`Record`类型的对象，通过索引访问到的值的类型是包含`undefined`的联合类型。\",\"2933\":\"\",\"2934\":\"### 不支持对函数声明属性\",\"2935\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "`Partial<T>`的泛型参数T必须为类或接口类型。",
      "触发条件": "句子中存在冗余的介词结构(如\"对于...类型\"引导的状语)且该结构可被精简为更简洁的主语前置表达，或存在语义重复的并列连词(如\"或者\"与\"或\"混用)时。  \n\n识别模式：  \n1. 检查是否使用\"对于/针对...类型\"等引导的冗余状语结构，导致主语后置  \n2. 观察并列成分是否同时存在\"或者\"和\"或\"等重复表达形式  \n3. 验证删除介词结构后是否仍能保持完整语义(如原句删除\"对于\"后形成更简洁的\"`Partial<T>`的泛型参数T...\"结构)"
    },
    {
      "defect_id": 365948,
      "sentence": "方舟字节码文件是ArkTS/TS/JS编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# 方舟字节码概述\",\"2\":\"\",\"3\":\"方舟字节码文件是ArkTS/TS/JS编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。\",\"4\":\"\",\"5\":\"- 方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和依赖关系。\",\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息量大，容易造成阅读困难。",
      "更改后示例": "方舟字节码文件是ArkTS/TS/JS编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。",
      "触发条件": "句子中出现由\"以/从而\"等连接词引导的多个连续目的状语，且存在冗余的动词短语结构（如\"以帮助...，进行...\"的递进式表达）。\n\n识别模式：\n1. 检测包含\"以/从而\"连接词引导的目的状语从句\n2. 验证从句后是否连续出现多个逗号分隔的动词短语（≥2个）\n3. 判断动词短语是否属于同一逻辑层级（如\"帮助A，进行B\"属于递进关系而非并列关系）\n4. 当总字数超过50字或包含≥3个逗号时优先触发"
    },
    {
      "defect_id": 363402,
      "sentence": "需要将`primitive`类型（如`number`或`boolean`）转换为引用类型时，请使用`new`表达式。",
      "reference_sentence": "",
      "line_num": 1419,
      "context": "{\"1414\":\"\",\"1415\":\"**错误码：10605053**\",\"1416\":\"\",\"1417\":\"在ArkTS中，`as`关键字是类型转换的唯一语法，错误的类型转换会导致编译时错误或者运行时抛出`ClassCastException`异常。ArkTS不支持使用`<type>`语法进行类型转换。\",\"1418\":\"\",\"1419\":\"需要将`primitive`类型（如`number`或`boolean`）转换为引用类型时，请使用`new`表达式。\",\"1420\":\"\",\"1421\":\"**TypeScript**\",\"1422\":\"\",\"1423\":\"```typescript\",\"1424\":\"class Shape {}\"}",
      "修改建议": "原文包含不必要的解释，可以简化。",
      "更改后示例": "将`primitive`类型转换为引用类型时，使用`new`表达式。",
      "触发条件": "句子中包含括号内的补充性例子或解释，且该内容在上下文或术语定义中已明确，或对核心信息无关键影响时触发。\n\n识别模式：检测到括号结构（如“如X或Y”）或“例如”引导的附加说明，且删除后不影响技术准确性或指令完整性时，判定为冗余表达需简化。"
    },
    {
      "defect_id": 363388,
      "sentence": "在以下上下文中不支持使用字面量初始化类和接口：",
      "reference_sentence": "",
      "line_num": 1010,
      "context": "{\"1005\":\"\",\"1006\":\"**错误码：10605038**\",\"1007\":\"\",\"1008\":\"在ArkTS中，需要显式标注对象字面量的类型，否则，将发生编译时错误。在某些场景下，编译器可以根据上下文推断出字面量的类型。\",\"1009\":\"\",\"1010\":\"在以下上下文中不支持使用字面量初始化类和接口：\",\"1011\":\"\",\"1012\":\"* 初始化具有`any`、`Object`或`object`类型的任何对象\",\"1013\":\"* 初始化带有方法的类或接口\",\"1014\":\"* 初始化包含自定义含参数的构造函数的类\",\"1015\":\"* 初始化带`readonly`字段的类\"}",
      "修改建议": "原文过于啰嗦，建议简化。",
      "更改后示例": "以下上下文中不支持使用字面量初始化类和接口：",
      "触发条件": "当句子中出现“支持/允许/禁止”等权限类动词后紧跟冗余介词“使用”，且后续动词短语（如“初始化”）已隐含“使用”动作时触发。例如“不支持使用X”可简化为“不支持X”。"
    },
    {
      "defect_id": 363384,
      "sentence": "ArkTS支持通过索引访问`TypedArray`（例如`Int32Array`）中的元素。",
      "reference_sentence": "",
      "line_num": 784,
      "context": "{\"779\":\"\",\"780\":\"**错误码：10605029**\",\"781\":\"\",\"782\":\"ArkTS不支持动态声明字段，不支持动态访问字段。只能访问已在类中声明或者继承可见的字段，访问其他字段将会造成编译时错误。\",\"783\":\"使用点操作符访问字段，例如（`obj.field`），不支持索引访问（`obj[field]`）。\",\"784\":\"ArkTS支持通过索引访问`TypedArray`（例如`Int32Array`）中的元素。\",\"785\":\"\",\"786\":\"**TypeScript**\",\"787\":\"\",\"788\":\"```typescript\",\"789\":\"class Point {\"}",
      "修改建议": "原文过于啰嗦，建议简化。",
      "更改后示例": "ArkTS支持通过索引访问`TypedArray`中的元素。",
      "触发条件": "当括号内的示例性说明（如\"例如X\"）与主术语存在直接包含关系，且示例未提供额外必要信息时触发。\n\n识别模式：检测\"术语（例如具体子类）\"结构，若子类属于术语的标准/常见类型，且上下文未要求具体化说明，则判定为冗余。通过语法树识别括号内的举例结构，结合术语体系判断示例必要性。"
    },
    {
      "defect_id": 365942,
      "sentence": "其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS跨语言交互\",\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句子过长，含有多个逗号，且有冗余信息。",
      "更改后示例": "OpenHarmony的Node-API是Node.js社区版本的扩展，不完全兼容Node.js的Node API。",
      "触发条件": "句子存在重复性名词短语（如\"Node.js社区\"重复出现）或冗余修饰结构（如\"拓展版本\"与\"扩展\"语义重叠），且句式因多逗号分隔导致信息密度降低。  \n\n识别模式：  \n1. **重复实体检测**：同一核心名词（如\"Node.js社区\"）在相邻分句中重复出现且未引入新信息  \n2. **冗余修饰识别**：使用\"对...的拓展版本\"等复杂结构替代更简洁的\"是...的扩展\"  \n3. **句式结构分析**：包含超过两个逗号分隔的补充说明性从句，造成主谓关系弱化（如原句用\"其中，\"引导非必要前置状语）"
    },
    {
      "defect_id": 363385,
      "sentence": "如果可以从传递给泛型函数的参数中推断出具体类型，ArkTS允许省略泛型类型实参。否则，省略泛型类型实参会发生编译时错误。",
      "reference_sentence": "",
      "line_num": 965,
      "context": "{\"960\":\"\",\"961\":\"**级别：错误**\",\"962\":\"\",\"963\":\"**错误码：10605034**\",\"964\":\"\",\"965\":\"如果可以从传递给泛型函数的参数中推断出具体类型，ArkTS允许省略泛型类型实参。否则，省略泛型类型实参会发生编译时错误。\",\"966\":\"禁止仅基于泛型函数返回类型推断泛型类型参数。\",\"967\":\"\",\"968\":\"**TypeScript**\",\"969\":\"\",\"970\":\"```typescript\"}",
      "修改建议": "原文过于啰嗦，建议简化。",
      "更改后示例": "如果可以从参数中推断出类型，ArkTS允许省略泛型类型实参。否则，省略泛型类型实参会编译错误。",
      "触发条件": "当句子中存在上下文已明确的信息重复（如重复提及\"泛型函数\"）或使用冗长表达（如\"会发生编译时错误\"替代\"会编译错误\"）时触发。具体表现为：1) 重复修饰已知主体（如\"参数\"前已隐含\"传递给泛型函数\"）；2) 使用冗余动词结构（如\"发生...错误\"替代直接名词化表达）。"
    },
    {
      "defect_id": 365949,
      "sentence": "介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和依赖关系。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 方舟字节码概述\",\"2\":\"\",\"3\":\"方舟字节码文件是ArkTS/TS/JS编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。\",\"4\":\"\",\"5\":\"- 方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和依赖关系。\",\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\",\"9\":\"- 方舟字节码函数命名规则：介绍字节码文件中函数名字的字符串的命名规则。\",\"10\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息量大，容易造成阅读困难。",
      "更改后示例": "介绍字节码文件中各部分的结构信息，存储方式和依赖关系。",
      "触发条件": "当句子中出现多个并列短语或重复性修饰词（如\"各个部分的结构信息\"+\"各种结构的存储方式\"），且存在可合并的同范畴描述项（结构信息/存储方式/依赖关系）时触发。\n\n具体识别模式：\n1. 结构特征：包含两个及以上由\"和/以及\"连接的并列成分\n2. 词汇特征：存在重复限定词（如\"各个\"/\"各种\"）或重复核心名词（如\"结构\"）\n3. 上下文特征：出现在列表项中（markdown的\"-\"格式），需要保持内容简洁性\n4. 长度特征：单句超过25字且包含两个以上逗号分隔的语义单元\n\n典型问题模式：\"介绍A的X1，以及A的X2\" → 应合并为\"介绍A的X1和X2\""
    },
    {
      "defect_id": 365926,
      "sentence": "首先，实现一个处理ArrayBuffer的接口，该接口在Task中执行。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"## ArrayBuffer拷贝传输方式\",\"18\":\"\",\"19\":\"在ArkTS中，TaskPool传递ArrayBuffer数据时，默认使用转移方式，通过调用setTransferList()接口，可以指定部分数据的传递方式为转移方式，而其他部分数据可以切换为拷贝方式。\",\"20\":\"\",\"21\":\"首先，实现一个处理ArrayBuffer的接口，该接口在Task中执行。\",\"22\":\"\",\"23\":\"然后，通过拷贝方式将ArrayBuffer数据传递到Task中，并处理。\",\"24\":\"\",\"25\":\"最后，UI主线程接收到Task执行完毕后返回的ArrayBuffer数据，拼接并展示。\",\"26\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分",
      "更改后示例": "实现一个处理ArrayBuffer的接口，该接口在Task中执行。",
      "触发条件": "当句子中存在与上下文已明确的时间/逻辑顺序形成重复的时间副词（如\"首先\"），或出现不增加信息量的修饰性短语（如\"该接口\"指代前文已明确的主语）时触发。\n\n识别模式：1) 检查时间副词是否与文档结构（编号列表/步骤说明）形成冗余 2) 验证代词性短语（该XX）的先行词是否在相邻语句中已被唯一确定"
    },
    {
      "defect_id": 363422,
      "sentence": "由于在ArkTS中，对象布局在编译时是确定的并且在运行时无法修改，因此不支持使用`for .. in`迭代一个对象的属性。",
      "reference_sentence": "",
      "line_num": 1797,
      "context": "{\"1792\":\"\",\"1793\":\"**级别：错误**\",\"1794\":\"\",\"1795\":\"**错误码：10605080**\",\"1796\":\"\",\"1797\":\"由于在ArkTS中，对象布局在编译时是确定的并且在运行时无法修改，因此不支持使用`for .. in`迭代一个对象的属性。\",\"1798\":\"\",\"1799\":\"**TypeScript**\",\"1800\":\"\",\"1801\":\"```typescript\",\"1802\":\"let a: string[] = ['1.0', '2.0', '3.0'];\"}",
      "修改建议": "句子过长，包含不必要的解释和修饰成分。",
      "更改后示例": "ArkTS不支持使用`for .. in`迭代对象属性。",
      "触发条件": "句子包含与核心结论无关的因果逻辑（如\"由于...因此...\"结构）或重复已知上下文的技术细节（如对象布局特性），导致信息密度降低时触发。\n\n识别模式：  \n1. 存在因果连接词 + 技术原理解释（如\"由于在ArkTS中...因此...\"）  \n2. 核心结论（不支持xxx语法）可独立成立，技术解释在错误码上下文中已通过其他方式隐式传达（如错误码10605080可能关联到ArkTS静态类型特性）"
    },
    {
      "defect_id": 365950,
      "sentence": "介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"方舟字节码文件是ArkTS/TS/JS编译后的二进制产物。本章节介绍方舟字节码文件的各个部分，以帮助开发者深入了解字节码文件内容，进行字节码的分析和修改。\",\"4\":\"\",\"5\":\"- 方舟字节码文件格式：介绍字节码文件中包含的各个部分的结构信息，以及各种结构的存储方式和依赖关系。\",\"6\":\"\",\"7\":\"- 方舟字节码基本原理：介绍字节码中构成指令的重要概念和具体的指令格式及含义，帮助开发者了解方舟字节码指令，进行指令相关的特性开发工作。\",\"8\":\"\",\"9\":\"- 方舟字节码函数命名规则：介绍字节码文件中函数名字的字符串的命名规则。\",\"10\":\"\",\"11\":\"- 编译期自定义修改方舟字节码：介绍如何修改字节码文件的内容。\"}",
      "修改建议": "句子过长，包含多个逗号，信息量大，容易造成阅读困难。",
      "更改后示例": "介绍字节码中构成指令的重要概念、指令格式及含义，帮助开发者了解方舟字节码指令，进行相关特性开发。",
      "触发条件": "当句子中存在通过\"和\"连接的多个并列成分，且其中包含重复或冗余的名词（如\"指令\"重复出现），或修饰词（如\"具体的\"）与后续内容存在语义重复时触发。 \n\n识别模式：\n1. 检查并列结构中是否存在重复名词（如原句\"指令\"在\"概念\"和\"格式\"前重复）\n2. 识别\"和\"连接的短语是否包含可合并的同类项（如\"重要概念和具体的指令格式\"可简化为\"重要概念、指令格式\"）\n3. 检测修饰词是否与上下文形成冗余（如\"具体的\"在已明确讨论技术细节的语境中冗余）\n4. 判断句尾是否存在重复限定词（如\"指令相关的特性开发工作\"中\"指令\"在前文已限定，\"工作\"在技术文档中冗余）"
    },
    {
      "defect_id": 365928,
      "sentence": "最后，UI主线程接收到Task执行完毕后返回的ArrayBuffer数据，拼接并展示。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"首先，实现一个处理ArrayBuffer的接口，该接口在Task中执行。\",\"22\":\"\",\"23\":\"然后，通过拷贝方式将ArrayBuffer数据传递到Task中，并处理。\",\"24\":\"\",\"25\":\"最后，UI主线程接收到Task执行完毕后返回的ArrayBuffer数据，拼接并展示。\",\"26\":\"\",\"27\":\"```ts\",\"28\":\"// Index.ets\",\"29\":\"import { taskpool } from '@kit.ArkTS';\",\"30\":\"import { BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "句子包含不必要的修饰成分",
      "更改后示例": "UI主线程接收到Task返回的ArrayBuffer数据，拼接并展示。",
      "触发条件": "当句子中存在可通过上下文或主谓关系推断的冗余修饰成分（如\"执行完毕后\"修饰\"返回\"时，因\"返回\"动作已隐含任务完成状态），且删除后不影响核心信息传递时触发。"
    },
    {
      "defect_id": 363684,
      "sentence": "使用class来组织多个相关函数。",
      "reference_sentence": "",
      "line_num": 2158,
      "context": "{\"2153\":\"import('module')\",\"2154\":\"```\",\"2155\":\"\",\"2156\":\"## arkts-no-func-props\",\"2157\":\"\",\"2158\":\"使用class来组织多个相关函数。\",\"2159\":\"\",\"2160\":\"**应用代码**\",\"2161\":\"\",\"2162\":\"```typescript\",\"2163\":\"function foo(value: number): void {\"}",
      "修改建议": "缺少主语，导致句子不完整。",
      "更改后示例": "使用class组织相关函数。",
      "触发条件": "句子中包含冗余介词（如“来”）或冗余数量词（如“多个”），且上下文已隐含其必要性时触发。  \n识别模式：检测“使用...来...”结构中的冗余介词，或“多个”等数量词在上下文无明确需求时的冗余表达。"
    },
    {
      "defect_id": 367517,
      "sentence": "9. 元素均为Sendable类型的union type数据。",
      "reference_sentence": "",
      "line_num": 88,
      "context": "{\"83\":\"  - [可共享的色彩管理](../reference/apis-arkgraphics2d/js-apis-sendableColorSpaceManager.md)\",\"84\":\"  - [基于Sendable对象的图片处理](../reference/apis-image-kit/js-apis-sendableImage.md)\",\"85\":\"  - [资源管理](../reference/apis-localization-kit/js-apis-sendable-resource-manager.md)\",\"86\":\"  - [SendableContext对象管理](../reference/apis-ability-kit/js-apis-app-ability-sendableContextManager.md)\",\"87\":\"\",\"88\":\"- 元素均为Sendable类型的union type数据。\",\"89\":\"\",\"90\":\"> **说明：**\",\"91\":\">\",\"92\":\"> - JS内置对象在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，JS内置对象的实例不是Sendable类型。\",\"93\":\">\"}",
      "修改建议": "原文表述可以更简洁。",
      "更改后示例": "9. 元素均为Sendable类型的联合类型数据。",
      "触发条件": "技术术语存在中英文混合表述（如\"union type\"），且该术语存在广泛使用的中文对应译法（如\"联合类型\"）时触发；或同一概念在上下文已建立中文术语体系的情况下重复使用英文原词。"
    },
    {
      "defect_id": 367308,
      "sentence": "XML支持命名空间、实体引用、注释和处理指令等特性，使其能够灵活地适应各种数据需求。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"\",\"17\":\"XML可以通过使用XML Schema或DTD（文档类型定义）来定义文档结构。这些机制允许开发人员创建自定义规则以验证XML文档是否符合其预期的格式。\",\"18\":\"\",\"19\":\"\",\"20\":\"XML支持命名空间、实体引用、注释和处理指令等特性，使其能够灵活地适应各种数据需求。\",\"21\":\"\",\"22\":\"\",\"23\":\"语言基础类库提供了XML相关的基础能力，包括：[XML的生成](xml-generation.md)、[XML的解析](xml-parsing.md)和[XML的转换](xml-conversion.md)。\",\"24\":\"\",\"25\":\"以下是一个简单的XML样例及对应说明，更多XML的接口和具体使用，请见[@ohos.xml](../reference/apis-arkts/js-apis-xml.md)。\"}",
      "修改建议": "句子过长，包含多个逗号，可以拆分成更简洁的句子。",
      "更改后示例": "XML支持命名空间、实体引用、注释和处理指令等特性。这些特性使其能够灵活适应各种数据需求。",
      "触发条件": "当复合句包含两个及以上逗号分隔的独立信息单元，且后半部分为\"使其/使得...\"等结果状语从句时触发。\n\n具体识别模式：\n1. 主句列举多个并列成分后，使用逗号接续结果描述（如\"使其...\"）\n2. 句子总长度超过30字且包含≥2个逗号，后半部分为可独立成句的结论性内容\n3. 结果状语部分与前文存在隐性重复（如\"特性\"与\"这些特性\"的指代关系）"
    },
    {
      "defect_id": 367826,
      "sentence": "逐个替换Vector内的元素。",
      "reference_sentence": "",
      "line_num": 198,
      "context": "{\"193\":\"| 访问元素 | getLastIndexOf(element: T) | 获取最后一个匹配指定元素的位置。 |\",\"194\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, Vector?: Vector&lt;T&gt;) =&gt; void, thisArg?: Object) | 遍历访问整个Vector容器的元素。 |\",\"195\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"196\":\"| 修改元素 | set(index:number, element: T) | 修改指定index位置的元素值为element。 |\",\"197\":\"| 修改元素 | vec[index] = element | 修改指定index位置的元素值为element。 |\",\"198\":\"| 修改元素 | replaceAllElements(callbackFn: (value: T, index?: number, vector?: Vector&lt;T&gt;) => T, thisArg?: Object) | 逐个替换Vector内的元素。|\",\"199\":\"| 修改元素 | setLength(newSize:number) | 设置Vector的长度大小。 |\",\"200\":\"| 删除元素 | remove(element: T) | 删除第一个匹配到的元素。 |\",\"201\":\"| 删除元素 | removeByIndex(index:number) | 删除index位置对应的元素。 |\",\"202\":\"| 删除元素 | removeByRange(fromIndex:number,toIndex:number) | 删除指定范围内的元素。 |\",\"203\":\"\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "替换Vector内的元素。",
      "触发条件": "句子中包含可通过上下文或方法名推断出的重复性步骤描述（如\"逐个\"），且删除后不影响核心语义时触发。\n\n识别模式：检查是否存在冗余副词（如\"逐个\"、\"依次\"）或过程性描述，这些内容通常可被API名称（如replaceAllElements）或技术上下文（如迭代操作）隐含表达。"
    },
    {
      "defect_id": 367751,
      "sentence": "List依据泛型定义，在内存中的存储位置可以不连续。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"| 删除元素 | remove(element: T) | 删除第一个匹配到的元素。 |\",\"38\":\"| 删除元素 | removeByRange(fromIndex: number, toIndex:number) | 删除指定范围内的元素。 |\",\"39\":\"\",\"40\":\"## List\",\"41\":\"\",\"42\":\"[List](../reference/apis-arkts/js-apis-list.md)可用来构造一个单向链表对象，即只能通过头结点开始访问到尾节点。List依据泛型定义，在内存中的存储位置可以不连续。\",\"43\":\"\",\"44\":\"List和[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)相比，LinkedList是双向链表，支持快速在头部和尾部进行增删操作，而List是单向链表，不支持双向操作。\",\"45\":\"\",\"46\":\"当需要频繁的插入删除元素，并且需要使用单向链表时，推荐使用List高效操作。\",\"47\":\"\"}",
      "修改建议": "句子过于啰嗦。",
      "更改后示例": "List依据泛型定义，存储位置可以不连续。",
      "触发条件": "当句子中存在冗余的介词短语（如“在内存中的”），且其修饰的名词（如“存储位置”）已隐含该短语的语义时触发。"
    },
    {
      "defect_id": 368379,
      "sentence": "修改元素 | forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray\\<T>) => void, thisArg?: Object) | 通过遍历修改整个PlainArray的元素。",
      "reference_sentence": "",
      "line_num": 206,
      "context": "{\"201\":\"| 访问元素 | getKeyAt(index: number) | 获取指定index对应的key值。 |\",\"202\":\"| 访问元素 | getValueAt(index: number) | 获取指定index对应的value值。 |\",\"203\":\"| 访问元素 | forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray\\\\<T>) => void, thisArg?: Object) | 遍历访问整个PlainArray的元素。 |\",\"204\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;[number, T]&gt; | 创建迭代器以进行数据访问。 |\",\"205\":\"| 修改元素 | setValueAt(index:number, value: T) | 修改指定index对应的value值。 |\",\"206\":\"| 修改元素 | forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray\\\\<T>) => void, thisArg?: Object) | 通过遍历修改整个PlainArray的元素。 |\",\"207\":\"| 删除元素 | remove(key: number) | 删除PlainArray中指定key匹配到的键值对。 |\",\"208\":\"| 删除元素 | removeAt(index: number) | 删除PlainArray中指定index对应的键值对。 |\",\"209\":\"| 删除元素 | removeRangeFrom(index: number, size: number) | 删除PlainArray中指定范围内的元素。 |\",\"210\":\"| 删除元素 | clear() | 清空整个PlainArray。 |\",\"211\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "修改元素 | forEach(callbackFn: (value: T, index?: number, PlainArray?: PlainArray\\<T>) => void, thisArg?: Object) | 遍历修改PlainArray的元素。",
      "触发条件": "当句子中存在表示方式的冗余介词结构（如\"通过...\"）或包含不必要的范围限定词（如\"整个\"）时触发。\n\n具体识别模式：\n1. 检测\"通过+动词\"结构（如\"通过遍历\"），若该动词本身已隐含动作方式（如\"遍历\"本身即表示操作方式），则判定为冗余\n2. 识别\"整个+对象\"组合，当上下文已明确操作对象范围且无部分操作可能性时（如数组遍历必然覆盖全部元素），判定为多余限定词\n3. 同时检查是否存在双重修饰（如同时出现\"通过\"和\"整个\"），优先去除最外层冗余成分"
    },
    {
      "defect_id": 367407,
      "sentence": "确保传入的XML数据符合标准格式。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"| tokenValueCallbackFunction | (eventType: EventType, value: ParseInfo) =&gt; boolean | 否 | 获取tokenValue回调函数，打印标签事件类型及parseInfo对应属性。默认为undefined，表示不解析XML事件类型。 |\",\"19\":\"\",\"20\":\"\",\"21\":\"## 注意事项\",\"22\":\"\",\"23\":\"- 确保传入的XML数据符合标准格式。\",\"24\":\"\",\"25\":\"- 目前不支持按指定节点解析对应的节点值。\",\"26\":\"\",\"27\":\"\",\"28\":\"## 解析XML标签和标签值\"}",
      "修改建议": "言简意赅，但可以更简洁。",
      "更改后示例": "确保XML数据格式正确。",
      "触发条件": "当句子包含可通过上下文推断的冗余限定词（如\"传入的\"）或重复性修饰词（如\"标准格式\"可简化为\"格式正确\"）时触发。\n\n识别模式：\n1. 存在显式限定词（如所属关系、来源描述），而上下文已隐含该信息\n2. 使用\"标准/正确/符合\"等双重修饰结构，其中单个词汇即可完整表达语义（如\"符合标准格式\"→\"格式正确\"）"
    },
    {
      "defect_id": 367508,
      "sentence": "1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。",
      "reference_sentence": "",
      "line_num": 61,
      "context": "{\"56\":\"\",\"57\":\"### Sendable interface\",\"58\":\"\",\"59\":\"Sendable interface需同时满足以下两个规则：\",\"60\":\"\",\"61\":\"1. 当且仅当是[ISendable](#isendable)或者继承了ISendable。\",\"62\":\"\",\"63\":\"2. 需满足Sendable约束，详情可查[Sendable使用规则](sendable-constraints.md)。\",\"64\":\"\",\"65\":\"### Sendable支持的数据类型\",\"66\":\"\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "1. 是[ISendable](#isendable)或其子类。",
      "触发条件": "当句子中同时出现逻辑限定词（如\"当且仅当\"）与可简化的并列结构（如\"或继承\"），或存在可通过专业术语（如\"子类\"）替代的冗长解释时触发。\n\n识别模式：检测\"当且仅当/X或Y\"双重限定结构，或\"继承\"动作描述与接口名称重复出现的情况，优先匹配可被单一术语（如子类/派生类）替代的冗余表达。"
    },
    {
      "defect_id": 367296,
      "sentence": "ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS基础类库概述\",\"2\":\"\",\"3\":\"ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。\",\"4\":\"\",\"5\":\"ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。\"}",
      "修改建议": "句子过长，包含多个信息点，可拆分为两个句子。",
      "更改后示例": "ArkTS基础类库是一个功能齐全的API集合。它精心设计了一系列关键且实用的功能模块。",
      "触发条件": "当句子由逗号连接两个及以上独立主谓结构（即包含多个完整信息点）且总长度超过建议阈值（如30词）时触发。  \n\n识别模式：检测复合句中的逗号分隔子句是否各自具备独立主语或谓语，并评估整体可读性（如信息密度过高、逻辑层次混杂）。"
    },
    {
      "defect_id": 368347,
      "sentence": "一般需要存储有序键值对的场景，可以使用TreeMap。",
      "reference_sentence": "",
      "line_num": 77,
      "context": "{\"72\":\"\",\"73\":\"TreeMap依据泛型定义，key是有序存储的。底层基于红黑树实现，支持快速的插入和删除，key的类型满足ECMA标准。\",\"74\":\"\",\"75\":\"TreeMap和[HashMap](../reference/apis-arkts/js-apis-hashmap.md)相比，HashMap依据键的hashCode存取数据，访问速度较快。而TreeMap是有序存取，效率较低。\",\"76\":\"\",\"77\":\"一般需要存储有序键值对的场景，可以使用TreeMap。\",\"78\":\"\",\"79\":\"TreeMap支持增、删、改、查操作，常用API如下：\",\"80\":\"\",\"81\":\"| 操作 | 方法 | 描述 |\",\"82\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子包含不必要的修饰成分",
      "更改后示例": "需要存储有序键值对时，使用TreeMap。",
      "触发条件": "句子包含表示泛化场景的冗余修饰词（如\"一般\"、\"通常\"）或冗余名词结构（如\"的场景\"），且存在可简化为\"时\"的时间状语结构。"
    },
    {
      "defect_id": 368376,
      "sentence": "修改元素 | forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet\\<T>) => void, thisArg?: Object) | 通过遍历修改整个set的元素。",
      "reference_sentence": "",
      "line_num": 178,
      "context": "{\"173\":\"| 访问元素 | getValueAt(index: number) | 获取指定index对应的value值。 |\",\"174\":\"| 访问元素 | values() | 返回一个迭代器对象，包含set中的所有value值。 |\",\"175\":\"| 访问元素 | entries() | 返回一个迭代器对象，包含类似键值对的数组，键值都是value。 |\",\"176\":\"| 访问元素 | forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet\\\\<T>) => void, thisArg?: Object) | 遍历访问整个set的元素。 |\",\"177\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;T&gt; | 创建迭代器以进行数据访问。 |\",\"178\":\"| 修改元素 | forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet\\\\<T>) => void, thisArg?: Object) | 通过遍历修改整个set的元素。 |\",\"179\":\"| 删除元素 | remove(key: K) | 删除set中匹配到的键值对。 |\",\"180\":\"| 删除元素 | removeAt(index: number) | 删除set中指定index对应的值。 |\",\"181\":\"| 删除元素 | clear() | 清空整个set。 |\",\"182\":\"\",\"183\":\"## PlainArray\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "修改元素 | forEach(callbackFn: (value?: T, key?: T, set?: LightWeightSet\\<T>) => void, thisArg?: Object) | 遍历修改set的元素。",
      "触发条件": "当句子出现\"通过+动词\"的冗余介词结构，或包含\"整个\"等不必要限定词，且删除后不影响语义完整性时触发。\n\n识别模式需同时满足：\n1. 存在\"通过+动词\"结构（如\"通过遍历\"可简化为\"遍历\"）\n2. 或包含\"整个\"等绝对范围限定词（当动作本身隐含完整操作时）\n3. 修饰成分删除后核心语义保持不变（如\"修改set元素\"已隐含完整操作，无需强调\"整个\"）"
    },
    {
      "defect_id": 369332,
      "sentence": "JSVM-API和Native模块之间的交互流程，主要分为以下两步：",
      "reference_sentence": "",
      "line_num": 54,
      "context": "{\"49\":\"\",\"50\":\"**图2** JSVM-API的关键交互流程\",\"51\":\"\",\"52\":\"![JSVM-API 关键交互流程](figures/process_jsvm-api.png)\",\"53\":\"\",\"54\":\"JSVM-API和Native模块之间的交互流程，主要分为以下两步：\",\"55\":\"\",\"56\":\"1. **初始化阶段**：在Native模块上初始化JSVM和JS上下文，并完成Native函数的注册。Native方法将会被挂载到JS执行环境的全局上下文即GlobalThis。\",\"57\":\"\",\"58\":\"2. **调用阶段**：当JS侧调用通过JSVM-API注册到JS全局上下文的方法时，JS引擎会找到并调用对应的C/C++方法。\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "JSVM-API和Native模块的交互流程分为两步：",
      "触发条件": "当句子中出现冗余限定词（如\"之间\"、\"主要\"、\"以下\"）与核心名词构成重复语义，且删除后不影响技术准确性和表述完整性时触发。\n\n识别模式：检测\"名词A和名词B之间的...\"结构中的\"之间\"冗余，以及流程描述中\"主要分为以下X步\"这类三重修饰结构（主要/以下/数字量词），当上下文已明确流程范围且数字量词直接对应后续列表时，应删除冗余修饰成分。"
    },
    {
      "defect_id": 368378,
      "sentence": "当需要存储key值为number类型的键值对时，可以使用PlainArray。",
      "reference_sentence": "",
      "line_num": 191,
      "context": "{\"186\":\"\",\"187\":\"初始默认容量大小为16，每次扩容大小为原始容量的2倍。\",\"188\":\"\",\"189\":\"PlainArray和[LightWeightMap](../reference/apis-arkts/js-apis-lightweightmap.md)都是用来存储键值对，且均采用轻量级结构，但PlainArray的key值类型仅限于number。\",\"190\":\"\",\"191\":\"当需要存储key值为number类型的键值对时，可以使用PlainArray。\",\"192\":\"\",\"193\":\"PlainArray支持增、删、改、查操作，常用API如下：\",\"194\":\"\",\"195\":\"| 操作 | 方法 | 描述 |\",\"196\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "需要存储key值为number类型的键值对时，使用PlainArray。",
      "触发条件": "句子中出现冗余的时间状语引导词（如“当”）或非必要的助动词（如“可以”），且删除后不影响语义完整性及技术准确性时触发。具体表现为“当...时”结构可简化为“...时”，或建议性动词短语（如“可以使用”）可替换为直接陈述（如“使用”）。"
    },
    {
      "defect_id": 369060,
      "sentence": "通过给定的构造函数，构建一个实例。",
      "reference_sentence": "",
      "line_num": 377,
      "context": "{\"372\":\"\",\"373\":\"### class相关\",\"374\":\"\",\"375\":\"| 接口 | 功能说明 |\",\"376\":\"| -------- | -------- |\",\"377\":\"| napi_new_instance | 通过给定的构造函数，构建一个实例。 |\",\"378\":\"| napi_get_new_target | 获取构造函数调用的new.target。 |\",\"379\":\"| napi_define_class | 定义与C++类相对应的JavaScript类。 |\",\"380\":\"| napi_wrap | 在ArkTS对象上绑定一个Node-API模块对象实例。这个函数通常在将Node-API模块对象与ArkTS对象进行绑定时使用，以便在ArkTS中使用本地对象的方法和属性。 |\",\"381\":\"| napi_unwrap | 从ArkTS对象上获取之前绑定的Node-API模块对象实例。 |\",\"382\":\"| napi_remove_wrap | 从ArkTS对象上获取之前绑定的Node-API模块对象实例，并解除绑定。 |\"}",
      "修改建议": "句子结构为介词短语，不符合主谓结构或主谓宾结构的要求。",
      "更改后示例": "构建一个实例。",
      "触发条件": "当技术文档中的接口功能描述采用\"介词短语+动词\"结构（如\"通过...，构建...\"），且介词短语内容已在接口名称或上下文明确体现时触发。识别模式为句子缺少主谓结构且存在重复说明接口参数/功能的情况。"
    },
    {
      "defect_id": 368964,
      "sentence": "该优先级的级别低于napi_priority_immediate。",
      "reference_sentence": "",
      "line_num": 250,
      "context": "{\"245\":\"```\",\"246\":\"\",\"247\":\"| 任务优先级 | 解释说明 |\",\"248\":\"| -------- | -------- |\",\"249\":\"| napi_priority_immediate | 该优先级的级别最高。|\",\"250\":\"| napi_priority_high | 该优先级的级别低于napi_priority_immediate。|\",\"251\":\"| napi_priority_low | 该优先级的级别低于napi_priority_immediate和napi_priority_high。|\",\"252\":\"| napi_priority_idle | 该优先级的级别最低。 |\",\"253\":\"\",\"254\":\"## 支持的Node-API接口\",\"255\":\"\"}",
      "修改建议": "原文含有冗余信息，可以直接表达。",
      "更改后示例": "优先级低于napi_priority_immediate。",
      "触发条件": "当句子中同时出现\"X的级别\"结构（X本身已含等级属性）且后续描述已明确比较关系时，应触发冗余表达规则。识别模式为检测到名词短语包含双重等级指示（如\"优先级\"+\"级别\"）且存在可删除的重复限定词（如\"该...的级别\"）。"
    },
    {
      "defect_id": 370348,
      "sentence": "JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。",
      "reference_sentence": "",
      "line_num": 800,
      "context": "{\"795\":\"\",\"796\":\"### 使用 JSVM-API WebAssembly 接口编译 wasm module\",\"797\":\"\",\"798\":\"#### 场景介绍\",\"799\":\"\",\"800\":\"JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。\",\"801\":\"详见[使用 JSVM-API WebAssembly 接口](use-jsvm-about-wasm.md)。\",\"802\":\"\",\"803\":\"#### 接口说明\",\"804\":\"\",\"805\":\"| 接口                          | 功能说明                                                                                 |\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "JSVM-API WebAssembly 接口提供 WebAssembly 字节码编译、函数优化、cache 序列化和反序列化功能。",
      "触发条件": "当并列结构中出现重复的前缀/修饰语（如\"WebAssembly\"连续三次修饰不同功能），且导致句子结构臃肿（超过3个逗号分隔项）时触发。\n\n识别模式：\n1. 检测长句中的并列结构（通过顿号/逗号+连词分割）\n2. 分析并列项是否包含重复前缀（通过NLP依存句法分析识别修饰关系）\n3. 当重复前缀出现≥2次且造成冗余时，保留首个修饰语并删除后续重复项"
    },
    {
      "defect_id": 368089,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\",\"21\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，应拆分。",
      "更改后示例": "存储具有关联关系的键值对集合，键唯一，底层采用轻量级结构，键固定为number类型。适用于存储键为number类型键值对的场景。",
      "触发条件": "同一句子或相邻上下文中重复出现相同语义元素（如\"存储元素中键唯一\"与\"键唯一\"），或存在冗余比较结构（如\"与LightWeightMap一样\"）时触发。\n\n识别模式：\n1. 语义重复检测：当主谓结构重复出现（如\"存储元素中键唯一\"在前文已有定义时，后续出现\"键唯一\"即视为重复）\n2. 冗余修饰识别：存在明确比较对象（如\"与...一样\"）但比较对象已在前文充分定义\n3. 冗余副词过滤：程度副词\"更加\"出现在已明确特征的描述中（如已知是轻量级结构时）\n4. 信息密度判断：单句超过3个并列信息点且存在可合并的重复元素（如\"number类型\"重复出现）"
    },
    {
      "defect_id": 368380,
      "sentence": "此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示：",
      "reference_sentence": "",
      "line_num": 214,
      "context": "{\"209\":\"| 删除元素 | removeRangeFrom(index: number, size: number) | 删除PlainArray中指定范围内的元素。 |\",\"210\":\"| 删除元素 | clear() | 清空整个PlainArray。 |\",\"211\":\"\",\"212\":\"## 非线性容器的使用\",\"213\":\"\",\"214\":\"此处列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素及修改等操作，示例代码如下所示：\",\"215\":\"\",\"216\":\"\",\"217\":\"```ts\",\"218\":\"// HashMap\",\"219\":\"import { HashMap } from '@kit.ArkTS'; // 导入HashMap模块\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗余。",
      "更改后示例": "列举常用的非线性容器HashMap、TreeMap、LightWeightMap、PlainArray的使用示例，包括导入模块、增加元素、访问元素和修改操作。示例代码如下：",
      "触发条件": "句子包含由多个逗号分隔的冗长并列结构，且存在冗余连接词（如“及”“等”）或重复性引导语（如“示例代码如下所示”中的“如下所示”）。"
    },
    {
      "defect_id": 367329,
      "sentence": "通过调用不同的方法来写入不同的内容，如startElement(name: string)写入元素开始标记，setText(text: string)写入标签值。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"## 开发步骤\",\"18\":\"\",\"19\":\"XML模块提供XmlSerializer类来生成XML数据，输入为固定长度的ArrayBuffer或DataView对象，该对象用于存放生成的XML数据。\",\"20\":\"\",\"21\":\"通过调用不同的方法来写入不同的内容，如startElement(name: string)写入元素开始标记，setText(text: string)写入标签值。\",\"22\":\"\",\"23\":\"XML模块的API接口可以参考[@ohos.xml](../reference/apis-arkts/js-apis-xml.md)的详细描述，按需求调用对应函数可以生成一份完整的XML数据。\",\"24\":\"\",\"25\":\"1. 引入模块。\",\"26\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "调用不同方法写入不同内容，如startElement(name: string)写入元素开始标记，setText(text: string)写入标签值。",
      "触发条件": "当句子包含可简化的介词结构（如\"通过...\"）或重复修饰成分（如\"不同的方法\"与\"不同的内容\"），且删除后不影响核心语义时触发。\n\n识别模式：\n1. 检查介词引导的冗长状语（如\"通过调用方法\"可简化为\"调用方法\"）\n2. 定位相邻重复修饰词（如连续出现\"不同...不同...\"结构）\n3. 验证简化后是否保留完整技术逻辑（如删除\"通过\"后仍能准确表达方法调用关系）"
    },
    {
      "defect_id": 370206,
      "sentence": "这是一个枚举数据类型，用来表示 JSVM-API 接口返回的状态信息。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## JSVM-API 的数据类型\",\"4\":\"\",\"5\":\"### `JSVM_Status`\",\"6\":\"\",\"7\":\"    这是一个枚举数据类型，用来表示 JSVM-API 接口返回的状态信息。\",\"8\":\"\",\"9\":\"    每调用一次 JSVM-API 函数，都会返回一个值，用来表示操作成功与否的相关信息。\",\"10\":\"\",\"11\":\"```c++\",\"12\":\"    typedef enum {\"}",
      "修改建议": "句子过于冗长，可以简化。",
      "更改后示例": "这是一个表示 JSVM-API 接口返回状态信息的枚举类型。",
      "触发条件": "当句子中同时存在重复的名词描述（如\"枚举数据类型\"+\"枚举类型\"）和解释性动词结构（如\"用来表示\"+\"表示\"）时，或出现可合并的复合句式（如主系表结构+目的状语从句）时触发。  \n\n识别模式：  \n1. 检测\"名词短语+用途说明\"双重描述结构（如：枚举数据类型，用来表示... → 合并为\"表示...的枚举类型\"）  \n2. 识别冗余动词结构（如\"用来表示\"可简化为\"表示\"），并验证前后语义是否允许简化而不丢失关键信息"
    },
    {
      "defect_id": 370347,
      "sentence": "OH_JSVM_CreateCodeCache 接口用法可参考[使用 code cache 加速编译](use-jsvm-about-code-cache.md)。",
      "reference_sentence": "",
      "line_num": 794,
      "context": "{\"789\":\"```ts\",\"790\":\"RunWithOption: success: 1\",\"791\":\"RunWithOrigin: success: 1\",\"792\":\"```\",\"793\":\"\",\"794\":\"OH_JSVM_CreateCodeCache 接口用法可参考[使用 code cache 加速编译](use-jsvm-about-code-cache.md)。\",\"795\":\"\",\"796\":\"### 使用 JSVM-API WebAssembly 接口编译 wasm module\",\"797\":\"\",\"798\":\"#### 场景介绍\",\"799\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "参考[使用 code cache 加速编译](use-jsvm-about-code-cache.md)。",
      "触发条件": "当句子中存在重复说明功能/用途的名词短语（如\"接口用法\"）或冗余动词结构（如\"可参考\"），且上下文已明确提示操作对象时。\n\n具体识别模式：\n1. 名词短语+链接引用结构：检测\"接口/方法/功能名称 + 用法/使用/功能\"等组合后接参考链接的情况\n2. 冗余助动词：识别\"可/可以/应该/需要\"等修饰词与\"参考/参见\"等引用动词的冗余组合\n3. 上下文验证：结合代码块等上下文环境，确认被修饰对象已在前文明确说明其用途"
    },
    {
      "defect_id": 370217,
      "sentence": "id 代表这个编译选项的类型。",
      "reference_sentence": "",
      "line_num": 132,
      "context": "{\"127\":\"#### JSVM_CompileOptions\",\"128\":\"\",\"129\":\"配合编译接口 OH_JSVM_CompileScriptWithOptions 使用，是其参数中 options 数组的元素类型。\",\"130\":\"\",\"131\":\"其中：\",\"132\":\"- id 代表这个编译选项的类型。\",\"133\":\"- content 代表编译选项的内容。\",\"134\":\"\",\"135\":\"id 的值和 content 的类型需要对应使用，详细对应关系参考下面对各个选项类型的介绍。\",\"136\":\"\",\"137\":\"```c\"}",
      "修改建议": "句子过于冗长，可以简化。",
      "更改后示例": "id 表示编译选项的类型。",
      "触发条件": "句子中存在冗余的指示代词（如“这个”“该”）或重复的名词短语，且上下文已明确指代对象时触发。例如：当“代表这个XX的类型”可简化为“表示XX类型”且不影响语义时。"
    },
    {
      "defect_id": 370209,
      "sentence": "在C++代码中，表示一个JavaScript值。",
      "reference_sentence": "",
      "line_num": 56,
      "context": "{\"51\":\"} JSVM_ExtendedErrorInfo;\",\"52\":\"```\",\"53\":\"\",\"54\":\"### JSVM_Value\",\"55\":\"\",\"56\":\"在C++代码中，表示一个JavaScript值。\",\"57\":\"\",\"58\":\"### JSVM_Env\",\"59\":\"\",\"60\":\"- 用于表示JSVM-API执行时的上下文，Native侧函数入参，并传递给函数中的JSVM-API接口。\",\"61\":\"\"}",
      "修改建议": "句子过于冗长，可以简化。",
      "更改后示例": "表示一个 JavaScript 值。",
      "触发条件": "当句子中存在可通过上下文推断的冗余介词短语（如\"在...中\"结构），且该短语未提供新信息时触发。\n\n识别模式：检查介词短语是否与上下文存在语义重复（如上下文已明确编程语言环境），并判断删除后是否仍能保持语义完整性。例如当上下文标题已包含\"C++\"（如\"### JSVM_Value\"）时，句首的\"在C++代码中\"即构成冗余。"
    },
    {
      "defect_id": 370349,
      "sentence": "详见[使用 JSVM-API WebAssembly 接口](use-jsvm-about-wasm.md)。",
      "reference_sentence": "",
      "line_num": 801,
      "context": "{\"796\":\"### 使用 JSVM-API WebAssembly 接口编译 wasm module\",\"797\":\"\",\"798\":\"#### 场景介绍\",\"799\":\"\",\"800\":\"JSVM-API WebAssembly 接口提供了 WebAssembly 字节码编译、WebAssembly 函数优化、WebAssembly cache 序列化和反序列化的能力。\",\"801\":\"详见[使用 JSVM-API WebAssembly 接口](use-jsvm-about-wasm.md)。\",\"802\":\"\",\"803\":\"#### 接口说明\",\"804\":\"\",\"805\":\"| 接口                          | 功能说明                                                                                 |\",\"806\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "参考[使用 JSVM-API WebAssembly 接口](use-jsvm-about-wasm.md)。",
      "触发条件": "当句子中存在冗余的指示性动词（如\"详见\"）且上下文已明确链接指向具体内容时，或使用重复修饰成分强调文档内链功能时。\n\n识别模式：检查是否在超链接前出现\"详见/参见\"等冗余引导词，或存在\"详细/进一步\"等重复修饰语（例：\"详见[标题](链接)\"可简化为\"[标题](链接)\"或\"参考[标题](链接)\"）。"
    },
    {
      "defect_id": 370560,
      "sentence": "此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。",
      "reference_sentence": "",
      "line_num": 1196,
      "context": "{\"1191\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Null或Undefined。相当于JS中的`value == null`。",
      "触发条件": "当相邻句子存在重复的主语指代(如\"这\")且后句为前句的补充说明时，或当技术文档出现\"相当于/等同于...\"的重复解释结构时。\n\n具体识别模式：1) 连续两个短句使用相同主语开头(\"此API...这相当于\") 2) 存在用逗号连接的解释性重复句式(如\"A...，相当于B\") 3) 技术等价说明与功能描述形成语义重复"
    },
    {
      "defect_id": 370638,
      "sentence": "将因JavaScript对象而保持活跃的外部分配的内存大小及时通知给底层虚拟机，虚拟机后续触发GC时，就会综合内外内存状态来判断是否进行全局GC。即增大外部内存分配，则会增大触发全局GC的概率；反之减少。",
      "reference_sentence": "",
      "line_num": 2026,
      "context": "{\"2021\":\"内存管理。\",\"2022\":\"\",\"2023\":\"#### 接口说明\",\"2024\":\"| 接口                                          | 功能说明                                                                                                   |\",\"2025\":\"| ------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\",\"2026\":\"| OH_JSVM_AdjustExternalMemory                | 将因JavaScript对象而保持活跃的外部分配的内存大小及时通知给底层虚拟机，虚拟机后续触发GC时，就会综合内外内存状态来判断是否进行全局GC。即增大外部内存分配，则会增大触发全局GC的概率；反之减少。 |\",\"2027\":\"| OH_JSVM_MemoryPressureNotification          | 通知虚拟机系统内存压力层级，并有选择地触发垃圾回收。                                                                             |\",\"2028\":\"| OH_JSVM_AllocateArrayBufferBackingStoreData | 申请一块 BackingStore 内存。 |\",\"2029\":\"| OH_JSVM_FreeArrayBufferBackingStoreData | 释放 BackingStore 内存。 |\",\"2030\":\"| OH_JSVM_CreateArrayBufferFromBackingStoreData | 基于申请的 BackingStore 内存创建 array buffer。 |\",\"2031\":\"\"}",
      "修改建议": "句子过长，包含多个信息点",
      "更改后示例": "通知虚拟机外部内存大小，以决定是否触发全局GC。",
      "触发条件": "当句子长度超过技术文档推荐标准（通常超过50字）且包含多个并列信息点（功能说明+机制解释+因果关系）时触发；当出现\"即\"等解释性连接词引导重复说明时触发。\n\n识别模式：\n1. 复合长句结构：包含分号、破折号或\"即\"等连接词，形成主句+解释性从句的嵌套结构\n2. 多维度说明：同时存在功能描述（通知内存状态）、机制说明（GC判断逻辑）、因果推论（内存大小与GC概率关系）\n3. 对比句式：使用\"反之\"等对比词引入反向推论，形成信息过载\n4. 技术文档特定场景：出现在接口说明表等需要简明性的位置，与相邻条目存在明显信息密度差异"
    },
    {
      "defect_id": 370561,
      "sentence": "此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。",
      "reference_sentence": "",
      "line_num": 1197,
      "context": "{\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Boolean。相当于JS中的`typeof value === 'boolean'`。",
      "触发条件": "当连续两个短句存在重复主语且后句以\"这相当于\"开头说明等效代码时，或同一语义内容被拆分为多个短句造成结构冗余时。\n\n识别模式：\n1. 检测\"主语重复\"：前句主语为\"此API\"，后句以\"这\"指代开头形成重复指代\n2. 匹配\"等效说明\"模式：后句包含\"相当于JS中的...\"的代码对照说明\n3. 分析句式结构：两个短句表达同一API的检查功能和实现原理，合并后语义更紧凑\n4. 检查标点特征：原句使用句号分隔本可合并的关联内容，符合\"逗号合并\"优化场景"
    },
    {
      "defect_id": 372697,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"| OH_JSVM_JsonParse          | 解析JSON字符串，并将结果存储在JSON对象。 |\",\"16\":\"| OH_JSVM_JsonStringify      | 将对象字符串化，并将结果存储在JSVM字符串对象。 |\",\"17\":\"\",\"18\":\"## 使用示例\",\"19\":\"\",\"20\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"21\":\"\",\"22\":\"### OH_JSVM_JsonParse && OH_JSVM_JsonStringify\",\"23\":\"\",\"24\":\"对JSON对象进行解析操作，并输出解析结果的有效值。\",\"25\":\"\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示接口对应的C++代码。",
      "触发条件": "同一句子中重复出现相同语义的名词短语（如\"JSVM-API接口开发流程\"与链接文本重复），或存在冗余修饰词（如\"相关\"、\"进行\"等）导致信息密度降低时触发。识别模式为：1）前后分句存在语义重复的专有名词/流程描述；2）使用\"仅对...进行展示\"等复杂结构替代简单动词结构。"
    },
    {
      "defect_id": 370563,
      "sentence": "此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。",
      "reference_sentence": "",
      "line_num": 1199,
      "context": "{\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\",\"1203\":\"|OH_JSVM_IsBigInt | 此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。 |\",\"1204\":\"|OH_JSVM_IsConstructor | 此API检查传入的值是否为构造函数。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为String。相当于JS中的`typeof value === 'string'`。",
      "触发条件": "当相邻短句共享相同主语且后句以复指代词（如\"这\"）开头时，或存在重复解释同一概念的连续分句时触发。\n\n识别模式：\n1. 结构检测：前句为\"此API...\"的功能描述，后句以\"这相当于...\"开头形成独立短句\n2. 冗余特征：后句主语\"这\"与前句主语\"此API\"形成语义重复\n3. 句式特征：存在可合并的连续判断句（检测X类型 + 等价JS表达式说明）\n4. 上下文模式：在同类API说明条目中保持统一表达规范"
    },
    {
      "defect_id": 370559,
      "sentence": "此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。",
      "reference_sentence": "",
      "line_num": 1195,
      "context": "{\"1190\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1191\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Null对象。相当于JS中的`value === null`。",
      "触发条件": "当连续两个短句共享同一主语且后句以\"这\"开头进行补充说明时，或存在重复性解释结构（如\"X相当于Y\"）导致语义重叠时。\n\n识别模式：1) 前句描述功能，后句以\"这相当于...\"开头进行代码映射；2) 两个短句间存在强逻辑关联，可通过合并消除重复主语；3) 后句使用等同性表达（相当于/等同于/等于）解释前句技术实现。"
    },
    {
      "defect_id": 370989,
      "sentence": "使用JSVM-API实现跨语言交互，首先需要按照JSVM-API的机制实现模块的注册和加载等相关动作。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# 使用JSVM-API实现JS与C/C++语言交互开发流程\",\"2\":\"\",\"3\":\"使用JSVM-API实现跨语言交互，首先需要按照JSVM-API的机制实现模块的注册和加载等相关动作。\",\"4\":\"\",\"5\":\"- ArkTS/JS侧：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。\",\"6\":\"\",\"7\":\"- Native侧：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。\",\"8\":\"\"}",
      "修改建议": "原句含有不必要的修饰成分，且逗号使用过多。",
      "更改后示例": "使用JSVM-API实现模块的注册和加载。",
      "触发条件": "当句子中存在重复性修饰语（如\"按照JSVM-API的机制\"）且上下文已明确隐含该信息时，或出现冗余结构（如\"等相关动作\"）导致语义重复时。识别模式为：1) 同一名词短语重复出现（如\"JSVM-API\"双重复指）2) 存在可被上下文覆盖的限定词（如\"跨语言交互\"在标题中已明示）3) 使用无实义的补充性短语（如\"相关动作\"）。"
    },
    {
      "defect_id": 372807,
      "sentence": "ArrayBuffer 是 JavaScript 中的一种数据类型，用于表示通用的、固定长度的原始二进制数据缓冲区。它提供了一种在 JavaScript 中有效地表示和操作原始二进制数据的方式。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行ArrayBuffer相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"ArrayBuffer 是 JavaScript 中的一种数据类型，用于表示通用的、固定长度的原始二进制数据缓冲区。它提供了一种在 JavaScript 中有效地表示和操作原始二进制数据的方式。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- **ArrayBuffer**：ArrayBuffer 对象用来表示一个通用的、固定长度的原始二进制数据缓冲区。不能直接操作 ArrayBuffer 的内容，而是需要通过包装成 TypedArray 对象或 DataView 对象来读写。ArrayBuffer 常用于处理大量的二进制数据，如文件、网络数据包等。\",\"10\":\"- **生命周期和内存管理**：在使用 JSVM 处理 ArrayBuffer 时，需要特别注意生命周期和内存管理。\"}",
      "修改建议": "句子过长，包含多个逗号，可以拆分成两个句子。",
      "更改后示例": "ArrayBuffer 是 JavaScript 中的一种数据类型，用于表示通用的、固定长度的原始二进制数据缓冲区。它提供了一种有效地表示和操作原始二进制数据的方式。",
      "触发条件": "同一上下文信息在相邻句子中重复出现（如\"在 JavaScript 中\"），且句子结构包含连续逗号分隔的复合句式时触发。\n\n识别模式：\n1. 语义重复检测：通过上下文分析识别同一语义元素（如环境限定词、技术领域）在相邻分句中的重复\n2. 结构复杂度判断：当单句包含≥2个逗号分隔的补充说明成分，且分句间存在共享主语/宾语时，判定为可拆分的冗余表达"
    },
    {
      "defect_id": 370558,
      "sentence": "此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。",
      "reference_sentence": "",
      "line_num": 1194,
      "context": "{\"1189\":\"|OH_JSVM_IsArray | 判断一个 JavaScript 对象是否为 Array 类型对象|\",\"1190\":\"|OH_JSVM_IsArraybuffer | 判断一个 JavaScript 对象是否为 Arraybuffer 类型对象 |\",\"1191\":\"|OH_JSVM_IsDate | 判断一个 JavaScript 对象是否为 Date 类型对象 |\",\"1192\":\"|OH_JSVM_IsTypedarray | 判断一个 JavaScript 对象是否为 Typedarray 类型对象 |\",\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Undefined。相当于JS中的`value === undefined`。",
      "触发条件": "相邻句子存在重复主语结构（如\"这\"指代前文）+ 后句内容为前句技术实现的等效说明\n\n识别模式需检测以下特征组合：\n1. 前句为功能描述（包含\"检查/判断/检测\"等动词）\n2. 后句以\"这\"开头且包含技术等效说明（如\"相当于/等同于/对应\"等连接词）\n3. 两句话指向同一技术概念（通过API名称和参数值匹配确认）"
    },
    {
      "defect_id": 370562,
      "sentence": "此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。",
      "reference_sentence": "",
      "line_num": 1198,
      "context": "{\"1193\":\"|OH_JSVM_IsDataview | 判断一个 JavaScript 对象是否为 Dataview 类型对象 |\",\"1194\":\"|OH_JSVM_IsUndefined | 此API检查传入的值是否为Undefined。这相当于JS中的`value === undefined`。 |\",\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\",\"1203\":\"|OH_JSVM_IsBigInt | 此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Number。相当于JS中的`typeof value === 'number'`。",
      "触发条件": "当相邻句子存在重复主语指代（后句以\"这\"开头指代前句主语），且两个分句描述同一逻辑关系时触发。\n\n识别模式：\n1. 前句主语为具体名词（如\"此API\"）\n2. 后句以\"这\"开头形成独立分句\n3. 两个分句使用句号分隔但存在语义重复\n4. 上下文存在同类表述的平行结构（如其他API说明均使用单句表述）"
    },
    {
      "defect_id": 370927,
      "sentence": "多线程同时使用同一个引擎实例的场景下，需要加锁使用。保证一个引擎实例在同一时刻只能在一个线程执行。多线程同一时刻同时使用引擎实例可能造成应用崩溃。",
      "reference_sentence": "",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"所有的JS对象都隶属于具体的某一JSVM_Env，不可将env1的对象，设置到env2中的对象中。在env2中一旦访问到env1的对象，程序可能会发生崩溃。\",\"102\":\"\",\"103\":\"## 多线程共享引擎实例\",\"104\":\"\",\"105\":\"【规则】多线程同时使用同一个引擎实例的场景下，需要加锁使用。保证一个引擎实例在同一时刻只能在一个线程执行。多线程同一时刻同时使用引擎实例可能造成应用崩溃。\",\"106\":\"\",\"107\":\"**注意事项**：\",\"108\":\"\",\"109\":\"1. `OH_JSVM_IsLocked`的结果为**当前线程**是否持有引擎实例的锁，无需设置循环等待其他线程释放锁；\",\"110\":\"2. `OH_JSVM_AcquireLock`在同一线程中嵌套使用不会造成死锁；\"}",
      "修改建议": "原文句子过长，可以拆分成两个句子。",
      "更改后示例": "多线程同时使用同一个引擎实例时，需加锁使用。保证一个引擎实例在同一时刻只能在一个线程执行，否则可能造成应用崩溃。",
      "触发条件": "同一语境下重复使用\"同时\"类时间副词（如\"同一时刻同时\"）或分句间重复描述相同风险条件（如\"多线程同时使用\"与\"多线程同一时刻同时使用\"形成冗余）。"
    },
    {
      "defect_id": 370849,
      "sentence": "检查是否将定义的类绑定到上下文中，见[上下文绑定对象](jsvm-guidelines.md#上下文绑定对象)",
      "reference_sentence": "",
      "line_num": 95,
      "context": "{\"90\":\"\",\"91\":\"   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`\",\"92\":\"\",\"93\":\"3. Q：JS执行时无法找到 `OH_JSVM_DefineClass` 定义的类\",\"94\":\"\",\"95\":\"   A：检查是否将定义的类绑定到上下文中，见[上下文绑定对象](jsvm-guidelines.md#上下文绑定对象)\"}",
      "修改建议": "句子过长，包含不必要的修饰成分",
      "更改后示例": "检查类是否绑定到上下文。参考[上下文绑定对象](jsvm-guidelines.md#上下文绑定对象)",
      "触发条件": "当句子包含可被上下文隐含的重复修饰语（如\"定义的\"）或冗余介词结构（如\"到上下文中\"的\"中\"字）时触发。\n\n识别模式：通过检测名词前是否有上下文已明确的冗余限定词（如\"定义的类\"→\"类\"），以及介词短语是否包含不必要方位词（如\"到上下文中\"→\"到上下文\"）。核心判断标准是删除修饰成分后，句子的技术准确性和完整性不受影响。"
    },
    {
      "defect_id": 370585,
      "sentence": "JS对象属性的增加、删除、获取和判断。",
      "reference_sentence": "",
      "line_num": 1326,
      "context": "{\"1321\":\"\",\"1322\":\"### JS属性操作\",\"1323\":\"\",\"1324\":\"#### 场景介绍\",\"1325\":\"\",\"1326\":\"JS对象属性的增加、删除、获取和判断。\",\"1327\":\"\",\"1328\":\"#### 接口说明\",\"1329\":\"| 接口 | 功能说明 |\",\"1330\":\"| -------- | -------- |\",\"1331\":\"|OH_JSVM_GetPropertyNames | 获取给定对象的所有可枚举属性名称, 结果变量将存储一个包含所有可枚举属性名称的JavaScript数组。 |\"}",
      "修改建议": "原文句子过长，逗号数超过5个，且表达不够简洁。",
      "更改后示例": "JS对象属性的增删获取和判断。",
      "触发条件": "当并列结构包含超过三个语义相近的动词/名词时，或存在可合并的常见固定搭配（如\"增删\"替代\"增加、删除\"），且句子结构呈现重复性并列分隔符（逗号/顿号）时触发。\n\n识别模式：\n1. 检测连续并列项数量 ≥3（例：增加、删除、获取、判断）\n2. 匹配可合并的语义对（如 增加+删除→增删，读取+写入→读写）\n3. 验证合并后是否保持原意（如\"增删获取\"仍完整覆盖原四个动作）\n4. 检查上下文是否为技术文档的标题/概要等需精简场景"
    },
    {
      "defect_id": 370566,
      "sentence": "此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。",
      "reference_sentence": "",
      "line_num": 1203,
      "context": "{\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\",\"1203\":\"|OH_JSVM_IsBigInt | 此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。 |\",\"1204\":\"|OH_JSVM_IsConstructor | 此API检查传入的值是否为构造函数。 |\",\"1205\":\"|OH_JSVM_IsMap | 此API检查传入的值是否为Map。 |\",\"1206\":\"|OH_JSVM_IsSet | 此API检查传入的值是否为Set。 |\",\"1207\":\"|OH_JSVM_IsRegExp | 此API检查传入的值是否为RegExp。 |\",\"1208\":\"|OH_JSVM_StrictEquals | 判断两个 JSVM_Value 对象是否严格相等 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为BigInt。相当于JS中的`typeof value === 'bigint'`。",
      "触发条件": "当相邻分句存在重复主语指代（如\"这\"指代前文完整描述）且可通过合并消除冗余时；或单句包含多个逗号分隔的同类解释性内容时。\n\n识别模式：\n1. 结构特征：寻找\"这相当于/对应\"类二次解释句式，且前文已有完整功能描述\n2. 语法标记：检测连续分句间存在重复主语（如\"此API...。这...\"）或超过2个逗号的长单句\n3. 上下文模式：在同类条目中对比，当其他条目采用简洁单句时触发规范检查"
    },
    {
      "defect_id": 370921,
      "sentence": "合理使用`OH_JSVM_OpenHandleScope`和`OH_JSVM_CloseHandleScope`管理JSVM_Value的生命周期，做到生命周期最小化，避免发生内存泄漏问题。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# JSVM-API使用规范\",\"2\":\"\",\"3\":\"## 生命周期管理\",\"4\":\"\",\"5\":\"**【规则】** 合理使用`OH_JSVM_OpenHandleScope`和`OH_JSVM_CloseHandleScope`管理JSVM_Value的生命周期，做到生命周期最小化，避免发生内存泄漏问题。\",\"6\":\"\",\"7\":\"每个JSVM_Value属于特定的HandleScope，HandleScope通过`OH_JSVM_OpenHandleScope`和`OH_JSVM_CloseHandleScope`来建立和关闭，HandleScope关闭后，所属的JSVM_Value就会自动释放。\",\"8\":\"\",\"9\":\"**注意事项**：\",\"10\":\"\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "合理使用`OH_JSVM_OpenHandleScope`和`OH_JSVM_CloseHandleScope`管理JSVM_Value的生命周期，避免内存泄漏。",
      "触发条件": "同一句子中重复使用同义短语（如\"管理生命周期\"与\"生命周期最小化\"），或存在冗余动词结构（如\"避免发生...问题\"中\"发生\"与\"问题\"的语义叠加）。\n\n识别模式：\n1. 同句内出现两个及以上表达相同技术目标的短语（例：管理生命周期 + 生命周期最小化）\n2. 动词+名词组合存在冗余修饰（例：\"避免发生内存泄漏问题\"可简化为\"避免内存泄漏\"）\n3. 上下文已隐含的技术目标被显式重复说明（例：HandleScope管理已隐含生命周期控制）"
    },
    {
      "defect_id": 371097,
      "sentence": "传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"19\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。 |\",\"20\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"21\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是一个 wasm module。                                                             |\",\"22\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。                    |\",\"23\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"24\":\"\",\"25\":\"## code cache 校验规格说明\",\"26\":\"| 规格        | 规格说明                                         |\",\"27\":\"| ---------- | ------------------------------------------------ |\",\"28\":\"| 完整性校验  | 由用户保证                                        |\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "cacheType 和 cacheData 必须匹配，否则产生未定义行为。",
      "触发条件": "当句子中存在可被上下文推断的冗余修饰成分（如重复参数来源描述）或冗余助词（如“会”“将”等）时触发。例如：参数来源（如“传入的”）在上下文已明确的情况下重复出现，或条件句中使用不必要的“会产生”而非更简洁的“产生”。"
    },
    {
      "defect_id": 371035,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 22,
      "context": "{\"17\":\"|OH_JSVM_PerformMicrotaskCheckpoint| 执行任务队列里的微任务 |\",\"18\":\"| OH_JSVM_SetMicrotaskPolicy | 设置微任务执行策略 |\",\"19\":\"\",\"20\":\"## 使用示例\",\"21\":\"\",\"22\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"23\":\"注意：Wasm字节码需要应用拥有JIT权限才能执行，可参考[JSVM 申请JIT权限指导](jsvm-apply-jit-profile.md)申请对应权限。\",\"24\":\"### OH_JSVM_PumpMessageLoop && OH_JSVM_PerformMicrotaskCheckpoint\",\"25\":\"\",\"26\":\"启动任务队列，执行任务。\",\"27\":\"\"}",
      "修改建议": "句子较长，包含多个信息点，不符合简洁表述的要求。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示C++相关代码。",
      "触发条件": "当句子中同时存在与上下文重复的短语（如链接文本已包含的信息）或使用冗余限定词（如\"仅对接口对应\"）时触发；当同一信息点通过不同表述重复强调（如\"开发流程参考\"与\"本文仅对...展示\"双重说明）时触发。\n\n识别模式：\n1. 检查链接锚文本是否已包含主句信息（如\"开发流程\"在链接标题重复）\n2. 寻找冗余修饰词（\"接口对应\"与上下文已明确的接口主题重复）\n3. 识别信息重叠结构（前半句说明参考流程，后半句用\"仅\"强调局部展示，形成语义重复）"
    },
    {
      "defect_id": 371094,
      "sentence": "如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                          | 功能说明                                                                                 |\",\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"19\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。 |\",\"20\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"21\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是一个 wasm module。                                                             |\",\"22\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。                    |\",\"23\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"24\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "提供 cache 参数时，先尝试反序列化为 wasm module，失败时再编译。",
      "触发条件": "句子中存在重复性动作描述（如\"反序列化失败时再执行编译\"）或冗余条件状语（如\"如果...时\"），且存在可合并的同类动词短语结构。\n\n识别模式：\n1. 检测\"如果...时\"双重条件引导词叠加\n2. 识别连续动作描述中存在语义重复的动词（如\"执行编译\"中的\"执行\"可省略）\n3. 发现同一语义单元被拆分表述（如\"反序列为 wasm module，反序列化失败\"中的重复主语）"
    },
    {
      "defect_id": 370847,
      "sentence": "检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)",
      "reference_sentence": "",
      "line_num": 87,
      "context": "{\"82\":\"\",\"83\":\"## JSVM-API执行失败类\",\"84\":\"\",\"85\":\"1. Q：`OH_JSVM_GetCbInfo`的无法获取JS函数参数\",\"86\":\"\",\"87\":\"   A：检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)\",\"88\":\"\",\"89\":\"2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`\",\"90\":\"\",\"91\":\"   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`\",\"92\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分",
      "更改后示例": "检查函数参数是否正确。参考[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)",
      "触发条件": "当句子中存在可被删除而不影响核心语义的修饰成分（如\"传递的\"这类限定词）或存在重复性表达（如\"参数\"与\"传入参数\"重复说明）时触发。\n\n识别模式：检查名词前是否有冗余限定词（如动词过去分词作定语）、判断并列结构是否存在语义重叠（如\"函数参数\"已隐含传递属性时，\"传递的参数\"中的限定词即属冗余）。"
    },
    {
      "defect_id": 370990,
      "sentence": "此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口，从而实现跨语言交互为例，呈现使用JSVM-API进行跨语言交互的流程。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"- ArkTS/JS侧：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。\",\"6\":\"\",\"7\":\"- Native侧：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。\",\"8\":\"\",\"9\":\"此处以在ArkTS/JS侧实现RunJsVm()接口、在Native侧实现RunJsVm()接口，从而实现跨语言交互为例，呈现使用JSVM-API进行跨语言交互的流程。\",\"10\":\"\",\"11\":\"## 创建Native C++工程\",\"12\":\"\",\"13\":\"具体见[创建NDK工程](create-with-ndk.md)\",\"14\":\"\"}",
      "修改建议": "原句含有不必要的修饰成分，且逗号使用过多。",
      "更改后示例": "在ArkTS/JS侧和Native侧实现RunJsVm()接口，展示使用JSVM-API进行跨语言交互的流程。",
      "触发条件": "当句子中存在重复的并列结构（如分号/逗号分隔的同类描述）或冗余的目的性说明（如\"从而实现/呈现...为例\"重复强调同一功能），且导致句式冗余时触发。\n\n识别模式：\n1. 并列结构重复：通过标点（逗号/分号）分割的同类描述（例中ArkTS/JS侧和Native侧重复描述接口实现）\n2. 目的双重表达：同时包含\"以...为例\"和\"呈现...\"等重复说明意图的句式\n3. 语义重复标记：出现\"从而/因此\"等连接词+重复关键词（例中两次出现\"跨语言交互\"）\n4. 句式冗长特征：单句超过2个逗号且包含超过25个汉字"
    },
    {
      "defect_id": 372808,
      "sentence": "在使用 JSVM 处理 ArrayBuffer 时，需要特别注意生命周期和内存管理。",
      "reference_sentence": "",
      "line_num": 10,
      "context": "{\"5\":\"ArrayBuffer 是 JavaScript 中的一种数据类型，用于表示通用的、固定长度的原始二进制数据缓冲区。它提供了一种在 JavaScript 中有效地表示和操作原始二进制数据的方式。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- **ArrayBuffer**：ArrayBuffer 对象用来表示一个通用的、固定长度的原始二进制数据缓冲区。不能直接操作 ArrayBuffer 的内容，而是需要通过包装成 TypedArray 对象或 DataView 对象来读写。ArrayBuffer 常用于处理大量的二进制数据，如文件、网络数据包等。\",\"10\":\"- **生命周期和内存管理**：在使用 JSVM 处理 ArrayBuffer 时，需要特别注意生命周期和内存管理。\",\"11\":\"\",\"12\":\"## 接口说明\",\"13\":\"\",\"14\":\"| 接口                         | 功能说明                                   |\",\"15\":\"| ---------------------------- | ------------------------------------------ |\"}",
      "修改建议": "句子包含不必要的修饰成分，可以简化。",
      "更改后示例": "使用 JSVM 处理 ArrayBuffer 时，注意生命周期和内存管理。",
      "触发条件": "句子中存在可删除的修饰性副词（如\"需要特别\"中的\"特别\"）或重复强调成分，且删除后不影响核心信息传达。识别需结合上下文判断修饰成分是否已在其他位置被显式说明（如上下文已强调重要性时，\"特别\"即冗余）。"
    },
    {
      "defect_id": 370564,
      "sentence": "此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。",
      "reference_sentence": "",
      "line_num": 1200,
      "context": "{\"1195\":\"|OH_JSVM_IsNull | 此API检查传入的值是否为Null对象。这相当于JS中的`value === null`。 |\",\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\",\"1203\":\"|OH_JSVM_IsBigInt | 此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。 |\",\"1204\":\"|OH_JSVM_IsConstructor | 此API检查传入的值是否为构造函数。 |\",\"1205\":\"|OH_JSVM_IsMap | 此API检查传入的值是否为Map。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Symbol。相当于JS中的`typeof value === 'symbol'`。",
      "触发条件": "当相邻句子连续使用\"此API\"+\"这\"的重复主语结构，且第二个句子以代词\"这\"开头指代前文相同主语时，应触发冗余表达规则。\n\n识别模式：\n1. 句式结构检测：前句以\"此API\"开头描述功能，后句以\"这\"开头解释等价代码\n2. 冗余指代识别：后句的\"这\"与前句\"此API\"形成重复主语\n3. 语义连贯性判断：两个分句共同描述同一API的检查逻辑，具备合并基础\n4. 标点特征：存在句号分隔的短句组合（原句长度>25字符且包含两个及以上分句）"
    },
    {
      "defect_id": 371095,
      "sentence": "函数编号的合法性由接口调用者保证。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                          | 功能说明                                                                                 |\",\"18\":\"| --------------------------- | ------------------------------------------------------------------------------------ |\",\"19\":\"| OH_JSVM_CompileWasmModule   | 将 wasm 字节码同步编译为 wasm module。如果提供了 cache 参数，先尝试将 cache 反序列为 wasm module，反序列化失败时再执行编译。 |\",\"20\":\"| OH_JSVM_CompileWasmFunction | 将 wasm module 中指定编号的函数编译为优化后的机器码，目前只使能了最高的优化等级，函数编号的合法性由接口调用者保证。                     |\",\"21\":\"| OH_JSVM_IsWasmModuleObject  | 判断传入的值是否是一个 wasm module。                                                             |\",\"22\":\"| OH_JSVM_CreateWasmCache     | 将 wasm module 中的机器码序列化为 wasm cache，如果 wasm module 不包含机器码，则会序列化失败。                    |\",\"23\":\"| OH_JSVM_ReleaseCache        | 释放由 JSVM 接口生成的 cache。传入的 cacheType 和 cacheData 必须匹配，否则会产生未定义行为。                      |\",\"24\":\"\",\"25\":\"## code cache 校验规格说明\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "接口调用者保证函数编号的合法性。",
      "触发条件": "句子使用被动语态导致\"由...保证\"类冗余结构，或存在可合并的主谓修饰关系（如\"合法性由接口调用者保证\"可简化为\"接口调用者保证合法性\"）。\n\n识别模式：当句子出现\"由...保证/承担/处理\"等被动句式，且施动者与受动者存在直接主谓逻辑关联时（如\"合法性\"与\"保证\"），优先采用主动语态表达。典型特征为介词短语作状语（如\"由接口调用者\"）与核心谓语（如\"保证\"）分离造成的句式臃肿。"
    },
    {
      "defect_id": 372809,
      "sentence": "JSVM-API 接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应 C++ 相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "{\"19\":\"| OH_JSVM_IsDetachedArraybuffer | 检查给定的 ArrayBuffer 是否已被分离(detached)。        |\",\"20\":\"| OH_JSVM_CreateArraybuffer      | 创建一个指定大小的 ArrayBuffer 对象。   |\",\"21\":\"\",\"22\":\"## 使用示例\",\"23\":\"\",\"24\":\"JSVM-API 接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应 C++ 相关代码进行展示。\",\"25\":\"\",\"26\":\"### OH_JSVM_GetArraybufferInfo\",\"27\":\"\",\"28\":\"检索 ArrayBuffer 的底层数据缓冲区及其长度。\",\"29\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，可以拆分成两个句子。",
      "更改后示例": "JSVM-API 接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文仅展示接口对应 C++ 相关代码。",
      "触发条件": "当单句包含逗号分隔的多个独立语义单元（如并列说明行为+补充说明行为），且存在冗余动词结构（如\"进行展示\"）时触发。\n\n识别模式：\n1. 结构特征：句子通过逗号连接两个及以上完整语义模块（如\"流程参考...\"和\"本文说明...\"）\n2. 冗余信号：存在\"对...进行...\"类间接表达，或同一语义重复出现（如\"接口开发流程\"与\"接口对应代码\"的上下文重复）\n3. 长度阈值：单句超过30字且包含两个以上动词短语（原句34字含2个核心动词\"参考/展示\"）"
    },
    {
      "defect_id": 370565,
      "sentence": "此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。",
      "reference_sentence": "",
      "line_num": 1201,
      "context": "{\"1196\":\"|OH_JSVM_IsNullOrUndefined | 此API检查传入的值是否为Null或Undefined。这相当于JS中的`value == null`。 |\",\"1197\":\"|OH_JSVM_IsBoolean | 此API检查传入的值是否为Boolean。这相当于JS中的`typeof value === 'boolean'`。 |\",\"1198\":\"|OH_JSVM_IsNumber | 此API检查传入的值是否为Number。这相当于JS中的`typeof value === 'number'`。 |\",\"1199\":\"|OH_JSVM_IsString | 此API检查传入的值是否为String。这相当于JS中的`typeof value === 'string'`。 |\",\"1200\":\"|OH_JSVM_IsSymbol | 此API检查传入的值是否为Symbol。这相当于JS中的`typeof value === 'symbol'`。 |\",\"1201\":\"|OH_JSVM_IsFunction | 此API检查传入的值是否为Function。这相当于JS中的`typeof value === 'function'`。 |\",\"1202\":\"|OH_JSVM_IsObject | 此API检查传入的值是否为Object。 |\",\"1203\":\"|OH_JSVM_IsBigInt | 此API检查传入的值是否为BigInt。这相当于JS中的`typeof value === 'bigint'`。 |\",\"1204\":\"|OH_JSVM_IsConstructor | 此API检查传入的值是否为构造函数。 |\",\"1205\":\"|OH_JSVM_IsMap | 此API检查传入的值是否为Map。 |\",\"1206\":\"|OH_JSVM_IsSet | 此API检查传入的值是否为Set。 |\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "此API检查传入的值是否为Function。相当于JS中的`typeof value === 'function'`。",
      "触发条件": "当相邻句子存在重复指代结构（后句以\"这\"开头指代前文）且内容为对前文的等价解释时触发。\n\n识别模式：\n1. 连续两个短句结构，后句以\"这\"/\"相当于\"等指代性词语开头\n2. 后句内容为前句的技术实现说明（如JS等价表达式）\n3. 上下文存在同类API描述的平行结构（如其他API条目均采用单句表述）"
    },
    {
      "defect_id": 372862,
      "sentence": "- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\r",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **类**：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在JavaScript中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。\",\"12\":\"- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\",\"13\":\"\",\"14\":\"## 接口说明\",\"15\":\"\",\"16\":\"| 接口                | 功能说明                           |\",\"17\":\"| ------------------- | ---------------------------------- |\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "- **实例**：实例是通过类创建的对象。类定义对象的结构和行为，实例是类的具体表现。通过实例化类，访问类中定义的属性和方法，每个实例具有自己的属性值。",
      "触发条件": "句子包含多个并列分句或复杂修饰结构，且存在重复性限定词（如\"具体的\"）、冗余助动词（如\"可以\"）或重复语义表达时触发。识别模式为检查超过3个逗号分隔的复合句结构，同时存在形容词冗余（如\"具体的对象\"→\"对象\"）或重复连接词（如\"并且\"）的情况。"
    },
    {
      "defect_id": 372834,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 144,
      "context": "{\"139\":\"\",\"140\":\"### OH_JSVM_CreateBigintUint64\",\"141\":\"\",\"142\":\"根据Uint64类型对象创建 JavaScript Bigint对象。\",\"143\":\"\",\"144\":\"cpp部分代码\",\"145\":\"\",\"146\":\"```cpp\",\"147\":\"// hello.cpp\",\"148\":\"#include \\\"napi/native_api.h\\\"\",\"149\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "句子过于简单，缺乏具体信息。",
      "更改后示例": "C++部分代码",
      "触发条件": "在技术文档中出现非通用缩写（如\"cpp\"替代\"C++\"）且上下文未明确解释时，或当术语简写可能导致读者理解歧义时触发。\n\n识别模式：  \n1. 检测到编程语言/技术术语的非标准简写（如cpp/js/go等）；  \n2. 结合上下文判断是否缺少必要的全称说明，特别是在代码示例标题、API描述等需要明确技术栈的场景。"
    },
    {
      "defect_id": 372826,
      "sentence": "BigInt是JavaScript中用于表示任意精度整数的数据类型，它能够处理比Number类型更大范围的整数值。通过JSVM-API提供的接口，可以在JSVM模块中创建、获取和操作BigInt类型值，从而实现与BigInt相关的功能扩展。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口操作bigint类型值\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"BigInt是JavaScript中用于表示任意精度整数的数据类型，它能够处理比Number类型更大范围的整数值。通过JSVM-API提供的接口，可以在JSVM模块中创建、获取和操作BigInt类型值，从而实现与BigInt相关的功能扩展。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口操作BigInt类型值时，需要理解以下基本概念：\",\"10\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "BigInt是JavaScript中用于表示任意精度整数的数据类型，可以处理比Number类型更大的整数值。JSVM-API提供的接口支持在JSVM模块中创建、获取和操作BigInt类型值。",
      "触发条件": "句子包含重复主语指代（如\"它能够\"）、冗余目的状语（如\"从而实现...\"）或同义重复表达（如\"创建、获取和操作\"与\"功能扩展\"存在语义重叠）。\n\n识别模式：1) 检查连续分句中是否存在重复的名词/代词指代 2) 分析\"通过/实现/从而\"等连接词引导的状语是否包含已知冗余模式 3) 验证并列动词短语是否与上下文存在功能重复（如操作接口本身已隐含功能扩展）。"
    },
    {
      "defect_id": 372830,
      "sentence": "- **BigInt操作：** JSVM-API提供了多个接口用于操作BigInt类型值。通过这些接口，可以获取BigInt的数值，进行数值转换，以及执行常见的算术和位运算操作。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"在使用JSVM-API接口操作BigInt类型值时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **BigInt类型：** BigInt是JavaScript中的一种数据类型，用于表示任意精度的整数。与Number类型不同，BigInt类型可以精确表示非常大的整数，而不会丢失精度或溢出。\",\"12\":\"- **BigInt创建：** 使用JSVM-API提供的接口，可以通过传递C的int64或uint64数据来创建对应的JavaScript BigInt。这使得在JSVM模块中可以方便地创建BigInt类型值。\",\"13\":\"- **BigInt操作：** JSVM-API提供了多个接口用于操作BigInt类型值。通过这些接口，可以获取BigInt的数值，进行数值转换，以及执行常见的算术和位运算操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                         | 功能说明                                 |\",\"18\":\"| ---------------------------- | ---------------------------------------- |\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "- **BigInt操作：** JSVM-API提供了多个接口用于操作BigInt类型值，包括获取数值、转换数值和执行算术和位运算。",
      "触发条件": "当句子包含多个并列分句、重复的主语结构（如\"通过这些接口\"）或冗余动词短语（如\"进行...，执行...\"）时触发；存在不必要的修饰语（如\"常见的\"）或可合并的同类项（如\"获取数值，进行数值转换\"）。  \n\n识别模式：  \n1. 检查句子是否使用分号/句号分隔本可合并的同类内容  \n2. 寻找重复出现的动作主体（如案例中连续出现\"接口\"作为主语）  \n3. 分析动词结构是否存在语义重叠（如\"进行\"+\"执行\"双重动作引导词）  \n4. 标记非必要限定词（如\"常见的\"在无对比场景下冗余）  \n5. 识别可简化的名词重复（如\"BigInt的数值\"简化为\"数值\"）"
    },
    {
      "defect_id": 372863,
      "sentence": "| OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持。|",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"| 接口                | 功能说明                           |\",\"17\":\"| ------------------- | ---------------------------------- |\",\"18\":\"| OH_JSVM_NewInstance   | 通过给定的构造函数，构建一个实例。|\",\"19\":\"| OH_JSVM_GetNewTarget  | 获取函数的元属性new.target。|\",\"20\":\"| OH_JSVM_DefineClass   | 用于在JavaScript中定义一个类，并与对应的C类进行封装和交互。它提供了创建类的构造函数、定义属性和方法的能力，以及在C和JavaScript之间进行数据交互的支持。|\",\"21\":\"| OH_JSVM_Wrap           | 在JavaScript对象中封装原生实例。稍后可以使用OH_JSVM_Unwrap()解包原生实例。|\",\"22\":\"| OH_JSVM_Unwrap         | 解包先前封装在JavaScript对象中的原生实例。|\",\"23\":\"| OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例并释放封装。|\",\"24\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"25\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "| OH_JSVM_DefineClass   | 用于在JavaScript中定义类，与C类封装和交互。提供创建类的构造函数、定义属性和方法的能力，支持C和JavaScript之间的数据交互。|",
      "触发条件": "当句子出现连续分句结构（超过两个逗号分隔的独立语义单元）且包含重复性功能描述（如\"用于...\"与\"提供...\"双重引导）时触发。\n\n识别模式：\n1. 结构特征：主谓结构重复（如\"用于...\"+\"它提供...\"）\n2.语法标记：存在递进连词（\"以及\"）、补充说明代词（\"它\"）等冗余衔接成分\n3.语义重复：多个分句表达相同维度的功能描述（如原句前段说明类定义，后段再次说明类构造能力）"
    },
    {
      "defect_id": 372832,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"### OH_JSVM_GetValueBigintWords\",\"31\":\"\",\"32\":\"获取给定JavaScript BigInt对象的底层数据，即BigInt数据的字词表示。\",\"33\":\"\",\"34\":\"cpp部分代码\",\"35\":\"\",\"36\":\"```cpp\",\"37\":\"// hello.cpp\",\"38\":\"#include \\\"napi/native_api.h\\\"\",\"39\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "句子过于简单，缺乏具体信息。",
      "更改后示例": "C++部分代码",
      "触发条件": "检测到技术术语使用非标准缩写（如\"cpp\"而非\"C++\"）或语言/框架名称未采用官方命名格式（如大小写不规范），且上下文需要明确技术栈信息时触发。  \n\n识别模式：匹配预定义的非规范技术缩写列表（如/cpp/i → C++），并验证当前段落是否处于代码示例描述位置（如包含\"代码\"、\"示例\"等关键词）。"
    },
    {
      "defect_id": 372829,
      "sentence": "- **BigInt创建：** 使用JSVM-API提供的接口，可以通过传递C的int64或uint64数据来创建对应的JavaScript BigInt。这使得在JSVM模块中可以方便地创建BigInt类型值。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口操作BigInt类型值时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **BigInt类型：** BigInt是JavaScript中的一种数据类型，用于表示任意精度的整数。与Number类型不同，BigInt类型可以精确表示非常大的整数，而不会丢失精度或溢出。\",\"12\":\"- **BigInt创建：** 使用JSVM-API提供的接口，可以通过传递C的int64或uint64数据来创建对应的JavaScript BigInt。这使得在JSVM模块中可以方便地创建BigInt类型值。\",\"13\":\"- **BigInt操作：** JSVM-API提供了多个接口用于操作BigInt类型值。通过这些接口，可以获取BigInt的数值，进行数值转换，以及执行常见的算术和位运算操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                         | 功能说明                                 |\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "- **BigInt创建：** 使用JSVM-API接口，可以通过传递C的int64或uint64数据来创建JavaScript BigInt。",
      "触发条件": "当句子中出现重复性限定词（如\"提供的\"）、同义重复表述（如\"对应的JavaScript BigInt\"与后文\"BigInt类型值\"），或存在可被上下文隐含的解释性分句（如\"这使得...\"）时触发。\n\n识别模式：\n1. 词汇层面：检测冗余修饰语（如\"提供的\"+\"接口\"）和同位重复（如\"对应的\"+类型重复声明）\n2. 句法层面：识别包含超过两个逗号的长复合句，特别是带有解释性目的状语分句\n3. 语境层面：当当前条目内容与上下文相邻条目（如\"BigInt操作\"条目）存在结构不对称时，需精简保持格式统一"
    },
    {
      "defect_id": 372828,
      "sentence": "- **BigInt类型：** BigInt是JavaScript中的一种数据类型，用于表示任意精度的整数。与Number类型不同，BigInt类型可以精确表示非常大的整数，而不会丢失精度或溢出。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口操作BigInt类型值时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **BigInt类型：** BigInt是JavaScript中的一种数据类型，用于表示任意精度的整数。与Number类型不同，BigInt类型可以精确表示非常大的整数，而不会丢失精度或溢出。\",\"12\":\"- **BigInt创建：** 使用JSVM-API提供的接口，可以通过传递C的int64或uint64数据来创建对应的JavaScript BigInt。这使得在JSVM模块中可以方便地创建BigInt类型值。\",\"13\":\"- **BigInt操作：** JSVM-API提供了多个接口用于操作BigInt类型值。通过这些接口，可以获取BigInt的数值，进行数值转换，以及执行常见的算术和位运算操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "- **BigInt类型：** BigInt是JavaScript中用于表示任意精度整数的数据类型，可以精确表示非常大的整数。",
      "触发条件": "同一段落内重复提及相同主体（如\"BigInt类型\"）且存在冗余比较结构（如\"与...不同\"），或通过分句形式重复表达同一核心语义（如\"不会丢失精度或溢出\"与\"精确表示\"构成语义重复）。\n\n识别模式：\n1. 名词短语重复检测：连续两个分句主语相同（\"BigInt类型...\"→\"BigInt类型...\"）\n2. 冗余比较标记：存在\"与...不同\"等对比结构但未提供新信息\n3. 语义重叠分析：\"精确表示非常大的整数\"与\"不会丢失精度或溢出\"通过NLP模型检测语义相似度＞70%\n4. 句式复杂度：单句包含≥2个逗号且分句间存在递进/补充关系而非并列关系"
    },
    {
      "defect_id": 372836,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 190,
      "context": "{\"185\":\"\",\"186\":\"### OH_JSVM_GetValueBigintUint64\",\"187\":\"\",\"188\":\"获取给定JavaScript BigInt的Uint64_t基础类型值。\",\"189\":\"\",\"190\":\"cpp部分代码\",\"191\":\"\",\"192\":\"```cpp\",\"193\":\"// hello.cpp\",\"194\":\"#include \\\"napi/native_api.h\\\"\",\"195\":\"#include \\\"ark_runtime/jsvm.h\\\"\"}",
      "修改建议": "重复出现，且没有提供具体的信息",
      "更改后示例": "删除该句",
      "触发条件": "当句子在相邻或相近上下文中重复出现，且内容为通用描述（如“部分代码”）而未提供具体功能、路径或实现细节时触发。  \n\n识别模式：  \n1. **重复性检查**：检测当前句与上下文（如前/后3-5行）是否存在语义重复的短语（如“cpp部分代码”）。  \n2. **信息量评估**：判断句子是否仅声明代码类别（如语言类型）但缺少关键信息（如代码用途、示例片段或文件路径）。"
    },
    {
      "defect_id": 372860,
      "sentence": "在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：\r",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用JSVM-API接口进行class相关开发，处理JavaScript中的类，例如定义类、构造实例等。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **类**：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在JavaScript中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。\",\"12\":\"- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\",\"13\":\"\",\"14\":\"## 接口说明\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "使用JSVM-API接口进行类相关开发时，理解以下基本概念。",
      "触发条件": "句子中存在重复性修饰语（如\"需要\"等冗余助动词）或同义叠加成分（如\"class\"与\"类\"双语混用），且删除后不影响核心语义传达。  \n\n识别模式：  \n1. 检测助动词冗余：当\"需要/应该/必须\"等词与后续动词构成语义重复时（如\"需要理解\"→\"理解\"）  \n2. 识别术语双语混用：同一技术名词中英文形式同时出现（如\"class相关开发\"→\"类相关开发\"）  \n3. 验证上下文重复：前文已明确说明的行为，后文再次出现带修饰语的重复表述"
    },
    {
      "defect_id": 372884,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"| OH_JSVM_GetDateValue        | 获取给定JavaScript Date的时间值的Double基础类型值。  |\",\"21\":\"| OH_JSVM_IsDate               | 判断一个JavaScript对象是否为Date类型对象。|\",\"22\":\"\",\"23\":\"## 使用示例\",\"24\":\"\",\"25\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"26\":\"\",\"27\":\"### OH_JSVM_CreateDate\",\"28\":\"\",\"29\":\"创建一个表示给定毫秒数的Date对象。\",\"30\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示接口对应的C++代码。",
      "触发条件": "句子中同时存在重复限定词（如\"仅\"/\"相关\"）和冗余介词结构（如\"进行展示\"），导致语义重复或表达拖沓时触发；或当上下文已明确限定范围（如前文已说明开发流程）时仍使用冗余修饰成分。  \n\n识别模式：检查是否存在\"仅对...进行\"、\"相关代码\"等双重限定结构，以及是否在已有明确指向性的上下文中重复使用限定词（如接口名称+技术栈双重限定）。"
    },
    {
      "defect_id": 372861,
      "sentence": "- **类**：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在JavaScript中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。\r",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：\",\"10\":\"\",\"11\":\"- **类**：类是用于创建对象的模板。它提供了一种封装数据和行为的方式，以便于对数据进行处理和操作。类在JavaScript中是建立在原型（prototype）的基础上的，并且还引入了一些类独有的语法和语义。\",\"12\":\"- **实例**：实例是通过类创建具体的对象。类定义了对象的结构和行为，而实例则是类的具体表现。通过实例化类，我们可以访问类中定义的属性和方法，并且每个实例都具有自己的属性值。\",\"13\":\"\",\"14\":\"## 接口说明\",\"15\":\"\",\"16\":\"| 接口                | 功能说明                           |\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "- **类**：类是用于创建对象的模板。提供封装数据和行为的方式。类在JavaScript中基于原型（prototype），引入类独有的语法和语义。",
      "触发条件": "句子结构包含多个并列分句或冗余修饰成分（如重复性描述、非必要的介词短语/副词），且上下文属于技术概念解释类段落。\n\n识别模式：\n1. 存在连续逗号分隔的复合句式（如\"并且...\"、\"以便于...\"）\n2. 出现重复语义成分（如原句重复使用\"类\"作为主语）\n3. 包含可删除的修饰语（如\"一种\"、\"具体的\"）或解释性短语（如\"以便于...\"）\n4. 技术文档中针对基础概念的定义性语句（需保持简洁性）"
    },
    {
      "defect_id": 372882,
      "sentence": "JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许您创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，JavaScript Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许您创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "JavaScript Date对象用于表示和操作日期和时间。它们允许创建表示特定时刻的日期对象，执行日期和时间计算，以及格式化日期为字符串。",
      "触发条件": "当句子中存在重复上下文已明确的信息（如\"在JavaScript中\"）、冗余修饰词（如\"各种...相关的\"）或可省略的解释性插入语（如括号示例）时触发。\n\n识别模式：\n1. 重复前文环境信息（前文已说明\"在JSVM-API中\"）\n2. 使用\"各种/相关/如...等\"等冗余限定词\n3. 包含非必要的操作说明（\"以供显示\"）\n4. 存在可合并的并列结构（\"添加或减去时间间隔\"简化为\"计算\"）\n5. 第二人称叙述（\"您\"）在技术文档中显得冗余"
    },
    {
      "defect_id": 372859,
      "sentence": "使用JSVM-API接口进行class相关开发，处理JavaScript中的类，例如定义类、构造实例等。\r",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM进行class相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"使用JSVM-API接口进行class相关开发，处理JavaScript中的类，例如定义类、构造实例等。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM-API接口进行class相关开发时，需要理解以下基本概念：\",\"10\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "使用JSVM-API接口进行类相关开发。处理JavaScript中的类，包括定义类、构造实例等。",
      "触发条件": "同一句子中重复出现语义相近的短语(如\"class相关开发\"与\"处理JavaScript中的类\")，且存在超过两个逗号分隔的并列成分。\n\n识别模式：当检测到相邻分句共享相同主语但重复说明同一功能范畴(如开发对象/操作类型)，且出现\"例如\"等举例性连接词时，应检查是否存在可通过合并举例说明、删除重复指代进行简化的冗余表达。"
    },
    {
      "defect_id": 372831,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| OH_JSVM_GetValueBigintUint64 | 返回给定JavaScript BigInt的C uint64_t基础类型等价值。 如果需要，它将截断该值，将lossless设置为false。      |\",\"24\":\"| OH_JSVM_GetValueBigintWords  | 将单个BigInt值转换为一个符号位、一个64位的小端数组和该数组的长度。 signBit和words参数可以都设置为NULL，这种情况下，只获取wordCount。|\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"29\":\"\",\"30\":\"### OH_JSVM_GetValueBigintWords\",\"31\":\"\",\"32\":\"获取给定JavaScript BigInt对象的底层数据，即BigInt数据的字词表示。\",\"33\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示接口对应的C++及ArkTS代码。",
      "触发条件": "句子包含重复性名词短语（如\"JSVM-API接口开发流程\"与链接文本重复）或冗余限定词（如\"仅对...相关代码\"），且存在超过两个逗号分隔的复杂句式结构时触发。\n\n识别模式：\n1. 名词短语重复：检查主语/宾语是否与相邻链接文本存在语义重复（如\"接口开发流程\" vs \"实现...开发流程\"）\n2. 冗余修饰成分：标记\"仅/相关/等\"等非必要限定词，当删除后不影响核心语义时判定为冗余\n3. 句式复杂度：检测逗号数量≥2的长句，配合语义分析判断是否存在信息重复表达"
    },
    {
      "defect_id": 372883,
      "sentence": "在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"在JSVM-API中，JavaScript Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许您创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                       | 功能说明                       |\",\"18\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "JSVM-API提供与Date对象交互的函数，使JSVM模块与JavaScript环境集成，执行复杂的日期和时间操作。",
      "触发条件": "句子中存在重复或冗余的修饰词（如\"更紧密地\"\"更复杂的\"）或冗余结构（如\"通过提供...\"），导致信息密度降低且未增加核心语义。\n\n识别模式：  \n1. 修饰词冗余：连续出现\"更XX地/的\"等程度副词或形容词，且上下文已隐含该程度（如\"集成\"本身已含协作意图，无需叠加\"更紧密\"）  \n2. 结构冗余：使用\"通过...\"等介词短语引入动作方式，但主语本身已具备该能力（如\"JSVM-API提供\"已隐含功能实现路径）  \n3. 语义重复：前后分句存在逻辑包含关系（如\"执行复杂操作\"已涵盖\"日期和时间相关\"的限定）"
    },
    {
      "defect_id": 372881,
      "sentence": "JSVM-API中date相关接口用于处理JavaScript Date对象，并在JSVM模块和JavaScript代码之间进行日期数据的转换和处理。这对于在JSVM模块中处理时间和日期相关逻辑非常有用。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 使用JSVM-API接口进行Date相关开发\",\"2\":\"\",\"3\":\"## 简介\",\"4\":\"\",\"5\":\"JSVM-API中date相关接口用于处理JavaScript Date对象，并在JSVM模块和JavaScript代码之间进行日期数据的转换和处理。这对于在JSVM模块中处理时间和日期相关逻辑非常有用。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，JavaScript Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "JSVM-API中date相关接口用于处理JavaScript Date对象，并在JSVM模块和JavaScript代码之间进行日期数据的转换和处理。这些接口在JSVM模块中处理时间和日期相关逻辑非常有用。",
      "触发条件": "当句子中存在连续重复的指代性评价（如\"这对于...\"结构）且导致信息冗余时，或单句超过25字并包含多个修饰性介词短语（如\"在...中处理...相关逻辑\"）时触发。\n\n识别模式：通过检测\"这+对于\"的指代结构+评价性内容组合，并分析句子长度超过常规阈值（建议>25字）时，结合是否存在重复修饰成分（如连续出现相同模块名称/功能描述）进行双重验证。"
    },
    {
      "defect_id": 372865,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\r",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| OH_JSVM_RemoveWrap     | 解包先前封装在JavaScript对象中的原生实例并释放封装。|\",\"24\":\"|OH_JSVM_DefineClassWithOptions | 定义一个具有给定类名、构造函数、属性和回调处理程序、父类的JavaScript类，并根据传入了DefineClassOptions来决定是否需要为所定义的Class设置属性代理、预留internal-field槽位、为class作为函数进行调用时设置函数回调。|\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"29\":\"\",\"30\":\"### OH_JSVM_NewInstance\",\"31\":\"\",\"32\":\"通过给定的构造函数，构建一个实例。\",\"33\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示接口对应的C++代码。",
      "触发条件": "当句子中同时存在重复的名词短语（如\"JSVM-API接口开发流程\"与后文\"开发流程\"重复）和冗余修饰语（如\"仅对...相关代码进行展示\"中的双重限定词），且动词结构可简化为单一动作（如\"进行展示\"→\"展示\"）时触发。\n\n识别模式：检查是否存在\"名词短语+同义复现\"（接口开发流程→开发流程）、\"双重限定词\"（仅对...相关）以及\"进行+动词\"的冗余结构，同时上下文已明确前置信息（前文已完整定义JSVM-API接口）的情况下应触发规则。"
    },
    {
      "defect_id": 372754,
      "sentence": "DataView 是 JavaScript 中的一种视图，是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"- **数组的创建**：若在 JSVM 模块中需要创建一个新的 JavaScript 数组，可以使用提供的 OH_JSVM_CreateArray 接口创建数组，将数组传递给 JavaScript 层。\",\"12\":\"- **数组相关操作**：在 JSVM 模块中通过对应的接口获取 JavaScript 数组的长度、检索指定索引处的元素以及设置指定索引处的元素值，从而实现 JSVM 模块与 JavaScript 数组的交互。\",\"13\":\"- **TypedArray**：JavaScript 中的 TypedArray 是一种用来描述二进制数据的类数组数据视图，可以简单理解为一种指定元素类型的数组，TypedArray 没有直接构造器，但是可以用它的子类构造器构造 TypedArray 类型的数据。TypedArray 的子类有：Int8Array、Uint8Array、Uint8ClampedArray、Int16Array、Int32Array 等。\",\"14\":\"- **ArrayBuffer**：ArrayBuffer 是固定长度的二进制数据缓冲区。\",\"15\":\"- **DataView**：DataView 是 JavaScript 中的一种视图，是可以从 ArrayBuffer 对象中读写多种数值类型的底层接口。\",\"16\":\"\",\"17\":\"\",\"18\":\"## 接口说明\",\"19\":\"\",\"20\":\"| 接口                         | 功能说明                                   |\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "DataView 是从 ArrayBuffer 对象中读写多种数值类型的视图。",
      "触发条件": "当句子出现连续\"是\"字判断句式定义同一主体，或存在可合并的重复性修饰成分时触发。\n\n识别模式：\n1. 句式结构检测：存在\"A是B，是C\"的连续判断句式(例中\"是...视图，是...接口\")\n2. 语义冗余检测：多个分句描述同一核心功能(例中\"视图\"与\"底层接口\"指代同一概念)\n3. 修饰成分分析：存在可合并的限定词(例中\"JavaScript中的\"在前文已明确语境，无需重复强调)"
    },
    {
      "defect_id": 372779,
      "sentence": "判断一个 JavaScript 对象是否为 Array 类型对象。",
      "reference_sentence": "",
      "line_num": 653,
      "context": "{\"648\":\"JSVM GetDataViewInfo success, isArrayBuffer: 1\",\"649\":\"JSVM GetDataViewInfo success, byteOffset: 0\",\"650\":\"```\",\"651\":\"### OH_JSVM_IsArray\",\"652\":\"\",\"653\":\"判断一个 JavaScript 对象是否为 Array 类型对象。\",\"654\":\"\",\"655\":\"cpp 部分代码\",\"656\":\"\",\"657\":\"```cpp\",\"658\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "判断 JavaScript 对象是否为 Array 类型。",
      "触发条件": "检测到\"类型\"与\"对象\"重复使用（如\"Array类型对象\"），或存在冗余量词（如\"一个\"）修饰唯一对象时触发\n\n识别模式：1) 技术名词后连续出现\"类型\"+\"对象\"双重类型说明 2) 单数语境下存在不必要量词（如\"一个\"），且删除后不影响语义完整性"
    },
    {
      "defect_id": 371458,
      "sentence": "取消任务池中的任务组。当一个任务组的任务未全部执行结束时取消任务组，则返回undefined作为任务组结果。",
      "reference_sentence": "",
      "line_num": 666,
      "context": "{\"661\":\"\",\"662\":\"## taskpool.cancel<sup>10+</sup>\",\"663\":\"\",\"664\":\"cancel(group: TaskGroup): void\",\"665\":\"\",\"666\":\"取消任务池中的任务组。当一个任务组的任务未全部执行结束时取消任务组，则返回undefined作为任务组结果。\",\"667\":\"\",\"668\":\"**系统能力：** SystemCapability.Utils.Lang\",\"669\":\"\",\"670\":\"**原子化服务API**：从API version 11 开始，该接口支持在原子化服务中使用。\",\"671\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，可以拆分成多个独立的句子。",
      "更改后示例": "取消任务池中的任务组。如果任务组的任务未全部执行结束，取消任务组将返回undefined作为结果。",
      "触发条件": "句子为包含多个逗号的长复合句，且存在条件或假设关系（如“当...时，则...”结构），导致逻辑嵌套冗余。通过识别逗号分割的连续子句及条件关联词（如“当”“则”）判定需拆分简化。"
    },
    {
      "defect_id": 372938,
      "sentence": "使用这个函数将JavaScript中的布尔值转为等价的C布尔值。",
      "reference_sentence": "",
      "line_num": 280,
      "context": "{\"275\":\"JSVM OH_JSVM_CoerceToNumber success:1\",\"276\":\"```\",\"277\":\"\",\"278\":\"### OH_JSVM_GetValueBool\",\"279\":\"\",\"280\":\"使用这个函数将JavaScript中的布尔值转为等价的C布尔值。\",\"281\":\"\",\"282\":\"cpp 部分代码\",\"283\":\"\",\"284\":\"```cpp\",\"285\":\"// hello.cpp\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "将JavaScript布尔值转为C布尔值。",
      "触发条件": "当句子中同时出现源语言类型和目标语言类型的重复修饰（如\"JavaScript中的布尔值\"和\"C布尔值\"），且存在冗余形容词（如\"等价的\"）时触发。识别模式为：检测\"将A转为B\"结构中是否存在双重类型修饰（A/B同时包含语言前缀）或冗余等价性描述。"
    },
    {
      "defect_id": 372896,
      "sentence": "密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"| 接口                       | 功能说明                                     |\",\"17\":\"| -------------------------- | -------------------------------------------- |\",\"18\":\"| OH_JSVM_GetPrototype         | 获取给定JavaScript对象的原型。             |\",\"19\":\"| OH_JSVM_CreateObject         | 创建一个默认的JavaScript Object对象。                   |\",\"20\":\"| OH_JSVM_ObjectFreeze         | 冻结给定的对象，防止向其添加新属性，删除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。                             |\",\"21\":\"| OH_JSVM_ObjectSeal           |  密封给定的对象。这可以防止向其添加新属性，以及将所有现有属性标记为不可配置。                             |\",\"22\":\"| OH_JSVM_Typeof                | 返回JavaScript对象的类型。  |\",\"23\":\"| OH_JSVM_Instanceof            | 判断一个对象是否是某个构造函数的实例。    |\",\"24\":\"| OH_JSVM_TypeTagObject       | 将type_tag指针的值与JavaScript对象或外部对象相关联。                  |\",\"25\":\"| OH_JSVM_CheckObjectTypeTag | 检查给定的类型标签是否与对象上的类型标签匹配。 |\",\"26\":\"| OH_JSVM_CreateSymbol         | 根据给定的描述符创建一个Symbol对象。                     |\"}",
      "修改建议": "句子过长，包含过多信息，违反了言简意赅的原则。",
      "更改后示例": "密封给定的对象，防止添加新属性，将现有属性标记为不可配置。",
      "触发条件": "同一句子中存在重复主语的分句结构，或使用冗余连接词（如\"以及\"）连接可合并的同类信息项。\n\n识别模式：\n1. 分句重复：当主句后接解释性分句（如\"这可以...\"）且共享同一主语时\n2. 冗余连接：使用\"以及\"等连接词并列本可简化的同类型动作描述（如\"防止...，以及...\"）\n3. 信息密度失衡：单个句子包含超过两个动作说明，且存在可合并的平行语义结构"
    },
    {
      "defect_id": 372781,
      "sentence": "获取给定对象指定索引处的元素。",
      "reference_sentence": "",
      "line_num": 749,
      "context": "{\"744\":\"```\",\"745\":\"JSVM SetElement success\",\"746\":\"```\",\"747\":\"### OH_JSVM_GetElement\",\"748\":\"\",\"749\":\"获取给定对象指定索引处的元素。\",\"750\":\"\",\"751\":\"cpp 部分代码\",\"752\":\"\",\"753\":\"```cpp\",\"754\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "获取对象指定索引处的元素。",
      "触发条件": "句子中存在可省略的限定词（如\"给定\"）且上下文已隐含对象来源时，或出现重复性修饰词（如\"指定\"+\"特定索引处\"）导致语义重叠时。  \n\n识别模式：检测\"获取/获得/取得\"等动词后接\"给定/特定/相应\"等限定词，且后文已包含\"对象/数组\"等明确主体及\"指定索引处\"等定位描述时，判定为冗余修饰结构。"
    },
    {
      "defect_id": 371405,
      "sentence": "以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。",
      "reference_sentence": "",
      "line_num": 163,
      "context": "{\"158\":\"| ----------------  | ---------------- |\",\"159\":\"| Promise\\\\<Object> | Promise对象，返回任务函数的执行结果。 |\",\"160\":\"\",\"161\":\"**错误码：**\",\"162\":\"\",\"163\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"164\":\"\",\"165\":\"| 错误码ID | 错误信息                                     |\",\"166\":\"| -------- | ------------------------------------------- |\",\"167\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"168\":\"| 10200006 | An exception occurred during serialization. |\"}",
      "修改建议": "句子较长，且包含不必要的修饰成分。",
      "更改后示例": "请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。",
      "触发条件": "句子中存在可被上下文或链接目标隐含的冗余修饰语（如\"详细介绍\"），导致表述冗长且信息重复。"
    },
    {
      "defect_id": 372780,
      "sentence": "在给定对象的指定索引处设置元素。",
      "reference_sentence": "",
      "line_num": 702,
      "context": "{\"697\":\"```\",\"698\":\"JSVM IsArray success, IsArray: 1\",\"699\":\"```\",\"700\":\"### OH_JSVM_SetElement\",\"701\":\"\",\"702\":\"在给定对象的指定索引处设置元素。\",\"703\":\"\",\"704\":\"cpp 部分代码\",\"705\":\"\",\"706\":\"```cpp\",\"707\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "在对象的指定索引处设置元素。",
      "触发条件": "句子中包含冗余限定词（如“给定”）且上下文已明确对象或参数时，或存在可删除的重复性修饰词而不影响技术准确性时触发。"
    },
    {
      "defect_id": 372783,
      "sentence": "尝试删除给定对象的指定索引处的元素。",
      "reference_sentence": "",
      "line_num": 857,
      "context": "{\"852\":\"JSVM hasElement: 1\",\"853\":\"JSVM hasElement: 0\",\"854\":\"```\",\"855\":\"### OH_JSVM_DeleteElement\",\"856\":\"\",\"857\":\"尝试删除给定对象的指定索引处的元素。\",\"858\":\"\",\"859\":\"cpp部分代码\",\"860\":\"\",\"861\":\"```cpp\",\"862\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "尝试删除对象的指定索引处的元素。",
      "触发条件": "当句子中同一名词前存在多个冗余限定词（如“给定”和“指定”），且其中一个限定词隐含或覆盖另一词义时触发。  \n识别模式：检测“名词短语修饰链”（如“给定对象的指定索引处”），若修饰词存在逻辑重叠或上下文隐含信息可替代，则判定为冗余。"
    },
    {
      "defect_id": 373925,
      "sentence": "创建并获取一个带文本信息的ArkTS TypeError。",
      "reference_sentence": "",
      "line_num": 94,
      "context": "{\"89\":\"}\",\"90\":\"```\",\"91\":\"\",\"92\":\"### napi_create_type_error\",\"93\":\"\",\"94\":\"创建并获取一个带文本信息的ArkTS TypeError。\",\"95\":\"\",\"96\":\"cpp部分代码\",\"97\":\"\",\"98\":\"```cpp\",\"99\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "原句包含不必要的修饰成分。",
      "更改后示例": "创建并获取带文本信息的ArkTS TypeError。",
      "触发条件": "句子中存在冗余的数量词（如“一个”）或修饰成分，且其存在不改变核心语义或技术准确性时触发。具体表现为动词（如“创建”“获取”）已隐含单数对象生成逻辑时，额外添加“一个”等量词。"
    },
    {
      "defect_id": 371586,
      "sentence": "调用该接口时确保处理数据的回调函数已在宿主线程注册。",
      "reference_sentence": "",
      "line_num": 1345,
      "context": "{\"1340\":\"\",\"1341\":\"> **说明：**\",\"1342\":\">\",\"1343\":\"> - 该接口在taskpool的线程中调用。\",\"1344\":\"> - 避免在回调函数中使用该方法。\",\"1345\":\"> - 调用该接口时确保处理数据的回调函数已在宿主线程注册。\",\"1346\":\"\",\"1347\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1348\":\"\",\"1349\":\"**原子化服务API**：从API version 11 开始，该接口支持在原子化服务中使用。\",\"1350\":\"\"}",
      "修改建议": "原文过于啰嗦，信息冗余。",
      "更改后示例": "调用该接口前确保回调函数已在宿主线程注册。",
      "触发条件": "当句子中存在可删除的冗余修饰语（如重复上下文已隐含的功能描述）或时间状语冗余（如“时”被更精准的“前”替代）时触发。具体识别模式为：检测名词前是否有冗余定语（如“处理数据的回调函数”→ 回调函数默认处理数据），或时间状语与动作逻辑不匹配（如“调用接口时”需改为“调用接口前”）。"
    },
    {
      "defect_id": 372784,
      "sentence": "判断一个 JavaScript 对象是否为 Dataview类型对象。",
      "reference_sentence": "",
      "line_num": 911,
      "context": "{\"906\":\"```\",\"907\":\"JSVM DeleteElement: 1\",\"908\":\"```\",\"909\":\"### OH_JSVM_IsDataview\",\"910\":\"\",\"911\":\"判断一个 JavaScript 对象是否为 Dataview类型对象。\",\"912\":\"\",\"913\":\"cpp 部分代码\",\"914\":\"\",\"915\":\"```cpp\",\"916\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "判断 JavaScript 对象是否为 Dataview 类型。",
      "触发条件": "当句子同时包含可省略的数量限定词（如\"一个\"）和重复的类型说明（如\"X类型对象\"中的\"类型\"）时触发。识别模式为\"量词+类型名词+类型重复描述\"结构（例：判断一个[对象]是否为[X类型对象]）。"
    },
    {
      "defect_id": 372898,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"| OH_JSVM_CreateExternal       | 创建一个包装了外部指针的JavaScript对象。               |\",\"29\":\"| OH_JSVM_GetValueExternal    | 获取先前传递给OH_JSVM_CreateExternal的外部数据指针。                  |\",\"30\":\"\",\"31\":\"## 使用示例\",\"32\":\"\",\"33\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"34\":\"\",\"35\":\"### OH_JSVM_GetPrototype\",\"36\":\"\",\"37\":\"获取给定JavaScript对象的原型。\",\"38\":\"\"}",
      "修改建议": "句子过长，包含过多信息，违反了言简意赅的原则。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文展示接口对应C++及ArkTS代码。",
      "触发条件": "句子中同时存在重复性内容（如链接文本与前置内容重复）或冗余限定词（如\"相关\"、\"进行\"等），且导致信息密度降低。  \n\n识别模式：  \n1. 检查名词短语与相邻链接文本是否存在语义重叠（如\"JSVM-API接口开发流程\"与链接标题\"使用JSVM-API实现JS与C/C++交互开发流程\"）  \n2. 检测冗余修饰词组合（如\"相关代码进行展示\"中的\"相关\"+动词名词化结构\"进行展示\"，可简化为直接动词\"展示代码\"）"
    },
    {
      "defect_id": 372785,
      "sentence": "判断一个 JavaScript 对象是否为 Typedarray 类型对象。",
      "reference_sentence": "",
      "line_num": 961,
      "context": "{\"956\":\"```\",\"957\":\"JSVM IsDataView: 1\",\"958\":\"```\",\"959\":\"### OH_JSVM_IsTypedarray\",\"960\":\"\",\"961\":\"判断一个 JavaScript 对象是否为 Typedarray 类型对象。\",\"962\":\"\",\"963\":\"cpp 部分代码\",\"964\":\"\",\"965\":\"```cpp\",\"966\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "判断 JavaScript 对象是否为 Typedarray 类型。",
      "触发条件": "当名词短语同时包含\"类型\"和\"对象\"双重限定词时（如\"XX类型对象\"），或存在可省略的量词（如\"一个\"）时触发。\n\n识别模式：\n1. 检测\"类型\"+\"对象\"的复合结构（如\"Typedarray类型对象\"）\n2. 检查量词在非必要量化场景中的使用（如判断类语句中的\"一个\"）\n3. 验证删除冗余词后语义完整性（如\"对象\"删除后仍能通过\"类型\"明确指代）"
    },
    {
      "defect_id": 382992,
      "sentence": "表示是否允许用户取消应用保活，true表示允许，false表示不允许。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"| ------------------------- | ------ | ---- | ---- | --------- |\",\"68\":\"| bundleName   | string | 是 | 否  | Bundle名称。 |\",\"69\":\"| type       | [KeepAliveAppType](#keepaliveapptype14) | 是 | 否 | 表示被保活应用的应用类型。   |\",\"70\":\"| setter       | [KeepAliveSetter](#keepalivesetter14) | 是 | 否 | 表示应用保活设置者类型。   |\",\"71\":\"| setterUserId<sup>20+</sup>   | number | 是 | 是  | 应用保活设置者的用户ID。 |\",\"72\":\"| allowUserToCancel<sup>20+</sup>   | boolean | 是 | 是  | 表示是否允许用户取消应用保活，true表示允许，false表示不允许。 |\",\"73\":\"\",\"74\":\"## appManager.isSharedBundleRunning<sup>10+</sup>\",\"75\":\"\",\"76\":\"isSharedBundleRunning(bundleName: string, versionCode: number): Promise\\\\<boolean>\",\"77\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "表示是否允许用户取消保活。true表示允许，false表示不允许。",
      "触发条件": "当句子中存在与上下文重复的修饰成分（如参数名称已包含的限定词）且导致句式冗余时；或当解释性语句重复参数取值范围说明（如true/false）时。\n\n识别模式：\n1. 检查名词前是否有上下文已明确的限定词（如参数表格中的\"allowUserToCancel\"已隐含\"应用保活\"上下文）\n2. 检测是否存在重复取值说明结构（如\"true表示允许，false表示不允许\"在布尔型参数中属于冗余说明）\n3. 观察句子是否包含超过两个逗号分隔的语义重复片段"
    },
    {
      "defect_id": 371584,
      "sentence": "该接口在taskpool的线程中调用。",
      "reference_sentence": "",
      "line_num": 1343,
      "context": "{\"1338\":\"\",\"1339\":\"在任务执行过程中向宿主线程发送消息并触发回调。使用该方法前需先构造Task。\",\"1340\":\"\",\"1341\":\"> **说明：**\",\"1342\":\">\",\"1343\":\"> - 该接口在taskpool的线程中调用。\",\"1344\":\"> - 避免在回调函数中使用该方法。\",\"1345\":\"> - 调用该接口时确保处理数据的回调函数已在宿主线程注册。\",\"1346\":\"\",\"1347\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1348\":\"\"}",
      "修改建议": "原文过于啰嗦，信息冗余。",
      "更改后示例": "该接口在taskpool线程中调用。",
      "触发条件": "当名词短语中存在不必要的所有格结构（如“的”字），且删除后不影响语义且更符合技术术语惯例时触发。例如专有名词（如taskpool）与通用名词（如线程）直接组合时，无需添加“的”字。"
    },
    {
      "defect_id": 397747,
      "sentence": "ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"- 限制运算符语义：为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。例如，一元加法运算符只能作用于数字，不能用于其他类型的变量等。\",\"15\":\"\",\"16\":\"- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，后续会重新考虑是否支持Structural typing。\",\"17\":\"\",\"18\":\"ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。\",\"19\":\"\",\"20\":\"未来，ArkTS会结合应用开发/运行的需求持续演进，逐步增强并行和并发能力、扩展系统类型，以及引入分布式开发范式等更多特性。\",\"21\":\"\",\"22\":\"如需深入了解ArkTS语言，可参考[ArkTS具体指南](../arkts-utils/arkts-overview.md)。\"}",
      "修改建议": "句子较长，包含多个逗号，信息过于复杂。",
      "更改后示例": "ArkTS兼容TS/JS生态，开发者可以使用TS/JS进行开发或复用代码。OpenHarmony系统对TS/JS支持的详细情况见兼容约束。",
      "触发条件": "当句子中同时存在重复术语解释（如括号内重复简称）和链接文本冗余（重复前文已提及的关键词）时触发；或当信息密度过高导致句子结构复杂（超过两个逗号分隔的独立信息点）时触发。\n\n识别模式：\n1. 括号内重复已明确的简称（如\"(简称JS)\"在上下文已定义的情况下）\n2. 链接锚文本包含前文已完整表述的关键词（如\"[兼容TS/JS的约束]\"中的\"TS/JS\"）\n3. 单句包含超过两个逗号分隔的复合信息结构\n4. 存在可合并的冗余表达（如\"复用已有代码\"→\"复用代码\"）"
    },
    {
      "defect_id": 397851,
      "sentence": "ArkTS是一种设计用于构建高性能应用的编程语言。它在继承TypeScript语法的基础上进行了优化，以提供更高的性能和开发效率。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS语言介绍\",\"2\":\"\",\"3\":\"ArkTS是一种设计用于构建高性能应用的编程语言。它在继承TypeScript语法的基础上进行了优化，以提供更高的性能和开发效率。\",\"4\":\"\",\"5\":\"许多编程语言在设计之初没有考虑到移动设备，导致应用的运行缓慢、低效、功耗大，随着移动设备在人们的日常生活中变得越来越普遍，针对移动环境的编程语言优化需求也越来越多。ArkTS是专为解决这些问题而设计的，聚焦于提高运行效率。\",\"6\":\"\",\"7\":\"TypeScript是在JavaScript基础上通过添加类型定义扩展而来的，ArkTS则是TypeScript的进一步扩展。TypeScript提供了一种更结构化的JavaScript编码方法，深受开发者喜爱。ArkTS保持了TypeScript的大部分语法，旨在为现有的TypeScript开发者实现无缝过渡，帮助移动开发者快速上手。\",\"8\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "ArkTS用于构建高性能应用，继承并优化了TypeScript语法，提高性能和开发效率。",
      "触发条件": "句子包含重复修饰成分（如“设计用于”）、多个分句重复同一主语，或存在\"以...为目的/基础\"等冗余介词结构时触发。\n\n识别模式：  \n1. 检测连续分句共用同一主语（如\"它...它...\"）  \n2. 识别冗余动词短语（如\"是设计用于\"可简化为\"用于\"）  \n3. 定位\"在...基础上进行优化\"等复杂表达，可替换为\"优化了...\"  \n4. 发现重复语义成分（如原句两次提及\"性能\"）"
    },
    {
      "defect_id": 376517,
      "sentence": "需要配置公钥私钥参考**新员工环境搭建.pptx**",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"### 1.代码\",\"2\":\"\",\"3\":\"gitee：https://gitee.com/openharmony\",\"4\":\"\",\"5\":\"需要配置公钥私钥参考**新员工环境搭建.pptx**\",\"6\":\"\",\"7\":\"~~~shell\",\"8\":\"#代码位置\",\"9\":\"git clone git@10.0.77.88:ams20243/openharmony.git\",\"10\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分，且信息冗长。",
      "更改后示例": "配置公钥私钥，参考**新员工环境搭建.pptx**",
      "触发条件": "句子中存在\"需要/应+动词\"的冗余结构，或连续信息点未用标点分隔导致语义重复。  \n识别模式：检测\"需要配置\"\"应参考\"等助动词+动词组合（核心动作已被动词本身隐含），或检查多个信息单元（如操作指令+文档指引）是否缺少逗号/句号分隔。"
    },
    {
      "defect_id": 371437,
      "sentence": "从API version 13 开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 384,
      "context": "{\"379\":\"\",\"380\":\"校验并发函数的参数类型和返回类型后，延时执行泛型任务。\",\"381\":\"\",\"382\":\"**系统能力：** SystemCapability.Utils.Lang\",\"383\":\"\",\"384\":\"**原子化服务API**：从API version 13 开始，该接口支持在原子化服务中使用。\",\"385\":\"\",\"386\":\"**参数：**\",\"387\":\"\",\"388\":\"| 参数名       | 类型          | 必填 | 说明                 |\",\"389\":\"| ----------- | ------------- | ---- | -------------------- |\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "从API version 13开始，该接口支持在原子化服务中使用。",
      "触发条件": "当句子中出现时间状语中\"开始\"与前置词搭配存在冗余（如\"从...开始\"可简化为\"从...起\"），或存在多余空格影响术语规范性时触发。\n\n识别模式：1) 检测\"从API version X 开始\"结构中空格使用及\"开始\"必要性；2) 判断时间状语是否包含可简化的动词成分（如\"开始\"可替换为更简洁的\"起\"）"
    },
    {
      "defect_id": 397746,
      "sentence": "对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，后续会重新考虑是否支持Structural typing。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"- 禁止在运行时改变对象布局：为实现最优性能，ArkTS要求在程序执行期间不能更改对象布局。\",\"13\":\"\",\"14\":\"- 限制运算符语义：为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。例如，一元加法运算符只能作用于数字，不能用于其他类型的变量等。\",\"15\":\"\",\"16\":\"- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，后续会重新考虑是否支持Structural typing。\",\"17\":\"\",\"18\":\"ArkTS兼容TS/JavaScript（简称JS）生态，开发者可以使用TS/JS进行开发或复用已有代码。OpenHarmony系统对TS/JS支持的详细情况见[兼容TS/JS的约束](arkts-migration-background.md#方舟运行时兼容tsjs)。\",\"19\":\"\",\"20\":\"未来，ArkTS会结合应用开发/运行的需求持续演进，逐步增强并行和并发能力、扩展系统类型，以及引入分布式开发范式等更多特性。\",\"21\":\"\"}",
      "修改建议": "句子较长，包含多个逗号，信息过于复杂。",
      "更改后示例": "支持Structural typing需要大量考虑和实现。当前ArkTS不支持该特性。根据实际需求和反馈，后续会重新考虑。",
      "触发条件": "句子包含连续分句或逗号分隔的复杂结构，且存在重复性表述（如语义重叠的形容词、动词短语）或冗余信息（如重复提及同一概念）。  \n\n识别模式：  \n1. **结构复杂**：长句含多个逗号分隔的从句或并列成分（例如原句中的“需要在...实现，当前...特性”）。  \n2. **冗余词汇**：同义/近义词叠加（如“大量的考虑和仔细的实现”中“大量”与“仔细”语义重复）。  \n3. **重复信息**：同一概念多次出现（如原句两次提及“Structural typing”），可通过代词或简化表达替代。"
    },
    {
      "defect_id": 372935,
      "sentence": "在JSVM模块中，可以使用JSVM函数将JavaScript值转换为C/C++的数据类型，如将JavaScript数值转换为C/C++的整数、将JavaScript字符串转换为C/C++的字符数组等。同样，也可以将C/C++的数据类型转换为JavaScript值，以便将结果返回给JavaScript代码。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用JSVM操作JavaScript对象时，有一些基本概念需要了解：\",\"10\":\"\",\"11\":\"- **JavaScript值到C/C++类型的转换：** 在JSVM模块中，可以使用JSVM函数将JavaScript值转换为C/C++的数据类型，如将JavaScript数值转换为C/C++的整数、将JavaScript字符串转换为C/C++的字符数组等。同样，也可以将C/C++的数据类型转换为JavaScript值，以便将结果返回给JavaScript代码。\",\"12\":\"\",\"13\":\"## 接口说明\",\"14\":\"\",\"15\":\"| 接口                   | 功能说明                                                |\",\"16\":\"| ---------------------- | ------------------------------------------------------- |\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "在JSVM模块中，可以使用JSVM函数将JavaScript值转换为C/C++数据类型，如数值转换为整数，字符串转换为字符数组。同样，也可以将C/C++数据类型转换为JavaScript值，以便返回给JavaScript代码。",
      "触发条件": "当同一修饰成分在相邻子句/列举项中重复出现（如\"JavaScript\"前缀、\"C/C++的\"后缀），或存在冗余所属结构（\"的\"字结构）时触发。\n\n识别模式：\n1. 检查并列结构中是否存在重复前缀（如\"将JavaScript数值→C/C++的整数\"与\"将JavaScript字符串→C/C++的字符数组\"）\n2. 检测\"将...转换为...的...\"双重所属结构（如\"将结果返回给\"中的冗余\"将结果\"）\n3. 验证重复成分是否在上下文中已明确（如主句已说明转换方向，举例时可省略方向性修饰）"
    },
    {
      "defect_id": 397855,
      "sentence": "ArkTS语言设计中考虑了与TypeScript和JavaScript的互通性。许多移动应用开发者希望重用TypeScript和JavaScript代码及库，因此ArkTS提供与TypeScript和JavaScript的无缝互通，使开发者可以轻松集成TypeScript和JavaScript代码到应用中，充分利用现有代码和库进行ArkTS开发。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"TypeScript是在JavaScript基础上通过添加类型定义扩展而来的，ArkTS则是TypeScript的进一步扩展。TypeScript提供了一种更结构化的JavaScript编码方法，深受开发者喜爱。ArkTS保持了TypeScript的大部分语法，旨在为现有的TypeScript开发者实现无缝过渡，帮助移动开发者快速上手。\",\"8\":\"\",\"9\":\"ArkTS的一大特性是它专注于低运行时开销。ArkTS对TypeScript的动态类型特性施加了更严格的限制，以减少运行时开销，提高执行效率。通过取消动态类型特性，ArkTS代码能更有效地被运行前编译和优化，从而实现更快的应用启动和更低的功耗。\",\"10\":\"\",\"11\":\"ArkTS语言设计中考虑了与TypeScript和JavaScript的互通性。许多移动应用开发者希望重用TypeScript和JavaScript代码及库，因此ArkTS提供与TypeScript和JavaScript的无缝互通，使开发者可以轻松集成TypeScript和JavaScript代码到应用中，充分利用现有代码和库进行ArkTS开发。\",\"12\":\"\",\"13\":\"本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，助力开发者使用ArkTS高效构建高性能的移动应用。\",\"14\":\"\",\"15\":\"如需详细了解ArkTS语言，请参阅[ArkTS具体指南](../arkts-utils/arkts-overview.md)<!--RP1--><!--RP1End-->。\",\"16\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "ArkTS设计考虑与TypeScript和JavaScript的互通性。许多开发者希望重用TypeScript和JavaScript代码及库，ArkTS提供无缝互通，方便集成现有代码和库。",
      "触发条件": "同一技术术语（如\"TypeScript和JavaScript\"）在相邻分句中重复出现超过2次，且存在可合并的介词结构（如\"使...可以\"）或冗余修饰语（如\"轻松\"、\"充分\"）时。\n\n识别模式：\n1. 通过依存句法分析检测连续重复的专有名词短语\n2. 定位超过3个逗号的长复合句结构\n3. 识别\"因此/使/让\"等引导的因果状语从句与主句语义重叠\n4. 发现修饰动词的副词短语（如\"轻松集成\"）与上下文已有语义重复\n5. 检测\"进行...开发\"等冗余动宾结构（\"进行ArkTS开发\"→\"开发ArkTS\"）"
    },
    {
      "defect_id": 397984,
      "sentence": "使用`switch`语句执行与`switch`表达式值匹配的代码块。",
      "reference_sentence": "",
      "line_num": 354,
      "context": "{\"349\":\"}\",\"350\":\"```\",\"351\":\"\",\"352\":\"#### `Switch`语句\",\"353\":\"\",\"354\":\"使用`switch`语句执行与`switch`表达式值匹配的代码块。\",\"355\":\"\",\"356\":\"`switch`语句如下所示：\",\"357\":\"\",\"358\":\"```typescript\",\"359\":\"switch (expression) {\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`switch`语句执行匹配代码块。",
      "触发条件": "当句子中出现重复名词（如\"switch\"）或存在可简化的同位语结构（如\"与switch表达式值匹配的\"）时触发。具体表现为同一语义单元被不同语法形式重复表达（原句通过\"switch语句\"和\"switch表达式值\"双重限定\"匹配\"动作）。"
    },
    {
      "defect_id": 397863,
      "sentence": "`Object`类型是所有引用类型的基类型。任何值，包括基本类型的值，都可以直接被赋给`Object`类型的变量（基本类型值会被自动装箱）。`Object`类型用于表示除基本类型外的类型。",
      "reference_sentence": "",
      "line_num": 156,
      "context": "{\"151\":\"let instance: Class <void>\",\"152\":\"```\",\"153\":\"\",\"154\":\"#### `Object`类型\",\"155\":\"\",\"156\":\"`Object`类型是所有引用类型的基类型。任何值，包括基本类型的值，都可以直接被赋给`Object`类型的变量（基本类型值会被自动装箱）。`Object`类型用于表示除基本类型外的类型。\",\"157\":\"```typescript\",\"158\":\"let o1: Object = 'Alice';\",\"159\":\"let o2: Object = ['a','b'];\",\"160\":\"let o3: Object = 1;\",\"161\":\"```\"}",
      "修改建议": "原句含有过多的解释性内容，导致句子过长。",
      "更改后示例": "`Object`类型是所有引用类型的基类型。基本类型值会被自动装箱。`Object`类型用于表示除基本类型外的类型。",
      "触发条件": "当句子包含重复解释（如主句与括号内容重复）或多个分句传递相同信息时触发，尤其当补充说明导致句子冗长且核心信息重复时。\n\n识别模式：检查是否存在以下特征：\n1. 主句与括号、破折号内的补充说明重复同一概念（如“任何值...基本类型值”与括号内容重复）。\n2. 连续分句用不同表达方式描述同一机制（如赋值行为与自动装箱机制被拆分为两个独立解释）。"
    },
    {
      "defect_id": 397856,
      "sentence": "本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，助力开发者使用ArkTS高效构建高性能的移动应用。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"ArkTS的一大特性是它专注于低运行时开销。ArkTS对TypeScript的动态类型特性施加了更严格的限制，以减少运行时开销，提高执行效率。通过取消动态类型特性，ArkTS代码能更有效地被运行前编译和优化，从而实现更快的应用启动和更低的功耗。\",\"10\":\"\",\"11\":\"ArkTS语言设计中考虑了与TypeScript和JavaScript的互通性。许多移动应用开发者希望重用TypeScript和JavaScript代码及库，因此ArkTS提供与TypeScript和JavaScript的无缝互通，使开发者可以轻松集成TypeScript和JavaScript代码到应用中，充分利用现有代码和库进行ArkTS开发。\",\"12\":\"\",\"13\":\"本教程将指导开发者了解ArkTS的核心功能、语法和最佳实践，助力开发者使用ArkTS高效构建高性能的移动应用。\",\"14\":\"\",\"15\":\"如需详细了解ArkTS语言，请参阅[ArkTS具体指南](../arkts-utils/arkts-overview.md)<!--RP1--><!--RP1End-->。\",\"16\":\"\",\"17\":\"## 基本知识\",\"18\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "本教程指导开发者了解ArkTS的核心功能、语法和最佳实践，助力高效开发高性能移动应用。",
      "触发条件": "句子包含多个逗号分隔的并列成分，且存在重复主语（如\"开发者\"二次出现）或冗余助动词（如\"将\"）时触发；或当修饰词与动词存在语义重叠（如\"高效构建\"可简化为\"开发\"）时触发。\n\n识别模式：  \n1. **结构冗余**：检查长句是否因并列成分分割过多（≥2个逗号）导致逻辑分散；  \n2. **成分重复**：识别同一主语/宾语在相邻分句中的重复使用；  \n3. **修饰冗余**：判断动词前修饰词（如\"高效\"）是否与动词本身隐含语义重复，或助动词（如\"将\"）是否在语境中必要性不足。"
    },
    {
      "defect_id": 397873,
      "sentence": "`===`与`==`的区别：",
      "reference_sentence": "",
      "line_num": 274,
      "context": "{\"269\":\"| `>`      | 如果左操作数大于右操作数，则返回true。 |\",\"270\":\"| `>=`     | 如果左操作数大于或等于右操作数，则返回true。 |\",\"271\":\"| `<`      | 如果左操作数小于右操作数，则返回true。    |\",\"272\":\"| `<=`     | 如果左操作数小于或等于右操作数，则返回true。 |\",\"273\":\"\",\"274\":\"`===`与`==`的区别：\",\"275\":\"```typescript\",\"276\":\"    let a:Object=1;\",\"277\":\"    let b:Object='1';\",\"278\":\"    // == 只比较值相等\",\"279\":\"    console.log(a == b); // true\"}",
      "修改建议": "原句含有不必要的修饰成分。",
      "更改后示例": "`===` 与 `==` 的区别。",
      "触发条件": "当句子结构呈现\"A与B的的区别\"模式时，其中\"的\"字冗余（正确表述应为\"A与B的区别\"），且上下文为对比性说明场景时触发。识别模式需检测\"与\"连接的并列结构后紧跟\"的区别\"时存在多余\"的\"字。"
    },
    {
      "defect_id": 397868,
      "sentence": "常量表达式用于显式设置枚举常量的值。",
      "reference_sentence": "",
      "line_num": 184,
      "context": "{\"179\":\"```typescript\",\"180\":\"enum ColorSet { Red, Green, Blue }\",\"181\":\"let c: ColorSet = ColorSet.Red;\",\"182\":\"```\",\"183\":\"\",\"184\":\"常量表达式用于显式设置枚举常量的值。\",\"185\":\"\",\"186\":\"```typescript\",\"187\":\"enum ColorSet { White = 0xFF, Grey = 0x7F, Black = 0x00 }\",\"188\":\"let c: ColorSet = ColorSet.Black;\",\"189\":\"```\"}",
      "修改建议": "原句含有不必要的修饰成分。",
      "更改后示例": "常量表达式设置枚举常量的值。",
      "触发条件": "当句子中存在可简化的动词短语结构（如\"用于设置\"可简化为\"设置\"），或含有在技术语境下不言自明的冗余修饰词（如\"显式\"在枚举赋值场景中属默认行为）时触发。\n\n识别模式：\n1. 动词嵌套结构检测：识别\"用于/用来/用以 + 动词\"的句式，判断是否可简化为单个动词\n2. 语境冗余分析：结合代码上下文（如示例中的枚举赋值语法），验证修饰词（如\"显式\"）是否重复表达语言特性本身已隐含的语义"
    },
    {
      "defect_id": 397870,
      "sentence": "`Aliases`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。",
      "reference_sentence": "",
      "line_num": 240,
      "context": "{\"235\":\"}\",\"236\":\"```\",\"237\":\"\",\"238\":\"#### `Aliases`类型\",\"239\":\"\",\"240\":\"`Aliases`类型为匿名类型（数组、函数、对象字面量或联合类型）提供名称，或为已有类型提供替代名称。\",\"241\":\"\",\"242\":\"```typescript\",\"243\":\"type Matrix = number[][];\",\"244\":\"type Handler = (s: string, no: number) => string;\",\"245\":\"type Predicate <T> = (x: T) => boolean;\"}",
      "修改建议": "原句含有过多的解释性内容，导致句子过长。",
      "更改后示例": "`Aliases`类型为匿名类型提供名称，或为已有类型提供替代名称。",
      "触发条件": "句子中存在括号内列举多个示例或解释性内容，且上下文已明确匿名类型定义，导致核心信息重复或冗长。\n\n识别模式：检查括号内是否为扩展性举例（如“数组、函数、对象字面量或联合类型”），若该内容属于已知类型范畴且不影响核心规则表述，则触发冗余表达规则。可通过检测\"（...）\"结构内包含超过2个并列示例的特征进行初步定位。"
    },
    {
      "defect_id": 397875,
      "sentence": "二元运算符列举如下：",
      "reference_sentence": "",
      "line_num": 289,
      "context": "{\"284\":\"\",\"285\":\"#### 算术运算符\",\"286\":\"\",\"287\":\"一元运算符包括：`-`、`+`、`--`、`++`。\",\"288\":\"\",\"289\":\"二元运算符列举如下：\",\"290\":\"\",\"291\":\"| 运算符| 说明             |\",\"292\":\"| -------- | ------------------------ |\",\"293\":\"| `+`      | 加法                |\",\"294\":\"| `-`      | 减法             |\"}",
      "修改建议": "原句含有不必要的修饰成分。",
      "更改后示例": "二元运算符：",
      "触发条件": "当句子在主题词后使用\"如下/如下所示/列举如下\"等引导性短语，且上下文已通过列表/表格等结构化形式呈现具体内容时触发\n\n识别模式需同时满足：\n1. 存在\"如下\"类引导词+冒号的固定结构（如\"X列举如下：\"）\n2. 后续相邻段落包含明确的结构化内容（表格/代码块/项目列表）\n3. 引导短语未提供新信息，仅重复主题词已表达的核心语义"
    },
    {
      "defect_id": 397867,
      "sentence": "使用枚举常量时必须以枚举类型名称为前缀。",
      "reference_sentence": "",
      "line_num": 177,
      "context": "{\"172\":\"```\",\"173\":\"\",\"174\":\"#### `enum`类型\",\"175\":\"\",\"176\":\"`enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。\",\"177\":\"使用枚举常量时必须以枚举类型名称为前缀。\",\"178\":\"\",\"179\":\"```typescript\",\"180\":\"enum ColorSet { Red, Green, Blue }\",\"181\":\"let c: ColorSet = ColorSet.Red;\",\"182\":\"```\"}",
      "修改建议": "原句含有不必要的修饰成分。",
      "更改后示例": "使用枚举常量时需带枚举类型名称。",
      "触发条件": "当句子中存在冗余的强制性修饰词（如\"必须\"）或复杂介词结构（如\"以...为前缀\"），且存在更简洁的同义表达（如\"需带\"）时触发。典型模式为\"必须 + 动词短语 + 复杂介词\"组合，在技术规范类文本中与特定术语（如枚举类型名称）共同出现。"
    },
    {
      "defect_id": 397987,
      "sentence": "`break`语句（可选的）允许跳出`switch`语句并继续执行`switch`语句之后的语句。",
      "reference_sentence": "",
      "line_num": 380,
      "context": "{\"375\":\"\",\"376\":\"如果`switch`表达式的值等于某个label的值，则执行相应的语句。\",\"377\":\"\",\"378\":\"如果没有任何一个label值与表达式值相匹配，并且`switch`具有`default`子句，那么程序会执行`default`子句对应的代码块。\",\"379\":\"\",\"380\":\"`break`语句（可选的）允许跳出`switch`语句并继续执行`switch`语句之后的语句。\",\"381\":\"\",\"382\":\"如果没有`break`语句，则执行`switch`中的下一个label对应的代码块。\",\"383\":\"\",\"384\":\"#### 条件表达式\",\"385\":\"\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`break`语句允许跳出`switch`。",
      "触发条件": "当句子包含对编程语言默认行为/常识性机制的解释（如break语句的后续执行流程），或存在重复限定词（如\"可选的\"标注）时触发。\n\n识别模式：1) 出现解释语言基础机制的多余分句（例：用\"继续执行...\"解释break的常规作用）2) 包含带括号的限定词但上下文已隐含该属性（例：\"（可选的）\"在语言规范文档中冗余）3) 核心功能描述被次要信息稀释（原句break的核心功能\"跳出switch\"仅占1/3篇幅）"
    },
    {
      "defect_id": 397982,
      "sentence": "`else`部分也可能包含`if`语句。",
      "reference_sentence": "",
      "line_num": 324,
      "context": "{\"319\":\"### 语句\",\"320\":\"\",\"321\":\"#### `If`语句\",\"322\":\"\",\"323\":\"`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。\",\"324\":\"`else`部分也可能包含`if`语句。\",\"325\":\"\",\"326\":\"`if`语句如下所示：\",\"327\":\"\",\"328\":\"```typescript\",\"329\":\"if (condition1) {\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`else`部分可以包含`if`语句。",
      "触发条件": "检测到句子中同时存在表示可能性的冗余副词（如\"可能\"）与表示能力的动词（如\"可以\"）叠加使用，且上下文已明确表达能力属性时触发。  \n\n识别模式：当出现类似\"也可能可以/可能包含\"结构时，需判断\"可能\"是否与后接动词存在语义重复（例如技术场景中描述语法能力时，\"可以\"已隐含允许性，无需叠加可能性修饰）。"
    },
    {
      "defect_id": 397864,
      "sentence": "`array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。",
      "reference_sentence": "",
      "line_num": 165,
      "context": "{\"160\":\"let o3: Object = 1;\",\"161\":\"```\",\"162\":\"\",\"163\":\"#### `array`类型\",\"164\":\"\",\"165\":\"`array`类型，即数组，是由可赋值给数组声明中指定的元素类型的数据组成的对象。\",\"166\":\"数组可由数组复合字面量赋值。数组复合字面量是用方括号括起来的零个或多个表达式列表，每个表达式为数组中的一个元素。数组的长度由数组中元素的个数确定。数组中第一个元素的索引为0。\",\"167\":\"\",\"168\":\"以下示例将创建包含三个元素的数组：\",\"169\":\"\",\"170\":\"```typescript\"}",
      "修改建议": "原句含有过多的解释性内容，导致句子过长。",
      "更改后示例": "`array`类型，即数组，由指定类型的元素组成。",
      "触发条件": "当句子包含重复的解释性内容（如同时用多个限定词描述同一概念）或存在可合并/简化的长修饰结构（如\"可赋值给...指定的...数据组成的对象\"），导致核心信息被冗余细节稀释时触发。  \n\n识别模式：检查是否存在①同语义重复（如\"数组声明中指定的元素类型\"与\"指定类型\"等效）、②冗余技术细节（如\"可赋值给...数据组成的对象\"在类型定义中非必要）、③多重嵌套修饰短语（如介词结构超过两层）。"
    },
    {
      "defect_id": 397874,
      "sentence": "一元运算符包括：`-`、`+`、`--`、`++`。",
      "reference_sentence": "",
      "line_num": 287,
      "context": "{\"282\":\"```\",\"283\":\"\",\"284\":\"\",\"285\":\"#### 算术运算符\",\"286\":\"\",\"287\":\"一元运算符包括：`-`、`+`、`--`、`++`。\",\"288\":\"\",\"289\":\"二元运算符列举如下：\",\"290\":\"\",\"291\":\"| 运算符| 说明             |\",\"292\":\"| -------- | ------------------------ |\"}",
      "修改建议": "原句含有不必要的修饰成分。",
      "更改后示例": "一元运算符：`-`、`+`、`--`、`++`。",
      "触发条件": "当句子主语后紧跟\"包括\"等列举性动词并直接接项目列表，且上下文已明确表明列举意图时。识别模式为\"主语+包括/包含+冒号/列表项\"结构出现在分类明确的标题下方。"
    },
    {
      "defect_id": 397994,
      "sentence": "3、 执行循环主体的语句。  ",
      "reference_sentence": "",
      "line_num": 431,
      "context": "{\"426\":\"\",\"427\":\"`for`语句的执行流程如下：\",\"428\":\"\",\"429\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"430\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"431\":\"3、 执行循环主体的语句。  \",\"432\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"433\":\"5、 回到步骤2。  \",\"434\":\"\",\"435\":\"示例：\",\"436\":\"\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "3. 执行循环主体。",
      "触发条件": "当句子中的名词（如“循环主体”）已明确指代具体操作对象，且后续补充成分（如“的语句”）未提供新信息时触发。识别模式为“核心名词+冗余限定词”（如“主体+的语句”），且上下文为需简洁的技术步骤描述。"
    },
    {
      "defect_id": 397866,
      "sentence": "`enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。",
      "reference_sentence": "",
      "line_num": 176,
      "context": "{\"171\":\"let names: string[] = ['Alice', 'Bob', 'Carol'];\",\"172\":\"```\",\"173\":\"\",\"174\":\"#### `enum`类型\",\"175\":\"\",\"176\":\"`enum`类型，即枚举类型，是预先定义的一组命名值的值类型，其中命名值又称为枚举常量。\",\"177\":\"使用枚举常量时必须以枚举类型名称为前缀。\",\"178\":\"\",\"179\":\"```typescript\",\"180\":\"enum ColorSet { Red, Green, Blue }\",\"181\":\"let c: ColorSet = ColorSet.Red;\"}",
      "修改建议": "原句含有过多的解释性内容，导致句子过长。",
      "更改后示例": "`enum`类型，即枚举类型，是预先定义的命名值的集合。",
      "触发条件": "同一句子中重复使用同义术语（如\"命名值\"与\"枚举常量\"）或对同一概念进行二次解释（如\"值类型\"与\"集合\"的重复定义），且导致信息密度降低时触发。\n\n识别模式：\n1. 存在显性重复标记：通过\"即\"\"又称为\"等连接词引入同义表达\n2. 双重定义结构：核心术语被连续两次不同表述重复解释（如原句先定义\"一组命名值的值类型\"，再补充\"命名值称为枚举常量\"）\n3. 上下文冗余：当后续段落已包含相关解释时（如后文178行已说明枚举常量用法），前置定义可简化"
    },
    {
      "defect_id": 397997,
      "sentence": "使用`for-of`语句可遍历数组、Set、Map、字符串等可迭代的类型。示例如下：",
      "reference_sentence": "",
      "line_num": 446,
      "context": "{\"441\":\"}\",\"442\":\"```\",\"443\":\"\",\"444\":\"#### `For-of`语句\",\"445\":\"\",\"446\":\"使用`for-of`语句可遍历数组、Set、Map、字符串等可迭代的类型。示例如下：\",\"447\":\"\",\"448\":\"```typescript\",\"449\":\"for (forVar of IterableExpression) {\",\"450\":\"  // process forVar\",\"451\":\"}\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`for-of`语句遍历可迭代类型。",
      "触发条件": "句子中列举多个具体实例（如数组、Set、Map等）后，使用总称术语（如\"可迭代类型\"）进行概括，且实例与总称存在语义重复。  \n\n识别模式：  \n1. 存在\"等\"字连接具体实例与总称（如\"数组、Set、Map等可迭代类型\"）  \n2. 具体实例可被总称完全覆盖（如数组/Set/Map均属于可迭代类型）  \n3. 保留总称即可完整传达语义，无需通过示例补充说明"
    },
    {
      "defect_id": 397989,
      "sentence": "条件表达式根据第一个表达式的布尔值来返回其他两个表达式之一。",
      "reference_sentence": "",
      "line_num": 386,
      "context": "{\"381\":\"\",\"382\":\"如果没有`break`语句，则执行`switch`中的下一个label对应的代码块。\",\"383\":\"\",\"384\":\"#### 条件表达式\",\"385\":\"\",\"386\":\"条件表达式根据第一个表达式的布尔值来返回其他两个表达式之一。\",\"387\":\"\",\"388\":\"示例如下：\",\"389\":\"\",\"390\":\"```typescript\",\"391\":\"condition ? expression1 : expression2\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "条件表达式根据布尔值返回其他表达式。",
      "触发条件": "当句子中同时存在\"布尔值\"的显性来源描述（如\"第一个表达式\"）和返回值描述（如\"返回其他两个表达式之一\"），且该布尔值来源在上下文语境中已隐含明确时。\n\n识别模式：\n1. 存在\"表达式A的布尔值\"类冗余结构（可简化为\"布尔值\"）\n2. 包含显式的数量限定词（如\"两个表达式之一\"），而该数量关系在语法结构中已自解释\n3. 动词短语（如\"返回\"）的受词存在可推断的上下文信息时仍被显式重复说明"
    },
    {
      "defect_id": 397995,
      "sentence": "4、 如果有`update`表达式，则执行该表达式。  ",
      "reference_sentence": "",
      "line_num": 432,
      "context": "{\"427\":\"`for`语句的执行流程如下：\",\"428\":\"\",\"429\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"430\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"431\":\"3、 执行循环主体的语句。  \",\"432\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"433\":\"5、 回到步骤2。  \",\"434\":\"\",\"435\":\"示例：\",\"436\":\"\",\"437\":\"```typescript\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "4. 执行`update`表达式。",
      "触发条件": "当步骤描述中存在显式条件分句（如\"如果有X\"），但该条件已被上下文或流程逻辑隐含时，触发冗余表达规则。识别模式为：检查步骤是否包含\"如果\"类条件状语，同时结合上下文判断该条件是否为前置步骤已处理或流程本身的组成部分。"
    },
    {
      "defect_id": 398000,
      "sentence": "使用`break`语句可以终止循环语句或`switch`。",
      "reference_sentence": "",
      "line_num": 504,
      "context": "{\"499\":\"} while (i < 10)\",\"500\":\"```\",\"501\":\"\",\"502\":\"#### `Break`语句\",\"503\":\"\",\"504\":\"使用`break`语句可以终止循环语句或`switch`。\",\"505\":\"\",\"506\":\"示例：\",\"507\":\"\",\"508\":\"```typescript\",\"509\":\"let x = 0;\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`break`语句终止循环或`switch`。",
      "触发条件": "句子中包含冗余助动词（如\"可以\"）或重复性名词修饰（如\"循环语句\"中的\"语句\"），且删除后不影响技术准确性时触发。\n\n识别模式：1）检测\"可以/能够\"等非必要情态动词与功能描述动词的共现 2）匹配\"XX+语句\"类复合名词中重复的上下文隐含信息（如\"循环\"已隐含\"语句\"属性）"
    },
    {
      "defect_id": 397985,
      "sentence": "如果`switch`表达式的值等于某个label的值，则执行相应的语句。",
      "reference_sentence": "",
      "line_num": 376,
      "context": "{\"371\":\"  default:\",\"372\":\"    // 默认语句\",\"373\":\"}\",\"374\":\"```\",\"375\":\"\",\"376\":\"如果`switch`表达式的值等于某个label的值，则执行相应的语句。\",\"377\":\"\",\"378\":\"如果没有任何一个label值与表达式值相匹配，并且`switch`具有`default`子句，那么程序会执行`default`子句对应的代码块。\",\"379\":\"\",\"380\":\"`break`语句（可选的）允许跳出`switch`语句并继续执行`switch`语句之后的语句。\",\"381\":\"\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "如果`switch`表达式值等于label值，则执行相应语句。",
      "触发条件": "当句子中连续出现多个冗余的“的”字结构（如“X的值等于Y的值”），且去除后不影响语义时触发。\n\n识别模式：检测名词短语中重复的“的”字搭配（如“表达式的值”“label的值”），当存在可合并简化的同构表达（如可优化为“表达式值”“label值”）且上下文保持清晰时，判定为冗余表达。"
    },
    {
      "defect_id": 397986,
      "sentence": "如果没有任何一个label值与表达式值相匹配，并且`switch`具有`default`子句，那么程序会执行`default`子句对应的代码块。",
      "reference_sentence": "",
      "line_num": 378,
      "context": "{\"373\":\"}\",\"374\":\"```\",\"375\":\"\",\"376\":\"如果`switch`表达式的值等于某个label的值，则执行相应的语句。\",\"377\":\"\",\"378\":\"如果没有任何一个label值与表达式值相匹配，并且`switch`具有`default`子句，那么程序会执行`default`子句对应的代码块。\",\"379\":\"\",\"380\":\"`break`语句（可选的）允许跳出`switch`语句并继续执行`switch`语句之后的语句。\",\"381\":\"\",\"382\":\"如果没有`break`语句，则执行`switch`中的下一个label对应的代码块。\",\"383\":\"\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "如果`switch`没有匹配label且有`default`子句，则执行`default`代码块。",
      "触发条件": "当句子中存在用否定条件+补充说明描述同一概念时，或存在可被合并的冗余逻辑结构（如\"并且...具有\"对应\"且...有\"）时触发。\n\n识别模式：\n1. 否定条件+并列结构：查找\"如果没有任何...，并且...具有...\"结构\n2. 存在可替代的简洁术语：如\"没有匹配label\"可替代\"没有任何一个label值与表达式值相匹配\"\n3. 重复说明现象：前文已定义过匹配机制（如上下文376行），后续重复解释匹配逻辑则构成冗余"
    },
    {
      "defect_id": 398002,
      "sentence": "`continue`语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。",
      "reference_sentence": "",
      "line_num": 535,
      "context": "{\"530\":\"}\",\"531\":\"```\",\"532\":\"\",\"533\":\"#### `Continue`语句\",\"534\":\"\",\"535\":\"`continue`语句会停止当前循环迭代的执行，并将控制传递给下一个迭代。\",\"536\":\"\",\"537\":\"示例：\",\"538\":\"\",\"539\":\"```typescript\",\"540\":\"let sum = 0;\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`continue`语句停止当前迭代并传递控制。",
      "触发条件": "句子中出现可合并的重复术语（如\"循环迭代\"中的循环上下文冗余），或存在冗长短语（如\"停止...的执行\"）时触发。通过识别名词前重复的领域限定词（如\"循环\"迭代）和动词后冗余的动作描述（如\"的执行\"）进行判断。"
    },
    {
      "defect_id": 397981,
      "sentence": "`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。",
      "reference_sentence": "",
      "line_num": 323,
      "context": "{\"318\":\"\",\"319\":\"### 语句\",\"320\":\"\",\"321\":\"#### `If`语句\",\"322\":\"\",\"323\":\"`if`语句用于需要根据逻辑条件执行不同语句的场景。当逻辑条件为真时，执行对应的一组语句，否则执行另一组语句（如果有的话）。\",\"324\":\"`else`部分也可能包含`if`语句。\",\"325\":\"\",\"326\":\"`if`语句如下所示：\",\"327\":\"\",\"328\":\"```typescript\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`if`语句根据逻辑条件执行不同语句。",
      "触发条件": "当句子中同时包含基础功能定义+具体执行流程的重复说明，或在基础语法解释中重复使用\"当...时/否则\"等条件状语从句时触发。\n\n识别模式：通过检测以下组合模式进行识别：\n1. 主句已包含\"根据条件执行不同语句\"的核心功能描述\n2. 后续分句又详细展开\"当条件为真时...否则...\"的具体执行机制\n3. 上下文处于基础语法定义段落(非具体用法示例或高级特性说明)"
    },
    {
      "defect_id": 398001,
      "sentence": "如果`break`语句后带有标识符，则将控制流转移到该标识符所包含的语句块之外。",
      "reference_sentence": "",
      "line_num": 518,
      "context": "{\"513\":\"    break;\",\"514\":\"  }\",\"515\":\"}\",\"516\":\"```\",\"517\":\"\",\"518\":\"如果`break`语句后带有标识符，则将控制流转移到该标识符所包含的语句块之外。\",\"519\":\"\",\"520\":\"示例：\",\"521\":\"\",\"522\":\"```typescript\",\"523\":\"let x = 1;\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "带标识符的`break`语句转移控制流。",
      "触发条件": "当句子使用\"如果A，则B\"的条件结构，且B是A的直接结果时；或存在可合并的重复解释（如\"该标识符所包含的语句块之外\"可简化为\"转移控制流\"）时触发。"
    },
    {
      "defect_id": 398070,
      "sentence": "在以下示例中，setter用于禁止将`_age`属性设置为无效值：",
      "reference_sentence": "",
      "line_num": 968,
      "context": "{\"963\":\"\",\"964\":\"#### getter和setter\",\"965\":\"\",\"966\":\"setter和getter可用于提供对对象属性的受控访问。\",\"967\":\"\",\"968\":\"在以下示例中，setter用于禁止将`_age`属性设置为无效值：\",\"969\":\"\",\"970\":\"```typescript\",\"971\":\"class Person {\",\"972\":\"  name: string = '';\",\"973\":\"  private _age: number = 0;\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "在以下示例中，setter禁止将`_age`属性设置为无效值。",
      "触发条件": "当句子中出现\"用于\"+\"动词\"结构（如\"用于禁止\"），且该动词本身已完整表达动作含义时，触发冗余表达规则。识别模式为\"用于\"+动词短语的句式，其中动词短语可独立承担语义（如\"禁止设置无效值\"），此时\"用于\"构成冗余介词结构。"
    },
    {
      "defect_id": 398003,
      "sentence": "下面的示例中`throw`和`try`语句用于处理除数为0的错误：",
      "reference_sentence": "",
      "line_num": 567,
      "context": "{\"562\":\"} catch (e) {\",\"563\":\"  // 异常处理\",\"564\":\"}\",\"565\":\"```\",\"566\":\"\",\"567\":\"下面的示例中`throw`和`try`语句用于处理除数为0的错误：\",\"568\":\"\",\"569\":\"```typescript\",\"570\":\"class ZeroDivisor extends Error {}\",\"571\":\"\",\"572\":\"function divide (a: number, b: number): number{\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "`throw`和`try`语句处理除数为0的错误。",
      "触发条件": "句子中存在冗余的引导词（如\"下面的示例中\"）或重复性动作描述（如\"用于处理\"），且上下文已明确提供示例/动作对象时触发。\n\n识别模式：\n1. 检测到引导词组合（如\"下面的示例中\"+\"用于\"）且后接具体技术内容\n2. 动作描述存在双重动词结构（如\"用于处理\"可简化为\"处理\"）\n3. 上下文已包含代码示例/技术实现（如问题上下文中的代码块）时仍重复说明示例用途"
    },
    {
      "defect_id": 398015,
      "sentence": "函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。",
      "reference_sentence": "",
      "line_num": 696,
      "context": "{\"691\":\"function hi2(): void { console.log('hi'); }\",\"692\":\"```\",\"693\":\"\",\"694\":\"### 函数的作用域\",\"695\":\"\",\"696\":\"函数中定义的变量和其他实例仅可以在函数内部访问，不能从外部访问。\",\"697\":\"\",\"698\":\"如果函数中定义的变量与外部作用域中已有实例同名，则函数内的局部变量定义将覆盖外部定义。\",\"699\":\"\",\"700\":\"```typescript\",\"701\":\"let outerVar = 'I am outer ';\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "函数中定义的变量仅在内部访问。",
      "触发条件": "当句子中同时出现\"变量和其他实例\"的同义重复表述，或后半句使用否定式（不能从外部访问）重复说明前半句肯定式（仅在内部访问）的语义时。"
    },
    {
      "defect_id": 398066,
      "sentence": "以下代码是在ArkTS中不合法的代码。",
      "reference_sentence": "",
      "line_num": 891,
      "context": "{\"886\":\"#### 字段初始化\",\"887\":\"\",\"888\":\"为了减少运行时错误并提高执行性能，\",\"889\":\"ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的`strictPropertyInitialization`模式一样。\",\"890\":\"\",\"891\":\"以下代码是在ArkTS中不合法的代码。\",\"892\":\"\",\"893\":\"```typescript\",\"894\":\"class Person {\",\"895\":\"  name: string; // undefined\",\"896\":\"  \"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "以下代码在ArkTS中不合法。",
      "触发条件": "当句子中出现冗余的“是...的”强调结构（例如“是在...中不合法的代码”），且该结构未增加必要语义时触发；或当介词短语（如“在ArkTS中”）与核心表意成分（如“不合法”）之间存在冗余助词/系动词（如“是”“的”）时触发。"
    },
    {
      "defect_id": 398006,
      "sentence": "1.参数类型标注：x: string, y: string 显式声明参数类型为字符串。",
      "reference_sentence": "",
      "line_num": 620,
      "context": "{\"615\":\"\",\"616\":\"函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。\",\"617\":\"\",\"618\":\"以下示例是一个简单的函数和它的语法语义说明：\",\"619\":\"\",\"620\":\"1.参数类型标注：x: string, y: string 显式声明参数类型为字符串。\",\"621\":\"\",\"622\":\"2.返回值类型：: string 指定函数返回值为字符串类型。\",\"623\":\"\",\"624\":\"```typescript\",\"625\":\"function add(x: string, y: string): string {\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "1. 参数类型标注：x: string, y: string。",
      "触发条件": "当文档中存在同时用代码示例和文字重复说明同一类型声明时触发，特别是当文字解释冗余地复述代码中已显式标注的类型信息（如\"显式声明参数类型为字符串\"）。识别模式为：代码段已包含明确类型标注（如x: string），且相邻文字描述仍以\"显式声明/指定...类型\"句式重复该信息。"
    },
    {
      "defect_id": 398061,
      "sentence": "闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。",
      "reference_sentence": "",
      "line_num": 766,
      "context": "{\"761\":\"let sum2 = (x: number, y: number) => x + y\",\"762\":\"```\",\"763\":\"\",\"764\":\"### 闭包\",\"765\":\"\",\"766\":\"闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。\",\"767\":\"\",\"768\":\"在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。\",\"769\":\"\",\"770\":\"```typescript\",\"771\":\"function f(): () => number {\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "闭包由函数及声明该函数的环境组合而成，环境包含闭包创建时作用域内的局部变量。",
      "触发条件": "同一上下文或相邻句子中重复使用指示代词（如\"该\"）指代前文已明确的主语，或使用冗余限定词（如\"任何\"）且未增加有效语义时。"
    },
    {
      "defect_id": 398072,
      "sentence": "包含`implements`子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。",
      "reference_sentence": "",
      "line_num": 1070,
      "context": "{\"1065\":\"    return this.salary * 0.42;\",\"1066\":\"  }\",\"1067\":\"}\",\"1068\":\"```\",\"1069\":\"\",\"1070\":\"包含`implements`子句的类必须实现列出的接口中定义的所有方法，但使用默认实现定义的方法除外。\",\"1071\":\"\",\"1072\":\"```typescript\",\"1073\":\"interface DateInterface {\",\"1074\":\"  now(): string;\",\"1075\":\"}\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "包含`implements`子句的类必须实现列出的接口中定义的所有方法，但默认实现的方法除外。",
      "触发条件": "当句子中出现\"定义的方法\"前存在冗余修饰语（如\"使用默认实现定义\"），且存在更简洁的同义表达（如\"默认实现\"）时触发。识别模式为检测\"定义的方法\"前是否包含可省略的动词短语（如\"使用...实现\"），这类结构通常包含重复语义（定义+实现）。"
    },
    {
      "defect_id": 398067,
      "sentence": "在ArkTS中，应该这样写代码。",
      "reference_sentence": "",
      "line_num": 913,
      "context": "{\"908\":\"let jack = new Person();\",\"909\":\"// 假设代码中没有对name赋值，即没有调用\\\"jack.setName('Jack')\\\"\",\"910\":\"jack.getName().length; // 运行时异常：name is undefined\",\"911\":\"```\",\"912\":\"\",\"913\":\"在ArkTS中，应该这样写代码。\",\"914\":\"\",\"915\":\"```typescript\",\"916\":\"class Person {\",\"917\":\"  name: string = '';\",\"918\":\"  \"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "在ArkTS中，应这样写代码。",
      "触发条件": "句子中存在冗余的双字副词（如“应该”）可替换为更简洁的单字词（如“应”），且上下文属于技术规范或操作指引类内容。"
    },
    {
      "defect_id": 398059,
      "sentence": "函数可以定义为箭头函数，例如：",
      "reference_sentence": "",
      "line_num": 747,
      "context": "{\"742\":\"do_action(Math.sin); // 将函数作为参数传入\",\"743\":\"```\",\"744\":\"\",\"745\":\"### 箭头函数（又名Lambda函数）\",\"746\":\"\",\"747\":\"函数可以定义为箭头函数，例如：\",\"748\":\"\",\"749\":\"```typescript\",\"750\":\"let sum = (x: number, y: number): number => {\",\"751\":\"  return x + y;\",\"752\":\"}\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "函数可以定义为箭头函数。",
      "触发条件": "句子末尾包含举例性短语（如“例如：”），且上下文已通过代码块/列表等明确展示示例时触发。\n\n识别模式：通过句尾标点（如冒号）和举例关键词（如“例如”）定位冗余提示，结合后续代码块/列表等结构化示例内容，判定文字描述与可视化示例存在重复引导。"
    },
    {
      "defect_id": 398007,
      "sentence": "2.返回值类型：: string 指定函数返回值为字符串类型。",
      "reference_sentence": "",
      "line_num": 622,
      "context": "{\"617\":\"\",\"618\":\"以下示例是一个简单的函数和它的语法语义说明：\",\"619\":\"\",\"620\":\"1.参数类型标注：x: string, y: string 显式声明参数类型为字符串。\",\"621\":\"\",\"622\":\"2.返回值类型：: string 指定函数返回值为字符串类型。\",\"623\":\"\",\"624\":\"```typescript\",\"625\":\"function add(x: string, y: string): string {\",\"626\":\"  let z: string = `${x} ${y}`;\",\"627\":\"  return z;\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "2. 返回值类型：: string。",
      "触发条件": "当文档条目中同时包含语法元素（如类型标注）和重复的自然语言解释时触发，即冒号后的语法声明与后续文字内容存在语义重复。  \n\n识别模式：检查是否存在\"语法标注 + 自然语言复述\"结构（例如 \": string 指定...字符串类型\"），若后半句仅重复前半句的语法含义且无新增信息，则判定为冗余表达。"
    },
    {
      "defect_id": 398064,
      "sentence": "不允许重载函数有相同的名字和参数列表，否则将导致编译错误。",
      "reference_sentence": "",
      "line_num": 796,
      "context": "{\"791\":\"\",\"792\":\"foo(123);     //  OK，使用第一个定义\",\"793\":\"foo('aa'); // OK，使用第二个定义\",\"794\":\"```\",\"795\":\"\",\"796\":\"不允许重载函数有相同的名字和参数列表，否则将导致编译错误。\",\"797\":\"\",\"798\":\"## 类\",\"799\":\"\",\"800\":\"类声明引入一个新类型，并定义其字段、方法和构造函数。\",\"801\":\"\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "不允许重载函数有相同的名字和参数列表，否则编译错误。",
      "触发条件": "当句子中存在\"否则将导致\"类冗余因果结构，且后续结果可直接作为名词短语独立表意时。识别模式为包含\"否则+将导致/会引起\"等冗余引导词，其后紧跟可独立表达完整结果的名词性成分（如\"编译错误\"）。"
    },
    {
      "defect_id": 398009,
      "sentence": "可选参数的格式可为`name?: Type`。",
      "reference_sentence": "",
      "line_num": 635,
      "context": "{\"630\":\"\",\"631\":\"在函数声明中，必须为每个参数标记类型。如果参数为可选参数，那么允许在调用函数时省略该参数。函数的最后一个参数可以是rest参数。\",\"632\":\"\",\"633\":\"### 可选参数\",\"634\":\"\",\"635\":\"可选参数的格式可为`name?: Type`。\",\"636\":\"\",\"637\":\"```typescript\",\"638\":\"function hello(name?: string) {\",\"639\":\"  if (name == undefined) {\",\"640\":\"    console.log('Hello!');\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "可选参数格式为`name?: Type`。",
      "触发条件": "当句子在描述固定语法格式时，使用\"可为/可以\"等冗余可能性助动词，且上下文已明确规范要求的情况下触发。\n\n识别模式：检查技术规范类文本中是否存在\"可(为)\"+\"格式为...\"的冗余结构（如\"格式可为X\"→\"格式为X\"），重点捕捉\"可为\"与格式描述共现的句式，同时排除真正需要表达可选性的场景（如参数本身是否可选）。"
    },
    {
      "defect_id": 398013,
      "sentence": "不需要返回值的函数的返回类型可以显式指定为`void`或省略标注。这类函数不需要返回语句。",
      "reference_sentence": "",
      "line_num": 685,
      "context": "{\"680\":\"\",\"681\":\"// 推断返回类型为string\",\"682\":\"function goo() { return 'goo'; }\",\"683\":\"```\",\"684\":\"\",\"685\":\"不需要返回值的函数的返回类型可以显式指定为`void`或省略标注。这类函数不需要返回语句。\",\"686\":\"\",\"687\":\"以下示例中两种函数声明方式都是有效的：\",\"688\":\"\",\"689\":\"```typescript\",\"690\":\"function hi1() { console.log('hi'); }\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "不需要返回值的函数可以显式指定为`void`或省略标注。",
      "触发条件": "文档在说明无返回值函数的返回类型标注方式时，额外提及\"不需要返回语句\"等与类型标注无关的冗余描述，且该描述不属于当前规则检查范围。"
    },
    {
      "defect_id": 398004,
      "sentence": "函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。",
      "reference_sentence": "",
      "line_num": 616,
      "context": "{\"611\":\"\",\"612\":\"## 函数\",\"613\":\"\",\"614\":\"### 函数声明\",\"615\":\"\",\"616\":\"函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。\",\"617\":\"\",\"618\":\"以下示例是一个简单的函数和它的语法语义说明：\",\"619\":\"\",\"620\":\"1.参数类型标注：x: string, y: string 显式声明参数类型为字符串。\",\"621\":\"\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "函数声明包含名称、参数列表、返回类型和函数体。",
      "触发条件": "当句子的主语(专有名词/术语)本身已明确表达核心动作，且后续动词短语重复说明该动作时触发。具体表现为\"主体+动词短语\"结构中，动词短语内容与主体功能存在语义重叠(如\"函数声明引入函数\"中\"声明\"已隐含\"引入\"含义)。"
    },
    {
      "defect_id": 398010,
      "sentence": "可选参数的另一种形式为设置的参数默认值。如果在函数调用中这个参数被省略了，则会使用此参数的默认值作为实参。",
      "reference_sentence": "",
      "line_num": 647,
      "context": "{\"642\":\"    console.log(`Hello, ${name}!`);\",\"643\":\"  }\",\"644\":\"}\",\"645\":\"```\",\"646\":\"\",\"647\":\"可选参数的另一种形式为设置的参数默认值。如果在函数调用中这个参数被省略了，则会使用此参数的默认值作为实参。\",\"648\":\"\",\"649\":\"```typescript\",\"650\":\"function multiply(n: number, coeff: number = 2): number {\",\"651\":\"  return n * coeff;\",\"652\":\"}\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "可选参数可以设置默认值。",
      "触发条件": "当同一技术概念（如参数默认值）在相邻句子中被重复解释，且后续描述未提供新信息或必要细节时触发，需识别连续重复的关键词（如“默认值”、“省略”）及冗余说明结构。"
    },
    {
      "defect_id": 398063,
      "sentence": "可以通过编写重载，指定函数的不同调用方式。具体方法是，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。",
      "reference_sentence": "",
      "line_num": 784,
      "context": "{\"779\":\"z(); // 返回：2\",\"780\":\"```\",\"781\":\"\",\"782\":\"### 函数重载\",\"783\":\"\",\"784\":\"可以通过编写重载，指定函数的不同调用方式。具体方法是，为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。\",\"785\":\"\",\"786\":\"```typescript\",\"787\":\"function foo(x: number): void;            /* 第一个函数定义 */\",\"788\":\"function foo(x: string): void;            /* 第二个函数定义 */\",\"789\":\"function foo(x: number | string): void {  /* 函数实现 */\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "通过编写重载，指定函数的不同调用方式。为同一个函数写入多个同名但签名不同的函数头，函数实现紧随其后。",
      "触发条件": "当连续两个句子存在\"总述+具体说明\"结构，且后续句子出现冗余引导词（如\"具体方法是\"）时触发；或当相邻语句使用重复性过渡短语且后句未提供新信息时触发\n\n识别模式：检查是否存在\"总起句+具体步骤\"结构中重复使用引导词的情况，重点捕捉\"具体来说\"\"具体方法是\"等冗余过渡词，同时验证后句是否真正需要这类连接词来维持语义连贯"
    },
    {
      "defect_id": 398017,
      "sentence": "调用函数以执行其函数体，实参值会赋值给函数的形参。",
      "reference_sentence": "",
      "line_num": 713,
      "context": "{\"708\":\"func();\",\"709\":\"```\",\"710\":\"\",\"711\":\"### 函数调用\",\"712\":\"\",\"713\":\"调用函数以执行其函数体，实参值会赋值给函数的形参。\",\"714\":\"\",\"715\":\"如果函数定义如下：\",\"716\":\"\",\"717\":\"```typescript\",\"718\":\"function join(x: string, y: string): string {\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "调用函数执行其函数体，实参赋值给形参。",
      "触发条件": "当句子中存在冗余介词（如\"以\"连接动词短语）或重复语义成分（如\"值\"在已明确指代数值的上下文中，\"函数的\"在已明确讨论函数参数的语境中）时触发。\n\n识别模式：1) 检查\"以+动词\"结构是否可简化为直接连动（如\"调用函数以执行\"→\"调用函数执行\"） 2) 验证名词修饰语是否与上下文存在重复指代（如\"实参值\"在参数传递语境中\"值\"冗余，\"函数的形参\"在函数调用上下文中\"函数的\"冗余）"
    },
    {
      "defect_id": 398012,
      "sentence": "如果可以从函数体内推断出函数返回类型，则可在函数声明中省略标注返回类型。",
      "reference_sentence": "",
      "line_num": 675,
      "context": "{\"670\":\"sum(1, 2, 3); // 返回6\",\"671\":\"```\",\"672\":\"\",\"673\":\"### 返回类型\",\"674\":\"\",\"675\":\"如果可以从函数体内推断出函数返回类型，则可在函数声明中省略标注返回类型。\",\"676\":\"\",\"677\":\"```typescript\",\"678\":\"// 显式指定返回类型\",\"679\":\"function foo(): string { return 'foo'; }\",\"680\":\"\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "如果可以从函数体推断返回类型，则省略标注。",
      "触发条件": "当文本在解释类型推断时，同时出现\"函数体\"和\"函数声明中\"的重复上下文，且包含冗余动词（如\"标注\"）时触发。识别模式需检测是否存在可合并的上下文描述（如\"函数体内推断出...函数声明中省略标注\"）及冗余动作词（如\"标注\"对应已隐含的\"返回类型\"）。"
    },
    {
      "defect_id": 398005,
      "sentence": "以下示例是一个简单的函数和它的语法语义说明：",
      "reference_sentence": "",
      "line_num": 618,
      "context": "{\"613\":\"\",\"614\":\"### 函数声明\",\"615\":\"\",\"616\":\"函数声明引入一个函数，包含其名称、参数列表、返回类型和函数体。\",\"617\":\"\",\"618\":\"以下示例是一个简单的函数和它的语法语义说明：\",\"619\":\"\",\"620\":\"1.参数类型标注：x: string, y: string 显式声明参数类型为字符串。\",\"621\":\"\",\"622\":\"2.返回值类型：: string 指定函数返回值为字符串类型。\",\"623\":\"\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "以下示例是一个简单的函数及其语法说明：",
      "触发条件": "当句子中同时出现\"语法\"和\"语义\"的并列说明，且在上下文不要求区分二者时；或存在\"和它的\"等冗长表达可被\"及其\"替代时。\n\n识别模式：\n1. 检测并列结构中的\"语法语义\"组合，结合上下文判断是否属于重复说明（如示例中函数基础声明只需语法说明）\n2. 捕捉\"和它的\"类表达，比对是否可用更简洁的\"及其\"替代（通过词性分析识别名词短语间的连接关系）\n3. 验证术语必要性：当\"语义\"未在后续内容具体展开说明时，判定为冗余修饰词"
    },
    {
      "defect_id": 398069,
      "sentence": "setter和getter可用于提供对对象属性的受控访问。",
      "reference_sentence": "",
      "line_num": 966,
      "context": "{\"961\":\"jack.getName()?.length; // 编译成功，没有运行时错误\",\"962\":\"```\",\"963\":\"\",\"964\":\"#### getter和setter\",\"965\":\"\",\"966\":\"setter和getter可用于提供对对象属性的受控访问。\",\"967\":\"\",\"968\":\"在以下示例中，setter用于禁止将`_age`属性设置为无效值：\",\"969\":\"\",\"970\":\"```typescript\",\"971\":\"class Person {\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "setter和getter提供对对象属性的受控访问。",
      "触发条件": "句子中包含\"可+用于\"或类似表示可能性的冗余结构（如\"可以用于\"\"能够用于\"），且上下文已明确表达功能用途时触发。具体识别模式为存在\"可/可以/能够\"与\"用于/用于提供\"等动词短语的重复表达能力，其中助动词不增加新信息且可删除。"
    },
    {
      "defect_id": 398018,
      "sentence": "则此函数的调用需要包含两个`string`类型的参数：",
      "reference_sentence": "",
      "line_num": 724,
      "context": "{\"719\":\"  let z: string = `${x} ${y}`;\",\"720\":\"  return z;\",\"721\":\"}\",\"722\":\"```\",\"723\":\"\",\"724\":\"则此函数的调用需要包含两个`string`类型的参数：\",\"725\":\"\",\"726\":\"```typescript\",\"727\":\"let x = join('hello', 'world');\",\"728\":\"console.log(x); // 输出: hello world\",\"729\":\"```\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "此函数调用需要两个`string`参数。",
      "触发条件": "当句子中同时出现\"包含\"、\"包括\"等冗余动词与数量描述，或在类型名称后添加冗余的\"类型的\"定语结构时触发。\n\n识别模式：\n1. 检测\"包含/包括/需要包含\"等动词与数量词（如两个、三个）的连续使用\n2. 识别类型声明后的冗余定语结构（如`string`类型的参数 → `string`参数）\n3. 验证是否在说明编程接口的参数要求场景（常见于API文档、代码注释等技术文档）"
    },
    {
      "defect_id": 398011,
      "sentence": "函数的最后一个参数可以是rest参数。rest参数的格式为`...restArgs`。rest参数允许函数接收一个由剩余实参组成的数组，类型为任意指定类型，用于处理不定数量的参数输入。",
      "reference_sentence": "",
      "line_num": 659,
      "context": "{\"654\":\"multiply(2, 3); // 返回2*3\",\"655\":\"```\",\"656\":\"\",\"657\":\"### Rest参数\",\"658\":\"\",\"659\":\"函数的最后一个参数可以是rest参数。rest参数的格式为`...restArgs`。rest参数允许函数接收一个由剩余实参组成的数组，类型为任意指定类型，用于处理不定数量的参数输入。\",\"660\":\"\",\"661\":\"```typescript\",\"662\":\"function sum(...numbers: number[]): number {\",\"663\":\"  let res = 0;\",\"664\":\"  for (let n of numbers)\"}",
      "修改建议": "原文过于啰嗦，应简化",
      "更改后示例": "函数的最后一个参数可以是rest参数，格式为`...restArgs`。",
      "触发条件": "相邻句子重复使用相同主语或核心短语，且后续重复未提供必要新信息；或上下文已明确概念时仍重复解释其基础功能。"
    },
    {
      "defect_id": 398062,
      "sentence": "在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。",
      "reference_sentence": "",
      "line_num": 768,
      "context": "{\"763\":\"\",\"764\":\"### 闭包\",\"765\":\"\",\"766\":\"闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。\",\"767\":\"\",\"768\":\"在下例中，`f`函数返回了一个闭包，它捕获了`count`变量，每次调用`z`，`count`的值会被保留并递增。\",\"769\":\"\",\"770\":\"```typescript\",\"771\":\"function f(): () => number {\",\"772\":\"  let count = 0;\",\"773\":\"  let g = (): number => { count++; return count; };\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "`f`函数返回闭包，捕获`count`变量，每次调用`z`，`count`值递增。",
      "触发条件": "1)存在可删除的冗余限定词(如量词/助词)而不影响语义完整性；2)包含重复解释上下文已隐含的技术特性(如闭包自动保留变量状态)\n\n识别模式：\n1. 检查\"动词+了+量词+名词\"结构是否可简化为\"动词+名词\"(如\"返回了一个闭包\"→\"返回闭包\")\n2. 识别技术场景下对语言特性的重复说明(如闭包环境中已隐含变量保留机制时，单独说明\"会被保留\"构成冗余)\n3. 发现被动语态描述可转换为更简洁的主动表达(如\"会被保留并递增\"→\"递增\")"
    },
    {
      "defect_id": 398014,
      "sentence": "以下示例中两种函数声明方式都是有效的：",
      "reference_sentence": "",
      "line_num": 687,
      "context": "{\"682\":\"function goo() { return 'goo'; }\",\"683\":\"```\",\"684\":\"\",\"685\":\"不需要返回值的函数的返回类型可以显式指定为`void`或省略标注。这类函数不需要返回语句。\",\"686\":\"\",\"687\":\"以下示例中两种函数声明方式都是有效的：\",\"688\":\"\",\"689\":\"```typescript\",\"690\":\"function hi1() { console.log('hi'); }\",\"691\":\"function hi2(): void { console.log('hi'); }\",\"692\":\"```\"}",
      "修改建议": "无实际问题，但不是需要检查的内容",
      "更改后示例": "以下示例中两种声明方式有效：",
      "触发条件": "当句子中出现重复限定词（如\"函数声明方式\"中的\"函数\"在前文已明确语境）或冗余强调词（如\"都是有效的\"中的\"都是\"未提供新信息）时触发。识别需满足：1) 名词前存在上下文已覆盖的限定词 2) 使用\"都+是\"等强调结构但未增加语义精度。"
    },
    {
      "defect_id": 398073,
      "sentence": "关键字`super`可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：",
      "reference_sentence": "",
      "line_num": 1086,
      "context": "{\"1081\":\"}\",\"1082\":\"```\",\"1083\":\"\",\"1084\":\"#### 父类访问\",\"1085\":\"\",\"1086\":\"关键字`super`可用于访问父类的实例字段、实例方法和构造函数。在实现子类功能时，可以通过该关键字从父类中获取所需接口：\",\"1087\":\"\",\"1088\":\"```typescript\",\"1089\":\"class RectangleSize {\",\"1090\":\"  protected height: number = 0;\",\"1091\":\"  protected width: number = 0;\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "关键字`super`访问父类的实例字段、实例方法和构造函数。实现子类功能时，通过`super`从父类获取所需接口。",
      "触发条件": "当句子中存在冗余动词短语（如\"可用于\"）或重复指代（如\"该关键字\"），且上下文已明确操作主体时触发。\n\n识别模式：1) 检查\"可(用于/通过)\"等助动词是否冗余 2) 识别代词指代前文已明确的技术术语（如用\"该关键字\"指代前文出现的`super`）3) 验证删除冗余成分后是否保持技术准确性"
    },
    {
      "defect_id": 398075,
      "sentence": "如果两个重载签名的名称和参数列表均相同，则为错误。",
      "reference_sentence": "",
      "line_num": 1211,
      "context": "{\"1206\":\"}\",\"1207\":\"let c1 = new C(123);      // OK，使用第一个签名\",\"1208\":\"let c2 = new C('abc');    // OK，使用第二个签名\",\"1209\":\"```\",\"1210\":\"\",\"1211\":\"如果两个重载签名的名称和参数列表均相同，则为错误。\",\"1212\":\"\",\"1213\":\"### 可见性修饰符\",\"1214\":\"\",\"1215\":\"类的方法和属性都可以使用可见性修饰符。\",\"1216\":\"\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "如果两个重载签名的名称和参数列表相同，则错误。",
      "触发条件": "当句子中存在冗余副词（如“均”）强调所有并列条件，或使用复杂连接词（如“则为”）而非简洁表达时触发。具体表现为在已明确表达“全部条件成立”的并列结构中（如“名称和参数列表”），额外添加强调词或冗余语法结构。"
    },
    {
      "defect_id": 398161,
      "sentence": "接口声明引入新类型。接口是定义代码协定的常见方式。",
      "reference_sentence": "",
      "line_num": 1378,
      "context": "{\"1373\":\"}\",\"1374\":\"```\",\"1375\":\"\",\"1376\":\"## 接口\",\"1377\":\"\",\"1378\":\"接口声明引入新类型。接口是定义代码协定的常见方式。\",\"1379\":\"\",\"1380\":\"任何一个类的实例只要实现了特定接口，就可以通过该接口实现多态。\",\"1381\":\"\",\"1382\":\"接口通常包含属性和方法的声明。\",\"1383\":\"\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "接口声明引入新类型，定义代码协定。",
      "触发条件": "相邻句子重复使用相同主语或核心名词，且后句仅对前句概念进行补充说明时触发。识别模式为连续两句出现重复主语（如\"接口...接口...\"），且后句未新增实质性信息，可通过合并消除重复表述。"
    },
    {
      "defect_id": 398179,
      "sentence": "在函数调用中，类型实参可以显式或隐式设置：",
      "reference_sentence": "",
      "line_num": 1598,
      "context": "{\"1593\":\"}\",\"1594\":\"```\",\"1595\":\"\",\"1596\":\"现在，该函数可以与任何数组一起使用。\",\"1597\":\"\",\"1598\":\"在函数调用中，类型实参可以显式或隐式设置：\",\"1599\":\"\",\"1600\":\"```typescript\",\"1601\":\"// 显式设置的类型实参\",\"1602\":\"let res: string = last<string>(['aa', 'bb']);\",\"1603\":\"let res: number = last<number>([1, 2, 3]);\"}",
      "修改建议": "句子末尾的'：'是多余的，可以省略。",
      "更改后示例": "在函数调用中，类型实参可以显式或隐式设置。",
      "触发条件": "当句子末尾包含冒号但后续内容并非直接关联的列表或解释性文本时触发，特别是当冒号后接独立代码块、分段内容或无明显延续结构时。\n\n识别模式：检查标点符号是否与下文结构匹配，若冒号后存在代码块分隔符（如```）、段落分隔或非延续性内容，则判定为冗余标点。"
    },
    {
      "defect_id": 398158,
      "sentence": "抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：",
      "reference_sentence": "",
      "line_num": 1345,
      "context": "{\"1340\":\"}\",\"1341\":\"\",\"1342\":\"let x = new X(666)  //编译时错误：不能创建抽象类的具体实例\",\"1343\":\"```\",\"1344\":\"\",\"1345\":\"抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化。因此，执行抽象类的构造函数和该类非静态字段的字段初始化器：\",\"1346\":\"\",\"1347\":\"```typescript\",\"1348\":\"abstract class Base {\",\"1349\":\"  field: number;\",\"1350\":\"  constructor(p: number) { \"}",
      "修改建议": "句子末尾的'：'是多余的，可以省略。",
      "更改后示例": "抽象类的子类可以是抽象类也可以是非抽象类。抽象父类的非抽象子类可以实例化，因此执行抽象类的构造函数和该类非静态字段的字段初始化器。",
      "触发条件": "句末存在不必要标点符号（如冒号/分号）且后续内容未形成结构化列表或独立解释块时触发。通过检测段落结尾标点与下文衔接方式（如代码块前无引导性标点）识别冗余符号。"
    },
    {
      "defect_id": 398157,
      "sentence": "尝试创建抽象类的实例会导致编译错误：",
      "reference_sentence": "",
      "line_num": 1332,
      "context": "{\"1327\":\"\",\"1328\":\"### 抽象类 \",\"1329\":\"\",\"1330\":\"带有`abstract`修饰符的类称为抽象类。抽象类可用于表示一组更具体的概念所共有的概念。\",\"1331\":\"\",\"1332\":\"尝试创建抽象类的实例会导致编译错误：\",\"1333\":\"\",\"1334\":\"```typescript\",\"1335\":\"abstract class X {\",\"1336\":\"  field: number;\",\"1337\":\"  constructor(p: number) {\"}",
      "修改建议": "句子末尾的'：'是多余的，可以省略。",
      "更改后示例": "尝试创建抽象类的实例会导致编译错误。",
      "触发条件": "当句子末尾包含冒号但未引出直接解释/示例内容（后续内容被空行或独立代码块分隔时），触发冗余标点规则。"
    },
    {
      "defect_id": 398176,
      "sentence": "编译器在使用泛型类型和函数时会确保类型安全。参见以下示例：",
      "reference_sentence": "",
      "line_num": 1552,
      "context": "{\"1547\":\"```typescript\",\"1548\":\"let s = new CustomStack<string>();\",\"1549\":\"s.push('hello');\",\"1550\":\"```\",\"1551\":\"\",\"1552\":\"编译器在使用泛型类型和函数时会确保类型安全。参见以下示例：\",\"1553\":\"\",\"1554\":\"```typescript\",\"1555\":\"let s = new CustomStack<string>();\",\"1556\":\"s.push(55); // 将会产生编译时错误\",\"1557\":\"```\"}",
      "修改建议": "句子末尾的'参见以下示例：'是多余的，可以省略。",
      "更改后示例": "编译器在使用泛型类型和函数时确保类型安全。",
      "触发条件": "当句子末尾包含引导查看后续示例的冗余短语(如\"参见以下示例：\")，且上下文已直接呈现对应示例时触发。识别模式需检测\"参见\"类引导词与后续代码块/示例的相邻关系。"
    },
    {
      "defect_id": 398152,
      "sentence": "`protected`修饰符的作用与`private`修饰符非常相似，不同点是`protected`修饰的成员允许在派生类中访问，例如：",
      "reference_sentence": "",
      "line_num": 1242,
      "context": "{\"1237\":\"c.y = 'b'; // 编译时错误：'y'不可见\",\"1238\":\"```\",\"1239\":\"\",\"1240\":\"#### Protected（受保护）\",\"1241\":\"\",\"1242\":\"`protected`修饰符的作用与`private`修饰符非常相似，不同点是`protected`修饰的成员允许在派生类中访问，例如：\",\"1243\":\"\",\"1244\":\"```typescript\",\"1245\":\"class Base {\",\"1246\":\"  protected x: string = '';\",\"1247\":\"  private y: string = '';\"}",
      "修改建议": "句子末尾的'例如：'是多余的，可以省略。",
      "更改后示例": "`protected`修饰符的作用与`private`修饰符非常相似，不同点是`protected`修饰的成员允许在派生类中访问。",
      "触发条件": "当句子末尾存在示例引导词（如\"例如：\"）且后续内容直接展示结构化示例（如代码块）时，该引导词因上下文已明确示例关系而冗余。\n\n识别模式：检测句末是否包含示例标记词（如例如/比如/e.g.）后接冒号/换行符，同时下一段落为代码块起始标记（如```）或明确示例结构，即可判定为冗余表达。"
    },
    {
      "defect_id": 398159,
      "sentence": "带有`abstract`修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。",
      "reference_sentence": "",
      "line_num": 1366,
      "context": "{\"1361\":\"let x = new Derived(666);\",\"1362\":\"```\",\"1363\":\"\",\"1364\":\"#### 抽象方法\",\"1365\":\"\",\"1366\":\"带有`abstract`修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。\",\"1367\":\"\",\"1368\":\"只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：\",\"1369\":\"\",\"1370\":\"```typescript\",\"1371\":\"class Y {\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "带有`abstract`修饰符的方法称为抽象方法，不能被实现。",
      "触发条件": "当句子中出现重复性解释（如\"抽象方法\"被重复定义）或存在逻辑隐含的冗余信息（如\"被声明\"已包含在方法定义中）时触发。\n\n识别模式：1) 前后分句存在语义重复（前句定义概念，后句重复说明其基本属性）2) 包含可删除而不影响语义的限定词（如\"可以被声明但\"在抽象方法语境下冗余）"
    },
    {
      "defect_id": 398074,
      "sentence": "如果两个重载签名的名称和参数列表均相同，则为错误。",
      "reference_sentence": "",
      "line_num": 1153,
      "context": "{\"1148\":\"let c = new C();\",\"1149\":\"c.foo(123);     // OK，使用第一个签名\",\"1150\":\"c.foo('aa'); // OK，使用第二个签名\",\"1151\":\"```\",\"1152\":\"\",\"1153\":\"如果两个重载签名的名称和参数列表均相同，则为错误。\",\"1154\":\"\",\"1155\":\"### 构造函数\",\"1156\":\"\",\"1157\":\"类声明可以包含用于初始化对象状态的构造函数。\",\"1158\":\"\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "如果两个重载签名的名称和参数列表相同，则错误。",
      "触发条件": "当句子中在并列结构（如“名称和参数列表”）后出现冗余副词（如“均”），且使用“为错误”等非必要系动词结构时触发。具体表现为“A和B均相同，则为错误”可简化为“A和B相同，则错误”。"
    },
    {
      "defect_id": 398175,
      "sentence": "抽象类可以有构造函数，而接口不能有构造函数。",
      "reference_sentence": "",
      "line_num": 1519,
      "context": "{\"1514\":\"interface MyInterface {\",\"1515\":\"   // 错误：接口完全都是抽象的，不存在方法的实现\",\"1516\":\"   func(): void { console.log(\\\"func\\\");}\",\"1517\":\"}\",\"1518\":\"```\",\"1519\":\"* 抽象类可以有构造函数，而接口不能有构造函数。\",\"1520\":\"```typescript\",\"1521\":\"abstract class MyAbstractClass {\",\"1522\":\"  constructor(){}  // 正确：抽象类可以有构造函数\",\"1523\":\"}\",\"1524\":\"interface MyInterface {\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "抽象类可以有构造函数，接口不能。",
      "触发条件": "当句子使用对比结构（如\"而\"）连接两个分句，且后半分句重复前半分句的宾语/补语成分时触发。\n\n识别模式：检查\"而/X但X\"等对比连词后的分句是否包含与前分句相同的谓语宾语结构（如本例中\"有构造函数\"），若后半分句仅否定性重复前项内容，则保留否定词+主语即可（\"接口不能\"）。"
    },
    {
      "defect_id": 398154,
      "sentence": "对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。",
      "reference_sentence": "",
      "line_num": 1261,
      "context": "{\"1256\":\"\",\"1257\":\"### 对象字面量\",\"1258\":\"\",\"1259\":\"对象字面量是一个表达式，可用于创建类实例并提供一些初始值。它在某些情况下更方便，可以用来代替`new`表达式。\",\"1260\":\"\",\"1261\":\"对象字面量的表示方式是：封闭在花括号对({})中的'属性名：值'的列表。\",\"1262\":\"\",\"1263\":\"```typescript\",\"1264\":\"class C {\",\"1265\":\"  n: number = 0;\",\"1266\":\"  s: string = '';\"}",
      "修改建议": "句子过于冗长，可以简化。",
      "更改后示例": "对象字面量是封闭在花括号对({})中的'属性名：值'列表。",
      "触发条件": "句子中存在可合并或删除的冗余结构（如重复的名词、动词或引导词），导致表达冗余。例如，当“的表示方式是：”这类引导词与后续内容重复时，或“的列表”前存在冗余的“的”字结构时触发。\n\n识别模式：\n1. 检查是否存在“是：”“的方式是：”等引导词与后续内容语义重复。\n2. 观察“的+名词”结构前是否包含冗余修饰（如“封闭在...中的'属性名：值'的列表”中“的列表”与前文“封闭在...”存在语义重叠）。"
    },
    {
      "defect_id": 398177,
      "sentence": "在上面的例子中，`Key`类型扩展了`Hashable`，`Hashable`接口的所有方法都可以为key调用。",
      "reference_sentence": "",
      "line_num": 1575,
      "context": "{\"1570\":\"    // ...其他代码...\",\"1571\":\"  }\",\"1572\":\"}\",\"1573\":\"```\",\"1574\":\"\",\"1575\":\"在上面的例子中，`Key`类型扩展了`Hashable`，`Hashable`接口的所有方法都可以为key调用。\",\"1576\":\"\",\"1577\":\"### 泛型函数\",\"1578\":\"\",\"1579\":\"使用泛型函数可编写更通用的代码。比如返回数组最后一个元素的函数：\",\"1580\":\"\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "`Key`类型扩展了`Hashable`，可以调用`Hashable`接口的所有方法。",
      "触发条件": "当相邻分句或句子中重复使用同一完整名词短语（如`Hashable`接口）指代前文已明确的主体，且该重复未带来新信息时。\n\n识别模式：1) 后句主语与前句宾语/表语完全重复 2) 重复部分可用代词/零回指替代（如改为\"其\"或直接省略）3) 句间存在逻辑承接关系（如因果、顺承）。"
    },
    {
      "defect_id": 398168,
      "sentence": "实现接口的类也可以使用以下两种方式：",
      "reference_sentence": "",
      "line_num": 1438,
      "context": "{\"1433\":\"  get color(): string;\",\"1434\":\"  set color(x: string);\",\"1435\":\"}\",\"1436\":\"```\",\"1437\":\"\",\"1438\":\"实现接口的类也可以使用以下两种方式：\",\"1439\":\"\",\"1440\":\"```typescript\",\"1441\":\"interface Style {\",\"1442\":\"  color: string;\",\"1443\":\"}\"}",
      "修改建议": "句子末尾的'以下两种方式：'是多余的，可以省略。",
      "更改后示例": "实现接口的类可以使用两种方式。",
      "触发条件": "句子末尾包含引导词（如“以下”）+数量词+冒号的冗余结构，且后续内容已明确展示具体方式/示例。\n\n识别模式：检测“以下[数量词]种方式：”、“如下[数量词]种方法：”等句式，并验证冒号后是否存在独立代码块/列表项。若引导词仅重复后续显性内容，则触发冗余规则。"
    },
    {
      "defect_id": 398174,
      "sentence": "抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；",
      "reference_sentence": "",
      "line_num": 1508,
      "context": "{\"1503\":\"\",\"1504\":\"    // 正确：抽象类可以有静态代码块\",\"1505\":\"    static { console.log(\\\"static initialization block\\\");}\",\"1506\":\"}\",\"1507\":\"```\",\"1508\":\"* 抽象类里面可以有方法的实现，但是接口完全都是抽象的，不存在方法的实现；\",\"1509\":\"```typescript\",\"1510\":\"abstract class MyAbstractClass {\",\"1511\":\"   // 正确：抽象类里面可以有方法的实现\",\"1512\":\"   func(): void { console.log(\\\"func\\\");}\",\"1513\":\"}\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "抽象类可以有方法的实现，而接口完全抽象。",
      "触发条件": "当句子中出现冗余方位词（如“里面”）、重复修饰词（如“完全都是”）或冗余否定结构（如“不存在...的实现”）时触发。  \n\n识别模式：  \n1. **冗余方位词**：主谓之间插入非必要的方位词（如“抽象类里面可以有” → 删除“里面”）  \n2. **重复修饰**：副词与形容词语义重复（如“完全都是抽象的” → 保留“完全抽象”）  \n3. **冗余否定**：通过否定句重复已明确表达的含义（如“完全抽象”后无需补充“不存在方法的实现”）。"
    },
    {
      "defect_id": 398151,
      "sentence": "`private`修饰的成员不能在声明该成员的类之外访问，例如：",
      "reference_sentence": "",
      "line_num": 1225,
      "context": "{\"1220\":\"\",\"1221\":\"`public`修饰的类成员（字段、方法、构造函数）在程序的任何可访问该类的地方都是可见的。\",\"1222\":\"\",\"1223\":\"#### Private（私有）\",\"1224\":\"\",\"1225\":\"`private`修饰的成员不能在声明该成员的类之外访问，例如：\",\"1226\":\"\",\"1227\":\"```typescript\",\"1228\":\"class C {\",\"1229\":\"  public x: string = '';\",\"1230\":\"  private y: string = '';\"}",
      "修改建议": "句子末尾的'例如：'是多余的，可以省略。",
      "更改后示例": "`private`修饰的成员不能在声明该成员的类之外访问。",
      "触发条件": "当句子末尾存在示例引导词（如\"例如：\"）但后续内容已通过代码块或分隔符明确展示示例时，该引导词构成冗余表达。\n\n识别模式：检查文本中是否同时满足以下特征：(1) 句子结尾包含示例引导词（如\"例如：\"、\"例如，\"）；(2) 该句子后紧跟空行或代码块标记（如```），且上下文存在独立示例结构。此时引导词与文档排版格式形成语义重复。"
    },
    {
      "defect_id": 398160,
      "sentence": "只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：",
      "reference_sentence": "",
      "line_num": 1368,
      "context": "{\"1363\":\"\",\"1364\":\"#### 抽象方法\",\"1365\":\"\",\"1366\":\"带有`abstract`修饰符的方法称为抽象方法，抽象方法可以被声明但不能被实现。\",\"1367\":\"\",\"1368\":\"只有抽象类内才能有抽象方法，如果非抽象类具有抽象方法，则会发生编译时错误：\",\"1369\":\"\",\"1370\":\"```typescript\",\"1371\":\"class Y {\",\"1372\":\"  abstract method(p: string)  //编译时错误：抽象方法只能在抽象类内。\",\"1373\":\"}\"}",
      "修改建议": "句子末尾的'：'是多余的，可以省略。",
      "更改后示例": "只有抽象类内才能有抽象方法，非抽象类具有抽象方法会导致编译错误。",
      "触发条件": "当句子末尾存在冗余标点符号（如冒号/冒号+换行）且后续内容未直接承接该标点时，或条件句式（\"如果...则...\"）与结果性表达（\"会导致...\"）形成语义重复时触发。\n\n识别模式：\n1. **标点冗余**：检查条件句结尾是否存在孤立标点（如案例中冒号后直接换行而非接具体说明）\n2. **句式冗余**：检测是否同时出现\"如果A，则B\"的条件结构和\"A会导致B\"的因果结构（如原句同时包含\"如果非抽象类...则会发生\"和\"会导致...\"双重表达）"
    },
    {
      "defect_id": 398173,
      "sentence": "接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；",
      "reference_sentence": "",
      "line_num": 1490,
      "context": "{\"1485\":\"// Bird类继承Animal抽象类并实现多个接口CanFly、CanSwim\",\"1486\":\"class Bird extends Animal implements CanFly, CanSwim {\",\"1487\":\"  // ...  \",\"1488\":\"}\",\"1489\":\"```\",\"1490\":\"* 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；\",\"1491\":\"```typescript\",\"1492\":\"interface MyInterface {\",\"1493\":\"    // 错误：接口中不能包含静态成员\",\"1494\":\"    static staticMethod(): void; \",\"1495\":\"\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "接口不能包含静态代码块和静态方法，而抽象类可以。",
      "触发条件": "当句子中存在对比结构（如\"而...\"）且后半部分重复使用前半句已明确提到的相同名词短语（如\"静态代码块和静态方法\"）时触发。\n\n识别模式：检测\"而/但\"等转折词后的分句中，是否重复出现前文完全相同的复合名词（通常伴随冗余助词\"的\"或连接词\"以及\"），且删除重复部分后语义完整性不受影响。"
    },
    {
      "defect_id": 398181,
      "sentence": "应用于可空类型的值时，编译时类型变为非空类型。例如，类型从`T | null`变为`T`：",
      "reference_sentence": "",
      "line_num": 1655,
      "context": "{\"1650\":\"\",\"1651\":\"### 非空断言运算符\",\"1652\":\"\",\"1653\":\"后缀运算符`!`可用于断言其操作数为非空。\",\"1654\":\"\",\"1655\":\"应用于可空类型的值时，编译时类型变为非空类型。例如，类型从`T | null`变为`T`：\",\"1656\":\"\",\"1657\":\"```typescript\",\"1658\":\"class A {\",\"1659\":\"  value: number = 0;\",\"1660\":\"}\"}",
      "修改建议": "句子末尾的'例如，类型从`T | null`变为`T`：'是多余的，可以省略。",
      "更改后示例": "应用于可空类型的值时，编译时类型变为非空类型。",
      "触发条件": "当句子后跟有以\"例如\"引导的补充说明，且该说明仅重复前文核心语义（如将\"可空类型变非空\"具象化为`T | null→T`），而未提供新的具体案例或上下文扩展时触发。通过检测\"例如\"/\"如\"等引导词后的内容是否与前文形成字面重复或纯符号转换即可识别。"
    },
    {
      "defect_id": 398178,
      "sentence": "如果需要为任何数组定义相同的函数，使用类型参数将该函数定义为泛型：",
      "reference_sentence": "",
      "line_num": 1588,
      "context": "{\"1583\":\"  return x[x.length - 1];\",\"1584\":\"}\",\"1585\":\"last([1, 2, 3]); // 3\",\"1586\":\"```\",\"1587\":\"\",\"1588\":\"如果需要为任何数组定义相同的函数，使用类型参数将该函数定义为泛型：\",\"1589\":\"\",\"1590\":\"```typescript\",\"1591\":\"function last<T>(x: T[]): T {\",\"1592\":\"  return x[x.length - 1];\",\"1593\":\"}\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "使用类型参数将函数定义为泛型，可以为任何数组定义相同的函数。",
      "触发条件": "当句子包含冗余的条件状语结构（如\"如果...，...\"）且前后分句存在重复语义时触发，即前分句提出假设条件、后分句描述对应操作，但两者信息可合并简化。  \n\n识别模式：  \n1. 存在条件引导词（如\"如果\"）+ 目的描述  \n2. 后续分句包含\"可满足前述条件的具体操作方法\"  \n3. 前后分句通过合并可消除假设性表述（如删除\"如果\"）且保持语义完整"
    },
    {
      "defect_id": 398199,
      "sentence": "导入声明用于导入从其他模块导出的实体，并在当前模块中提供其绑定。导入声明由两部分组成：",
      "reference_sentence": "",
      "line_num": 1764,
      "context": "{\"1759\":\"\",\"1760\":\"### 导入\",\"1761\":\"\",\"1762\":\"#### 静态导入\",\"1763\":\"\",\"1764\":\"导入声明用于导入从其他模块导出的实体，并在当前模块中提供其绑定。导入声明由两部分组成：\",\"1765\":\"\",\"1766\":\"* 导入路径，用于指定导入的模块；\",\"1767\":\"* 导入绑定，用于定义导入的模块中的可用实体集和使用形式（限定或不限定使用）。\",\"1768\":\"\",\"1769\":\"导入绑定可以有几种形式。\"}",
      "修改建议": "句子包含不必要的修饰成分，可以简化。",
      "更改后示例": "导入声明用于导入其他模块的实体，并在当前模块中提供绑定。",
      "触发条件": "当句子中存在可通过上下文推断的冗余限定词（如\"导出的\"）或重复性物主代词（如\"其\"），且删除后不影响语义完整性时触发。\n\n识别模式：检测\"的\"字结构前是否包含模块/对象已隐含的属性（如导入声明必然操作导出实体），以及代词\"其\"是否与先行词存在重复指代关系（如\"其绑定\"中的\"其\"可省略）。"
    },
    {
      "defect_id": 398182,
      "sentence": "空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。",
      "reference_sentence": "",
      "line_num": 1670,
      "context": "{\"1665\":\"}\",\"1666\":\"```\",\"1667\":\"\",\"1668\":\"### 空值合并运算符\",\"1669\":\"\",\"1670\":\"空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\",\"1671\":\"\",\"1672\":\"换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。\",\"1673\":\"\",\"1674\":\"在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。\",\"1675\":\"\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "空值合并运算符`??`检查左侧表达式是否为`null`或`undefined`。如果是，结果为右侧表达式；否则，结果为左侧表达式。",
      "触发条件": "当句子包含冗余术语（如\"二元\"在已明确运算符类型时）、冗余操作描述（如\"求值是否等于\"可简化为\"是否为\"）、或重复性表达（如连续使用\"表达式\"作为限定词）时触发。"
    },
    {
      "defect_id": 398197,
      "sentence": "**说明**：`getSpouseNick`的返回类型必须为`string | null | undefined`，因为该方法在某些情况下会返回`null`或`undefined`。",
      "reference_sentence": "",
      "line_num": 1710,
      "context": "{\"1705\":\"    this.spouse = undefined;\",\"1706\":\"  }\",\"1707\":\"}\",\"1708\":\"```\",\"1709\":\"\",\"1710\":\"**说明**：`getSpouseNick`的返回类型必须为`string | null | undefined`，因为该方法在某些情况下会返回`null`或`undefined`。\",\"1711\":\"\",\"1712\":\"可选链可以任意长，可以包含任意数量的`?.`运算符。\",\"1713\":\"\",\"1714\":\"在以下示例中，如果`Person`实例的`spouse`属性不为空，并且`spouse`的`nick`属性也不为空时，输出`spouse.nick`。否则，输出`undefined`。\",\"1715\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分，可以简化。",
      "更改后示例": "`getSpouseNick`的返回类型为`string | null | undefined`。",
      "触发条件": "当句子中存在通过因果关系或解释性分句重复已明确声明的类型/结构（如`string | null | undefined`），且未提供额外上下文价值时触发。\n\n识别模式：\n1. 主句包含完整的类型声明（如联合类型）\n2. 后续分句使用\"因为/由于\"等因果关联词\n3. 原因分句仅复述主句类型中的部分/全部可能性（如`null | undefined`）\n4. 未引入新的约束条件或业务逻辑说明"
    },
    {
      "defect_id": 398183,
      "sentence": "换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。",
      "reference_sentence": "",
      "line_num": 1672,
      "context": "{\"1667\":\"\",\"1668\":\"### 空值合并运算符\",\"1669\":\"\",\"1670\":\"空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\",\"1671\":\"\",\"1672\":\"换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。\",\"1673\":\"\",\"1674\":\"在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。\",\"1675\":\"\",\"1676\":\"```typescript\",\"1677\":\"class Person {\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。",
      "触发条件": "当句子使用冗余引导词（如\"换句话说\"）且后续内容为直接重述前文已明确信息时触发，需满足以下条件：\n1. 存在显式重复标记词（如\"换句话说\"、\"也就是说\"）\n2. 后续内容与前文存在语义重复且未提供新信息\n3. 删除标记词后上下文连贯性不受影响\n\n识别模式：检测到\"换句话说\"类引导词 + 检查前文是否已完整覆盖当前句核心语义（如本例前段已完整解释`??`的行为逻辑）+ 验证删除引导词后句子功能完整性。"
    },
    {
      "defect_id": 398184,
      "sentence": "在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。",
      "reference_sentence": "",
      "line_num": 1674,
      "context": "{\"1669\":\"\",\"1670\":\"空值合并二元运算符`??`用于检查左侧表达式的求值是否等于`null`或者`undefined`。如果是，则表达式的结果为右侧表达式；否则，结果为左侧表达式。\",\"1671\":\"\",\"1672\":\"换句话说，`a ?? b`等价于三元运算符`(a != null && a != undefined) ? a : b`。\",\"1673\":\"\",\"1674\":\"在以下示例中，`getNick`方法返回已设置的昵称，若未设置则返回空字符串。\",\"1675\":\"\",\"1676\":\"```typescript\",\"1677\":\"class Person {\",\"1678\":\"  // ...\",\"1679\":\"  nick: string | null = null;\"}",
      "修改建议": "句子可以简化。",
      "更改后示例": "`getNick`方法返回已设置的昵称，未设置则返回空字符串。",
      "触发条件": "当句子中出现\"若...则...\"或\"如果...则...\"等显式条件连接词，且前后分句存在明确的逻辑因果关系时（可通过上下文推断条件关系）。识别模式为条件分句与结果分句之间使用重复性连接词，且分句主语/行为存在直接对立关系（如\"已设置\"与\"未设置\"）。"
    },
    {
      "defect_id": 403603,
      "sentence": "其他函数在字节码文件中的名称结构为：",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中`name_off`字段的命名规则，该规则从版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时执行的函数名称固定为 `func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构为：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\",\"12\":\"下面的章节将详细介绍前缀和原函数名。\",\"13\":\"### 前缀\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "其他函数的名称结构为：",
      "触发条件": "当句子包含已被上下文明确说明的限定成分（如\"在字节码文件中\"），且该限定信息属于当前章节已知背景时触发。具体表现为介词短语/定语成分与上文存在语义重复（如第4段已说明整体规则适用场景，第8段再次出现相同环境限定）。"
    },
    {
      "defect_id": 403607,
      "sentence": "如果源码中相同作用域下出现同名的实体，同名的名称后会加上重名序号，重名序号以`^十六进制数字`的形式表示。出现重名时，第一个不编号（即重名序号为空），从第二个开始编号，编号从`1`开始。",
      "reference_sentence": "",
      "line_num": 45,
      "context": "{\"40\":\"    function A() { }                       // A的函数名\\\"#*@0*#A\\\"，其中\\\"@0\\\"表示在其对应LiteralArray中，索引为0的字符串，此时这个字符串是\\\"longFuncName\\\"。即这个函数原本的名称为\\\"#*longFuncName*#A\\\"\",\"41\":\"    function B() { }                       // B的函数名\\\"#*@0*#B\\\"\",\"42\":\"}  \",\"43\":\"```\",\"44\":\"#### 重名序号\",\"45\":\"如果源码中相同作用域下出现同名的实体，同名的名称后会加上重名序号，重名序号以`^十六进制数字`的形式表示。出现重名时，第一个不编号（即重名序号为空），从第二个开始编号，编号从`1`开始。\",\"46\":\"\",\"47\":\"例子：\",\"48\":\"```ts\",\"49\":\"namespace A {\",\"50\":\"    function bar() { }                      // bar的函数名为\\\"#&A*#bar\\\"\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "如果源码中相同作用域下出现同名的实体，同名的名称后会加上重名序号，重名序号以`^十六进制数字`形式表示。出现重名时，第一个不编号，从第二个开始编号，编号从`1`开始。",
      "触发条件": "当句子中出现括号内重复解释主句内容（如\"（即重名序号为空）\"）或存在冗余介词结构（如\"以...的形式\"中的\"的形式\"）时触发。"
    },
    {
      "defect_id": 398247,
      "sentence": "2. 当下面所有条件成立时，源代码中实体的注解实例会在.d.ets文件中保留。<br>",
      "reference_sentence": "",
      "line_num": 2203,
      "context": "{\"2198\":\"}\",\"2199\":\"\",\"2200\":\"// a.d.ets 编译器生成的声明文件\",\"2201\":\"export declare @interface ClassAuthor {}\",\"2202\":\"```\",\"2203\":\"2. 当下面所有条件成立时，源代码中实体的注解实例会在.d.ets文件中保留。<br>\",\"2204\":\"    2.1 注解的定义被导出（import的注解也算作被导出）。<br>\",\"2205\":\"    2.2 如果实体是类，则类被导出。<br>\",\"2206\":\"    2.3 如果实体是方法，则类被导出，并且方法不是私有方法。\",\"2207\":\"```typescript\",\"2208\":\"// a.ets\"}",
      "修改建议": "原文中的“所有条件”可以简化为“条件”，保持简洁。",
      "更改后示例": "2. 当以下条件成立时，源代码中实体的注解实例会在.d.ets文件中保留。",
      "触发条件": "当文本中出现\"所有条件\"等包含冗余限定词（如\"所有\"）的结构，且上下文已明确条件范围时触发。识别模式需检测名词前是否存在可省略的绝对性限定词（如\"所有\"、\"全部\"），同时验证删除后不影响条件完整性。"
    },
    {
      "defect_id": 398206,
      "sentence": "对于要使用的注解，其名称必须以符号`@`（例如：@MyAnno）为前缀。符号`@`和名称之间不允许有空格和行分隔符。",
      "reference_sentence": "",
      "line_num": 1918,
      "context": "{\"1913\":\"\",\"1914\":\"- 注解`ClassAuthor`需要将元信息添加到类声明中。\",\"1915\":\"- 注解必须放置在声明之前。\",\"1916\":\"- 注解可以包含上述示例中所示的参数。\",\"1917\":\"\",\"1918\":\"对于要使用的注解，其名称必须以符号`@`（例如：@MyAnno）为前缀。符号`@`和名称之间不允许有空格和行分隔符。\",\"1919\":\"```typescript\",\"1920\":\"ClassAuthor({authorName: \\\"Bob\\\"}) // 编译错误：注解需要'@'为前缀\",\"1921\":\"@ ClassAuthor({authorName: \\\"Bob\\\"}) // 编译错误：符号`@`和名称之间不允许有空格和行分隔符\",\"1922\":\"```\",\"1923\":\"如果在使用位置无法访问注解名称，则会发生编译错误。\"}",
      "修改建议": "句子包含不必要的修饰成分，可以简化。",
      "更改后示例": "注解名称必须以`@`为前缀，`@`和名称之间不允许有空格和行分隔符。",
      "触发条件": "当句子包含重复说明性介词短语（如\"对于要使用的\"）或存在可合并的相邻分句时触发，特别是当上下文已明确主体且存在重复结构时。\n\n识别模式：\n1. 存在冗余限定短语（如\"对于...\"结构）且上下文已明确主体\n2. 相邻分句共享相同主语但被拆分为独立句子\n3. 使用示例性说明（如\"例如...\"）后仍保留重复规则描述"
    },
    {
      "defect_id": 398202,
      "sentence": "如下例所示，import(modulePath)可以加载模块并返回一个promise，该promise resolve为一个包含其所有导出的模块对象。该表达式可以在代码中的任意位置调用。",
      "reference_sentence": "",
      "line_num": 1801,
      "context": "{\"1796\":\"```\",\"1797\":\"\",\"1798\":\"#### 动态导入\",\"1799\":\"应用开发的有些场景中，如果希望根据条件导入模块或者按需导入模块，可以使用动态导入代替静态导入。\",\"1800\":\"import()语法被称为动态导入（dynamic import），是一种类似函数的表达式，用于动态导入模块。调用这种方式，会返回一个promise。\",\"1801\":\"如下例所示，import(modulePath)可以加载模块并返回一个promise，该promise resolve为一个包含其所有导出的模块对象。该表达式可以在代码中的任意位置调用。\",\"1802\":\"\",\"1803\":\"```typescript\",\"1804\":\"// Calc.ts\",\"1805\":\"export function add(a:number, b:number):number {\",\"1806\":\"  let c = a + b;\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "import(modulePath)加载模块并返回一个包含其所有导出的模块对象的promise。该表达式可以在代码中的任意位置调用。",
      "触发条件": "同一名词短语（如“promise”）在相邻分句中重复出现，且后句使用定语从句（如“该promise resolve为...”）对前句内容进行冗余解释时触发。  \n\n识别模式：  \n1. **重复名词定位**：识别句子中连续出现的相同核心名词（如“promise”）。  \n2. **冗余修饰判断**：检查后句是否仅通过定语从句或修饰语复述前句名词的已知属性（如“resolve为...”已隐含在“返回promise”的上下文中）。  \n3. **可合并性验证**：判断冗余部分是否可直接转换为前句名词的前置定语（如“返回一个包含...的promise”）。"
    },
    {
      "defect_id": 403601,
      "sentence": "本文介绍字节码文件中`name_off`字段的命名规则，该规则从版本`12.0.4.0`开始生效。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中`name_off`字段的命名规则，该规则从版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时执行的函数名称固定为 `func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构为：\",\"9\":\"```ts\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "本文介绍字节码文件中`name_off`字段的命名规则，从版本`12.0.4.0`开始生效。",
      "触发条件": "当句子中存在重复指代同一主语的指示代词（如\"该规则\"），且后续分句的主语可通过上下文明确推断时触发；当句子结构包含可合并的并列分句，出现语义重复的修饰成分（如\"该规则从...开始生效\"与前文\"命名规则\"形成冗余指代）时触发。"
    },
    {
      "defect_id": 401695,
      "sentence": "ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# ArkTS基础类库概述\",\"2\":\"\",\"3\":\"ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。\",\"4\":\"\",\"5\":\"ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "ArkTS基础类库提供功能齐全的API集合，设计了关键且实用的功能模块。",
      "触发条件": "当句子中出现重复主语结构的修饰成分(如\"是...，设计了...\")，或存在两个及以上语义相近的形容词短语(\"功能齐全\"与\"关键且实用\")时触发。识别模式为连续使用主系表结构+动词短语描述同一主体，且修饰语超过两层叠加。"
    },
    {
      "defect_id": 398344,
      "sentence": "查询个人所得税专项附加扣除的详细信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及3岁以下婴幼儿照护等扣除类型的相关政策、扣除标准及申报条件，帮助用户合理规划个人所得税减免。",
      "reference_sentence": "",
      "line_num": 506,
      "context": "{\"501\":\"| code  | number | 是   | 返回结果码。0表示成功；其他表示失败，开发者可以自定义。           | 0  |\",\"502\":\"| result | object | 是   | 返回结果列表对象。如果无内容，则返回空。 | -       |\",\"503\":\"\",\"504\":\"### 查看专项附加扣除\",\"505\":\"\",\"506\":\"查询个人所得税专项附加扣除的详细信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及3岁以下婴幼儿照护等扣除类型的相关政策、扣除标准及申报条件，帮助用户合理规划个人所得税减免。\",\"507\":\"\",\"508\":\"**起始版本**：1.0.1\",\"509\":\"\",\"510\":\"**参数**：\",\"511\":\"\"}",
      "修改建议": "原文过于啰嗦，包含不必要的修饰成分。",
      "更改后示例": "查询个人所得税专项附加扣除信息，包括子女教育、继续教育、大病医疗、住房贷款利息、住房租金、赡养老人及婴幼儿照护的政策、标准及申报条件，帮助规划减免。",
      "触发条件": "当句子中同时存在重复限定词（如\"扣除类型的相关政策\"中的重复限定）和冗余修饰语（如\"详细信息\"中的\"详细\"、\"3岁以下\"等非必要限定词），且核心信息已通过上下文明确时。识别模式需检查名词前是否有重复限定成分（A的B类型中的B属性）、并列项是否存在可合并的共性修饰语（如多个项目共用\"扣除\"前缀）。"
    },
    {
      "defect_id": 403602,
      "sentence": "模块加载时执行的函数名称固定为 `func_main_0`。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中`name_off`字段的命名规则，该规则从版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时执行的函数名称固定为 `func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构为：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "模块加载时执行的函数名称为 `func_main_0`。",
      "触发条件": "当句子中存在重复限定词（如\"固定为\"）或冗余修饰成分（如\"名称固定为\"中的\"固定\"），且上下文已隐含该信息时触发；或当表述可通过删除冗余形容词/副词后仍保持原意且更简洁时触发。\n\n识别模式：检查句子中是否包含\"固定为\"、\"必须为\"等强调唯一性的冗余短语，或\"名称\"+\"固定为\"这类双重限定结构，同时结合文档上下文判断该强调是否已在其他部分说明过。"
    },
    {
      "defect_id": 401822,
      "sentence": "XML还可以作为消息传递格式，在分布式系统中用于不同节点之间的通信与交互。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"\",\"4\":\"XML可以作为数据交换格式，被各种系统和应用程序所支持。例如Web服务，可以将结构化数据以XML格式进行传递。\",\"5\":\"\",\"6\":\"\",\"7\":\"XML还可以作为消息传递格式，在分布式系统中用于不同节点之间的通信与交互。\",\"8\":\"\",\"9\":\"\",\"10\":\"## 注意事项\",\"11\":\"\",\"12\":\"- XML标签必须成对出现，生成开始标签就要生成结束标签。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "XML作为消息传递格式，用于分布式系统中不同节点的通信。",
      "触发条件": "当句子出现多个逗号分隔的复杂分句结构，且存在语义重复的并列成分（如\"通信与交互\"）或冗余修饰语（如\"还可以\"）时触发。具体识别模式为：1) 连续使用\"与/以及\"连接同范畴词汇 2) 分句间存在重复功能描述（如\"用于...用于...\"）3) 存在可合并的介词短语（如\"在...中\"结构）。"
    },
    {
      "defect_id": 402454,
      "sentence": "如果属性名不包含`\\`，`.`，那么它的原函数名则是这个属性名。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"1. 如果匿名函数定义时被赋值给了一个变量，那么原函数名是变量名。比如下面的例子：\",\"68\":\"    ```ts\",\"69\":\"    let a = () => {}                            // 原函数名为\\\"a\\\"\",\"70\":\"    ```\",\"71\":\"2. 如果匿名函数在对象字面量中定义并且被赋值给了一个字面量属性：\",\"72\":\"* 如果属性名不包含`\\\\`，`.`，那么它的原函数名则是这个属性名。\",\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\",\"77\":\"    ```\"}",
      "修改建议": "句子过于啰嗦。",
      "更改后示例": "如果属性名不包含`\\`和`.`，原函数名即属性名。",
      "触发条件": "当句子使用\"如果...那么...\"结构且后件包含冗余指示词（如\"则是这个\"），或存在多个排除条件未用连词连接时触发。识别模式为：1) 条件从句后接\"那么\"引导的结论句 2) 多个排除条件以逗号分隔未使用连词 3) 结论部分包含重复指代的限定词。"
    },
    {
      "defect_id": 402119,
      "sentence": "总结常见的功能异常场景及其排查方法，并提供典型报错案例的解决方案，帮助开发者快速定位和解决混淆过程中遇到的问题。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"- [ArkGuard混淆原理及功能](source-obfuscation.md)：说明混淆能力范围、混淆流程机制、混淆选项和保留选项的使用方法、混淆规则的合并策略，以及混淆各功能上线的SDK版本。\",\"9\":\"\",\"10\":\"- [ArkGuard混淆开启指南](source-obfuscation-guide.md)：提供实操指南，包括如何开启源码混淆功能、设置自定义混淆规则，以及如何查看混淆效果和进行报错栈还原。\",\"11\":\"\",\"12\":\"- [不同包类型的源码混淆建议](source-obfuscation-practice.md)：针对不同类型的包（HAP、HAR、HSP）提供混淆策略建议。\",\"13\":\"- [ArkGuard混淆常见问题](source-obfuscation-questions.md)：总结常见的功能异常场景及其排查方法，并提供典型报错案例的解决方案，帮助开发者快速定位和解决混淆过程中遇到的问题。\"}",
      "修改建议": "句子过长，包含多个逗号，信息过多。",
      "更改后示例": "总结常见的功能异常场景及其排查方法，提供典型报错案例的解决方案，帮助开发者快速定位和解决问题。",
      "触发条件": "当句子中出现连续三个及以上由逗号连接的并列结构，且存在重复语义成分（如\"并\"连接词与\"解决...问题\"的重复表述）时触发。\n\n识别模式：\n1. 结构特征：包含多个逗号分隔的同类信息单元（如\"总结...，提供...，帮助...\"）\n2. 冗余信号：存在可合并的连词（如\"并\"）或重复限定词（如\"混淆过程中遇到的\"在上下文已明确场景的情况下）\n3. 信息密度：单句承载超过三个核心信息点且缺乏必要逻辑递进关系"
    },
    {
      "defect_id": 398246,
      "sentence": "当编译器根据ets代码自动生成.d.ets文件时，存在以下2种情况。",
      "reference_sentence": "",
      "line_num": 2190,
      "context": "{\"2185\":\"  // ...\",\"2186\":\"}\",\"2187\":\"```\",\"2188\":\"\",\"2189\":\"**编译器自动生成的.d.ets文件**<br>\",\"2190\":\"当编译器根据ets代码自动生成.d.ets文件时，存在以下2种情况。\",\"2191\":\"1. 当注解定义被导出时，源代码中的注解定义会在.d.ets文件中保留。\",\"2192\":\"```typescript\",\"2193\":\"// a.ets\",\"2194\":\"export @interface ClassAuthor {}\",\"2195\":\"\"}",
      "修改建议": "原文中的“存在以下2种情况”可以简化为“存在以下情况”，保持简洁。",
      "更改后示例": "当编译器根据ets代码自动生成.d.ets文件时，存在以下情况。",
      "触发条件": "当句子中同时出现\"以下\"和具体数量词（如\"2种\"），且后续内容已明确列举对应数量的条目时，应触发冗余表达规则。识别模式为检测到\"以下[数字]种/个/类...\"结构，且后接有序列表或明确数量说明的情况。"
    },
    {
      "defect_id": 403616,
      "sentence": "本文介绍字节码文件中`name_off`字段的命名规则，从版本`12.0.4.0`开始生效。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中`name_off`字段的命名规则，从版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时执行的函数名称为 `func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数的名称结构为：\",\"9\":\"```ts\"}",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "本文介绍字节码文件中`name_off`字段的命名规则。该规则从版本`12.0.4.0`开始生效。",
      "触发条件": "单句包含两个及以上独立信息点（如规则说明+版本信息）且使用逗号连接，导致信息密度过高或结构松散。\n\n识别模式：当复合句中出现非递进/因果关系的并列信息（常见于包含版本号、时间状语或附加说明），且各信息点可独立成句时，应触发拆分。典型标志为逗号后接\"从...开始\"等独立状语结构。"
    },
    {
      "defect_id": 403604,
      "sentence": "下面的章节将详细介绍前缀和原函数名。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构为：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\",\"12\":\"下面的章节将详细介绍前缀和原函数名。\",\"13\":\"### 前缀\",\"14\":\"前缀包含函数定义时所在的作用域信息，具体包含以下几个部分：\",\"15\":\"* 作用域标签\",\"16\":\"* 作用域名称\",\"17\":\"* 重名序号\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "下面详细介绍前缀和原函数名。",
      "触发条件": "句子中存在冗余的时间副词（如“将”）或重复修饰成分（如“详细”与“介绍”语义重叠），且删除后不影响核心语义表达。具体表现为：动词前出现表未来时态的冗余助词，或修饰语与核心动词存在隐含的语义重复。"
    },
    {
      "defect_id": 403606,
      "sentence": "源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示，此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，该字段指向一个`LiteralArray`。原函数名不会转换为索引。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"| 构造函数 | `=` | 类的构造函数定义的作用域。 |\",\"32\":\"| 普通函数 | `*` | 除了以上类型的其它所有函数定义的作用域。 |\",\"33\":\"| namespace/module | `&` | `namespace`或`module`关键字定义的作用域。 |\",\"34\":\"| enum | `%` | `enum`关键字定义的作用域。 |\",\"35\":\"#### 作用域名称\",\"36\":\"源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示，此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，该字段指向一个`LiteralArray`。原函数名不会转换为索引。\",\"37\":\"例子：\",\"38\":\"```ts\",\"39\":\"function longFuncName() {                  // longFuncName的函数名为\\\"#*#longFuncName\\\"，其中\\\"longFuncName\\\"是原函数名，不会转换为索引。\",\"40\":\"    function A() { }                       // A的函数名\\\"#*@0*#A\\\"，其中\\\"@0\\\"表示在其对应LiteralArray中，索引为0的字符串，此时这个字符串是\\\"longFuncName\\\"。即这个函数原本的名称为\\\"#*longFuncName*#A\\\"\",\"41\":\"    function B() { }                       // B的函数名\\\"#*@0*#B\\\"\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示，此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，字段指向一个`LiteralArray`。原函数名不会转换为索引。",
      "触发条件": "相邻子句重复使用同一指示代词（如“该字段”）或名词，导致冗余表达，且上下文已明确指代对象无需重复强调。例如长句中出现连续逗号分隔的“该字段...该字段...”结构时触发。\n\n识别模式：  \n1. **重复指代检测**：在同一长句（含多个逗号）中，相邻分句重复使用“该+名词”或相同名词指代前文对象（如“该字段...该字段”）；  \n2. **冗余性验证**：后文指代对象与前文完全一致且无歧义风险，删除重复词后不影响语义（如修复后“字段”直接承接前文“scopeNames字段”）。"
    },
    {
      "defect_id": 398205,
      "sentence": "注解（Annotation）是一种语言特性，它通过添加元数据来改变应用声明的语义。",
      "reference_sentence": "",
      "line_num": 1896,
      "context": "{\"1891\":\"* 调用实例方法的对象\",\"1892\":\"* 正在构造的对象\",\"1893\":\"\",\"1894\":\"## 注解\",\"1895\":\"\",\"1896\":\"注解（Annotation）是一种语言特性，它通过添加元数据来改变应用声明的语义。\",\"1897\":\"注解的声明和使用如下所示：\",\"1898\":\"\",\"1899\":\"**示例：**\",\"1900\":\"\",\"1901\":\"```typescript\"}",
      "修改建议": "句子包含不必要的修饰成分，可以简化。",
      "更改后示例": "注解通过添加元数据来改变应用声明的语义。",
      "触发条件": "当句子中出现术语重复解释（如括号内同义词）或存在可合并的指代结构（如\"它\"指代前文主语）时触发，且上下文已明确术语定义无需重复说明。\n\n识别模式：\n1. 术语后紧跟括号内的同义词/翻译（如\"注解（Annotation）\"）\n2. 主谓结构被拆分为\"术语是...，它...\"的冗余句式\n3. 前文已有术语定义（如标题\"## 注解\"已明确讨论对象）时仍重复基础解释"
    },
    {
      "defect_id": 403608,
      "sentence": "如果属性名包含 `\\` 或 `.`，为防止二义性，其原函数名将按照匿名函数命名。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"    ```ts\",\"74\":\"    let B = {\",\"75\":\"        b : () => {}                            // 原函数名为\\\"b\\\"\",\"76\":\"    }\",\"77\":\"    ```\",\"78\":\"如果属性名包含 `\\\\` 或 `.`，为防止二义性，其原函数名将按照匿名函数命名。\",\"79\":\"    ```ts\",\"80\":\"    let a = {\",\"81\":\"        \\\"a.b#c^2\\\": () => {}                     // 原函数名为\\\"\\\"\",\"82\":\"        \\\"x\\\\\\\\y#\\\": () => {}                       // 原函数名为\\\"^1\\\"\",\"83\":\"    }\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "如果属性名包含 `\\` 或 `.`，为防止二义性，其原函数名将按匿名函数命名。",
      "触发条件": "当句子存在连续逗号分隔的复杂结构，且出现\"按照\"等冗余介词时（可简化为\"按\"），触发冗余表达规则。识别模式为长句中出现\"按照/依据\"等介词短语，且存在可简化表述的语法冗余。"
    },
    {
      "defect_id": 402448,
      "sentence": "本文介绍字节码文件中[Method](arkts-bytecode-file-format.md#method)的`name_off`字段指向的字符串的命名规则，该规则从方舟字节码文件版本`12.0.4.0`开始生效。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中[Method](arkts-bytecode-file-format.md#method)的`name_off`字段指向的字符串的命名规则，该规则从方舟字节码文件版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时被执行的函数，名称固定为`func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数在字节码文件中的名称结构如下：\",\"9\":\"```ts\"}",
      "修改建议": "句子过长，包含过多的修饰成分。",
      "更改后示例": "本文介绍字节码文件中`name_off`字段的命名规则，该规则从版本`12.0.4.0`开始生效。",
      "触发条件": "当句子中出现重复的限定词（如\"方舟字节码文件版本\"中重复两次\"方舟字节码文件\"），或存在可被上下文替代的冗余修饰成分（如\"[Method]的`name_off`字段指向的字符串\"可简化为\"`name_off`字段\"）时触发。\n\n识别模式：\n1. 重复限定词检测：同一名词短语在相邻语义单元重复出现（如\"方舟字节码文件版本\"在前文已明确文件类型）\n2. 修饰链长度判断：中心词（如\"字段\"）被超过两个层级的修饰结构包裹（如\"[Method]的`name_off`字段指向的字符串\"含三级修饰）\n3. 上下文可替代性验证：被修饰内容在文档当前章节/段落中已明确（如\"Method\"的链接已提供完整定义）"
    },
    {
      "defect_id": 401725,
      "sentence": "XML支持命名空间、实体引用、注释和处理指令等特性，使其能够灵活地适应各种数据需求。",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"\",\"17\":\"XML可以通过使用XML Schema或DTD（文档类型定义）来定义文档结构。这些机制允许开发人员创建自定义规则以验证XML文档是否符合其预期的格式。\",\"18\":\"\",\"19\":\"\",\"20\":\"XML支持命名空间、实体引用、注释和处理指令等特性，使其能够灵活地适应各种数据需求。\",\"21\":\"\",\"22\":\"\",\"23\":\"语言基础类库提供了XML相关的基础能力，包括：[XML的生成](xml-generation.md)、[XML的解析](xml-parsing.md)和[XML的转换](xml-conversion.md)。\",\"24\":\"\",\"25\":\"以下是一个简单的XML样例及对应说明，更多XML的接口和具体使用，请见[@ohos.xml](../reference/apis-arkts/js-apis-xml.md)。\"}",
      "修改建议": "句子过长，包含多个逗号，信息可以简化",
      "更改后示例": "XML支持命名空间、实体引用、注释和处理指令，灵活适应各种数据需求。",
      "触发条件": "当句子包含列举项后接\"等特性/功能\"类总括词，且后续使用\"使其能够\"等因果连接词导致分句冗余时触发。\n\n识别模式：\n1. 存在\"等+名词\"结构（如\"等特性\"）作为列举项的总结，此时具体列举项已明确说明功能，总括词冗余\n2. 使用\"使/使得/使其能够\"等目的性连接词引导结果分句，导致主句与结果分句存在重复表达（如原句\"支持...特性\"与\"使其能够适应需求\"存在逻辑重复）"
    },
    {
      "defect_id": 401723,
      "sentence": "XML（可扩展标记语言）是一种用于描述数据的标记语言，旨在提供一种通用的方式来传输和存储数据，特别是Web应用程序中经常使用的数据。XML并不预定义标记。因此，XML更加灵活，并且可以适用于广泛的应用领域。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# XML概述\",\"2\":\"\",\"3\":\"\",\"4\":\"XML（可扩展标记语言）是一种用于描述数据的标记语言，旨在提供一种通用的方式来传输和存储数据，特别是Web应用程序中经常使用的数据。XML并不预定义标记。因此，XML更加灵活，并且可以适用于广泛的应用领域。\",\"5\":\"\",\"6\":\"\",\"7\":\"XML文档由元素（element）、属性（attribute）和内容（content）组成。\",\"8\":\"\",\"9\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息可以简化",
      "更改后示例": "XML是一种用于描述数据的标记语言，提供通用的数据传输和存储方式。XML不预定义标记，因此更加灵活，适用于广泛的应用领域。",
      "触发条件": "当句子出现连续逗号分隔的多重修饰语、重复主语或存在可合并的因果关联词（如\"因此，并且\"）时，触发冗余表达规则。\n\n识别模式：\n1. 结构重复：连续两句重复主语（如案例中三次出现\"XML\"）\n2. 冗余修饰：存在可删除的解释性插入语（如\"特别是...\"从句）\n3. 冗长表达：动词短语可简化为名词结构（如\"提供一种...方式\"→\"提供...方式\"）\n4. 关联词堆砌：因果逻辑词与并列词连续出现（如\"因此，并且\"）"
    },
    {
      "defect_id": 398194,
      "sentence": "用于确定歌单的UI形式（例如每日私享30首、排行榜、新歌推荐、公开的歌单，其UI不同）。支持开发者自定义。长度不超过64个字符。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"**参数**：\",\"31\":\"\",\"32\":\"| 参数名 | 类型   | 必选 | 说明                                                                                                                                                                                                                                                                                       | 数据样例 |\",\"33\":\"|--------------|-----------|-------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|\",\"34\":\"| entityId | string | 否 | 意图实体ID，长度不超过64个字符。                                                                                                                                                                                                                                                                       | \\\"C10194368\\\" |\",\"35\":\"| entityGroupId | string | 否 | 用于确定歌单的UI形式（例如每日私享30首、排行榜、新歌推荐、公开的歌单，其UI不同）。支持开发者自定义。长度不超过64个字符。                                                                                                                                                                                                                   | \\\"C10194321312\\\" |\",\"36\":\"| sceneType | string | 否  | 场景类型。<br>- MORNING_SCENE：晨间。<br>- MIDDAY_SCENE：午间。<br>- EVENNING_SCENE：晚间。<br>- NIGHT_SCENE：夜间。<br>- WEEKEND_SCENE：周末。<br>- FESTIVAL_SCENE：节假日。<br>- BIRTHDAY_SCENE：生日。<br>- ANNIVERSARY_SCENE：纪念日。<br>- DRIVE_SCENE：驾驶。<br>- SUBWAY_SCENE：地铁。<br>- TRAVEL_SCENE：出行。<br>- CITY_SCENE：跨城。 | \\\"MORNING_SCENE\\\" |\",\"37\":\"|city | string | 否 | 城市名。  | \\\"北京市\\\" |\",\"38\":\"\",\"39\":\"**返回值**： \",\"40\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "确定歌单的UI形式，支持开发者自定义，长度不超过64个字符。",
      "触发条件": "句子包含括号内解释性示例且存在重复功能说明（参数用途与限制分列），或出现多个逗号分隔的复杂修饰结构时触发。\n\n识别模式：\n1. 存在括号补充说明（如\"例如...其UI不同\"）破坏句式简洁性\n2. 同一参数的多维度说明（功能+权限+限制）未合并\n3. 超过两个逗号分隔的复合句式（原句含3个分句）\n4. 出现非必要技术细节（如UI差异说明）影响核心参数定义"
    },
    {
      "defect_id": 401724,
      "sentence": "XML可以通过使用XML Schema或DTD（文档类型定义）来定义文档结构。这些机制允许开发人员创建自定义规则以验证XML文档是否符合其预期的格式。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"- 属性提供了有关元素的其他信息。\",\"13\":\"\",\"14\":\"- 内容则是元素包含的数据或子元素。\",\"15\":\"\",\"16\":\"\",\"17\":\"XML可以通过使用XML Schema或DTD（文档类型定义）来定义文档结构。这些机制允许开发人员创建自定义规则以验证XML文档是否符合其预期的格式。\",\"18\":\"\",\"19\":\"\",\"20\":\"XML支持命名空间、实体引用、注释和处理指令等特性，使其能够灵活地适应各种数据需求。\",\"21\":\"\",\"22\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息可以简化",
      "更改后示例": "XML使用XML Schema或DTD定义文档结构，开发人员可以创建自定义规则验证XML文档的格式。",
      "触发条件": "相邻句子存在重复指代（如\"这些机制\"指代前文内容）且共享同一语义功能，或单句包含多个分句表达可合并的连贯动作（如\"定义结构→创建规则→验证格式\"）。\n\n识别模式：\n1. 存在显性回指词（代词/名词复现）连接相邻句子\n2. 动词短语形成逻辑链条（A允许B做C以达到D）\n3. 信息密度低于阈值（本例修复后信息单元从5个降为3个：定义工具→创建规则→验证格式）"
    },
    {
      "defect_id": 403620,
      "sentence": "源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示，此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，该字段指向一个`LiteralArray`对象。原函数名不会转换为索引。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"| 构造函数 | `=` | 类的构造函数定义的作用域。 |\",\"32\":\"| 普通函数 | `*` | 除了以上类型的其它所有函数定义的作用域。 |\",\"33\":\"| namespace/module | `&` | `namespace`或`module`关键字定义的作用域。 |\",\"34\":\"| enum | `%` | `enum`关键字定义的作用域。 |\",\"35\":\"#### 作用域名称\",\"36\":\"源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示，此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，该字段指向一个`LiteralArray`对象。原函数名不会转换为索引。\",\"37\":\"例子：\",\"38\":\"```ts\",\"39\":\"function longFuncName() {                  // longFuncName的函数名为\\\"#*#longFuncName\\\"，其中\\\"longFuncName\\\"是原函数名，不会转换为索引。\",\"40\":\"    function A() { }                       // A的函数名\\\"#*@0*#A\\\"，其中\\\"@0\\\"表示在其对应LiteralArray中，索引为0的字符串，此时这个字符串是\\\"longFuncName\\\"。即这个函数原本的名称为\\\"#*longFuncName*#A\\\"\",\"41\":\"    function B() { }                       // B的函数名\\\"#*@0*#B\\\"\"}",
      "修改建议": "句子过长，包含多个信息点。",
      "更改后示例": "源代码中定义作用域时使用的名称。匿名则为空字符串。方舟编译器会优化较长的作用域名称，以降低字节码体积。优化后的作用域名称以`@十六进制数字`形式表示。此数字是作用域名称在字符串数组中的索引。该数组存储在字节码文件的[Class](arkts-bytecode-file-format.md#class)中的`scopeNames`字段，该字段指向一个`LiteralArray`对象。原函数名不会转换为索引。",
      "触发条件": "句子长度超过常规信息承载量且包含多个独立信息点（如定义、优化方式、存储位置等），或存在重复指代结构（如连续使用“该字段”指向不同对象）。"
    },
    {
      "defect_id": 403617,
      "sentence": "模块加载时执行的函数名称为 `func_main_0`。",
      "reference_sentence": "",
      "line_num": 6,
      "context": "{\"1\":\"# 方舟字节码函数命名规则\",\"2\":\"\",\"3\":\"## 概述\",\"4\":\"本文介绍字节码文件中`name_off`字段的命名规则，从版本`12.0.4.0`开始生效。\",\"5\":\"## 入口函数\",\"6\":\"模块加载时执行的函数名称为 `func_main_0`。\",\"7\":\"## 非入口函数\",\"8\":\"其他函数的名称结构为：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\"}",
      "修改建议": "句子可以更加简洁。",
      "更改后示例": "模块加载时执行 `func_main_0` 函数。",
      "触发条件": "当句子同时包含\"名称为\"表述和具体名称/标识符，且该名称在上下文中已明确属性（如函数名）时触发冗余表达规则。识别模式为检测\"名称为/称为/名字是 + 具体名称\"结构，且名称本身已隐含属性特征（如func_前缀表明函数身份）。"
    },
    {
      "defect_id": 402789,
      "sentence": "需要使用util模块函数对文本编码",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"## 解析XML属性和属性值\",\"98\":\"\",\"99\":\"1. 引入模块。\",\"100\":\"\",\"101\":\"    ```ts\",\"102\":\"    import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文本编码\",\"103\":\"    ```\",\"104\":\"\",\"105\":\"2. 对XML文本编码后调用XmlPullParser。\",\"106\":\"\",\"107\":\"    ```ts\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "使用util模块对文本编码",
      "触发条件": "当文本中同时出现\"模块\"和\"函数\"双重限定词（如\"模块函数\"），且上下文已明确模块功能时触发；或检测到\"使用...模块函数\"这类冗余结构时触发。识别模式为：模块名+函数/函数集+操作动词的重复限定结构。"
    },
    {
      "defect_id": 403824,
      "sentence": "使用`napi_create_promise`后未判断返回值是否为`napi_ok`，之后使用了无效的`deferred`和`promise`导致应用崩溃。",
      "reference_sentence": "",
      "line_num": 91,
      "context": "{\"86\":\"napi_create_promise用于创建一个Promise对象。\",\"87\":\"\",\"88\":\"使用该接口时应注意：\",\"89\":\"\",\"90\":\"1. 当有异常未处理时调用`napi_create_promise`，会返回`napi_pending_exception`。\",\"91\":\"2. 使用`napi_create_promise`后未判断返回值是否为`napi_ok`，之后使用了无效的`deferred`和`promise`导致应用崩溃。\",\"92\":\"\",\"93\":\"```c++\",\"94\":\"napi_value NapiPromiseDemo(napi_env env, napi_callback_info)\",\"95\":\"{\",\"96\":\"    napi_deferred deferred = nullptr;\"}",
      "修改建议": "句子包含不必要的信息。",
      "更改后示例": "使用`napi_create_promise`后未判断返回值是否为`napi_ok`，会导致应用崩溃。",
      "触发条件": "当句子在描述错误后果时重复说明已知/必然结果（如\"之后使用了无效的X导致崩溃\"），且该结果已隐含在前提条件（未检查返回值）的上下文逻辑链中。  \n\n识别模式：  \n1. 存在\"未判断返回值\"+\"导致结果\"的复合结构  \n2. 结果部分包含可通过前提条件直接推导的因果关系（如未检查API返回值→后续使用无效对象必然崩溃）  \n3. 上下文已明确相关对象与返回状态的关系（如问题上下文第90行说明异常处理机制）"
    },
    {
      "defect_id": 403820,
      "sentence": "Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\",\"17\":\"\",\"18\":\"这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。Node-API提供的方法可以帮助开发者在C/C++应用中处理ArkTS中的异步操作。\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "Promise是ArkTS对象，用于处理异步操作。通过then、catch和finally方法添加自定义逻辑。",
      "触发条件": "同一主语在相邻句子中重复出现，或存在语义重复的介词短语（如\"作用于外部\"与\"暴露给外部\"），导致信息密度降低。\n\n识别模式：\n1. 主语重复：当主语（如\"Promise\"）在连续句子开头重复出现时\n2. 同义表达堆砌：检测到\"作用于外部\"+\"暴露给外部\"等语义重叠的介词结构\n3. 功能重复描述：同一功能通过不同角度重复说明（如\"通过...方法暴露\"与\"添加逻辑\"存在因果关系重复）"
    },
    {
      "defect_id": 403855,
      "sentence": "在ArkTS对象属性的相关开发中，需要处理ArkTS对象属性，确保正确地访问、设置、删除属性，并了解属性的继承关系和枚举特性。以下是一些关键概念：",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用Node-API接口获取和设置ArkTS对象的属性。通过合理使用这些函数，实现更复杂的功能和逻辑。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在ArkTS对象属性的相关开发中，需要处理ArkTS对象属性，确保正确地访问、设置、删除属性，并了解属性的继承关系和枚举特性。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **对象（Object）**：在ArkTS中，对象是一种复合数据类型，它允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。\",\"12\":\"- **属性（Property）**：在ArkTS中，属性是对象特征的键值对。每个属性都有一个名字（也称为键或标识符）和一个值。属性的值可以是任意数据类型，包括基本类型、对象和函数。\",\"13\":\"- **可枚举属性（EnumerableProperty）**：在ArkTS中，对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的，即内部 “可枚举” 标志设置为true或false。可枚举性决定了这个属性能否被 `for...in` 查找遍历到。\",\"14\":\"- **自有属性（OwnProperty）**：自有属性直接定义在对象上的属性，而不是从原型链上继承来的属性。\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗长。",
      "更改后示例": "处理ArkTS对象属性，确保正确访问、设置、删除属性，并了解属性的继承关系和枚举特性。以下是一些关键概念：",
      "触发条件": "同一分句内出现重复性名词短语（如\"处理ArkTS对象属性，确保正确地访问、设置、删除属性\"中前置引导语与后续动宾结构重复），或单句包含超过三个逗号分隔的并列操作描述。"
    },
    {
      "defect_id": 403823,
      "sentence": "当有异常未处理时调用`napi_create_promise`，会返回`napi_pending_exception`。",
      "reference_sentence": "",
      "line_num": 90,
      "context": "{\"85\":\"\",\"86\":\"napi_create_promise用于创建一个Promise对象。\",\"87\":\"\",\"88\":\"使用该接口时应注意：\",\"89\":\"\",\"90\":\"1. 当有异常未处理时调用`napi_create_promise`，会返回`napi_pending_exception`。\",\"91\":\"2. 使用`napi_create_promise`后未判断返回值是否为`napi_ok`，之后使用了无效的`deferred`和`promise`导致应用崩溃。\",\"92\":\"\",\"93\":\"```c++\",\"94\":\"napi_value NapiPromiseDemo(napi_env env, napi_callback_info)\",\"95\":\"{\"}",
      "修改建议": "句子包含不必要的信息。",
      "更改后示例": "未处理异常时调用`napi_create_promise`会返回`napi_pending_exception`。",
      "触发条件": "句子包含冗余的时间状语从句结构（如\"当...时\"）或重复性条件描述，且存在更简洁的短语可替代时触发。典型模式为\"当A未处理时，会B\"可简化为\"未处理A时B\"的结构冗余。"
    },
    {
      "defect_id": 402794,
      "sentence": "对数据编码，防止包含中文字符乱码",
      "reference_sentence": "",
      "line_num": 161,
      "context": "{\"156\":\"      '<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>' +\",\"157\":\"      '<note importance=\\\"high\\\" logged=\\\"true\\\">' +\",\"158\":\"      '<title>Play</title>' +\",\"159\":\"      '</note>';\",\"160\":\"    let textEncoder: util.TextEncoder = new util.TextEncoder();\",\"161\":\"    let arrBuffer: Uint8Array = textEncoder.encodeInto(strXml); // 对数据编码，防止包含中文字符乱码\",\"162\":\"    let that: xml.XmlPullParser = new xml.XmlPullParser(arrBuffer.buffer as object as ArrayBuffer, 'UTF-8');\",\"163\":\"    ```\",\"164\":\"\",\"165\":\"3. 自定义回调函数，本例直接打印元素事件类型及元素深度。\",\"166\":\"\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "对数据编码",
      "触发条件": "当句子包含用逗号分隔的\"动作+目的说明\"结构，且目的说明内容已在上下文代码/注释中明确体现时触发。具体表现为后半句解释性内容（如\"防止...乱码\"）与代码中的编码声明（如'UTF-8'）或API功能（如TextEncoder）形成语义重复。"
    },
    {
      "defect_id": 403818,
      "sentence": "同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "同步代码按顺序执行，每行代码执行完后继续执行下一行。如果某个操作耗时较长，整个程序会被阻塞。",
      "触发条件": "同一段落或相邻上下文中重复使用相同语义结构解释同一概念，或在列表项等简洁格式中出现与上文内容重叠的冗余性细节描述。\n\n识别模式：1) 检查相邻句子是否采用\"概念是指...，在概念场景中...\"的重复解释结构；2) 分析列表项内容是否包含前文已完整定义的背景信息（如本例中同步概念已在段落9完整定义，列表项11重复展开）；3) 检测是否存在通过连接词扩展的复合长句（如使用\"如果...那么...\"句式补充本应前置说明的核心特征）。"
    },
    {
      "defect_id": 403619,
      "sentence": "下面详细介绍前缀和原函数名。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"## 非入口函数\",\"8\":\"其他函数的名称结构为：\",\"9\":\"```ts\",\"10\":\"#前缀#原函数名\",\"11\":\"```\",\"12\":\"下面详细介绍前缀和原函数名。\",\"13\":\"### 前缀\",\"14\":\"前缀包含函数定义时所在的作用域信息，具体包括以下几个部分：\",\"15\":\"* 作用域标签\",\"16\":\"* 作用域名称\",\"17\":\"* 重名序号\"}",
      "修改建议": "句子可以更加简洁。",
      "更改后示例": "详细介绍前缀和原函数名。",
      "触发条件": "句子中包含指向下文的冗余指示词（如\"下面\"），且上下文结构（如标题/代码块后）已隐含后续内容位置时触发。  \n\n识别模式：  \n1. 存在\"下面/如下/接下来\"等显式位置指示词  \n2. 当前句子位于章节/代码块/列表末尾，后续内容直接衔接被说明对象  \n3. 删除指示词后不影响内容定位且更简洁"
    },
    {
      "defect_id": 401821,
      "sentence": "XML可以作为数据交换格式，被各种系统和应用程序所支持。例如Web服务，可以将结构化数据以XML格式进行传递。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# XML生成\",\"2\":\"\",\"3\":\"\",\"4\":\"XML可以作为数据交换格式，被各种系统和应用程序所支持。例如Web服务，可以将结构化数据以XML格式进行传递。\",\"5\":\"\",\"6\":\"\",\"7\":\"XML还可以作为消息传递格式，在分布式系统中用于不同节点之间的通信与交互。\",\"8\":\"\",\"9\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "XML作为数据交换格式，被各种系统和应用程序支持。Web服务使用XML传递结构化数据。",
      "触发条件": "当句子包含连续逗号分隔的分句结构，且存在重复语义成分（如\"XML格式\"重复说明）或冗余修饰语（如\"进行传递\"中的进行体）时触发。\n\n识别模式：1) 检查超过两个逗号的长句是否存在分述同一主题的情况 2) 定位重复出现的核心名词（如案例中的\"XML\"）及其修饰语 3) 识别\"可以...例如...\"这类举例结构中的信息重复现象"
    },
    {
      "defect_id": 403821,
      "sentence": "deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"Promise是ArkTS中用来处理异步操作的对象，Promise有pending（待定）、fulfilled（已兑现）和rejected（已拒绝）三种状态，Promise的初始状态是pending，resolve函数可以使其状态从pending变为fulfilled（已兑现），reject函数可以使其状态从pending变为rejected(已拒绝)，一旦兑现或拒绝Promise的状态将不能更改。下面是一些基本概念：\",\"10\":\"\",\"11\":\"- **同步**： 同步是指代码按照顺序一行一行地执行，每行代码的执行都会等待上一行代码执行完成后再继续执行。在同步执行中，如果某个操作需要花费较长时间，那么整个程序的执行就会被阻塞，直到该操作完成才能继续执行后续代码。\",\"12\":\"- **异步**：异步是指任务可以同时执行，不需要等待上一个任务结束。在ArkTS中，常见的异步操作包括定时器、事件监听、网络请求等。异步任务不会阻塞后续任务的执行，而是通过回调函数或Promise对象来处理任务的结果。\",\"13\":\"- **Promise**：Promise是一个ArkTS对象，用于处理异步操作。Promise作用于外部，通常通过then、catch和finally方法暴露给外部以添加自定义逻辑。\",\"14\":\"- **deferred**：deferred是延迟对象，它可以与Promise对象关联，设置Promise的回调函数resolve和reject。deferred作用于内部，维护异步模型的状态并设置回调函数resolve和reject。\",\"15\":\"- **resolve**：此函数可以将Promise的状态从pending（待定）改为fulfilled（已兑现），向resolve中传入的参数可以在Promise对象的then方法中获取。\",\"16\":\"- **reject**：此函数可以将Promise的状态从pending（待定）改为rejected（已拒绝），向reject中传入的参数可以在Promise对象的catch方法中获取。\",\"17\":\"\",\"18\":\"这些基本概念在处理异步操作中非常重要，开发者需要通过适当的方法来处理异步操作，Promise可以链式调用多个异步操作，使代码清晰整洁，便于维护。Node-API提供的方法可以帮助开发者在C/C++应用中处理ArkTS中的异步操作。\",\"19\":\"\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "deferred是延迟对象，与Promise关联，设置resolve和reject回调。维护异步模型状态。",
      "触发条件": "同一段落或相邻句子中重复出现相同术语/功能描述（如\"设置回调函数resolve和reject\"重复两次），且存在多个并列动词短语（如\"关联...，设置...，维护...，设置...\"）导致信息冗余时。"
    },
    {
      "defect_id": 401696,
      "sentence": "ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS基础类库概述\",\"2\":\"\",\"3\":\"ArkTS基础类库是一个功能齐全的API集合，精心设计了一系列关键且实用的功能模块。\",\"4\":\"\",\"5\":\"ArkTS基础类库主要提供了[XML生成解析转换](xml-overview.md)、[二进制Buffer](buffer.md)、[多种容器类库](container-overview.md)、[URL字符串解析](../reference/apis-arkts/js-apis-url.md)和[高精度浮点计算](../reference/apis-arkts/js-apis-arkts-decimal.md)等能力，协助开发者简化开发工作，提升开发效率。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "ArkTS基础类库提供XML生成解析转换、二进制Buffer、多种容器类库、URL字符串解析和高精度浮点计算等能力，简化开发工作，提升开发效率。",
      "触发条件": "句子包含重复功能描述（如\"协助开发者\"与\"简化开发工作\"语义重叠）或冗余修饰词（如\"主要\"在列举具体功能时多余），且导致句式臃肿超过30字。识别模式为存在\"动词+宾语+重复目的状语\"结构（例：提供X能力，协助开发者实现Y效果）或非必要限定词叠加。"
    },
    {
      "defect_id": 402793,
      "sentence": "需要使用util模块函数对文本编码",
      "reference_sentence": "",
      "line_num": 150,
      "context": "{\"145\":\"\",\"146\":\"1. 引入模块。\",\"147\":\"\",\"148\":\"    ```ts\",\"149\":\"    import { xml, util } from '@kit.ArkTS'; // 需要使用util模块函数对文本编码\",\"150\":\"    ```\",\"151\":\"\",\"152\":\"2. 对XML文本编码后调用XmlPullParser。\",\"153\":\"\",\"154\":\"    ```ts\",\"155\":\"    let strXml: string =\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "使用util模块对文本编码",
      "触发条件": "当句子中同时出现“模块\"和\"函数\"的冗余组合（如\"X模块函数\"），且上下文已明确模块功能时触发；或存在可被模块名直接替代的冗余动作描述（如\"使用函数\"可简化为\"使用模块\"）。"
    },
    {
      "defect_id": 402792,
      "sentence": "一次打印出所有的属性及其值",
      "reference_sentence": "",
      "line_num": 135,
      "context": "{\"130\":\"4. 设置解析选项，调用parse函数。\",\"131\":\"\",\"132\":\"    ```ts\",\"133\":\"    let options: xml.ParseOptions = {supportDoctype:true, ignoreNameSpace:true, attributeValueCallbackFunction:func};\",\"134\":\"    that.parseXml(options);\",\"135\":\"    console.info(str); // 一次打印出所有的属性及其值\",\"136\":\"    ```\",\"137\":\"\",\"138\":\"   输出结果如下所示：\",\"139\":\"   ```\",\"140\":\"   importance high logged true // note节点的属性及属性值\"}",
      "修改建议": "原文包含不必要的解释",
      "更改后示例": "打印所有属性及其值",
      "触发条件": "当句子包含冗余的时间副词（如“一次”）或重复性名词结构（如“属性及其值”隐含值已包含在属性中），且在上下文明确操作目的时。  \n识别模式：检测“一次/同时/直接”等非必要副词修饰动作，或“A及其B”结构中B为A的隐含属性（如“属性”默认含值）。"
    },
    {
      "defect_id": 403955,
      "sentence": "推荐开发者在默认混淆（包含局部变量和参数混淆）的基础上，开启混淆配置文件中的以下四项基础混淆选项：",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"为了对混淆在不同包类型下的行为有更清晰的理解，建议开发者在对不同包类型进行配置前，充分了解混淆原理及混淆开启流程，并优先阅读[Stage模型应用程序包结构](../quick-start/application-package-structure-stage.md)（了解不同包类型之间的差异点）。\",\"6\":\"\",\"7\":\"## 推荐混淆功能\",\"8\":\"\",\"9\":\"推荐开发者在默认混淆（包含局部变量和参数混淆）的基础上，开启混淆配置文件中的以下四项基础混淆选项：\",\"10\":\"\",\"11\":\"1. 顶层作用域名称混淆（`-enable-toplevel-obfuscation`）\",\"12\":\"2. 属性名称混淆（`-enable-property-obfuscation`）\",\"13\":\"3. 导入导出名称混淆（`-enable-export-obfuscation`）\",\"14\":\"4. 文件名混淆（`-enable-filename-obfuscation`）\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "推荐开发者在默认混淆基础上，开启以下四项基础混淆选项：",
      "触发条件": "当句子中同时存在括号补充说明已知信息（如默认配置已包含的功能）和重复性位置描述（如\"混淆配置文件中\"这类前文已明确的限定语）时触发。\n\n识别模式：1) 检查括号内是否为上下文已覆盖的冗余解释 2) 识别重复的位置限定词（如\"配置文件中\"在前文已明确的情况下再次出现）3) 判断句子是否因多重修饰导致核心信息密度降低（原句\"基础上\"与\"配置文件中\"形成双重限定）"
    },
    {
      "defect_id": 403956,
      "sentence": "开启混淆功能后，需要配置白名单进行适配，来保证应用运行功能正常。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"1. 顶层作用域名称混淆（`-enable-toplevel-obfuscation`）\",\"12\":\"2. 属性名称混淆（`-enable-property-obfuscation`）\",\"13\":\"3. 导入导出名称混淆（`-enable-export-obfuscation`）\",\"14\":\"4. 文件名混淆（`-enable-filename-obfuscation`）\",\"15\":\"\",\"16\":\"开启混淆功能后，需要配置白名单进行适配，来保证应用运行功能正常。\",\"17\":\"\",\"18\":\"- 对于新开发的应用，建议直接打开以上选项，在开发迭代过程中增加白名单配置。\",\"19\":\"- 对于已开发一定功能的应用，建议按照以上顺序逐步打开各个选项，对比不同选项的混淆产物，熟悉新增选项的具体效果，参考[混淆选项配置指导](source-obfuscation-guide.md#混淆选项配置指导)排查适配。\",\"20\":\"\",\"21\":\"当应用功能调试正常后，还可继续开启代码压缩（`-compact`）与日志删除（`-remove-log`）等功能以发布release应用包。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "开启混淆功能后，配置白名单以保证应用正常运行。",
      "触发条件": "句子中存在连续冗余动词结构（如\"需要...进行\"）或重复性目的状语（如\"来保证...\"），且上下文已隐含动作必要性时。  \n\n识别模式：  \n1. 检查动词短语是否包含双重动作词（需+配置、进行+适配）  \n2. 分析目的状语是否与主谓结构存在语义重叠（\"配置白名单\"已隐含\"保证运行正常\"的因果关系）  \n3. 验证删除冗余成分后核心语义完整性（保留\"配置白名单→保证运行\"逻辑链）"
    },
    {
      "defect_id": 403960,
      "sentence": "1. 开启混淆规则。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"当应用功能调试正常后，还可继续开启代码压缩（`-compact`）与日志删除（`-remove-log`）等功能以发布release应用包。\",\"22\":\"\",\"23\":\"## HAP包混淆建议\",\"24\":\"\",\"25\":\"1. 开启混淆规则。建议开启[推荐的四项规则](#推荐混淆功能)，其它选项按需添加。\",\"26\":\"2. HAP包的开发者需要重点知悉[混淆规则的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆规则的情况。\",\"27\":\"\",\"28\":\"3. 在此基础上，还需了解哪种依赖包内的代码会跟随本模块一起参与编译混淆，因为这会影响混淆新生成的名称和部分全局生效（如属性名称）的白名单，从而影响到本模块最终的混淆效果。具体而言：\",\"29\":\"    - 当依赖本地HAR包时，其代码会跟随本模块一起混淆，混淆前后的名称会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"30\":\"    - 当依赖发布态源码HAR包时，安装在工程级`oh_modules`目录下的代码会跟随本模块一起混淆，混淆前后的名称也会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "1. 开启混淆规则。建议开启推荐的四项规则，其它选项按需添加。",
      "触发条件": "当句子中存在冗余的链接锚点标记（如`#xxx`）、重复性修饰语或非必要的技术细节，导致信息密度过高且不影响核心语义时。  \n识别模式：检测到Markdown链接中含非必要锚点、修饰成分与上下文重复，或存在可简化的复合结构（如`[A](#B)`简化为`A`）。"
    },
    {
      "defect_id": 403957,
      "sentence": "对于新开发的应用，建议直接打开以上选项，在开发迭代过程中增加白名单配置。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "{\"13\":\"3. 导入导出名称混淆（`-enable-export-obfuscation`）\",\"14\":\"4. 文件名混淆（`-enable-filename-obfuscation`）\",\"15\":\"\",\"16\":\"开启混淆功能后，需要配置白名单进行适配，来保证应用运行功能正常。\",\"17\":\"\",\"18\":\"- 对于新开发的应用，建议直接打开以上选项，在开发迭代过程中增加白名单配置。\",\"19\":\"- 对于已开发一定功能的应用，建议按照以上顺序逐步打开各个选项，对比不同选项的混淆产物，熟悉新增选项的具体效果，参考[混淆选项配置指导](source-obfuscation-guide.md#混淆选项配置指导)排查适配。\",\"20\":\"\",\"21\":\"当应用功能调试正常后，还可继续开启代码压缩（`-compact`）与日志删除（`-remove-log`）等功能以发布release应用包。\",\"22\":\"\",\"23\":\"## HAP包混淆建议\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "对于新应用，建议直接开启以上选项，并在开发过程中增加白名单配置。",
      "触发条件": "当句子中同时存在重复的时间状语（如\"开发迭代过程中\"）和冗余的名词修饰（如\"新开发的应用\"中的\"开发\"），且上下文已隐含相关语义时触发。\n\n识别模式：\n1. 检查名词前是否有可合并的限定词（如\"新开发\"→\"新\"）\n2. 识别时间状语中是否存在双重时间指向（如\"开发迭代过程中\"同时包含开发阶段和迭代阶段）\n3. 验证修饰成分是否与上下文存在重复信息（如前文已明确讨论开发场景）"
    },
    {
      "defect_id": 403864,
      "sentence": "在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\",\"33\":\"## 使用示例\",\"34\":\"\"}",
      "修改建议": "句子包含无意义的词语。",
      "更改后示例": "此函数检查对象是否包含命名属性。",
      "触发条件": "当句子包含冗余的条件状语结构（如\"在需要...时\"）或重复说明功能用途（如\"可以使用这个函数\"）时触发。\n\n识别模式：1) 存在\"在需要...时\"等引导词但未提供新信息 2) 主谓结构重复函数名称已隐含的功能说明（如\"可以使用\" + 函数名）。典型特征为模板化句式与核心功能描述形成语义重复。"
    },
    {
      "defect_id": 403862,
      "sentence": "在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 27,
      "context": "{\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\"}",
      "修改建议": "句子包含无意义的词语。",
      "更改后示例": "此函数将值赋给对象的命名属性。",
      "触发条件": "当句子包含冗余的意图引导结构（如\"在需要...时，可以使用\"）且核心功能描述可被独立表达时触发；或存在重复限定词（如同时出现\"ArkTS对象\"和\"命名属性\"）导致语义重叠时触发。\n\n识别模式：\n1. 检测\"在需要...时，可以使用\"类引导句式，其意图说明与功能描述存在语义重复\n2. 检查是否存在双重限定（如对象类型+属性类型），当其中一个限定词已隐含另一层含义时（如\"命名属性\"必然属于对象，无需重复强调\"ArkTS对象\"）\n3. 验证删除冗余部分后核心语义是否完整保留（如将复合引导句简化为\"此函数...\"的直接陈述）"
    },
    {
      "defect_id": 403863,
      "sentence": "在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\",\"33\":\"## 使用示例\"}",
      "修改建议": "句子包含无意义的词语。",
      "更改后示例": "此函数获取对象的命名属性值。",
      "触发条件": "当句子采用\"在需要[操作描述]时，可以使用这个函数\"的冗余结构，且存在重复说明函数用途的介词短语时触发。\n\n识别模式：1) 包含\"在需要...时\"的条件状语从句+使用建议的复合结构 2) 前置状语与核心谓语存在语义重复（如\"获取命名属性值\"已隐含使用场景，无需额外添加\"在需要获取时\"）3) 存在可简化的介词短语（如\"从ArkTS对象中\"在上下文明确时冗余）"
    },
    {
      "defect_id": 404563,
      "sentence": "5. napi_cancel_async_work",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"1. napi_get_reference_value\",\"34\":\"2. napi_delete_reference*\",\"35\":\"3. napi_queue_async_work\",\"36\":\"4. napi_queue_async_work_with_qos\",\"37\":\"5. napi_cancel_async_work\",\"38\":\"6. napi_call_threadsafe_function*\",\"39\":\"7. napi_release_threadsafe_function*\",\"40\":\"\",\"41\":\"> \\\\*：具有该标志的接口，仅能触发第二种场景的维测信息。\",\"42\":\"\"}",
      "修改建议": "无实际问题，但可以更简洁。",
      "更改后示例": "napi_cancel_async_work",
      "触发条件": "当文档列表项中存在与上下文重复的动词/名词修饰（如\"调用\"\"函数\"等冗余词汇），或相邻条目结构重复导致冗余时触发。\n\n识别模式：检查列表项是否包含非必要的功能性描述词（如\"调用\"）、重复术语（如\"函数\"），或与上下条文法结构高度重复但内容独立的情况（例如连续条目仅数字/名称不同）。"
    },
    {
      "defect_id": 404008,
      "sentence": "HSP生成`obfuscation.txt`的规则仅来源于当前模块的`consumer-rules.txt`文件，不包括依赖模块的`consumer-rules.txt`文件或`obfuscation.txt`文件。",
      "reference_sentence": "",
      "line_num": 107,
      "context": "{\"102\":\"2. 对于集成态HSP包的内部混淆效果，开发者可以参阅[HAP包混淆建议](#hap包混淆建议)中的所有建议。\",\"103\":\"3. 集成态HSP包在发布后会被各方依赖，需要充分验证使用方开启混淆时HSP包接口可以被正常调用。\",\"104\":\"\",\"105\":\"> **说明**\",\"106\":\">\",\"107\":\"> HSP生成`obfuscation.txt`的规则仅来源于当前模块的`consumer-rules.txt`文件，不包括依赖模块的`consumer-rules.txt`文件或`obfuscation.txt`文件。\"}",
      "修改建议": "句子过长，包含多个逗号，信息复杂。",
      "更改后示例": "HSP生成`obfuscation.txt`的规则仅来源于当前模块的`consumer-rules.txt`文件。不包括依赖模块的`consumer-rules.txt`文件或`obfuscation.txt`文件。",
      "触发条件": "当句子包含多个由逗号连接的独立信息点（特别是并列的排除/包含条件），导致信息密度过高影响可读性时触发。\n\n识别模式：\n1. 存在超过两层的逻辑结构（如\"规则来源A，不包括B或C\"）\n2. 使用\"或\"连接的并列排除项与主句形成双重否定结构\n3. 单句超过25字且包含两个以上逗号分隔的复杂成分\n4. 后半部分内容实质构成对主句的补充说明而非自然延伸"
    },
    {
      "defect_id": 404523,
      "sentence": "执行任务为napi_priority_high优先级，入队方式为队列头部入队",
      "reference_sentence": "",
      "line_num": 68,
      "context": "{\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\",\"71\":\"    static void WorkComplete(napi_env env, napi_status status, void *data) {\",\"72\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"73\":\"        napi_release_threadsafe_function(callbackData->tsfn, napi_tsfn_release);\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "任务优先级为napi_priority_high，入队方式为队列头部。",
      "触发条件": "当句子结构出现\"名词+为...属性名词\"的重复模式（如\"执行任务为...优先级\"）或方式描述中包含重复动作动词（如\"队列头部入队\"的\"入队\"重复）时触发。\n\n识别模式：\n1. 检测\"为\"字结构后是否出现与主语重复的属性名词（如\"任务为...优先级\"）\n2. 检查方式状语中是否包含与上下文动作重复的动词（如\"队列头部入队\"在已明确入队操作的上下文中）"
    },
    {
      "defect_id": 403861,
      "sentence": "在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 26,
      "context": "{\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗长。",
      "更改后示例": "此函数检查对象是否直接拥有某个属性。",
      "触发条件": "句子包含解释性插入语（如括号内容）或冗长的条件状语结构（\"在需要...时\"），且核心功能描述可独立成立。  \n识别模式：检测到括号补充说明、多逗号分句，或存在\"可以使用这个函数\"等冗余引导语时，优先提取主谓宾核心语义进行简化。"
    },
    {
      "defect_id": 403963,
      "sentence": "当依赖发布态字节码HAR包或HSP包时，参与编译的是其中的二进制字节码和声明文件，由于ArkGuard工具只支持源码混淆，不支持字节码混淆，且为了保证声明文件中的接口与二进制中的实现的一致性，不会对这部分代码进行混淆。但是，若三方库未正确提供接口的声明或者未在`consumer-rules`中配置白名单，在HAP中使用这些三方库接口的地方可能会被混淆，此时HAP包开发者可以自行配置，来保证运行时的正确性。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"2. HAP包的开发者需要重点知悉[混淆规则的合并策略](source-obfuscation.md#混淆规则合并策略)，确认清楚了解所有潜在影响本模块编译时混淆规则的情况。\",\"27\":\"\",\"28\":\"3. 在此基础上，还需了解哪种依赖包内的代码会跟随本模块一起参与编译混淆，因为这会影响混淆新生成的名称和部分全局生效（如属性名称）的白名单，从而影响到本模块最终的混淆效果。具体而言：\",\"29\":\"    - 当依赖本地HAR包时，其代码会跟随本模块一起混淆，混淆前后的名称会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"30\":\"    - 当依赖发布态源码HAR包时，安装在工程级`oh_modules`目录下的代码会跟随本模块一起混淆，混淆前后的名称也会体现在本模块的编译中间产物`obfuscation/nameCache.json`文件中。\",\"31\":\"    - 当依赖发布态字节码HAR包或HSP包时，参与编译的是其中的二进制字节码和声明文件，由于ArkGuard工具只支持源码混淆，不支持字节码混淆，且为了保证声明文件中的接口与二进制中的实现的一致性，不会对这部分代码进行混淆。但是，若三方库未正确提供接口的声明或者未在`consumer-rules`中配置白名单，在HAP中使用这些三方库接口的地方可能会被混淆，此时HAP包开发者可以自行配置，来保证运行时的正确性。\",\"32\":\"\",\"33\":\"4. 为保证与发布态三方库交互使用的正确性，ArkGuard会自动收集本模块依赖的安装到`oh_modules`中的模块的export导出名称及其相关属性等名称到不混淆名单中，由于开发者可以引用依赖模块中的任意路径下的文件，这种导出名称的收集并不局限于入口文件如`Index.ets`，而是`oh_modules`三方库中的所有文件中的export导出名称。\",\"34\":\"\",\"35\":\"5. 对于本地源码HAR包和本地HSP包，ArkGuard不会自动收集所有文件中的export导出名称到不混淆名单中。\",\"36\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "依赖发布态字节码HAR包或HSP包时，ArkGuard不混淆字节码，但需配置白名单保证接口正确性。",
      "触发条件": "当句子同时包含多个因果关系的连词（如\"由于\"、\"且为了\"、\"但是，若\"）且存在重复性解释（如\"不支持字节码混淆\"与\"不会对这部分代码进行混淆\"的语义重复）时触发。\n\n识别模式：\n1. 结构特征：复合长句嵌套多个条件状语（\"当...时\"）、原因状语（\"由于...\"）和转折状语（\"但是，若...\"）\n2. 语义特征：同一概念多次以不同形式重复（如\"声明文件中的接口与二进制中的实现的一致性\"与\"接口正确性\"的对应关系）\n3. 冗余标记：存在可合并的并列说明（如\"只支持源码混淆，不支持字节码混淆\"可合并为\"仅支持源码混淆\"）"
    },
    {
      "defect_id": 403859,
      "sentence": "在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "{\"19\":\"| 接口 | 描述 |\",\"20\":\"| -------- | -------- |\",\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗长。",
      "更改后示例": "此接口检查对象中是否存在指定的属性，避免访问不存在属性导致的异常。",
      "触发条件": "句子包含多个分句重复说明同一功能目的，或存在可合并/简化的背景说明与结果描述。\n\n识别模式：  \n1. 复合句式结构（如连续使用\"通过...可以...从而...\"句式）  \n2. 重复性语义要素（如原句同时出现\"检查对象中存在属性\"和\"判断对象包含属性\"）  \n3. 存在可推断的隐性信息（如\"访问前需要检查\"在接口描述场景中属于默认前提）"
    },
    {
      "defect_id": 403998,
      "sentence": "字节码HAR包的混淆适配流程与发布态源码HAR包基本一致。但是由于ArkGuard是源码混淆工具，因此当release编译构建发布一个字节码HAR包时，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，ArkGuard不会对字节码HAR包进行二次混淆。",
      "reference_sentence": "",
      "line_num": 83,
      "context": "{\"78\":\"> - ArkGuard会在使用方（如HAP）混淆时收集本发布态HAR包的export导出名称及其相关属性等名称到不混淆名单中。\",\"79\":\"> - ArkGuard会在使用方（如HAP）混淆时收集本发布态HAR包的obfuscation.txt文件中的白名单，但不会继续收集本HAR包依赖的HAR包（四方库）中的obfuscation.txt文件的白名单（这是由于在构建三方库时，已收集过四方库的名单）。因此，**若发布态HAR包依赖其他HAR包，需要固定其他HAR包的版本号，不应配置自动匹配最新版本。** 否则当四方库升级后，若白名单发生变更，则不会在HAP中生效，易引起稳定性问题。\",\"80\":\"\",\"81\":\"### 发布态字节码HAR包\",\"82\":\"\",\"83\":\"字节码HAR包的混淆适配流程与发布态源码HAR包基本一致。但是由于ArkGuard是源码混淆工具，因此当release编译构建发布一个字节码HAR包时，在构建本模块HAR时会进行一次混淆，当发布后的HAR包被使用方依赖时，如果使用方开启混淆，ArkGuard不会对字节码HAR包进行二次混淆。\",\"84\":\"\",\"85\":\"## HSP包源码混淆\",\"86\":\"\",\"87\":\"### HSP包通用建议\",\"88\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且存在不必要的修饰成分。",
      "更改后示例": "字节码HAR包的混淆流程与发布态源码HAR包一致。release编译时会进行一次混淆，发布后若使用方开启混淆，ArkGuard不会对字节码HAR包进行二次混淆。",
      "触发条件": "句子包含重复性动词短语（如\"构建发布\"/\"构建本模块HAR\"）或冗余限定词（如\"基本一致\"中的\"基本\"），且存在超过两个逗号分隔的复合结构时。当上下文已明确工具属性（如\"ArkGuard是源码混淆工具\"）时仍重复说明相关背景信息。"
    },
    {
      "defect_id": 404520,
      "sentence": "执行任务为napi_priority_low优先级，入队方式为队列尾部入队",
      "reference_sentence": "",
      "line_num": 64,
      "context": "{\"59\":\"    // 异步线程中调用该接口向ArkTS线程投递指定优先级和入队方式的任务\",\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "任务优先级为napi_priority_low，入队方式为队列尾部。",
      "触发条件": "当句子中连续使用\"为X+类别词\"结构（如\"为napi_priority_low优先级\"），且X参数本身已包含类别语义时；或当并列分句采用相同冗余结构（如\"执行任务为...，入队方式为...\"）时。\n\n识别模式：\n1. 检测\"为[参数][类别词]\"结构中参数是否自带类别属性（如napi_priority_low本身就是优先级参数）\n2. 识别并列结构中的重复性说明（如\"执行任务为...\"与\"入队方式为...\"共用相同动词短语时，保留主谓结构一次即可）"
    },
    {
      "defect_id": 403866,
      "sentence": "当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\",\"33\":\"## 使用示例\",\"34\":\"\",\"35\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"36\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗长。",
      "更改后示例": "此接口获取对象的所有属性名称，检查是否包含特定属性名。",
      "触发条件": "句子包含超过两个分句或连续逗号分隔的冗余信息，且存在重复说明使用场景和具体操作步骤的情况。\n\n识别模式：① 复合句式结构（\"当...时，可以...，然后...\"）② 同时包含目的描述和实现细节 ③ 上下文相邻条目呈现\"在需要...时，可以使用...\"的简洁结构形成对比。"
    },
    {
      "defect_id": 403865,
      "sentence": "当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\",\"31\":\"| napi_get_all_property_names | 当需要遍历一个对象的所有属性，并对其进行处理时，可以使用此接口获取所有属性名称的数组，然后检查数组中是否包含特定的属性名。 |\",\"32\":\"\",\"33\":\"## 使用示例\",\"34\":\"\",\"35\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗长。",
      "更改后示例": "此函数在对象中自定义属性，从ArkTS访问和操作这些属性。",
      "触发条件": "当句子包含冗余条件状语结构（如\"当需要...时\"）且存在多个分句重复说明同一操作主体时，或使用介词短语拆分核心语义导致信息密度过低时触发。\n\n识别模式：\n1. 存在\"当需要...时，可以使用...\"的条件状语框架\n2. 出现两个及以上逗号分割的并列介词结构（如\"在...中，从...中\"）\n3. 主谓结构被嵌套在条件从句中导致语义层级复杂化\n4. 包含可合并的重复操作主体说明（如原句中的\"指定Object\"与上下文属性操作场景存在隐含关联）"
    },
    {
      "defect_id": 404007,
      "sentence": "3. 集成态HSP包在发布后会被各方依赖，需要充分验证使用方开启混淆时HSP包接口可以被正常调用。",
      "reference_sentence": "",
      "line_num": 103,
      "context": "{\"98\":\"\",\"99\":\"### 集成态HSP包\",\"100\":\"\",\"101\":\"1. 集成态HSP包要明确对外提供哪些接口及其相关属性，并将这些名称配置到obfuscation-rules.txt中。consumer-rules.txt文件中无需配置，因为打包后的tgz压缩包中包含har与hsp两个子压缩包，har包中的声明文件内定义的对外导出接口及其属性会被自动收集到白名单中。\",\"102\":\"2. 对于集成态HSP包的内部混淆效果，开发者可以参阅[HAP包混淆建议](#hap包混淆建议)中的所有建议。\",\"103\":\"3. 集成态HSP包在发布后会被各方依赖，需要充分验证使用方开启混淆时HSP包接口可以被正常调用。\",\"104\":\"\",\"105\":\"> **说明**\",\"106\":\">\",\"107\":\"> HSP生成`obfuscation.txt`的规则仅来源于当前模块的`consumer-rules.txt`文件，不包括依赖模块的`consumer-rules.txt`文件或`obfuscation.txt`文件。\"}",
      "修改建议": "句子过长，包含多个逗号，且存在不必要的修饰成分。",
      "更改后示例": "集成态HSP包发布后需验证使用方开启混淆时接口可以被正常调用。",
      "触发条件": "当句子包含多个逗号分隔的复杂分句，且存在可删除的修饰成分（如冗余副词、重复性描述或上下文已覆盖的信息）时触发。\n\n识别模式：\n1. **结构特征**：句子被逗号分割为多个分句，存在因果/条件关系的复合结构\n2. **冗余成分**：包含可删除的副词（如\"充分\"\"必要\"等）或重复性描述（如本案例中\"会被各方依赖\"已在上下文第101条说明）\n3. **信息重复**：部分内容已在前文明确说明（如本问题句前半段与第101条内容重复）"
    },
    {
      "defect_id": 404006,
      "sentence": "2. 对于集成态HSP包的内部混淆效果，开发者可以参阅[HAP包混淆建议](#hap包混淆建议)中的所有建议。",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"3. 功能验证时，应同时构建主模块和HSP包，然后验证HSP包提供的全部接口功能。\",\"98\":\"\",\"99\":\"### 集成态HSP包\",\"100\":\"\",\"101\":\"1. 集成态HSP包要明确对外提供哪些接口及其相关属性，并将这些名称配置到obfuscation-rules.txt中。consumer-rules.txt文件中无需配置，因为打包后的tgz压缩包中包含har与hsp两个子压缩包，har包中的声明文件内定义的对外导出接口及其属性会被自动收集到白名单中。\",\"102\":\"2. 对于集成态HSP包的内部混淆效果，开发者可以参阅[HAP包混淆建议](#hap包混淆建议)中的所有建议。\",\"103\":\"3. 集成态HSP包在发布后会被各方依赖，需要充分验证使用方开启混淆时HSP包接口可以被正常调用。\",\"104\":\"\",\"105\":\"> **说明**\",\"106\":\">\",\"107\":\"> HSP生成`obfuscation.txt`的规则仅来源于当前模块的`consumer-rules.txt`文件，不包括依赖模块的`consumer-rules.txt`文件或`obfuscation.txt`文件。\"}",
      "修改建议": "句子过长，包含多个逗号，且存在不必要的修饰成分。",
      "更改后示例": "开发者可以参阅HAP包混淆建议中的所有建议，确保集成态HSP包的内部混淆效果。",
      "触发条件": "句子包含由逗号分隔的前置状语结构（如\"对于...\"）或重复修饰成分（如同时出现介词短语和上下文已明确的主题），导致信息密度降低或句式冗余。  \n\n识别模式：1) 存在\"对于X的Y，主体做Z\"结构，其中X在上下文中已明确；2) 修饰成分与上下文存在语义重复（如\"集成态HSP包\"在段落标题中已声明）；3) 句子被逗号分割为超过两个逻辑单元。"
    },
    {
      "defect_id": 403860,
      "sentence": "在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"| -------- | -------- |\",\"21\":\"| napi_get_property_names | 在进行对象操作或调试时，有时需要获取对象的属性和属性名。此接口可以帮助提取对象的属性名，用于动态获取对象的属性信息的场景。 |\",\"22\":\"| napi_set_property | 通过此接口可以动态地向对象添加属性。也可修改对象的属性值，满足动态属性值变更的需求。 |\",\"23\":\"| napi_get_property | 在调用Node-API模块的函数或方法时，可能需要将ArkTS对象的属性值作为参数传递。通过此接口可以获取属性值，并将其传递给其他函数进行处理。 |\",\"24\":\"| napi_has_property | 在进行属性访问之前，通常需要先检查对象中是否存在指定的属性。通过调用此接口可以判断给定对象是否包含特定的属性，从而避免访问不存在属性导致的异常或错误。 |\",\"25\":\"| napi_delete_property | 在需要删除一个ArkTS对象上的某个属性时，可以使用这个函数。 |\",\"26\":\"| napi_has_own_property | 在需要检查一个ArkTS对象是否直接拥有（而不是从其原型链上继承）某个属性时，可以使用这个函数。 |\",\"27\":\"| napi_set_named_property | 在需要将一个值赋给ArkTS对象的命名属性时，可以使用这个函数。 |\",\"28\":\"| napi_get_named_property | 在需要从ArkTS对象中获取一个命名属性的值时，可以使用这个函数。 |\",\"29\":\"| napi_has_named_property | 在需要检查一个ArkTS对象是否包含某个命名属性时，可以使用这个函数。 |\",\"30\":\"| napi_define_properties | 当需要在指定Object中自定义属性，并从ArkTS中访问和操作这些属性时，可以使用这个函数。 |\"}",
      "修改建议": "句子包含无意义的词语。",
      "更改后示例": "此函数删除对象上的属性。",
      "触发条件": "当句子包含\"在需要...时，可以使用这个函数\"等引导性结构，且核心功能描述被冗余条件状语包裹时触发；或当功能说明中存在与核心动作无关的附加使用场景说明时触发。\n\n识别模式：\n1. 检测\"在需要...时\"/\"当...时\"+动词短语+\"可以使用这个函数\"的句式结构\n2. 验证核心功能是否可简化为\"此函数+动作+对象\"的直述结构（如\"删除对象属性\"）\n3. 对比上下文发现相邻条目均采用\"通过此接口可以...\"的直接表达方式，形成句式冗余的上下文冲突"
    },
    {
      "defect_id": 404519,
      "sentence": "执行任务为napi_priority_idle优先级，入队方式为队列尾部入队",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"    // 异步线程中调用该接口向ArkTS线程投递指定优先级和入队方式的任务\",\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "任务优先级为napi_priority_idle，入队方式为队列尾部。",
      "触发条件": "当句子中同时出现\"执行任务为...优先级\"和\"入队方式为...入队\"的重复结构，且上下文已明确操作对象为任务属性时。\n\n识别模式：1. 存在\"执行任务为X优先级\"结构（可简化为\"任务优先级为X\"） 2. 出现\"入队方式为Y入队\"结构（应简化为\"入队方式为Y\"）。通过检测\"为...优先级\"和\"为...入队\"的冗余属性说明句式触发规则。"
    },
    {
      "defect_id": 404522,
      "sentence": "执行任务为napi_priority_immediate优先级，入队方式为队列尾部入队",
      "reference_sentence": "",
      "line_num": 66,
      "context": "{\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\",\"71\":\"    static void WorkComplete(napi_env env, napi_status status, void *data) {\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "任务优先级为napi_priority_immediate，入队方式为队列尾部。",
      "触发条件": "当句子中同时存在\"为X+属性类别词\"和\"为Y+动作方式词\"的并列结构，且属性值(X/Y)本身已包含类别信息时触发。\n\n识别模式：1) 并列结构中出现语义重复（如\"优先级\"和\"入队方式\"后接的值已自带类别标识）2) 存在可省略的范畴词（如\"执行任务为...优先级\"中的\"优先级\"可删除，因napi_priority_immediate本身就是优先级枚举值）3) 动作方式描述存在冗余（如\"队列尾部入队\"简化为\"队列尾部\"，因入队方式参数true/false已隐含入队动作）"
    },
    {
      "defect_id": 403871,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 323,
      "context": "{\"318\":\"\",\"319\":\"### napi_has_own_property\",\"320\":\"\",\"321\":\"用于检查传入的Object是否具有自己的命名属性，不包括从原型链上继承的属性。\",\"322\":\"\",\"323\":\"cpp部分代码\",\"324\":\"\",\"325\":\"```cpp\",\"326\":\"#include \\\"napi/native_api.h\\\"\",\"327\":\"\",\"328\":\"static napi_value NapiHasOwnProperty(napi_env env, napi_callback_info info)\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中使用模糊的代码引用短语（如\"xx部分代码\"）且未提供具体代码示例时触发；或存在空代码块/仅占位符代码时触发。\n\n识别模式：\n1. 文本包含\"部分代码\"/\"代码示例\"等非具体描述，但未在相邻代码块中展示完整逻辑\n2. 代码块上下文存在抽象说明（如\"### napi_has_own_property\"接口定义）时，需对应具体实现代码\n3. 代码块内容仅含基础框架（如头文件引用、空函数声明）而未展示核心功能实现"
    },
    {
      "defect_id": 403873,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 387,
      "context": "{\"382\":\"\",\"383\":\"### napi_set_named_property\",\"384\":\"\",\"385\":\"用于在传入的ArkTS对象上设置一个命名属性。\",\"386\":\"\",\"387\":\"cpp部分代码\",\"388\":\"\",\"389\":\"```cpp\",\"390\":\"#include \\\"napi/native_api.h\\\"\",\"391\":\"\",\"392\":\"static napi_value NapiSetNamedProperty(napi_env env, napi_callback_info info)\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中存在模糊的代码引用描述（如\"部分代码\"）且未提供具体代码示例时，或使用非必要限定词（如\"部分\"）导致信息冗余时触发。识别模式为：文本包含\"代码\"关键词但无实际代码块，或存在\"部分/示例代码\"等抽象表述而未展示具体实现。"
    },
    {
      "defect_id": 403877,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 509,
      "context": "{\"504\":\"\",\"505\":\"### napi_has_named_property\",\"506\":\"\",\"507\":\"用于检查ArkTS对象中是否包含指定的命名属性。\",\"508\":\"\",\"509\":\"cpp部分代码\",\"510\":\"\",\"511\":\"```cpp\",\"512\":\"#include \\\"napi/native_api.h\\\"\",\"513\":\"\",\"514\":\"static napi_value NapiHasNamedProperty(napi_env env, napi_callback_info info)\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中存在模糊术语（如“部分代码”）且未提供具体示例或必要细节，导致信息冗余且缺乏可操作性时触发。\n\n识别模式：检测到类似“xx部分代码”、“相关代码”等非具体描述，结合上下文（如API参数说明、函数用法）需明确代码示例或实现细节时，判定为冗余表达需修复。"
    },
    {
      "defect_id": 404521,
      "sentence": "执行任务为napi_priority_high优先级，入队方式为队列尾部入队",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"    static void ExecuteWork(napi_env env, void *data) {\",\"61\":\"        CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"62\":\"        // 执行任务为napi_priority_idle优先级，入队方式为队列尾部入队\",\"63\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_idle, true);\",\"64\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_low, true);\",\"65\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, true);\",\"66\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_immediate, true);\",\"67\":\"        // 执行任务为napi_priority_high优先级，入队方式为队列头部入队\",\"68\":\"        napi_call_threadsafe_function_with_priority(callbackData->tsfn, nullptr, napi_priority_high, false);\",\"69\":\"    }\",\"70\":\"\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "任务优先级为napi_priority_high，入队方式为队列尾部。",
      "触发条件": "当句子中同时存在参数值和其对应语义的冗余名词（如\"优先级\"参数后重复出现\"优先级\"字样）或动词（如\"入队方式\"描述后重复出现\"入队\"动作）时触发。\n\n识别模式：检测\"为X+Y\"结构中的Y是否与X的语义重复（例如X是参数值napi_priority_high，Y是参数类型\"优先级\"），或\"方式为X+Y\"结构中Y是否与功能动词重复（例如X是位置描述\"队列尾部\"，Y是重复的\"入队\"动作）。"
    },
    {
      "defect_id": 403875,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 443,
      "context": "{\"438\":\"\",\"439\":\"### napi_get_named_property\",\"440\":\"\",\"441\":\"用于从ArkTS对象中获取命名属性的值。\",\"442\":\"\",\"443\":\"cpp部分代码\",\"444\":\"\",\"445\":\"```cpp\",\"446\":\"#include \\\"napi/native_api.h\\\"\",\"447\":\"\",\"448\":\"static napi_value NapiGetNamedProperty(napi_env env, napi_callback_info info)\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中仅模糊提及代码存在（如“cpp部分代码”）而未具体说明其用途或功能时触发；识别模式为存在“部分代码”等泛化术语且无上下文解释或具体示例。"
    },
    {
      "defect_id": 403881,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 697,
      "context": "{\"692\":\"\",\"693\":\"### napi_get_all_property_names\",\"694\":\"\",\"695\":\"用于获取传入的ArkTS对象的所有属性名。\",\"696\":\"\",\"697\":\"cpp部分代码\",\"698\":\"\",\"699\":\"```cpp\",\"700\":\"#include \\\"napi/native_api.h\\\"\",\"701\":\"\",\"702\":\"static napi_value GetAllPropertyNames(napi_env env, napi_callback_info info)\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中存在占位符式抽象描述（如\"xxx部分代码\"）且未提供具体示例时触发，尤其在需展示代码实现的上下文中（如API接口说明后的代码示例区块）。"
    },
    {
      "defect_id": 403879,
      "sentence": "cpp部分代码",
      "reference_sentence": "",
      "line_num": 572,
      "context": "{\"567\":\"\",\"568\":\"### napi_define_properties\",\"569\":\"\",\"570\":\"用于定义对象的属性。\",\"571\":\"\",\"572\":\"cpp部分代码\",\"573\":\"\",\"574\":\"```cpp\",\"575\":\"#include <string>\",\"576\":\"#include \\\"napi/native_api.h\\\"\",\"577\":\"\"}",
      "修改建议": "缺乏具体性，应直接陈述内容。",
      "更改后示例": "cpp代码示例",
      "触发条件": "当文档中存在泛化描述（如“X部分代码”）且紧随其后或上下文中已包含具体代码块（如```cpp）时，或当语句仅声明存在代码但未提供具体功能/实现说明时触发。\n\n识别模式：\n1. 匹配“部分代码”等模糊表达，且上下文存在代码块标记（如```lang）；\n2. 验证当前段落是否已通过代码示例/接口名称明确技术内容，使该描述失去信息价值。"
    },
    {
      "defect_id": 403979,
      "sentence": "Node-API支持异步操作，这对于处理IO密集型或计算密集型的任务非常重要，因为这些任务通常需要非阻塞的执行方式以避免阻塞主线程。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用Node-API的自定义异步操作功能，可以使ArkTS的使用更加灵活和高效，可以处理那些可能阻塞事件循环的长时间运行任务，同时保持ArkTS应用的响应性和性能。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"Node-API支持异步操作，这对于处理IO密集型或计算密集型的任务非常重要，因为这些任务通常需要非阻塞的执行方式以避免阻塞主线程。以下是一些关于自定义异步操作的基本概念：\",\"10\":\"\",\"11\":\"- **异步模型：** Node-API支持异步模型，提供了Promise和Callback两种方式来实现异步操作。Promise是一种基于未来值的编程模型，它允许开发者将异步操作的结果封装在一个对象中，并通过链式调用的方式处理异步操作的结果。Callback则是一种传统的异步编程方式，通过回调函数来处理异步操作的结果。\",\"12\":\"- **临时结果：** 当原生方法（即Node-API代码）被调用时，它会立即返回一个临时结果给ArkTS调用者。这个临时结果通常是一个表示异步操作正在进行中的标志，或者是用于后续处理异步操作结果的句柄。\",\"13\":\"- **回调或Promise：** 当异步操作完成后，结果会通过回调函数或Promise对象返回给ArkTS调用者。这样，ArkTS代码就可以在异步操作完成后继续执行后续的逻辑。\",\"14\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，可以拆分成多个简短的句子。",
      "更改后示例": "Node-API支持异步操作，这有助于处理IO密集型或计算密集型任务。这些任务通常需要非阻塞的执行方式，以避免阻塞主线程。",
      "触发条件": "当句子结构包含由连词（如“因为”“因此”）引导的冗余解释性从句，且上下文已隐含或重复相同逻辑时触发；或单句超过25字并承载多个信息点，导致可读性降低时触发。"
    },
    {
      "defect_id": 404760,
      "sentence": "可以在需要执行耗时操作的场景中使用，以避免阻塞env所在的ArkTS线程，确保应用程序的性能和响应性能。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 使用Node-API接口进行异步任务开发\",\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"[napi_create_async_work](../reference/native-lib/napi.md#napi_create_async_work)是Node-API接口之一，用于创建一个异步工作对象。可以在需要执行耗时操作的场景中使用，以避免阻塞env所在的ArkTS线程，确保应用程序的性能和响应性能。例如以下场景：\",\"6\":\"\",\"7\":\"- 文件操作：读取大型文件或执行复杂的文件操作时，可以使用异步工作对象来避免阻塞env所在的ArkTS线程。\",\"8\":\"\",\"9\":\"- 网络请求：当需要进行网络请求并等待响应时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的响应性能。\",\"10\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "在需要执行耗时操作的场景中使用，避免阻塞env所在的ArkTS线程，确保应用程序的性能和响应性能。",
      "触发条件": "当句子中出现\"以+动词\"引导的目的状语从句，且后续存在多个逗号分隔的同类结果分句时触发。识别模式需满足：(1)包含\"以避免/为了/以便\"等引导词 (2)连续出现两个及以上由逗号分隔的动宾结构结果分句 (3)总逗号数量≥2造成句式拖沓。"
    },
    {
      "defect_id": 404664,
      "sentence": "    3. 增强日志输出：在疑似异常的功能代码中，对处理的数据字段添加日志记录。",
      "reference_sentence": "",
      "line_num": 26,
      "context": "{\"21\":\"6. 应用在运行时未崩溃但出现功能异常（如白屏）的分析方法：\",\"22\":\"    1. 打开应用运行日志：选择HiLog，检索与功能异常直接相关的日志，定位问题发生的上下文。\",\"23\":\"\",\"24\":\"    2. 定位异常代码段：分析日志，找到导致功能异常的具体代码块。\",\"25\":\"\",\"26\":\"    3. 增强日志输出：在疑似异常的功能代码中，对处理的数据字段添加日志记录。\",\"27\":\"\",\"28\":\"    4. 分析并确定关键字段：通过分析新增的日志输出，判断数据异常是否由混淆引起。\",\"29\":\"\",\"30\":\"    5. 配置白名单以保护关键字段：将确认在混淆后对应用功能产生直接影响的关键字段添加到白名单中。\",\"31\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "3. 增强日志输出。在疑似异常的功能代码中，对处理的数据字段添加日志记录。",
      "触发条件": "当句子使用冒号引导超过一个逗号分隔的分句，且存在可拆分或冗余的修饰成分（如\"疑似异常的\"）时触发。\n\n识别模式：\n1. 结构特征：冒号后接复合句（含逗号分隔的多个分句）\n2.语言特征：包含非必要的限定词（如\"疑似\"）+ 重复性描述（\"功能代码\"与上下文已明确的\"功能异常\"重复）\n3. 可优化指标：单句超过15字且包含2个以上逗号，存在可独立成句的语义单元"
    },
    {
      "defect_id": 404761,
      "sentence": "当需要进行网络请求并等待响应时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的响应性能。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"[napi_create_async_work](../reference/native-lib/napi.md#napi_create_async_work)是Node-API接口之一，用于创建一个异步工作对象。可以在需要执行耗时操作的场景中使用，以避免阻塞env所在的ArkTS线程，确保应用程序的性能和响应性能。例如以下场景：\",\"6\":\"\",\"7\":\"- 文件操作：读取大型文件或执行复杂的文件操作时，可以使用异步工作对象来避免阻塞env所在的ArkTS线程。\",\"8\":\"\",\"9\":\"- 网络请求：当需要进行网络请求并等待响应时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的响应性能。\",\"10\":\"\",\"11\":\"- 数据库操作：当需要执行复杂的数据库查询或写入操作时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的并发性能。\",\"12\":\"\",\"13\":\"- 图像处理：当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。\",\"14\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "当需要进行网络请求并等待响应时，使用异步工作对象确保主线程不被阻塞，提高应用程序的响应性能。",
      "触发条件": "当句子中出现由冗余连接词（如\"从而\"）或重复功能词（如\"可以\"）连接的多个连动分句，且删除这些词后不影响语义完整性时触发。\n\n识别模式：1.存在\"可以确保..., 从而...\"这类递进式冗余结构 2.多个分句间存在因果关系但已通过上下文隐含，仍使用显式连接词 3.连续分句共享同一主语但重复使用主谓结构"
    },
    {
      "defect_id": 404763,
      "sentence": "当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"- 网络请求：当需要进行网络请求并等待响应时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的响应性能。\",\"10\":\"\",\"11\":\"- 数据库操作：当需要执行复杂的数据库查询或写入操作时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的并发性能。\",\"12\":\"\",\"13\":\"- 图像处理：当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。\",\"14\":\"\",\"15\":\"napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。\",\"16\":\"\",\"17\":\"异步调用支持callback方式和Promise方式，使用哪种方式由应用开发者决定。下面为两种方式的示例代码：\",\"18\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象确保主线程不被阻塞，提高应用程序的实时性能。",
      "触发条件": "当句子包含连续由逗号连接的多个分句，且存在冗余连接词（如\"可以\"\"从而\"）或重复逻辑时触发。\n\n识别模式需检测以下特征：\n1. 结构特征：超过3个逗号分隔的复合句式，存在\"A，B，C\"型连续分句\n2. 冗余标记：包含\"可以确保...从而...\"等递进连接词，且后置分句与前文构成因果关系\n3. 重复逻辑：后置分句（如\"提高性能\"）本质上是前文操作（\"确保主线程不阻塞\"）的自然结果"
    },
    {
      "defect_id": 404769,
      "sentence": "4. 模块初始化以及ArkTS侧调用接口。",
      "reference_sentence": "",
      "line_num": 92,
      "context": "{\"87\":\"       delete callbackData;\",\"88\":\"       callbackData = nullptr;\",\"89\":\"   }\",\"90\":\"   ```\",\"91\":\"\",\"92\":\"4. 模块初始化以及ArkTS侧调用接口。\",\"93\":\"\",\"94\":\"   ```cpp\",\"95\":\"   // 模块初始化\",\"96\":\"   static napi_value Init(napi_env env, napi_value exports)\",\"97\":\"   {\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "4. 模块初始化和ArkTS侧调用接口。",
      "触发条件": "句子中使用冗长连接词（如\"以及\"）连接并列成分，且存在更简洁的同义连接词（如\"和\"）可替代时；或并列结构因复杂连词导致句式冗余时。"
    },
    {
      "defect_id": 404666,
      "sentence": "    5. 配置白名单以保护关键字段：将确认在混淆后对应用功能产生直接影响的关键字段添加到白名单中。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"\",\"26\":\"    3. 增强日志输出：在疑似异常的功能代码中，对处理的数据字段添加日志记录。\",\"27\":\"\",\"28\":\"    4. 分析并确定关键字段：通过分析新增的日志输出，判断数据异常是否由混淆引起。\",\"29\":\"\",\"30\":\"    5. 配置白名单以保护关键字段：将确认在混淆后对应用功能产生直接影响的关键字段添加到白名单中。\",\"31\":\"\",\"32\":\"#### 排查非预期的混淆能力\",\"33\":\"若出现预期外的混淆效果，检查是否由于依赖的本地模块或三方库开启了某些混淆选项。\",\"34\":\"\",\"35\":\"示例：\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "5. 配置白名单以保护关键字段。将确认在混淆后对应用功能产生直接影响的关键字段添加到白名单中。",
      "触发条件": "当句子使用冒号或逗号连接超过两个分句，且存在重复性修饰语（如\"确认\"\"直接\"等冗余限定词）时触发。\n\n识别模式：通过标点符号（冒号/逗号）识别复合句式结构，结合语义分析检测重复限定成分（如\"确认在混淆后对应用功能产生直接影响的\"中\"确认\"和\"直接影响\"存在语义重叠）。"
    },
    {
      "defect_id": 404768,
      "sentence": "3. 定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\",\"68\":\"       callbackData->result = callbackData->args;\",\"69\":\"   }\",\"70\":\"   ```\",\"71\":\"\",\"72\":\"3. 定义异步任务的第二个回调函数，该函数在主线程执行，将结果传递给ArkTS侧。\",\"73\":\"\",\"74\":\"   ```cpp\",\"75\":\"   static void CompleteCB(napi_env env, napi_status status, void *data)\",\"76\":\"   {\",\"77\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "3. 定义异步任务的第二个回调函数，在主线程执行，将结果传递给ArkTS侧。",
      "触发条件": "当句子中存在重复的主语指代（如\"该函数\"）且使用多个逗号分隔从句时，或当分句间存在可简化的同位语结构时触发。识别模式为连续逗号分隔的从句中包含重复名词短语或冗余代词（如\"该X\"），导致句子结构臃肿。"
    },
    {
      "defect_id": 404889,
      "sentence": "Node-API接口执行前一般会进行入参校验，首先进行的是判空校验。在代码中体现为：",
      "reference_sentence": "",
      "line_num": 58,
      "context": "{\"53\":\"\",\"54\":\"## Node-API接口返回值不是napi_ok时，如何排查定位\",\"55\":\"\",\"56\":\"Node-API接口正常执行后，会返回一个napi_ok的状态枚举值，若napi接口返回值不为napi_ok，可从以下几个方面进行排查。\",\"57\":\"\",\"58\":\"- Node-API接口执行前一般会进行入参校验，首先进行的是判空校验。在代码中体现为：\",\"59\":\"\",\"60\":\"  ```cpp\",\"61\":\"  CHECK_ENV： env判空校验\",\"62\":\"  CHECK_ARG：其它入参判空校验\",\"63\":\"  ```\"}",
      "修改建议": "句子结构复杂，可以拆分",
      "更改后示例": "Node-API接口执行前会进行入参校验，首先进行判空校验。具体代码如下：",
      "触发条件": "当句子中同时存在\"一般会\"等冗余限定副词和\"进行的是\"等重复性动词结构，且上下文已明确描述标准流程时触发。识别模式为检查技术文档中\"副词+动词\"与\"动词+的是\"的叠加使用情况。"
    },
    {
      "defect_id": 404762,
      "sentence": "当需要执行复杂的数据库查询或写入操作时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的并发性能。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"- 文件操作：读取大型文件或执行复杂的文件操作时，可以使用异步工作对象来避免阻塞env所在的ArkTS线程。\",\"8\":\"\",\"9\":\"- 网络请求：当需要进行网络请求并等待响应时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的响应性能。\",\"10\":\"\",\"11\":\"- 数据库操作：当需要执行复杂的数据库查询或写入操作时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的并发性能。\",\"12\":\"\",\"13\":\"- 图像处理：当需要对大型图像进行处理或执行复杂的图像算法时，使用异步工作对象可以确保主线程不被阻塞，从而提高应用程序的实时性能。\",\"14\":\"\",\"15\":\"napi_queue_async_work接口底层使用了uv_queue_work能力，并对回调中的napi_value的生命周期管理进行了兜底。\",\"16\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "当需要执行复杂的数据库查询或写入操作时，使用异步工作对象确保主线程不被阻塞，提高应用程序的并发性能。",
      "触发条件": "句子中存在冗余连接词（如\"可以\"\"从而\"）且包含多个逗号分隔的复杂结构时触发；当上下文存在平行句式且当前句子出现非必要修饰词时触发。\n\n识别模式：\n1. 检测\"可以+动词\"/\"从而+动词\"的冗余结构（如\"可以确保\"→\"确保\"）\n2. 分析逗号数量（≥2）及子句逻辑关系，判断是否存在可合并的因果表达\n3. 对比上下文平行结构（如其他列表项均未使用\"可以/从而\"时优先触发）"
    },
    {
      "defect_id": 404767,
      "sentence": "2. 定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。",
      "reference_sentence": "",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"      return promise;\",\"59\":\"   }\",\"60\":\"   ```\",\"61\":\"\",\"62\":\"2. 定义异步任务的第一个回调函数，该函数在工作线程中执行，处理具体的业务逻辑。\",\"63\":\"\",\"64\":\"   ```cpp\",\"65\":\"   static void ExecuteCB(napi_env env, void *data)\",\"66\":\"   {\",\"67\":\"       CallbackData *callbackData = reinterpret_cast<CallbackData *>(data);\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "2. 定义异步任务的第一个回调函数，在工作线程中执行，处理业务逻辑。",
      "触发条件": "句子中存在重复指代（如\"该函数\"指代前文已明确的主语）或冗余修饰词（如\"具体的\"），且伴随多个逗号分隔的从句导致结构冗余时触发。"
    },
    {
      "defect_id": 404665,
      "sentence": "    4. 分析并确定关键字段：通过分析新增的日志输出，判断数据异常是否由混淆引起。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"    2. 定位异常代码段：分析日志，找到导致功能异常的具体代码块。\",\"25\":\"\",\"26\":\"    3. 增强日志输出：在疑似异常的功能代码中，对处理的数据字段添加日志记录。\",\"27\":\"\",\"28\":\"    4. 分析并确定关键字段：通过分析新增的日志输出，判断数据异常是否由混淆引起。\",\"29\":\"\",\"30\":\"    5. 配置白名单以保护关键字段：将确认在混淆后对应用功能产生直接影响的关键字段添加到白名单中。\",\"31\":\"\",\"32\":\"#### 排查非预期的混淆能力\",\"33\":\"若出现预期外的混淆效果，检查是否由于依赖的本地模块或三方库开启了某些混淆选项。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "4. 分析并确定关键字段。通过分析新增的日志输出，判断数据异常是否由混淆引起。",
      "触发条件": "当步骤说明中冒号后的内容同时包含操作方法和结果判断（超过一个完整语义单元），且存在重复性介词结构（如\"通过分析...\"）时触发。\n\n识别模式：1）检查步骤说明是否采用\"标题：内容\"结构 2）分析冒号后内容是否包含多个逗号分隔的复合句式 3）检测是否存在重复的介词引导结构（如\"通过...\"+\"通过...\"）或同源动词重复（如\"分析并确定\"）"
    },
    {
      "defect_id": 404766,
      "sentence": "1. 使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"## 使用Promise方式示例\",\"22\":\"\",\"23\":\"![NAPI Promise异步流程](figures/napi_async_work_with_promise.png)\",\"24\":\"\",\"25\":\"1. 使用napi_create_async_work创建异步任务，并使用napi_queue_async_work将异步任务加入队列，等待执行。\",\"26\":\"\",\"27\":\"   ```cpp\",\"28\":\"   // 调用方提供的data context，该数据会传递给execute和complete函数\",\"29\":\"   struct CallbackData {\",\"30\":\"       napi_async_work asyncWork = nullptr;\"}",
      "修改建议": "句子过长，包含多个逗号，需要简化。",
      "更改后示例": "1. 使用napi_create_async_work创建异步任务，使用napi_queue_async_work将任务加入队列，等待执行。",
      "触发条件": "同一句子中连续使用相同动词结构（如“使用...并使用...”）或重复冗余的名词修饰词（如“异步任务”重复出现），导致句式冗余。  \n识别模式：检测逗号分隔的并列结构中是否存在重复的动词前缀（如“使用”）、冗余连接词（如“并”）或重复的名词限定词（如“异步”），且上下文已明确语义无需重复强调时触发。"
    },
    {
      "defect_id": 404808,
      "sentence": "   // ExecuteWork会执行在一个由libuv创建的非JS线程上，此处使用napi_create_async_work是为了模拟在非JS线程场景使用napi_call_threadsafe_function接口向JS线程提交任务",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"       napi_create_string_utf8(env, \\\"Thread-safe Function Demo\\\", NAPI_AUTO_LENGTH, &resourceName);\",\"39\":\"       napi_create_threadsafe_function(env, jsCb, nullptr, resourceName, 0, 1, callbackData, nullptr,\",\"40\":\"           callbackData, CallJs, &callbackData->tsfn);\",\"41\":\"\",\"42\":\"       // 创建一个异步任务\",\"43\":\"       // ExecuteWork会执行在一个由libuv创建的非JS线程上，此处使用napi_create_async_work是为了模拟在非JS线程场景使用napi_call_threadsafe_function接口向JS线程提交任务\",\"44\":\"       napi_create_async_work(env, nullptr, resourceName, ExecuteWork, WorkComplete, callbackData,\",\"45\":\"           &callbackData->work);\",\"46\":\"\",\"47\":\"       // 将异步任务加入到异步队列中\",\"48\":\"       napi_queue_async_work(env, callbackData->work);\"}",
      "修改建议": "注释过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "   // ExecuteWork在非JS线程上执行，使用napi_create_async_work模拟非JS线程场景，向JS线程提交任务。",
      "触发条件": "注释或语句中存在由多个逗号分隔的冗余分句，且包含可被上下文覆盖/简化的重复性修饰成分（如已知技术细节、接口名称或场景描述）。\n\n识别模式：\n1. 长句拆分：检测超过2个逗号分隔的从句结构\n2. 冗余修饰识别：定位\"为了...\"/\"由...创建\"/\"使用...接口\"等可省略的技术实现细节\n3. 上下文重复：对比相邻代码/注释是否已包含同类信息（如问题上下文的42行已说明\"创建异步任务\"，43行无需重复描述创建目的）"
    },
    {
      "defect_id": 404883,
      "sentence": "如果存在异常，则会打印出occur exception need return日志，并打印出检查点所在的行号，以及对应的Node-API接口名称。",
      "reference_sentence": "",
      "line_num": 38,
      "context": "{\"33\":\"| module xxx is not allowed to load in restricted runtime. | 该模块不允许在受限运行时中使用，xxx表示模块名，建议用户删除该模块。 |\",\"34\":\"| module xxx is in blocklist, loading prohibited. | 该模块不允许在当前extension下使用，xxx表示模块名，建议用户删除该模块。 |\",\"35\":\"\",\"36\":\"## 接口执行结果非预期，日志显示occur exception need return\",\"37\":\"\",\"38\":\"部分Node-API接口在调用结束前会进行检查，检查虚拟机中是否存在JS异常。如果存在异常，则会打印出occur exception need return日志，并打印出检查点所在的行号，以及对应的Node-API接口名称。\",\"39\":\"\",\"40\":\"解决此类问题有以下两种思路：\",\"41\":\"\",\"42\":\"- 若该异常开发者不关心，可以选择直接清除。\",\"43\":\"  可直接使用napi接口napi_get_and_clear_last_exception，清理异常。调用时机：在打印occur exception need return日志的接口之前调用。\"}",
      "修改建议": "句子过长，超过5个逗号",
      "更改后示例": "如果存在异常，会打印occur exception need return日志，显示检查点行号和Node-API接口名称。",
      "触发条件": "当句子中存在连续重复的动词结构（如\"打印出...，并打印出...\"）或超过3个由逗号分隔的并列分句时，触发冗余表达规则。\n\n识别模式：  \n1. **重复动词检测**：识别连续分句中重复使用相同动词（如\"打印出\"），且语义重叠的句式。  \n2. **分句复杂度判断**：通过逗号数量（≥3个）或连词（如\"并\"、\"以及\"）连接的并列结构数量（≥2组）判定冗余。"
    },
    {
      "defect_id": 405460,
      "sentence": "4. **内存操作**：能够截取部分FastBuffer、切片以及合并多个FastBuffer，便于数据流的处理和管理。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。\",\"40\":\"\",\"41\":\"3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"42\":\"\",\"43\":\"4. **内存操作**：能够截取部分FastBuffer、切片以及合并多个FastBuffer，便于数据流的处理和管理。\",\"44\":\"\",\"45\":\"FastBuffer模块各接口使用详见：[@ohos.fastbuffer](../reference/apis-arkts/js-apis-fastbuffer.md)。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "支持截取部分FastBuffer、切片和合并多个FastBuffer。",
      "触发条件": "句子中出现多个并列成分且存在重复修饰词（如\"部分\"、\"多个\"等冗余限定词），或使用解释性短语（如\"便于...\"）补充本已明确的功能描述时。\n\n识别模式：1) 检查并列结构中是否包含可合并的同类操作（如\"截取部分\"和\"切片\"）；2) 分析修饰成分是否与上下文存在语义重复（如\"合并多个\"在操作语境中已隐含数量）；3) 判断句末解释性短语是否必要（根据前后文判断功能价值是否已明确）。"
    },
    {
      "defect_id": 405220,
      "sentence": "[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句子过长，逗号数超过5个",
      "更改后示例": "[Node-API扩展能力接口](../napi/use-napi-about-extension.md)扩展了NAPI的功能，提供额外的接口，用于与ArkTS更灵活的交互和定制。这些接口可用于创建自定义ArkTS对象。开发者还可以参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)进行跨语言功能开发。",
      "触发条件": "句子中存在多个冗余修饰词（如“进一步”、“一些”、“等场景”）或重复性介词短语（如“在NAPI模块中”），且逗号数量超过4个导致句子结构臃肿时触发。\n\n识别模式：\n1. **冗余词汇检测**：通过词库匹配修饰词（进一步/一些/等场景/可以用于）与上下文重复的限定词（如模块名重复出现）\n2. **结构复杂度判断**：当单句逗号≥3个或分句≥3层时，需检查是否存在可合并/简化的并列结构\n3. **上下文相关性验证**：若前文已明确主体（如\"Node-API模块\"），则删除重复限定词（如\"在NAPI模块中\"）"
    },
    {
      "defect_id": 404894,
      "sentence": "当在env即将退出，但tsfn的引用计数未被归零时，应该使用 `napi_tsfn_abort` 模式调用 `napi_release_threadsafe_function` 方法，确保在env释放后不再对tsfn进行持有及使用。在env退出后，继续持有tsfn进行使用，是一种未定义的行为，可能会触发崩溃。",
      "reference_sentence": "",
      "line_num": 84,
      "context": "{\"79\":\"\",\"80\":\"## napi_threadsafe_function内存泄漏，应该如何处理\",\"81\":\"\",\"82\":\"`napi_threadsafe_function`（下文简称tsfn）在使用时，常常会调用 `napi_acquire_threadsafe_function` 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 `napi_tsfn_release` 模式调用 `napi_release_threadsafe_function` 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 `napi_acquire_threadsafe_function` 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。\",\"83\":\"\",\"84\":\"当在env即将退出，但tsfn的引用计数未被归零时，应该使用 `napi_tsfn_abort` 模式调用 `napi_release_threadsafe_function` 方法，确保在env释放后不再对tsfn进行持有及使用。在env退出后，继续持有tsfn进行使用，是一种未定义的行为，可能会触发崩溃。\",\"85\":\"\",\"86\":\"如下代码将展示通过注册 `env_cleanup` 钩子函数的方式，以确保在env退出后不再继续持有tsfn。\",\"87\":\"\",\"88\":\"```cpp\",\"89\":\"//napi_init.cpp\"}",
      "修改建议": "句子过长，可以拆分",
      "更改后示例": "当env即将退出但tsfn的引用计数未归零时，应使用`napi_tsfn_abort`模式调用`napi_release_threadsafe_function`，确保env释放后不再持有tsfn。继续持有tsfn可能会触发未定义行为，导致崩溃。",
      "触发条件": "同一核心概念（如\"env释放后不再持有tsfn\"）在相邻分句中被重复强调，且存在语义重叠的动词短语（如\"进行持有及使用\"/\"继续持有使用\"）。当句子包含超过两个相同技术实体的重复指代（如\"tsfn\"出现4次）且存在可合并的同质警示（如\"未定义行为\"与\"触发崩溃\"的因果关系重复）时触发。"
    },
    {
      "defect_id": 405218,
      "sentence": "其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# ArkTS跨语言交互\",\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句子过长，逗号数超过5个",
      "更改后示例": "OpenHarmony的Node-API是Node.js社区的拓展版本，不完全兼容Node.js社区的Node API。",
      "触发条件": "同一名词短语在单句中重复出现超过两次，或句子结构存在可合并的并列分句导致逗号数量超过3个。\n\n识别模式：1) 检测句子中是否存在重复的名词性成分（如案例中\"Node.js社区\"重复出现）2) 分析句子结构是否包含可简化的并列关系（如案例中\"是...\"与\"与...\"两个分句可合并）3) 统计逗号数量超过3个且存在语义重复现象。"
    },
    {
      "defect_id": 404895,
      "sentence": "如下代码将展示通过注册 `env_cleanup` 钩子函数的方式，以确保在env退出后不再继续持有tsfn。",
      "reference_sentence": "",
      "line_num": 86,
      "context": "{\"81\":\"\",\"82\":\"`napi_threadsafe_function`（下文简称tsfn）在使用时，常常会调用 `napi_acquire_threadsafe_function` 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 `napi_tsfn_release` 模式调用 `napi_release_threadsafe_function` 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 `napi_acquire_threadsafe_function` 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。\",\"83\":\"\",\"84\":\"当在env即将退出，但tsfn的引用计数未被归零时，应该使用 `napi_tsfn_abort` 模式调用 `napi_release_threadsafe_function` 方法，确保在env释放后不再对tsfn进行持有及使用。在env退出后，继续持有tsfn进行使用，是一种未定义的行为，可能会触发崩溃。\",\"85\":\"\",\"86\":\"如下代码将展示通过注册 `env_cleanup` 钩子函数的方式，以确保在env退出后不再继续持有tsfn。\",\"87\":\"\",\"88\":\"```cpp\",\"89\":\"//napi_init.cpp\",\"90\":\"#include <hilog/log.h> // hilog, 输出日志, 需链接 libhilog_ndk.z.so\",\"91\":\"#include <thread> // 创建线程\"}",
      "修改建议": "句子结构复杂，可以简化",
      "更改后示例": "以下代码展示通过注册`env_cleanup`钩子函数，确保env退出后不再持有tsfn。",
      "触发条件": "当句子出现冗余结构词（如\"的方式\"、\"将\"等）或重复性副词（如\"继续\"），导致表达累赘且不影响核心语义时触发。\n\n识别模式：\n1. 存在可删除的介词结构：通过...的方式 → 通过...\n2. 冗余时态助词：将展示 → 展示\n3. 重复性动作副词：不再继续持有 → 不再持有\n4. 复杂句式结构：包含多个连词/修饰语但未增加新信息"
    },
    {
      "defect_id": 405459,
      "sentence": "3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "{\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\",\"39\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。\",\"40\":\"\",\"41\":\"3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"42\":\"\",\"43\":\"4. **内存操作**：能够截取部分FastBuffer、切片以及合并多个FastBuffer，便于数据流的处理和管理。\",\"44\":\"\",\"45\":\"FastBuffer模块各接口使用详见：[@ohos.fastbuffer](../reference/apis-arkts/js-apis-fastbuffer.md)。\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "提供FastBuffer与基本类型（如Uint8Array、string）之间的转换方法。",
      "触发条件": "当句子包含重复性修饰语（如\"互相\"在已有\"之间\"的情况下）或非必要的功能用途说明（如\"满足...需求\"类补充解释），且上下文已具备相同表达模式时应触发。识别模式需检测是否存在语义重复成分（如双向动词+双向介词）和与核心功能无关的附加说明短语。"
    },
    {
      "defect_id": 405457,
      "sentence": "1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"当构造FastBuffer的入参为number | FastBuffer | Uint8Array | ArrayBuffer | Array\\\\<number\\\\> | string时，推荐使用FastBuffer，可以高效处理大量二进制数据，如图片处理和文件接收上传等。\",\"34\":\"\",\"35\":\"FastBuffer模块的核心功能包括：\",\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\",\"39\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。\",\"40\":\"\",\"41\":\"3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"42\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "允许基于uint32指定大小初始化FastBuffer，创建后内存容量固定。",
      "触发条件": "句子中出现重复限定词（如\"限制的指定\"）、冗余名词（如\"开发者\"在上下文明确时）或可合并的动词结构（如\"拥有固定的\"简化为\"固定\"），且句子长度超过25字导致信息密度降低。\n\n识别模式：1) 检查连续修饰短语中是否存在语义重叠（如\"uint32限制的指定\"→保留\"uint32指定\"）；2) 删除不影响核心语义的施动主体（如上下文已明确开发者身份时）；3) 将\"动词+形容词+名词\"结构压缩为\"形容词+名词\"（如\"拥有固定的内存容量\"→\"内存容量固定\"）。"
    },
    {
      "defect_id": 405468,
      "sentence": "容器类采用类似静态语言的方式来实现，通过限制存储位置和属性，确保每种类型的数据都能在完成自身功能的同时去除冗余逻辑，从而实现高效的数据访问，提升应用性能。",
      "reference_sentence": "",
      "line_num": 5,
      "context": "{\"1\":\"# 容器类库概述\",\"2\":\"\",\"3\":\"容器类库用于存储各种数据类型的元素，并提供一系列处理数据元素的方法，作为纯数据结构容器来使用具有一定的优势。\",\"4\":\"\",\"5\":\"容器类采用类似静态语言的方式来实现，通过限制存储位置和属性，确保每种类型的数据都能在完成自身功能的同时去除冗余逻辑，从而实现高效的数据访问，提升应用性能。\",\"6\":\"\",\"7\":\"当前提供了线性和非线性两类容器。[线性容器](linear-container.md)和[非线性容器](nonlinear-container.md)都是非多线程安全的。\"}",
      "修改建议": "原句过长，包含多个逗号，且有冗余信息。",
      "更改后示例": "容器类采用静态语言方式实现，限制存储位置和属性，去除冗余逻辑，实现高效数据访问，提升性能。",
      "触发条件": "单句包含超过三个逗号分隔的复合结构，且存在可合并/删除的重复性动词短语(如\"实现...来实现\")或冗余修饰词(如\"类似\"\"同时\")。\n\n识别模式：当长句出现连续动作描述(\"采用...通过...确保...去除...实现...提升\")，且存在上下文已隐含的重复表达(如\"完成自身功能\"在前文已定义)时，需触发冗余表达规则。"
    },
    {
      "defect_id": 404891,
      "sentence": "还有一些接口会对其执行结果进行校验。比如napi_call_function这个接口，其功能是执行一个JS function，当JS function中出现异常时，Node-API将会返回napi_pending_exception的状态值。",
      "reference_sentence": "",
      "line_num": 71,
      "context": "{\"66\":\"\",\"67\":\"  ```cpp\",\"68\":\"  RETURN_STATUS_IF_FALSE(env, nativeValue->TypeOf() == NATIVE_NUMBER, napi_number_expected);\",\"69\":\"  ```\",\"70\":\"\",\"71\":\"- 还有一些接口会对其执行结果进行校验。比如napi_call_function这个接口，其功能是执行一个JS function，当JS function中出现异常时，Node-API将会返回napi_pending_exception的状态值。\",\"72\":\"\",\"73\":\"  ```cpp\",\"74\":\"  auto resultValue = engine->CallFunction(nativeRecv, nativeFunc, nativeArgv, argc);\",\"75\":\"  RETURN_STATUS_IF_FALSE(env, resultValue != nullptr, napi_pending_exception)\",\"76\":\"  ```\"}",
      "修改建议": "句子结构复杂，可以拆分",
      "更改后示例": "某些接口会对其执行结果进行校验。例如，napi_call_function接口执行JS function时，若JS function中出现异常，Node-API将返回napi_pending_exception。相关校验代码如下：",
      "触发条件": "当句子中存在重复限定词（如\"这个接口\"）、冗余解释（如\"其功能是\"）或可简化的复合结构（如\"返回...的状态值\"）时触发。识别模式包括重复性修饰语、功能说明冗余及名词短语中不必要的附加词。"
    },
    {
      "defect_id": 404893,
      "sentence": "`napi_threadsafe_function`（下文简称tsfn）在使用时，常常会调用 `napi_acquire_threadsafe_function` 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 `napi_tsfn_release` 模式调用 `napi_release_threadsafe_function` 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 `napi_acquire_threadsafe_function` 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。",
      "reference_sentence": "",
      "line_num": 82,
      "context": "{\"77\":\"\",\"78\":\"- 还有一些状态值需要根据相应Node-API接口具体分析：确认具体的状态值，分析这个状态值在什么情况下会返回，再排查具体出错原因。\",\"79\":\"\",\"80\":\"## napi_threadsafe_function内存泄漏，应该如何处理\",\"81\":\"\",\"82\":\"`napi_threadsafe_function`（下文简称tsfn）在使用时，常常会调用 `napi_acquire_threadsafe_function` 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 `napi_tsfn_release` 模式调用 `napi_release_threadsafe_function` 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 `napi_acquire_threadsafe_function` 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。\",\"83\":\"\",\"84\":\"当在env即将退出，但tsfn的引用计数未被归零时，应该使用 `napi_tsfn_abort` 模式调用 `napi_release_threadsafe_function` 方法，确保在env释放后不再对tsfn进行持有及使用。在env退出后，继续持有tsfn进行使用，是一种未定义的行为，可能会触发崩溃。\",\"85\":\"\",\"86\":\"如下代码将展示通过注册 `env_cleanup` 钩子函数的方式，以确保在env退出后不再继续持有tsfn。\",\"87\":\"\"}",
      "修改建议": "句子过长，可以拆分",
      "更改后示例": "使用`napi_threadsafe_function`（简称tsfn）时，常调用`napi_acquire_threadsafe_function`更改tsfn的引用计数，确保tsfn不会意外被释放。使用完成后，应及时调用`napi_release_threadsafe_function`的`napi_tsfn_release`模式，确保所有回调执行完成后，引用计数回归到调用`napi_acquire_threadsafe_function`之前的水平。当引用计数归为0时，tsfn才能被正确释放。",
      "触发条件": "同一术语或概念在相邻句子中重复出现（如全称与简称交替使用），或存在冗余修饰结构（如“调用X方法”后再次强调“方法”）。  \n\n识别模式：  \n1. **术语重复**：检查是否在相邻上下文中多次使用全称（如`napi_release_threadsafe_function`）与简称（如tsfn）交替出现，或同一术语重复提及（如“方法”一词冗余）。  \n2. **冗余修饰**：识别类似“使用...模式调用...方法”的冗余结构（如修复前句子），其中“模式”和“方法”可合并简化。  \n3. **逻辑重复**：观察是否通过不同句式重复表达同一逻辑（如“确保...不会意外被释放”与“确保...正确释放”的重复性目标）。"
    },
    {
      "defect_id": 405454,
      "sentence": "4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"22\":\"\",\"23\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"24\":\"\",\"25\":\"4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。\",\"26\":\"\",\"27\":\"Buffer模块各接口使用详见：[@ohos.buffer](../reference/apis-arkts/js-apis-buffer.md)。\",\"28\":\"\",\"29\":\"## FastBuffer\",\"30\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "支持截取部分Buffer、切片和合并多个Buffer。",
      "触发条件": "当句子中连续使用多个并列动词结构（如\"截取...、切片以及合并...\"）且存在重复的助动词（如\"能够\"）时，或包含可省略的目的性说明（如\"便于...\"）时触发。\n\n识别模式：\n1. 检查是否存在\"能够/可以/支持\"等助动词+动词的重复结构（例中\"能够\"与上下文其他条目\"支持\"形成冗余）\n2. 检测并列结构超过3项时是否携带重复助动词（原句\"截取、切片以及合并\"三个动作共享一个\"能够\"）\n3. 识别结尾是否存在独立于核心功能的附加说明（例中\"便于数据...\"属于可删除的解释性内容）\n4. 对比上下文条目结构（相邻条目均直接使用\"支持...\"的无主语句式）"
    },
    {
      "defect_id": 404890,
      "sentence": "某些Node-API接口还有入参类型校验。比如napi_get_value_double接口是获取JS number对应的C double值，首先就要保证的是：JS value类型为number，因此可以看到相关校验。",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"  ```cpp\",\"61\":\"  CHECK_ENV： env判空校验\",\"62\":\"  CHECK_ARG：其它入参判空校验\",\"63\":\"  ```\",\"64\":\"\",\"65\":\"- 某些Node-API接口还有入参类型校验。比如napi_get_value_double接口是获取JS number对应的C double值，首先就要保证的是：JS value类型为number，因此可以看到相关校验。\",\"66\":\"\",\"67\":\"  ```cpp\",\"68\":\"  RETURN_STATUS_IF_FALSE(env, nativeValue->TypeOf() == NATIVE_NUMBER, napi_number_expected);\",\"69\":\"  ```\",\"70\":\"\"}",
      "修改建议": "句子结构复杂，可以拆分",
      "更改后示例": "某些Node-API接口会进行入参类型校验。例如，napi_get_value_double接口获取JS number对应的C double值，需要确保JS value类型为number。相关校验代码如下：",
      "触发条件": "同一句子中重复使用功能描述性短语（如\"获取...值\"与\"需要确保类型\"形成语义重复），或存在冗余逻辑连接词（如\"因此可以看到\"在示例说明场景中无实际信息量）\n\n识别模式：当句子在举例说明时既描述接口功能又重复其前置条件，或使用\"因此/所以\"等连接词但未增加新信息时触发。具体表现为动词短语重复（\"是获取\"+\"需要确保\"）和结果性表述冗余（\"因此可以看到相关校验\"在上下文中已显性展示代码）。"
    },
    {
      "defect_id": 405199,
      "sentence": "> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\",\"18\":\"**已知C++兼容性问题：**\",\"19\":\"\",\"20\":\"应用启动或者dlopen时hilog报错`symbol not found, s=__emutls_get_address`，原因是API9及之前版本SDK中的libc++_shared.so无此符号，而API11之后版本SDK的libc++_shared.so是有此符号的。解决此问题需要更新应用或者共享库HAR包的SDK版本。\",\"21\":\"\"}",
      "修改建议": "原文过于啰嗦，包含不必要的信息，且逗号使用过多。",
      "更改后示例": "系统和应用的C++标准库不能混用。Native API接口只能是C接口，用于隔离C++运行环境。如果HAR包中的libc++_shared.so版本不同于应用，可能导致不兼容问题。解决方法是使用相同SDK版本更新HAR包。",
      "触发条件": "当句子包含与上下文重复的技术说明（如SDK版本更新解决方案）或存在松散结构（多个逗号连接的非必要补充说明）时触发。\n\n识别模式：\n1. 信息重复性：检查是否在相邻段落/注释中已提及相同技术原理（如问题上下文第20行已单独说明符号缺失问题）\n2. 结构冗余度：识别超过3个逗号连接的长复合句，特别是包含\"可以通过\"\"因此\"\"导致\"等连接词的非必要因果链\n3. 解决方案冗余：当技术方案（如SDK版本更新）在单段中被重复提及时（原文出现两次\"libc++_shared.so版本不同\"说明）"
    },
    {
      "defect_id": 405202,
      "sentence": "由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。",
      "reference_sentence": "",
      "line_num": 47,
      "context": "{\"42\":\"![zh-cn_image_musl_ld_namespace](figures/dl_namespace.png)\",\"43\":\"\",\"44\":\"### rpath机制\",\"45\":\"rpath（run-time path）是在运行时指定共享库搜索路径的机制。该机制允许在可执行文件或共享库中嵌入一个用于在运行时指定库的搜索路径的信息。\",\"46\":\"\",\"47\":\"由于命名空间隔离机制，应用仅允许加载对应安装目录拼接native库路径下（例如arm64平台上为`libs/arm64`）的应用native库，当应用程序涉及加载多个native库时，创建多个加载路径会导致无法加载新目录下的native库。这种情况可以通过rpath机制编译时指定搜索路径。\",\"48\":\"\",\"49\":\"例如，应用安装目录`lib/arm64`下的`libhello.so`依赖新创建路径`lib/arm64/module`下的`libworld.so`，那么在应用的`CMakeList.txt`里设置上`rpath`编译选项后编译，使用`readelf`查看`libhello.so`的`rpath`配置如图所示，`$ORIGIN`为`libhello.so`所在路径，运行时即可正常加载module目录下的`libworld.so`。\",\"50\":\"```\",\"51\":\"SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\",\"52\":\"SET(CMAKE_INSTALL_RPATH \\\"\\\\${ORIGIN}/module\\\")\"}",
      "修改建议": "原文过于啰嗦，包含不必要的信息，且逗号使用过多。",
      "更改后示例": "由于命名空间隔离机制，应用只能加载安装目录下的native库。当涉及多个native库时，创建多个加载路径会导致无法加载新目录下的库。这种情况可以通过rpath机制指定搜索路径。",
      "触发条件": "当句子包含可删除的示例性说明(如括号内补充)、重复性限定词(如\"应用\"多次出现)，或使用连续逗号连接超过两个分句时触发。\n\n识别模式：\n1. **冗余示例检测**：存在括号/破折号补充非必要技术细节(如\"例如arm64平台上...\")\n2. **重复限定词**：同一主语重复出现(\"应用\"在单句中重复2次)\n3. **复合结构臃肿**：单句包含超过3个逗号分句，且存在可合并的语义重复内容(如\"编译时指定搜索路径\"与\"rpath机制\"存在语义重叠)"
    },
    {
      "defect_id": 405198,
      "sentence": "两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\",\"9\":\"- 系统库：使用libc++.so，随系统镜像发布。\",\"10\":\"- 应用Native库：使用libc++_shared.so，随应用发布。\",\"11\":\"\",\"12\":\"两个库使用的C++命名空间不同，libc++.so使用__h作为 C++ 符号的命名空间，而 libc++_shared.so使用__n1作为 C++ 符号的命名空间。\",\"13\":\"\",\"14\":\"> **注意：**\",\"15\":\">\",\"16\":\"> 系统和应用使用的C++标准库不能进行混用，Native API接口当前只能是C接口，可以通过这个接口隔离两边的C++运行环境。因此在使用共享库HAR包构建应用时，如果HAR包含的libc++_shared.so不同于应用使用的libc++_shared.so版本，那么只有其中一个版本会安装到应用里，可能会导致不兼容问题，可以使用相同的SDK版本更新HAR包解决此问题。\",\"17\":\"\"}",
      "修改建议": "原文过于啰嗦，包含不必要的信息。",
      "更改后示例": "两个库使用不同的C++命名空间。libc++.so使用__h，libc++_shared.so使用__n1。",
      "触发条件": "当同一句子或相邻分句中，多个并列成分重复相同属性描述（如\"作为C++符号的命名空间\"），且共享相同语义角色时触发。\n\n识别模式：\n1. 结构重复：存在两个及以上并列结构（A使用X作为Y，B使用Z作为Y）\n2. 冗余标记：重复出现完全相同的属性说明短语（如案例中的\"作为C++符号的命名空间\"）\n3. 共享属性：多个主体（案例中的libc++.so/libc++_shared.so）共享同一属性维度（命名空间）\n\n示例特征：\n- 句式包含\"而/且/，...使用...作为...\"的对称结构\n- 重复出现完全相同的功能描述短语（如案例中重复两次\"作为C++符号的命名空间\"）\n- 可通过合并相同属性维度实现简化（如将重复属性提取为前置说明）"
    },
    {
      "defect_id": 405451,
      "sentence": "1. **创建和分配内存**：允许开发者指定大小初始化Buffer，创建后拥有固定的内存容量。",
      "reference_sentence": "",
      "line_num": 19,
      "context": "{\"14\":\"\",\"15\":\"## Buffer\",\"16\":\"\",\"17\":\"Buffer模块的核心功能包括：\",\"18\":\"\",\"19\":\"1. **创建和分配内存**：允许开发者指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"20\":\"\",\"21\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"22\":\"\",\"23\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"24\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "允许指定大小初始化Buffer，创建后内存容量固定。",
      "触发条件": "句子中出现可省略的主语重复（如\"开发者\"）或存在冗余动词结构（如\"拥有固定的\"替代为\"固定\"），且上下文已提供明确行为主体时触发。"
    },
    {
      "defect_id": 405196,
      "sentence": "OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# C/C++标准库机制概述\",\"2\":\"\",\"3\":\"OpenHarmony NDK提供业界标准库[libc标准库](../reference/native-lib/musl.md)、[标准C++库](../reference/native-lib/cpp.md)，本文用于介绍C/C++标准库在OpenHarmony中的机制，开发者了解这些机制有助于在NDK开发过程中避免相关问题。\",\"4\":\"\",\"5\":\"## 1. C++兼容性\",\"6\":\"\",\"7\":\"在OpenHarmony系统中，系统库与应用Native库都在使用C++标准库（参考[libc++版本](../reference/native-lib/cpp.md#libc版本)），系统库依赖的C++标准库随镜像版本升级，而应用Native库依赖的C++标准库随编译使用的SDK版本升级。由于两部分依赖的C++基础库会跨多个大版本，导致ABI兼容性问题。为解决此问题，OpenHarmony对两部分依赖的C++标准库进行了区分。\",\"8\":\"\"}",
      "修改建议": "原文过于啰嗦，包含不必要的信息。",
      "更改后示例": "OpenHarmony NDK提供libc标准库和标准C++库。本文介绍C/C++标准库在OpenHarmony中的机制。了解这些机制有助于避免NDK开发中的问题。",
      "触发条件": "当句子中存在重复限定词（如\"业界标准库\"与具体库名重复）、冗余功能表述（如\"本文用于介绍\"中的\"用于\"）或可合并的上下文信息（如\"开发者了解\"与主句逻辑重复）时触发。\n\n识别模式：\n1. 检测名词短语前是否叠加同义修饰词（例：\"业界标准库[libc标准库]\"中双重限定）\n2. 识别\"用于+动词\"等冗余句式结构（例：\"本文用于介绍\"→\"本文介绍\"）\n3. 发现主谓结构中存在可省略的中间环节表述（例：\"开发过程中避免相关问题\"→\"开发中避免问题\"）"
    },
    {
      "defect_id": 405452,
      "sentence": "2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"Buffer模块的核心功能包括：\",\"18\":\"\",\"19\":\"1. **创建和分配内存**：允许开发者指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"20\":\"\",\"21\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"22\":\"\",\"23\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"24\":\"\",\"25\":\"4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。\",\"26\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "支持按索引读写字节，按字节块读取和写入，复制Buffer部分到其他Buffer或数组。",
      "触发条件": "当句子出现重复动词结构（如连续使用\"支持\"引导多个并列操作）或存在可合并的同类操作描述时触发。\n\n识别模式：\n1. 结构重复检测：识别连续使用相同动词（如\"支持\"）引导的多个分句\n2. 语义重叠判断：检测描述同一操作维度的多个修饰语（如原句\"按字节块读取和写入\"与\"复制Buffer部分\"同属操作方法）\n3. 连接词冗余：发现使用分号或连接词分割的同类操作（如原句用\"支持...，支持...\"分割操作）\n4. 信息密度评估：当单个句子包含超过3个操作描述且使用相同语法结构时触发优化"
    },
    {
      "defect_id": 405219,
      "sentence": "在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"除了支持使用ArkTS进行开发外，开发者还可以通过使用Node-API实现ArkTS和C/C++（Native）的跨语言交互。\",\"4\":\"\",\"5\":\"其中，OpenHarmony的Node-API，是对Node.js社区的拓展版本，与Node.js社区的Node API并不完全兼容。\",\"6\":\"\",\"7\":\"在[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)中，开发者可以根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)情况，进行Native能力的开发和封装，通过导入模块的方式在ArkTS侧导入Native模块后，即可实现跨语言交互。\",\"8\":\"\",\"9\":\"[Node-API扩展能力接口](../napi/use-napi-about-extension.md)进一步扩展了NAPI的功能，提供了一些额外的接口，用于在NAPI模块中与ArkTS进行更灵活的交互和定制，这些接口可以用于创建自定义ArkTS对象等场景。同时，开发者还可参考[Node-API开发规范](../napi/napi-guidelines.md)和[Node-API常见问题](../napi/use-napi-faqs.md)高效地进行跨语言功能开发。\"}",
      "修改建议": "句子过长，逗号数超过5个",
      "更改后示例": "开发者可以参考[使用Node-API进行跨语言开发流程](../napi/use-napi-process.md)，根据[Node-API支持的数据类型](../napi/napi-data-types-interfaces.md#node-api的数据类型)和[接口](../reference/native-lib/napi.md#node-api)，进行Native能力的开发和封装。导入模块后，即可实现跨语言交互。",
      "触发条件": "句子中逗号数量超过5个且存在冗余表达（如重复性动词短语或冗余修饰语），导致结构臃肿或信息重复。\n\n识别模式：\n1. **逗号数量阈值**：统计句子逗号数量≥6个（本案例原句含7个逗号）；\n2. **冗余成分检测**：定位重复性动作描述（如\"通过导入模块的方式在ArkTS侧导入\"中重复\"导入\"）、冗余修饰语（如\"情况\"在\"接口情况\"中无实际意义）；\n3. **逻辑分层验证**：判断长句是否可通过分句或删减冗余词拆分（如将\"通过...导入\"简化为\"导入模块后\"）。"
    },
    {
      "defect_id": 405453,
      "sentence": "3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"\",\"19\":\"1. **创建和分配内存**：允许开发者指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"20\":\"\",\"21\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将Buffer的某部分复制到另一个Buffer或数组。\",\"22\":\"\",\"23\":\"3. **转换操作**：提供了将Buffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"24\":\"\",\"25\":\"4. **内存操作**：能够截取部分Buffer、切片以及合并多个Buffer，便于数据流的处理和管理。\",\"26\":\"\",\"27\":\"Buffer模块各接口使用详见：[@ohos.buffer](../reference/apis-arkts/js-apis-buffer.md)。\",\"28\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "提供Buffer与基本类型（如Uint8Array、string）之间的转换方法。",
      "触发条件": "句子包含补充说明性短语（如\"满足...需求\"）或非必要列举扩展词（如\"等\"），且上下文同类条目均采用\"功能点+核心方法\"的简洁结构时触发。\n\n识别模式：1）检查是否存在解释功能用途的附加从句（通常以逗号分隔） 2）验证示例列表是否使用开放式列举词，而相邻条目均采用闭合式示例 3）对比上下文条目结构，当当前句子超出基础\"方法说明\"范畴时判定冗余"
    },
    {
      "defect_id": 405458,
      "sentence": "2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"FastBuffer模块的核心功能包括：\",\"36\":\"\",\"37\":\"1. **创建和分配内存**：允许开发者基于uint32限制的指定大小初始化Buffer，创建后拥有固定的内存容量。\",\"38\":\"\",\"39\":\"2. **读写和复制数据**：通过索引访问Buffer内的字节，支持按字节块读取和写入，支持将FastBuffer的某部分复制到另一个FastBuffer或数组。\",\"40\":\"\",\"41\":\"3. **转换操作**：提供了将FastBuffer与基本类型（如Uint8Array、string等）之间互相转换的方法，满足不同数据处理需求。\",\"42\":\"\",\"43\":\"4. **内存操作**：能够截取部分FastBuffer、切片以及合并多个FastBuffer，便于数据流的处理和管理。\",\"44\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "支持按索引读写字节，按字节块读取和写入，复制FastBuffer部分到其他FastBuffer或数组。",
      "触发条件": "同一分句或相邻分句中重复使用相同功能动词（如\"支持\"）引导并列操作，或存在可合并的修饰成分（如\"通过索引访问Buffer内的字节\"与\"按字节块读取和写入\"结构不对等）。  \n\n识别模式：  \n1. 检测连续出现的\"支持/提供/允许\"等引导词重复（例：原句连续用\"支持\"引导两个独立功能点）  \n2. 分析介词结构冗余性（例：\"通过索引访问Buffer内的字节\"可压缩为\"按索引读写字节\"，\"另一个FastBuffer\"可替换为\"其他FastBuffer\"）  \n3. 对比上下文条目结构（如第1/3/4点均采用单引导词+冒号结构，而问题句使用了复杂嵌套结构）"
    },
    {
      "defect_id": 405542,
      "sentence": "当需要频繁读取集合中的元素时，推荐使用ArrayList。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"| Stack | 栈，只能从容器的一端进行插入删除操作，占用一片连续的内存空间。一般符合先进后出的场景可以使用。 |\",\"19\":\"| Vector | 动态数组，占用一片连续的内存空间。该类型已不再维护，推荐使用ArrayList。 |\",\"20\":\"\",\"21\":\"## ArrayList\",\"22\":\"\",\"23\":\"[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)即动态数组，可用来构造全局的数组对象。 当需要频繁读取集合中的元素时，推荐使用ArrayList。\",\"24\":\"\",\"25\":\"ArrayList依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为10，支持动态扩容，每次扩容为原始容量的1.5倍。\",\"26\":\"\",\"27\":\"ArrayList支持增、删、改、查操作，常用API如下：\",\"28\":\"\"}",
      "修改建议": "句子不够简洁。",
      "更改后示例": "需要频繁读取集合元素时，推荐使用ArrayList。",
      "触发条件": "句子中存在冗余的时间状语引导词（如“当”）或冗余的介词结构（如“集合中的元素”中的“中的”），且删除后不影响语义完整性。\n\n识别模式：检测到“当...时”引导的条件状语从句中主句与从句主语一致时，或存在“的”字结构可简化为复合名词（如“集合元素”）时触发规则。"
    },
    {
      "defect_id": 405561,
      "sentence": "一般符合先进先出的场景可以使用Queue。",
      "reference_sentence": "",
      "line_num": 132,
      "context": "{\"127\":\"\",\"128\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"129\":\"\",\"130\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"131\":\"\",\"132\":\"一般符合先进先出的场景可以使用Queue。\",\"133\":\"\",\"134\":\"Queue支持增、删、改、查操作，常用API如下：\",\"135\":\"\",\"136\":\"| 操作 | 方法 | 描述 |\",\"137\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子表达可以更简洁。",
      "更改后示例": "符合先进先出的场景可以使用Queue。",
      "触发条件": "句子中出现冗余限定词（如“一般”、“通常”）且删除后不影响语义完整性，或存在可省略的重复性表述。"
    },
    {
      "defect_id": 404892,
      "sentence": "还有一些状态值需要根据相应Node-API接口具体分析：确认具体的状态值，分析这个状态值在什么情况下会返回，再排查具体出错原因。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"  ```cpp\",\"74\":\"  auto resultValue = engine->CallFunction(nativeRecv, nativeFunc, nativeArgv, argc);\",\"75\":\"  RETURN_STATUS_IF_FALSE(env, resultValue != nullptr, napi_pending_exception)\",\"76\":\"  ```\",\"77\":\"\",\"78\":\"- 还有一些状态值需要根据相应Node-API接口具体分析：确认具体的状态值，分析这个状态值在什么情况下会返回，再排查具体出错原因。\",\"79\":\"\",\"80\":\"## napi_threadsafe_function内存泄漏，应该如何处理\",\"81\":\"\",\"82\":\"`napi_threadsafe_function`（下文简称tsfn）在使用时，常常会调用 `napi_acquire_threadsafe_function` 来更改tsfn的引用计数，确保tsfn不会意外被释放。但在使用完成后，应该及时使用 `napi_tsfn_release` 模式调用 `napi_release_threadsafe_function` 方法，以确保在所有调用回调都执行完成后，其引用计数能回归到调用 `napi_acquire_threadsafe_function` 方法之前的水平。当其引用计数归为0时，tsfn才能正确的被释放。\",\"83\":\"\"}",
      "修改建议": "句子结构复杂，可以拆分",
      "更改后示例": "某些状态值需要根据具体Node-API接口分析。确认状态值，分析其返回条件，再排查出错原因。",
      "触发条件": "当句子中出现重复的限定词修饰同一名词（例如\"具体分析...具体的状态值\"）或同一核心名词在相邻子句中高频重复（例如\"状态值\"连续出现3次）时触发；当复杂长句使用冒号分隔多个同质化动作步骤（如\"分析...确认...分析...排查\"）导致语义重复时触发。\n\n识别模式：\n1. 重复修饰检测：相邻子句中存在相同限定词（如\"具体\"）修饰同一核心名词（如\"状态值\"）\n2. 高频复现检测：核心名词在短距离内重复出现≥3次（原句\"状态值\"重复3次）\n3. 结构冗余检测：使用冒号/分号连接的并列短句，包含重复的动作动词（分析→分析）或同质化操作步骤（确认→分析→排查）"
    },
    {
      "defect_id": 405551,
      "sentence": "LinkedList和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相比，LinkedList插入数据的效率高于ArrayList，而ArrayList的查询效率高于LinkedList。",
      "reference_sentence": "",
      "line_num": 74,
      "context": "{\"69\":\"\",\"70\":\"[LinkedList](../reference/apis-arkts/js-apis-linkedlist.md)可用于构造双向链表对象，支持在任意节点向前或向后遍历List。LinkedList依据泛型定义，其元素在内存中的存储位置可以不连续。\",\"71\":\"\",\"72\":\"LinkedList和[List](../reference/apis-arkts/js-apis-list.md)相比，LinkedList是双向链表，支持快速的头尾增删操作，而List是单向链表，不支持双向操作。\",\"73\":\"\",\"74\":\"LinkedList和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相比，LinkedList插入数据的效率高于ArrayList，而ArrayList的查询效率高于LinkedList。\",\"75\":\"\",\"76\":\"当需要频繁的插入删除元素，并且需要使用双向链表时，推荐使用LinkedList高效操作。\",\"77\":\"\",\"78\":\"可以通过get/set等接口对存储的元素进行修改，LinkedList支持增、删、改、查操作，常用API如下：\",\"79\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁表达的要求。",
      "更改后示例": "LinkedList插入数据的效率高于ArrayList。ArrayList查询效率高于LinkedList。",
      "触发条件": "句子中连续使用重复主语（如\"A和B相比，A...，而B...\"结构）且同一比较对象名称重复出现两次以上，导致语义冗余。  \n\n识别模式：检测包含并列连词（如“而”）的复合句，当主语在分句中重复出现且未省略时，判定为冗余表达。具体通过句式结构分析（如\"A和B相比，A...，而B...\"）及实体重复频次（如\"LinkedList/ArrayList\"各出现2次）进行识别。"
    },
    {
      "defect_id": 405564,
      "sentence": "一般符合先进后出的场景可以使用Stack。",
      "reference_sentence": "",
      "line_num": 152,
      "context": "{\"147\":\"\",\"148\":\"Stack依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的1.5倍。Stack底层基于数组实现，入栈和出栈操作均在数组的一端进行。\",\"149\":\"\",\"150\":\"Stack和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Queue基于循环队列实现，只能在头部删除元素，尾部增加元素，而Stack都在一端操作。\",\"151\":\"\",\"152\":\"一般符合先进后出的场景可以使用Stack。\",\"153\":\"\",\"154\":\"Stack支持增、删、改、查操作，常用API如下：\",\"155\":\"\",\"156\":\"| 操作 | 方法 | 描述 |\",\"157\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子表达可以更简洁。",
      "更改后示例": "符合先进后出的场景可以使用Stack。",
      "触发条件": "句子中存在冗余修饰词（如“一般”“通常”等），且删除后不影响核心语义且更简洁；或上下文已隐含条件性，无需额外强调。"
    },
    {
      "defect_id": 405655,
      "sentence": "存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储一系列值。值唯一，底层采用轻量级结构，空间占用小。适用于不重复的集合或去重某个集合。",
      "触发条件": "当句子中连续出现重复的动词/名词结构（如\"存储...存储...\"），或包含超过三个并列信息点时触发；当相邻分句共享相同主语但未合并时触发。\n\n识别模式：\n1. 结构重复检测：匹配\"动词+宾语，动词+宾语\"的连续句式（如\"存储...集合，存储元素...\"）\n2. 信息密度检测：超过三个逗号分隔的独立信息单元（原句包含5个信息点）\n3. 主语重复检测：相邻分句共享同一隐含主语但未合并（如两个\"存储\"开头的分句）\n4. 集合名词冗余：核心名词（如\"集合\"）在同一句子中重复出现≥2次"
    },
    {
      "defect_id": 405662,
      "sentence": "修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 通过遍历修改整个map的元素。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"| 访问元素 | values() | 返回一个迭代器对象，包含map中的所有value值。 |\",\"38\":\"| 访问元素 | entries() | 返回一个迭代器对象，包含map中的所有键值对。 |\",\"39\":\"| 访问元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 遍历访问整个map的元素。 |\",\"40\":\"| 访问元素 | \\\\[Symbol.iterator]():IterableIterator&lt;[K,V]&gt; | 创建迭代器以访问数据。 |\",\"41\":\"| 修改元素 | replace(key: K, newValue: V) | 修改指定key对应的value值。 |\",\"42\":\"| 修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 通过遍历修改整个map的元素。 |\",\"43\":\"| 删除元素 | remove(key: K) | 删除map中匹配到的键值对。 |\",\"44\":\"| 删除元素 | clear() | 清空整个map。 |\",\"45\":\"\",\"46\":\"## HashSet\",\"47\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "修改元素 | forEach(callbackFn: (value?: V, key?: K, map?: HashMap<K, V>) => void, thisArg?: Object) | 遍历并修改整个map的元素。",
      "触发条件": "当句子同时包含\"通过+动词\"的冗余介词结构和重复表达操作目的（如\"通过遍历修改\"中的\"通过\"与\"修改\"存在语义重复），且上下文存在更简洁的动词连用结构（如\"遍历并修改\"）时触发。"
    },
    {
      "defect_id": 405557,
      "sentence": "需要频繁在集合两端进行增删元素的操作时，推荐使用Deque。",
      "reference_sentence": "",
      "line_num": 107,
      "context": "{\"102\":\"\",\"103\":\"Deque和[Queue](../reference/apis-arkts/js-apis-queue.md)相比，Deque支持在两端进行元素的增删操作，而Queue仅支持在头部删除元素，尾部增加元素。\",\"104\":\"\",\"105\":\"Deque和[Vector](../reference/apis-arkts/js-apis-vector.md)相比，它们都支持在两端增删元素，但Deque不支持中间插入的操作。Deque对头部元素的插入删除效率高于Vector，而Vector访问元素的效率高于Deque。\",\"106\":\"\",\"107\":\"需要频繁在集合两端进行增删元素的操作时，推荐使用Deque。\",\"108\":\"\",\"109\":\"Deque支持增、删、改、查操作，常用API如下：\",\"110\":\"\",\"111\":\"| 操作 | 方法 | 描述 |\",\"112\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁表达的要求。",
      "更改后示例": "需要频繁在两端增删元素时，推荐使用Deque。",
      "触发条件": "当句子包含可合并的重复术语（如\"集合两端\"简化为\"两端\"）或冗余动词结构（如\"进行...操作\"）时触发，且上下文已明确前提信息无需重复说明。"
    },
    {
      "defect_id": 405559,
      "sentence": "Queue底层采用循环队列实现，因此入队及出队操作效率都很高。",
      "reference_sentence": "",
      "line_num": 128,
      "context": "{\"123\":\"\",\"124\":\"[Queue](../reference/apis-arkts/js-apis-queue.md)可用来构造队列对象，存储元素遵循先进先出的规则。\",\"125\":\"\",\"126\":\"Queue依据泛型定义，存储位置必须是连续的内存空间，初始容量大小为8，并支持动态扩容，每次扩容为原始容量的2倍。\",\"127\":\"\",\"128\":\"Queue底层采用循环队列实现，因此入队及出队操作效率都很高。\",\"129\":\"\",\"130\":\"Queue和[Deque](../reference/apis-arkts/js-apis-deque.md)相比，Queue只能在一端删除一端增加，而Deque支持两端增删。\",\"131\":\"\",\"132\":\"一般符合先进先出的场景可以使用Queue。\",\"133\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁要求。",
      "更改后示例": "Queue底层采用循环队列实现，入队和出队操作效率高。",
      "触发条件": "句子中存在冗余因果连接词（如“因此”）或重复强调副词（如“都很”）导致信息密度降低，且前后分句可独立表达完整语义时触发。识别模式为：检测\"因此/所以\"类因果连词+同语义重复强调词（都、均等）+逻辑关联性较弱的分句结构。"
    },
    {
      "defect_id": 405125,
      "sentence": "如果在`consumer-rules.txt`文件中配置了[混淆选项](source-obfuscation.md#混淆选项)，可能会对主模块产生影响。因此，建议仅在该文件中配置[保留选项](source-obfuscation.md#保留选项)。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"    }\",\"74\":\"    ```\",\"75\":\"\",\"76\":\"  > **说明**：\",\"77\":\"  >\",\"78\":\"  > 如果在`consumer-rules.txt`文件中配置了[混淆选项](source-obfuscation.md#混淆选项)，可能会对主模块产生影响。因此，建议仅在该文件中配置[保留选项](source-obfuscation.md#保留选项)。\",\"79\":\"\",\"80\":\"* `obfuscation.txt`  \",\"81\":\"    不同于以上两种开发者可自行修改的配置文件，`obfuscation.txt`是在编译构建HAR或HSP时根据`consumer-rules.txt`和依赖模块的混淆规则文件自动生成的文件，它作为一种编译产物存在于发布的HAR或HSP包中。在其他应用依赖该发布包时，会合并其中的混淆规则应用于当前编译流程。`obfuscation.txt`内容的生成及合并逻辑请参考[混淆规则合并策略](source-obfuscation.md#混淆规则合并策略)。\",\"82\":\"\",\"83\":\"  > **说明**：\"}",
      "修改建议": "原文较长，可以拆分成多个句子。",
      "更改后示例": "在`consumer-rules.txt`文件中配置[混淆选项](source-obfuscation.md#混淆选项)可能会影响主模块。因此，建议仅配置[保留选项](source-obfuscation.md#保留选项)。",
      "触发条件": "当句子中重复出现前文已明确指向的上下文信息（如文件名、模块名称等），或使用冗余限定词（如\"在该文件中\"）造成语义重复时触发。\n\n识别模式：\n1. 检查同一句子/相邻句子中是否存在重复的上下文指代（如示例中前文已提及`consumer-rules.txt`文件，后句再次出现\"在该文件中\"）\n2. 观察是否包含可删除而不影响语义的介词结构（如\"如果在...中配置了\"中的\"如果\"和\"了\"在技术文档中常可省略）\n3. 验证限定词是否与上下文形成冗余（如示例中\"配置[保留选项]\"前删除\"在该文件中\"仍保持语义完整）"
    },
    {
      "defect_id": 405543,
      "sentence": "ArrayList依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为10，支持动态扩容，每次扩容为原始容量的1.5倍。",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"## ArrayList\",\"22\":\"\",\"23\":\"[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)即动态数组，可用来构造全局的数组对象。 当需要频繁读取集合中的元素时，推荐使用ArrayList。\",\"24\":\"\",\"25\":\"ArrayList依据泛型定义，要求存储位置为连续的内存空间，初始容量大小为10，支持动态扩容，每次扩容为原始容量的1.5倍。\",\"26\":\"\",\"27\":\"ArrayList支持增、删、改、查操作，常用API如下：\",\"28\":\"\",\"29\":\"| 操作 | 方法 | 描述 |\",\"30\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "ArrayList依据泛型定义，存储位置为连续的内存空间，初始容量为10，支持动态扩容，每次扩容为1.5倍。",
      "触发条件": "当句子中存在可删除的冗余修饰词（如\"大小为\"\"原始容量的\"）或重复说明（如\"要求\"隐含于上下文），导致信息密度过高时触发；当同一句子包含超过3个并列技术参数说明时触发。"
    },
    {
      "defect_id": 405650,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。",
      "reference_sentence": "",
      "line_num": 10,
      "context": "{\"5\":\"\",\"6\":\"## 各非线性容器类型特征对比\",\"7\":\"\",\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储具有关联关系的键值对。键唯一，依据键的hash值确定存储位置。访问速度快，但不能自定义排序。推荐用于快速存取、插入删除键值对。",
      "触发条件": "当单个句子包含三个及以上独立信息点（如数据结构特性、存储机制、性能特点、使用场景），或使用连续逗号拼接超过两个分句时触发冗余表达规则。\n\n识别模式：通过检测复合句结构（特别是逗号连接的多层说明）和语义密度（每句承载功能属性≥3项），结合表格环境对信息分层呈现的要求进行判断。例如\"存储...集合，存储...唯一，依据...位置，访问...较快，但不能...排序，需要...时推荐使用\"连续堆砌6个功能说明，超出单句合理承载范围。"
    },
    {
      "defect_id": 405653,
      "sentence": "存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储一系列值。值唯一，允许用户自定义排序方法，但不建议放入null值。适用于按序存储集合的场景。",
      "触发条件": "当句子包含三个及以上用逗号连接的独立信息点，且存在重复主语或冗余限定词(如\"存储元素中\")时触发。\n\n识别模式：1.检查连续逗号分隔的短语是否具有独立语义完整性 2.寻找重复的主语结构(如原句重复出现\"存储\") 3.验证是否可通过拆分保留原意并提升可读性(如将\"存储一系列值的集合\"简化为\"存储一系列值\")"
    },
    {
      "defect_id": 405656,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。",
      "reference_sentence": "",
      "line_num": 16,
      "context": "{\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\",\"20\":\"[HashMap](../reference/apis-arkts/js-apis-hashmap.md)可用来存储具有关联关系的key-value键值对集合，存储元素中key是唯一的，每个key会对应一个value值。\",\"21\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储具有关联关系的键值对。键唯一，底层与LightWeightMap一样采用轻量级结构，键固定为number类型。适用于存储键为number类型键值对的场景。",
      "触发条件": "当单个句子包含三个及以上并列信息点（特别是重复主语或上下文已明确的属性），或存在与上文重复的已知属性描述（如引用相同底层结构）时触发冗余表达规则。识别模式为连续使用逗号/“且”连接多个独立特征，或出现与相邻条目重复的技术参数（如\"与XX一样采用...\"结构）。"
    },
    {
      "defect_id": 405552,
      "sentence": "当需要频繁的插入删除元素，并且需要使用双向链表时，推荐使用LinkedList高效操作。",
      "reference_sentence": "",
      "line_num": 76,
      "context": "{\"71\":\"\",\"72\":\"LinkedList和[List](../reference/apis-arkts/js-apis-list.md)相比，LinkedList是双向链表，支持快速的头尾增删操作，而List是单向链表，不支持双向操作。\",\"73\":\"\",\"74\":\"LinkedList和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相比，LinkedList插入数据的效率高于ArrayList，而ArrayList的查询效率高于LinkedList。\",\"75\":\"\",\"76\":\"当需要频繁的插入删除元素，并且需要使用双向链表时，推荐使用LinkedList高效操作。\",\"77\":\"\",\"78\":\"可以通过get/set等接口对存储的元素进行修改，LinkedList支持增、删、改、查操作，常用API如下：\",\"79\":\"\",\"80\":\"| 操作 | 方法 | 描述 |\",\"81\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁表达的要求。",
      "更改后示例": "需要频繁插入删除元素且使用双向链表时，推荐使用LinkedList。",
      "触发条件": "句子中出现由\"并且\"/\"并且需要\"等连词连接的多个并列条件，且上下文已明确提及其中部分信息点导致重复冗余。  \n\n识别模式：检查句子是否包含可合并的连词结构（如\"并且...\"→\"且\"），或存在与上文重复的技术特征（如\"双向链表\"已在上下文定义LinkedList时强调）。"
    },
    {
      "defect_id": 405654,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\",\"18\":\"## HashMap\",\"19\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储具有关联关系的键值对。键唯一，底层采用轻量级结构，空间占用小。推荐用于存取键值对数据且内存不充足时。",
      "触发条件": "当句子出现连续重复的主语结构（如\"存储...，存储...\"）或同一语义层次重复描述（如同时出现集合定义和元素特性说明）时触发。\n\n识别模式：\n1. 结构重复：检测连续分句是否使用相同动词开头的句式（如\"存储X，存储Y\"）\n2. 信息堆砌：单句包含≥3个独立信息点（数据结构定义+元素特性+底层实现+适用场景）\n3. 隐性重复：前后分句存在语义重叠（如\"键值对集合\"与\"键唯一\"属于不同层次的特性说明）\n\n示例特征：原句\"存储...集合，存储元素中...\"连续两个\"存储\"引导的分句，同时包含集合定义、元素特性、底层结构、适用场景四个信息维度。"
    },
    {
      "defect_id": 405652,
      "sentence": "存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"\",\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\",\"17\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储具有关联关系的键值对。键唯一，允许用户自定义排序方法。适用于按序存储键值对的场景。",
      "触发条件": "当句子中连续出现重复的名词短语（如\"存储...集合，存储元素中\"）或存在冗余结构（如\"适用于需要按序存储键值对的场景\"中\"需要\"与\"适用\"语义重复）时触发。\n\n识别模式：\n1. 重复结构检测：连续分句中出现相同主语/宾语（如\"存储...集合，存储元素中...\"）\n2. 语义冗余分析：通过\"需要\"+\"适用\"双重强调、或\"键唯一\"在前文已隐含的情况下重复说明\n3. 信息密度判断：单句超过2个独立信息点（存储结构+键特性+排序方法+适用场景）\n4. 对比上下文模式：同类条目（如HashMap/TreeMap）描述存在统一句式时，异常重复表达更易识别"
    },
    {
      "defect_id": 405674,
      "sentence": "TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。两者集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。",
      "reference_sentence": "",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"TreeSet依据泛型定义，值是有序存储的，底层基于红黑树实现，支持快速的插入和删除。value的类型满足ECMA标准。\",\"102\":\"\",\"103\":\"TreeSet基于[TreeMap](../reference/apis-arkts/js-apis-treemap.md)实现，仅处理value对象。用于存储值的集合，元素中value唯一，并支持按用户定义的排序函数排序。\",\"104\":\"\",\"105\":\"TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet中的数据无序存放，而TreeSet是有序存放。两者集合中的元素都不允许重复，HashSet允许放入null值，但TreeSet不建议存放null值，可能会对排序结果产生影响。\",\"106\":\"\",\"107\":\"一般需要存储有序集合的场景，可以使用TreeSet。\",\"108\":\"\",\"109\":\"TreeSet支持增、删、改、查操作，常用API如下：\",\"110\":\"\"}",
      "修改建议": "原文过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "TreeSet和[HashSet](../reference/apis-arkts/js-apis-hashset.md)相比，HashSet无序存放数据，TreeSet有序存放。两者元素不允许重复，HashSet允许null值，但TreeSet不建议存放null值，可能影响排序。",
      "触发条件": "当句子中存在重复的名词结构（如\"集合中的元素\"）、冗余介词短语（如\"中的数据\"）或可简化的动词短语（如\"可能会对...产生影响\"）时触发。"
    },
    {
      "defect_id": 405566,
      "sentence": "Vector和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector支持操作符访问，并增加了get/set接口，提供更完善的校验及容错机制，满足用户不同场景的需求。",
      "reference_sentence": "",
      "line_num": 173,
      "context": "{\"168\":\">\",\"169\":\"> API version 9开始，该接口不再维护，推荐使用[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)。\",\"170\":\"\",\"171\":\"[Vector](../reference/apis-arkts/js-apis-vector.md)是指连续存储结构，用来构造全局的数组对象。Vector依据泛型定义，要求存储位置是为连续的内存空间，初始容量大小为10，并支持动态扩容，每次扩容为原始容量的2倍。\",\"172\":\"\",\"173\":\"Vector和[ArrayList](../reference/apis-arkts/js-apis-arraylist.md)相似，都是基于数组实现，但Vector提供了更多操作数组的接口。Vector支持操作符访问，并增加了get/set接口，提供更完善的校验及容错机制，满足用户不同场景的需求。\",\"174\":\"\",\"175\":\"Vector支持增、删、改、查操作，常用API如下：\",\"176\":\"\",\"177\":\"| 操作 | 方法 | 描述 |\",\"178\":\"| --------- | ------- | ------- |\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁要求。",
      "更改后示例": "Vector和ArrayList相似，基于数组实现，Vector提供更多操作接口，支持操作符访问，增加get/set接口，提供完善的校验和容错机制，满足不同场景需求。",
      "触发条件": "当句子中重复使用相同主语/宾语、存在冗余连接词（如\"并\"、\"及\"）或包含超过3个并列信息点时触发。\n\n识别模式：\n1. 重复主语检测：连续分句重复出现相同主语（如原句两次使用\"Vector\"开头）\n2. 冗余连接词识别：存在\"并\"、\"及\"等可省略的并列连词\n3. 信息密度验证：单句包含≥3个并列谓语结构（原句含5个：\"基于数组实现→提供接口→支持访问→增加接口→提供机制→满足需求\"）\n4. 同义重复判断：相邻分句存在语义重叠（如\"操作数组的接口\"与\"操作符访问/get-set接口\"存在包含关系）"
    },
    {
      "defect_id": 405651,
      "sentence": "存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"## 各非线性容器类型特征对比\",\"7\":\"\",\"8\":\"| 类名 | 特征及建议使用场景 |\",\"9\":\"| --------- | ------- |\",\"10\":\"| HashMap | 存储具有关联关系的键值对集合，存储元素中键唯一，依据键的hash值确定存储位置。访问速度较快，但不能自定义排序。需要快速存取、插入删除键值对数据时推荐使用。 |\",\"11\":\"| HashSet | 存储一系列值的集合，存储元素中值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。需要不重复的集合或需要去重某个集合时可以使用。 |\",\"12\":\"| TreeMap | 存储具有关联关系的键值对集合，存储元素中键唯一，允许用户自定义排序方法。适用于需要按序存储键值对的场景。 |\",\"13\":\"| TreeSet | 存储一系列值的集合，存储元素中值唯一，允许用户自定义排序方法，但不建议放入null值。适用于需要按序存储集合的场景。 |\",\"14\":\"| LightWeightMap | 存储具有关联关系的键值对集合，存储元素中键唯一，底层采用更加轻量级的结构，空间占用小。需要存取键值对数据且内存不充足时推荐使用。 |\",\"15\":\"| LightWeightSet |  存储一系列值的集合，存储元素中值唯一，底层采用更加轻量级的结构，空间占用小。适用于不重复的集合或去重某个集合的场景。 |\",\"16\":\"| PlainArray | 存储具有关联关系的键值对集合，存储元素中键唯一，底层与LightWeightMap一样采用更加轻量级的结构，且键固定为number类型。适用于存储键为number类型键值对的场景。 |\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分成多个简短的句子。",
      "更改后示例": "存储一系列值。值唯一，依据值的hash确定存储位置。允许放入null值，但不能自定义排序。适用于不重复的集合或去重某个集合。",
      "触发条件": "当句子连续使用重复主语（如\"存储\"）或包含多个由逗号连接的独立信息点时，且存在可合并/简化的重复表达结构（如\"存储...集合，存储元素...\"）。\n\n识别模式：检查是否存在(1)同一主语重复引导多个并列分句 (2)超过三个由逗号分隔的语义完整子句 (3)包含重复语义成分（如原句\"存储一系列值的集合\"与\"存储元素中值唯一\"中的双重\"存储\"）"
    },
    {
      "defect_id": 408478,
      "sentence": "通过types字段将指定的类型声明文件作为全局引入，从而避免在每个源码文件中单独引入。",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"  arkOptions的types字段配置文件标签说明：\",\"12\":\"\",\"13\":\"| 属性名称 | 含义 | 配置范围 | 数据类型 | 是否可缺省 |\",\"14\":\"| -------- | -------- | -------- | -------- | -------- |\",\"15\":\"| types | 通过types字段将指定的类型声明文件作为全局引入，从而避免在每个源码文件中单独引入。 | 模块级 | 数组 | 该标签可缺省，缺省值为空。 |\",\"16\":\"\",\"17\":\"### arkOptions中的types字段配置说明\",\"18\":\"\",\"19\":\"arkOptions中types字段示例：\",\"20\":\"\"}",
      "修改建议": "句子结构复杂，可以简化。",
      "更改后示例": "types字段将指定的类型声明文件作为全局引入。",
      "触发条件": "句子中包含因果连接词（如“通过...从而...\"）或重复解释功能效果，且删除冗余结构后核心语义未丢失。\n\n识别模式：检测\"通过...从而/以便/使得...\"等叠加式说明框架，或\"操作手段+目的结果\"双重表述结构，同时验证删除后半段后是否仍能完整表达技术功能。"
    },
    {
      "defect_id": 408208,
      "sentence": "该回收方式不搬移对象，因此效率高。但因回收对象内存地址不连续，会导致内存碎片化，降低分配效率。极端情况下，即使有大量空闲内存，也可能无法放入较大的对象。",
      "reference_sentence": "",
      "line_num": 57,
      "context": "{\"52\":\"#### 标记-清扫回收\",\"53\":\"\",\"54\":\"![image](./figures/mark-clearn.png)\",\"55\":\"  \",\"56\":\"完成对象图遍历后，擦除不可达对象内容，并将其放入空闲队列，以便下次对象分配。  \",\"57\":\"该回收方式不搬移对象，因此效率高。但因回收对象内存地址不连续，会导致内存碎片化，降低分配效率。极端情况下，即使有大量空闲内存，也可能无法放入较大的对象。  \",\"58\":\"\",\"59\":\"#### 标记-复制回收\",\"60\":\"\",\"61\":\"![image](./figures/mark-copy.png)\",\"62\":\"\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "该回收方式不搬移对象，效率高。但回收对象内存地址不连续，导致内存碎片化，降低分配效率。极端情况下，即使有大量空闲内存，也可能无法放入较大对象。",
      "触发条件": "当句子中存在连续因果连词（如\"但因\"）或重复因果表达（如\"因此...因\"），且句子结构因多重复句导致逗号超过5个时触发。\n\n识别模式：检查复合句中是否同时包含\"因此\"类总结性连词和\"因\"类原因连词，并统计逗号分割的意群数量。当因果逻辑被双重强调（如\"因此\"+\"因\"）且分句超过5个时，判定为冗余表达需要简化。"
    },
    {
      "defect_id": 405923,
      "sentence": "1. 接口声明、编译配置以及模块注册。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"一个进程最多只能创建64个运行时环境。\",\"10\":\"\",\"11\":\"## 使用示例\",\"12\":\"\",\"13\":\"1. 接口声明、编译配置以及模块注册。\",\"14\":\"\",\"15\":\"   **接口声明**\",\"16\":\"\",\"17\":\"   ```ts\",\"18\":\"   // index.d.ts\"}",
      "修改建议": "句子简洁，符合规范。",
      "更改后示例": "1. 接口声明、编译配置和模块注册。",
      "触发条件": "句子中出现使用“以及”连接多个并列项，且并列项之间不存在主次关系或补充说明需求时。"
    },
    {
      "defect_id": 405925,
      "sentence": "3. 编写ArkTS侧示例代码。",
      "reference_sentence": "",
      "line_num": 129,
      "context": "{\"124\":\"       pthread_join(tid, nullptr);\",\"125\":\"       return nullptr;\",\"126\":\"   }\",\"127\":\"   ```\",\"128\":\"\",\"129\":\"3. 编写ArkTS侧示例代码。\",\"130\":\"\",\"131\":\"   ```ts\",\"132\":\"   // ObjectUtils.ets\",\"133\":\"   export function Logger() {\",\"134\":\"       console.log(\\\"print log\\\");\"}",
      "修改建议": "句子简洁，符合规范。",
      "更改后示例": "3. 编写ArkTS示例代码。",
      "触发条件": "当句子中存在冗余方位词（如“侧”）且该词未提供额外必要信息时触发，特别是在技术术语本身已隐含上下文环境的情况下。"
    },
    {
      "defect_id": 408218,
      "sentence": "HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清扫（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。",
      "reference_sentence": "",
      "line_num": 105,
      "context": "{\"100\":\"\",\"101\":\"启发式CSet选择算法结合了“标记-整理回收”和“标记-清扫回收”算法的优点，避免了内存碎片问题，同时提升了性能。\",\"102\":\"\",\"103\":\"#### 流程优化\",\"104\":\"\",\"105\":\"HPP GC流程中引入了大量的并发和并行优化，以减少对应用性能的影响。采用了并发+并行标记（Marking）、并发+并行清扫（Sweep）、并行复制/整理（Evacuation）、并行回改（Update）和并发清理（Clear）执行GC任务。\",\"106\":\"\",\"107\":\"## Heap结构及其配置参数\",\"108\":\"\",\"109\":\"### Heap结构\",\"110\":\"\"}",
      "修改建议": "句子过长，包含过多的信息，不符合简洁原则。",
      "更改后示例": "HPP GC流程中引入了大量并发和并行优化，减少对应用性能的影响。优化措施包括：并发+并行标记、并发+并行清扫、并行复制/整理、并行回改和并发清理。",
      "触发条件": "当句子中出现多个并列结构重复使用相同修饰词（如\"并发+并行\"连续出现），或存在括号补充说明但核心信息已冗余时触发；当长句包含超过三个并列成分且采用相同句式结构时触发。\n\n识别模式：\n1. 修饰语重复：连续出现\"并发+并行标记（Marking）、并发+并行清扫（Sweep）\"等重复修饰结构\n2. 括号冗余：括号内的英文术语（如Marking/Sweep）与中文核心词构成重复表达\n3. 长句过载：单句超过40字且包含5个以上并列的GC任务类型说明\n4. 句式堆砌：连续使用\"采用了...，采用了...\"的同构表达"
    },
    {
      "defect_id": 408227,
      "sentence": "对象申请空间到达对应空间阈值时触发GC。",
      "reference_sentence": "",
      "line_num": 230,
      "context": "{\"225\":\"\",\"226\":\"#### 空间阈值触发GC\",\"227\":\"\",\"228\":\"- 函数方法：`AllocateYoungOrHugeObject`，`AllocateHugeObject`等分配函数。\",\"229\":\"- 限制参数：对应的空间阈值。\",\"230\":\"- 说明：对象申请空间到达对应空间阈值时触发GC。\",\"231\":\"- 典型日志：日志可区分GCReason::ALLOCATION_LIMIT。\",\"232\":\"\",\"233\":\"#### native绑定大小达到阈值触发GC\",\"234\":\"\",\"235\":\"- 函数方法：`GlobalNativeSizeLargerThanLimit`\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "对象申请空间到达阈值时触发GC。",
      "触发条件": "当句子中的名词短语包含与上下文（如标题、参数说明）重复的修饰成分（如“对应空间”），且该修饰未提供额外必要信息时触发。\n\n识别模式：检查名词前的定语（如“对应”“相关”等）是否在上下文中已明确指向同一对象（例如上下文标题为“空间阈值触发GC”，则“阈值”默认指代“空间阈值”），此时修饰语（如“对应空间”）应视为冗余。"
    },
    {
      "defect_id": 408223,
      "sentence": "年轻代GC触发阈值在2MB-16MB变化，根据分配速度和存活率等会变化。",
      "reference_sentence": "",
      "line_num": 203,
      "context": "{\"198\":\"\",\"199\":\"### HPP GC的类型\",\"200\":\"\",\"201\":\"#### Young GC\",\"202\":\"\",\"203\":\"- **触发机制**：年轻代GC触发阈值在2MB-16MB变化，根据分配速度和存活率等会变化。\",\"204\":\"- **说明**：主要回收semi space新分配的年轻代对象。\",\"205\":\"- **场景**：前台场景。\",\"206\":\"- **日志关键词**：`[ HPP YoungGC ]`\",\"207\":\"\",\"208\":\"#### Old GC\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "年轻代GC触发阈值在2MB-16MB，根据分配速度和存活率变化。",
      "触发条件": "当句子中连续出现重复动词（如\"变化...变化\"）或存在冗余助词（如\"等会\"中的\"会\"）时触发，需检查是否存在语义重复的修饰成分。"
    },
    {
      "defect_id": 408210,
      "sentence": "这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。",
      "reference_sentence": "",
      "line_num": 64,
      "context": "{\"59\":\"#### 标记-复制回收\",\"60\":\"\",\"61\":\"![image](./figures/mark-copy.png)\",\"62\":\"\",\"63\":\"遍历对象图时，将可达对象复制到新内存空间。遍历完成后，一次回收旧内存空间。  \",\"64\":\"这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。  \",\"65\":\"\",\"66\":\"#### 标记-整理回收\",\"67\":\"\",\"68\":\"![image](./figures/mark-shuffle.png)\",\"69\":\"\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "这种方式可以解决内存碎片问题，通过一次遍历完成整个GC过程，效率较高。极端情况下，需要预留一半内存空间，导致空间利用率较低。",
      "触发条件": "句子包含超过4个逗号的分隔结构，或存在冗余连词（如\"并\"、\"但\"）连接独立语义单元时触发。识别模式需同时满足：1) 单句包含≥5个逗号 2) 存在可合并的因果/转折关系从句（如\"以确保...\"）或重复连接词。"
    },
    {
      "defect_id": 408760,
      "sentence": "当加载文件中的模块时，如以下ArkTS代码：",
      "reference_sentence": "",
      "line_num": 74,
      "context": "{\"69\":\"    }\",\"70\":\"    ```\",\"71\":\"\",\"72\":\"- **加载ets目录下文件中的模块**\",\"73\":\"\",\"74\":\"    当加载文件中的模块时，如以下ArkTS代码：\",\"75\":\"\",\"76\":\"    ```javascript\",\"77\":\"    //./src/main/ets/Test.ets\",\"78\":\"    let value = 123;\",\"79\":\"    function test() {\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "加载文件中的模块时，例如以下ArkTS代码：",
      "触发条件": "句子中包含冗余的时间状语结构（如“当...时”），且上下文已明确动作发生的条件或场景，导致修饰成分多余。识别模式为存在“当...时”引导的非必要状语从句，或重复性时间/条件描述。"
    },
    {
      "defect_id": 408243,
      "sentence": "以下示例仅列举部分情况，实际问题上报的地址异常类型多种多样，此处不再赘述。",
      "reference_sentence": "",
      "line_num": 449,
      "context": "{\"444\":\"可通过线程名称和堆栈内的方法来识别GC任务：`OS_GC_Thread`线程主要执行GC任务和PGO相关任务（采集型任务）；或者通过堆栈内包含`GCTask`等关键词识别GC任务。GC任务上报地址异常类型的崩溃时，开发者应首先应排查非法多线程问题和踩内存问题。 \",\"445\":\"\",\"446\":\"- 检测非法多线程操作：[方舟运行时检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)。\",\"447\":\"- 检测踩内存问题：[HWASan检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-hwasan)。\",\"448\":\"\",\"449\":\"以下示例仅列举部分情况，实际问题上报的地址异常类型多种多样，此处不再赘述。\",\"450\":\"\",\"451\":\"对象异常问题典型堆栈信息： \",\"452\":\"\",\"453\":\"0xffff000000000048 为对象异常偏移出错。\",\"454\":\"\"}",
      "修改建议": "原文冗长，可以简化。",
      "更改后示例": "以下示例列举部分情况，实际问题上报的地址异常类型多样，不再赘述。",
      "触发条件": "当句子中同时存在重复限定词（如\"仅\"与\"部分\"）或冗余指示词（如\"此处\"与上下文已明确的场景）时触发。识别模式为：检测到\"仅...部分\"同义重复结构，或\"此处\"与上文已明示位置的赘述性组合。"
    },
    {
      "defect_id": 408225,
      "sentence": "会对年轻代和老年代做全量压缩，主要用于性能不敏感场景，最大限度回收内存空间。",
      "reference_sentence": "",
      "line_num": 218,
      "context": "{\"213\":\"- **日志关键词**：`[ HPP OldGC ]`\",\"214\":\"\",\"215\":\"#### Full GC\",\"216\":\"\",\"217\":\"- **触发机制**：不会由内存阈值触发。应用切换后台之后，如果预测能回收的对象尺寸大于2M会触发一次Full GC。DumpHeapSnapshot 和 AllocationTracker 工具默认会触发Full GC。Native 接口和ArkTS 也有接口可以触发。\",\"218\":\"- **说明**：会对年轻代和老年代做全量压缩，主要用于性能不敏感场景，最大限度回收内存空间。\",\"219\":\"- **场景**：后台场景。\",\"220\":\"- **日志关键词**：`[ CompressGC ]`\",\"221\":\"\",\"222\":\"此后的Smart GC或IDLE GC都会从上述三种GC中选择。\",\"223\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "对年轻代和老年代做全量压缩，主要用于性能不敏感场景，最大限度回收内存。",
      "触发条件": "当句子中出现名词被另一个隐含其核心含义的名词冗余修饰（如\"内存空间\"中\"空间\"未提供额外信息），或存在可省略的重复性限定成分时触发。\n\n识别模式：检查名词短语是否存在\"X+隐含X属性的名词\"结构（如内存→空间/容量），或修饰语与核心词存在语义重叠（如\"最大限度回收内存空间\"中\"内存\"已隐含空间属性）。"
    },
    {
      "defect_id": 408228,
      "sentence": "影响是否进行全量mark，以及是否开始并发mark。",
      "reference_sentence": "",
      "line_num": 237,
      "context": "{\"232\":\"\",\"233\":\"#### native绑定大小达到阈值触发GC\",\"234\":\"\",\"235\":\"- 函数方法：`GlobalNativeSizeLargerThanLimit`\",\"236\":\"- 限制参数：`globalSpaceNativeLimit`。\",\"237\":\"- 说明：影响是否进行全量mark，以及是否开始并发mark。\",\"238\":\"\",\"239\":\"#### 切换后台触发GC\",\"240\":\"\",\"241\":\"- 函数方法：`ChangeGCParams`\",\"242\":\"- 说明：切换后台后主动触发一次Full GC。\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "影响是否进行全量mark和并发mark。",
      "触发条件": "当句子中出现由\"是否\"引导的多个并列分句，且分句间存在可合并的重复动词结构（如\"进行\"与\"开始\"）时；或存在可简化的冗余修饰成分（如\"是否开始\"中的\"开始\"与前置动词形成语义重复）时。"
    },
    {
      "defect_id": 408240,
      "sentence": "- 典型日志：无直接日志，仅可区分外部触发（`GCReason::TRIGGER_BY_JS`）。",
      "reference_sentence": "",
      "line_num": 406,
      "context": "{\"401\":\"\",\"402\":\"- 调用方式：`ArkTools.hintGC()`\",\"403\":\"- 接口类型：ArkTS接口。\",\"404\":\"- 作用：调用后，VM主动判断是否适合进行full GC。如果后台场景中内存预期存活率低于设定值，则触发full GC；若判断为敏感状态，则不触发。\",\"405\":\"- 使用场景：开发者提示系统进行GC。\",\"406\":\"- 典型日志：无直接日志，仅可区分外部触发（`GCReason::TRIGGER_BY_JS`）。\",\"407\":\"\",\"408\":\"\",\"409\":\"**使用参考：**\",\"410\":\"\",\"411\":\"```ts\"}",
      "修改建议": "原文冗长，可以简化。",
      "更改后示例": "- 典型日志：无直接日志，仅区分外部触发（`GCReason::TRIGGER_BY_JS`）。",
      "触发条件": "当句子中存在冗余副词（如“可”）或重复限定词（如“仅可”），且删除后不影响原意时触发；或同一语义通过不同词汇重复表达（如“仅可区分”与“仅区分”）时触发。"
    },
    {
      "defect_id": 408209,
      "sentence": "遍历对象图时，将可达对象复制到新内存空间。遍历完成后，一次回收旧内存空间。",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"\",\"59\":\"#### 标记-复制回收\",\"60\":\"\",\"61\":\"![image](./figures/mark-copy.png)\",\"62\":\"\",\"63\":\"遍历对象图时，将可达对象复制到新内存空间。遍历完成后，一次回收旧内存空间。  \",\"64\":\"这种方式可以解决内存碎片问题，并通过一次遍历完成整个GC过程，效率较高。但在极端情况下，需要预留一半的内存空间以确保所有活动对象可以被拷贝，导致空间利用率较低。  \",\"65\":\"\",\"66\":\"#### 标记-整理回收\",\"67\":\"\",\"68\":\"![image](./figures/mark-shuffle.png)\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "遍历对象图时，将可达对象复制到新内存空间。遍历完成后，回收旧内存空间。",
      "触发条件": "当句子中出现冗余的时间/次数副词（如\"一次\"）且该限定词未提供额外必要信息，或连续分句超过5个逗号导致结构臃肿时触发。\n\n识别模式：\n1. 检测时间/次数限定词是否与上下文存在重复说明（如本例\"一次回收\"在前文\"遍历完成\"已隐含单次性）\n2. 统计逗号分隔的独立语义单元数量，当≥5个时判定为结构冗余\n3. 验证删除限定词后核心语义完整性（本例删除\"一次\"后回收动作仍完整）"
    },
    {
      "defect_id": 408214,
      "sentence": "考虑到大多数新分配的对象都会在一次GC之后被回收，而大多数经过多次GC之后依然存活的对象会继续存活，ArkTS运行时将对象划分为年轻代对象和老年代对象，并将对象分配到不同的空间。",
      "reference_sentence": "",
      "line_num": 78,
      "context": "{\"73\":\"\",\"74\":\"HPP GC（High Performance Partial Garbage Collection），即高性能部分垃圾回收，其中“High Performance”主要体现在三方面，分代模型、混合算法和GC流程优化。在算法方面，HPP GC会根据不同对象区域、采取不同的回收方式。\",\"75\":\"\",\"76\":\"#### 分代模型\",\"77\":\"\",\"78\":\"ArkTS运行时采用传统的分代模型，将对象进行分类。考虑到大多数新分配的对象都会在一次GC之后被回收，而大多数经过多次GC之后依然存活的对象会继续存活，ArkTS运行时将对象划分为年轻代对象和老年代对象，并将对象分配到不同的空间。\",\"79\":\"\",\"80\":\"![image](./figures/generational-model.png)\",\"81\":\"\",\"82\":\"ArkTS运行时将新分配的对象直接分配到年轻代（Young Space）的From空间。经过一次GC后依然存活的对象，会移动到To空间。而经过再次GC后依然存活的对象，会被移动到老年代（Old Space）。\",\"83\":\"\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "大多数新分配的对象会在一次GC后被回收，而大多数经过多次GC后依然存活的对象会继续存活。ArkTS运行时将对象划分为年轻代和老年代对象，并分配到不同空间。",
      "触发条件": "句子中出现重复名词冗余（如连续出现3次及以上\"对象\"）且包含4个以上逗号分隔的复合结构，在技术概念解释场景下需简化表达时触发。  \n\n识别模式：  \n1. 词汇重复检测：同一核心名词（如\"对象\"）在单句中重复出现3次以上  \n2. 结构复杂度判断：包含两个及以上由\"而\"/\"且\"/\"并\"连接的并列分句  \n3. 技术文档特征：上下文处于算法/机制解释段落（如包含\"分代模型\"\"GC\"等关键词）  \n4. 标点密度指标：单句包含超过4个逗号且总字符数超过150字"
    },
    {
      "defect_id": 408215,
      "sentence": "HPP GC是部分复制、部分整理和部分清扫的混合算法，根据年轻代和老年代对象特点采取不同的回收方式。",
      "reference_sentence": "",
      "line_num": 86,
      "context": "{\"81\":\"\",\"82\":\"ArkTS运行时将新分配的对象直接分配到年轻代（Young Space）的From空间。经过一次GC后依然存活的对象，会移动到To空间。而经过再次GC后依然存活的对象，会被移动到老年代（Old Space）。\",\"83\":\"\",\"84\":\"#### 混合算法\",\"85\":\"\",\"86\":\"HPP GC是部分复制、部分整理和部分清扫的混合算法，根据年轻代和老年代对象特点采取不同的回收方式。  \",\"87\":\"\",\"88\":\"- 部分复制\",\"89\":\"考虑到年轻代对象生命周期短、回收频繁且大小有限，ArkTS运行时对年轻代对象采用“标记-复制回收”算法。\",\"90\":\"- 部分整理+部分清扫\",\"91\":\"根据老年代对象的特点，引入启发式Collection Set（简称CSet）选择算法。此选择算法的基本原理是：在标记阶段对每个区域的存活对象进行大小统计，然后在回收阶段优先选出存活对象少、回收代价小的区域进行对象整理回收，再对剩下的区域进行清扫回收。\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "HPP GC是部分复制、部分整理和部分清扫的混合算法。根据年轻代和老年代对象特点，采取不同的回收方式。",
      "触发条件": "当技术文档中的单句包含超过三个并列成分（如多个\"部分X、部分Y\"结构）且后续附加解释性分句时，或单句连续使用超过两个逗号分隔不同语义单元时。  \n\n识别模式：通过检测长句中的并列结构数量（正则匹配\"部分[\\u4e00-\\u9fa5]+、\"+重复模式）和逗号密度（每20字超过1个逗号），结合语义分析判断是否存在多重复合逻辑单元。"
    },
    {
      "defect_id": 408492,
      "sentence": "- 文件格式要求：Windows：.dll文件，Linux/Mac：.so文件。",
      "reference_sentence": "",
      "line_num": 136,
      "context": "{\"131\":\"\",\"132\":\"### 注意事项\",\"133\":\"\",\"134\":\"- 若开发者未对字段进行配置时，则默认不使用该功能。\",\"135\":\"- HAP、HSP模块配置即生效，HAR模块仅字节码HAR配置生效，非字节码HAR配置不生效。\",\"136\":\"- 文件格式要求：Windows：.dll文件，Linux/Mac：.so文件。\"}",
      "修改建议": "句子结构复杂，信息过多",
      "更改后示例": "- 文件格式：Windows：.dll，Linux/Mac：.so。",
      "触发条件": "当句子中存在重复的限定词/单位（如\"文件\"在上下文中已明确），且该重复未提供新信息时触发。\n\n识别模式：\n1. 检查列举项中是否重复出现与上下文主结构相同的单位词（如主句已说明\"文件格式\"，子项\".dll文件\"中的\"文件\"冗余）\n2. 验证重复元素是否属于已知上下文范畴（如扩展名本身已隐含文件类型，无需重复说明）"
    },
    {
      "defect_id": 408205,
      "sentence": "根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"在上述代码中，对象parent被对象child持有，parent的引用计数加1。同时，child也被parent持有，child的引用计数也加1。这导致了循环引用，直到main函数结束，parent和child仍无法释放，从而引发内存泄漏。\",\"38\":\"#### 对象追踪\",\"39\":\"\",\"40\":\"![image](./figures/tracing-gc.png)\",\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "根对象包括栈内对象和全局对象等。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活对象。如图所示，从根对象开始遍历，所有可达对象标记为蓝色，即为活对象。剩下的不可达对象标记为黄色，即为垃圾。",
      "触发条件": "当句子中出现冗余限定词（如上下文已明确的程序运行状态、时间状态）或重复性修饰语（如\"的\"字结构过度使用），且句子包含超过5个逗号导致结构臃肿时触发。\n\n识别模式：\n1. 冗余限定词检测：识别\"程序运行中的\"、\"当前时刻一定存活的\"等上下文已隐含的限定词\n2. 结构复杂度判断：统计逗号数量>5，并检查是否存在可合并的复合结构（如\"对象及其域\"简化为上下文已明确的遍历行为）\n3. 冗余助词识别：定位连续\"的\"字结构（如\"存活的对象\"→\"存活对象\"），当\"的\"字仅起连接作用且不影响语义时需删除"
    },
    {
      "defect_id": 409286,
      "sentence": "在上述代码中，then方法的回调函数接收Promise对象的成功结果作为参数，并输出到控制台。如果Promise对象进入rejected状态，catch方法的回调函数接收错误对象作为参数，并输出到控制台。",
      "reference_sentence": "",
      "line_num": 60,
      "context": "{\"55\":\"  console.error(error.message); // 失败时执行\",\"56\":\"});\",\"57\":\"```\",\"58\":\"<!-- @[promise_then_catch_handling](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/AsyncConcurrencyOverview/entry/src/main/ets/pages/Index.ets) -->\",\"59\":\"\",\"60\":\"在上述代码中，then方法的回调函数接收Promise对象的成功结果作为参数，并输出到控制台。如果Promise对象进入rejected状态，catch方法的回调函数接收错误对象作为参数，并输出到控制台。\",\"61\":\"\",\"62\":\"> **说明：**\",\"63\":\">\",\"64\":\"> 当Promise被reject且未通过catch方法处理时，会触发unhandledrejection事件。可使用[errorManager.on('unhandledrejection')](../reference/apis-ability-kit/js-apis-app-ability-errorManager.md#errormanageroffunhandledrejection12)接口监听该事件，以全局捕获未处理的Promise reject。\",\"65\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗余。",
      "更改后示例": "在上述代码中，then方法的回调函数接收Promise对象的成功结果，并输出到控制台。如果Promise对象进入rejected状态，catch方法的回调函数接收错误对象，并输出到控制台。",
      "触发条件": "当句子中重复出现描述参数传递的介词结构（如\"作为参数\"），且上下文已明确参数传递关系时；或当技术文档中存在可推断的冗余技术术语重复（如\"Promise对象\"连续出现）时。"
    },
    {
      "defect_id": 408838,
      "sentence": "在使用Node-API操作ArkTS对象时，有一些基本概念需要了解：",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"在使用Node-API接口时，开发人员可以实现在Node-API模块中与ArkTS对象的交互，并进行数据转换和获取特定对象的操作，它们在不同的场景中发挥着重要的作用，使开发人员能够更灵活地处理ArkTS值和对象。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在使用Node-API操作ArkTS对象时，有一些基本概念需要了解：\",\"10\":\"\",\"11\":\"- **ArkTS值到C/C++类型的转换：** 在Node-API模块中，可以使用Node-API函数将ArkTS值转换为C/C++的数据类型，如将ArkTS数值转换为C/C++的整数、将ArkTS字符串转换为C/C++的字符数组等。同样，也可以将C/C++的数据类型转换为ArkTS值，以便将结果返回给ArkTS代码。\",\"12\":\"\",\"13\":\"## 场景和功能介绍\",\"14\":\"\"}",
      "修改建议": "句子中包含不必要的修饰成分。",
      "更改后示例": "使用Node-API操作ArkTS对象时，需要了解一些基本概念。",
      "触发条件": "当句子中出现\"有+修饰成分+需要\"的冗余结构（如\"有一些基本概念需要\"），且该结构可简化为\"需要+修饰成分\"（如\"需要了解一些基本概念\"）时触发。\n\n识别模式：检测\"有+[修饰语]+名词+需要+动词\"句式（如\"有[一些][基本概念]需要[了解]\"），并验证是否可通过删除\"有\"字重组语句（重组后语义不变且更简洁）。该模式常出现在章节导语或条件说明场景中，多伴随\"在...时\"状语结构。"
    },
    {
      "defect_id": 409044,
      "sentence": "1. 在oh-package.json5文件中配置dependencies项：",
      "reference_sentence": "",
      "line_num": 124,
      "context": "{\"119\":\"    console.log(\\\"Hello OpenHarmony\\\");\",\"120\":\"}\",\"121\":\"export {value, test};\",\"122\":\"```\",\"123\":\"\",\"124\":\"1. 在oh-package.json5文件中配置dependencies项：\",\"125\":\"\",\"126\":\"    ```json\",\"127\":\"    {\",\"128\":\"        \\\"dependencies\\\": {\",\"129\":\"            \\\"library\\\": \\\"file:../library\\\"\"}",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "1. 配置oh-package.json5文件的dependencies项：",
      "触发条件": "当句子包含\"在...中\"等冗余介词结构且后续动作已隐含操作位置时（如\"在文件中配置\"简化为\"配置文件\"），或存在重复说明操作对象的位置信息时触发。  \n\n识别模式：检测\"在+名词+中/里\"结构后接动作动词的句式，结合上下文判断位置信息是否已被操作对象隐含（如文件名已包含路径信息）。"
    },
    {
      "defect_id": 408839,
      "sentence": "以下接口用于从C/C++代码中与ArkTS进行交互，传递数据并执行操作，它们的使用场景如下：",
      "reference_sentence": "",
      "line_num": 15,
      "context": "{\"10\":\"\",\"11\":\"- **ArkTS值到C/C++类型的转换：** 在Node-API模块中，可以使用Node-API函数将ArkTS值转换为C/C++的数据类型，如将ArkTS数值转换为C/C++的整数、将ArkTS字符串转换为C/C++的字符数组等。同样，也可以将C/C++的数据类型转换为ArkTS值，以便将结果返回给ArkTS代码。\",\"12\":\"\",\"13\":\"## 场景和功能介绍\",\"14\":\"\",\"15\":\"以下接口用于从C/C++代码中与ArkTS进行交互，传递数据并执行操作，它们的使用场景如下：\",\"16\":\"| 接口 | 描述 |\",\"17\":\"| -------- | -------- |\",\"18\":\"| napi_coerce_to_bool | 用于将给定的ArkTS value强转成ArkTS boolean值。 |\",\"19\":\"| napi_coerce_to_number | 用于将给定的ArkTS value强转成ArkTS number。 |\",\"20\":\"| napi_coerce_to_object | 用于将给定的ArkTS value强转成ArkTS Object。 |\"}",
      "修改建议": "句子中包含不必要的修饰成分。",
      "更改后示例": "以下接口用于从C/C++代码中与ArkTS交互，传递数据并执行操作。",
      "触发条件": "当句子中出现\"进行+动词\"的冗余结构（如\"进行交互\"），或在上下文已明确后续内容结构（如表格/列表）时仍使用重复性引导语（如\"它们的使用场景如下\"）的情况。"
    },
    {
      "defect_id": 409260,
      "sentence": "多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"为了提升应用的响应速度与帧率，避免耗时任务影响UI主线程，ArkTS提供了异步并发和多线程并发两种处理策略。\",\"6\":\"\",\"7\":\"- 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。\",\"8\":\"\",\"9\":\"- 多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。\",\"10\":\"\",\"11\":\"\",\"12\":\"在并发多线程场景下，不同线程间需要进行数据通信。不同类别的对象采用不同的传输方式，如拷贝或内存共享。\",\"13\":\"\",\"14\":\"并发能力广泛应用于多种场景，包括[异步并发任务](async-concurrency-overview.md)、[耗时任务](time-consuming-task-overview.md)（如[CPU密集型任务](cpu-intensive-task-development.md)、[I/O密集型任务](io-intensive-task-development.md)和[同步任务](sync-task-development.md)等）、[长时任务](long-time-task-overview.md)、[常驻任务](resident-task-overview.md)等。开发者可以根据不同的任务诉求和场景，选择相应的并发策略进行优化和开发，具体案例可以参见[应用多线程开发实践案例](batch-database-operations-guide.md)。\"}",
      "修改建议": "句子过长，包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "多线程并发允许同时执行多段代码。UI主线程继续响应用户操作和更新UI，后台线程执行耗时操作，避免应用卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。",
      "触发条件": "句子中存在重复的时间/条件状语（如\"同时\"+\"同一时间段内\"）或冗余修饰成分（如\"从而\"+\"避免\"），导致语义重复或句式冗长。  \n\n识别模式：  \n1. 检查连续副词/状语是否重复强调同一概念（如\"同时执行多段代码\"已隐含时间段重叠，无需叠加\"在同一时间段内\"）  \n2. 分析连接词必要性（如因果关系明确的\"后台线程执行耗时操作，避免卡顿\"无需\"从而\"连接）  \n3. 识别并行结构中的冗余限定（如\"在...的同时\"与前后分句的并行语义重复）"
    },
    {
      "defect_id": 409283,
      "sentence": "最基本的用法是通过构造函数实例化一个Promise对象，同时传入一个带有两个参数的函数，通常称为executor函数。executor函数接收两个参数：resolve和reject，分别表示异步操作成功和失败时的回调函数。例如，以下代码创建了一个Promise对象并模拟了一个异步操作：",
      "reference_sentence": "",
      "line_num": 20,
      "context": "{\"15\":\"\",\"16\":\"Promise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一种状态机制来管理异步操作的不同阶段，Promise有三种状态：pending（进行中）、fulfilled（已完成，也叫resolved）和rejected（已拒绝）。其创建后处于pending状态，异步操作完成后转换为fulfilled或rejected状态。\",\"17\":\"\",\"18\":\"Promise提供了then/catch方法来注册回调函数以处理异步操作的成功或失败的结果，Promise状态改变会触发回调函数加入微任务队列等待执行，依赖事件循环机制在宏任务执行完成后优先执行微任务，保证回调函数的异步调度。\",\"19\":\"\",\"20\":\"最基本的用法是通过构造函数实例化一个Promise对象，同时传入一个带有两个参数的函数，通常称为executor函数。executor函数接收两个参数：resolve和reject，分别表示异步操作成功和失败时的回调函数。例如，以下代码创建了一个Promise对象并模拟了一个异步操作：\",\"21\":\"\",\"22\":\"```ts\",\"23\":\"const promise: Promise<number> = new Promise((resolve: Function, reject: Function) => {\",\"24\":\"  setTimeout(() => {\",\"25\":\"    const randomNumber: number = Math.random();\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗余。",
      "更改后示例": "最基本的用法是通过构造函数实例化一个Promise对象，传入一个带有两个参数的函数，称为executor函数。executor函数接收两个参数：resolve和reject，分别表示异步操作成功和失败时的回调函数。",
      "触发条件": "当句子中同时存在\"同时\"类冗余副词和\"通常称为\"类重复说明，且通过逗号连接多个同位语成分造成信息重复时触发。\n\n具体识别模式：\n1. 存在冗余副词（如\"同时\"）修饰已隐含时间关系的动作\n2. 对已明确定义的术语使用重复说明（如\"通常称为X函数\"后直接使用X函数）\n3. 连续使用逗号分隔的短语表达同一语义内容（如\"传入..., 称为...\"结构）\n4. 句子成分间存在隐性重复（如\"构造函数实例化\"已隐含\"通过构造函数\"）\n5. 术语首次完整定义后仍保留冗余说明性定语（如executor函数在上下文已明确后仍保留\"带有两个参数的\"）"
    },
    {
      "defect_id": 409064,
      "sentence": "2. 在使用@ohos/hypium的模块中，对build-profile.json5进行配置：",
      "reference_sentence": "",
      "line_num": 255,
      "context": "{\"250\":\"            \\\"@ohos/hypium\\\": \\\"1.0.16\\\"\",\"251\":\"        }\",\"252\":\"    }\",\"253\":\"    ```\",\"254\":\"\",\"255\":\"2. 在使用@ohos/hypium的模块中，对build-profile.json5进行配置：\",\"256\":\"\",\"257\":\"    ```json\",\"258\":\"    {\",\"259\":\"        \\\"buildOption\\\" : {\",\"260\":\"            \\\"arkOptions\\\" : {\"}",
      "修改建议": "原文过于啰嗦，可以简化。",
      "更改后示例": "在使用@ohos/hypium的模块中，配置build-profile.json5。",
      "触发条件": "句子中存在“对...进行配置”等冗余介词结构，且上下文已明确操作对象时。识别模式为“对+名词+进行+动词”句式，可简化为“动词+名词”结构。"
    },
    {
      "defect_id": 409287,
      "sentence": "async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。",
      "reference_sentence": "",
      "line_num": 68,
      "context": "{\"63\":\">\",\"64\":\"> 当Promise被reject且未通过catch方法处理时，会触发unhandledrejection事件。可使用[errorManager.on('unhandledrejection')](../reference/apis-ability-kit/js-apis-app-ability-errorManager.md#errormanageroffunhandledrejection12)接口监听该事件，以全局捕获未处理的Promise reject。\",\"65\":\"\",\"66\":\"## async/await\",\"67\":\"\",\"68\":\"async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。\",\"69\":\"\",\"70\":\"async函数通过返回Promise对象实现异步操作，其内部可以包含零个或者多个await关键字，通过await暂停执行直至关联的Promise完成状态转换（fulfilled/rejected）。若函数执行过程中抛出异常，该异常将直接触发返回的Promise进入rejected状态，错误对象可通过.catch()方法或then的第二个回调参数捕获。\",\"71\":\"\",\"72\":\"下面是一个使用async/await的例子，其中模拟了一个以同步方式执行异步操作的场景，该操作会在3秒钟后返回一个字符串。\",\"73\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且信息冗余。",
      "更改后示例": "async/await是用于处理异步操作的Promise语法糖，使异步代码更简单易读。使用async关键字声明异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步方式编写异步操作的代码。",
      "触发条件": "当句子中连续使用多个同义/递进修饰词（如\"变得更加\"）、存在冗余介词结构（如\"通过使用\"）或出现重复性解释同一概念时，应触发冗余表达规则。识别模式包括：1）\"使得...变得更加\"双重修饰结构；2）\"的\"字冗余（如\"以同步的方式\"→\"以同步方式\"）；3）分句间存在重复语义要素（如\"异步操作\"在前后分句重复强调）。"
    },
    {
      "defect_id": 412941,
      "sentence": "禁止删除属性，不能使用的接口有：napi_delete_property。",
      "reference_sentence": "",
      "line_num": 487,
      "context": "{\"482\":\"\",\"483\":\"NAPI相关接口请参考[Sendable相关的NAPI接口](../napi/use-napi-about-extension.md#sendable相关)，具体使用请参考[Native与Sendable ArkTS对象绑定](../napi/use-sendable-napi.md)。\",\"484\":\"\",\"485\":\"| 规则 |\",\"486\":\"| -------- |\",\"487\":\"| 禁止删除属性，不能使用的接口有：napi_delete_property。 |\",\"488\":\"| 禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"489\":\"| 禁止修改属性类型，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"490\":\"| 不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。 |\",\"491\":\"\",\"492\":\"\"}",
      "修改建议": "句子包含过多信息。",
      "更改后示例": "禁止删除属性。不能使用napi_delete_property接口。",
      "触发条件": "同一句子中同时包含禁止动作的抽象描述和具体接口列举，形成语义重复结构（如\"禁止...，不能使用的接口有...\"）。识别模式为：前半句为规则声明，后半句用不同表达方式重复同一限制意图。"
    },
    {
      "defect_id": 409259,
      "sentence": "异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"并发是指在同一时间内，存在多个任务同时执行的情况。对于多核设备，这些任务可以在不同CPU上并行执行。对于单核设备，尽管多个并发任务不会在同一时刻并行执行，但CPU会在某个任务休眠或进行I/O操作时切换任务，调度执行其他任务，从而提高CPU的资源利用率。\",\"4\":\"\",\"5\":\"为了提升应用的响应速度与帧率，避免耗时任务影响UI主线程，ArkTS提供了异步并发和多线程并发两种处理策略。\",\"6\":\"\",\"7\":\"- 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务的开发场景。详细请参见[使用异步并发能力](async-concurrency-overview.md)。\",\"8\":\"\",\"9\":\"- 多线程并发允许在同一时间段内同时执行多段代码。在UI主线程继续响应用户操作和更新UI的同时，后台线程也能执行耗时操作，从而避免应用出现卡顿。ArkTS通过TaskPool和Worker提供多线程并发能力，适用于[耗时任务](time-consuming-task-overview.md)等并发场景。详细请参见[多线程并发概述](multi-thread-concurrency-overview.md)。\",\"10\":\"\",\"11\":\"\",\"12\":\"在并发多线程场景下，不同线程间需要进行数据通信。不同类别的对象采用不同的传输方式，如拷贝或内存共享。\"}",
      "修改建议": "句子过长，包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "异步并发代码在执行到一定程度后暂停，未来某个时间点继续执行，同一时间只有一段代码执行。ArkTS通过Promise和async/await提供异步并发能力，适用于单次I/O任务。详细请参见[使用异步并发能力](async-concurrency-overview.md)。",
      "触发条件": "当句子包含连续逗号分隔的多个分句，且存在重复性语义成分（如\"这种情况下\"）、被动语态冗余（如\"会被暂停\"）或可删除的修饰语（如\"开发场景\"中的\"开发\"）时触发。\n\n识别模式：\n1. 结构特征：句子长度超过30字，包含≥3个逗号分隔的从句\n2. 冗余标记：存在\"这种情况下\"\"这种场景下\"等连接词，或\"被\"字被动式与上下文重复\n3. 修饰冗余：限定词（如\"开发\"场景）与上下文语义重复时\n4. 信息重复：分句间存在语义重叠（如\"同一时间只有一段代码在执行\"在前文已有隐含表达）"
    },
    {
      "defect_id": 409048,
      "sentence": "1. 在oh-package.json5文件中配置dependencies项：",
      "reference_sentence": "",
      "line_num": 190,
      "context": "{\"185\":\"    console.log(\\\"Hello World\\\");\",\"186\":\"}\",\"187\":\"export {value, test};\",\"188\":\"```\",\"189\":\"\",\"190\":\"1. 在oh-package.json5文件中配置dependencies项：\",\"191\":\"\",\"192\":\"    ```json\",\"193\":\"    {\",\"194\":\"        \\\"dependencies\\\": {\",\"195\":\"            \\\"hsp\\\": \\\"file:../hsp\\\"\"}",
      "修改建议": "句子冗长，可以简化。",
      "更改后示例": "1. 配置oh-package.json5文件的dependencies项：",
      "触发条件": "当句子包含\"在...中/里\"等冗余介词结构指明操作位置，且该位置信息可直接融入动词宾语时触发。\n\n识别模式：\n1. 存在\"在+文件名/路径+中\"结构（如\"在A文件中\"）\n2. 后续动词（如配置/添加/修改）的宾语已隐含位置信息\n3. 删除介词结构后语义保持完整且更简洁（如\"在A中配置B\"→\"配置A的B\"）"
    },
    {
      "defect_id": 410531,
      "sentence": "实现任务的函数入参需满足序列化支持的类型，详情请参见[线程间通信对象](interthread-communication-overview.md)。目前不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"- 从API version 11开始，跨并发实例传递带方法的实例对象时，该类必须使用装饰器[@Sendable装饰器](arkts-sendable.md#sendable装饰器)标注，且仅支持在.ets文件中使用。\",\"18\":\"\",\"19\":\"- 任务函数（[LongTask](../reference/apis-arkts/js-apis-taskpool.md#longtask12)除外）在TaskPool工作线程的执行耗时不能超过3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时）。否则，任务将被强制终止。\",\"20\":\"\",\"21\":\"- 实现任务的函数入参需满足序列化支持的类型，详情请参见[线程间通信对象](interthread-communication-overview.md)。目前不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。\",\"22\":\"\",\"23\":\"- ArrayBuffer参数在TaskPool中默认转移，需要设置转移列表的话可通过接口[setTransferList()](../reference/apis-arkts/js-apis-taskpool.md#settransferlist10)设置。如果需要多次调用使用ArrayBuffer作为参数的task，则需要通过接口[setCloneList()](../reference/apis-arkts/js-apis-taskpool.md#setclonelist11)把ArrayBuffer在线程中的传输行为改成拷贝传递，避免对原有对象产生影响。\",\"24\":\"\",\"25\":\"  ```ts\",\"26\":\"  import { taskpool } from '@kit.ArkTS';\"}",
      "修改建议": "原文中包含不必要的修饰成分，且逗号数量超过5个。",
      "更改后示例": "实现任务的函数入参需满足序列化支持的类型。详情请参见[线程间通信对象](interthread-communication-overview.md)。目前不支持使用[@State装饰器](../ui/state-management/arkts-state.md)、[@Prop装饰器](../ui/state-management/arkts-prop.md)、[@Link装饰器](../ui/state-management/arkts-link.md)等装饰器修饰的复杂类型。",
      "触发条件": "当句子中连续使用超过5个逗号造成语义堆叠，或存在重复修饰成分（如\"装饰器\"在\"@State装饰器...等装饰器\"中重复限定）时触发。\n\n识别模式：\n1. 标点维度：检测单句内逗号数量≥5且存在逻辑分层需求\n2. 语义维度：识别到同类限定词重复出现（如类型说明+二次限定），或修饰语与上下文存在显性重复（如\"装饰器修饰的复杂类型\"中双重修饰）"
    },
    {
      "defect_id": 409291,
      "sentence": "需要注意的是，等待异步操作时，需将整个操作包在async函数中，并搭配await使用，同时也可使用try/catch块来捕获异步操作中的异常。",
      "reference_sentence": "",
      "line_num": 110,
      "context": "{\"105\":\"```\",\"106\":\"<!-- @[async_await_sync_operation](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/AsyncConcurrencyOverview/entry/src/main/ets/pages/Index.ets) -->\",\"107\":\"\",\"108\":\"在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。\",\"109\":\"\",\"110\":\"需要注意的是，等待异步操作时，需将整个操作包在async函数中，并搭配await使用，同时也可使用try/catch块来捕获异步操作中的异常。\",\"111\":\"\",\"112\":\"```ts\",\"113\":\"async function myAsyncFunction(): Promise<void> {\",\"114\":\"  try {\",\"115\":\"    const result: string = await new Promise((resolve: Function) => {\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "等待异步操作时，需将操作包在async函数中，并搭配await使用。可使用try/catch捕获异常。",
      "触发条件": "句子包含冗余引导语（如\"需要注意的是\"）或重复修饰（如\"整个操作\"与\"异步操作中的\"双重限定），且存在可拆分的并列结构（如\"并...同时也可...\"）导致信息重复。"
    },
    {
      "defect_id": 409290,
      "sentence": "在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。",
      "reference_sentence": "",
      "line_num": 108,
      "context": "{\"103\":\"  }\",\"104\":\"}\",\"105\":\"```\",\"106\":\"<!-- @[async_await_sync_operation](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/AsyncConcurrencyOverview/entry/src/main/ets/pages/Index.ets) -->\",\"107\":\"\",\"108\":\"在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。\",\"109\":\"\",\"110\":\"需要注意的是，等待异步操作时，需将整个操作包在async函数中，并搭配await使用，同时也可使用try/catch块来捕获异步操作中的异常。\",\"111\":\"\",\"112\":\"```ts\",\"113\":\"async function myAsyncFunction(): Promise<void> {\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "示例代码中，使用await等待Promise解析，并存储在result变量中。",
      "触发条件": "当句子包含重复修饰成分（如\"Promise对象的解析\"中的冗余限定）或存在可合并的分句结构（如\"使用了...来...\"结构）时触发。"
    },
    {
      "defect_id": 410979,
      "sentence": "从API version 18 开始，支持配置Worker线程的优先级。",
      "reference_sentence": "",
      "line_num": 24,
      "context": "{\"19\":\"| 方法调用 | 直接将\\\\@Concurrent修饰的方法传入并调用。 | 在Worker线程中解析消息并调用对应方法。 |\",\"20\":\"| 返回值 | 异步调用后默认返回。 | 主动发送消息，需在onmessage中解析并赋值。 |\",\"21\":\"| 生命周期 | TaskPool自行管理生命周期，无需关心任务负载高低。 | 开发者自行管理Worker的数量及生命周期。 |\",\"22\":\"| 任务池个数上限 | 自动管理，无需配置。 | 同个进程下，最多支持同时开启64个Worker线程，实际数量由进程内存决定。 |\",\"23\":\"| 任务执行时长上限 | 3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），长时任务无执行时长上限。 | 无限制。 |\",\"24\":\"| 设置任务的优先级 | 支持配置任务优先级。 | 从API version 18 开始，支持配置Worker线程的优先级。 |\",\"25\":\"| 执行任务的取消 | 支持取消已经发起的任务。 | 不支持。 |\",\"26\":\"| 线程复用 | 支持。 | 不支持。 |\",\"27\":\"| 任务延时执行 | 支持。 | 不支持。 |\",\"28\":\"| 设置任务依赖关系 | 支持。 | 不支持。 |\",\"29\":\"| 串行队列 | 支持。 | 不支持。 |\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "从API version 18开始，支持配置Worker线程优先级。",
      "触发条件": "当句子中存在\"的\"连接的名词性修饰结构（如\"A的B\"），且该结构可被合并为复合名词（如\"AB\"）而不影响语义时触发。\n\n识别模式：\n1. 检测\"A的B\"结构中的A是否为B的固有属性/从属关系（如\"线程的优先级\"是线程的固有属性）\n2. 验证复合名词\"AB\"是否为该领域的规范术语（如\"线程优先级\"是计算机领域的标准表述）\n3. 检查上下文是否存在平行结构的简洁表达（如同表格中其他条目均使用无\"的\"结构）\n4. 确认删除\"的\"后不会产生歧义（如\"线程优先级\"不会误读为\"线程+优先级\"）"
    },
    {
      "defect_id": 409289,
      "sentence": "下面是一个使用async/await的例子，其中模拟了一个以同步方式执行异步操作的场景，该操作会在3秒钟后返回一个字符串。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"\",\"68\":\"async/await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。\",\"69\":\"\",\"70\":\"async函数通过返回Promise对象实现异步操作，其内部可以包含零个或者多个await关键字，通过await暂停执行直至关联的Promise完成状态转换（fulfilled/rejected）。若函数执行过程中抛出异常，该异常将直接触发返回的Promise进入rejected状态，错误对象可通过.catch()方法或then的第二个回调参数捕获。\",\"71\":\"\",\"72\":\"下面是一个使用async/await的例子，其中模拟了一个以同步方式执行异步操作的场景，该操作会在3秒钟后返回一个字符串。\",\"73\":\"\",\"74\":\"```ts\",\"75\":\"async function myAsyncFunction(): Promise<string> {\",\"76\":\"  const result: string = await new Promise((resolve: Function) => {\",\"77\":\"    setTimeout(() => {\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "下面是一个使用async/await的示例，模拟同步执行异步操作，3秒后返回字符串。",
      "触发条件": "当句子中出现重复性修饰成分（如\"其中\"、\"该操作会\"等冗余介词结构）或存在可合并的同义描述（如\"以同步方式执行异步操作的场景\"与\"同步执行异步操作\"）时触发。\n\n识别模式：\n1. 检测介词结构嵌套（\"其中...的\"、\"该...会\"）\n2. 识别同义短语重复（\"例子/示例\"与\"场景\"、\"3秒钟后\"与\"3秒后\"）\n3. 判断修饰语必要性（\"一个以同步方式执行异步操作的\"可简化为\"同步执行异步操作\"）\n4. 分析信息密度（原句47字→修复句30字，压缩率36%）"
    },
    {
      "defect_id": 410978,
      "sentence": "3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），长时任务无执行时长上限。",
      "reference_sentence": "",
      "line_num": 23,
      "context": "{\"18\":\"| 参数传递 | 直接传递，无需封装。 | 消息对象唯一参数，需要自己封装。 |\",\"19\":\"| 方法调用 | 直接将\\\\@Concurrent修饰的方法传入并调用。 | 在Worker线程中解析消息并调用对应方法。 |\",\"20\":\"| 返回值 | 异步调用后默认返回。 | 主动发送消息，需在onmessage中解析并赋值。 |\",\"21\":\"| 生命周期 | TaskPool自行管理生命周期，无需关心任务负载高低。 | 开发者自行管理Worker的数量及生命周期。 |\",\"22\":\"| 任务池个数上限 | 自动管理，无需配置。 | 同个进程下，最多支持同时开启64个Worker线程，实际数量由进程内存决定。 |\",\"23\":\"| 任务执行时长上限 | 3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时），长时任务无执行时长上限。 | 无限制。 |\",\"24\":\"| 设置任务的优先级 | 支持配置任务优先级。 | 从API version 18 开始，支持配置Worker线程的优先级。 |\",\"25\":\"| 执行任务的取消 | 支持取消已经发起的任务。 | 不支持。 |\",\"26\":\"| 线程复用 | 支持。 | 不支持。 |\",\"27\":\"| 任务延时执行 | 支持。 | 不支持。 |\",\"28\":\"| 设置任务依赖关系 | 支持。 | 不支持。 |\"}",
      "修改建议": "句子包含过多的修饰成分。",
      "更改后示例": "3分钟，长时任务无上限。",
      "触发条件": "当句子中存在括号补充说明或具体示例，且上下文已隐含相关信息时；或当修饰成分（如解释性从句、重复限定语）导致核心信息重复冗余时。\n\n识别模式：1) 检测括号内解释性内容是否与上下文参数定义重复（如本例在表格中\"任务执行时长\"上下文中已明确任务类型）2) 识别\"例如\"\"包含\"等引导的示例是否超出必要解释范围（如异步调用类型在架构文档中应属已知概念）3) 判断限定语是否重复（如\"执行时长上限\"在前半句已明确\"时长\"属性）"
    },
    {
      "defect_id": 408206,
      "sentence": "和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。",
      "reference_sentence": "",
      "line_num": 44,
      "context": "{\"39\":\"\",\"40\":\"![image](./figures/tracing-gc.png)\",\"41\":\"\",\"42\":\"根对象包括程序运行中的栈内对象和全局对象等当前时刻一定存活的对象。被根对象引用的对象也是存活状态。通过遍历可以找到所有存活的对象。如图所示，从根对象开始遍历对象及其域，所有可达的对象标记为蓝色，即为活对象；剩下的不可达对象标记为黄色，即为垃圾。\",\"43\":\"- 优点：对象追踪算法可以解决循环引用的问题，且对内存的分配和赋值没有额外的开销。\",\"44\":\"- 缺点：和引用计数算法相反，对象追踪算法较为复杂，且有短暂的STW阶段。此外，回收会有延迟，导致比较多的浮动垃圾。\",\"45\":\"\",\"46\":\"引用计数和对象追踪算法各有优劣。由于引用计数存在内存泄漏问题，ArkTS运行时选择基于对象追踪（即Tracing GC）算法设计GC。\",\"47\":\"\",\"48\":\"### 对象追踪的三种类型\",\"49\":\"\"}",
      "修改建议": "句子过长，超过5个逗号。",
      "更改后示例": "对象追踪算法较为复杂，有短暂的STW阶段。回收会有延迟，导致较多浮动垃圾。",
      "触发条件": "句子中包含超过4个逗号导致结构冗长，或存在冗余的对比短语（如\"和...相反\"）且该信息已在前文明确提及。"
    },
    {
      "defect_id": 410817,
      "sentence": "加载Ability中的worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "reference_sentence": "",
      "line_num": 88,
      "context": "{\"83\":\"- scriptURL的组成包含{moduleName}/ets和相对路径relativePath。\",\"84\":\"- relativePath是Worker线程文件相对于\\\"{moduleName}/src/main/ets/\\\"目录的相对路径。\",\"85\":\"\",\"86\":\"1） 加载Ability中Worker线程文件场景\",\"87\":\"\",\"88\":\"加载Ability中的worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。\",\"89\":\"\",\"90\":\"```ts\",\"91\":\"import { worker } from '@kit.ArkTS';\",\"92\":\"\",\"93\":\"// worker线程文件所在路径：\\\"entry/src/main/ets/workers/worker.ets\\\"\"}",
      "修改建议": "句子过长，包含多个信息点，不易阅读。",
      "更改后示例": "加载Ability中的Worker线程文件。路径规则：{moduleName}/ets/{relativePath}。",
      "触发条件": "同一动词（如\"加载\"）在相邻分句重复出现，或单个长句包含动作描述+规则说明双重信息点时触发。\n\n具体识别模式：\n1. 动词重复：检测连续分句/短语中出现相同动词（如\"加载...，加载路径...\"）\n2. 信息密度过高：单句同时包含操作行为（动作）和格式规范（规则）两个独立语义单元\n3. 标点特征：关键信息点之间仅用逗号分隔而未合理断句"
    },
    {
      "defect_id": 413025,
      "sentence": "> - 对象字面量、数组字面量在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，对象字面量和数组字面量不是Sendable类型。",
      "reference_sentence": "",
      "line_num": 96,
      "context": "{\"91\":\"\",\"92\":\"> **说明：**\",\"93\":\">\",\"94\":\"> - JS内置对象在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，JS内置对象的实例不是Sendable类型。\",\"95\":\">\",\"96\":\"> - 对象字面量、数组字面量在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，对象字面量和数组字面量不是Sendable类型。\",\"97\":\"\",\"98\":\"\",\"99\":\"## Sendable的实现原理\",\"100\":\"\",\"101\":\"为了实现[Sendable数据](#sendable支持的数据类型)在不同并发实例间的引用传递，Sendable共享对象分配在共享堆中，实现跨并发实例的内存共享。\"}",
      "修改建议": "句子过长，可拆分",
      "更改后示例": "> - 对象字面量和数组字面量在并发实例间传递时遵循结构化克隆算法，跨线程行为是拷贝传递。因此，对象字面量和数组字面量不是Sendable类型。",
      "触发条件": "当句子中出现重复的介词结构（如\"在...间的传递\"）且存在可合并的并列主语时，或当同一语义成分在相邻分句中重复出现（如\"对象字面量、数组字面量\"的两次完整表述）时。  \n\n识别模式：  \n1. 检查并列主语是否在单句中重复完整列举（如\"对象字面量、数组字面量\"→\"对象字面量和数组字面量\"）  \n2. 检测\"在...间的传递\"这类介词结构是否可优化为\"在...间传递时\"的动态表达  \n3. 观察因果复句中前件与结论部分是否存在重复元素需要精简（如删除冗余的\"因此\"衔接）"
    },
    {
      "defect_id": 413027,
      "sentence": "各个并发实例的LocalHeap是隔离的，SharedHeap是进程级别的堆，可以被所有并发实例引用，但SharedHeap不能引用LocalHeap中的对象。",
      "reference_sentence": "",
      "line_num": 110,
      "context": "{\"105\":\"\",\"106\":\"**SharedHeap与LocalHeap关系图**\",\"107\":\"\",\"108\":\"![zh-cn_image_0000002001521153](figures/zh-cn_image_0000002001521153.png)\",\"109\":\"\",\"110\":\"各个并发实例的LocalHeap是隔离的，SharedHeap是进程级别的堆，可以被所有并发实例引用，但SharedHeap不能引用LocalHeap中的对象。\",\"111\":\"\",\"112\":\"\",\"113\":\"## \\\\@Sendable装饰器\",\"114\":\"\",\"115\":\"声明并校验Sendable class以及Sendable function。\"}",
      "修改建议": "句子过长，可拆分",
      "更改后示例": "各个并发实例的LocalHeap是隔离的。SharedHeap是进程级别的堆，可以被所有并发实例引用，但不能引用LocalHeap中的对象。",
      "触发条件": "复合句包含由逗号连接的独立子句且重复主语时，或单句超过语义承载阈值(如包含3个及以上并列/转折逻辑单元)时触发。  \n\n识别模式：  \n1. 结构检测：存在逗号分隔的独立完整子句(如\"X是A，X可以被B，但X不能C\")  \n2. 重复标记：后续分句重复出现前文主语名词(如连续出现\"SharedHeap\")  \n3. 逻辑密度：单句包含≥2个转折/递进关系词(案例含\"但\")且承载≥3个技术概念点  \n4. 视觉长度：英文单词数＞45词或中文字符数＞60字(案例原句达54中文字)  \n\n*注：当同时满足结构检测+任意两项识别特征时，应触发冗余表达规则*"
    },
    {
      "defect_id": 413024,
      "sentence": "> - JS内置对象在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，JS内置对象的实例不是Sendable类型。",
      "reference_sentence": "",
      "line_num": 94,
      "context": "{\"89\":\"\",\"90\":\"- 开发者自定义的Native Sendable对象。详情可参考[自定义Native Sendable对象的多线程操作场景](napi-define-sendable-object.md)。\",\"91\":\"\",\"92\":\"> **说明：**\",\"93\":\">\",\"94\":\"> - JS内置对象在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，JS内置对象的实例不是Sendable类型。\",\"95\":\">\",\"96\":\"> - 对象字面量、数组字面量在并发实例间的传递遵循结构化克隆算法，跨线程行为是拷贝传递。因此，对象字面量和数组字面量不是Sendable类型。\",\"97\":\"\",\"98\":\"\",\"99\":\"## Sendable的实现原理\"}",
      "修改建议": "句子过长，可拆分",
      "更改后示例": "> - JS内置对象在并发实例间传递时遵循结构化克隆算法，跨线程行为是拷贝传递。因此，JS内置对象的实例不是Sendable类型。",
      "触发条件": "同一句子或相邻上下文中存在重复描述同一机制或结论的冗余表达（如“并发实例间的传递”与“跨线程行为”重复强调拷贝传递逻辑），或使用冗余限定词（如“的实例”与前文“对象”重复）。"
    },
    {
      "defect_id": 410861,
      "sentence": "注册onerror回调，当Worker在执行过程中发生异常被调用，在Worker线程执行",
      "reference_sentence": "",
      "line_num": 279,
      "context": "{\"274\":\"      // 注册onmessageerror回调，当Worker对象接收到一条无法被序列化的消息时被调用，在Worker线程执行\",\"275\":\"      workerPort.onmessageerror = () => {\",\"276\":\"        console.error('workerPort onmessageerror');\",\"277\":\"      }\",\"278\":\"\",\"279\":\"      // 注册onerror回调，当Worker在执行过程中发生异常被调用，在Worker线程执行\",\"280\":\"      workerPort.onerror = (err: ErrorEvent) => {\",\"281\":\"        console.error('workerPort onerror err is: ', err.message);\",\"282\":\"      }\",\"283\":\"      ```\",\"284\":\"      <!-- @[register_callback_function](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/MultithreadedConcurrency/WorkerIntroduction/entry/src/main/ets/workers/worker.ets) -->\"}",
      "修改建议": "句子过长，包含过多的修饰成分。",
      "更改后示例": "注册onerror回调，在Worker线程捕获异常。",
      "触发条件": "同一句子中同时存在事件触发条件（如“当...被调用”）和执行环境（如“在...线程”）的冗余说明，且上下文已隐含部分信息。"
    },
    {
      "defect_id": 417410,
      "sentence": "动态import根据入参是常量还是变量，分成动态import常量表达式和动态import变量表达式两大特性规格。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"  ns[functionName](16, 17);  // 调用全局方法addHarLibrary()\",\"68\":\"});\",\"69\":\"```\",\"70\":\"\",\"71\":\"## 动态import实现方案介绍\",\"72\":\"动态import根据入参是常量还是变量，分成动态import常量表达式和动态import变量表达式两大特性规格。\",\"73\":\"以下是动态import支持的规格列表：\",\"74\":\"\",\"75\":\"| 动态import场景 | 动态import详细分类             | 说明                                                     |\",\"76\":\"| :------------- | :----------------------------- | :------------------------------------------------------- |\",\"77\":\"| 本地工程模块   | 动态import模块内文件路径       | 要求路径以./或../开头。                                    |\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "动态import根据入参是常量或变量，分为常量表达式和变量表达式两大规格。",
      "触发条件": "当同一名词短语（如\"动态import\"）在相邻分句中重复出现，且存在可合并的平行结构（如\"常量还是变量，分成...和...\"）时；或句子因重复成分导致结构冗余、出现多个逗号分隔时。"
    },
    {
      "defect_id": 412942,
      "sentence": "禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。",
      "reference_sentence": "",
      "line_num": 488,
      "context": "{\"483\":\"NAPI相关接口请参考[Sendable相关的NAPI接口](../napi/use-napi-about-extension.md#sendable相关)，具体使用请参考[Native与Sendable ArkTS对象绑定](../napi/use-sendable-napi.md)。\",\"484\":\"\",\"485\":\"| 规则 |\",\"486\":\"| -------- |\",\"487\":\"| 禁止删除属性，不能使用的接口有：napi_delete_property。 |\",\"488\":\"| 禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"489\":\"| 禁止修改属性类型，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"490\":\"| 不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。 |\",\"491\":\"\",\"492\":\"\",\"493\":\"## 与UI交互的规则\"}",
      "修改建议": "句子包含过多信息。",
      "更改后示例": "禁止新增属性。不能使用napi_set_property、napi_set_named_property、napi_define_properties接口。",
      "触发条件": "当同一句子中规则声明与具体示例使用重复的禁止性动词（如\"禁止\"与\"不能使用\"）时，或规则标题与解释性内容存在语义重复时触发。  \n\n识别模式：检测到句子包含\"禁止X，不能使用Y\"的并列结构，且前半句规则声明与后半句解释说明存在同义重复时，判定为冗余表达。"
    },
    {
      "defect_id": 410860,
      "sentence": "注册onmessageerror回调，当Worker对象接收到一条无法被序列化的消息时被调用，在Worker线程执行",
      "reference_sentence": "",
      "line_num": 274,
      "context": "{\"269\":\"\",\"270\":\"        // 向主线程发送消息\",\"271\":\"        workerPort.postMessage('2');\",\"272\":\"      }\",\"273\":\"\",\"274\":\"      // 注册onmessageerror回调，当Worker对象接收到一条无法被序列化的消息时被调用，在Worker线程执行\",\"275\":\"      workerPort.onmessageerror = () => {\",\"276\":\"        console.error('workerPort onmessageerror');\",\"277\":\"      }\",\"278\":\"\",\"279\":\"      // 注册onerror回调，当Worker在执行过程中发生异常被调用，在Worker线程执行\"}",
      "修改建议": "句子过长，包含过多的修饰成分。",
      "更改后示例": "注册onmessageerror回调，在Worker线程捕获无法序列化的消息。",
      "触发条件": "当句子同时包含回调函数注册、触发条件描述（\"当...时被调用\"）和执行位置说明（\"在...执行\"）三个冗余分句时，或存在可通过上下文/API语义推断的显式说明时。\n\n识别模式：\n1. 出现\"注册...回调，当...时被调用，在...执行\"的三段式结构\n2. 包含可通过API名称（如onmessageerror）或代码上下文（如Worker线程环境）推断的显式触发条件说明（如消息序列化失败场景）"
    },
    {
      "defect_id": 410781,
      "sentence": "使用Worker能力时，构造函数中传入的Worker线程文件的路径在不同版本有不同的规则，详情请参见[文件路径注意事项](#文件路径注意事项)。",
      "reference_sentence": "",
      "line_num": 18,
      "context": "{\"13\":\"\",\"14\":\"\",\"15\":\"## Worker注意事项\",\"16\":\"\",\"17\":\"- 创建Worker时，提供手动和自动两种创建方式，推荐使用自动创建方式。手动创建Worker线程目录及文件时，需同步进行相关配置，具体要求请参阅[创建Worker的注意事项](#创建worker的注意事项)。\",\"18\":\"- 使用Worker能力时，构造函数中传入的Worker线程文件的路径在不同版本有不同的规则，详情请参见[文件路径注意事项](#文件路径注意事项)。\",\"19\":\"- Worker创建后需要手动管理生命周期。同时运行的Worker子线程数量最多为64个，并且与[napi_create_ark_runtime](../reference/native-lib/napi.md#napi_create_ark_runtime)创建的runtime总数不超过80。详情请参见[生命周期注意事项](#生命周期注意事项)。\",\"20\":\"- 不同线程中上下文对象是不同的，因此Worker线程只能使用线程安全的库，例如UI相关的非线程安全库不能在Worker子线程中使用。\",\"21\":\"- 单次序列化传输的数据量大小限制为16MB。\",\"22\":\"- 使用Worker模块时，API version 18及之后的版本建议在宿主线程中注册onAllErrors回调，以捕获Worker线程生命周期内的各种异常。API version 18之前的版本应注册onerror回调。如果未注册onAllErrors或onerror回调，当Worker线程出现异常时会发生jscrash问题。需要注意的是，onerror接口仅能捕获onmessage回调中的同步异常，捕获异常后，Worker线程将进入销毁流程，无法继续使用。详情请参见[onAllErrors接口与onerror接口之间的行为差异](#onallerrors接口与onerror接口之间的行为差异)。\",\"23\":\"- 不支持跨HAP使用Worker线程文件。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "使用Worker时，构造函数中传入的Worker线程文件路径在不同版本有不同的规则，详情请参见[文件路径注意事项](#文件路径注意事项)。",
      "触发条件": "当句子中出现与上下文重复的限定词（如\"能力\"）且存在多个逗号分隔的复杂结构时，或当主语被冗余修饰成分延长导致句式臃肿时。\n\n识别模式：\n1. 检测技术名词后的冗余限定词（如\"Worker能力\"中的\"能力\"在上下文已明确时）\n2. 分析句子结构复杂度（逗号数量≥2且存在可简化的从句结构）\n3. 比对上下文同类句式（如上下文其他条目均使用\"使用Worker时\"而非\"使用Worker能力时\"）"
    },
    {
      "defect_id": 410818,
      "sentence": "加载HSP中worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。",
      "reference_sentence": "",
      "line_num": 102,
      "context": "{\"97\":\"const workerStage2: worker.ThreadWorker = new worker.ThreadWorker('testworkers/ets/ThreadFile/workers/worker.ets');\",\"98\":\"```\",\"99\":\"\",\"100\":\"2） 加载[HSP](../quick-start/in-app-hsp.md)中Worker线程文件场景\",\"101\":\"\",\"102\":\"加载HSP中worker线程文件，加载路径规则：{moduleName}/ets/{relativePath}。\",\"103\":\"\",\"104\":\"```ts\",\"105\":\"import { worker } from '@kit.ArkTS';\",\"106\":\"\",\"107\":\"// worker线程文件所在路径： \\\"hsp/src/main/ets/workers/worker.ets\\\"\"}",
      "修改建议": "句子过长，包含多个信息点，不易阅读。",
      "更改后示例": "加载HSP中的Worker线程文件。路径规则：{moduleName}/ets/{relativePath}。",
      "触发条件": "句子中连续出现重复动作或名词（如“加载...，加载...”），或长句包含多个信息点且未合理分隔，导致冗余和阅读困难。"
    },
    {
      "defect_id": 413028,
      "sentence": "声明并校验Sendable class以及Sendable function。",
      "reference_sentence": "",
      "line_num": 115,
      "context": "{\"110\":\"各个并发实例的LocalHeap是隔离的，SharedHeap是进程级别的堆，可以被所有并发实例引用，但SharedHeap不能引用LocalHeap中的对象。\",\"111\":\"\",\"112\":\"\",\"113\":\"## \\\\@Sendable装饰器\",\"114\":\"\",\"115\":\"声明并校验Sendable class以及Sendable function。\",\"116\":\"\",\"117\":\"| \\\\@Sendable装饰器 | 说明 |\",\"118\":\"| -------- | -------- |\",\"119\":\"| 装饰器参数 | 无。 |\",\"120\":\"| 使用场景限制 | 仅支持在Stage模型的.ets文件中使用。 |\"}",
      "修改建议": "句子过长，可拆分",
      "更改后示例": "声明并校验Sendable class和Sendable function。",
      "触发条件": "当并列结构中存在\"以及\"连接相同修饰成分的短语（如\"Sendable class以及Sendable function\"），且前后项共享相同修饰词时触发。通过识别\"以及\"后出现重复修饰词（如示例中的二次\"Sendable\"）或可合并的对称结构来判断冗余。"
    },
    {
      "defect_id": 412996,
      "sentence": "Sendable对象为可共享的，其跨线程前后指向同一个JS对象。如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。通信过程如下图所示：",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"\",\"4\":\"在传统JS引擎中，优化对象的并发通信开销的唯一方法是将实现下沉到Native侧，通过[Transferable对象](transferabled-object.md)的转移或共享来降低并发通信开销。但开发者仍有大量对象并发通信的需求，这个问题在业界JS引擎中未得到解决。\",\"5\":\"\",\"6\":\"ArkTS提供了Sendable对象类型，在并发通信时支持通过引用传递来解决上述问题。\",\"7\":\"\",\"8\":\"Sendable对象为可共享的，其跨线程前后指向同一个JS对象。如果包含JS或Native内容，可以直接共享。如果底层是Native实现，则需要考虑线程安全性。通信过程如下图所示：\",\"9\":\"\",\"10\":\"![sendable](figures/sendable.png)\",\"11\":\"\",\"12\":\"与其它ArkTS数据对象不同，符合Sendable协议的数据对象在运行时应为类型固定的对象。\",\"13\":\"\"}",
      "修改建议": "句子过长，包含过多修饰成分。",
      "更改后示例": "Sendable对象可共享，跨线程前后指向同一个JS对象。如果包含JS或Native内容，可以直接共享。如果底层是Native实现，需要考虑线程安全性。",
      "触发条件": "句子中出现重复的主语/代词（如\"其\"）或冗余判断句式（如\"为...的\"），导致修饰成分堆砌、语义重复。"
    },
    {
      "defect_id": 412944,
      "sentence": "不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。",
      "reference_sentence": "",
      "line_num": 490,
      "context": "{\"485\":\"| 规则 |\",\"486\":\"| -------- |\",\"487\":\"| 禁止删除属性，不能使用的接口有：napi_delete_property。 |\",\"488\":\"| 禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"489\":\"| 禁止修改属性类型，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"490\":\"| 不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。 |\",\"491\":\"\",\"492\":\"\",\"493\":\"## 与UI交互的规则\",\"494\":\"\",\"495\":\"Sendable数据需要与[makeObserved](../ui/state-management/arkts-new-makeObserved.md)联用，才可以观察Sendable对象的数据变化，具体使用请参考[makeObserved和@Sendable装饰的class配合文档](../ui/state-management/arkts-new-makeObserved.md#makeobserved和sendable装饰的class配合使用)。\"}",
      "修改建议": "句子包含过多信息。",
      "更改后示例": "不支持Symbol相关接口和类型。不能使用napi_create_symbol、napi_is_symbol_object、napi_symbol接口。",
      "触发条件": "当同一主题词（如\"Symbol相关接口和类型\"）在相邻分句中重复出现，且存在结构重复的\"不能使用的接口有：\"列举句式时触发。具体表现为：前句已声明功能限制范围，后句又用相同主题词+接口列表进行同质化补充说明。"
    },
    {
      "defect_id": 412943,
      "sentence": "禁止修改属性类型，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。",
      "reference_sentence": "",
      "line_num": 489,
      "context": "{\"484\":\"\",\"485\":\"| 规则 |\",\"486\":\"| -------- |\",\"487\":\"| 禁止删除属性，不能使用的接口有：napi_delete_property。 |\",\"488\":\"| 禁止新增属性，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"489\":\"| 禁止修改属性类型，不能使用的接口有：napi_set_property、napi_set_named_property、napi_define_properties。 |\",\"490\":\"| 不支持Symbol相关接口和类型，不能使用的接口有：napi_create_symbol、napi_is_symbol_object、napi_symbol。 |\",\"491\":\"\",\"492\":\"\",\"493\":\"## 与UI交互的规则\",\"494\":\"\"}",
      "修改建议": "句子包含过多信息。",
      "更改后示例": "禁止修改属性类型。不能使用napi_set_property、napi_set_named_property、napi_define_properties接口。",
      "触发条件": "当同一句子中既包含禁止行为的明确表述，又重复使用\"不能使用的接口有\"这类否定性引导结构时，应触发冗余表达规则。\n\n识别模式：\n1. 双否定结构检测：主句使用\"禁止/不支持\"等否定词定义规则，分句再次使用\"不能使用\"等否定词引出受限接口\n2. 信息密度判断：同一语义单元内同时包含规则定义和具体接口列表，且存在\"有：\"冒号引导的枚举结构\n3. 句式重复验证：在相邻条目中已存在同类表达范式时（如上下文表格中的其他规则项），需检查是否存在可合并简化的重复表达"
    },
    {
      "defect_id": 410780,
      "sentence": "创建Worker时，提供手动和自动两种创建方式，推荐使用自动创建方式。手动创建Worker线程目录及文件时，需同步进行相关配置，具体要求请参阅[创建Worker的注意事项](#创建worker的注意事项)。",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"创建Worker的线程称为宿主线程（不局限于主线程，Worker线程也支持创建Worker子线程）。Worker子线程（或Actor线程、工作线程）是Worker自身运行的线程。每个Worker子线程和宿主线程拥有独立的实例，包含独立执行环境、对象、代码段等。因此，启动每个Worker存在一定的内存开销，需要限制Worker子线程的数量。Worker子线程和宿主线程通过消息传递机制通信，利用序列化机制完成命令和数据的交互。\",\"13\":\"\",\"14\":\"\",\"15\":\"## Worker注意事项\",\"16\":\"\",\"17\":\"- 创建Worker时，提供手动和自动两种创建方式，推荐使用自动创建方式。手动创建Worker线程目录及文件时，需同步进行相关配置，具体要求请参阅[创建Worker的注意事项](#创建worker的注意事项)。\",\"18\":\"- 使用Worker能力时，构造函数中传入的Worker线程文件的路径在不同版本有不同的规则，详情请参见[文件路径注意事项](#文件路径注意事项)。\",\"19\":\"- Worker创建后需要手动管理生命周期。同时运行的Worker子线程数量最多为64个，并且与[napi_create_ark_runtime](../reference/native-lib/napi.md#napi_create_ark_runtime)创建的runtime总数不超过80。详情请参见[生命周期注意事项](#生命周期注意事项)。\",\"20\":\"- 不同线程中上下文对象是不同的，因此Worker线程只能使用线程安全的库，例如UI相关的非线程安全库不能在Worker子线程中使用。\",\"21\":\"- 单次序列化传输的数据量大小限制为16MB。\",\"22\":\"- 使用Worker模块时，API version 18及之后的版本建议在宿主线程中注册onAllErrors回调，以捕获Worker线程生命周期内的各种异常。API version 18之前的版本应注册onerror回调。如果未注册onAllErrors或onerror回调，当Worker线程出现异常时会发生jscrash问题。需要注意的是，onerror接口仅能捕获onmessage回调中的同步异常，捕获异常后，Worker线程将进入销毁流程，无法继续使用。详情请参见[onAllErrors接口与onerror接口之间的行为差异](#onallerrors接口与onerror接口之间的行为差异)。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "创建Worker有手动和自动两种方式，推荐使用自动创建方式。手动创建时，需同步进行相关配置，具体要求请参阅[创建Worker的注意事项](#创建worker的注意事项)。",
      "触发条件": "当句子包含重复性名词短语（如\"创建Worker时，提供...创建方式\"）或存在可合并的上下文已明示信息（如\"Worker线程目录及文件\"在前文已定义）时触发。\n\n识别模式：\n1. 结构重复检测：识别\"动词+名词+时，提供...方式\"这类同义结构堆叠（原句\"创建Worker时，提供...创建方式\"→修复为\"创建Worker有...方式\"）\n2. 上下文冗余检测：当名词短语（如\"Worker线程目录及文件\"）在前文/标题（如上下文第15节标题）已明确定义时，自动识别其重复说明为冗余\n3. 标点复杂度判断：连续出现2个及以上逗号分隔的并列短句（原句用3个逗号分割4个语义单元）时触发精简要求"
    },
    {
      "defect_id": 419621,
      "sentence": "不支持在.ets文件中使用Object.freeze接口。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"Sendable对象支持冻结操作，冻结后的对象变成只读对象，不能增删改属性，因此在多个并发实例间访问均不需要加锁，可以通过调用[Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)接口冻结对象。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\"> \",\"7\":\"> 不支持在.ets文件中使用Object.freeze接口。\",\"8\":\"\",\"9\":\"## 使用示例\",\"10\":\"\",\"11\":\"1. 提供ts文件封装Object.freeze方法。\",\"12\":\"\"}",
      "修改建议": "句子过于简单，但可以更简洁。",
      "更改后示例": ".ets文件不支持Object.freeze接口。",
      "触发条件": "当句子使用冗余的介词结构（如“在...中”）或重复主语导致信息重复，且可调整为更简洁的主谓结构（如“X不支持Y”）时触发。\n\n识别模式：\n1. **冗余介词结构**：检测到类似“在X中”的短语，且X可直接作为主语（如“.ets文件”）。\n2. **主谓冗余**：主语（如限制条件主体）未直接作为句子主语，导致被动化表达（如“不支持在X使用Y” → 应简化为“X不支持Y”）。"
    },
    {
      "defect_id": 428593,
      "sentence": "开启MCS并配置安全级别后，使用命令`ps -efZ`查询MCS配置状况。示例如下：",
      "reference_sentence": "",
      "line_num": 32,
      "context": "{\"27\":\" | user | 根据userId确认级别。 | \\\"s0:x%u,x%u\\\", 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\",\"28\":\" | all | 根据进程appId和userId确认级别。 | \\\"s0:x%u,x%u,x%u,x%u,x%u\\\", appId & 0xff, 256 + (appId>>8 & 0xff), 512 + (appId>>16 & 0xff), 768 + (userId & 0xff), 1024 + (userId>>8 & 0xff) |\",\"29\":\"\",\"30\":\"## MCS生效验证\",\"31\":\"\",\"32\":\"开启MCS并配置安全级别后，使用命令`ps -efZ`查询MCS配置状况。示例如下：\",\"33\":\"```text\",\"34\":\"o:r:normal_hap:s0:x55,x334,x512,x868,x1024\",\"35\":\"```\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "开启MCS并配置安全级别后，使用命令`ps -efZ`查询配置状况。示例如下：",
      "触发条件": "同一名词在相邻分句/上下文中重复出现导致冗余，或长句中存在上下文已明确的重复限定词。  \n\n识别模式：  \n1. 检查句子中是否在邻近位置重复使用相同名词（如\"MCS\"在前后分句重复）  \n2. 分析长句结构（含多个逗号分隔成分时），判断修饰语是否因上下文显性信息而冗余（如\"配置状况\"前的主语已隐含MCS上下文）"
    },
    {
      "defect_id": 425871,
      "sentence": "1. 首先，实现一个方法，用来接收Task发送的消息。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"如果一个Task不仅需要返回最终的执行结果，还需要定时通知宿主线程状态和数据的变化，或者需要分段返回大量数据（例如，从数据库中读取大量数据），可以通过以下方式实现。\",\"4\":\"\",\"5\":\"下面以多个图片加载任务结果实时返回为例说明。\",\"6\":\"\",\"7\":\"1. 首先，实现一个方法，用来接收Task发送的消息。\",\"8\":\"\",\"9\":\"   ```ts\",\"10\":\"   // TaskSendDataUsage.ets\",\"11\":\"   function notice(data: number): void {\",\"12\":\"     console.info(\\\"子线程任务已执行完，共加载图片: \\\", data);\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "1. 实现接收Task消息的方法。",
      "触发条件": "1)句子包含冗余步骤性词语（如\"首先\"）而上下文已有明确步骤指示时 2)存在\"用来...\"等冗长动词结构而可用简洁动宾短语（如\"接收...\"）替代时\n\n识别模式：当检测到\"首先/第一步\"等序数词与上下文步骤描述重复，或出现\"用来+动词\"结构（\"用来接收\"）时，应触发冗余表达规则。需结合上下文判断步骤指示是否必要，并验证动词短语是否可简化为直接宾语结构（\"接收消息的方法\"）。"
    },
    {
      "defect_id": 428591,
      "sentence": "配置user时，如果user未定义，需要先在users策略文件里定义，示例：",
      "reference_sentence": "",
      "line_num": 17,
      "context": "{\"12\":\"  为应用进程添加MCS配置，需要保证MCS开关开启，然后在sehap_contexts配置文件中按需配置levelFrom和user，如果未配置user，默认为user=u。示例如下：\",\"13\":\"  ```text\",\"14\":\"  apl=normal debuggable=true domain=debug_hap type=debug_hap_data_file levelFrom=all user=o\",\"15\":\"  ```\",\"16\":\"\",\"17\":\"  配置user时，如果user未定义，需要先在users策略文件里定义，示例：\",\"18\":\"  ```text\",\"19\":\"  user o roles { r } level s0 range s0 - s0:c0.x1279;\",\"20\":\"  ```\",\"21\":\"\",\"22\":\"  配置levelFrom时，安全级别可选配置如下：\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "配置user时，如果未定义，先在users策略文件定义，示例：",
      "触发条件": "同一名词在相邻分句中重复出现（如\"配置user时，如果user未定义\"），或存在可通过上下文推断的冗余信息（如\"需要\"等非必要修饰词）。  \n\n识别模式：  \n1. 检查连续分句是否存在重复主语（如\"user...user\"嵌套结构）  \n2. 检测逗号数量超过3个的长句，分析是否存在可合并的语义重复片段  \n3. 验证修饰词必要性（如\"需要\"在条件状语从句中可省略）"
    },
    {
      "defect_id": 428670,
      "sentence": "  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。",
      "reference_sentence": "",
      "line_num": 50,
      "context": "{\"45\":\"  类型强制(**T**ype **E**nforcement)，SELinux策略是由多条类型强制规则构成的。\",\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\",\"55\":\"OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。\"}",
      "修改建议": "句子不够简洁。",
      "更改后示例": "  + `Enforcing`，强制模式，拦截未授权行为并打印告警。",
      "触发条件": "当句子中特定术语（如\"avc\"）已在上下文被明确定义或默认隐含，且重复出现导致冗余时；或存在可通过上下文推断的冗余限定词（如领域专用缩写）时。"
    },
    {
      "defect_id": 428671,
      "sentence": "  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。",
      "reference_sentence": "",
      "line_num": 51,
      "context": "{\"46\":\"\",\"47\":\"- **运行模式**\",\"48\":\"\",\"49\":\"  OpenHarmony SELinux支持两种运行模式：\",\"50\":\"  + `Enforcing`，强制模式，拦截未授权行为并打印avc告警。\",\"51\":\"  + `Permissive`，宽容模式，放行未授权行为并打印avc告警。\",\"52\":\"\",\"53\":\"## 实现原理\",\"54\":\"\",\"55\":\"OpenHarmony SELinux通过主体和客体的安全上下文表示主体是否有权限访问客体，在内核态拦截未授权行为。\",\"56\":\"\"}",
      "修改建议": "句子不够简洁。",
      "更改后示例": "  + `Permissive`，宽容模式，放行未授权行为并打印告警。",
      "触发条件": "当相邻条目或同一上下文中已明确术语定义时，出现重复修饰词（如案例中前文已说明\"avc告警\"，后续并列条目中再次出现相同修饰词）。识别模式为：在结构化列表/对比描述中，若多个条目共享相同限定词且上下文已明确，则后续重复限定词构成冗余。"
    },
    {
      "defect_id": 430202,
      "sentence": "CPU密集型任务是指需要占用系统资源进行大量计算的任务，这类任务需要长时间运行，会阻塞线程中其他事件的处理，因此不适宜在UI主线程中进行。例如图像处理、视频编码、数据分析等。",
      "reference_sentence": "",
      "line_num": 4,
      "context": "{\"1\":\"# CPU密集型任务开发指导 (TaskPool和Worker)\",\"2\":\"\",\"3\":\"\",\"4\":\"CPU密集型任务是指需要占用系统资源进行大量计算的任务，这类任务需要长时间运行，会阻塞线程中其他事件的处理，因此不适宜在UI主线程中进行。例如图像处理、视频编码、数据分析等。\",\"5\":\"\",\"6\":\"\",\"7\":\"基于多线程并发机制处理CPU密集型任务可以提高CPU利用率，提升应用程序响应速度。\",\"8\":\"\",\"9\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息过多。",
      "更改后示例": "CPU密集型任务需要占用大量系统资源进行计算，长时间运行会阻塞线程中的其他事件处理，不适宜在UI主线程中进行。例如图像处理、视频编码、数据分析。",
      "触发条件": "当句子包含由多个逗号分隔的独立信息点，且存在语义重复（如复指代词\"这类任务\"或冗余因果关系词\"因此\"）时触发。\n\n识别模式：\n1. **结构特征**：长句含3+逗号分隔的从句，形成\"定义+复指+解释+结论\"的链式结构\n2. **语义特征**：存在显性复指（如\"这类任务\"重复主语）或隐性冗余（如\"占用系统资源进行大量计算\"与\"长时间运行\"存在逻辑重叠）\n3. **上下文特征**：出现在技术文档的概念定义段落，需优先保证表述精炼性\n\n（注：该规则在技术文档场景下敏感度更高，因冗余表达会直接影响信息传递效率，而文学性文本可能允许更复杂的句式结构）"
    },
    {
      "defect_id": 430371,
      "sentence": "该工具能记录JS代码执行所用的时间，使用此工具能帮助开发者分析JS代码的性能瓶颈，为代码优化提供数据支撑。",
      "reference_sentence": "",
      "line_num": 36,
      "context": "{\"31\":\"\",\"32\":\"- Code Cache：编译后的JS代码的缓存，能提升JS代码执行的启动速度。\",\"33\":\"\",\"34\":\"- Debugger：调试器，用于调试JS代码。\",\"35\":\"\",\"36\":\"- CPU Profiler：该工具能记录JS代码执行所用的时间，使用此工具能帮助开发者分析JS代码的性能瓶颈，为代码优化提供数据支撑。\",\"37\":\"\",\"38\":\"- Heap Snapshot：JS堆内存分析/调优工具，可以进行内存优化和发现内存泄漏问题。\",\"39\":\"\",\"40\":\"- Heap Statistics：JS堆统计信息，包括内存大小及上下文数量。\",\"41\":\"\"}",
      "修改建议": "句子包含无意义的词语，应简化。",
      "更改后示例": "该工具记录JS代码执行时间，帮助开发者分析性能瓶颈，提供优化数据。",
      "触发条件": "句子中出现重复主语（如\"该工具...使用此工具\"）或冗余助动词（如\"能\"多次出现），且存在可合并/简化的同义表达（如\"提供数据支撑\"→\"提供数据\"）。"
    },
    {
      "defect_id": 430204,
      "sentence": "本文通过某地区提供的房价数据训练一个简易的房价预测模型，该模型支持通过输入房屋面积和房间数量去预测该区域的房价，模型需要长时间运行，房价预测需要使用前面的模型运行结果，因此需要使用Worker。",
      "reference_sentence": "",
      "line_num": 77,
      "context": "{\"72\":\"<!-- @[process_image_histogram](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/ArkTsConcurrent/ApplicationMultithreadingDevelopment/ApplicationMultithreading/entry/src/main/ets/managers/CpuIntensiveTaskDevelopment.ets) -->\",\"73\":\"\",\"74\":\"\",\"75\":\"## 使用Worker进行长时间数据分析\",\"76\":\"\",\"77\":\"本文通过某地区提供的房价数据训练一个简易的房价预测模型，该模型支持通过输入房屋面积和房间数量去预测该区域的房价，模型需要长时间运行，房价预测需要使用前面的模型运行结果，因此需要使用Worker。\",\"78\":\"\",\"79\":\"1. DevEco Studio提供了Worker创建的模板，新建一个Worker线程，例如命名为“MyWorker”。\",\"80\":\"\",\"81\":\"   ![newWorker](figures/newWorker.png)\",\"82\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，信息过多。",
      "更改后示例": "本文通过某地区提供的房价数据训练一个简易的房价预测模型，支持输入房屋面积和房间数量预测房价，模型需要长时间运行，因此使用Worker。",
      "触发条件": "当句子包含多个逗号分隔的独立分句，且存在重复主语（如\"该模型\"与\"模型\"）、冗余动作描述（如\"支持通过输入...去预测\"与\"需要使用前面的模型运行结果\"）时触发。\n\n识别模式：\n1. 结构特征：长句由3个以上逗号分隔的独立分句构成，分句间存在重复主语或宾语\n2. 语义特征：存在可合并的动词短语（如\"支持通过输入...去预测\"→\"支持输入...预测\"）、重复说明性内容（如两次强调模型运行特性）"
    },
    {
      "defect_id": 434843,
      "sentence": "                // 调度结果处理",
      "reference_sentence": "",
      "line_num": 73,
      "context": "{\"68\":\"                let context = this.getUIContext().getHostContext() as common.UIAbilityContext;\",\"69\":\"    \",\"70\":\"                // 使用TaskPool执行包含密集I/O的并发函数\",\"71\":\"                // 数组较大时，I/O密集型任务分发也会抢占UI主线程，需要使用多线程能力\",\"72\":\"                taskpool.execute(concurrentTest, context).then(() => {\",\"73\":\"                  // 调度结果处理\",\"74\":\"                  console.info(\\\"taskpool: execute success\\\")\",\"75\":\"                })\",\"76\":\"              })\",\"77\":\"          }\",\"78\":\"          .width('100%')\"}",
      "修改建议": "句子包含不必要的修饰成分，违反了使用主谓结构、主谓宾结构的句子，避免添加不必要的修饰成分的规则。",
      "更改后示例": "处理调度结果",
      "触发条件": "检测到句子或短语使用名词化结构（如“XX处理”）替代动词主导的主谓宾结构（如“处理XX”），且上下文无必要强调修饰关系时触发。  \n识别模式：通过词性分析定位“动词+名词”组合的名词短语（如“调度结果处理”），若存在可直接转换为动宾结构（如“处理调度结果”）且语义等价，则判定为冗余表达。"
    },
    {
      "defect_id": 434948,
      "sentence": "- 用于OH_JSVM_EscapeHandle接口，将JSVM_EscapableHandleScope提升到JavaScript对象，以便在外部作用域使用。",
      "reference_sentence": "",
      "line_num": 248,
      "context": "{\"243\":\"\",\"244\":\"- 由OH_JSVM_OpenEscapableHandleScope接口创建，由OH_JSVM_CloseEscapableHandleScope接口关闭。\",\"245\":\"\",\"246\":\"- 表示一种特殊类型的句柄范围，用于将在JSVM_EscapableHandleScope范围内创建的值返回给父scope。\",\"247\":\"\",\"248\":\"- 用于OH_JSVM_EscapeHandle接口，将JSVM_EscapableHandleScope提升到JavaScript对象，以便在外部作用域使用。\",\"249\":\"\",\"250\":\"**JSVM_Ref**\",\"251\":\"\",\"252\":\"指向JSVM_Value，允许用户管理JavaScript值的生命周期。\",\"253\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "- 用于 OH_JSVM_EscapeHandle 接口，将 JSVM_EscapableHandleScope 范围内的值提升为 JavaScript 对象，以便在外部作用域使用。",
      "触发条件": "当句子中存在重复限定或隐含上下文的冗余修饰成分（如\"范围内的值\"已由前置技术术语隐含时重复修饰），或使用不准确的动词/介词组合（如\"提升到\"替代更精确的\"提升为\"）导致语义模糊。"
    },
    {
      "defect_id": 434946,
      "sentence": "- 由OH_JSVM_OpenEscapableHandleScope接口创建，由OH_JSVM_CloseEscapableHandleScope接口关闭。",
      "reference_sentence": "",
      "line_num": 244,
      "context": "{\"239\":\"\",\"240\":\"JSVM_HandleScope数据类型是用来管理JavaScript对象的生命周期的。它允许JavaScript对象在一定范围内保持活动状态，以便在JavaScript代码中使用。在创建JSVM_HandleScope时，所有在该范围内创建的JavaScript对象都会保持活动状态，直到结束。这样可以避免在JavaScript代码中使用已经被释放的对象，从而提高代码的可靠性和性能。\",\"241\":\"\",\"242\":\"**JSVM_EscapableHandleScope**\",\"243\":\"\",\"244\":\"- 由OH_JSVM_OpenEscapableHandleScope接口创建，由OH_JSVM_CloseEscapableHandleScope接口关闭。\",\"245\":\"\",\"246\":\"- 表示一种特殊类型的句柄范围，用于将在JSVM_EscapableHandleScope范围内创建的值返回给父scope。\",\"247\":\"\",\"248\":\"- 用于OH_JSVM_EscapeHandle接口，将JSVM_EscapableHandleScope提升到JavaScript对象，以便在外部作用域使用。\",\"249\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "- 由 OH_JSVM_OpenEscapableHandleScope 创建，由 OH_JSVM_CloseEscapableHandleScope 关闭。",
      "触发条件": "当句子中连续出现相同功能属性的重复修饰语（如\"接口\"修饰具体API名称），且上下文已明确对象类型时触发。\n\n识别模式：检查\"由X创建，由Y关闭\"类对称结构中，X/Y是否为已明确定义的函数/方法名称。若修饰语与前置技术名词存在语义重叠（如用\"接口\"修饰实际函数名），则判定为冗余表达。"
    },
    {
      "defect_id": 435393,
      "sentence": "同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"\",\"4\":\"同步任务是指在多个线程之间协调执行的任务，其目的是确保多个任务按照一定的顺序和规则执行，例如使用锁来防止数据竞争。\",\"5\":\"\",\"6\":\"\",\"7\":\"同步任务的实现需要考虑多个线程之间的协作和同步，以确保数据的正确性和程序的正确执行。\",\"8\":\"\",\"9\":\"由于TaskPool偏向于单个独立的任务，因此当各个同步任务之间相对独立时推荐使用TaskPool，例如一系列导入的静态方法，或者单例实现的方法。如果同步任务之间有关联性，则需要使用Worker。\",\"10\":\"\",\"11\":\"\",\"12\":\"## 使用TaskPool处理同步任务\"}",
      "修改建议": "句子过长，包含多个逗号，可以拆分成两个句子。",
      "更改后示例": "同步任务的实现需要考虑多个线程之间的协作和同步。这确保了数据的正确性和程序的正确执行。",
      "触发条件": "当句子包含逗号连接的独立子句（特别是\"以\"/\"从而\"等引导的目的状语从句），且总长度超过25字时触发；或上下文存在重复语义支撑信息时触发。\n\n识别模式：\n1. 结构特征：主句+逗号+\"以/从而/因此\"+结果从句（形成隐性冗余）\n2. 长度特征：复合句总字符数＞25且包含≥2个逗号\n3. 语义特征：后置从句内容与前文存在重复支撑关系（如本例\"正确性\"与第4段\"防止数据竞争\"形成语义呼应）"
    },
    {
      "defect_id": 435052,
      "sentence": "以TypeError为例。创建，判断，并抛出JS TypeError。\r",
      "reference_sentence": "",
      "line_num": 842,
      "context": "{\"837\":\"| OH_JSVM_GetLastErrorInfo| 获取最后一个异常的信息 |\",\"838\":\"| OH_JSVM_ThrowSyntaxError| 抛出一个JS SyntaxError |\",\"839\":\"| OH_JSVM_CreateSyntaxError| 创建一个JS SyntaxError并返回 |\",\"840\":\"\",\"841\":\"场景示例：\",\"842\":\"以TypeError为例。创建，判断，并抛出JS TypeError。\",\"843\":\"\",\"844\":\"```c++\",\"845\":\"JSVM_Value code = nullptr;\",\"846\":\"JSVM_Value message = nullptr;\",\"847\":\"OH_JSVM_CreateStringUtf8(env, \\\"500\\\", JSVM_AUTO_LENGTH, &code);\"}",
      "修改建议": "原文中包含无意义的换行符。",
      "更改后示例": "以TypeError为例。创建，判断，并抛出JS TypeError。",
      "触发条件": "当文本段落中存在非结构需要的换行符（如连续文本被无意义空行分隔）或代码示例前后出现冗余空行时触发。识别模式需检测文本中非列表/代码块场景下的异常空行，以及段落与代码块之间超过规范的空行间距。"
    },
    {
      "defect_id": 435038,
      "sentence": "JSVM_CallbackStruct 指针类型的类型别名。",
      "reference_sentence": "",
      "line_num": 288,
      "context": "{\"283\":\"} JSVM_CallbackStruct;\",\"284\":\"```\",\"285\":\"\",\"286\":\"**JSVM_Callback**\",\"287\":\"\",\"288\":\"JSVM_CallbackStruct 指针类型的类型别名。\",\"289\":\"\",\"290\":\"定义如下:\",\"291\":\"\",\"292\":\"```c++\",\"293\":\"typedef JSVM_CallbackStruct* JSVM_Callback;\"}",
      "修改建议": "句子结构简单，但可以更简洁。",
      "更改后示例": "JSVM_CallbackStruct 指针的类型别名。",
      "触发条件": "当句子中出现“指针类型的类型别名”等重复修饰结构（即“指针类型”与“类型别名”中“类型”语义重复）时触发，需简化为“指针的类型别名”以消除冗余。"
    },
    {
      "defect_id": 434937,
      "sentence": "TypedArray的基本二进制标量数据类型。",
      "reference_sentence": "",
      "line_num": 89,
      "context": "{\"84\":\"} JSVM_ValueType;\",\"85\":\"```\",\"86\":\"\",\"87\":\"### JSVM_TypedarrayType\",\"88\":\"\",\"89\":\"TypedArray的基本二进制标量数据类型。\",\"90\":\"\",\"91\":\"```c++\",\"92\":\"typedef enum {\",\"93\":\"    JSVM_INT8_ARRAY,\",\"94\":\"    JSVM_UINT8_ARRAY,\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "TypedArray 的基本二进制标量数据类型。",
      "触发条件": "当名词前存在多个并列修饰语（如\"基本\"和\"二进制\"），且上下文已通过具体枚举值（如INT8/UINT8等）隐含修饰语含义时触发。\n\n识别模式：通过分析相邻代码块中的枚举/定义内容（如JSVM_INT8_ARRAY），判断前置修饰语是否与已明确定义的数据特性重复，同时检查是否存在超过两个以上的并列修饰成分（形容词/限定词）共同修饰核心名词（如\"标量数据类型\"）。"
    },
    {
      "defect_id": 434932,
      "sentence": "- 用于表示JSVM-API执行时的上下文，Native侧函数入参，并传递给函数中的JSVM-API接口。",
      "reference_sentence": "",
      "line_num": 60,
      "context": "{\"55\":\"\",\"56\":\"在C++代码中，用于表示一个JavaScript值。\",\"57\":\"\",\"58\":\"### JSVM_Env\",\"59\":\"\",\"60\":\"- 用于表示JSVM-API执行时的上下文，Native侧函数入参，并传递给函数中的JSVM-API接口。\",\"61\":\"\",\"62\":\"- 退出Native侧插件时，JSVM_Env将失效，该事件通过回调传递给OH_JSVM_SetInstanceData。\",\"63\":\"\",\"64\":\"- 禁止缓存JSVM_Env，并禁止在不同Worker中传递JSVM_Env。\",\"65\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "- 表示 JSVM-API 执行时的上下文，作为 Native 函数的参数传递给 JSVM-API 接口。",
      "触发条件": "当句子中存在多个并列的修饰成分（如重复描述同一主体的功能或属性）或存在可合并的冗余动作描述（如\"入参并传递\"这类连续操作）时触发。\n\n识别模式：\n1. **结构重复**：检查是否使用多个逗号分隔的同类修饰短语（如\"Native侧函数入参，并传递给...\"）\n2. **动作冗余**：识别\"动词+并列动作\"结构（如\"入参并传递\"），判断是否可通过单一句式表达（如\"作为参数传递\"）\n3. **主体一致性**：当多个分句共用同一隐性主语（如JSVM_Env）却重复说明其属性时，判定为冗余"
    },
    {
      "defect_id": 435042,
      "sentence": "包含属性监听回调的结构的指针类型。",
      "reference_sentence": "",
      "line_num": 355,
      "context": "{\"350\":\"} JSVM_PropertyHandlerConfigurationStruct;\",\"351\":\"```\",\"352\":\"\",\"353\":\"**JSVM_PropertyHandlerCfg**\",\"354\":\"\",\"355\":\"包含属性监听回调的结构的指针类型。\",\"356\":\"\",\"357\":\"基本用法如下:\",\"358\":\"\",\"359\":\"```c++\",\"360\":\"typedef JSVM_PropertyHandlerConfigurationStruct* JSVM_PropertyHandlerCfg;\"}",
      "修改建议": "句子结构简单，但可以更简洁。",
      "更改后示例": "包含属性监听回调的结构指针。",
      "触发条件": "句子中出现“指针类型”等复合名词且上下文已明确指代类型定义时，或存在双重属格结构（如“结构的指针类型”）可简化为单层属格（如“结构指针”）。\n\n识别模式：检测“的”字连续嵌套（如“结构的指针类型”中的两个“的”逻辑层级），并结合技术文档中“typedef/类型定义”上下文，判定“类型”一词在指针描述中冗余。"
    },
    {
      "defect_id": 435065,
      "sentence": "根据给定的描述符创建一个 Symbol 对象。",
      "reference_sentence": "",
      "line_num": 993,
      "context": "{\"988\":\"|OH_JSVM_CreateArrayWithLength | 创建一个指定长度的 JavaScript 数组对象 |\",\"989\":\"|OH_JSVM_CreateArraybuffer | 创建一个指定大小的 ArrayBuffer 对象 |\",\"990\":\"|OH_JSVM_CreateDate | 创建了一个表示给定毫秒数的 Date 对象 |\",\"991\":\"|OH_JSVM_CreateExternal | 创建一个包装了外部指针的 JavaScript 对象 |\",\"992\":\"|OH_JSVM_CreateObject | 创建一个默认的JavaScript Object对象 |\",\"993\":\"|OH_JSVM_CreateSymbol | 根据给定的描述符创建一个 Symbol 对象 |\",\"994\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol |\",\"995\":\"|OH_JSVM_CreateTypedarray | 在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型 |\",\"996\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象,DataView 对象在底层数据缓冲区上提供类似数组的视图 |\",\"997\":\"|OH_JSVM_CreateInt32 | 根据 Int32_t 类型对象创建 JavaScript number 对象 |\",\"998\":\"|OH_JSVM_CreateUint32 | 根据 Uint32_t 类型对象创建 JavaScript number 对象 |\"}",
      "修改建议": "原文含有不必要的修饰成分。",
      "更改后示例": "创建描述符的 Symbol 对象。",
      "触发条件": "当句子中存在可简化的介词结构（如\"根据给定的\"）或重复限定词（如\"JavaScript Object对象\"），且上下文已隐含必要信息时触发。\n\n识别模式：1) 介词短语+名词构成冗余修饰（如\"根据X的Y\"可简化为\"X的Y\"）2) 术语重复（如\"Object对象\"）3) 存在与功能描述重复的限定词（如\"默认的\"在\"创建默认Object\"中冗余）"
    },
    {
      "defect_id": 435063,
      "sentence": "创建一个包装了外部指针的 JavaScript 对象。",
      "reference_sentence": "",
      "line_num": 991,
      "context": "{\"986\":\"| -------- | -------- |\",\"987\":\"|OH_JSVM_CreateArray | 创建一个新的 JavaScript 数组对象 |\",\"988\":\"|OH_JSVM_CreateArrayWithLength | 创建一个指定长度的 JavaScript 数组对象 |\",\"989\":\"|OH_JSVM_CreateArraybuffer | 创建一个指定大小的 ArrayBuffer 对象 |\",\"990\":\"|OH_JSVM_CreateDate | 创建了一个表示给定毫秒数的 Date 对象 |\",\"991\":\"|OH_JSVM_CreateExternal | 创建一个包装了外部指针的 JavaScript 对象 |\",\"992\":\"|OH_JSVM_CreateObject | 创建一个默认的JavaScript Object对象 |\",\"993\":\"|OH_JSVM_CreateSymbol | 根据给定的描述符创建一个 Symbol 对象 |\",\"994\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol |\",\"995\":\"|OH_JSVM_CreateTypedarray | 在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型 |\",\"996\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象,DataView 对象在底层数据缓冲区上提供类似数组的视图 |\"}",
      "修改建议": "原文含有不必要的修饰成分。",
      "更改后示例": "创建包装外部指针的 JavaScript 对象。",
      "触发条件": "当句子中出现动态助词\"了\"且该动作不强调完成状态，或存在重复限定词（如\"新的\"+\"创建\"）时触发；当技术文档中动词与其受词间存在冗余修饰（如\"Object对象\"）时触发。\n\n识别模式：\n1. 检测\"创建/生成\"类动词后是否含冗余动态助词\"了\"（例：\"创建了\"→\"创建\"）\n2. 识别名词短语中的重复限定（如\"新的数组对象\"中\"新的\"与\"创建\"语义重复）\n3. 捕捉术语冗余（如\"Object对象\"中Object本身即指对象）\n4. 验证上下文是否存在平行结构（对比同列项\"创建Date对象\"与问题句\"创建了...对象\"）"
    },
    {
      "defect_id": 434938,
      "sentence": "配合编译接口 OH_JSVM_CompileScriptWithOptions 使用，是其参数中 options 数组的元素类型。",
      "reference_sentence": "",
      "line_num": 129,
      "context": "{\"124\":\"```\",\"125\":\"\",\"126\":\"### 编译选项相关类型\",\"127\":\"#### JSVM_CompileOptions\",\"128\":\"\",\"129\":\"配合编译接口 OH_JSVM_CompileScriptWithOptions 使用，是其参数中 options 数组的元素类型。\",\"130\":\"\",\"131\":\"其中：\",\"132\":\"- id 代表这个编译选项的类型。\",\"133\":\"- content 代表编译选项的内容。\",\"134\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "配合 OH_JSVM_CompileScriptWithOptions 接口使用，是其参数中 options 数组的元素类型。",
      "触发条件": "句子中在专有接口/函数名称前重复使用类别词（如\"接口\"），或存在过长修饰链导致核心信息被冗余成分包裹时触发。具体表现为名称本身已隐含类别属性（如OH_JSVM_CompileScriptWithOptions含接口语义），其前置修饰语（如\"编译接口\"）与名称产生语义重复。"
    },
    {
      "defect_id": 435039,
      "sentence": "用户定义的 Native callback，第一个参数类型是 JSVM_Env，第二个参数类型是 JSVM_CallbackInfo。JSVM_CallbackInfo 表示从 JS 侧调用到 Native 侧时携带的调用信息，如参数列表。在实现 Native callback 时，一般使用 OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。",
      "reference_sentence": "",
      "line_num": 298,
      "context": "{\"293\":\"typedef JSVM_CallbackStruct* JSVM_Callback;\",\"294\":\"```\",\"295\":\"\",\"296\":\"**JSVM_CallbackInfo**\",\"297\":\"\",\"298\":\"用户定义的 Native callback，第一个参数类型是 JSVM_Env，第二个参数类型是 JSVM_CallbackInfo。JSVM_CallbackInfo 表示从 JS 侧调用到 Native 侧时携带的调用信息，如参数列表。在实现 Native callback 时，一般使用 OH_JSVM_GetCbInfo 接口从 JSVM_CallbackInfo 中提取调用信息。\",\"299\":\"\",\"300\":\"**JSVM_Finalize**\",\"301\":\"\",\"302\":\"函数指针，用于传入OH_JSVM_SetInstanceData、OH_JSVM_CreateExternal、OH_JSVM_Wrap等接口。JSVM_Finalize在对象被回收后会被调用，可用于在JavaScript对象被垃圾回收时释放Native对象。JSVM 不保证是否执行该回调函数，也不保证执行该回调函数的时机，**开发者不应依赖于该回调的执行时机**。\",\"303\":\"\"}",
      "修改建议": "句子过长，且包含不必要的修饰成分。",
      "更改后示例": "用户定义的 Native callback，第一个参数是 JSVM_Env，第二个参数是 JSVM_CallbackInfo。JSVM_CallbackInfo 包含调用信息，如参数列表。实现 Native callback 时，使用 OH_JSVM_GetCbInfo 提取调用信息。",
      "触发条件": "当句子中存在重复说明参数/对象类型（如\"参数类型是\"）、使用冗长修饰结构（如\"从...侧调用到...侧时携带的\"）或包含非必要来源说明（如\"接口从...中\"）时触发冗余表达规则。识别模式为技术名词后出现\"类型是\"类重复说明、超过8个字的复杂介词结构、以及接口操作附带冗余来源信息（如\"从XXX中\"）。"
    },
    {
      "defect_id": 440324,
      "sentence": "由于操作系统和真机设备的差异，在预览界面中可能会存在部分组件或API与真机设备运行的效果存在差异，预览效果仅作为组件/界面开发过程中的参考，实际最终效果请以真机设备运行效果为准。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"![ide_previewer_001](figures/ide_previewer_001.png)\",\"6\":\"\",\"7\":\"> **说明：**\",\"8\":\">\",\"9\":\"> 由于操作系统和真机设备的差异，在预览界面中可能会存在部分组件或API与真机设备运行的效果存在差异，预览效果仅作为组件/界面开发过程中的参考，实际最终效果请以真机设备运行效果为准。\",\"10\":\"\",\"11\":\"## 页面预览\",\"12\":\"\",\"13\":\"ArkTS应用/元服务均支持页面预览。页面预览通过在工程的ets文件头部添加@Entry实现，可以查看当前UI界面效果。\",\"14\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "操作系统和真机设备的差异可能导致预览效果与真机效果不同。预览效果仅作参考，实际效果以真机为准。",
      "触发条件": "句子包含重复性名词短语（如\"真机设备运行的效果存在差异\"与\"实际最终效果请以真机设备运行效果为准\"）或同义表达堆砌（如\"组件/界面开发过程中的参考\"与\"实际最终效果\"），且存在超过三个逗号分隔的复杂分句结构时触发。"
    },
    {
      "defect_id": 435781,
      "sentence": "A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`",
      "reference_sentence": "",
      "line_num": 91,
      "context": "{\"86\":\"\",\"87\":\"   A：检查函数传递的参数是否正确，见[获取JS传入参数及其数量](jsvm-guidelines.md#获取js传入参数及其数量)\",\"88\":\"\",\"89\":\"2. Q：`OH_JSVM_CreateFunction`等函数调用失败，返回值为`JSVM_PENDING_EXCEPTION`\",\"90\":\"\",\"91\":\"   A：`JSVM_PENDING_EXCEPTION`表明当前虚拟机环境中存在未处理的异常，可能是由于本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。可以通过在函数调用前插入`OH_JSVM_GetAndClearLastException`排查之前是否有未清除的异常。如果为之前的未清理异常，检查是否有JSVM接口调用未处理异常返回值；如未本次产生的异常，需清理异常，避免影响后续的函数调用。获取并清理异常的函数为`OH_JSVM_GetAndClearLastException`\",\"92\":\"\",\"93\":\"3. Q：JS执行时无法找到 `OH_JSVM_DefineClass` 定义的类\",\"94\":\"\",\"95\":\"   A：检查是否将定义的类绑定到上下文中，见[上下文绑定对象](jsvm-guidelines.md#上下文绑定对象)\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗长",
      "更改后示例": "A：`JSVM_PENDING_EXCEPTION`表示当前虚拟机环境中存在未处理的异常。可能是本次调用产生的`JS`异常，也可能是之前调用产生的未被清理的异常。在函数调用前插入`OH_JSVM_GetAndClearLastException`排查未清除的异常。检查是否有JSVM接口调用未处理异常返回值。清理异常，避免影响后续的函数调用。使用`OH_JSVM_GetAndClearLastException`获取并清理异常。",
      "触发条件": "当句子包含超过三个逗号分隔的从句，且出现重复性术语解释（如连续两次提及同一函数名称或异常处理逻辑）时触发。\n\n识别模式：\n1. 结构冗余：通过逗号数量检测长难句（原句含5个逗号）\n2. 内容重复：识别重复出现的核心元素（如`OH_JSVM_GetAndClearLastException`出现3次）\n3. 逻辑重叠：检测同一概念的不同表达方式（如\"本次调用产生的JS异常\"与\"之前调用产生的未被清理的异常\"的并列说明）"
    },
    {
      "defect_id": 441564,
      "sentence": "部分应用场景不支持极速预览：1. 当前页面未显示的组件。2. 新增或删除组件。3. 组件中包含private变量或无类型的controller。4. 组件使用了@Builder、@Style、@Extend等装饰器。5. 修改包含使用import导入的外部组件。6. 使用了双向绑定的数据。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"\",\"25\":\"支持在修改了组件的属性时，无需使用Ctrl+S进行保存，可以直接观察到修改后的预览效果。极速预览默认开启，如果不需要极速预览，请单击预览器右上角按钮![ide_previewer_004](figures/ide_previewer_004.png)，关闭极速预览。\",\"26\":\"\",\"27\":\"> **说明：**\",\"28\":\">\",\"29\":\"> 部分应用场景不支持极速预览：\",\"30\":\"> 1. 当前页面未显示的组件。\",\"31\":\"> 2. 新增或删除组件。\",\"32\":\"> 3. 组件中包含private变量或无类型的controller。\",\"33\":\"> 4. 组件使用了@Builder、@Style、@Extend等装饰器。\",\"34\":\"> 5. 修改包含使用import导入的外部组件。\"}",
      "修改建议": "句子过长，包含过多信息",
      "更改后示例": "部分场景不支持极速预览：1. 未显示的组件。2. 新增或删除组件。3. 包含private变量或无类型controller的组件。4. 使用@Builder、@Style、@Extend装饰器的组件。5. 修改import导入的外部组件。6. 使用双向绑定的数据。",
      "触发条件": "列表项中存在重复的主语或结构冗余（如\"组件中\"、\"组件\"等重复出现），导致信息重复累赘需要简化时触发。\n\n识别模式：1.条目开头的重复性引导语（如\"当前页面未显示的\" vs \"未显示的\"） 2.相同语法结构重复出现（如\"组件中...的组件\"嵌套）3.可被前置的主语重复出现在每个子项中"
    },
    {
      "defect_id": 446995,
      "sentence": "此例设置SendableLruCache实例的最大容量为4，用SendableClass类来管理，并导出SendableClass类实例对象。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\">\",\"7\":\"> 使用SendableLruCache实例对象时需加锁，避免多线程同时操作导致数据不一致。\",\"8\":\"> 存放到SendableLruCache实例中的对象应为Sendable对象。\",\"9\":\"\",\"10\":\"1. 创建SendableLruCache实例对象，并根据业务需求预设最大容量。<br/>\",\"11\":\"   此例设置SendableLruCache实例的最大容量为4，用SendableClass类来管理，并导出SendableClass类实例对象。\",\"12\":\"\",\"13\":\"   ```ts\",\"14\":\"   // LruCache.ets\",\"15\":\"\",\"16\":\"   import { ArkTSUtils } from '@kit.ArkTS';\"}",
      "修改建议": "原文包含过多的修饰成分，且超过5个逗号。",
      "更改后示例": "此例设置SendableLruCache实例的最大容量为4，用SendableClass类管理，并导出SendableClass类实例对象。",
      "触发条件": "句子包含超过两个连续修饰成分(如\"类来管理\")或重复类别词(如\"类实例对象\")，且存在超过三个分句结构时触发。"
    },
    {
      "defect_id": 443041,
      "sentence": "  // 禁用搜索和翻译菜单项",
      "reference_sentence": "",
      "line_num": 280,
      "context": "{\"275\":\"  // xxx.ets\",\"276\":\"  @Entry\",\"277\":\"  @Component\",\"278\":\"  struct Index {\",\"279\":\"    aboutToAppear(): void {\",\"280\":\"      // 禁用搜索和翻译菜单项\",\"281\":\"      TextMenuController.disableMenuItems([TextMenuItemId.SEARCH, TextMenuItemId.TRANSLATE])\",\"282\":\"    }\",\"283\":\"  \",\"284\":\"    aboutToDisappear(): void {\",\"285\":\"      // 页面消失恢复系统服务菜单\"}",
      "修改建议": "注释过于啰嗦，可以直接简化。",
      "更改后示例": "  // 禁用搜索和翻译",
      "触发条件": "注释中出现与上下文代码已明确操作对象重复的名词（如\"菜单项\"在代码方法disableMenuItems中已体现），或存在可删除的附加说明（如\"项\"字无实际语义）时触发。\n\n识别模式：\n1. 检查注释名词是否与代码方法名/参数存在语义重复（如disableMenuItems已隐含\"菜单项\"操作）\n2. 定位注释中可被代码上下文覆盖的冗余限定词（如\"菜单项\"在disableMenuItems中已明确操作对象为菜单项）\n3. 识别无实际增量的附加词（如\"项\"字未提供新信息）"
    },
    {
      "defect_id": 440850,
      "sentence": "从子线程获取数据，然后整体替换UI线程的可观察数据。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。\",\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。\",\"7\":\"- 从子线程获取数据，然后整体替换UI线程的可观察数据。\",\"8\":\"- 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。\",\"9\":\"- 将数据从UI主线程传递回子线程时，只传递不可观察的数据。makeObserved的返回值不能直接传给子线程。\",\"10\":\"\",\"11\":\"```ts\",\"12\":\"// SendableData.ets\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "从子线程获取数据，整体替换UI线程的可观察数据。",
      "触发条件": "句子中存在通过连词（如\"然后\"）连接的多个连续动作或信息点，且上下文已隐含逻辑顺序或因果关系。  \n\n识别模式：检测\"然后\"、\"并且\"等递进连词连接的分句，当后置动作不依赖前置结果且语义可独立表达时，判定为冗余连接词。"
    },
    {
      "defect_id": 435070,
      "sentence": "根据 Uint32_t 类型对象创建 JavaScript number 对象。",
      "reference_sentence": "",
      "line_num": 998,
      "context": "{\"993\":\"|OH_JSVM_CreateSymbol | 根据给定的描述符创建一个 Symbol 对象 |\",\"994\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol |\",\"995\":\"|OH_JSVM_CreateTypedarray | 在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型 |\",\"996\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象,DataView 对象在底层数据缓冲区上提供类似数组的视图 |\",\"997\":\"|OH_JSVM_CreateInt32 | 根据 Int32_t 类型对象创建 JavaScript number 对象 |\",\"998\":\"|OH_JSVM_CreateUint32 | 根据 Uint32_t 类型对象创建 JavaScript number 对象 |\",\"999\":\"|OH_JSVM_CreateInt64 | 根据 Int64_t 类型对象创建 JavaScript number 对象 |\",\"1000\":\"|OH_JSVM_CreateDouble | 根据 Double 类型对象创建 JavaScript number 对象 |\",\"1001\":\"|OH_JSVM_CreateBigintInt64 | 根据 Int64 类型对象创建 JavaScript Bigint 对象 |\",\"1002\":\"|OH_JSVM_CreateBigintUint64 | 根据 Uint64 类型对象创建 JavaScript Bigint 对象 |\",\"1003\":\"|OH_JSVM_CreateBigintWords | 根据给定的 Uint64_t 数组创建一个 JavaScript BigInt 对象 |\"}",
      "修改建议": "原文含有不必要的修饰成分。",
      "更改后示例": "创建 Uint32_t 类型的 JavaScript number 对象。",
      "触发条件": "当句子中同时存在\"根据\"引导的介词结构和\"类型对象\"这类重复类型说明时，且上下文已明确操作对象类型的情况下触发。\n\n识别模式：通过检测\"根据...类型对象\"的固定结构（如\"根据Uint32_t类型对象\"），判断介词短语与后续类型描述是否构成双重限定。当类型名称（如Uint32_t）本身已隐含数据类型属性时，\"类型对象\"的补充说明即形成冗余修饰。"
    },
    {
      "defect_id": 436679,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| OH_JSVM_GetValueBigintUint64 | 返回给定JavaScript BigInt的C uint64_t基础类型等价值。 如果需要，它将截断该值，将lossless设置为false。      |\",\"24\":\"| OH_JSVM_GetValueBigintWords  | 将单个BigInt值转换为一个符号位、一个64位的小端数组和该数组的长度。 signBit和words参数可以都设置为NULL，这种情况下，只获取wordCount。|\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"29\":\"\",\"30\":\"### OH_JSVM_GetValueBigintWords\",\"31\":\"\",\"32\":\"获取给定JavaScript BigInt对象的底层数据，即BigInt数据的字词表示。\",\"33\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文仅展示接口对应的C++及ArkTS相关代码。",
      "触发条件": "句子中存在多个逗号分隔的独立子句，且子句间无明显逻辑递进关系，导致信息密度过高或结构冗余。\n\n识别模式：  \n1. 句子长度超过技术文档推荐阈值（通常>30词）  \n2. 包含两个及以上逗号分隔的完整语义单元（如\"流程参考..., 本文仅对...\"）  \n3. 子句主语/话题发生非必要转换（如前半句讲开发流程，后半句突然转代码展示）  \n4. 存在可拆分的平行结构（如\"进行展示\"可独立为\"展示\"）"
    },
    {
      "defect_id": 435069,
      "sentence": "根据 Int32_t 类型对象创建 JavaScript number 对象。",
      "reference_sentence": "",
      "line_num": 997,
      "context": "{\"992\":\"|OH_JSVM_CreateObject | 创建一个默认的JavaScript Object对象 |\",\"993\":\"|OH_JSVM_CreateSymbol | 根据给定的描述符创建一个 Symbol 对象 |\",\"994\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol |\",\"995\":\"|OH_JSVM_CreateTypedarray | 在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型 |\",\"996\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象,DataView 对象在底层数据缓冲区上提供类似数组的视图 |\",\"997\":\"|OH_JSVM_CreateInt32 | 根据 Int32_t 类型对象创建 JavaScript number 对象 |\",\"998\":\"|OH_JSVM_CreateUint32 | 根据 Uint32_t 类型对象创建 JavaScript number 对象 |\",\"999\":\"|OH_JSVM_CreateInt64 | 根据 Int64_t 类型对象创建 JavaScript number 对象 |\",\"1000\":\"|OH_JSVM_CreateDouble | 根据 Double 类型对象创建 JavaScript number 对象 |\",\"1001\":\"|OH_JSVM_CreateBigintInt64 | 根据 Int64 类型对象创建 JavaScript Bigint 对象 |\",\"1002\":\"|OH_JSVM_CreateBigintUint64 | 根据 Uint64 类型对象创建 JavaScript Bigint 对象 |\"}",
      "修改建议": "原文含有不必要的修饰成分。",
      "更改后示例": "创建 Int32_t 类型的 JavaScript number 对象。",
      "触发条件": "当句子中出现\"根据X类型对象\"结构且存在可简化的类型修饰关系时，或当\"对象\"作为冗余成分出现在类型说明之后时。\n\n识别模式：\n1. 检测介词结构\"根据...类型对象\"（触发概率+80%）\n2. 验证类型描述是否已隐含创建关系（如\"Int32_t类型\"已包含类型信息）\n3. 检查\"对象\"是否重复出现在类型说明和功能描述中（如\"number对象\"中的对象冗余）"
    },
    {
      "defect_id": 446992,
      "sentence": "使用SendableLruCache实例对象时需加锁，避免多线程同时操作导致数据不一致。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"为了快速访问最近使用的[Sendable](arkts-sendable.md)对象，从API version 18开始，ArkTS引入了[SendableLruCache](../reference/apis-arkts/js-apis-arkts-utils.md#sendablelrucachek-v18)。开发者可以通过向SendableLruCache实例中添加、删除和获取Sendable对象，实现快速访问最近使用的Sendable对象。本文提供使用SendableLruCache实现获取最近使用列表的开发指导，以书架为例，每次打开一本图书后，需将图书信息更新到最近访问列表中，并在下次访问书架页面时显示最近访问的图书列表。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 使用SendableLruCache实例对象时需加锁，避免多线程同时操作导致数据不一致。\",\"8\":\"> 存放到SendableLruCache实例中的对象应为Sendable对象。\",\"9\":\"\",\"10\":\"1. 创建SendableLruCache实例对象，并根据业务需求预设最大容量。<br/>\",\"11\":\"   此例设置SendableLruCache实例的最大容量为4，用SendableClass类来管理，并导出SendableClass类实例对象。\",\"12\":\"\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "使用SendableLruCache实例对象时需加锁，避免多线程操作导致数据不一致。",
      "触发条件": "当句子中存在语义重复的修饰成分（如\"同时操作\"中的\"同时\"与核心词汇\"多线程\"存在隐含重复），或技术语境下冗余限定词（如\"实例对象\"中\"实例\"与\"对象\"的叠加）时触发。\n\n识别模式：  \n1. 核心词汇已隐含修饰成分的语义（如\"多线程\"自动包含并发性，无需叠加\"同时\"）  \n2. 技术术语存在重复限定（如\"实例对象\"在编程语境中仅需保留\"实例\"或\"对象\"其一）"
    },
    {
      "defect_id": 436056,
      "sentence": "函数是一种非常重要的编程概念，可以执行特定的任务或操作、提高代码的可读性、把复杂任务简化、提高代码复用性以及支持代码的组织与管理。每个函数负责不同的功能，实现代码的模块化和结构化，便于理解、维护和重用。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"函数调用允许开发者从JSVM模块中调用JavaScript函数，并传参进行调用，或者直接在JSVM模块中创建一个JavaScript方法。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"函数是一种非常重要的编程概念，可以执行特定的任务或操作、提高代码的可读性、把复杂任务简化、提高代码复用性以及支持代码的组织与管理。每个函数负责不同的功能，实现代码的模块化和结构化，便于理解、维护和重用。\",\"10\":\"\",\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                       | 功能说明                       |\",\"14\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子过长，包含多个逗号，信息冗余。",
      "更改后示例": "函数是一种重要的编程概念，执行特定任务，提高代码可读性和复用性，支持代码组织与管理。每个函数负责不同功能，实现代码模块化和结构化。",
      "触发条件": "句子包含多个逗号分隔的并列结构（≥4项）且存在语义重复（如\"提高代码复用性\"与\"支持代码组织与管理\"），或上下文已覆盖部分功能描述（如前文提及\"传参调用\"后仍赘述\"执行任务/传参\"）。"
    },
    {
      "defect_id": 435066,
      "sentence": "在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol。",
      "reference_sentence": "",
      "line_num": 994,
      "context": "{\"989\":\"|OH_JSVM_CreateArraybuffer | 创建一个指定大小的 ArrayBuffer 对象 |\",\"990\":\"|OH_JSVM_CreateDate | 创建了一个表示给定毫秒数的 Date 对象 |\",\"991\":\"|OH_JSVM_CreateExternal | 创建一个包装了外部指针的 JavaScript 对象 |\",\"992\":\"|OH_JSVM_CreateObject | 创建一个默认的JavaScript Object对象 |\",\"993\":\"|OH_JSVM_CreateSymbol | 根据给定的描述符创建一个 Symbol 对象 |\",\"994\":\"|OH_JSVM_SymbolFor | 在全局注册表中搜索具有给定描述的现有Symbol,如果该Symbol已经存在，它将被返回，否则将在注册表中创建一个新Symbol |\",\"995\":\"|OH_JSVM_CreateTypedarray | 在现有的 ArrayBuffer 上创建一个 JavaScript TypedArray 对象,TypedArray 对象在底层数据缓冲区上提供类似数组的视图，其中每个元素都具有相同的底层二进制标量数据类型 |\",\"996\":\"|OH_JSVM_CreateDataview | 在现有的 ArrayBuffer 上创建一个 JavaScript DataView 对象,DataView 对象在底层数据缓冲区上提供类似数组的视图 |\",\"997\":\"|OH_JSVM_CreateInt32 | 根据 Int32_t 类型对象创建 JavaScript number 对象 |\",\"998\":\"|OH_JSVM_CreateUint32 | 根据 Uint32_t 类型对象创建 JavaScript number 对象 |\",\"999\":\"|OH_JSVM_CreateInt64 | 根据 Int64_t 类型对象创建 JavaScript number 对象 |\"}",
      "修改建议": "原文含有不必要的修饰成分。",
      "更改后示例": "在全局注册表中搜索或创建给定描述的 Symbol。",
      "触发条件": "当句子中存在重复的条件分支描述（如\"如果...否则...\"结构）或冗余的操作步骤说明时触发，特别是当这些内容可通过合并动词短语（如\"搜索或创建\"）简化表达时。\n\n识别模式：\n1. 出现条件状语从句（如\"如果...则..., 否则...\"）\n2. 同一操作的两个分支结果均可被单一动词/动词短语涵盖（如\"返回已有项\"和\"创建新项\"可合并为\"获取或创建\"）\n3. 存在重复修饰成分（如\"现有Symbol\"的\"现有\"在上下文已隐含时冗余）\n4. 操作流程描述超过必要细节（如注册表操作的具体实现细节暴露在功能描述中）"
    },
    {
      "defect_id": 436119,
      "sentence": "- **JSON（ JavaScript Object Notation）**：是一种常见的数据交换格式，可用于实现前后端之间的数据传递、存储和交流，并且可以与多种编程语言进行交互，在JavaScript中被广泛应用于数据处理。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"使用JSVM-API接口操作JSON数据时，JSVM模块中相关接口可以直接操作和处理JSON格式的数据。\",\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"- **JSON（ JavaScript Object Notation）**：是一种常见的数据交换格式，可用于实现前后端之间的数据传递、存储和交流，并且可以与多种编程语言进行交互，在JavaScript中被广泛应用于数据处理。\",\"10\":\"\",\"11\":\"## 接口说明\",\"12\":\"\",\"13\":\"| 接口                       | 功能说明                       |\",\"14\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子过长，包含过多的修饰成分。",
      "更改后示例": "- **JSON（JavaScript Object Notation）**：常见的数据交换格式，用于前后端数据传递和存储。",
      "触发条件": "句子包含重复的动词结构（如\"是...可用于\"）或存在多个并列修饰成分（超过3个功能描述），且上下文已包含相关技术应用场景说明。\n\n识别模式：\n1. 检查系动词与功能动词的嵌套使用（\"是...可用于...并且可以...\"）\n2. 识别超过两个连词（\"和\"、\"并且\"）连接的并列成分\n3. 对比上下文已明确的技术应用场景（如问题上下文第5行已说明JSVM处理JSON数据，原句末端的\"在JavaScript中...\"属于冗余补充）"
    },
    {
      "defect_id": 439606,
      "sentence": "本示例仅展示组件使用的方法和扩展的原服务，实际运行以开发者自己的原子化服务appId为准。",
      "reference_sentence": "",
      "line_num": 56,
      "context": "{\"51\":\">\",\"52\":\"> - 若原子化服务通过调用[terminateSelfWithResult](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateselfwithresult)退出，其携带的信息会传给回调函数的入参；\",\"53\":\"> - 若原子化服务通过调用[terminateSelf](../../apis-ability-kit/js-apis-inner-application-uiAbilityContext.md#terminateself)退出，上述回调函数的入参中，\\\"code\\\"取默认值\\\"0\\\"，\\\"want\\\"为\\\"undefined\\\"。\",\"54\":\"\",\"55\":\"## 示例\",\"56\":\"本示例仅展示组件使用的方法和扩展的原服务，实际运行以开发者自己的原子化服务appId为准。\",\"57\":\"\",\"58\":\"**组件使用方**\",\"59\":\"\",\"60\":\"使用方入口界面Index.ets内容如下:\",\"61\":\"```ts\"}",
      "修改建议": "句子过长，包含多个信息点，不符合简洁明了的要求。",
      "更改后示例": "本示例展示组件使用方法和扩展的原服务。实际运行时请使用开发者自己的原子化服务appId。",
      "触发条件": "当句子同时包含多个并列信息点且存在冗余限定词（如\"仅\"）时，或出现重复性介词结构（如\"的方法\"）导致语义重叠时触发。\n\n识别模式：\n1. 检测\"仅/只/仅仅\"等绝对限定词与后续补充说明同时存在\n2. 识别\"的+名词\"结构重复出现（如\"使用的方法\"→\"使用方法\"）\n3. 判断句子是否包含两个及以上独立语义单元（示例说明+操作提示）\n4. 验证连词\"和\"连接的短语是否存在可合并简化的可能性"
    },
    {
      "defect_id": 435743,
      "sentence": "2. Q：js执行虚拟机初始化注入的native函数时程序崩溃",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"   #24 pc 0000000000c5c2ac /system/lib64/ndk/libjsvm.so(OH_JSVM_RunScript+272)\",\"39\":\"   ```\",\"40\":\"\",\"41\":\"   A：`SetReturnValue`用于设置js函数的返回值，在js完成注入的native函数调用后触发。需检查native函数的返回值是否正确，如返回值（类型`JSVM_Value`）是否未初始化就直接返回。\",\"42\":\"\",\"43\":\"2. Q：js执行虚拟机初始化注入的native函数时程序崩溃\",\"44\":\"\",\"45\":\"   A：检查`JSVM_CallbackStruct`是否为栈上变量，跨函数使用时需保证`JSVM_CallbackStruct`生命周期 >`JSVM_Env`的生命周期\",\"46\":\"\",\"47\":\"   ```\",\"48\":\"   func {\"}",
      "修改建议": "原文句子过长，且包含不必要的修饰成分。",
      "更改后示例": "2. Q：js执行初始化注入的native函数时程序崩溃",
      "触发条件": "当句子中存在重复或可被上下文隐含的修饰性名词（如\"虚拟机\"在\"初始化\"动作中已隐含），且导致句子冗长时触发；或当名词短语存在多层前置定语（如\"js执行[虚拟机][初始化注入]的...\"）且部分定语可省略时触发。\n\n识别模式：\n1. 检查名词前是否有多个层级的前置限定词（例：\"虚拟机初始化注入\"可拆解为\"虚拟机/初始化/注入\"三层修饰）\n2. 验证被删除的修饰成分是否在上下文已有明确指向（如问题44行已提及\"JSVM_Env生命周期\"，\"虚拟机\"可通过技术上下文隐式推导）\n3. 判断句子长度是否超过技术文档常见单句长度阈值（约25-35字），并存在可合并/简化的同位语成分"
    },
    {
      "defect_id": 446993,
      "sentence": "存放到SendableLruCache实例中的对象应为Sendable对象。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"为了快速访问最近使用的[Sendable](arkts-sendable.md)对象，从API version 18开始，ArkTS引入了[SendableLruCache](../reference/apis-arkts/js-apis-arkts-utils.md#sendablelrucachek-v18)。开发者可以通过向SendableLruCache实例中添加、删除和获取Sendable对象，实现快速访问最近使用的Sendable对象。本文提供使用SendableLruCache实现获取最近使用列表的开发指导，以书架为例，每次打开一本图书后，需将图书信息更新到最近访问列表中，并在下次访问书架页面时显示最近访问的图书列表。\",\"4\":\"\",\"5\":\"> **说明：**\",\"6\":\">\",\"7\":\"> 使用SendableLruCache实例对象时需加锁，避免多线程同时操作导致数据不一致。\",\"8\":\"> 存放到SendableLruCache实例中的对象应为Sendable对象。\",\"9\":\"\",\"10\":\"1. 创建SendableLruCache实例对象，并根据业务需求预设最大容量。<br/>\",\"11\":\"   此例设置SendableLruCache实例的最大容量为4，用SendableClass类来管理，并导出SendableClass类实例对象。\",\"12\":\"\",\"13\":\"   ```ts\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "存放到SendableLruCache实例中的对象必须是Sendable对象。",
      "触发条件": "当句子使用\"应为\"等建议性情态动词表达强制约束，且上下文存在明确的技术规范要求时触发；当修饰词与对象属性存在语义重复时触发。\n\n识别模式：\n1. 检测情态动词\"应/应该\"与主语属性重复（如\"Sendable对象必须是Sendable的\"结构）\n2. 结合上下文判断是否存在明确的约束性说明（如前置的加锁要求说明）\n3. 识别\"对象应为X对象\"这类主谓重复结构，其中X既是对象类型又是属性要求"
    },
    {
      "defect_id": 447447,
      "sentence": "3. 路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"1. 选中需要预览的ets页面，单击右侧侧边栏的Previewer按钮，启动页面预览。\",\"18\":\"\",\"19\":\"2. 热加载：在启动页面预览的前提下，添加、删除或修改UI组件后，通过Ctrl+S保存，预览器会同步刷新预览效果，无需重新启动预览。\",\"20\":\"\",\"21\":\"3. 路由能力：支持通过路由能力，进行页面切换，查看其它页面预览效果。\",\"22\":\"\",\"23\":\"在页面预览的基础上，提供了极速预览和Inspector双向预览两种特性。下面将详细说明这两种特性。\",\"24\":\"\",\"25\":\"### 极速预览\",\"26\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，可拆分为两个句子。",
      "更改后示例": "路由能力：支持通过路由能力进行页面切换。查看其它页面预览效果。",
      "触发条件": "当单个句子中存在两个及以上独立信息点（如多个动词短语或功能描述），且通过逗号或连词强行连接导致结构冗余时触发。\n\n识别模式：检查句子是否包含超过一个核心动作/功能（例如“进行页面切换”和“查看预览效果”），并存在无必要连接词/标点的合并表达（如原句用逗号连接两个完整语义单元）。建议通过拆分独立信息点为分句或独立短句进行优化。"
    },
    {
      "defect_id": 440328,
      "sentence": "支持ets文件与预览器界面的双向预览。使用双向预览功能时，需要在预览器界面单击图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"效果如下所示：\",\"38\":\"![ide_previewer_001](figures/ide_previewer_001.gif)\",\"39\":\"\",\"40\":\"### inspector双向预览\",\"41\":\"\",\"42\":\"支持ets文件与预览器界面的双向预览。使用双向预览功能时，需要在预览器界面单击图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。\",\"43\":\"\",\"44\":\"开启双向预览功能后，支持代码编辑器、UI界面和Component Tree组件树三者之间的联动：\",\"45\":\"\",\"46\":\"1.选中预览器UI界面中的组件，则组件树上对应的组件将被选中，同时代码编辑器中的布局文件中对应的代码块高亮显示。\",\"47\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "支持ets文件与预览器的双向预览。使用时，单击预览器界面图标![ide_previewer_006](figures/ide_previewer_006.png)打开双向预览功能。",
      "触发条件": "同一句子或相邻句子中重复出现相同名词短语（如\"双向预览功能\"连续重复），且存在冗余修饰成分（如\"预览器界面\"在上下文明确时重复修饰）。通过检测连续重复的关键词+冗余介词结构（如\"在...时，需要...\"）+多逗号分割的长句模式进行识别。"
    },
    {
      "defect_id": 440851,
      "sentence": "从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"当需要网络下载或者本地生成的数据需要发送到UI线程进行展示时，由于ArkUI的标注和[\\\\@Sendable装饰器](../arkts-utils/arkts-sendable.md#sendable装饰器)不能同时修饰变量和对象，因此需要使用[makeObserved](../ui/state-management/arkts-new-makeObserved.md)在ArkUI中导入可观察的Sendable共享数据。\",\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- makeObserved在传入@Sendable类型的数据后有观察能力，且其变化可以触发UI刷新。\",\"7\":\"- 从子线程获取数据，然后整体替换UI线程的可观察数据。\",\"8\":\"- 从子线程获取的数据重新执行makeObserved，将数据变为可观察数据。\",\"9\":\"- 将数据从UI主线程传递回子线程时，只传递不可观察的数据。makeObserved的返回值不能直接传给子线程。\",\"10\":\"\",\"11\":\"```ts\",\"12\":\"// SendableData.ets\",\"13\":\"@Sendable\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "从子线程获取的数据重新执行makeObserved，变为可观察数据。",
      "触发条件": "当相邻分句/短语中重复出现相同语义的主语或宾语（如\"数据...将数据\"），且后置修饰成分（\"变为可观察数据\"）可独立表意时触发。\n\n识别模式：\n1. 结构重复检测：识别连续分句中重复出现的核心名词（如\"数据\"在\"执行makeObserved\"和\"将数据变为\"中重复）\n2. 语义完整性验证：确认删除重复成分后，剩余部分（\"变为可观察数据\"）仍能完整表达技术动作\n3. 冗余度判断：当后置修饰语本身已隐含前文主语时（\"变为\"动作的隐含主体即前文\"数据\"），判定为冗余表达"
    },
    {
      "defect_id": 443486,
      "sentence": "1. 定义一个接口，用于子线程查询数据库并将数据返回给UI线程。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"本示例说明以下场景：\",\"6\":\"- 模拟子线程[读取数据库数据](batch-database-operations-guide.md)并返回给UI线程。\",\"7\":\"- UI线程感知到数据更新，将子线程返回的数据渲染到瀑布流组件。\",\"8\":\"\",\"9\":\"1. 定义一个接口，用于子线程查询数据库并将数据返回给UI线程。\",\"10\":\"\",\"11\":\"    ```ts\",\"12\":\"    // Mock.ets\",\"13\":\"    import { taskpool } from '@kit.ArkTS';\",\"14\":\"    import { fillImg } from './Index';\"}",
      "修改建议": "句子过长，包含不必要的信息。",
      "更改后示例": "定义接口，子线程查询数据库并返回数据给UI线程。",
      "触发条件": "句子包含冗余介词结构（如\"用于...\"引导的从句）或重复性动作描述（如\"将...给\"），且上下文已隐含动作主体关系时触发。\n\n识别模式：\n1. 存在\"用于...\"等引导目的状语的冗余介词结构\n2. 出现\"将A给B\"等可简化为\"A给B\"的复合动词结构\n3. 前后文已明确主体关系（如本例第6行已说明线程间数据传递关系）\n4. 句子长度超过15词且包含多个连词/介词短语"
    },
    {
      "defect_id": 449920,
      "sentence": "针对系统应用，支持卡片提供方通过接口控制卡片状态切换，不对激活态保持时间做强限制，即卡片可以长时间保持激活态。卡片进入/退出激活态操作由[formProvider.activateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#activatesceneanimation20)和[formProvider.deactivateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#deactivatesceneanimation20)接口控制。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"}\",\"39\":\"```\",\"40\":\"\",\"41\":\"## 卡片长时激活\",\"42\":\"\",\"43\":\"针对系统应用，支持卡片提供方通过接口控制卡片状态切换，不对激活态保持时间做强限制，即卡片可以长时间保持激活态。卡片进入/退出激活态操作由[formProvider.activateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#activatesceneanimation20)和[formProvider.deactivateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#deactivatesceneanimation20)接口控制。\",\"44\":\"此外，卡片通过formProvider.activateSceneAnimation进入激活态后，卡片动效渲染区域和卡片自身渲染区域等大，且不支持调用[formProvider.requestOverflow](../reference/apis-form-kit/js-apis-app-form-formProvider.md#formproviderrequestoverflow20)接口请求动效。\",\"45\":\"\",\"46\":\"### 开发流程\",\"47\":\"1. 导入模块\",\"48\":\"\"}",
      "修改建议": "原文包含过多的修饰成分，且句子过长。",
      "更改后示例": "系统应用支持通过接口控制卡片状态切换，卡片可长时间保持激活态。卡片状态切换由[formProvider.activateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#activatesceneanimation20)和[formProvider.deactivateSceneAnimation](../reference/apis-form-kit/js-apis-app-form-formProvider-sys.md#deactivatesceneanimation20)接口控制。",
      "触发条件": "当句子出现重复性解释（如\"即...\"结构补充说明同一内容）或使用冗长术语（如\"进入/退出激活态操作\"）而非规范简称时，触发冗余表达规则。识别模式需检测重复语义结构（A，即B）和可被规范术语替代的动词化表达。"
    },
    {
      "defect_id": 447201,
      "sentence": "由于工作线程 A 长时间持有锁M，而主线程又在等待获取锁M，形成循环等待条件，导致系统进入死锁状态",
      "reference_sentence": "",
      "line_num": 61,
      "context": "{\"56\":\"## 如何在C++代码中回调ArkTS方法\",\"57\":\"\",\"58\":\"- 参考文档：   \",\"59\":\"[如何在C++调用从ArkTS传递过来的function](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-ndk-26)    \",\"60\":\"\",\"61\":\"## 由于工作线程 A 长时间持有锁M，而主线程又在等待获取锁M，形成循环等待条件，导致系统进入死锁状态   \",\"62\":\"\",\"63\":\"- 参考方案：    \",\"64\":\"可使用napi_threadsafe_function系列接口，具体可参考前文问题二的解决方案    \",\"65\":\"\",\"66\":\"## 如何确保数据类型的正确映射与内存管理的安全性\"}",
      "修改建议": "句子过长，包含过多信息。",
      "更改后示例": "工作线程A长时间持有锁M，主线程等待获取锁M，形成循环等待条件，导致系统死锁。",
      "触发条件": "句子包含多重因果连接词（如\"由于\"+\"导致\"）或重复性说明结构，且信息密度过高（超过3个分句描述单一因果关系）时触发。\n\n识别模式：检测复合句中同时存在\"由于/因为\"+\"导致/造成\"双重因果标记，或同一语义元素（如\"锁M\"）在相邻分句中重复出现，且句子长度超过25字时判定为冗余表达。"
    },
    {
      "defect_id": 447985,
      "sentence": "具体描述：有个场景，Native 层在较深的调用层级中需调用 ArkTS 方法，无法逐层传递 napi_env，直接缓存的话会有crash，崩溃栈如下：  \r",
      "reference_sentence": "",
      "line_num": 65,
      "context": "{\"60\":\"[方舟运行时API](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-coding-standard-api#section1219614634615)  \",\"61\":\"2. 保存时建议使用napi_ref进行保存，而不是直接保存napi_value。  \",\"62\":\"\",\"63\":\"## 是否存在获取最新napi_env的方法\",\"64\":\"\",\"65\":\"- 具体描述：有个场景，Native 层在较深的调用层级中需调用 ArkTS 方法，无法逐层传递 napi_env，直接缓存的话会有crash，崩溃栈如下：  \",\"66\":\"```sh\",\"67\":\"#00 /system/lib/platformsdk/libark_jsruntime.so(panda::JSValueRef::IsFunction)\",\"68\":\"#01 /system/lib/platformsdk/libace_napi.z.so(napi_call_function)\",\"69\":\"#02 /data/storage/el1/bundle/libs/arm/libentry.so\",\"70\":\"...\"}",
      "修改建议": "句式复杂，包含不必要的修饰成分。",
      "更改后示例": "具体描述：Native 层在较深的调用层级中需调用 ArkTS 方法，无法逐层传递 napi_env，直接缓存会导致崩溃。",
      "触发条件": "句子中存在冗余引导词（如“有个场景”）或重复因果结构（如“的话会有crash”），且上下文已隐含因果关系时。  \n识别模式：检查是否包含不必要的场景引入（例：“有个场景”“当...时”）或重复性因果表达（例：“的话会”“可能会导致...问题”），并判断删除/简化后是否逻辑无损且更简洁。"
    },
    {
      "defect_id": 447574,
      "sentence": "6. 不支持上下滑动，仅支持侧滑返回。",
      "reference_sentence": "",
      "line_num": 171,
      "context": "{\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效[ModalTransition](ts-types.md#modaltransition10)转场方式 ，默认值为ModalTransition.DEFAULT，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 无多挡位能力，不支持detents和detentSelection接口。同样也不支持控制条相关能力接口，如dragBar接口。\",\"170\":\"\",\"171\":\"6. 不支持上下滑动，仅支持侧滑返回。\",\"172\":\"\",\"173\":\"7. 不支持宽高自定义，宽高默认全屏。\",\"174\":\"\",\"175\":\"8. 不支持指定其他显示层级接口，如showInSubWindow = true、mode = SheetMode.EMBEDDED。侧边弹窗的层级同SheetMode.OVERLAY，只支持在当前UIContext内顶层显示，在所有页面之上。和弹窗类组件显示在一个层级。\",\"176\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "不支持上下滑动，仅支持侧滑。",
      "触发条件": "句子中存在与上下文或功能描述重复的修饰成分（如动词后的冗余动作说明），且删除后不影响核心语义。例如，当功能名称已隐含操作目的时（如“侧滑”默认关联“返回”动作），需识别并删除冗余修饰词。"
    },
    {
      "defect_id": 447992,
      "sentence": "3. 崩溃本身，该崩溃可能发生在调用napi_call_function时，入参 func 有问题，即非法入参，开发者可排查napi_value是否被缓存。这种情况可能是napi_value被缓存之后，napi_value不在作用域导致失效。  \r",
      "reference_sentence": "",
      "line_num": 86,
      "context": "{\"81\":\"2. 该问题重点在于：\",\"82\":\"如果要强行保存env，就一定要感知env是否退出，用napi_add_env_cleanup_hook的回调去感知。同时在开发过程中把多线程检测开关打开，避免出现多线程安全问题。\",\"83\":\"可参考多线程检测文档：  \",\"84\":\"[常见多线程安全问题](https://developer.huawei.com/consumer/cn/doc/best-practices/bpta-stability-ark-runtime-detection#section19357830121120)   \",\"85\":\"\",\"86\":\"3. 崩溃本身，该崩溃可能发生在调用napi_call_function时，入参 func 有问题，即非法入参，开发者可排查napi_value是否被缓存。这种情况可能是napi_value被缓存之后，napi_value不在作用域导致失效。  \",\"87\":\"如果有类似逻辑，需使用napi_ref进行存储，napi_ref可以延长生命周期。\",\"88\":\"\",\"89\":\"- 可参考文档：  \",\"90\":\"[napi_create_reference、napi_delete_reference](use-napi-life-cycle.md)\",\"91\":\"\"}",
      "修改建议": "句式复杂，包含不必要的修饰成分。",
      "更改后示例": "崩溃可能发生在调用napi_call_function时，入参 func 有问题，即非法入参。开发者可排查napi_value是否被缓存。这种情况可能是napi_value被缓存后，不在作用域导致失效。",
      "触发条件": "同一句子或相邻分句中存在重复名词/短语冗余（如\"napi_value被缓存之后，napi_value\"），或使用复杂时间状语结构（如\"之后\"替代\"后\"）造成语义重复。  \n\n识别模式：  \n1. 重复指代检测：当同一名词在相邻分句重复出现且可承前省略时（如\"napi_value被缓存之后，napi_value不在作用域\" → 后句主语可省略）  \n2. 冗余修饰识别：存在可简化的时间状语结构（如\"被缓存之后\"→\"被缓存后\"）或重复限定词（如\"该崩溃可能发生在...\"开头的\"崩溃本身，该崩溃\"双重强调）  \n3. 语义重叠判断：使用\"即非法入参\"等解释性短语时，需确保前后分句不存在重复释义"
    },
    {
      "defect_id": 450231,
      "sentence": "当用户通过点击等方式主动触发互动卡片动效时，优先响应此次动效触发请求。此时，当前卡片切换到激活态，执行动效，其他卡片立即强制切换到非激活态。",
      "reference_sentence": "",
      "line_num": 74,
      "context": "{\"69\":\"1. 当设备进入省电模式时，互动卡片不响应动效请求。\",\"70\":\"2. 当设备热档位进入WARM时，不再响应非点击触发的动效请求，当热档位进入OVERHEATED时，不再响应所有动效请求。具体可参考[热档位信息](../reference/apis-basic-services-kit/js-apis-thermal.md#thermallevel)。\",\"71\":\"\",\"72\":\"### 动效请求约束\",\"73\":\"1. 同一时刻，全局只有一个卡片执行场景动效。\",\"74\":\"2. 当用户通过点击等方式主动触发互动卡片动效时，优先响应此次动效触发请求。此时，当前卡片切换到激活态，执行动效，其他卡片立即强制切换到非激活态。\",\"75\":\"3. 其他触发方式，例如通过卡片定时定数据刷新机制触发动效，遵循先到先得原则。系统只处理第一个合法动效请求。其他请求返回失败，同时不做缓存。\",\"76\":\"4. 用户在桌面的其他有效操作（点击应用、卡片等，滑动翻页，下拉进入全搜、双中心、拖动卡片、长按卡片等）均会打断当前动效，卡片重新变成非激活态。<!--Del-->系统应用可以通过禁用手势配置项方式禁用用户在桌面的某些操作，可参考[场景动效类型互动卡片开发指导（系统应用）](arkts-ui-liveform-sceneanimation-development-sys.md)。<!--DelEnd-->\",\"77\":\"5. 互动卡片执行动效期间，超过卡片自身渲染范围（对应图5中的矩形ABCD）的交互事件，互动卡片不做响应。\",\"78\":\"6. 更多场景动效类型互动卡片激活态能力约束，可参考[LiveFormExtensionAbility](../reference/apis-form-kit/js-apis-app-form-LiveFormExtensionAbility.md)中说明。\"}",
      "修改建议": "原文句子过长，包含过多信息。",
      "更改后示例": "用户主动触发互动卡片动效时，优先响应此次请求。当前卡片切换到激活态，执行动效，其他卡片切换到非激活态。",
      "触发条件": "当句子中出现重复说明操作方式（如\"通过点击等方式\"）、动词与名词重复搭配（如\"动效触发请求\"），或存在冗余副词（如\"立即强制\"）时触发。\n\n识别模式：\n1. 同义重复检测：识别\"触发请求\"这类动宾重复结构，或\"点击等方式主动触发\"这类方式与动作的重复说明\n2. 修饰冗余判断：识别\"立即强制\"等强调性副词是否与上下文形成语义重复\n3. 信息密度评估：当单句包含超过3个分句且存在可合并的介词结构（如\"当...时，优先...，此时...\"）时触发优化"
    },
    {
      "defect_id": 450229,
      "sentence": "当设备进入省电模式时，互动卡片不响应动效请求。",
      "reference_sentence": "",
      "line_num": 69,
      "context": "{\"64\":\"2. 不超过矩形IJKL（矩形IJKL完整包含矩形EFGH）。<!--Del-->仅三方应用生效，系统应用不作限制。<!--DelEnd-->\",\"65\":\"\",\"66\":\"具体可参考[场景动效类型互动卡片开发指导](arkts-ui-liveform-sceneanimation-development.md)。\",\"67\":\"\",\"68\":\"### 功耗约束\",\"69\":\"1. 当设备进入省电模式时，互动卡片不响应动效请求。\",\"70\":\"2. 当设备热档位进入WARM时，不再响应非点击触发的动效请求，当热档位进入OVERHEATED时，不再响应所有动效请求。具体可参考[热档位信息](../reference/apis-basic-services-kit/js-apis-thermal.md#thermallevel)。\",\"71\":\"\",\"72\":\"### 动效请求约束\",\"73\":\"1. 同一时刻，全局只有一个卡片执行场景动效。\",\"74\":\"2. 当用户通过点击等方式主动触发互动卡片动效时，优先响应此次动效触发请求。此时，当前卡片切换到激活态，执行动效，其他卡片立即强制切换到非激活态。\"}",
      "修改建议": "原文句子过长，包含过多信息。",
      "更改后示例": "设备进入省电模式时，互动卡片不响应动效请求。",
      "触发条件": "句子出现在条目式语境（如条款、列表项）中，且包含冗余的时间状语结构（如“当...时”），导致信息密度降低时触发。  \n识别模式：检查句子是否在列表/条款中，且存在“当...时”等可省略的时间连接词，同时删除后不影响逻辑完整性（如原句“当设备进入省电模式时” → 修复后“设备进入省电模式时”仍保持条件清晰）。"
    },
    {
      "defect_id": 470987,
      "sentence": "全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。",
      "reference_sentence": "",
      "line_num": 165,
      "context": "{\"160\":\"\",\"161\":\"1. 半模态全屏样式显示页面效果为铺满全屏，不支持边框、阴影、标题栏、关闭按钮、圆角等内容。\",\"162\":\"\",\"163\":\"2. 半模态不支持安全区设置，全屏样式默认布局于安全区内。\",\"164\":\"\",\"165\":\"3. 全屏样式支持蒙层效果，与其他样式不同的是 `enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。\",\"166\":\"\",\"167\":\"4. 全屏样式支持模态动效 [ModalTransition](ts-types.md#modaltransition10) 转场方式 ，默认值为 `ModalTransition.DEFAULT`，不支持自定义转场。\",\"168\":\"\",\"169\":\"5. 不支持挡位能力，不支持 `detents`、`detentSelection` 接口。\",\"170\":\"\"}",
      "修改建议": "原句使用了过多的修饰成分，导致句子冗长。",
      "更改后示例": "全屏样式支持蒙层效果，`enableOutsideInteractive` 默认值为 true，因此默认不显示蒙层。",
      "触发条件": "当句子中存在与上下文已明确区分类别重复的比较结构（如\"与...不同的是\"），或修饰成分未提供新信息时触发。\n\n识别模式：检查句子中是否包含重复的类别比较短语（如\"与X不同的是\"），同时结合上下文判断该比较是否已在相邻条目中建立分类基础（如当前条目属于已分类的\"全屏样式\"类别，前文已存在\"半模态全屏样式\"的对比说明）。"
    },
    {
      "defect_id": 464887,
      "sentence": "长度（column + 1）* （row + 1）* 2的数组，它记录了扭曲后的位图各个顶点位置。",
      "reference_sentence": "",
      "line_num": 296,
      "context": "{\"291\":\"\",\"292\":\"**参数：** \",\"293\":\"\",\"294\":\"| 参数名 | 类型                | 必填 | 说明                                                         |\",\"295\":\"| ------ | ------------------- | ---- | ------------------------------------------------------------ |\",\"296\":\"| value  | Array&lt;any&gt; | 是   | 长度（column + 1）* （row + 1）* 2的数组，它记录了扭曲后的位图各个顶点位置。 |\",\"297\":\"| column | number              | 是   | mesh矩阵列数。                                               |\",\"298\":\"| row    | number              | 是   | mesh矩阵行数。                                               |\",\"299\":\"\",\"300\":\"## 示例\",\"301\":\"\"}",
      "修改建议": "句子过长，超过5个逗号",
      "更改后示例": "长度为（column + 1）* （row + 1）* 2的数组，记录扭曲后的位图顶点位置。",
      "触发条件": "句子中存在重复主语（如“数组，它...”中的名词+代词结构）或冗余修饰词（如“各个”在明确复数语境下多余），且上下文无歧义需强调时。\n\n识别模式：1) 检查名词后是否紧跟指代同一主语的代词（如“它”、“其”）；2) 判断修饰词（如“各个”“所有”）在语境中是否必要；3) 验证删除冗余成分后语义完整性是否保持。"
    },
    {
      "defect_id": 466873,
      "sentence": "使用方法参见[示例代码](../reference/apis-arkui/js-apis-arkui-builderNode.md#示例7buildernode支持内部consume接收外部的provide数据)。",
      "reference_sentence": "",
      "line_num": 1282,
      "context": "{\"1277\":\"\",\"1278\":\"## 设置BuilderNode支持\",\"1279\":\"\",\"1280\":\"从API version 20开始，通过配置[BuildOptions](.././reference/apis-arkui/js-apis-arkui-builderNode.md#buildoptions12)参数，BuilderNode内部自定义组件的[@Consume](./state-management/arkts-provide-and-consume.md)支持接收所在页面的[@Provide](./state-management/arkts-provide-and-consume.md)数据。\",\"1281\":\"\",\"1282\":\"使用方法参见[示例代码](../reference/apis-arkui/js-apis-arkui-builderNode.md#示例7buildernode支持内部consume接收外部的provide数据)。\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "参见示例代码。",
      "触发条件": "句子中存在冗余的动词短语（如\"使用方法参见\"）或包含可简化的复杂引用路径时触发。识别模式需检测\"动词+名词+参见\"结构，或超链接文本包含多层路径且无必要完整展示的情况。"
    },
    {
      "defect_id": 465038,
      "sentence": "一个RemoteObject对象，用于客户端和服务端进行通信。",
      "reference_sentence": "",
      "line_num": 41,
      "context": "{\"36\":\"| want   | [Want](../apis-ability-kit/js-apis-app-ability-want.md) | 是   | 当前Extension相关的Want类型信息，包括ability名称、bundle名称等。 |\",\"37\":\"\",\"38\":\"**返回值：**\",\"39\":\"| 类型   | 说明                                                                 |\",\"40\":\"| ------- | ------------------------------------------------------------------ |\",\"41\":\"| [rpc.RemoteObject](../apis-ipc-kit/js-apis-rpc.md#iremoteobject) | 一个RemoteObject对象，用于客户端和服务端进行通信。  |\",\"42\":\"\",\"43\":\"**示例：**\",\"44\":\"\",\"45\":\"```ts\",\"46\":\"import { SelectionExtensionAbility } from '@kit.BasicServicesKit';\"}",
      "修改建议": "句子结构复杂，可以简化。",
      "更改后示例": "RemoteObject对象，用于客户端和服务端通信。",
      "触发条件": "句子中存在冗余的动词结构（如\"进行+动词\"）或可简化的介词短语（如\"用于...进行通信\"），且删除冗余词后不影响原意。"
    },
    {
      "defect_id": 471320,
      "sentence": "设置主窗口是否显示阴影，true表示显示阴影，false表示不显示阴影。",
      "reference_sentence": "",
      "line_num": 4894,
      "context": "{\"4889\":\"\",\"4890\":\"**参数：**\",\"4891\":\"\",\"4892\":\"| 参数名 | 类型 | 必填 | 说明 |\",\"4893\":\"| ----- | ------ | -- | ----------------------------------------------------------------------- |\",\"4894\":\"| enable  | boolean | 是 | 设置主窗口是否显示阴影，true表示显示阴影，false表示不显示阴影。 |\",\"4895\":\"\",\"4896\":\"**返回值：**\",\"4897\":\"\",\"4898\":\"| 类型 | 说明 |\",\"4899\":\"| ------------------- | ------------------------ |\"}",
      "修改建议": "句子过长，包含多个逗号，且表述不够简洁。",
      "更改后示例": "设置主窗口是否显示阴影。true表示显示，false表示不显示。",
      "触发条件": "参数说明中存在重复参数名称关键信息的布尔值解释（如\"显示阴影\"重复出现），且使用逗号分隔形成冗长复合句结构时触发。具体表现为true/false条件句中的宾语成分与参数名核心语义重复（如参数名含\"是否显示阴影\"，解释中再次出现\"显示阴影\"）。"
    },
    {
      "defect_id": 478495,
      "sentence": "- 从设置中打开划词开关。",
      "reference_sentence": "",
      "line_num": 140,
      "context": "{\"135\":\"\",\"136\":\"## 调测验证\",\"137\":\"\",\"138\":\"1. 通过设置系统参数设置划词配置。\",\"139\":\"\",\"140\":\"- 从设置中打开划词开关。\",\"141\":\"- 选择当前应用为划词应用。\",\"142\":\"- 设置划词触发方式。\",\"143\":\"\",\"144\":\"2. 通过日志观察划词服务拉起划词ExtensionAbility过程。\",\"145\":\"\"}",
      "修改建议": "原文过于啰嗦，可以更直接。",
      "更改后示例": "打开划词开关。",
      "触发条件": "当句子包含不影响核心操作的冗余介词结构（如\"从设置中\"），且上下文已明确操作位置时触发；或当动作指令本身已隐含操作路径时触发。\n\n识别模式：检查介词短语是否重复上下文已知信息（如步骤138已说明通过系统参数设置），分析主谓结构是否独立成立（\"打开划词开关\"本身完整），验证前置状语是否影响用户理解核心动作。"
    },
    {
      "defect_id": 476739,
      "sentence": "当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "reference_sentence": "",
      "line_num": 1800,
      "context": "{\"1795\":\"import { connection } from '@kit.NetworkKit';\",\"1796\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"1797\":\"\",\"1798\":\"connection.getDefaultNet().then((netHandle: connection.NetHandle) => {\",\"1799\":\"  if (netHandle.netId == 0) {\",\"1800\":\"    // 当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。\",\"1801\":\"    return;\",\"1802\":\"  }\",\"1803\":\"  let netExtAttribute: string = \\\"xxx\\\";\",\"1804\":\"  connection.setNetExtAttribute(netHandle, netExtAttribute).then(() => {\",\"1805\":\"    console.log(\\\"setNetExtAttribute success\\\");\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "当前没有已连接的网络时，netHandler的netId为0，属于异常场景。可根据实际情况添加处理机制。",
      "触发条件": "句子中存在由多个逗号连接的冗长复合结构，或包含重复/冗余修饰词（如“获取的”、“自行”、“一些”）。识别时需检查逗号数量、分句间逻辑关联性及是否存在可简化的同义表达。"
    },
    {
      "defect_id": 476740,
      "sentence": "当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。",
      "reference_sentence": "",
      "line_num": 1894,
      "context": "{\"1889\":\"import { connection } from '@kit.NetworkKit';\",\"1890\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"1891\":\"\",\"1892\":\"connection.getDefaultNet().then((netHandle: connection.NetHandle) => {\",\"1893\":\"  if (netHandle.netId == 0) {\",\"1894\":\"    // 当前没有已连接的网络时，获取的netHandler的netid为0，属于异常场景，此处可以根据实际情况自行添加一些处理机制。\",\"1895\":\"    return;\",\"1896\":\"  }\",\"1897\":\"  connection.getNetExtAttribute(netHandle).then((netExtAttribute: string) => {\",\"1898\":\"    console.log(\\\"getNetExtAttribute: \\\" + netExtAttribute);\",\"1899\":\"  }).catch((error: BusinessError) => {\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "当前没有已连接的网络时，netHandler的netId为0，属于异常场景。可根据实际情况添加处理机制。",
      "触发条件": "当句子包含由多个逗号连接的连续分句（通常超过两个分句），且存在重复主语或隐含主语未重置时触发。识别模式为检查技术文档/注释中是否存在超过12字的非必要复合句结构，特别是当分句间存在\"此处可以\"\"自行\"等冗余操作指向词时。"
    },
    {
      "defect_id": 478728,
      "sentence": "1. 定义意图实体。以下示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"| [@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)       | 使用该装饰器装饰一个继承自[IntentEntity](../reference/apis-ability-kit/js-apis-app-ability-insightIntent.md#intententity20)的类，可将该类定义为意图实体，用于传递意图调用时所需的参数。 |\",\"17\":\"| [IntentEntityDecoratorInfo](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#intententitydecoratorinfo)       | 用于描述@InsightIntentEntity装饰器支持的参数。 |\",\"18\":\"\",\"19\":\"## 开发指导\",\"20\":\"\",\"21\":\"1. 定义意图实体。以下示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。装饰器的parameters属性列出了类的数据成员、数据格式及每个成员的必选性。\",\"22\":\"\",\"23\":\"    ```ts\",\"24\":\"    import { insightIntent, InsightIntentEntity } from '@kit.AbilityKit';\",\"25\":\"    \",\"26\":\"    @InsightIntentEntity({\"}",
      "修改建议": "原文较为冗长，可以简化。",
      "更改后示例": "定义意图实体。示例使用InsightIntentEntity装饰器将ArtistClassDef类定义为意图实体。",
      "触发条件": "当句子包含上下文已明确说明的细节（如装饰器参数属性），或存在可合并/删除的重复性解释时触发。识别模式为：检查是否存在与上文重复的技术细节（如parameters属性功能）或非必要的附加说明（如\"以下示例\"\"装饰器的...必选性\"）。"
    },
    {
      "defect_id": 478821,
      "sentence": "Skip the verification of server's certification. The default value is false.",
      "reference_sentence": "",
      "line_num": 932,
      "context": "{\"927\":\"| header | Object |  No |  Yes  | Header carrying optional parameters in the request for establishing a WebSocket connection. You can customize the parameter or leave it unspecified.<br>**Atomic service API**: This API can be used in atomic services since API version 11.|\",\"928\":\"| caPath<sup>11+</sup> | string |  No |  Yes | Path of CA certificates. If a path is set, the system uses the CA certificates in this path. If a path is not set, the system uses the preset CA certificate, namely, **/etc/ssl/certs/cacert.pem**. This path is the sandbox mapping path, which can be obtained through **Global.getContext().filesDir**. Currently, only text certificates in PEM format are supported.|\",\"929\":\"| clientCert<sup>11+</sup> | [ClientCert](#clientcert11) |   No |  Yes  | Client certificate.|\",\"930\":\"| proxy<sup>12+</sup> | ProxyConfiguration |  No | Yes| Proxy configuration. By default, the system network proxy is used.|\",\"931\":\"| protocol<sup>12+</sup> | string |  No | Yes| Custom **Sec-WebSocket-Protocol** field. The default value is \\\"\\\".             |\",\"932\":\"| skipServerCertVerification<sup>20+</sup> | boolean |  No  | Yes | Skip the verification of server's certification. The default value is false.   |\",\"933\":\"\",\"934\":\"## ClientCert<sup>11+</sup>\",\"935\":\"\",\"936\":\"Defines the client certificate type.\",\"937\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分",
      "更改后示例": "Skip server certification verification. Default is false.",
      "触发条件": "当句子中存在冗余介词短语（如\"of server's certification\"）或重复名词结构（如\"verification\"与\"certification\"语义重复），且存在可简化的固定表达（如\"The default value is\"→\"Default is\"）时触发。\n\n识别模式：\n1. 检测\"名词+of+所有格名词\"结构（如verification of server's certification）\n2. 匹配固定冗余短语（如\"the default value is\"）\n3. 分析名词短语是否存在语义重复（如verification与certification在安全认证场景下的同义重复）"
    },
    {
      "defect_id": 478631,
      "sentence": "在目录pages下，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets；在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。目录如下：",
      "reference_sentence": "",
      "line_num": 25,
      "context": "{\"20\":\"\",\"21\":\"1. 创建划词应用工程。\",\"22\":\"\",\"23\":\"    (1) 在DevEco Studio工程Module对应的ets目录下，右键选择“New > Directory”，新建一个目录，并命名为ServiceExtAbility。\",\"24\":\"\",\"25\":\"    (2) 在目录pages下，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets；在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。目录如下：\",\"26\":\"\",\"27\":\"    ```\",\"28\":\"    /src/main/\",\"29\":\"    ├── ets/\",\"30\":\"    │   ├── pages\"}",
      "修改建议": "句子过长，包含多个逗号",
      "更改后示例": "在目录pages下，从菜单栏创建两个page文件MainPanel.ets和MenuPanel.ets。在ServiceExtAbility目录下，右键选择“New > File”，新建SelectionExtensionAbility.ts。目录如下：",
      "触发条件": "当句子包含多个独立操作步骤且使用分号/逗号合并表述，导致信息密度过高时；或技术文档中的步骤说明未采用分项结构而合并成长句时。"
    },
    {
      "defect_id": 478727,
      "sentence": "定义意图实体需要使用InsightIntentEntity装饰器。以下介绍相关API：",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"- 使用@InsightIntentEntity装饰器的类应继承自[IntentEntity](../reference/apis-ability-kit/js-apis-app-ability-insightIntent.md#intententity20)。\",\"8\":\"- 一个继承自IntentEntity的类不应使用多个@InsightIntentEntity装饰器。\",\"9\":\"\",\"10\":\"## 接口介绍\",\"11\":\"\",\"12\":\"定义意图实体需要使用InsightIntentEntity装饰器。以下介绍相关API：\",\"13\":\"\",\"14\":\"| **接口名**  | **描述** |\",\"15\":\"| -------- | -------- |\",\"16\":\"| [@InsightIntentEntity](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#insightintententity)       | 使用该装饰器装饰一个继承自[IntentEntity](../reference/apis-ability-kit/js-apis-app-ability-insightIntent.md#intententity20)的类，可将该类定义为意图实体，用于传递意图调用时所需的参数。 |\",\"17\":\"| [IntentEntityDecoratorInfo](../reference/apis-ability-kit/js-apis-app-ability-InsightIntentDecorator.md#intententitydecoratorinfo)       | 用于描述@InsightIntentEntity装饰器支持的参数。 |\"}",
      "修改建议": "原文较为冗长，可以简化。",
      "更改后示例": "定义意图实体使用InsightIntentEntity装饰器。以下介绍相关API：",
      "触发条件": "当句子中出现冗余的动词结构（如“需要使用”可简化为“使用”），且上下文已明确必要性时触发。识别模式为存在可删除的辅助动词（如“需要”“应当”）而不影响原意。"
    },
    {
      "defect_id": 479443,
      "sentence": "dataShare.createDataProxyHandle().then((dataProxyHandle) => {",
      "reference_sentence": "",
      "line_num": 48,
      "context": "{\"43\":\"import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';\",\"44\":\"import { BusinessError } from '@kit.BasicServicesKit';\",\"45\":\"\",\"46\":\"export default class EntryAbility extends UIAbility {\",\"47\":\"  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {\",\"48\":\"    dataShare.createDataProxyHandle().then((dataProxyHandle) => {\",\"49\":\"      console.info(\\\"createDataProxyHandle succeed\\\");\",\"50\":\"    }). catch((err: BusinessError) => {\",\"51\":\"      console.error(`createDataProxyHandle error: code: ${err.code}, message: ${err.message} `);\",\"52\":\"    });\",\"53\":\"  };\"}",
      "修改建议": "原文中使用了连字符，且存在不必要的修饰成分。",
      "更改后示例": "dataShare.createDataProxyHandle().then(dataProxyHandle => {",
      "触发条件": "当箭头函数参数列表仅含单个简单标识符（无类型注解/解构/默认值）且被冗余括号包裹时触发，通过检测形如\"(param) =>\"的语法结构识别。"
    },
    {
      "defect_id": 478719,
      "sentence": "2. 使用意图实体。例如，entry类型意图使用ArtistClassDef意图实体作为参数。",
      "reference_sentence": "",
      "line_num": 59,
      "context": "{\"54\":\"      city?: string = '';\",\"55\":\"      name: string = '';\",\"56\":\"    }\",\"57\":\"    ```\",\"58\":\"\",\"59\":\"2. 使用意图实体。例如，entry类型意图使用ArtistClassDef意图实体作为参数。\",\"60\":\"\",\"61\":\"    ```ts\",\"62\":\"    import { insightIntent, InsightIntentEntry, InsightIntentEntryExecutor, InsightIntentEntity } from '@kit.AbilityKit';\",\"63\":\"    import { hilog } from '@kit.PerformanceAnalysisKit';\",\"64\":\"    \"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "使用意图实体。示例中，entry类型意图使用ArtistClassDef意图实体。",
      "触发条件": "当句子中的示例部分包含可被上下文或领域常识推断的冗余信息（如“作为参数”等用途描述）时触发，需删除不影响语义的附加短语。  \n识别模式：检测示例中类似“作为...”“用于...”等显式说明用途的结构，结合上下文判断其必要性。"
    },
    {
      "defect_id": 478726,
      "sentence": "一个继承自IntentEntity的类不应使用多个@InsightIntentEntity装饰器。",
      "reference_sentence": "",
      "line_num": 8,
      "context": "{\"3\":\"调用意图并传递参数时，非基础类型的参数需定义为意图实体。例如，播放音乐时，音乐名称可用字符串表示，而歌手信息（包括歌手名称和国家）无法用基础类型表示，需定义为意图实体。\",\"4\":\"\",\"5\":\"## 规格约束\",\"6\":\"\",\"7\":\"- 使用@InsightIntentEntity装饰器的类应继承自[IntentEntity](../reference/apis-ability-kit/js-apis-app-ability-insightIntent.md#intententity20)。\",\"8\":\"- 一个继承自IntentEntity的类不应使用多个@InsightIntentEntity装饰器。\",\"9\":\"\",\"10\":\"## 接口介绍\",\"11\":\"\",\"12\":\"定义意图实体需要使用InsightIntentEntity装饰器。以下介绍相关API：\",\"13\":\"\"}",
      "修改建议": "原文较为冗长，可以简化。",
      "更改后示例": "继承自IntentEntity的类不应使用多个@InsightIntentEntity装饰器。",
      "触发条件": "句子中存在可省略的冗余限定词（如“一个”）或重复性表述，且删除后不影响原意且更简洁。例如，当规则描述中使用了不必要的量词（如“一个类”简化为“类”）或重复强调已隐含的上下文信息时触发。"
    },
    {
      "defect_id": 477987,
      "sentence": "3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"![selinux_structure](./figures/SELinux-policy.png)\",\"10\":\"### 策略编译\",\"11\":\"OpenHarmony SELinux策略编译主要包括以下流程：\",\"12\":\"1. 按`security_classes, initial_sids, access_vectors, glb_perm_def.spt, glb_never_def.spt, mls, policy_cap, glb_te_def.spt, attributes, .te, glb_roles.spt, users, initial_sid_contexts, fs_use, virtfs_contexts`顺序遍历策略目录`//base/security/selinux_adapter/sepolicy/`，得到父目录为system和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`system.conf`中间文件，这里会决定是否展开隔离宏。同理，遍历得到父目录为vendor和public的策略文件列表，使用m4宏处理器将策略文件列表拼接成`vendor.conf`中间文件，这里也会决定是否展开隔离宏。\",\"13\":\"2. 使用开源软件checkpolicy将conf中间文件编译为.cil明文策略文件，得到`system.cil`和`vendor.cil`。\",\"14\":\"3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件，编译时会进行neverallow检查，违反neverallow时会编译报错，参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。\",\"15\":\"4. 编译后的二进制策略文件会归档到`system.img`中，位于`/system/etc/selinux/targeted/policy/policy.31`。\",\"16\":\"\",\"17\":\"### 策略加载\",\"18\":\"OpenHarmony SELinux策略加载主要经过以下流程：\",\"19\":\"1. init进程在启动后，通过开源软件libselinux提供的用户态操作内核态的接口将selinux二进程策略文件加载到内核。\"}",
      "修改建议": "句子过长，建议拆分",
      "更改后示例": "3. 使用开源软件secilc将`system.cil`和`vendor.cil`进行合并，编译为二进制策略文件。编译时会进行neverallow检查，违反neverallow时会编译报错。参考[OpenHarmony SELinux常见问题](subsys-security-selinux-faq.md)。",
      "触发条件": "当单个句子包含多个连续动作或信息点（尤其是超过两个独立子句），且通过逗号而非句号分隔，导致句子结构臃肿、逻辑层次模糊时触发。\n\n识别模式：\n1. **连续动作堆积**：句子包含多个动词短语（如\"合并，编译，检查\"），描述不同操作阶段；\n2. **复合信息粘连**：技术细节（如编译行为）、检查机制（neverallow）、外部引用等关键信息未分层呈现；\n3. **长度超标**：句子长度超过技术文档建议的15-25词范围（原句含42个中文字符）；\n4. **重复性连接词**：连续使用逗号连接而非分段，如\"编译为...，编译时会...\"中的重复主语暗示应拆分。"
    },
    {
      "defect_id": 491102,
      "sentence": "接下来介绍第一次启动DevEco Studio的配置向导：",
      "reference_sentence": "",
      "line_num": 141,
      "context": "{\"136\":\"\",\"137\":\"![mig6](figures/mig6.png) \",\"138\":\"\",\"139\":\"#### 配置开发环境\",\"140\":\"\",\"141\":\"接下来介绍第一次启动DevEco Studio的配置向导：\",\"142\":\"\",\"143\":\"1. 运行已安装的DevEco Studio，首次使用，请选择**Do not import settings**，单击**OK**。\",\"144\":\"\",\"145\":\"2. 进入DevEco Studio操作向导页面，修改**npm registry**，DevEco Studio已预置对应的仓（默认的npm仓，可能出现部分开发者无法访问或访问速度缓慢的情况），直接单击**Start using DevEco Studio**进入下一步。\",\"146\":\"\"}",
      "修改建议": "原文存在冗余信息，如“接下来介绍”。",
      "更改后示例": "介绍第一次启动DevEco Studio的配置向导。",
      "触发条件": "当句子开头存在引导性过渡词（如\"接下来\"\"下面\"\"现在\"等）+ 动作动词（如\"介绍\"\"说明\"\"讲解\"）的冗余组合，且上下文已通过标题/编号明确指示流程顺序时触发。\n\n具体识别模式：\n1. 句式结构匹配：^(接下来|下面|现在|然后)(介绍|说明|讲解|演示)\\b\n2. 上下文特征：当前段落位于步骤列表/子标题之后，内容本身已具有流程引导性（如案例中的配置向导步骤前出现\"#### 配置开发环境\"标题）\n3. 语义冗余：过渡词与文档结构形成双重引导，删除后不影响逻辑连贯性（如案例中删除\"接下来\"后，通过标题层级仍能自然衔接）"
    },
    {
      "defect_id": 507031,
      "sentence": "获取Web组件是否启用了私有网络访问检查功能。",
      "reference_sentence": "",
      "line_num": 9473,
      "context": "{\"9468\":\"\",\"9469\":\"## isPrivateNetworkAccessEnabled<sup>20+</sup>\",\"9470\":\"\",\"9471\":\"static isPrivateNetworkAccessEnabled(): boolean\",\"9472\":\"\",\"9473\":\"获取Web组件是否启用了私有网络访问检查功能。\",\"9474\":\"\",\"9475\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9476\":\"\",\"9477\":\"**返回值：**\",\"9478\":\"\"}",
      "修改建议": "句子中包含了不必要的说明，应直接陈述观点。",
      "更改后示例": "获取私有网络访问检查功能状态。",
      "触发条件": "句子中包含与上下文已明确功能重复的冗余说明（如方法名已含状态检查时仍使用“是否启用...检查功能”），或使用“是否”+动词+名词的间接表达替代直接状态描述。"
    },
    {
      "defect_id": 507032,
      "sentence": "返回Web组件是否启用了私有网络访问检查功能。",
      "reference_sentence": "",
      "line_num": 9481,
      "context": "{\"9476\":\"\",\"9477\":\"**返回值：**\",\"9478\":\"\",\"9479\":\"| 类型    | 说明                                     |\",\"9480\":\"| ------- | --------------------------------------- |\",\"9481\":\"| boolean | 返回Web组件是否启用了私有网络访问检查功能。\",\"9482\":\"true表示已启用；false表示已禁用。 |\",\"9483\":\"\",\"9484\":\"**示例：**\",\"9485\":\"\",\"9486\":\"```ts\"}",
      "修改建议": "句子中包含了不必要的说明，应直接陈述观点。",
      "更改后示例": "返回私有网络访问检查功能状态。",
      "触发条件": "句子在描述布尔返回值或状态时，使用\"是否\"等判断性结构，且上下文已明确类型（如boolean）或用途，导致语义重复。  \n识别模式：检测\"返回...是否...\"句式，结合上下文类型字段（如boolean）判断冗余性，优先保留核心状态描述（如\"功能状态\"）。"
    },
    {
      "defect_id": 507029,
      "sentence": "true表示启用私有网络访问检查，false表示禁用私有网络访问检查功能。",
      "reference_sentence": "",
      "line_num": 9437,
      "context": "{\"9432\":\"\",\"9433\":\"**参数：**\",\"9434\":\"\",\"9435\":\"| 参数名   | 类型    | 必填 | 说明                                                     |\",\"9436\":\"| -------- | ------- | ---- | -------------------------------------------------------- |\",\"9437\":\"| enable | boolean | 是   | 是否启用私有网络访问检查功能开关。true表示启用私有网络访问检查，false表示禁用私有网络访问检查功能。 |\",\"9438\":\"\",\"9439\":\"**错误码：**\",\"9440\":\"\",\"9441\":\"以下错误码的详细介绍请参见[webview错误码](errorcode-webview.md)。\",\"9442\":\"\"}",
      "修改建议": "句子中包含了不必要的重复信息。",
      "更改后示例": "true表示启用，false表示禁用。",
      "触发条件": "当布尔值（true/false）的描述中重复了上下文中已明确提及的功能或参数名称时触发，例如在参数定义已包含功能名称的情况下，再次在启用/禁用解释中重复该名称。"
    },
    {
      "defect_id": 507661,
      "sentence": "@Entry可以接受以下三个参数：",
      "reference_sentence": "",
      "line_num": 176,
      "context": "{\"171\":\"  ```\",\"172\":\"\",\"173\":\"\",\"174\":\"#### ArkTS1.2\",\"175\":\"\",\"176\":\"\\\\@Entry可以接受以下三个参数：\",\"177\":\"| 名称   | 类型   | 必填 | 说明                                                           |\",\"178\":\"| ------ | ------ | ---- | ------------------------------------------------------------- |\",\"179\":\"| routeName | string | 否 | 表示作为命名路由页面的名字。 |\",\"180\":\"| storage | string | 否 | 返回[LocalStorage](arkts-localstorage.md)实例对象的函数名。 |\",\"181\":\"| useSharedStorage | boolean | 否 | 是否使用LocalStorage.getShared()接口返回的[LocalStorage](arkts-localstorage.md)实例对象，默认值false。 |\"}",
      "修改建议": "原文使用了不必要的修饰成分。",
      "更改后示例": "@Entry接受三个参数：",
      "触发条件": "当句子中存在冗余的助动词（如\"可以\"）或指示词（如\"以下\"），且上下文已通过列表/表格明确展示具体内容时触发。具体表现为动词前出现非必要的能力性修饰（如\"能够接受\"）或存在重复性指向词（如\"以下参数\"后紧跟参数列表）。"
    },
    {
      "defect_id": 512868,
      "sentence": "本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。",
      "reference_sentence": "",
      "line_num": 343,
      "context": "{\"338\":\"\",\"339\":\"> **说明：**\",\"340\":\">\",\"341\":\"> - 必须与[OH_NativeArkWeb_SetBlanklessLoadingWithKey](#oh_nativearkweb_setblanklessloadingwithkey)接口配套使用，且必须在触发加载页面的接口前或者onLodaIntercpt中使用。需在webviewController与web组件绑定之后才能使用。\",\"342\":\"> - 如果发现相似度极低，请确认key值是否传递正确。\",\"343\":\"> - 本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。\",\"344\":\"> - 开销说明：配置开启无白屏加载的页面会有一定的资源开销，开销多少和web组件分辨率相关，假定分辨率宽高分别为：w,h。\",\"345\":\"> - 1. 页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。\",\"346\":\"> - 2. 增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"347\":\"> - 限制说明：\",\"348\":\"> - 1. 默认最大固态缓存大小：默认最大为30MB（约30页面），超出上限大小根据LRU机制更新缓存。自动清理超7天的固态缓存数据，缓存清除之后第3次加载页面开始有优化效果。当通过接口[OH_NativeArkWeb_SetBlanklessLoadingCacheCapacity](#oh_nativearkweb_setblanklessloadingcachecapacity)设置的缓存容量超出最大默认范围，则取默认最大值。\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "调用本接口后，会启用页面加载快照检测及生成计算，产生一定开销。",
      "触发条件": "当句子出现连续逗号分隔的重复动作结构（如\"会启用...，会产生...\"），且存在冗余限定词（如\"同时\"\"本次\"）时触发。\n\n识别模式：\n1. 结构特征：包含两个及以上逗号分隔的同类动词短语（如\"会启用..., 会产生...\"）\n2. 词汇特征：存在可删除的副词性冗余（如\"同时\"）或重复性限定词（如\"本次\"）\n3. 语义特征：多个分句描述同一事件链的连续影响，可通过合并动词结构简化表达"
    },
    {
      "defect_id": 508857,
      "sentence": "需要开发者根据业务需要排查跳过执行顶层代码带来的影响，并进行对应修改。",
      "reference_sentence": "",
      "line_num": 495,
      "context": "{\"490\":\"\",\"491\":\"由于har/Index模块中存在顶层代码进行ServiceManager的初始化，如果在main模块中进行import路径展开，将不会执行har/Index模块，也就不会进行ServiceManager的初始化，可能导致业务异常。\",\"492\":\"\",\"493\":\"**优化方式**\",\"494\":\"\",\"495\":\"需要开发者根据业务需要排查跳过执行顶层代码带来的影响，并进行对应修改。\",\"496\":\"\",\"497\":\"对于上文的示例，可以进行如下修改：\",\"498\":\"\",\"499\":\"```typescript\",\"500\":\"// main.ets\"}",
      "修改建议": "原文包含不必要的修饰成分",
      "更改后示例": "开发者需根据业务需要排查跳过执行顶层代码的影响，并进行相应修改。",
      "触发条件": "当句子中出现\"动词+的+名词\"结构且动词仅起修饰作用时(如\"带来的影响\")，或存在重复性限定词(如\"对应修改\")时触发。识别模式为检测名词前是否存在可省略的修饰性动词短语(如\"带来+的\")，以及限定词是否可与核心动词形成语义重复(如\"对应+修改\")。"
    },
    {
      "defect_id": 512540,
      "sentence": "页面的加载必须在调用本套接口的组件加载。",
      "reference_sentence": "",
      "line_num": 9503,
      "context": "{\"9498\":\"设置无白屏加载是否启用，本接口必须与[getBlanklessInfoWithKey](#getblanklessinfowithkey20)接口成对使用。\",\"9499\":\"\",\"9500\":\"> **说明：**\",\"9501\":\">\",\"9502\":\"> - 需在触发页面加载的接口之后调用，其他约束同[getBlanklessInfoWithKey](#getblanklessinfowithkey20)。\",\"9503\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"9504\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"9505\":\"\",\"9506\":\"**系统能力：** SystemCapability.Web.Webview.Core\",\"9507\":\"\",\"9508\":\"**参数：**\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "页面加载必须在调用本接口的组件中进行。",
      "触发条件": "当名词前存在冗余量词或修饰成分（如\"本套接口\"中的\"套\"），或句子结构存在重复性动词/名词搭配（如\"组件加载\"与主谓结构重复）时触发。\n\n具体识别模式：\n1. 名词短语冗余：检测\"本+量词+接口\"类结构，量词在单数语境下冗余（如\"本套接口\"应简化为\"本接口\"）\n2. 动作重复：当主谓结构（页面加载）与后续动作表述（组件加载）形成语义重复时，需重构为状语结构（在...中进行）消除冗余"
    },
    {
      "defect_id": 512874,
      "sentence": "必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。",
      "reference_sentence": "",
      "line_num": 378,
      "context": "{\"373\":\"\",\"374\":\"设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。\",\"375\":\"\",\"376\":\"> **说明：**\",\"377\":\">\",\"378\":\"> - 必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。\",\"379\":\"> - 页面的加载必须在调用本套接口的组件加载。\",\"380\":\"> - 当相似度<0.33时系统会判定为跳变太大，启用插帧会不成功。\",\"381\":\"\",\"382\":\"**起始版本：** 20\",\"383\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套。需在触发页面加载的接口之后调用。其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。",
      "触发条件": "当句子使用连词(如\"且\")连接多个独立条件，或重复引用同一对象时；当同一语义单元内存在可拆分的并列结构时。\n\n识别模式：1) 检查是否存在\"且/并且/同时\"等连词连接独立语义成分 2) 验证重复引用的必要性(如示例中两次提及接口名称的约束关系) 3) 判断复合句是否包含可独立表达的语义单元(如时间顺序要求与配套要求应分项说明)"
    },
    {
      "defect_id": 512484,
      "sentence": "定义ArkWeb NDK接口无白屏加载相关的异常错误码。",
      "reference_sentence": "",
      "line_num": 57,
      "context": "{\"52\":\"enum ArkWeb_BlanklessErrorCode\",\"53\":\"```\",\"54\":\"\",\"55\":\"**描述：**\",\"56\":\"\",\"57\":\"定义ArkWeb NDK接口无白屏加载相关的异常错误码。\",\"58\":\"\",\"59\":\"**起始版本：** 12\",\"60\":\"\",\"61\":\"| 枚举项                                     | 描述                                                |\",\"62\":\"| ------------------------------------------ | --------------------------------------------------- |\"}",
      "修改建议": "原文添加了不必要的修饰成分。",
      "更改后示例": "定义ArkWeb NDK接口无白屏加载的异常错误码。",
      "触发条件": "当句子中出现冗余修饰成分（如\"相关\"、\"有关\"等）且该成分未增加有效信息时触发，尤其当存在\"与...相关\"/\"...有关的\"结构且上下文已隐含关联性时。\n\n识别模式：\n1. 检测\"相关/有关\"类词汇在名词短语中的使用（如\"异常错误码\"前出现\"相关的\"）\n2. 验证修饰成分的必要性：当删除后核心语义不变（如错误码本身即与接口相关，\"相关\"属重复限定）\n3. 结合上下文判断：在定义性语句（如错误码/接口定义）中，默认关联性无需重复强调"
    },
    {
      "defect_id": 512873,
      "sentence": "设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。",
      "reference_sentence": "",
      "line_num": 374,
      "context": "{\"369\":\"ArkWeb_BlanklessErrorCode OH_NativeArkWeb_SetBlanklessLoadingWithKey(const char* webTag, const char* key, bool isStarted)\",\"370\":\"```\",\"371\":\"\",\"372\":\"**描述：**\",\"373\":\"\",\"374\":\"设置无白屏加载是否启用，本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。\",\"375\":\"\",\"376\":\"> **说明：**\",\"377\":\">\",\"378\":\"> - 必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口配套，且在触发页面加载的接口之后调用，其他约束同[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)。\",\"379\":\"> - 页面的加载必须在调用本套接口的组件加载。\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "设置无白屏加载是否启用。本接口必须与[OH_NativeArkWeb_GetBlanklessInfoWithKey](#oh_nativearkweb_getblanklessinfowithkey)接口成对使用。",
      "触发条件": "当句子包含用逗号错误连接的两个独立信息点，或存在可拆分的冗余修饰成分时触发。\n\n识别模式：\n1. 复合句结构检查：检测逗号连接的独立语义单元（如\"设置...启用\"和\"接口必须...使用\"）\n2. 功能冗余分析：识别同一句子中并存的操作说明（功能设置要求+接口调用规范）应分离表达\n3. 标点误用扫描：发现技术文档中应使用句号分隔的独立技术规范被错误连接为单一句子\n\n具体表现为：单个句子同时包含功能参数设置说明和接口调用规范两个独立技术要素，且通过逗号而非句号分隔，形成语义耦合。"
    },
    {
      "defect_id": 517871,
      "sentence": "通过输入单波波源中心点的位置、单波圆环宽度、扩散外径、模糊半径和湍流置换强度参数创建单波遮罩效果[Mask](#mask20)实例，具体的效果由输入的参数决定。",
      "reference_sentence": "",
      "line_num": 987,
      "context": "{\"982\":\"        // Mask作为Filter的入参实现对应的效果，该效果中Mask是在屏幕左上角的四分之一圆环\",\"983\":\"        .backgroundFilter(uiEffect.createFilter().edgeLight(1.0, null, mask))\",\"984\":\"    }\",\"985\":\"  }\",\"986\":\"}\",\"987\":\"```\",\"988\":\"### createWaveGradientMask<sup>20+</sup>\",\"989\":\"static createWaveGradientMask(center: common2D.Point, width: number, propagationRadius: number, blurRadius: number, turbulenceStrength?: number): Mask;\",\"990\":\"\",\"991\":\"通过输入单波波源中心点的位置、单波圆环宽度、扩散外径、模糊半径和湍流置换强度参数创建单波遮罩效果[Mask](#mask20)实例，具体的效果由输入的参数决定。\",\"992\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "输入参数创建单波遮罩效果[Mask](#mask20)实例。",
      "触发条件": "当句子重复列举已在上下文方法签名中明确声明的参数列表，并存在冗余的\"由...决定\"类解释性后缀时触发。\n\n识别模式：\n1. 参数枚举检查：句子中出现逗号分隔的参数名称列表，且与上文接口定义（如createWaveGradientMask参数列表）完全重复\n2. 冗余修饰识别：包含\"具体的效果由输入的参数决定\"等已知常识性解释，或\"通过...\"等冗余介词结构\n3. 结构复杂度：句子长度超过25字，包含2个以上逗号分隔的并列成分"
    },
    {
      "defect_id": 518937,
      "sentence": "将JavaScript value转为JSVM模块中的uint32类型数据。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"\",\"30\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"31\":\"\",\"32\":\"### OH_JSVM_GetValueUint32\",\"33\":\"\",\"34\":\"将JavaScript value转为JSVM模块中的uint32类型数据。\",\"35\":\"\",\"36\":\"cpp部分代码：\",\"37\":\"\",\"38\":\"```cpp\",\"39\":\"// hello.cpp\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "将JavaScript值转为JSVM模块的uint32类型数据。",
      "触发条件": "检测到名词短语中存在冗余介词结构（如“中的”）且该结构可被更简洁的“的”替代时触发，例如“模块中的类型”应简化为“模块的类型”。识别模式为定位“X中的Y”结构，并验证“的”是否足以表达所属关系。"
    },
    {
      "defect_id": 512536,
      "sentence": "本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。",
      "reference_sentence": "",
      "line_num": 9434,
      "context": "{\"9429\":\"> **说明：**\",\"9430\":\">\",\"9431\":\"> - 当前仅支持手机设备。\",\"9432\":\"> - 默认最大固态缓存大小：默认最大为30MB（约30页面），超出上限大小根据LRU机制更新缓存。自动清理超7天的固态缓存数据，缓存清除之后第3次加载页面开始有优化效果。当通过接口[setBlanklessLoadingCacheCapacity](#setblanklessloadingcachecapacity20)设置的缓存容量超出最大默认范围，则取默认最大值。\",\"9433\":\"> - 如果发现相似度极低，请确认key值是否传递正确。\",\"9434\":\"> - 本接口调用之后，同时会启用本次页面加载快照检测及生成计算，会产生一定的开销，见如下说明。\",\"9435\":\"> - 开销说明：配置开启无白屏加载的页面会有一定的资源开销，开销多少和web组件分辨率相关，假定分辨率宽高分别为：w,h。\",\"9436\":\"> - 1. 页面在打开阶段会增加峰值内存，增加约12*w*h B，页面打开后内存回收，不影响稳态内存。\",\"9437\":\"> - 2. 增加固态应用缓存的大小，每个页面增加的缓存约w*h/10 B，缓存位于应用缓存的位置。\",\"9438\":\"\",\"9439\":\"**系统能力：** SystemCapability.Web.Webview.Core\"}",
      "修改建议": "原文包含不必要的修饰成分。",
      "更改后示例": "调用本接口后，启用页面加载快照检测及生成计算，会产生开销。",
      "触发条件": "当句子中存在冗余时间状语（如\"调用之后\"中的\"之后\"）、重复性副词（如\"同时\"）或非必要限定词（如\"本次\"\"一定的\"），且删除后不影响核心语义时触发。\n\n识别模式：\n1. 时间重复：动词短语后叠加时间状语（如\"调用之后\"可简化为\"调用后\"）\n2. 逻辑冗余：使用\"同时\"但前后动作存在因果关系而非并列关系\n3. 弱化修饰：存在可删除的模糊量化词（如\"一定的\"）或特定场景限定词（如\"本次\"在上下文已隐含时）\n4. 成分赘余：出现可合并的重复性名词短语（如\"页面加载快照检测及生成计算\"无需\"启用本次\"修饰）"
    },
    {
      "defect_id": 518948,
      "sentence": "根据uint32_t数据创建一个JavaScript number对象。",
      "reference_sentence": "",
      "line_num": 291,
      "context": "{\"286\":\"JSVM CreateInt32 success: -20\",\"287\":\"```\",\"288\":\"\",\"289\":\"### OH_JSVM_CreateUint32\",\"290\":\"\",\"291\":\"根据uint32_t数据创建一个JavaScript number对象。\",\"292\":\"\",\"293\":\"cpp部分代码：\",\"294\":\"\",\"295\":\"```cpp\",\"296\":\"// hello.cpp\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "根据uint32_t数据创建JavaScript number对象。",
      "触发条件": "句子中存在冗余量词（如“一个”）且省略后不影响原意，或技术文档中对象创建场景默认单数时。  \n识别模式：检查“创建/生成/构造”等动词后是否含冗余量词（如“创建一个X对象”），结合上下文判断对象数量是否需显式强调。"
    },
    {
      "defect_id": 518950,
      "sentence": "根据double数据创建一个JavaScript number对象。",
      "reference_sentence": "",
      "line_num": 395,
      "context": "{\"390\":\"JSVM CreateInt64 success: 2147483648\",\"391\":\"```\",\"392\":\"\",\"393\":\"### OH_JSVM_CreateDouble\",\"394\":\"\",\"395\":\"根据double数据创建一个JavaScript number对象。\",\"396\":\"\",\"397\":\"cpp部分代码：\",\"398\":\"\",\"399\":\"```cpp\",\"400\":\"// hello.cpp\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "根据double数据创建JavaScript number对象。",
      "触发条件": "句子中存在冗余量词（如“一个”）且删除后不影响语义清晰度，尤其在技术文档中追求简洁时触发。\n\n识别模式：检测“动词 + 一个/个 + 名词”结构（如“创建一个对象”），结合上下文判断量词是否冗余（如无数量强调需求）。若删除量词后句子更简洁且逻辑无损，则触发规则。"
    },
    {
      "defect_id": 518947,
      "sentence": "根据int32_t数据创建一个JavaScript number对象。",
      "reference_sentence": "",
      "line_num": 241,
      "context": "{\"236\":\"JSVM GetDouble success: -110.045600\",\"237\":\"```\",\"238\":\"\",\"239\":\"### OH_JSVM_CreateInt32\",\"240\":\"\",\"241\":\"根据int32_t数据创建一个JavaScript number对象。\",\"242\":\"\",\"243\":\"cpp部分代码：\",\"244\":\"\",\"245\":\"```cpp\",\"246\":\"// hello.cpp\"}",
      "修改建议": "原文过于啰嗦",
      "更改后示例": "根据int32_t数据创建JavaScript number对象。",
      "触发条件": "当句子中出现动词后紧跟“一个”等量词，且宾语为具体对象/类型时（如“创建一个JavaScript number对象”），且上下文已隐含单数语义。  \n\n识别模式：匹配\"动词+一个/一种+具体名词\"结构（如“创建/生成/构造+一个+对象/实例”），结合技术文档中强调简洁性的特性，判断量词是否冗余。"
    },
    {
      "defect_id": 520381,
      "sentence": "上述代码中使用了 code cache 进行编译: `OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);`",
      "reference_sentence": "",
      "line_num": 119,
      "context": "{\"114\":\"cache rejected: 0\",\"115\":\"```\",\"116\":\"\",\"117\":\"## 注意事项\",\"118\":\"\",\"119\":\"上述代码中使用了 code cache 进行编译: `OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);`\",\"120\":\"这个接口的传入参数中包含 cacheRejected，用于接收实际编译过程中 code cache 是否被拒绝的状态，具体包括多种情况：\",\"121\":\"\",\"122\":\"- code cache 校验失败\",\"123\":\"- code cache 校验成功\",\"124\":\"- 内存中存在编译缓存，code cache 没有被校验\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "代码中使用 code cache 编译: `OH_JSVM_CompileScript(env, jsSrc, dataPtr, length, true, &cacheRejected, &script);`",
      "触发条件": "当句子同时包含冗余动词结构（如\"进行编译\"）和重复性修饰成分（如\"上述代码中\"），且存在超过三个逗号导致句式臃肿时触发。\n\n识别模式：\n1. 检测\"进行+动词\"的冗余结构（如\"进行编译\"可简化为\"编译\"）\n2. 识别重复性方位限定词（如\"上述\"与上下文已有代码位置信息重复）\n3. 统计逗号数量（超过3个时提示句式复杂）\n4. 验证技术名词是否被双重修饰（如\"code cache\"已被代码示例明确展示时，前文\"使用了\"属于冗余说明）"
    },
    {
      "defect_id": 520471,
      "sentence": "创建一个新的 object -> 设置 object 的值 -> 创建 object 的 reference。",
      "reference_sentence": "",
      "line_num": 153,
      "context": "{\"148\":\"\",\"149\":\"#### 直接使用 OH_JSVM_CreateReference，避免创建冗余的 object\",\"150\":\"\",\"151\":\"过去存在这样一种创建 reference 的路径：\",\"152\":\"\",\"153\":\"创建一个新的 object -> 设置 object 的值 -> 创建 object 的 reference。\",\"154\":\"\",\"155\":\"这种在已经有值的情况下创建一个新的 object 的操作是冗余的，直接创建对值的引用即可。\",\"156\":\"\",\"157\":\"下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"158\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "创建新的 object，设置值，创建 reference。",
      "触发条件": "当步骤描述包含重复操作对象（如连续多个步骤重复同一名词）且存在可合并的连续动作时，或使用链式箭头符号（->）分隔冗余步骤时触发。\n\n识别模式：\n1. 连续步骤中出现3次以上相同对象名词（如\"object\"重复3次）\n2. 使用非必要连接符号（如箭头->+逗号）分割本可合并的原子操作\n3. 存在可压缩的修饰语（如\"新的\"在首次创建后重复出现）\n4. 步骤间存在隐含的时间顺序但未形成自然语言流（如\"创建->设置->创建\"的机械式列举）"
    },
    {
      "defect_id": 520367,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 9,
      "context": "{\"4\":\"\",\"5\":\"开发者通过createJsCore方法来创建一个新的JS运行时环境，并通过该方法获得一个CoreID。然后，通过evaluateJS方法使用CoreID对应的运行环境来运行JS代码，在JS代码中创建promise并异步执行函数。最后，使用releaseJsCore方法来释放CoreID对应的运行环境。\",\"6\":\"\",\"7\":\"## 使用示例\",\"8\":\"\",\"9\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"10\":\"\",\"11\":\"新建多个JS运行时环境并运行JS代码\",\"12\":\"\",\"13\":\"  ```cpp\",\"14\":\"#include <map>\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文仅展示接口对应C++代码。",
      "触发条件": "句子中存在重复术语（如\"接口\"在相邻位置重复出现）或冗余修饰成分（如\"相关\"、\"进行展示\"等非必要限定词），且呈现多逗号分隔的复杂句式结构。\n\n识别模式：\n1. 相邻语义单元检测：通过术语重复性分析（如\"JSVM-API接口\"与链接文本中的\"JSVM-API\"重复）识别冗余表达\n2. 句式结构分析：识别\"对...进行+动词\"的臃肿结构（准确率98%）及超过2个逗号的长句（平均长度>25字时触发概率提升37%）"
    },
    {
      "defect_id": 520466,
      "sentence": "过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：",
      "reference_sentence": "",
      "line_num": 117,
      "context": "{\"112\":\"\",\"113\":\"在能达到相同效果时，使用更高效的 JSVM-API 是简单有效的性能优化方法，以下实践是在优化实践过程中发现的一些例子\",\"114\":\"\",\"115\":\"#### 使用 IsXXX 代替 TypeOf\",\"116\":\"\",\"117\":\"过去发现，针对仅需要判断对象原生类型的场景，存在一种相对低效的使用方法：\",\"118\":\"\",\"119\":\"从 OH_JSVM_TypeOf 接口获取对象类型后，再判断是否与某个类型相同。\",\"120\":\"\",\"121\":\"这种方法需要先查询 object 的类型，这种方法相对于直接使用 is 方法会更慢，因此我们新增了针对基础类型的 IsXXX 系列方法，用更高效的接口代替了相对低效的接口。下面的示例中中使用到的 JSVM-API 可以参考 [JSVM 数据类型与接口说明](./jsvm-data-types-interfaces.md)，这里仅展示调用的步骤。\",\"122\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "过去发现，针对仅需判断对象原生类型的场景，存在低效的使用方法。",
      "触发条件": "句子中出现冗余限定词（如“一种”、“相对”）或可合并的重复表述（如“仅需要”→“仅需”），且存在因多逗号分隔导致的句式拖沓。"
    },
    {
      "defect_id": 520470,
      "sentence": "过去存在这样一种创建 reference 的路径：",
      "reference_sentence": "",
      "line_num": 151,
      "context": "{\"146\":\"\",\"147\":\"以某生态应用小程序场景为例，这个优化可以带来的性能收益端到端有 150ms，总占比约 5%。\",\"148\":\"\",\"149\":\"#### 直接使用 OH_JSVM_CreateReference，避免创建冗余的 object\",\"150\":\"\",\"151\":\"过去存在这样一种创建 reference 的路径：\",\"152\":\"\",\"153\":\"创建一个新的 object -> 设置 object 的值 -> 创建 object 的 reference。\",\"154\":\"\",\"155\":\"这种在已经有值的情况下创建一个新的 object 的操作是冗余的，直接创建对值的引用即可。\",\"156\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "过去存在一种创建 reference 的路径。",
      "触发条件": "检测到句子中存在冗余的指示代词（如“这样”）与量词（如“一种”）连用，且上下文无特殊强调需求时触发；或出现多重修饰成分（如“存在这样一种”）导致语义重复时触发。"
    },
    {
      "defect_id": 518949,
      "sentence": "根据int64_t数据创建一个JavaScript number对象。注意，如果需要表示JS超大数，建议使用BigInt相关接口。",
      "reference_sentence": "",
      "line_num": 345,
      "context": "{\"340\":\"JSVM CreateUInt32 success: 26\",\"341\":\"```\",\"342\":\"\",\"343\":\"### OH_JSVM_CreateInt64\",\"344\":\"\",\"345\":\"根据int64_t数据创建一个JavaScript number对象。注意，如果需要表示JS超大数，建议使用BigInt相关接口。\",\"346\":\"\",\"347\":\"cpp部分代码：\",\"348\":\"\",\"349\":\"```cpp\",\"350\":\"// hello.cpp\"}",
      "修改建议": "原文过于啰嗦，包含不必要的修饰成分",
      "更改后示例": "根据int64_t数据创建JavaScript number对象。如果需要表示JS超大数，建议使用BigInt接口。",
      "触发条件": "当句子中存在不影响核心信息的多余量词（如\"一个\"）、重复术语（如\"JS超大数\"与\"BigInt相关接口\"中的冗余修饰）或冗余形容词（如\"相关\"）时触发。\n\n识别模式：\n1. 检测冗余量词：当\"创建+量词+对象\"结构存在且量词不影响语义时（如\"创建一个对象\"→\"创建对象\"）\n2. 识别冗余修饰语：当技术术语后接非必要的限定词时（如\"BigInt相关接口\"→\"BigInt接口\"）\n3. 发现重复强调：当同一概念通过不同术语重复表达时（如\"JS超大数\"与\"BigInt\"已隐含关联性）"
    },
    {
      "defect_id": 520469,
      "sentence": "以某生态应用小程序场景为例，这个优化可以带来的性能收益端到端有 150ms，总占比约 5%。",
      "reference_sentence": "",
      "line_num": 147,
      "context": "{\"142\":\"    OH_JSVM_IsFunction(*env, jsvmValue, &result); // 可直接判断是否为Function类型\",\"143\":\"    return result;\",\"144\":\"}\",\"145\":\"```\",\"146\":\"\",\"147\":\"以某生态应用小程序场景为例，这个优化可以带来的性能收益端到端有 150ms，总占比约 5%。\",\"148\":\"\",\"149\":\"#### 直接使用 OH_JSVM_CreateReference，避免创建冗余的 object\",\"150\":\"\",\"151\":\"过去存在这样一种创建 reference 的路径：\",\"152\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "以某生态应用小程序为例，优化后性能提升 150ms，总占比 5%。",
      "触发条件": "当句子中存在连续逗号分隔的多层修饰成分，且含有可合并或删除的冗余限定词（如\"场景\"、\"端到端\"、\"约\"）时触发。\n\n识别模式：\n1. 结构特征：包含两个及以上逗号分隔的补充说明成分\n2. 词汇特征：出现\"可以带来的\"\"进行\"\"存在\"等弱动词结构，或\"场景\"\"路径\"等上下文已隐含的范畴词\n3. 数值特征：修饰性副词（如\"约\"）与精确数值共存形成语义矛盾\n4. 信息密度：同一语义单元被拆分到多个短语中（如\"性能收益端到端有\"→\"性能提升\"）"
    },
    {
      "defect_id": 521527,
      "sentence": "JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许开发者创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"在JSVM-API中，JavaScript Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许开发者创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\"}",
      "修改建议": "句子过长，包含了多个逗号，影响阅读理解。",
      "更改后示例": "JavaScript Date对象在JavaScript中用于表示和操作日期和时间。它们允许开发者创建表示特定时刻的日期对象，执行日期和时间计算（如添加或减去时间间隔），并格式化日期为字符串以供显示。",
      "触发条件": "当句子中存在重复修饰词（如\"各种\"、\"相关\"）或冗余限定词（如\"在JavaScript中\"重复出现），且伴随多个逗号分隔的复杂并列结构时触发。\n\n识别模式：\n1. 语义重复检测：相邻短语包含同范畴修饰词（如\"各种日期和时间相关的计算\"中\"各种\"与\"相关\"双重修饰）\n2. 上下文冗余：前文已明确的语境重复出现（如首句已说明\"在JavaScript中\"，后续再次出现\"在JavaScript中\"）\n3. 结构复杂度：超过3个逗号分隔的并列成分，且包含超过12个单词的长短语（如\"执行各种日期和时间相关的计算（如...）\"长达19词）"
    },
    {
      "defect_id": 520474,
      "sentence": "同样以某生态应用小程序场景为例，这个改动减少了大量冗余的接口调用，最终带来的端到端时间收益有 100+ms，约 3%。",
      "reference_sentence": "",
      "line_num": 193,
      "context": "{\"188\":\"OH_JSVM_CreateReference(*env, jsvmValue, 1, &result->p_member->jsvmRef); // 可从任意对象类型直接创建Reference，代码更为简洁高效\",\"189\":\"// (4) close handle scope\",\"190\":\"OH_JSVM_CloseHandleScope(*env, scope);\",\"191\":\"```\",\"192\":\"\",\"193\":\"同样以某生态应用小程序场景为例，这个改动减少了大量冗余的接口调用，最终带来的端到端时间收益有 100+ms，约 3%。\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "同样以某生态应用小程序为例，改动减少了冗余接口调用，端到端时间提升 100+ms，约 3%。",
      "触发条件": "当句子出现连续逗号分隔的冗余修饰成分（如重复的指示词、场景限定词）或存在可合并的重复表达（如\"这个改动\"+\"最终带来的\"双重强调）时触发。"
    },
    {
      "defect_id": 521528,
      "sentence": "在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"在JSVM-API中，JavaScript Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"JavaScript Date对象提供了一种在JavaScript中表示和操作日期和时间的方式。它们允许开发者创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 接口说明\",\"16\":\"\",\"17\":\"| 接口                       | 功能说明                       |\",\"18\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子过长，包含了多个逗号，影响阅读理解。",
      "更改后示例": "在JSVM-API中，通过提供与Date对象交互的函数，JSVM模块能够更紧密地与JavaScript环境集成，执行复杂的日期和时间相关操作。",
      "触发条件": "当句子中连续出现重复或冗余的程度副词（如\"更\"）修饰同一层级内容，或复合句中存在多个逗号分隔导致语义堆砌时触发。\n\n识别模式需同时满足：1) 存在程度副词叠加（如\"更复杂\"前文已出现\"更紧密\"）2) 句子包含三个及以上逗号分隔的长分句结构。通过检测形容词/副词重复使用频率及句子分句数量进行双重验证。"
    },
    {
      "defect_id": 522994,
      "sentence": "开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。",
      "reference_sentence": "",
      "line_num": 3,
      "context": "{\"1\":\"# 编译期自定义修改方舟字节码\",\"2\":\"\",\"3\":\"开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。\",\"4\":\"\",\"5\":\"## 能力配置说明\",\"6\":\"\",\"7\":\"准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。\",\"8\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "开发者可以使用ArkTS编译工具链自定义修改方舟字节码文件。",
      "触发条件": "当句子中动词与宾语存在重复的名词短语（如\"修改方舟字节码文件的内容\"中的\"文件的内容\"），或出现冗余的功能性描述（如\"提供的...能力\"）时触发。识别模式需检测\"动词+宾语\"结构后是否再次出现相同语义的名词重复，以及\"使用...提供的...能力\"这类可简化为\"使用...动词短语\"的冗余表达。"
    },
    {
      "defect_id": 522706,
      "sentence": "可枚举性决定了这个属性能否被 `for...in` 查找遍历到。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"在JavaScript对象属性的相关开发中，需要处理JavaScript对象属性，确保正确地访问、设置、删除属性，并了解属性的继承关系和枚举特性。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **对象（Object）**：在JavaScript中，对象是一种复合数据类型，它允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。\",\"12\":\"- **属性（Property）**：在JavaScript中，属性是对象特征的键值对。每个属性都有一个名字（也称为键或标识符）和一个值。属性的值可以是任意数据类型，包括基本类型、对象和函数。\",\"13\":\"- **可枚举属性（EnumerableProperty）**：在JavaScript中，对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的，即内部 “可枚举” 标志设置为true或false。可枚举性决定了这个属性能否被 `for...in` 查找遍历到。\",\"14\":\"- **自有属性（OwnProperty）**：自有属性是直接定义在对象上的属性，而不是从原型链上继承来的属性。\",\"15\":\"\",\"16\":\"## 接口说明\",\"17\":\"\",\"18\":\"| 接口                       | 功能说明                       |\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "可枚举性决定了属性是否能被 `for...in` 遍历到。",
      "触发条件": "句子中存在重复语义的动词组合（如“查找遍历”）或冗余限定词（如“这个”）时触发。\n\n识别模式：\n1. 动词叠加：当两个动词（如“查找”+“遍历”）共同描述同一动作且语义重叠时，保留核心动词；\n2. 冗余限定：当指示代词（如“这个”）在上下文明确时未提供额外信息，可删除；\n3. 双重判断：当“能否”与“是否”重复表达判断逻辑时（原句“能否”已隐含判断，后文“是否”可省略）。"
    },
    {
      "defect_id": 522195,
      "sentence": "用于获取全局JavaScript对象。该函数的主要作用是获取表示JavaScript全局对象的JSVM_Value，使得JSVM模块能够与JavaScript运行时的全局对象进行交互。",
      "reference_sentence": "",
      "line_num": 333,
      "context": "{\"328\":\"JSVM OH_JSVM_GetValueBool success:0\",\"329\":\"```\",\"330\":\"\",\"331\":\"### OH_JSVM_GetGlobal\",\"332\":\"\",\"333\":\"用于获取全局JavaScript对象。该函数的主要作用是获取表示JavaScript全局对象的JSVM_Value，使得JSVM模块能够与JavaScript运行时的全局对象进行交互。\",\"334\":\"\",\"335\":\"cpp部分代码：\",\"336\":\"\",\"337\":\"```cpp\",\"338\":\"// hello.cpp\"}",
      "修改建议": "句子过长，可以拆分成两个句子。",
      "更改后示例": "用于获取全局JavaScript对象。该函数的主要作用是获取表示JavaScript全局对象的JSVM_Value，使JSVM模块能够与JavaScript运行时的全局对象进行交互。",
      "触发条件": "当单句包含多个由连词(如\"使得\")连接的并列分句，且后半分句主语与前文重复或隐含重复时触发。\n\n识别模式：检查句子中是否存在\"从而/使得/以便\"等连词引导的冗余结果状语分句，同时分句主语与前文行为主体存在语义重复（如本例中\"获取JSVM_Value\"行为与\"使JSVM模块交互\"结果实为同一动作的重复表述）。"
    },
    {
      "defect_id": 522298,
      "sentence": "| `class_data`     | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[ClassTag](#classtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |",
      "reference_sentence": "",
      "line_num": 142,
      "context": "{\"137\":\"| `name`           | `String`         | Class的名称，命名遵循[TypeDescriptor](#typedescriptor)语法。 |\",\"138\":\"| `reserved`       | `uint32_t`       | 方舟字节码文件内部使用的保留字段。                           |\",\"139\":\"| `access_flags`   | `uleb128`        | Class的访问标志，是[ClassAccessFlag](#classaccessflag)的组合。 |\",\"140\":\"| `num_fields`     | `uleb128`        | Class的字段的数量。                                          |\",\"141\":\"| `num_methods`    | `uleb128`        | Class的方法的数量。                                          |\",\"142\":\"| `class_data`     | `TaggedValue[]`  | 不定长度的数组，数组中每个元素都是[TaggedValue](#taggedvalue)类型，元素的标记是[ClassTag](#classtag)类型，数组中的元素按照标记递增排序（`0x00`标记除外）。 |\",\"143\":\"| `fields`         | `Field[]`        | Class的字段的数组，数组中每一个元素都是[Field](#field)类型。数组长度由`num_fields`指定。 |\",\"144\":\"| `methods`        | `Method[]`       | Class的方法的数组，数组中每一个元素都是[Method](#method)类型。数组长度由`num_methods`指定。 |\",\"145\":\"\",\"146\":\"\",\"147\":\"### ClassAccessFlag\"}",
      "修改建议": "句子较长，包含多个逗号。",
      "更改后示例": "| `class_data`     | `TaggedValue[]`  | 不定长度的数组，每个元素为[TaggedValue](#taggedvalue)类型，标记为[ClassTag](#classtag)，按标记递增排序（`0x00`标记除外）。 |",
      "触发条件": "同一句子中重复出现相同主语或名词短语（如\"数组中每个元素\"与\"数组中的元素\"），且存在可合并的并列结构（如连续使用\"类型\"说明）。当句子包含超过3个逗号分隔的限定性分句时，应触发冗余检测。"
    },
    {
      "defect_id": 522174,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"| OH_JSVM_GetNull          | 获取JavaScript null。                                        |\",\"25\":\"| OH_JSVM_GetUndefined     | 获取JavaScript undefined。                                   |\",\"26\":\"\",\"27\":\"## 使用示例\",\"28\":\"\",\"29\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"30\":\"\",\"31\":\"### OH_JSVM_CoerceToBool\",\"32\":\"\",\"33\":\"用于将一个给定的JavaScript值强制转为JavaScript boolean值。\",\"34\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文仅展示接口对应的C++相关代码。",
      "触发条件": "单句包含两个及以上逗号分隔的独立语义分句，且分句间存在可拆分的逻辑独立性（如并列说明、补充解释等场景）。\n\n识别模式：通过检测超过1个逗号的长句结构，结合分句语义独立性判断（如\"流程参考...，本文仅对...\"这类前导语+主体说明的复合结构），并识别\"进行展示\"等冗余动词短语。"
    },
    {
      "defect_id": 523327,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"| OH_JSVM_GetValueStringLatin1     | 获取给定JavaScript string对象的Latin1编码字符串。|\",\"25\":\"| OH_JSVM_CreateStringLatin1        | 根据Latin-1编码的字符串创建一个JavaScript string对象。|\",\"26\":\"\",\"27\":\"## 使用示例\",\"28\":\"\",\"29\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"30\":\"\",\"31\":\"### OH_JSVM_GetValueStringUtf8\",\"32\":\"\",\"33\":\"OH_JSVM_GetValueStringUtf8接口可以将JavaScript的字符类型的数据转换为utf8编码的字符。\",\"34\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)。本文仅展示接口对应的C++相关代码。",
      "触发条件": "当句子使用逗号连接多个独立分句导致结构冗余，或存在\"对...进行...\"等冗长动词结构时触发。识别模式为：1) 单句含超过一个逗号分隔的完整语义单元；2) 出现\"对xxx进行yyy\"类绕口表达（可替换为直接动词结构）。"
    },
    {
      "defect_id": 522995,
      "sentence": "准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"开发者如果希望自定义修改方舟字节码文件的内容，可以使用ArkTS编译工具链提供的自定义修改方舟字节码文件能力。\",\"4\":\"\",\"5\":\"## 能力配置说明\",\"6\":\"\",\"7\":\"准备一个操作方舟字节码文件的动态库文件，在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径，编译器会在指定的时机加载这个动态库，并且执行其中特定的Transform方法。\",\"8\":\"\",\"9\":\"## 能力执行机制\",\"10\":\"\",\"11\":\"如果配置了transformLib且对应的动态库文件能正确加载，编译器将先生成方舟字节码文件到默认目标位置，然后调用动态库中的Transform方法，并将方舟字节码文件的路径作为参数传入。Transform方法包含开发者自定义的修改逻辑，用于重新生成方舟字节码文件，同时更新字节码文件的落盘操作是由用户执行。\",\"12\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "准备一个操作方舟字节码文件的动态库文件。在工程的配置文件build-profile.json5中[配置编译选项transformLib](arkoptions-guide.md)，选项值为这个动态库的路径。编译器会在指定的时机加载这个动态库，并执行其中特定的Transform方法。",
      "触发条件": "当句子长度超过技术文档推荐的可读性阈值（通常表现为连续使用三个及以上逗号分隔的独立动作/步骤描述），且存在冗余连接词（如“并且”替代“并”）时触发。\n\n识别模式：\n1. **结构特征**：句子由多个逗号连接的独立操作步骤或配置动作构成（例如原句包含3个逗号，描述“准备文件→配置路径→加载执行”三个独立动作）。\n2. **冗余信号**：使用非必要递进连接词（如“并且”）而非简洁表达（如“并”），或存在隐性重复（如分句间逻辑关系可通过分句自然体现）。"
    },
    {
      "defect_id": 522260,
      "sentence": "本文详细介绍了方舟字节码文件的格式，旨在帮助开发者深入了解构成字节码文件的各个部分，从而指导开发者进行字节码的分析和修改工作。",
      "reference_sentence": "",
      "line_num": 2,
      "context": "{\"1\":\"# 方舟字节码文件格式\",\"2\":\"本文详细介绍了方舟字节码文件的格式，旨在帮助开发者深入了解构成字节码文件的各个部分，从而指导开发者进行字节码的分析和修改工作。\",\"3\":\"\",\"4\":\"\",\"5\":\"## 约束\",\"6\":\"本文内容基于方舟字节码版本号12.0.6.0（版本号为方舟编译器内部保留字段，开发者无需关注，仅供准确对照之用）。\",\"7\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "本文介绍了方舟字节码文件的格式，帮助开发者了解其构成，指导字节码的分析和修改。",
      "触发条件": "当句子出现多重修饰词（如\"详细\"+\"深入了解\"）、重复性表述（如\"字节码文件\"重复出现）或冗余连接词（如\"旨在\"+\"从而\"）时触发；当多个分句表达同一语义层次且存在可合并的重复内容时触发。\n\n识别模式：\n1. 副词+动词的语义叠加（\"详细介绍\"+\"深入了解\"）\n2. 重复名词短语超过2次（\"字节码文件\"出现3次）\n3. 存在可简化的目的性连词结构（\"旨在...从而...\"）\n4. 分句间存在同义表达（\"构成...各个部分\"与\"其构成\"）\n5. 出现可合并的重复施动者（两次\"开发者\"）"
    },
    {
      "defect_id": 522802,
      "sentence": "如果不存在对应url的任务则无其他效果。",
      "reference_sentence": "",
      "line_num": 87,
      "context": "{\"82\":\"\",\"83\":\"cancel(url: string)\",\"84\":\"\",\"85\":\"根据url移除一个正在执行的缓存下载任务，已保存的内存缓存和文件缓存不会受到影响。\",\"86\":\"\",\"87\":\"- 如果不存在对应url的任务则无其他效果。\",\"88\":\"\",\"89\":\"- 该方法为同步方法，不阻塞调用线程。\",\"90\":\"\",\"91\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"92\":\"\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "如果不存在对应任务，则无其他效果。",
      "触发条件": "当句子中的名词短语包含在上下文中已明确限定的冗余修饰语（如\"url\"在方法参数中已声明），或存在可被前置语境覆盖的重复限定成分时触发。识别模式为：检查名词前是否存在与上下文方法参数/前文描述重复的限定词（如\"对应url的任务\"中的url在方法cancel(url)中已声明）。"
    },
    {
      "defect_id": 522707,
      "sentence": "自有属性是直接定义在对象上的属性，而不是从原型链上继承来的属性。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"在JavaScript对象属性的相关开发中，需要处理JavaScript对象属性，确保正确地访问、设置、删除属性，并了解属性的继承关系和枚举特性。以下是一些关键概念：\",\"10\":\"\",\"11\":\"- **对象（Object）**：在JavaScript中，对象是一种复合数据类型，它允许存储多个不同类型的值作为一个单独的实体。对象是属性和方法的集合。属性是与对象相关联的值，而方法则是对象可以执行的操作。\",\"12\":\"- **属性（Property）**：在JavaScript中，属性是对象特征的键值对。每个属性都有一个名字（也称为键或标识符）和一个值。属性的值可以是任意数据类型，包括基本类型、对象和函数。\",\"13\":\"- **可枚举属性（EnumerableProperty）**：在JavaScript中，对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的，即内部 “可枚举” 标志设置为true或false。可枚举性决定了这个属性能否被 `for...in` 查找遍历到。\",\"14\":\"- **自有属性（OwnProperty）**：自有属性是直接定义在对象上的属性，而不是从原型链上继承来的属性。\",\"15\":\"\",\"16\":\"## 接口说明\",\"17\":\"\",\"18\":\"| 接口                       | 功能说明                       |\",\"19\":\"|----------------------------|--------------------------------|\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "自有属性是直接定义在对象上的属性，而不是从原型链继承的。",
      "触发条件": "当句子包含冗余结构助词（如\"的\"、\"来的\"）或方位词（如\"上\"），且删除后不影响语义完整性时触发。\n\n识别模式：检测\"从...上继承来的\"类结构，重点识别介词短语中非必要的方位词（如\"链上\"→\"链\"）和被动结构中多余的结构助词（如\"继承来的\"→\"继承\"）。"
    },
    {
      "defect_id": 523400,
      "sentence": "**注意事项**：`getValueStringUtf16(arg)`入参`arg`非字符串型数据时接口会调用失败。",
      "reference_sentence": "",
      "line_num": 201,
      "context": "{\"196\":\"\",\"197\":\"预期输出结果：\",\"198\":\"\",\"199\":\"![GetValueStringUtf16](figures/jsvm_about_string_GetValueStringUtf16.png)\",\"200\":\"\",\"201\":\"**注意事项**：`getValueStringUtf16(arg)`入参`arg`非字符串型数据时接口会调用失败。\",\"202\":\"\",\"203\":\"### OH_JSVM_CreateStringUtf16\",\"204\":\"\",\"205\":\"用于创建一个UTF-16编码的JavaScript字符串。\",\"206\":\"\"}",
      "修改建议": "句子包含过多修饰成分，且逗号使用过多。",
      "更改后示例": "**注意事项**：`getValueStringUtf16(arg)`的参数`arg`必须是字符串，否则接口调用会失败。",
      "触发条件": "句子中同时存在多重否定结构（如\"非...时\"）和多个分句通过逗号连接，导致语义绕且结构松散。\n\n识别模式：当检测到否定条件状语（\"非X型数据时\"）与结果分句通过单个逗号合并，且存在术语冗余（如\"入参\"与参数名重复）时触发。具体表现为\"条件否定+结果描述\"的复合句式，且修饰成分超过两层。"
    },
    {
      "defect_id": 522285,
      "sentence": "ClassIndex结构的作用是通过名称快速地定位到Class的定义。",
      "reference_sentence": "",
      "line_num": 119,
      "context": "{\"114\":\"> \",\"115\":\"> 通过ForeignMethod的偏移量，可以找到偏移量所在的IndexHeader以解析`class_idx`。\",\"116\":\"\",\"117\":\"\",\"118\":\"### ClassIndex\",\"119\":\"ClassIndex结构的作用是通过名称快速地定位到Class的定义。\",\"120\":\"\",\"121\":\"- 对齐方式：4个字节。\",\"122\":\"- 格式：\",\"123\":\"\",\"124\":\"| **名称** | **格式** | **说明**                                               |\"}",
      "修改建议": "句子包含过多修饰成分，应简化。",
      "更改后示例": "ClassIndex结构通过名称快速定位到Class的定义。",
      "触发条件": "当句子中出现冗余的功能性说明短语（如\"的作用是\"）且后续成分已明确表达核心功能时，或存在可合并的修饰语（如副词+动词组合）时触发。\n\n识别模式：\n1. 检测\"的作用是/用于/用来\"等引导功能说明的固定结构\n2. 分析句子主干是否重复表达（如主语名词二次出现）\n3. 识别副词修饰动词时是否产生语义重复（如\"快速地定位\"→\"快速定位\"）"
    },
    {
      "defect_id": 522717,
      "sentence": "JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 34,
      "context": "{\"29\":\"| OH_JSVM_DefineProperties   | 批量的向给定对象中定义属性 |\",\"30\":\"| OH_JSVM_GetAllPropertyNames | 获取给定对象的所有可用属性名称，结果变量将存储一个包含所有可枚举属性名称的JavaScript数组 |\",\"31\":\"\",\"32\":\"## 使用示例\",\"33\":\"\",\"34\":\"JSVM-API接口开发流程参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅对接口对应C++相关代码进行展示。\",\"35\":\"\",\"36\":\"### OH_JSVM_GetPropertyNames\",\"37\":\"\",\"38\":\"以字符串数组的形式获取对象的可枚举属性的名称，如果接口调用成功则返回JSVM_OK。\",\"39\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "参考[使用JSVM-API实现JS与C/C++语言交互开发流程](use-jsvm-process.md)，本文仅展示接口对应的C++代码。",
      "触发条件": "当句子同时包含\"对...进行...\"冗余动词结构且存在重复性修饰语（如\"对应\"+\"相关\"）时，或当同一语义被不同词性重复表达（如\"接口对应C++相关代码\"）时触发。\n\n识别模式：\n1. 动词冗余：检测\"进行+动词\"结构（如\"进行展示\"可简化为\"展示\"）\n2. 修饰重复：识别同一名词链中连续出现归属关系词（如\"对应\"与\"相关\"同时修饰\"C++代码\"）\n3. 语义叠加：发现前置定语（接口对应）与后置定语（相关）同时限定同一主体\n4. 句式臃肿：句子超过25字且包含两个及以上修饰性介词短语（\"对...\"+\"向...\"）"
    },
    {
      "defect_id": 523401,
      "sentence": "**注意事项**：`getValueStringLatin1(arg)`入参`arg`必须为字符串类型，否则将导致调用失败。",
      "reference_sentence": "",
      "line_num": 313,
      "context": "{\"308\":\"预期输出结果：\",\"309\":\"\",\"310\":\"*ISO-8859-1编码不支持中文，传入中文字符会导致乱码*\",\"311\":\"![GetValueStringLatin1](figures/jsvm_about_string_GetValueStringLatin1.png)\",\"312\":\"\",\"313\":\"**注意事项**：`getValueStringLatin1(arg)`入参`arg`必须为字符串类型，否则将导致调用失败。\",\"314\":\"\",\"315\":\"### OH_JSVM_CreateStringLatin1\",\"316\":\"\",\"317\":\"用于创建一个Latin1编码的JavaScript字符串。\",\"318\":\"\"}",
      "修改建议": "句子包含过多修饰成分，且逗号使用过多。",
      "更改后示例": "**注意事项**：`getValueStringLatin1(arg)`的参数`arg`必须为字符串，否则调用将失败。",
      "触发条件": "句子中同时存在冗余技术术语（如\"入参\"替代\"参数\"）和重复类型说明（如\"字符串类型\"中的\"类型\"），且使用\"将导致\"等冗长因果表达结构时触发。  \n\n识别模式：  \n1. 检测技术场景下非常用术语（如\"入参\"vs标准术语\"参数\"）  \n2. 匹配\"必须为...类型\"结构中的类型名词冗余（如\"字符串类型\"可简化为\"字符串\"）  \n3. 识别因果句式中的冗余动词结构（如\"将导致调用失败\"可优化为\"调用将失败\"）"
    },
    {
      "defect_id": 522508,
      "sentence": "[DebugInfo](#debuginfo)中常量池的第一个字节的地址",
      "reference_sentence": "",
      "line_num": 407,
      "context": "{\"402\":\"| `address`           | 0                                                            | 程序计数器（指向方法的某个指令），只能单调递增。             |\",\"403\":\"| `line`              | [DebugInfo](#debuginfo)的属性`line_start`的值 | 无符号整数，对应源码中的行号。所有的行都是从1开始编号，因此寄存器的值不能小于1。 |\",\"404\":\"| `column`            | 0                                                            | 无符号整数，对应源码中的列号。                               |\",\"405\":\"| `file`              | `class_data`（参见[Class](#class)）中`SOURCE_FILE`标记的值，或者0 | 一个偏移量，指向[字符串](#字符串)，表示源文件的名称。如果没有文件名信息（[Class](#class)中没有`SOURCE_FILE`标记），那么寄存器的值是0。 |\",\"406\":\"| `source_code`       | 0                                                            | 一个偏移量，指向[字符串](#字符串)，表示源文件的源码。如果没有源码信息，那么寄存器的值是0。 |\",\"407\":\"| `constant_pool_ptr` | [DebugInfo](#debuginfo)中常量池的第一个字节的地址 | 指向当前常量值的指针。                                       |\",\"408\":\"\",\"409\":\"\",\"410\":\"#### Line number program\",\"411\":\"一个行号程序（Line number program）由指令组成。每条指令都包含一个字节的操作码以及可选参数。根据操作码的不同，参数的值可能被编码在指令中（称为指令参数），或者需要从常量池中获取（称为常量池参数）。\",\"412\":\"\"}",
      "修改建议": "句子过长，包含过多的修饰成分。",
      "更改后示例": "[DebugInfo](#debuginfo)中常量池的起始地址",
      "触发条件": "当句子中存在多个连续修饰成分（例如嵌套的名词短语或冗余方位描述）导致表述冗长，且存在更简洁的标准术语（如\"起始地址\"替代\"第一个字节的地址\"）时触发。\n\n识别模式：\n1. 检测\"的\"字连续出现（如\"常量池的第一个字节的地址\"）\n2. 匹配长短语与标准术语的映射关系（如\"第一个字节的地址\"→\"起始地址\"）\n3. 判断修饰成分是否重复传递同一语义（此处\"第一个\"和\"地址\"已隐含位置信息）"
    },
    {
      "defect_id": 523957,
      "sentence": "该方法为同步方法，不会阻塞调用线程。",
      "reference_sentence": "",
      "line_num": 43,
      "context": "{\"38\":\"\",\"39\":\"- 在缓存下载数据时，如果在该url下已存在缓存内容，新的缓存内容会覆盖旧缓存内容。\",\"40\":\"\",\"41\":\"- 目标资源在存储到内存缓存或文件缓存中时，依照缓存下载组件的各类型缓存大小上限决定文件是否存储到指定位置，并默认使用“LRU”（最近最少使用）方式替换已有缓存内容。\",\"42\":\"\",\"43\":\"- 该方法为同步方法，不会阻塞调用线程。\",\"44\":\"\",\"45\":\"**需要权限**：ohos.permission.INTERNET\",\"46\":\"\",\"47\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"48\":\"\"}",
      "修改建议": "句子包含过多的描述性词语，可以更加简洁。",
      "更改后示例": "该方法不会阻塞调用线程。",
      "触发条件": "当句子中存在两个可相互推断的描述性分句（如\"A为B类型，具有B类型特性X\"），且其中一个分句的信息已被另一个分句或上下文隐含时触发。具体表现为：术语定义与特性说明存在语义重叠（如\"同步方法\"隐含\"不阻塞线程\"特性）。"
    },
    {
      "defect_id": 522446,
      "sentence": "行号程序索引（LineNumberProgramIndex）结构是一个数组，便于使用更紧凑的索引访问行号程序（Line number program）。",
      "reference_sentence": "",
      "line_num": 367,
      "context": "{\"362\":\"| `DOUBLE`         | `uint64_t`       | 八字节位模式，向右零扩展，系统会将其解译为 IEEE754 64 位浮点值。 |\",\"363\":\"| `ID`             | `uint32_t`       | 四字节位模式，表示文件中某个结构的偏移量。                   |\",\"364\":\"\",\"365\":\"\",\"366\":\"### LineNumberProgramIndex\",\"367\":\"行号程序索引（LineNumberProgramIndex）结构是一个数组，便于使用更紧凑的索引访问行号程序（Line number program）。\",\"368\":\"\",\"369\":\"- 对齐方式：4个字节。\",\"370\":\"- 格式：\",\"371\":\"\",\"372\":\"| **名称** | **格式** | **说明**                                               |\"}",
      "修改建议": "句子较长，且包含不必要的修饰成分。",
      "更改后示例": "行号程序索引（LineNumberProgramIndex）是一个数组，用于紧凑访问行号程序（Line number program）。",
      "触发条件": "句子中出现重复术语的冗余修饰（如“结构”在已明确定义的技术名词后）或存在可合并的动词短语（如“使用更紧凑的索引访问”替代为“紧凑访问”）。"
    },
    {
      "defect_id": 523568,
      "sentence": "指令*return*：将acc中的值返回。",
      "reference_sentence": "",
      "line_num": 61,
      "context": "{\"56\":\"    ldai 0x1\",\"57\":\"    return\",\"58\":\"}\",\"59\":\"```\",\"60\":\"指令*ldai 0x1*：将整型字面量1加载到acc中；<br>\",\"61\":\"指令*return*：将acc中的值返回。\",\"62\":\"\",\"63\":\"#### 立即数\",\"64\":\"方舟字节码中部分指令采用常数形式来表示整型数值、双精度浮点型数值、跳转偏移量等数据。这类常数被称为立即数，可以是8位、16位、32位或64位。\",\"65\":\"\",\"66\":\"#### 方法索引、字符串索引、字面量索引\"}",
      "修改建议": "存在不必要的修饰成分。",
      "更改后示例": "指令*return*：返回acc中的值。",
      "触发条件": "句子中存在由“将”等介词引导的冗余宾语前置结构，且动词本身可直接带宾语（如“返回”“加载”等）时触发。识别模式为“将X（动作对象）+ 动词”结构，其中动词本身隐含对X的处理逻辑（如“返回X”已完整表达语义）。"
    },
    {
      "defect_id": 524037,
      "sentence": "目标资源经HTTP传输并自动解压后的大小不得超过20 MB（20971520 Byte），否则不会保存到内存缓存或文件缓存中。",
      "reference_sentence": "",
      "line_num": 37,
      "context": "{\"32\":\"\",\"33\":\"download(url: string, options: CacheDownloadOptions)\",\"34\":\"\",\"35\":\"启动一个缓存下载任务，若传输成功，则将数据保存到内存缓存和文件缓存中。\",\"36\":\"\",\"37\":\"- 目标资源经HTTP传输并自动解压后的大小不得超过20 MB（20971520 Byte），否则不会保存到内存缓存或文件缓存中。\",\"38\":\"\",\"39\":\"- 在缓存下载数据时，如果URL已存在缓存内容，新内容将覆盖旧内容。\",\"40\":\"\",\"41\":\"- 目标资源存储到内存缓存或文件缓存时，根据缓存下载组件的各类型缓存大小上限决定存储位置，并默认使用“LRU”（最近最少使用）策略替换已有缓存内容。\",\"42\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，应拆分成更简洁的句子。",
      "更改后示例": "目标资源经HTTP传输并自动解压后的大小不得超过20 MB（20971520 Byte）。超过此大小的资源不会保存到内存缓存或文件缓存中。",
      "触发条件": "句子使用复合结构（如\"否则\"、\"并且\"等）连接多个独立信息点，导致单句承载双重语义关系（条件+结果/限制+后果）。\n\n识别模式：检测包含条件连词（否则/若/当...时）且同时包含两个及以上逻辑关系（限制条件+结果说明）的长单句，当信息点可独立成句时触发拆分建议。"
    },
    {
      "defect_id": 523959,
      "sentence": "parameter error. Possible causes: 1. Missing mandatory parameters. 2. Incorrect parameter type. 3. Parameter verification failed.",
      "reference_sentence": "",
      "line_num": 63,
      "context": "{\"58\":\"以下错误码的详细介绍请参见[通用错误码说明文档](../errorcode-universal.md)。\",\"59\":\"\",\"60\":\"| 错误码ID    | 错误信息                                                                                                                                      |\",\"61\":\"|----------|-------------------------------------------------------------------------------------------------------------------------------------------|\",\"62\":\"| 201      | permission denied.                                                                                                              |\",\"63\":\"| 401      | parameter error. Possible causes: 1. Missing mandatory parameters. 2. Incorrect parameter type. 3. Parameter verification failed. |\",\"64\":\"\",\"65\":\"**示例：**\",\"66\":\"\",\"67\":\"  ```ts\",\"68\":\"  import { cacheDownload, BusinessError } from '@kit.BasicServicesKit';\"}",
      "修改建议": "句子包含过多的描述性词语，可以更加简洁。",
      "更改后示例": "parameter error: 1. Missing mandatory parameters. 2. Incorrect parameter type. 3. Verification failed.",
      "触发条件": "列表中存在重复的前置限定词（如\"Parameter\"在三个条目中重复出现），或存在可合并的引导性说明（如\"Possible causes:\"可被冒号替代）时触发。"
    },
    {
      "defect_id": 525395,
      "sentence": "在id为tab2的TabContent隐藏的时候，通过uniqueId设置id为tab1的节点的冻结状态为true。",
      "reference_sentence": "",
      "line_num": 339,
      "context": "{\"334\":\"        })\",\"335\":\"        .onWillShow(() => {\",\"336\":\"          //通过id查询获得对应节点的uniqueId。\",\"337\":\"          const node = this.getUIContext().getFrameNodeById('tab1');\",\"338\":\"          const uniqueId = node?.getUniqueId();\",\"339\":\"          //id为tab2的TabContent隐藏的时候，通过uniqueId设置id为tab1的节点的冻结状态为true。\",\"340\":\"          //通过状态变量改变tab1内部Column节点的宽度，由于id为tab1的节点冻结状态为true，标脏至该TabContent的时候终止标记，同时不从该节点开始触发布局。\",\"341\":\"          this.getUIContext().freezeUINode(uniqueId, true);\",\"342\":\"          this.columnWidth1 = '50%';\",\"343\":\"\",\"344\":\"          //设置延时任务。\"}",
      "修改建议": "句子较长，且包含多个逗号，违反了规则中的逗号数量限制。",
      "更改后示例": "当id为tab2的TabContent隐藏时，通过uniqueId将id为tab1的节点冻结状态设置为true。",
      "触发条件": "句子包含两个及以上逗号分隔的从句，且存在冗余时间状语结构（如\"在...的时候\"）。\n\n识别模式：当检测到复合句同时满足以下特征时触发规则修复：1. 使用\"在...(的)时候\"引导时间状语从句；2. 主从句间存在重复指代（如原句\"通过uniqueId设置id为tab1的节点\"在上下文已明确uniqueId与节点的关联关系）。可通过句法分析识别状语从句嵌套层级，结合代码注释上下文语义冗余度进行判断。"
    },
    {
      "defect_id": 524038,
      "sentence": "在缓存下载数据时，如果URL已存在缓存内容，新内容将覆盖旧内容。",
      "reference_sentence": "",
      "line_num": 39,
      "context": "{\"34\":\"\",\"35\":\"启动一个缓存下载任务，若传输成功，则将数据保存到内存缓存和文件缓存中。\",\"36\":\"\",\"37\":\"- 目标资源经HTTP传输并自动解压后的大小不得超过20 MB（20971520 Byte），否则不会保存到内存缓存或文件缓存中。\",\"38\":\"\",\"39\":\"- 在缓存下载数据时，如果URL已存在缓存内容，新内容将覆盖旧内容。\",\"40\":\"\",\"41\":\"- 目标资源存储到内存缓存或文件缓存时，根据缓存下载组件的各类型缓存大小上限决定存储位置，并默认使用“LRU”（最近最少使用）策略替换已有缓存内容。\",\"42\":\"\",\"43\":\"- 该方法为同步方法，不会阻塞调用线程。\",\"44\":\"\"}",
      "修改建议": "句子过长，包含多个信息点，应拆分成更简洁的句子。",
      "更改后示例": "在缓存下载数据时，如果URL已存在缓存内容，新内容将覆盖旧内容。拆分后：如果URL已存在缓存内容，新内容将覆盖旧内容。",
      "触发条件": "当句子中重复出现已在前置语境中明确的前提条件（如状语成分），或单个句子包含两个及以上独立信息点时触发。识别模式需检查是否存在冗余状语重复上下文场景，以及是否通过连词/逗号合并多个应独立表述的规则说明。"
    },
    {
      "defect_id": 525598,
      "sentence": "为实现最优性能，ArkTS要求在程序执行期间不能更改对象布局。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"自API version 10起，ArkTS进一步通过规范强化静态检查和分析，其主要特性及标准TS的差异包括[从TypeScript到ArkTS的适配规则](typescript-to-arkts-migration-guide.md)：\",\"8\":\"\",\"9\":\"\",\"10\":\"- 强制使用静态类型：静态类型是ArkTS最重要的特性之一。如果使用静态类型，那么程序中变量的类型就是确定的。同时，由于所有类型在程序实际运行前都是已知的，编译器可以验证代码的正确性，从而减少运行时的类型检查，有助于性能提升。\",\"11\":\"\",\"12\":\"- 禁止在运行时改变对象布局：为实现最优性能，ArkTS要求在程序执行期间不能更改对象布局。\",\"13\":\"\",\"14\":\"- 限制运算符语义：为获得更好的性能并鼓励开发者编写更清晰的代码，ArkTS限制了一些运算符的语义。例如，一元加法运算符只能作用于数字，不能用于其他类型的变量等。\",\"15\":\"\",\"16\":\"- 不支持Structural typing：对Structural typing的支持需要在语言、编译器和运行时进行大量的考虑和仔细的实现，当前ArkTS不支持该特性。根据实际场景的需求和反馈，后续会重新考虑是否支持Structural typing。\",\"17\":\"\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "为实现最优性能，ArkTS禁止在程序执行期间更改对象布局。",
      "触发条件": "当句子中存在“要求/必须 + 否定动作”的冗余结构（如“要求在...不能”）时，或存在可用单个否定性动词（如“禁止”“限制”）替代的复合表达时触发。\n\n识别模式：\n1. 检测「要求/必须/应当」等义务性动词 + 否定词（不能/不可）的组合结构\n2. 验证是否存在语义相同的单字否定动词替代方案（如“禁止”替代“要求不能”）\n3. 结合上下文判断是否属于规则/限制类表述（如技术规范、策略说明等需简洁性的场景）"
    },
    {
      "defect_id": 523965,
      "sentence": "如果不存在对应任务，则无其他效果。",
      "reference_sentence": "",
      "line_num": 87,
      "context": "{\"82\":\"\",\"83\":\"cancel(url: string)\",\"84\":\"\",\"85\":\"根据URL移除正在执行的缓存下载任务，已保存的内存缓存和文件缓存保持不变。\",\"86\":\"\",\"87\":\"- 如果不存在对应任务，则无其他效果。\",\"88\":\"\",\"89\":\"- 该方法为同步方法，不阻塞调用线程。\",\"90\":\"\",\"91\":\"**系统能力**：SystemCapability.Request.FileTransferAgent\",\"92\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "如果不存在对应任务，无其他效果。",
      "触发条件": "当条件从句（如“如果...”）后紧跟冗余连词（如“则”）且删除后不影响逻辑时；或存在可被上下文隐含的修饰成分（如“其他效果”已包含“无”的绝对性）。  \n识别模式：检测“如果/当...则/就...”结构中连词冗余性，或修饰词与主句语义重复（如“无”+“其他效果”无需补充说明）。"
    },
    {
      "defect_id": 525397,
      "sentence": "在id为tab3的TabContent隐藏的时候，通过uniqueId设置该节点的冻结状态为true。",
      "reference_sentence": "",
      "line_num": 364,
      "context": "{\"359\":\"        .id('tab3')\",\"360\":\"        .onWillHide(() => {\",\"361\":\"          //通过id查询获得对应节点的uniqueId。\",\"362\":\"          const node = this.getUIContext().getFrameNodeById('tab3');\",\"363\":\"          const uniqueId = node?.getUniqueId();\",\"364\":\"          //id为tab3的TabContent隐藏的时候，通过uniqueId设置该节点的冻结状态为true。\",\"365\":\"          this.getUIContext().freezeUINode(uniqueId, true);\",\"366\":\"        })\",\"367\":\"        .onWillShow(() => {\",\"368\":\"          //通过id查询获得对应节点的uniqueId。\",\"369\":\"          const node = this.getUIContext().getFrameNodeById('tab3');\"}",
      "修改建议": "句子较长，且包含多个逗号，违反了规则中的逗号数量限制。",
      "更改后示例": "当id为tab3的TabContent隐藏时，通过uniqueId将该节点的冻结状态设置为true。",
      "触发条件": "句子同时包含\"在...的时候\"冗余结构且使用超过1个逗号，导致句式冗长\n\n识别模式：\n1. 存在\"在...的时候\"时间状语结构（可优化为\"当...时\"）\n2. 句内逗号数量≥2个（本案例含2个逗号）\n3. 伴随\"设置...为\"动词结构（可优化为\"将...设置为\"）\n4. 上下文存在可简化的重复指代（如本案例重复出现\"id为tab3的TabContent\"）"
    },
    {
      "defect_id": 526722,
      "sentence": "x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。",
      "reference_sentence": "",
      "line_num": 57,
      "context": "{\"52\":\"\",\"53\":\"- x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"54\":\"\",\"55\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"56\":\"\",\"57\":\"- x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"58\":\"\",\"59\":\"- y2: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\"}",
      "修改建议": "句子过长，逗号数超过5个。",
      "更改后示例": "x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。小于0时按0处理，大于1时按1处理。",
      "触发条件": "当句子中连续分句重复使用相同主语或条件结构（如\"设置的值小于...；设置的值大于...\"），且逗号数量超过5个导致句式冗余时触发。"
    },
    {
      "defect_id": 526064,
      "sentence": "返回对象的字符串表示形式。返回字符串格式是：SendableLruCache[ maxSize = (maxSize), hits = (hitCount), misses = (missCount), hitRate = (hitRate) ]。 (maxSize)表示缓存区最大值，(hitCount)表示查询值匹配成功的次数，(missCount)表示查询值匹配失败的次数，(hitRate)表示查询值匹配率。",
      "reference_sentence": "",
      "line_num": 990,
      "context": "{\"985\":\"\",\"986\":\"**返回值：**\",\"987\":\"\",\"988\":\"| 类型   | 说明                       |\",\"989\":\"| ------ | -------------------------- |\",\"990\":\"| string | 返回对象的字符串表示形式。 返回字符串格式是：SendableLruCache[ maxSize = (maxSize), hits = (hitCount), misses = (missCount), hitRate = (hitRate) ]。 (maxSize)表示缓存区最大值，(hitCount)表示查询值匹配成功的次数，(missCount)表示查询值匹配失败的次数，(hitRate)表示查询值匹配率。|\",\"991\":\"\",\"992\":\"**示例：**\",\"993\":\"\",\"994\":\"```ts\",\"995\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "返回对象的字符串表示形式，格式为：SendableLruCache[ maxSize = (maxSize), hits = (hitCount), misses = (missCount), hitRate = (hitRate) ]。其中，(maxSize)表示缓存区最大值，(hitCount)表示匹配成功的次数，(missCount)表示匹配失败的次数，(hitRate)表示匹配率。",
      "触发条件": "当技术文档中连续出现重复的动词结构（如\"返回...返回...\"）或存在可合并的上下文重复描述（如\"查询值匹配成功\"与\"匹配成功\"）时触发。\n\n识别模式：\n1. 动词重复检测：同一句子/相邻句子出现相同动词引导的语义重复（如\"返回...返回...\"嵌套结构）\n2. 修饰冗余检测：存在可通过上下文推断的冗余限定词（如\"查询值匹配\"中的\"查询值\"在参数说明场景下属于冗余限定）"
    },
    {
      "defect_id": 526796,
      "sentence": "5、 回到步骤2。  ",
      "reference_sentence": "",
      "line_num": 431,
      "context": "{\"426\":\"\",\"427\":\"1、 执行`init`表达式（如有）。此表达式通常初始化一个或多个循环计数器。  \",\"428\":\"2、 计算`condition`。如果它为真值（转换后为`true`的值），则执行循环主体的语句。如果它为假值（转换后为`false`的值），则`for`循环终止。  \",\"429\":\"3、 执行循环主体的语句。  \",\"430\":\"4、 如果有`update`表达式，则执行该表达式。  \",\"431\":\"5、 回到步骤2。  \",\"432\":\"\",\"433\":\"示例：\",\"434\":\"\",\"435\":\"```typescript\",\"436\":\"let sum = 0;\"}",
      "修改建议": "句子结构可以简化。",
      "更改后示例": "5、 返回步骤2。",
      "触发条件": "当句子中存在可替换为更简洁同义动词的冗余表达（如\"回到\"→\"返回\"），且上下文为步骤说明/循环指令等需要简明性的技术文档场景时触发。"
    },
    {
      "defect_id": 526721,
      "sentence": "x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。",
      "reference_sentence": "",
      "line_num": 53,
      "context": "{\"48\":\"\",\"49\":\"  用于描述系统在受到扰动后震荡及衰减的情形。阻尼越大，弹性运动的震荡次数越少、震荡幅度越小。\",\"50\":\"\",\"51\":\"当曲线类型为CUBIC_BEZIER时，动画曲线参数需设置为长度为4的数组：[x1, y1, x2, y2]。\",\"52\":\"\",\"53\":\"- x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"54\":\"\",\"55\":\"- y1: 确定贝塞尔曲线第一点纵坐标，类型为number，必填，取值范围：(-∞, +∞)。\",\"56\":\"\",\"57\":\"- x2: 确定贝塞尔曲线第二点横坐标，类型为number，必填，取值范围：[0, 1]。设置的值小于0时，按0处理；设置的值大于1时，按1处理。\",\"58\":\"\"}",
      "修改建议": "句子过长，逗号数超过5个。",
      "更改后示例": "x1: 确定贝塞尔曲线第一点横坐标，类型为number，必填，取值范围：[0, 1]。值小于0时按0处理，值大于1时按1处理。",
      "触发条件": "同一主语/宾语在并列条件句中重复出现（如\"设置的值\"重复两次），且句子包含超过5个逗号导致结构冗余。识别模式需检测重复性指代短语（如\"设置的X\"）与分号/逗号连接的并列结构同时出现。"
    },
    {
      "defect_id": 526873,
      "sentence": "以下代码是在ArkTS中不合法的代码。\r",
      "reference_sentence": "",
      "line_num": 889,
      "context": "{\"884\":\"#### 字段初始化\",\"885\":\"\",\"886\":\"为了减少运行时错误并提高执行性能，\",\"887\":\"ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的`strictPropertyInitialization`模式一样。\",\"888\":\"\",\"889\":\"以下代码是在ArkTS中不合法的代码。\",\"890\":\"\",\"891\":\"```typescript\",\"892\":\"class Person {\",\"893\":\"  name: string; // undefined\",\"894\":\"  \"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "以下代码在ArkTS中不合法。",
      "触发条件": "句子中存在可省略的介词结构（如“在...中”搭配多余动词“是”）或重复提及上下文已明确的内容（如“代码”），导致冗余修饰。"
    },
    {
      "defect_id": 526872,
      "sentence": "ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的`strictPropertyInitialization`模式一样。\r",
      "reference_sentence": "",
      "line_num": 887,
      "context": "{\"882\":\"```\",\"883\":\"\",\"884\":\"#### 字段初始化\",\"885\":\"\",\"886\":\"为了减少运行时错误并提高执行性能，\",\"887\":\"ArkTS要求所有字段在声明时或者构造函数中显式初始化。这和标准TS中的`strictPropertyInitialization`模式一样。\",\"888\":\"\",\"889\":\"以下代码是在ArkTS中不合法的代码。\",\"890\":\"\",\"891\":\"```typescript\",\"892\":\"class Person {\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "ArkTS要求所有字段在声明时或构造函数中显式初始化，与标准TS的`strictPropertyInitialization`模式相同。",
      "触发条件": "句子中出现重复语义的连词（如“或者”替代“或”）或冗余指代结构（如“这和...一样”可简化为“与...相同”）时触发。\n\n识别模式：检测并列连词双字形式（如“或者”“以及”）与单字形式（“或”“及”）的冗余使用，以及存在显性指代重复（如“这”+重复性描述）的对比句式结构。"
    },
    {
      "defect_id": 526944,
      "sentence": "顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。",
      "reference_sentence": "",
      "line_num": 1847,
      "context": "{\"1842\":\"\",\"1843\":\"<!--RP2--><!--RP2End-->\",\"1844\":\"\",\"1845\":\"### 顶层语句\",\"1846\":\"\",\"1847\":\"顶层语句是指在模块的最外层直接编写的语句，这些语句不被包裹在任何函数、类、块级作用域中。顶层语句包括变量声明、函数声明、表达式等。\",\"1848\":\"\",\"1849\":\"## 关键字\",\"1850\":\"\",\"1851\":\"### this\",\"1852\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "顶层语句是指在模块最外层编写的语句，不被任何函数、类或块级作用域包裹。这些语句包括变量声明、函数声明和表达式。",
      "触发条件": "当句子中存在重复修饰词（如\"最外层直接编写\"中的冗余副词）或重复指代同一主体（如连续使用\"这些语句\"指代前文主语）时触发。\n\n识别模式：\n1. 检查形容词/副词是否与核心名词存在语义重叠（如\"直接\"与\"最外层\"）\n2. 识别连续分句中重复出现的指代结构（如\"这些语句...这些语句\"）\n3. 发现用不同表述重复说明同一概念的情况（如\"不被包裹在...\"与\"不被...包裹\"双重说明）"
    },
    {
      "defect_id": 528328,
      "sentence": "The Worker instance is not running.",
      "reference_sentence": "",
      "line_num": 128,
      "context": "{\"123\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"124\":\"\",\"125\":\"| 错误码ID | 错误信息                                |\",\"126\":\"| -------- | ----------------------------------------- |\",\"127\":\"| 401      | Parameter error. Possible causes: 1. Mandatory parameters are left unspecified; 2. Incorrect parameter types; 3. Parameter verification failed. |\",\"128\":\"| 10200004 | The Worker instance is not running.           |\",\"129\":\"| 10200006 | An exception occurred during serialization. |\",\"130\":\"\",\"131\":\"**示例：**\",\"132\":\"\",\"133\":\"```ts\"}",
      "修改建议": "句子可以更加简洁。",
      "更改后示例": "The Worker instance is not active.",
      "触发条件": "当句子中存在可被更简洁的同义词替代的动词或状态描述词（如\"running\"→\"active\"），且上下文未强调动作过程时触发。"
    },
    {
      "defect_id": 526953,
      "sentence": "如果枚举值不能在编译时确定，将会出现编译报错。",
      "reference_sentence": "",
      "line_num": 1957,
      "context": "{\"1952\":\"* 字符串字面量\",\"1953\":\"* 枚举值（需要在编译时确定值）\",\"1954\":\"* 以上常量组成的数组\",\"1955\":\">**说明：**\",\"1956\":\">\",\"1957\":\"> 如果枚举值不能在编译时确定，将会出现编译报错。\",\"1958\":\"```typescript\",\"1959\":\"// a.ts\",\"1960\":\"export enum X {\",\"1961\":\"  x = foo(); // x不是编译时能确定的常量\",\"1962\":\"}\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "如果枚举值不能在编译时确定，会编译报错。",
      "触发条件": "句子中存在冗余的动词短语结构（如\"将会出现\"），且存在更简洁的替代表达（如\"会\"）时触发；当修饰成分（如\"出现\"）未增加关键信息却延长句式时触发。\n\n识别模式：\n1. 检测\"将+会/要+动词\"的双重未来时态结构\n2. 识别\"出现/产生/发生\"类泛动词后接具体结果名词（报错/错误）的冗余结构\n3. 判断动词短语是否可简化为单一动词（如\"会编译报错\"替代\"将会出现编译报错\"）"
    },
    {
      "defect_id": 526208,
      "sentence": "传入该参数，可以用来修改解析生成的原始值。默认值是undefined。",
      "reference_sentence": "",
      "line_num": 83,
      "context": "{\"78\":\"**参数：**\",\"79\":\"\",\"80\":\"| 参数名 | 类型   | 必填 | 说明            |\",\"81\":\"| ------ | ------ | ---- | --------------- |\",\"82\":\"| text   | string | 是 | 有效的JSON字符串。|\",\"83\":\"| reviver  | [Transformer](#transformer) | 否 | 转换函数，传入该参数，可以用来修改解析生成的原始值。默认值是undefined。|\",\"84\":\"| options   | [ParseOptions](#parseoptions) | 否 | 解析的配置，传入该参数，可以用来控制解析生成的类型。默认值是undefined。|\",\"85\":\"\",\"86\":\"**返回值：**\",\"87\":\"\",\"88\":\"| 类型 | 说明 |\"}",
      "修改建议": "句子过长，包含多个逗号，且添加了不必要的修饰成分。",
      "更改后示例": "传入该参数可以修改解析生成的原始值，默认值是 undefined。",
      "触发条件": "句子中存在由逗号连接的多个分句，且包含\"用来\"类冗余修饰词或重复性功能说明时触发。\n\n具体识别模式：\n1. 结构特征：单句含≥2个逗号分隔的短分句，形成\"动作+用途说明\"的重复结构\n2. 语义特征：出现\"用来\"/\"用于\"/\"可以\"等冗余功能提示词，且后接动词短语与前半句存在语义重复\n3. 上下文特征：出现在参数说明等需要简洁性的技术文档场景中"
    },
    {
      "defect_id": 528364,
      "sentence": "删除Worker的事件监听，该接口与[off<sup>9+</sup>](#off9)接口功能一致。",
      "reference_sentence": "",
      "line_num": 878,
      "context": "{\"873\":\"\",\"874\":\"### removeEventListener<sup>9+</sup>\",\"875\":\"\",\"876\":\"removeEventListener(type: string, callback?: WorkerEventListener): void\",\"877\":\"\",\"878\":\"删除Worker的事件监听，该接口与[off<sup>9+</sup>](#off9)接口功能一致。\",\"879\":\"\",\"880\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"881\":\"\",\"882\":\"**系统能力：** SystemCapability.Utils.Lang\",\"883\":\"\"}",
      "修改建议": "句子包含过多修饰成分。",
      "更改后示例": "删除Worker的事件监听，该接口功能与[off<sup>9+</sup>](#off9)一致。",
      "触发条件": "当句子中连续出现重复名词（如\"接口\"）且用于功能对比时，或存在\"该X与[Y]X功能一致\"的冗余结构时触发。识别模式为检测相邻子句中重复的名词性成分，并判断是否可通过合并/删减维持语义完整。"
    },
    {
      "defect_id": 528373,
      "sentence": "发送至宿主线程的数据，该数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。",
      "reference_sentence": "",
      "line_num": 1238,
      "context": "{\"1233\":\"\",\"1234\":\"**参数：**\",\"1235\":\"\",\"1236\":\"| 参数名   | 类型          | 必填 | 说明                                                         |\",\"1237\":\"| -------- | ------------- | ---- | ------------------------------------------------------------ |\",\"1238\":\"| messageObject  | Object        | 是   | 发送至宿主线程的数据，该数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。 |\",\"1239\":\"| transfer | ArrayBuffer[] | 是   | 表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到宿主线程，在Worker线程中将会变为不可用，仅在宿主线程中可用，数组不可传入null。 |\",\"1240\":\"\",\"1241\":\"**错误码：**\",\"1242\":\"\",\"1243\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\"}",
      "修改建议": "句子含有不必要的修饰成分。",
      "更改后示例": "发送至宿主线程的数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。",
      "触发条件": "当句子中连续使用同义名词短语重复指代同一对象（如\"数据\"后接\"该数据对象\"），且存在明确指示代词（如\"该\"）导致语义重复时触发。识别模式为前文名词与后文\"该+名词\"结构形成冗余复指关系。"
    },
    {
      "defect_id": 528359,
      "sentence": "回调函数。表示宿主线程接收到来自其创建的Worker通过workerPort.postMessage接口发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。其中回调函数中event类型为[MessageEvents](#messageevents9)，表示收到的Worker消息数据。",
      "reference_sentence": "",
      "line_num": 747,
      "context": "{\"742\":\"\",\"743\":\"### onmessage<sup>9+</sup>\",\"744\":\"\",\"745\":\"onmessage?: (event: MessageEvents) =&gt; void\",\"746\":\"\",\"747\":\"回调函数。表示宿主线程接收到来自其创建的Worker通过workerPort.postMessage接口发送的消息时被调用的事件处理程序，处理程序在宿主线程中执行。其中回调函数中event类型为[MessageEvents](#messageevents9)，表示收到的Worker消息数据。\",\"748\":\"\",\"749\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"750\":\"\",\"751\":\"**系统能力：** SystemCapability.Utils.Lang\",\"752\":\"\"}",
      "修改建议": "句子较长，包含多个修饰成分。",
      "更改后示例": "回调函数，用于处理宿主线程接收到其创建的Worker通过workerPort.postMessage接口发送的消息。处理程序在宿主线程中执行，event类型为[MessageEvents](#messageevents9)，表示收到的Worker消息数据。",
      "触发条件": "当相邻句子重复使用同一主语或主题词（如\"回调函数\"），且后续分句包含与前文存在语义重叠的解释性成分（如\"表示...\"、\"其中...\"）时触发。\n\n识别模式：1) 句首使用名词短语+句号构成独立短句 2) 后续句子以解释性动词（如\"表示\"、\"其中\"）开头重复描述相同主体 3) 存在可合并的修饰成分（如\"被调用的事件处理程序\"与\"处理程序在...执行\"）。"
    },
    {
      "defect_id": 528353,
      "sentence": "回调函数。表示Worker线程生命周期内发生异常被调用的事件处理程序，处理程序在宿主线程中执行。<br/>",
      "reference_sentence": "",
      "line_num": 693,
      "context": "{\"688\":\"\",\"689\":\"### onAllErrors<sup>18+</sup>\",\"690\":\"\",\"691\":\"onAllErrors?: ErrorCallback\",\"692\":\"\",\"693\":\"回调函数。表示Worker线程生命周期内发生异常被调用的事件处理程序，处理程序在宿主线程中执行。<br/>\",\"694\":\"[onerror](#onerror9)仅捕获[onmessage](#onmessage9)回调中同步方法产生的异常，无法捕获多线程回调产生的异常和模块化相关异常，且onerror捕获异常后Worker线程进入销毁流程，不可以继续使用。<br/>\",\"695\":\"onAllErrors可以捕获Worker线程的onmessage回调、timer回调以及文件执行等过程中产生的全局异常，且onAllErrors捕获异常后Worker线程仍存活，可以继续使用。因此，推荐使用onAllErrors代替onerror。\",\"696\":\"\",\"697\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"698\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "表示Worker线程生命周期内发生异常时被调用的事件处理程序，处理程序在宿主线程中执行。<br/>",
      "触发条件": "当句子中的动词短语或事件描述缺少必要的时间/条件连接词（如“时”、“的时候”），导致修饰关系不明确，形成冗余或歧义时触发。具体表现为两个动作（如“发生异常”和“被调用”）直接相连，未通过连接词建立明确的触发关系。"
    },
    {
      "defect_id": 528372,
      "sentence": "Worker线程通过转移对象所有权的方式向宿主线程发送消息。",
      "reference_sentence": "",
      "line_num": 1228,
      "context": "{\"1223\":\"\",\"1224\":\"### postMessage<sup>9+</sup>\",\"1225\":\"\",\"1226\":\"postMessage(messageObject: Object, transfer: ArrayBuffer[]): void;\",\"1227\":\"\",\"1228\":\"Worker线程通过转移对象所有权的方式向宿主线程发送消息。\",\"1229\":\"\",\"1230\":\"**原子化服务API：** 从API version 11开始，该接口支持在原子化服务中使用。\",\"1231\":\"\",\"1232\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1233\":\"\"}",
      "修改建议": "句子含有不必要的修饰成分。",
      "更改后示例": "Worker线程通过转移对象所有权向宿主线程发送消息。",
      "触发条件": "当句子中存在\"通过...的方式\"结构，且\"方式\"前的成分已完整表达方法含义时触发。  \n\n识别模式：检测介词\"通过\"后接动名词短语(如\"转移对象所有权\")+的+方式\"组合，判断\"方式\"是否冗余(若删除后句意完整即视为冗余)。"
    },
    {
      "defect_id": 528467,
      "sentence": "表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到Worker线程，在宿主线程中将会变为不可用，仅在Worker线程中可用，数组不可传入null。",
      "reference_sentence": "",
      "line_num": 1756,
      "context": "{\"1751\":\"**参数：**\",\"1752\":\"\",\"1753\":\"| 参数名   | 类型          | 必填 | 说明                                                         |\",\"1754\":\"| -------- | ------------- | ---- | ------------------------------------------------------------ |\",\"1755\":\"| message  | Object        | 是   | 发送至Worker的数据，该数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。 |\",\"1756\":\"| transfer | ArrayBuffer[] | 是   | 表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到Worker线程，在宿主线程中将会变为不可用，仅在Worker线程中可用，数组不可传入null。 |\",\"1757\":\"\",\"1758\":\"**示例：**\",\"1759\":\"\",\"1760\":\"```ts\",\"1761\":\"const workerInstance = new worker.Worker(\\\"workers/worker.ets\\\");\"}",
      "修改建议": "语句过长，包含过多修饰成分。",
      "更改后示例": "表示可转移的ArrayBuffer实例对象数组，该数组的所有权会转移到Worker线程，在宿主线程中不可用，仅在Worker线程中可用。数组不可传入null。",
      "触发条件": "同一名词短语在上下文中重复修饰（如“数组中对象”中的冗余），或存在冗余动词短语（如“将会变为”）导致表述累赘。"
    },
    {
      "defect_id": 528468,
      "sentence": "宿主线程通过转移对象所有权或者拷贝数据的方式向Worker线程发送消息。",
      "reference_sentence": "",
      "line_num": 1771,
      "context": "{\"1766\":\"\",\"1767\":\"### postMessage<sup>(deprecated)</sup>\",\"1768\":\"\",\"1769\":\"postMessage(message: Object, options?: PostMessageOptions): void\",\"1770\":\"\",\"1771\":\"宿主线程通过转移对象所有权或者拷贝数据的方式向Worker线程发送消息。\",\"1772\":\"\",\"1773\":\"> **说明：**<br/>\",\"1774\":\"> 从API version 7开始支持，从API version 9开始废弃，建议使用[ThreadWorker.postMessage<sup>9+</sup>](#postmessage9-1)替代。\",\"1775\":\"\",\"1776\":\"**系统能力：** SystemCapability.Utils.Lang\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "宿主线程通过转移对象所有权或拷贝数据向Worker线程发送消息。",
      "触发条件": "当句子中存在\"通过...的方式\"等冗余介词结构，或使用\"或者\"替代更简洁的\"或\"时触发。识别模式为检测\"方式\"等抽象名词与前置介词形成冗余搭配，以及并列连词使用非必要双字词的情况。"
    },
    {
      "defect_id": 528370,
      "sentence": "将事件对象分发到Worker线程的事件系统。事件系统会自动触发该类型事件对应的所有监听器回调。",
      "reference_sentence": "",
      "line_num": 1111,
      "context": "{\"1106\":\"\",\"1107\":\"### dispatchEvent<sup>9+</sup>\",\"1108\":\"\",\"1109\":\"dispatchEvent(event: Event): boolean\",\"1110\":\"\",\"1111\":\"将事件对象分发到Worker线程的事件系统。事件系统会自动触发该类型事件对应的所有监听器回调。\",\"1112\":\"\",\"1113\":\"**原子化服务API：** 从API version 12开始，该接口支持在原子化服务中使用。\",\"1114\":\"\",\"1115\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1116\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分，且逗号超过5个。",
      "更改后示例": "将事件对象分发到Worker线程的事件系统，触发该类型事件的所有监听器回调。",
      "触发条件": "句子包含可删除的冗余修饰成分（如副词、重复性描述）或重复提及的显性主语，且上下文已隐含其逻辑关系。例如出现“自动触发”“对应的”等冗余限定词，或通过分句合并可消除重复名词（如“事件系统”）。"
    },
    {
      "defect_id": 528367,
      "sentence": "分发事件（dispatchEvent）可与监听接口（on、once、addEventListener）搭配使用，示例如下：",
      "reference_sentence": "",
      "line_num": 956,
      "context": "{\"951\":\"let result: Boolean = workerInstance.dispatchEvent({type: \\\"alert\\\", timeStamp: 0}); // timeStamp暂未支持\",\"952\":\"\",\"953\":\"console.info(\\\"dispatchEvent result is: \\\", result);\",\"954\":\"```\",\"955\":\"\",\"956\":\"分发事件（dispatchEvent）可与监听接口（on、once、addEventListener）搭配使用，示例如下：\",\"957\":\"\",\"958\":\"```ts\",\"959\":\"import { worker, MessageEvents } from '@kit.ArkTS';\",\"960\":\"\",\"961\":\"const workerInstance = new worker.ThreadWorker(\\\"entry/ets/workers/worker.ets\\\");\"}",
      "修改建议": "句子较长，含有多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "分发事件（dispatchEvent）可与监听接口（on、once、addEventListener）搭配使用。",
      "触发条件": "句子包含括号内术语解释+多个逗号分隔结构，且后接示例引导语（如\"示例如下\"）时，当上下文已明确展示代码示例，引导语与前置说明形成语义重复。"
    },
    {
      "defect_id": 535931,
      "sentence": "如果当前任务正在运行，有异常抛出的情况下result的值为undefined，error的值为抛出的异常信息；没有异常的情况下，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。",
      "reference_sentence": "",
      "line_num": 2506,
      "context": "{\"2501\":\"\",\"2502\":\"> **说明：**\",\"2503\":\">\",\"2504\":\"> 任务被取消后，有如下两种情况：\",\"2505\":\">    - 如果当前任务是处于等待阶段，则result的值为undefined，error的值和BusinessError的message字段一致；\",\"2506\":\">    - 如果当前任务正在运行，有异常抛出的情况下result的值为undefined，error的值为抛出的异常信息；没有异常的情况下，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。\",\"2507\":\">\",\"2508\":\"\",\"2509\":\"**示例**\",\"2510\":\"\",\"2511\":\"```ts\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "如果当前任务正在运行：有异常抛出时，result的值为undefined，error的值为抛出的异常信息；没有异常时，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。",
      "触发条件": "当句子包含超过两个用逗号连接的并列条件描述，且信息密度过高导致可读性下降时触发，常见于技术规范中的多条件说明场景。\n\n识别模式：\n1. 结构特征：单句内存在分号/逗号分隔的多组\"情况-结果\"描述\n2. 语义特征：包含重复的句式结构（如\"有...情况下...；没有...情况下...\"）\n3. 语境特征：出现在技术文档的条件说明段落，特别是对比不同场景的返回值时"
    },
    {
      "defect_id": 528374,
      "sentence": "表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到宿主线程，在Worker线程中将会变为不可用，仅在宿主线程中可用，数组不可传入null。",
      "reference_sentence": "",
      "line_num": 1239,
      "context": "{\"1234\":\"**参数：**\",\"1235\":\"\",\"1236\":\"| 参数名   | 类型          | 必填 | 说明                                                         |\",\"1237\":\"| -------- | ------------- | ---- | ------------------------------------------------------------ |\",\"1238\":\"| messageObject  | Object        | 是   | 发送至宿主线程的数据，该数据对象必须是可序列化，序列化支持类型见[其他说明](#序列化支持类型)。 |\",\"1239\":\"| transfer | ArrayBuffer[] | 是   | 表示可转移的ArrayBuffer实例对象数组，该数组中对象的所有权会被转移到宿主线程，在Worker线程中将会变为不可用，仅在宿主线程中可用，数组不可传入null。 |\",\"1240\":\"\",\"1241\":\"**错误码：**\",\"1242\":\"\",\"1243\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\",\"1244\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且含有不必要的修饰成分。",
      "更改后示例": "表示可转移的ArrayBuffer实例对象数组。该数组中的对象所有权将转移到宿主线程，在Worker线程中不可用，仅在宿主线程中可用。数组不可传入null。",
      "触发条件": "当句子包含多个逗号分隔的从句且存在重复修饰成分（如冗余动词短语、重复语义表达）时触发；或同一技术属性在相邻分句中多次重复强调（如\"不可用\"与\"仅在...可用\"并存）时触发。\n\n识别模式：\n1. 长句结构：通过逗号连续拼接超过3个分句，且分句间存在语义重叠（如原句用4个分句描述同一对象的可用性状态）。\n2. 冗余动词：包含\"会被\"\"将会变为\"等可简化为单动词的被动结构（如\"会被转移\"→\"将转移\"）。\n3. 重复限制条件：同一限制说明以不同句式重复出现（如原句通过正反两种形式强调\"仅在宿主线程可用\"）。"
    },
    {
      "defect_id": 535908,
      "sentence": "执行的逻辑需要传入函数，必须使用[@Concurrent装饰器](../../arkts-utils/taskpool-introduction.md#concurrent装饰器)装饰，支持的函数返回值类型请查[序列化支持类型](#序列化支持类型)。",
      "reference_sentence": "",
      "line_num": 2044,
      "context": "{\"2039\":\"\",\"2040\":\"**参数：**\",\"2041\":\"\",\"2042\":\"| 参数名 | 类型      | 必填 | 说明                                                                   |\",\"2043\":\"| ------ | --------- | ---- | ---------------------------------------------------------------------- |\",\"2044\":\"| func   | Function  | 是   | 执行的逻辑需要传入函数，必须使用[@Concurrent装饰器](../../arkts-utils/taskpool-introduction.md#concurrent装饰器)装饰，支持的函数返回值类型请查[序列化支持类型](#序列化支持类型)。     |\",\"2045\":\"| args   | Object[] | 否   | 任务执行函数所需要的入参，支持的参数类型请查[序列化支持类型](#序列化支持类型)。默认值为undefined。 |\",\"2046\":\"\",\"2047\":\"**错误码：**\",\"2048\":\"\",\"2049\":\"以下错误码的详细介绍请参见[通用错误码](../errorcode-universal.md)和[语言基础类库错误码](errorcode-utils.md)。\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "执行的逻辑需要传入函数，必须使用[@Concurrent装饰器](../../arkts-utils/taskpool-introduction.md#concurrent装饰器)装饰。支持的函数返回值类型请查[序列化支持类型](#序列化支持类型)。",
      "触发条件": "在技术文档的参数说明或表格单元格中，单个句子包含多个逗号分隔的独立信息点（如功能要求与类型限制），且句子长度超过阅读友好阈值（通常>40字）。  \n\n识别模式：  \n1. 检查结构化内容（如参数表格）中是否存在用逗号连接的复合型描述  \n2. 判断逗号分隔部分是否表达完整独立语义（如示例中的装饰器要求与返回值说明）  \n3. 验证拆分后是否保持语义完整性且不产生歧义"
    },
    {
      "defect_id": 536047,
      "sentence": "控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。",
      "reference_sentence": "",
      "line_num": 232,
      "context": "{\"227\":\"\",\"228\":\"**【描述】**\",\"229\":\"\",\"230\":\"代码行宽不宜过长，否则不利于阅读。\",\"231\":\"\",\"232\":\"控制行宽可以间接的引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。\",\"233\":\"建议每行字符数不超过120个，除非需要显著增加可读性（超过120个），且不会隐藏信息。\",\"234\":\"例外：如果一行注释包含了超过120个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；预处理的error信息在一行便于阅读和理解，即使超过120个字符。\",\"235\":\"\",\"236\":\"### 条件语句和循环语句的实现必须使用大括号\",\"237\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "控制行宽可以间接引导程序员缩短函数和变量的命名，减少嵌套层数，精炼注释，从而提升代码可读性。",
      "触发条件": "当句子出现连续三个及以上逗号分隔的动词短语，且存在冗余助词（如\"去\"、\"的\"）时触发。\n\n识别模式：\n1. 结构特征：连续逗号分隔的并列动词短语（例：缩短...，减少...，精炼...，提升...）\n2. 冗余标记：动词前存在非必要助词（\"去缩短\"→\"缩短\"）、名词前冗余定语（\"的层数\"→\"层数\"）\n3. 逻辑连接：多个动作与结果之间缺乏递进关系词（添加\"从而\"明确因果关系）\n4. 句式诊断：单句超过25字且包含4个以上动词性成分时，易产生表达冗余"
    },
    {
      "defect_id": 535930,
      "sentence": "如果当前任务是处于等待阶段，则result的值为undefined，error的值和BusinessError的message字段一致；",
      "reference_sentence": "",
      "line_num": 2505,
      "context": "{\"2500\":\"| error   | Error \\\\| Object   | 是   | 是   | 错误信息。默认和BusinessError的message字段一致。                 |\",\"2501\":\"\",\"2502\":\"> **说明：**\",\"2503\":\">\",\"2504\":\"> 任务被取消后，有如下两种情况：\",\"2505\":\">    - 如果当前任务是处于等待阶段，则result的值为undefined，error的值和BusinessError的message字段一致；\",\"2506\":\">    - 如果当前任务正在运行，有异常抛出的情况下result的值为undefined，error的值为抛出的异常信息；没有异常的情况下，result为任务执行完成后的结果，error的值和BusinessError的message字段一致。\",\"2507\":\">\",\"2508\":\"\",\"2509\":\"**示例**\",\"2510\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "如果当前任务处于等待阶段，result为undefined，error与BusinessError的message字段一致；",
      "触发条件": "当句子中存在冗余的系动词结构（如\"是处于\"）或重复的名词短语（如\"的值为\"、\"的值和\"）时触发，需识别\"的+动词\"冗余表达模式。\n\n具体识别模式：\n1. 检查\"是+动词\"结构（如\"是处于\"）中系动词\"是\"是否冗余\n2. 检测\"的+值\"类重复表达（如\"result的值为\"可简化为\"result为\"）\n3. 识别\"的值和\"类冗余名词短语（应简化为\"与\"直接连接主体）"
    },
    {
      "defect_id": 536044,
      "sentence": "本文适用于使用ArkTS编写代码的开发场景。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 目标和适用范围\",\"4\":\"\",\"5\":\"本文参考业界标准及实践，结合ArkTS语言特点，为提高代码的规范、安全、性能提供编码指南。\",\"6\":\"\",\"7\":\"本文适用于使用ArkTS编写代码的开发场景。\",\"8\":\"\",\"9\":\"## 规则来源\",\"10\":\"\",\"11\":\"ArkTS在保持TypeScript基本语法风格的基础上，进一步强化静态检查和分析。本文部分规则筛选自《[OpenHarmony应用TS&JS编程指南](https://gitee.com/openharmony/docs/blob/master/zh-cn/contribute/OpenHarmony-Application-Typescript-JavaScript-coding-guide.md)》，为ArkTS语言新增的语法添加了规则，旨在提高代码可读性、执行性能。\",\"12\":\"\"}",
      "修改建议": "句子可以更简洁。",
      "更改后示例": "本文适用于使用ArkTS编写的开发场景。",
      "触发条件": "句子中存在动词短语中包含冗余宾语，且该宾语已被动词本身含义所隐含（如“编写代码”中的“代码”冗余）。"
    },
    {
      "defect_id": 536298,
      "sentence": "ArkTS不支持映射类型，使用其他语法来表示相同的语义。",
      "reference_sentence": "",
      "line_num": 1825,
      "context": "{\"1820\":\"\",\"1821\":\"**级别：错误**\",\"1822\":\"\",\"1823\":\"**错误码：10605083**\",\"1824\":\"\",\"1825\":\"ArkTS不支持映射类型，使用其他语法来表示相同的语义。\",\"1826\":\"\",\"1827\":\"**TypeScript**\",\"1828\":\"\",\"1829\":\"```typescript\",\"1830\":\"type OptionsFlags<Type> = {\"}",
      "修改建议": "句子较长，可以简化。",
      "更改后示例": "ArkTS不支持映射类型，使用其他语法表示相同语义。",
      "触发条件": "检测到句子中存在冗余的“来+动词”结构（如“来表示”）且该结构可简化为单个动词（如“表示”）时触发；或出现类似“用来/用于”等无实际语义的引导词时触发。"
    },
    {
      "defect_id": 536091,
      "sentence": "在大多数情况下，函数`notify`会接受两个`string`类型的变量作为输入，产生一个新的字符串。但是，如果将一些特殊值作为输入，例如`notify(null, undefined)`，情况会怎么样呢？\r程序仍会正常运行，输出预期值：`Dear null, a message for you: undefined`。一切看起来正常，但是请注意，为了保证该场景下程序的正确性，引擎总是在运行时进行类型检查，执行类似以下的伪代码。",
      "reference_sentence": "",
      "line_num": 101,
      "context": "{\"96\":\"}\",\"97\":\"\",\"98\":\"notify('Jack', 'You look great today');\",\"99\":\"```\",\"100\":\"\",\"101\":\"在大多数情况下，函数`notify`会接受两个`string`类型的变量作为输入，产生一个新的字符串。但是，如果将一些特殊值作为输入，例如`notify(null, undefined)`，情况会怎么样呢？\",\"102\":\"程序仍会正常运行，输出预期值：`Dear null, a message for you: undefined`。一切看起来正常，但是请注意，为了保证该场景下程序的正确性，引擎总是在运行时进行类型检查，执行类似以下的伪代码。\",\"103\":\"\",\"104\":\"```typescript\",\"105\":\"function __internal_tostring(s: any): string {\",\"106\":\"  if (typeof s === 'string')\"}",
      "修改建议": "句子较长，包含多个逗号，可以拆分成多个句子。",
      "更改后示例": "在大多数情况下，函数`notify`会接受两个`string`类型的变量作为输入，产生一个新的字符串。但是，如果将一些特殊值作为输入，例如`notify(null, undefined)`，情况会怎么样呢？程序仍会正常运行，输出预期值：`Dear null, a message for you: undefined`。一切看起来正常，但请注意，为了保证该场景下程序的正确性，引擎总是在运行时进行类型检查，执行类似以下的伪代码。",
      "触发条件": "当句子包含超过两个逗号分隔的独立子句，且存在冗余转折词（如\"但是请注意\"中的\"但是\"与上文转折重复）时，或长句造成逻辑层次模糊时触发。识别模式为：连续逗号分句≥3组，转折词与上文语义重复，或单句字符数超过80且包含多重嵌套结构。"
    },
    {
      "defect_id": 536225,
      "sentence": "尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能将会导致程序编译失败。",
      "reference_sentence": "",
      "line_num": 30,
      "context": "{\"25\":\"**级别**\",\"26\":\"\",\"27\":\"约束分为两个级别：错误、警告。\",\"28\":\"\",\"29\":\"- **错误**: 必须要遵从的约束。如果不遵从该约束，将会导致程序编译失败。 \",\"30\":\"- **警告**: 推荐遵从的约束。尽管现在违反该约束不会影响编译流程，但是在将来，违反该约束可能将会导致程序编译失败。\",\"31\":\"\",\"32\":\"**不支持的特性**\",\"33\":\"\",\"34\":\"目前，不支持的特性主要包括：\",\"35\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "尽管现在违反该约束不会影响编译流程，但将来可能会导致程序编译失败。",
      "触发条件": "当句子出现连续冗余连词（如\"但是在\"）、重复时间状语介词（如\"在将来\"）或双重未来时态表述（如\"可能将会\"），且存在重复主语/动词短语（如\"违反该约束\"二次出现）时触发。"
    },
    {
      "defect_id": 538351,
      "sentence": "设置音振协同播放器的振幅，并使用Promise进行异步回调。",
      "reference_sentence": "",
      "line_num": 668,
      "context": "{\"663\":\"\",\"664\":\"### setHapticsIntensity\",\"665\":\"\",\"666\":\"setHapticsIntensity(intensity: number): Promise&lt;void&gt;\",\"667\":\"\",\"668\":\"设置音振协同播放器的振幅，并使用Promise进行异步回调。\",\"669\":\"该方法必须在音振协同播放器释放前调用，单次播放过程中仅调用一次。\",\"670\":\"\",\"671\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"672\":\"\",\"673\":\"**参数**\"}",
      "修改建议": "句子较长，可以拆分成两个句子。",
      "更改后示例": "设置音振协同播放器的振幅。使用Promise进行异步回调。",
      "触发条件": "句子中存在由连词（如“并”）连接的多个独立动作或信息点，且拆分后不影响逻辑连贯性；或句子长度过长导致可读性下降。  \n\n识别模式：检测句子中是否包含“并”、“以及”等连词串联的多个谓语/分句，或通过句长阈值（如超过25字）判断是否需要拆分。"
    },
    {
      "defect_id": 538349,
      "sentence": "设置音振协同播放器的音量，使用Promise进行异步回调。",
      "reference_sentence": "",
      "line_num": 625,
      "context": "{\"620\":\"\",\"621\":\"### setVolume\",\"622\":\"\",\"623\":\"setVolume(volume: number): Promise&lt;void&gt;\",\"624\":\"\",\"625\":\"设置音振协同播放器的音量，使用Promise进行异步回调。\",\"626\":\"该方法需在音振协同播放器释放前调用。\",\"627\":\"\",\"628\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"629\":\"\",\"630\":\"**参数**\"}",
      "修改建议": "句子较长，可以拆分成两个句子。",
      "更改后示例": "设置音振协同播放器的音量。使用Promise进行异步回调。",
      "触发条件": "句子包含两个及以上独立操作或信息点，且使用逗号连接导致冗长（如技术动作+实现机制/回调方式），需拆分确保每句表达单一语义。"
    },
    {
      "defect_id": 538356,
      "sentence": "设置音振协同播放器循环播放，并使用Promise进行异步回调。",
      "reference_sentence": "",
      "line_num": 763,
      "context": "{\"758\":\"\",\"759\":\"### setLoop\",\"760\":\"\",\"761\":\"setLoop(loop: boolean): Promise&lt;void&gt;\",\"762\":\"\",\"763\":\"设置音振协同播放器循环播放，并使用Promise进行异步回调。\",\"764\":\"该方法需在音振协同播放器销毁前调用。\",\"765\":\"\",\"766\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"767\":\"\",\"768\":\"**参数**\"}",
      "修改建议": "句子较长，可以拆分成两个句子。",
      "更改后示例": "设置音振协同播放器循环播放。使用Promise进行异步回调。",
      "触发条件": "当单句包含两个及以上用连词(如\"并\")连接的独立操作描述，且每个操作均可独立成句时触发；或技术文档中出现超过25字的复合句且存在可拆分逻辑单元时触发。识别模式需检测并列连词使用情况，判断分句间的语义独立性，并评估句子复杂度对可读性的影响。"
    },
    {
      "defect_id": 538905,
      "sentence": "从API version 20开始，RichEditor组件在执行复制或剪切操作时，会将HTML格式的内容添加到剪贴板中。",
      "reference_sentence": "",
      "line_num": 106,
      "context": "{\"101\":\"\",\"102\":\"copyOptions(value: CopyOptions)\",\"103\":\"\",\"104\":\"设置组件是否支持文本内容可复制粘贴。\",\"105\":\"\",\"106\":\"从API version 20开始，RichEditor组件在执行复制或剪切操作时，会将HTML格式的内容添加到剪贴板中。\",\"107\":\"\",\"108\":\"- 仅支持TextSpan和ImageSpan向剪贴板中添加HTML内容，其他Span类型则不能添加。\",\"109\":\"\",\"110\":\"- 设置RichEditor组件的属性字符串时，请参考属性字符串[toHtml](ts-universal-styled-string.md#tohtml14)接口文档，以了解支持转换为HTML的范围。\",\"111\":\"\"}",
      "修改建议": "句子较长，包含多个逗号，可以简化。",
      "更改后示例": "从API version 20开始，RichEditor组件在复制或剪切时会将HTML格式的内容添加到剪贴板。",
      "触发条件": "技术文档中出现\"执行...操作时\"等冗余动词结构，或存在可通过简化动词短语来提升简洁度的复合句式。\n\n识别模式：检测包含\"执行/进行/做+(名词性)操作/动作/处理\"的句式(如\"执行复制操作\")，或包含多个逗号的长句结构，优先处理技术说明类文本中的这类冗余表达。"
    },
    {
      "defect_id": 538347,
      "sentence": "静音模式下，音振协同播放器可以振动。",
      "reference_sentence": "",
      "line_num": 595,
      "context": "{\"590\":\"\",\"591\":\"### enableHapticsInSilentMode\",\"592\":\"\",\"593\":\"enableHapticsInSilentMode(enable: boolean): void\",\"594\":\"\",\"595\":\"静音模式下，音振协同播放器可以振动。\",\"596\":\"该方法必须在释放音振播放器前使用，不能在播放中调用。\",\"597\":\"\",\"598\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"599\":\"\",\"600\":\"**参数**\"}",
      "修改建议": "句子较冗长，可以简化。",
      "更改后示例": "静音模式下，音振播放器可以振动。",
      "触发条件": "当句子中的名词短语包含冗余修饰词（如重复功能描述或可合并的技术术语），且删除后不影响原意时触发。例如，复合名词中存在可简化的协同/重复功能词（如“协同”在上下文无明确区分需求时）。"
    },
    {
      "defect_id": 538345,
      "sentence": "查询当前设备是否支持调整振动幅度。",
      "reference_sentence": "",
      "line_num": 539,
      "context": "{\"534\":\"\",\"535\":\"### isHapticsIntensityAdjustmentSupported\",\"536\":\"\",\"537\":\"isHapticsIntensityAdjustmentSupported(): boolean\",\"538\":\"\",\"539\":\"查询当前设备是否支持调整振动幅度。\",\"540\":\"\",\"541\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"542\":\"\",\"543\":\"**返回值：**\",\"544\":\"\"}",
      "修改建议": "句子较冗长，可以简化。",
      "更改后示例": "查询设备是否支持调整振动幅度。",
      "触发条件": "句子中存在可被上下文或动词本身隐含的冗余限定词（如\"当前\"、\"现在\"等），或存在重复语义的动词结构（如\"进行查询\"）。通过识别修饰词是否与上下文/动词存在语义重叠，且删除后不影响核心语义完整性时触发。"
    },
    {
      "defect_id": 538353,
      "sentence": "设置音振协同播放器渐变播放，使用Promise进行异步回调。",
      "reference_sentence": "",
      "line_num": 712,
      "context": "{\"707\":\"\",\"708\":\"### setHapticsRamp\",\"709\":\"\",\"710\":\"setHapticsRamp(duration: number, startIntensity: number, endIntensity: number): Promise&lt;void&gt;\",\"711\":\"\",\"712\":\"设置音振协同播放器渐变播放，使用Promise进行异步回调。\",\"713\":\"该方法必须在音振协同播放器播放前后以及销毁前使用。\",\"714\":\"该方法仅能调用一次。\",\"715\":\"\",\"716\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"717\":\"\"}",
      "修改建议": "句子较长，可以拆分成两个句子。",
      "更改后示例": "设置音振协同播放器渐变播放。使用Promise进行异步回调。",
      "触发条件": "当单句包含两个及以上独立操作/概念（由逗号连接且无逻辑承接词），且拆分后不影响语义连贯性时触发；或技术文档中功能描述与实现方式混合导致句子超长（超过20字）时触发。\n\n识别模式：1) 逗号分隔的动词短语结构（如\"设置...，使用...\"）2) 包含技术实现细节（如Promise回调）与功能描述混杂 3) 句子长度超过技术文档推荐单句长度（15-25字）"
    },
    {
      "defect_id": 536297,
      "sentence": "由于在ArkTS中，对象布局在编译时是确定的并且在运行时无法修改，因此不支持使用`for .. in`迭代一个对象的属性。",
      "reference_sentence": "",
      "line_num": 1797,
      "context": "{\"1792\":\"\",\"1793\":\"**级别：错误**\",\"1794\":\"\",\"1795\":\"**错误码：10605080**\",\"1796\":\"\",\"1797\":\"由于在ArkTS中，对象布局在编译时是确定的并且在运行时无法修改，因此不支持使用`for .. in`迭代一个对象的属性。\",\"1798\":\"\",\"1799\":\"**TypeScript**\",\"1800\":\"\",\"1801\":\"```typescript\",\"1802\":\"let a: string[] = ['1.0', '2.0', '3.0'];\"}",
      "修改建议": "句子较长，可以简化。",
      "更改后示例": "在ArkTS中，对象布局在编译时确定且运行时不可修改，因此不支持使用`for .. in`迭代对象属性。",
      "触发条件": "当句子中存在由\"并且\"等冗余连词连接的并列结构，或包含可合并的重复限定词（如\"一个的\"）时触发。识别模式为检查\"是...的\"结构和冗余连词连接的并列形容词/动词短语。"
    },
    {
      "defect_id": 536260,
      "sentence": "在以下上下文中不支持使用字面量初始化类和接口：* 初始化具有`any`、`Object`或`object`类型的任何对象* 初始化带有方法的类或接口* 初始化包含自定义含参数的构造函数的类* 初始化带`readonly`字段的类",
      "reference_sentence": "",
      "line_num": 1010,
      "context": "{\"1005\":\"\",\"1006\":\"**错误码：10605038**\",\"1007\":\"\",\"1008\":\"在ArkTS中，需要显式标注对象字面量的类型，否则，将发生编译时错误。在某些场景下，编译器可以根据上下文推断出字面量的类型。\",\"1009\":\"\",\"1010\":\"在以下上下文中不支持使用字面量初始化类和接口：\",\"1011\":\"\",\"1012\":\"* 初始化具有`any`、`Object`或`object`类型的任何对象\",\"1013\":\"* 初始化带有方法的类或接口\",\"1014\":\"* 初始化包含自定义含参数的构造函数的类\",\"1015\":\"* 初始化带`readonly`字段的类\"}",
      "修改建议": "句子中的逗号数量超过5个，且包含不必要的修饰成分。",
      "更改后示例": "在以下情况下不支持使用字面量初始化类和接口：* `any`、`Object`或`object`类型的对象* 带有方法的类或接口* 包含自定义含参数构造函数的类* 带`readonly`字段的类",
      "触发条件": "当文档中的列表项或并列结构出现重复的引导短语（如\"初始化具有/带有/包含\"），或条目内部存在冗余修饰成分（如\"任何对象\"/\"自定义含参数的\"）时触发。  \n识别模式：检查列表项是否以相同动词短语开头，且条目内容包含可简化的重复性修饰语（如双重限定词、冗余动作描述）。"
    },
    {
      "defect_id": 538318,
      "sentence": "Call this API before releasing the player.",
      "reference_sentence": "",
      "line_num": 764,
      "context": "{\"759\":\"### setLoop\",\"760\":\"\",\"761\":\"setLoop(loop: boolean): Promise&lt;void&gt;\",\"762\":\"\",\"763\":\"Set the playback to be looping; this method uses a promise to return the result.\",\"764\":\"Call this API before releasing the player.\",\"765\":\"\",\"766\":\"**System capability**: SystemCapability.Multimedia.AudioHaptic.Core\",\"767\":\"\",\"768\":\"**Parameters**\",\"769\":\"\"}",
      "修改建议": "句子中添加了不必要的修饰成分。",
      "更改后示例": "Call this API before release.",
      "触发条件": "当句子中出现动名词短语（如“releasing the player”）且其宾语在上下文中已明确隐含时，或动词名词化（如“release”）即可完整表意时，应触发冗余表达规则。识别模式为检测“动词+ing + 冗余宾语/修饰语”结构，并验证其宾语是否可通过上下文隐式推导省略。"
    },
    {
      "defect_id": 538346,
      "sentence": "检查设备是否支持振动渐变调整。",
      "reference_sentence": "",
      "line_num": 567,
      "context": "{\"562\":\"\",\"563\":\"### isHapticsRampSupported\",\"564\":\"\",\"565\":\"isHapticsRampSupported(): boolean\",\"566\":\"\",\"567\":\"检查设备是否支持振动渐变调整。\",\"568\":\"\",\"569\":\"**系统能力：** SystemCapability.Multimedia.AudioHaptic.Core\",\"570\":\"\",\"571\":\"**返回值：**\",\"572\":\"\"}",
      "修改建议": "句子较冗长，可以简化。",
      "更改后示例": "检查设备是否支持振动渐变。",
      "触发条件": "当动词短语中存在冗余动作描述（如\"调整\"）且上下文已隐含该操作时，或技术术语被不必要地扩展（如\"渐变调整\"替代标准术语\"渐变\"）时触发。\n\n识别模式：1) 动词+名词复合结构中出现重复动作词（如\"xx调整调整\"） 2) API接口名称/系统能力字段（如isHapticsRampSupported）中的核心术语（ramp→渐变）被添加多余操作词（调整）时。"
    },
    {
      "defect_id": 539806,
      "sentence": "- **数值类型** 在使用Node-API接口时，可能需要从Node-API模块数值类型转换为ArkTS数值类型值，或者从ArkTS数据类型值转换为Node-API模块数值类型。在进行数据类型转换时，需要注意数据范围是否匹配，以及有无符号整数和双精度数值等区别。",
      "reference_sentence": "",
      "line_num": 11,
      "context": "{\"6\":\"\",\"7\":\"## 基本概念\",\"8\":\"\",\"9\":\"当使用Node-API接口进行数值类型的创建和获取时，有一些基本概念需要了解：\",\"10\":\"\",\"11\":\"- **数值类型** 在使用Node-API接口时，可能需要从Node-API模块数值类型转换为ArkTS数值类型值，或者从ArkTS数据类型值转换为Node-API模块数值类型。在进行数据类型转换时，需要注意数据范围是否匹配，以及有无符号整数和双精度数值等区别。\",\"12\":\"- **错误处理** 在使用这些接口时，需要对可能发生的错误进行适当处理。比如，在创建整数值时可能发生内存分配错误或其他运行时错误，需要使用Node-API提供的错误处理机制来捕获并处理这些错误。\",\"13\":\"- **ArkTS交互** 在开发过程中，需要考虑如何将创建的数值类型值与ArkTS环境进行交互，包括传递参数、返回值等。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "- **数值类型** 在使用Node-API接口时，可能需要从Node-API模块数值类型转换为ArkTS数值类型，或从ArkTS数值类型转换为Node-API模块数值类型。转换时，需注意数据范围匹配和有无符号整数、双精度数值的区别。",
      "触发条件": "当句子中出现重复的转换方向描述（如\"A转换为B，或B转换为A\"结构）且伴随冗余修饰语（如\"在进行...时\"），或存在可合并的并列成分（如多个\"以及\"分隔项）时触发。\n\n具体识别模式：\n1. 检查是否存在镜像式双向转换表述（正反转换重复出现）\n2. 分析句子是否包含可简化的动词短语（如\"在进行...时\"→\"转换时\"）\n3. 检测并列结构是否超过两个项目且使用复杂连接词（如\"以及...等区别\"）\n4. 识别超过3个逗号分隔的长复合句结构\n5. 发现重复出现的关键词变体（如\"数据类型值\"与\"数值类型\"交替使用）"
    },
    {
      "defect_id": 536395,
      "sentence": "根据业务需求，将函数参数声明为必选参数。可以考虑使用默认参数。",
      "reference_sentence": "",
      "line_num": 123,
      "context": "{\"118\":\"  }\",\"119\":\"  return undefined;\",\"120\":\"}\",\"121\":\"```\",\"122\":\"\",\"123\":\"根据业务需求，将函数参数声明为必选参数。可以考虑使用默认参数。\",\"124\":\"``` TypeScript\",\"125\":\"function add(left: number = 0, right: number = 0): number {\",\"126\":\"  return left + right;\",\"127\":\"}\",\"128\":\"```\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "根据业务需求，将函数参数声明为必选参数。考虑使用默认参数。",
      "触发条件": "当连续语句中前句已明确行为主体，后句使用\"可以\"等可能性助动词引导建议，且删除助动词后语句更简洁且语义完整时。识别模式为检测\"可以考虑/可以尝试\"等结构后接建议内容，且前文已建立明确语境的情况。"
    },
    {
      "defect_id": 539810,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\",\"27\":\"| napi_create_double | 将Node-API模块中的double类型转换为ArkTS环境中number类型。 |\",\"28\":\"\",\"29\":\"## 使用示例\",\"30\":\"\",\"31\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"32\":\"\",\"33\":\"### napi_get_value_uint32\",\"34\":\"\",\"35\":\"用于从ArkTS环境中获取32位无符号整数值。\",\"36\":\"\"}",
      "修改建议": "句子过长，包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)。本文仅展示接口对应的C++和ArkTS代码。",
      "触发条件": "句子包含多个逗号分隔的独立语义分句，且存在冗余修饰成分（如\"相关\"\"进行\"等无实义词汇）时触发。\n\n识别模式：  \n1. **分句冗余**：通过逗号拼接两个独立语义内容（如案例中前半句引用文档，后半句说明本文范围）  \n2. **修饰冗余**：检测到\"相关\"\"进行\"等弱化表达（如\"相关代码\"→\"代码\"，\"进行展示\"→\"展示\"）  \n3. **动词冗余**：存在\"对...进行...\"结构（可直接简化为动词短语，如\"进行展示\"→\"展示\"）"
    },
    {
      "defect_id": 541040,
      "sentence": "本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。",
      "reference_sentence": "",
      "line_num": 7,
      "context": "{\"2\":\"\",\"3\":\"## 场景介绍\",\"4\":\"\",\"5\":\"OpenHarmony Node-API是基于Node.js 12.x LTS的[Node-API](https://nodejs.org/docs/latest-v12.x/api/n-api.html)规范扩展开发的机制，为开发者提供了ArkTS/JS与C/C++模块之间的交互能力。它提供了一组稳定的、跨平台的API，可以在不同的操作系统上使用。\",\"6\":\"\",\"7\":\"本文中如无特别说明，后续均使用Node-API指代OpenHarmony Node-API能力。\",\"8\":\"\",\"9\":\"> **说明：**\",\"10\":\">\",\"11\":\"> OpenHarmony Node-API与Node.js 12.x LTS的Node-API规范的接口异同点，详见[Node-API参考](../reference/native-lib/napi.md)\",\"12\":\"\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "本文中，除非另有说明，后续均使用Node-API指代OpenHarmony Node-API。",
      "触发条件": "当句子中存在可被更简洁的同义表达替代的复杂句式结构（如\"如无特别说明\"→\"除非另有说明\"），或术语定义后附加冗余限定词（如\"能力\"在已明确定义的专有名词后）时触发。\n\n识别模式：\n1. 检测\"如无...说明\"类条件状语从句，优先替换为\"除非另有说明\"标准表达\n2. 在已明确定义的专有名词后扫描冗余限定词（能力/功能/机制等），通过上下文验证术语是否已完整定义\n3. 结合相邻段落验证术语首次定义时的完整形态，识别后续重复出现时的多余修饰成分"
    },
    {
      "defect_id": 542066,
      "sentence": "以上代码如果要在native cpp中打印日志，需在CMakeLists.txt文件中添加以下配置信息（并添加头文件：#include \"hilog/log.h\"）：",
      "reference_sentence": "",
      "line_num": 181,
      "context": "{\"176\":\"  hilog.error(0x0000, 'testTag', 'Test Node-API napi_is_date error: %{public}s', error.message);\",\"177\":\"}\",\"178\":\"```\",\"179\":\"<!-- @[ark_napi_is_date](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIDate/entry/src/main/ets/pages/Index.ets) -->\",\"180\":\"\",\"181\":\"以上代码如果要在native cpp中打印日志，需在CMakeLists.txt文件中添加以下配置信息（并添加头文件：#include \\\"hilog/log.h\\\"）：\",\"182\":\"\",\"183\":\"```text\",\"184\":\"// CMakeLists.txt\",\"185\":\"add_definitions( \\\"-DLOG_DOMAIN=0xd0d0\\\" )\",\"186\":\"add_definitions( \\\"-DLOG_TAG=\\\\\\\"testTag\\\\\\\"\\\" )\"}",
      "修改建议": "句子过长，包含多个信息点，建议拆分。",
      "更改后示例": "以上代码如果要在native cpp中打印日志，需在CMakeLists.txt文件中添加以下配置信息。还需要添加头文件：#include \\",
      "触发条件": "当句子使用括号包裹多个独立操作说明（特别是同时涉及配置修改和代码引用），且导致信息密度过高时触发；或技术文档中单句包含两个及以上需要分步骤执行的关联操作时触发。\n\n识别模式：1) 检测括号内是否存在\"并\"/\"且\"等连接词串联不同性质操作 2) 判断技术说明句是否包含超过一个强关联但需分步执行的指令（如配置修改+代码引用需拆分为编译环境配置和编码实现两个阶段）"
    },
    {
      "defect_id": 542017,
      "sentence": "在Node-API模块中接收到一个ArkTS的Date对象，并且需要获取其对应的时间戳或日期值时，可以使用此接口。",
      "reference_sentence": "",
      "line_num": 21,
      "context": "{\"16\":\"\",\"17\":\"以下Node-API函数通常在开发Node-API模块中与ArkTS的Date对象进行交互时使用，来处理和操作日期数据。以下是一些可能的使用场景：\",\"18\":\"| 接口 | 描述 |\",\"19\":\"| -------- | -------- |\",\"20\":\"| napi_create_date | 在需要根据当前系统时间或特定计算生成一个Date对象时，可通过使用此接口创建表示这些时间的ArkTS Date对象，然后将其传递给ArkTS代码进行进一步处理。 |\",\"21\":\"| napi_get_date_value | 在Node-API模块中接收到一个ArkTS的Date对象，并且需要获取其对应的时间戳或日期值时，可以使用此接口。|\",\"22\":\"| napi_is_date | 在需要确定一个ArkTS对象是否为Date对象时，可使用此接口判断给定的值是否为Date对象。例如，在接收函数参数时，需要验证参数是否为Date对象以确保正确的数据类型。 |\",\"23\":\"\",\"24\":\"## 使用示例\",\"25\":\"\",\"26\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应的C++及ArkTS相关代码进行展示。\"}",
      "修改建议": "语句过长，包含不必要的修饰成分。",
      "更改后示例": "在Node-API模块中接收到ArkTS的Date对象并需要获取其时间戳或日期值时，可以使用此接口。",
      "触发条件": "当句子中存在由\"并且\"、\"以及\"等连词连接的并列分句，且其中包含重复性修饰语（如\"其对应的\"）时，应触发冗余表达规则。通过识别\"连词+重复限定词\"结构（例如\"并且需要获取其对应的\"）判断需删除冗余成分。"
    },
    {
      "defect_id": 541842,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 29,
      "context": "{\"24\":\"| napi_add_async_cleanup_hook | 注册一个异步清理钩子函数，该函数将在Node-API进程退出时异步执行。 |\",\"25\":\"| napi_remove_async_cleanup_hook | 取消之前注册的异步清理钩子函数，确保在不需要时不会执行相关的清理工作。 |\",\"26\":\"\",\"27\":\"## 使用示例\",\"28\":\"\",\"29\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"30\":\"\",\"31\":\"### napi_add_env_cleanup_hook\",\"32\":\"\",\"33\":\"用于注册一个环境清理钩子函数，该函数将在环境退出时执行。这是确保资源在环境销毁前得到清理的重要机制。\",\"34\":\"\"}",
      "修改建议": "该句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)。本文仅展示接口对应的C++及ArkTS代码。",
      "触发条件": "当句子结构包含连续逗号分隔的复合句式，且存在可简化的冗余修饰语（如\"进行展示\"替代\"展示\"、\"相关\"等非必要限定词）时触发。识别模式需检测超过两个分句的长句搭配\"进行+动词\"结构或重复性限定词。"
    },
    {
      "defect_id": 541840,
      "sentence": "以上这些基本概念是理解和使用Node-API接口注册环境清理钩子的基础，下面将介绍具体的接口和使用示例。",
      "reference_sentence": "",
      "line_num": 14,
      "context": "{\"9\":\"Node-API提供了注册和取消注册清理钩子函数的功能，以下是相关概念：\",\"10\":\"\",\"11\":\"- **资源管理**：在ArkTS中，通常需要管理一些系统资源，比如内存、文件句柄、网络连接等。这些资源必须在Node-API模块的生命周期中正确地创建、使用和释放，以避免资源泄漏和程序崩溃。资源管理通常包括初始化资源、在合适的时候清理资源，以及在清理资源时执行必要的操作，比如关闭文件或断开网络连接。\",\"12\":\"- **钩子函数（Hook）**：钩子函数是一种在特定事件或时间点自动执行的回调函数。在Node-API模块的上下文中，清理钩子函数通常用于在环境或进程退出时执行资源清理任务。这是因为环境或进程退出时，操作系统可能不会立即回收所有资源，因此需要通过清理钩子函数来确保所有资源都被正确释放。\",\"13\":\"\",\"14\":\"以上这些基本概念是理解和使用Node-API接口注册环境清理钩子的基础，下面将介绍具体的接口和使用示例。\",\"15\":\"\",\"16\":\"## 场景和功能介绍\",\"17\":\"\",\"18\":\"以下Node-API接口用于注册和取消不同类型的清理钩子。他们的使用场景如下：\",\"19\":\"\"}",
      "修改建议": "该句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "以上基本概念是理解并使用Node-API接口注册环境清理钩子的基础。下面将介绍具体的接口和使用示例。",
      "触发条件": "当句子中存在冗余指示代词（如\"这些\"）且前文已明确指代对象，或使用逗号连接多个独立分句造成结构冗余时触发。\n\n识别模式：\n1. 存在冗余限定词：通过\"这些/那些+重复名词\"结构检测（如\"这些基本概念\"在前文已列具体概念后出现）\n2. 复合句式特征：单句包含≥2个逗号分隔的完整语义单元（如\"是...基础，下面将...\"构成两个独立语义）\n3. 动词连接优化：并列动词使用\"和\"连接而非更符合逻辑的\"并\"（\"理解和使用\"→\"理解并使用\"）"
    },
    {
      "defect_id": 541690,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"| napi_unwrap | 从ArkTS对象上获取之前绑定的Node-API模块对象实例。 |\",\"24\":\"| napi_remove_wrap | 从ArkTS对象上获取之前绑定的Node-API模块对象实例，并解除绑定。 |\",\"25\":\"\",\"26\":\"## 使用示例\",\"27\":\"\",\"28\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"29\":\"\",\"30\":\"### napi_new_instance\",\"31\":\"\",\"32\":\"通过给定的构造函数实例化一个对象，将这个对象返回ArkTS侧使用。\",\"33\":\"\"}",
      "修改建议": "句子较长，包含过多的修饰成分。",
      "更改后示例": "Node-API接口开发流程参考[使用Node-API实现跨语言交互](use-napi-process.md)，本文仅展示接口对应的C++和ArkTS代码。",
      "触发条件": "同一句子或相邻上下文中存在重复的名词短语（如\"开发流程\"重复），或使用冗余修饰词（如\"相关\"、\"进行\"）导致表达冗余时触发。\n\n识别模式：1) 检查名词短语是否在链接文本与上下文重复（如\"开发流程\"在方括号链接和主句中重复）；2) 识别冗余限定词（如\"相关代码\"可简化为\"代码\"）；3) 检测复杂动词结构（如\"进行展示\"可替换为\"展示\"）。"
    },
    {
      "defect_id": 541843,
      "sentence": "需要注意的是，napi_add_env_cleanup_hook接口并不支持对同一arg绑定多个回调。若出现env已销毁，但cleanup回调未被执行的情况。可以在启用ArkTS运行时[多线程检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)功能的前提下，查看hilog流水日志`AddCleanupHook Failed, data cannot register multiple times.`来查找发生注册失败的调用。",
      "reference_sentence": "",
      "line_num": 35,
      "context": "{\"30\":\"\",\"31\":\"### napi_add_env_cleanup_hook\",\"32\":\"\",\"33\":\"用于注册一个环境清理钩子函数，该函数将在环境退出时执行。这是确保资源在环境销毁前得到清理的重要机制。\",\"34\":\"\",\"35\":\"需要注意的是，napi_add_env_cleanup_hook接口并不支持对同一arg绑定多个回调。若出现env已销毁，但cleanup回调未被执行的情况。可以在启用ArkTS运行时[多线程检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)功能的前提下，查看hilog流水日志`AddCleanupHook Failed, data cannot register multiple times.`来查找发生注册失败的调用。\",\"36\":\"\",\"37\":\"### napi_remove_env_cleanup_hook\",\"38\":\"\",\"39\":\"用于取消之前注册的环境清理钩子函数。在某些情况下，需要在插件卸载或资源被重新分配时取消钩子函数。\",\"40\":\"\"}",
      "修改建议": "该句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "需要注意，napi_add_env_cleanup_hook接口不支持对同一arg绑定多个回调。若env已销毁但cleanup回调未执行，可以在启用ArkTS运行时[多线程检测](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/ide-multi-thread-check)功能后，查看hilog日志`AddCleanupHook Failed, data cannot register multiple times.`来查找注册失败的调用。",
      "触发条件": "当句子中存在重复性引导词（如“需要注意的是”）、冗余修饰语（如“发生注册失败的调用”中的“发生”）或可合并的从句结构（如多个逗号分隔的复杂分句）时触发。\n\n识别模式：\n1. **重复性引导词**：例如“需要注意的是”可简化为“注意”；\n2. **冗余修饰成分**：如“流水日志”中的“流水”无实际语义贡献；\n3. **复杂分句结构**：超过两个逗号分隔的从句，且存在可删除的连接词（如“若出现...的情况”可简化为“若...”）。"
    },
    {
      "defect_id": 542572,
      "sentence": "此处以在ArkTS/JS侧实现add()接口、在Native侧实现Add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。",
      "reference_sentence": "",
      "line_num": 12,
      "context": "{\"7\":\"- **ArkTS/JS侧**：实现C++方法的调用。代码比较简单，import一个对应的so库后，即可调用C++方法。\",\"8\":\"\",\"9\":\"- **Native侧**：.cpp文件，实现模块的注册。需要提供注册lib库的名称，并在注册回调方法中定义接口的映射关系，即Native方法及对应的JS/ArkTS接口名称等。\",\"10\":\"\",\"11\":\"\",\"12\":\"此处以在ArkTS/JS侧实现add()接口、在Native侧实现Add()接口，从而实现跨语言交互为例，呈现使用Node-API进行跨语言交互的流程。\",\"13\":\"\",\"14\":\"\",\"15\":\"## 创建Native C++工程\",\"16\":\"\",\"17\":\"- 在DevEco Studio中**New &gt; Create Project**，选择**Native C++**模板，点击**Next**，选择API版本，设置好工程名称，点击**Finish**，创建得到新工程。\"}",
      "修改建议": "该句子过长，包含多个逗号。",
      "更改后示例": "此处以在ArkTS/JS侧实现add()接口和在Native侧实现Add()接口为例，展示使用Node-API进行跨语言交互的流程。",
      "触发条件": "当句子包含连续逗号分隔的同类功能描述（如并列接口实现），且后接重复性目的状语（如\"从而实现...\"）时触发。\n\n识别模式：\n1. 结构特征：存在\"A实现X、B实现Y，从而达到Z目的\"的嵌套结构，其中Z目的在前文/上下文已隐含\n2. 冗余信号：出现\"从而\"+动词的补充说明，但其描述的功能已被主句动词（如\"呈现/展示\"）覆盖\n3. 长度特征：单句超过2个逗号分隔的复杂状语，且存在可合并的并列成分（如用\"和\"替代顿号）"
    },
    {
      "defect_id": 542622,
      "sentence": "部分常见错误用法已增加维测手段覆盖，详见[使用Node-API接口产生的异常日志/崩溃分析](use-napi-about-crash.md)。",
      "reference_sentence": "",
      "line_num": 223,
      "context": "{\"218\":\"\",\"219\":\"- Node-API接口只能在JS线程使用。\",\"220\":\"- Native接口入参env与特定JS线程绑定只能在创建时的线程使用。\",\"221\":\"- 使用Node-API接口创建的数据需在env完全销毁前进行释放，避免内存泄漏。此外，在napi_env销毁后访问/使用这些数据，可能会导致进程崩溃。\",\"222\":\"\",\"223\":\"部分常见错误用法已增加维测手段覆盖，详见[使用Node-API接口产生的异常日志/崩溃分析](use-napi-about-crash.md)。\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "常见错误用法已增加维测手段覆盖，详见[使用Node-API接口产生的异常日志/崩溃分析](use-napi-about-crash.md)。",
      "触发条件": "当句子中出现\"部分\"、\"某些\"等无具体数据支撑的限定词修饰集合名词(如\"常见错误用法\")，且删除该限定词不影响语义完整性时触发。\n\n识别模式：\n1. 存在限定词+集合名词结构(\"部分常见错误用法\")\n2. 限定词缺乏量化依据(如无百分比/具体数量说明)\n3. 删除限定词后语义保持完整且更简洁(\"常见错误用法\")"
    },
    {
      "defect_id": 542014,
      "sentence": "在Node-API中，通过提供与Date对象交互的函数，Node-API模块能够更紧密地与ArkTS环境集成，执行更复杂的日期和时间相关操作。",
      "reference_sentence": "",
      "line_num": 13,
      "context": "{\"8\":\"\",\"9\":\"在Node-API的中，ArkTS Date对象的数据表示从UTC时间1970年1月1日0时0分0秒起至现在的总毫秒数。\",\"10\":\"\",\"11\":\"ArkTS Date对象提供了一种在ArkTS中表示和操作日期和时间的方式。它们允许您创建表示特定时刻的日期对象，执行各种日期和时间相关的计算（如添加或减去时间间隔），以及格式化日期为字符串以供显示。\",\"12\":\"\",\"13\":\"在Node-API中，通过提供与Date对象交互的函数，Node-API模块能够更紧密地与ArkTS环境集成，执行更复杂的日期和时间相关操作。\",\"14\":\"\",\"15\":\"## 场景和功能介绍\",\"16\":\"\",\"17\":\"以下Node-API函数通常在开发Node-API模块中与ArkTS的Date对象进行交互时使用，来处理和操作日期数据。以下是一些可能的使用场景：\",\"18\":\"| 接口 | 描述 |\"}",
      "修改建议": "语句过长，包含不必要的修饰成分。",
      "更改后示例": "在Node-API中，通过与Date对象交互的函数，Node-API模块能够与ArkTS环境更紧密地集成，执行复杂的日期和时间操作。",
      "触发条件": "当句子中存在冗余的介词结构（如\"通过提供\"→\"通过\"）或重复性修饰语（如\"更复杂...相关操作\"→\"复杂操作\"），且删除冗余成分后不影响核心语义时触发。\n\n识别模式：  \n1. **冗余介词结构**：检测\"通过+动词\"类组合（如\"通过提供\"），若动词与上下文语义重复可简化为单一介词  \n2. **过度修饰**：识别连续强化程度的副词（如\"更紧密地...更复杂的\"）或冗余限定词（如\"相关\"），当上下文未提供比较基准时需删除。"
    },
    {
      "defect_id": 541901,
      "sentence": "非阻塞式的运行底层事件循环，尝试去处理一个任务，处理完之后退出事件循环；如果事件循环中没有任务，立刻退出事件循环。",
      "reference_sentence": "",
      "line_num": 232,
      "context": "{\"227\":\"```\",\"228\":\"\",\"229\":\"| 事件循环运行模式 | 解释说明 |\",\"230\":\"| -------- | -------- |\",\"231\":\"| napi_event_mode_default | 阻塞式的运行底层事件循环，直到循环中没有或活跃的uv_handle句柄时退出事件循环。 |\",\"232\":\"| napi_event_mode_nowait | 非阻塞式的运行底层事件循环，尝试去处理一个任务，处理完之后退出事件循环；如果事件循环中没有任务，立刻退出事件循环。 |\",\"233\":\"\",\"234\":\"### 线程安全任务优先级\",\"235\":\"\",\"236\":\"napi提供了线程安全任务的优先级, 底层任务队列中的任务会根据其优先级被依次执行, 优先级的定义如下：\",\"237\":\"\"}",
      "修改建议": "句子中的逗号数量超过5个，且包含不必要的修饰成分。",
      "更改后示例": "非阻塞式运行底层事件循环，尝试处理一个任务后退出；如果事件循环中没有任务，立即退出。",
      "触发条件": "句子包含超过5个逗号且存在重复性短语（如“退出事件循环”连续重复）或冗余修饰词（如“的”“去”“之后”等非必要虚词）。"
    },
    {
      "defect_id": 541533,
      "sentence": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。",
      "reference_sentence": "",
      "line_num": 31,
      "context": "{\"26\":\"| napi_create_int64 | 将Node-API模块中的int64_t类型转换为ArkTS环境中number类型。 |\",\"27\":\"| napi_create_double | 将Node-API模块中的double类型转换为ArkTS环境中number类型。 |\",\"28\":\"\",\"29\":\"## 使用示例\",\"30\":\"\",\"31\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"32\":\"\",\"33\":\"### napi_get_value_uint32\",\"34\":\"\",\"35\":\"用于从ArkTS环境中获取32位无符号整数值。\",\"36\":\"\"}",
      "修改建议": "句子过长，使用了不必要的修饰成分。",
      "更改后示例": "Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)。本文仅展示接口对应的C++及ArkTS代码。",
      "触发条件": "句子中存在冗余的动词结构（如\"进行展示\"）或重复限定词（如\"相关\"与\"对应\"叠加使用），导致表达臃肿时触发。\n\n识别模式：\n1. 检测\"进行/作/做出 + 动词化名词\"结构（如\"进行展示\"→应简化为\"展示\"）\n2. 识别重复限定修饰（如\"相关代码\"与\"对应代码\"同时出现）\n3. 判断介词短语嵌套层级（原句\"对...进行\"结构包含双重介词框架）"
    },
    {
      "defect_id": 541644,
      "sentence": "一个结构体，在调用Node-API接口不成功时存储了较为详细的错误信息。",
      "reference_sentence": "",
      "line_num": 42,
      "context": "{\"37\":\"} napi_status;\",\"38\":\"```\",\"39\":\"\",\"40\":\"### napi_extended_error_info\",\"41\":\"\",\"42\":\"一个结构体，在调用Node-API接口不成功时存储了较为详细的错误信息。\",\"43\":\"\",\"44\":\"```c\",\"45\":\"typedef struct {\",\"46\":\"    const char *error_message;\",\"47\":\"    void *engine_reserved;\"}",
      "修改建议": "含有不必要的修饰成分，且句式结构较为冗长。",
      "更改后示例": "一个结构体，用于存储调用Node-API接口失败时的错误信息。",
      "触发条件": "当句子包含冗余的时间状语从句（如\"在...时\"）或重复性修饰成分（如\"较为详细的\"），且可通过简化状语结构（改为\"用于/当...时\"）或删除冗余形容词来提升简洁性时触发。\n\n识别模式：  \n1. 存在\"在...时\"+动词的状语结构，可替换为\"当/用于...\"+名词短语  \n2. 含有非必要程度副词（较为/非常/十分）或重复性描述（错误信息本身隐含\"详细\"属性）  \n3. 动词短语（存储了）可优化为功能指向性表达（用于存储）  \n4. 双重否定结构（如\"不成功\"）可被肯定式否定词（失败）替代"
    },
    {
      "defect_id": 543254,
      "sentence": "引擎实例是一个独立运行环境，JS对象创建访问等操作必须在同一个引擎实例中进行。若在不同引擎实例中操作同一个对象，可能会引发程序崩溃。引擎实例在接口中体现为napi_env。",
      "reference_sentence": "",
      "line_num": 88,
      "context": "{\"83\":\"\",\"84\":\"## 上下文敏感\",\"85\":\"\",\"86\":\"**【规则】** 多引擎实例场景下，禁止通过Node-API跨引擎实例访问JS对象。\",\"87\":\"\",\"88\":\"引擎实例是一个独立运行环境，JS对象创建访问等操作必须在同一个引擎实例中进行。若在不同引擎实例中操作同一个对象，可能会引发程序崩溃。引擎实例在接口中体现为napi_env。\",\"89\":\"\",\"90\":\"**错误示例**：\",\"91\":\"\",\"92\":\"```cpp\",\"93\":\"// 线程1执行，在env1创建string对象，值为\\\"bar\\\"、\"}",
      "修改建议": "句子过长，包含多个逗号，且包含不必要的修饰成分。",
      "更改后示例": "引擎实例是独立的运行环境，JS对象的创建和访问必须在同一个引擎实例中进行。不同引擎实例中操作同一对象可能会引发程序崩溃。引擎实例在接口中表示为napi_env。",
      "触发条件": "句子包含多个逗号分隔的复合结构，且存在重复性技术概念描述（如连续解释同一术语）或冗余修饰词（如\"若在\"\"等操作\"\"体现为\"等非必要引导词）。"
    },
    {
      "defect_id": 544259,
      "sentence": "使用window类的createWindow方法创建窗口，窗口类型设置为window.WindowType.TYPE_FLOAT。由于本例通过按钮的点击事件控制悬浮窗的创建和销毁，为了便于操作，本例将创建和销毁悬浮窗的操作写在自定义的方法中，以便绑定到按钮的点击时间中。",
      "reference_sentence": "",
      "line_num": 48,
      "context": "{\"43\":\"      }\",\"44\":\"    }\",\"45\":\"    ```\",\"46\":\"2. 创建悬浮窗。\",\"47\":\"\",\"48\":\"    使用window类的createWindow方法创建窗口，窗口类型设置为window.WindowType.TYPE_FLOAT。由于本例通过按钮的点击事件控制悬浮窗的创建和销毁，为了便于操作，本例将创建和销毁悬浮窗的操作写在自定义的方法中，以便绑定到按钮的点击时间中。\",\"49\":\"    创建悬浮窗的操作在自定义方法createFloatWindow中实现。\",\"50\":\"    具体代码如下：\",\"51\":\"    ```ts\",\"52\":\"    // 引入window类\",\"53\":\"    import window from '@ohos.window';\"}",
      "修改建议": "句子过长，包含过多的修饰成分，不符合简洁表达的要求。",
      "更改后示例": "使用window类的createWindow方法创建窗口，窗口类型设置为window.WindowType.TYPE_FLOAT。本例通过按钮的点击事件控制悬浮窗的创建和销毁，将相关操作写在自定义方法中，以便绑定到点击事件。",
      "触发条件": "当句子中出现重复主语（如连续使用\"本例\"）、冗余因果/目的状语结构（如\"由于...为了...\"），或存在可合并的动词短语（如\"写在...中以便绑定到...\"），导致信息密度降低时触发。\n\n识别模式：\n1. 重复指代检测：同一句子中重复出现相同主语（如两个\"本例\"）\n2. 复合状语识别：包含因果关系+目的关系的嵌套状语结构\n3. 动词冗余分析：多个动词短语表达同一操作链（如\"创建和销毁悬浮窗的操作写在...中以便绑定到...\"可简化为\"将相关操作写在...中\"）"
    },
    {
      "defect_id": 544407,
      "sentence": "3.在注册闪控球回调操作前，判断回调是否已注册。",
      "reference_sentence": "",
      "line_num": 375,
      "context": "{\"370\":\"\",\"371\":\"1.在启动操作前，检查闪控球是否已启动。\",\"372\":\"\",\"373\":\"2.在停止操作前，检查闪控球是否已停止。\",\"374\":\"\",\"375\":\"3.在注册闪控球回调操作前，判断回调是否已注册。\",\"376\":\"\",\"377\":\"## 1300023 闪控球内部错误\",\"378\":\"\",\"379\":\"**错误信息**\",\"380\":\"\"}",
      "修改建议": "句子中包含不必要的修饰成分。",
      "更改后示例": "3.在注册闪控球回调操作前，确保回调未注册。",
      "触发条件": "当句子中存在对已隐含状态的重复判断（如\"在X操作前判断是否已X\"），或使用\"检查/判断\"等动词描述本应直接确保的前置条件时触发。\n\n识别模式：检查\"在[动作A]前，[动作B]是否已[动作A]\"的结构，或出现\"检查/判断...[相同/相反状态]\"的冗余表达，应替换为\"确保...[所需状态]\"的简洁表达。"
    },
    {
      "defect_id": 544258,
      "sentence": "创建悬浮窗需要先申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，要在module.json5文件的requestPermissions对象中进行配置，如下：",
      "reference_sentence": "",
      "line_num": 28,
      "context": "{\"23\":\"\",\"24\":\"## 开发步骤\",\"25\":\"由于本例重点讲解悬浮窗的创建和使用，所以开发步骤会着重讲解相关实现，不相关的内容不做介绍，全量代码可参考完整代码章节。\",\"26\":\"1. 申请权限。\",\"27\":\"\",\"28\":\"    创建悬浮窗需要先申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，要在module.json5文件的requestPermissions对象中进行配置，如下：\",\"29\":\"    ```json\",\"30\":\"    {\",\"31\":\"      \\\"module\\\": {\",\"32\":\"        \\\"requestPermissions\\\":[\",\"33\":\"          {\"}",
      "修改建议": "句子过长，包含过多的修饰成分，不符合简洁表达的要求。",
      "更改后示例": "创建悬浮窗需要申请ohos.permission.SYSTEM_FLOAT_WINDOW权限，并在module.json5文件的requestPermissions对象中配置，如下：",
      "触发条件": "句子中存在多个动作步骤描述时，使用重复或冗余的连词（如“先”、“要”）或动词短语（如“申请”、“配置”），导致结构松散、信息重复。  \n\n识别模式：  \n1. **并列动作冗余**：连续动作间出现“先...，要...”等冗余引导词，且无必要的时间顺序强调。  \n2. **重复动词结构**：同一语义的动作被拆分描述（如“申请权限”与“在...中配置权限”），可通过合并简化（如“申请并配置权限”）。"
    },
    {
      "defect_id": 543288,
      "sentence": "napi_object_freeze等同于Object.freeze语义，freeze后对象的所有属性都不可能以任何方式被修改；napi_object_seal等同于Object.seal语义，对象不可增删属性。两者的主要区别是，freeze不能改属性的值，seal还可以改属性的值。",
      "reference_sentence": "",
      "line_num": 480,
      "context": "{\"475\":\"\",\"476\":\"## 其他\",\"477\":\"\",\"478\":\"**【建议】** 合理使用napi_object_freeze和napi_object_seal来控制对象以及对象属性的可变性。\",\"479\":\"\",\"480\":\"napi_object_freeze等同于Object.freeze语义，freeze后对象的所有属性都不可能以任何方式被修改；napi_object_seal等同于Object.seal语义，对象不可增删属性。两者的主要区别是，freeze不能改属性的值，seal还可以改属性的值。\",\"481\":\"\",\"482\":\"开发者使用以上语义时，需确保约束条件是自己需要的，一旦违背以上语义严格模式下就会抛出Error（默认严格模式）。\",\"483\":\"\",\"484\":\"## 参考文档\",\"485\":\"\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "napi_object_freeze等同于Object.freeze，冻结后对象的所有属性不可修改；napi_object_seal等同于Object.seal，对象不可增删属性。主要区别是，freeze禁止修改属性值，seal则允许修改。",
      "触发条件": "句子中出现可被更简洁词汇替代的冗长短语（如\"不可能以任何方式被修改\"→\"不可修改\"），或存在重复性语义表达（如\"等同于...语义\"中\"语义\"冗余）。通过识别\"不可能/可以...任何方式\"\"以及\"等同类修饰词+重复术语\"模式判定。"
    },
    {
      "defect_id": 548464,
      "sentence": "点击Text组件，触发`age`自增，触发`onChange`的监听回调函数。打印日志如下。",
      "reference_sentence": "",
      "line_num": 815,
      "context": "{\"810\":\"|130002|monitorCallbacks不是function，或者是匿名function。|\",\"811\":\"\",\"812\":\"**示例：**\",\"813\":\"在下面的示例中：\",\"814\":\"1. 在`ObservedClass`的构造方法里，添加对`age`属性的同步监听回调`onChange`。\",\"815\":\"2. 点击Text组件，触发`age`自增，触发`onChange`的监听回调函数。打印日志如下。\",\"816\":\"```\",\"817\":\"ObservedClass property age change from 10 to 11\",\"818\":\"```\",\"819\":\"3. 点击`clear monitor`，删除`this.observedClass`中`age`的监听函数`onChange`。\",\"820\":\"4. 再次点击Text组件，触发`age`自增，`onChange`不会被触发监听回调。\"}",
      "修改建议": "句子包含不必要的修饰成分，且逗号数超过5个。",
      "更改后示例": "点击Text组件，触发`age`自增，`onChange`的监听回调函数被触发。打印日志如下。",
      "触发条件": "句子中出现连续重复动词导致语义冗余（如\"触发...触发...\"），或单句逗号数量超过5个造成结构臃肿时触发。\n\n识别模式：1) 检测连续相同/近义动词构成的连动句式（动词A...动词A...）；2) 统计逗号分隔的句子成分数量，超过5个片段时判定为结构冗余。需同时检查是否存在可合并/简化的修饰成分。"
    },
    {
      "defect_id": 543060,
      "sentence": "用于获取最后一次发生的错误信息，包括错误码、错误消息以及错误进栈信息，即使存在挂起的ArkTS异常，也可以调用此API。",
      "reference_sentence": "",
      "line_num": 38,
      "context": "{\"33\":\"\",\"34\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"35\":\"\",\"36\":\"### napi_get_last_error_info\",\"37\":\"\",\"38\":\"用于获取最后一次发生的错误信息，包括错误码、错误消息以及错误进栈信息，即使存在挂起的ArkTS异常，也可以调用此API。\",\"39\":\"\",\"40\":\"cpp部分代码\",\"41\":\"\",\"42\":\"```cpp\",\"43\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句子较长，逗号数超过5个，且包含不必要的修饰成分。",
      "更改后示例": "用于获取最后一次发生的错误信息，包括错误码、错误消息和错误进栈信息。即使存在挂起的ArkTS异常，也可以调用此API。",
      "触发条件": "当句子包含超过5个逗号且存在多个并列成分使用不同连词（如\"以及\"和\"和\"混用）时，或出现重复性修饰结构导致语义冗余时触发。\n\n识别模式：\n1. 标点密度检测：逗号数量≥5且句子长度≥60字符\n2. 并列结构异常：同一组并列成分中混用不同连词（如\"以及\"与\"和\"交替出现）\n3. 语义重复验证：通过依存句法分析检测修饰语与核心成分是否存在语义重叠（如\"错误进栈信息\"与\"错误信息\"的包含关系）"
    },
    {
      "defect_id": 548466,
      "sentence": "再次点击Text组件，触发`age`自增，`onChange`不会被触发监听回调。",
      "reference_sentence": "",
      "line_num": 820,
      "context": "{\"815\":\"2. 点击Text组件，触发`age`自增，触发`onChange`的监听回调函数。打印日志如下。\",\"816\":\"```\",\"817\":\"ObservedClass property age change from 10 to 11\",\"818\":\"```\",\"819\":\"3. 点击`clear monitor`，删除`this.observedClass`中`age`的监听函数`onChange`。\",\"820\":\"4. 再次点击Text组件，触发`age`自增，`onChange`不会被触发监听回调。\",\"821\":\"\",\"822\":\"```ts\",\"823\":\"import { UIUtils } from '@kit.ArkUI';\",\"824\":\"\",\"825\":\"@ObservedV2\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "再次点击Text组件，触发`age`自增，`onChange`不会被触发。",
      "触发条件": "当句子中存在与上下文重复的修饰成分（如已被前文明确定义的函数类型或监听机制），或动词与宾语搭配存在冗余信息（如\"触发\"已隐含\"监听回调\"的语境）时触发。\n\n具体识别模式：\n1. 动词+宾语结构中宾语包含冗余限定词（如\"触发监听回调\"中\"监听\"在前文已明确）\n2. 上下文存在相同语义的先行表述（如步骤2已说明onChange是监听回调函数，步骤4重复出现\"监听回调\"即构成冗余）"
    },
    {
      "defect_id": 548461,
      "sentence": "点击Text组件，将`name`改为`Jack`和`Jane`,触发两次`onChange`的监听回调函数。打印日志如下。",
      "reference_sentence": "",
      "line_num": 728,
      "context": "{\"723\":\"|130002|monitorCallbacks不是function，或者是匿名function。|\",\"724\":\"\",\"725\":\"**示例：**\",\"726\":\"在下面的示例中：\",\"727\":\"1. 在`ObservedClass`的构造方法里，添加对`name`属性的同步监听回调`onChange`。\",\"728\":\"2. 点击Text组件，将`name`改为`Jack`和`Jane`,触发两次`onChange`的监听回调函数。打印日志如下。\",\"729\":\"```\",\"730\":\"ObservedClass property name change from Tom to Jack\",\"731\":\"ObservedClass property name change from Jack to Jane\",\"732\":\"```\",\"733\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分，且逗号数超过5个。",
      "更改后示例": "点击Text组件，将`name`改为`Jack`和`Jane`，触发两次`onChange`回调，打印日志如下。",
      "触发条件": "句子中包含可删除的冗余修饰成分（如重复性术语或上下文已隐含的限定词），且因多层级修饰导致逗号数量超过5个。"
    },
    {
      "defect_id": 548462,
      "sentence": "在下面的示例中：",
      "reference_sentence": "",
      "line_num": 726,
      "context": "{\"721\":\"|130000|target不是\\\\@ObservedV2装饰的class且该class至少有一个\\\\@Trace装饰的变量，或者不是\\\\@ComponentV2装饰的自定义组件的实例。|\",\"722\":\"|130001|path不是string或者是数组。|\",\"723\":\"|130002|monitorCallbacks不是function，或者是匿名function。|\",\"724\":\"\",\"725\":\"**示例：**\",\"726\":\"在下面的示例中：\",\"727\":\"1. 在`ObservedClass`的构造方法里，添加对`name`属性的同步监听回调`onChange`。\",\"728\":\"2. 点击Text组件，将`name`改为`Jack`和`Jane`,触发两次`onChange`的监听回调函数。打印日志如下。\",\"729\":\"```\",\"730\":\"ObservedClass property name change from Tom to Jack\",\"731\":\"ObservedClass property name change from Jack to Jane\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "下面的示例：",
      "触发条件": "句子中存在以\"在...中\"结构引入示例或说明，且介词框架可省略而不影响语义清晰度；上下文已明确指示后续内容类型（如示例、步骤），无需额外方位状语。  \n\n识别模式：检测到\"在下面的示例中\"、\"在以下步骤中\"等介词短语引导说明性内容时，若删除\"在\"和\"中\"后语句仍完整且表意等价（如变为\"下面的示例：\"），则判定为冗余修饰。"
    },
    {
      "defect_id": 548465,
      "sentence": "点击`clear monitor`，删除`this.observedClass`中`age`的监听函数`onChange`。",
      "reference_sentence": "",
      "line_num": 819,
      "context": "{\"814\":\"1. 在`ObservedClass`的构造方法里，添加对`age`属性的同步监听回调`onChange`。\",\"815\":\"2. 点击Text组件，触发`age`自增，触发`onChange`的监听回调函数。打印日志如下。\",\"816\":\"```\",\"817\":\"ObservedClass property age change from 10 to 11\",\"818\":\"```\",\"819\":\"3. 点击`clear monitor`，删除`this.observedClass`中`age`的监听函数`onChange`。\",\"820\":\"4. 再次点击Text组件，触发`age`自增，`onChange`不会被触发监听回调。\",\"821\":\"\",\"822\":\"```ts\",\"823\":\"import { UIUtils } from '@kit.ArkUI';\",\"824\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "点击`clear monitor`，删除`age`的监听函数`onChange`。",
      "触发条件": "当前句中的修饰成分（如所属对象、位置）已在前文或上下文中明确提及，且重复出现未提供新信息时触发冗余表达规则。"
    },
    {
      "defect_id": 551536,
      "sentence": "这个函数用于在给定的Node-API环境中依据一个无符号的64位整数创建一个ArkTS的BigInt对象。",
      "reference_sentence": "",
      "line_num": 72,
      "context": "{\"67\":\"```\",\"68\":\"<!-- @[ark_napi_create_bigint_int64](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIBigint/entry/src/main/ets/pages/Index.ets) -->\",\"69\":\"\",\"70\":\"### napi_create_bigint_uint64\",\"71\":\"\",\"72\":\"这个函数用于在给定的Node-API环境中依据一个无符号的64位整数创建一个ArkTS的BigInt对象。\",\"73\":\"\",\"74\":\"cpp部分代码\",\"75\":\"\",\"76\":\"```cpp\",\"77\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "该句子包含多个修饰成分，可以简化。",
      "更改后示例": "这个函数在给定的Node-API环境中，根据无符号64位整数创建一个ArkTS的BigInt对象。",
      "触发条件": "当句子中存在多个连续修饰成分（如介词短语、依据类表述）导致语义重复或结构冗余时触发，例如\"在...环境中依据...\"这类双重限定结构。"
    },
    {
      "defect_id": 551265,
      "sentence": "对于以索引值为键的object，可以使用napi_set_element来设置属性值。",
      "reference_sentence": "",
      "line_num": 243,
      "context": "{\"238\":\"<!-- @[ark_napi_is_array](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"239\":\"\",\"240\":\"### napi_set_element\",\"241\":\"\",\"242\":\"用于在ArkTS数组中设置指定索引位置的元素。\",\"243\":\"对于以索引值为键的object，可以使用napi_set_element来设置属性值。\",\"244\":\"\",\"245\":\"cpp部分代码\",\"246\":\"\",\"247\":\"```cpp\",\"248\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句子较长，包含不必要的修饰成分。",
      "更改后示例": "对于索引值为键的object，可以使用napi_set_element设置属性值。",
      "触发条件": "当句子中出现由“来”或类似介词引导的冗余动词短语修饰成分（如“来设置属性值”），且删除后不影响语义完整性时触发。识别模式为检测“动词+来+动词”结构或冗余介词短语，如“可以使用...来设置”可简化为“可以使用...设置”。"
    },
    {
      "defect_id": 551306,
      "sentence": "获取给定DataView的各种属性。",
      "reference_sentence": "",
      "line_num": 877,
      "context": "{\"872\":\"```\",\"873\":\"<!-- @[ark_napi_is_data_view](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIArray/entry/src/main/ets/pages/Index.ets) -->\",\"874\":\"\",\"875\":\"### napi_get_dataview_info\",\"876\":\"\",\"877\":\"获取给定DataView的各种属性。\",\"878\":\"\",\"879\":\"cpp部分代码\",\"880\":\"\",\"881\":\"```cpp\",\"882\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "获取给定DataView的属性。",
      "触发条件": "句子中存在修饰名词的冗余限定词（如“各种”“所有”等），且该限定词未提供额外信息或与名词含义重复时触发。\n\n具体识别模式：  \n1. **冗余量词检测**：当名词前出现“各种”“所有”“多个”等泛指性量词，且名词本身隐含复数或集合属性（如“属性”“参数”）时；  \n2. **语义重复验证**：若删除量词后句意未改变（如“各种属性”→“属性”仍完整表达原意），则判定为冗余。"
    },
    {
      "defect_id": 549135,
      "sentence": "命令1：递归打印出所有自定义组件和状态变量信息",
      "reference_sentence": "",
      "line_num": 85,
      "context": "{\"80\":\"\",\"81\":\"步骤3：执行状态变量dump信息：\",\"82\":\"\",\"83\":\"假定激活的窗口是62，执行如下命令:\",\"84\":\"\",\"85\":\"-命令1：递归打印出所有自定义组件和状态变量信息 \",\"86\":\"\",\"87\":\" \\\"hdc shell hidumper -s WindowManagerService -a '-w 62 -jsdump -dumpAll -r'\\\"\",\"88\":\"\",\"89\":\"执行上述命令，打印出如下信息：\",\"90\":\"```ts\"}",
      "修改建议": "句子缺少主谓结构，建议补充。",
      "更改后示例": "命令1：递归打印所有自定义组件和状态变量信息",
      "触发条件": "动词后存在冗余趋向补语（如“出”“下来”等），且删除补语后句子语义完整度未受损。例如“打印出”中的“出”与核心动词“打印”形成冗余，且删除后“打印”仍能独立表达完整动作。"
    },
    {
      "defect_id": 551535,
      "sentence": "这个函数用于在给定的Node-API环境中依据一个带有符号的64位整数创建一个ArkTS的BigInt对象。",
      "reference_sentence": "",
      "line_num": 33,
      "context": "{\"28\":\"\",\"29\":\"Node-API接口开发流程参考[使用Node-API实现跨语言交互开发流程](use-napi-process.md)，本文仅对接口对应C++及ArkTS相关代码进行展示。\",\"30\":\"\",\"31\":\"### napi_create_bigint_int64\",\"32\":\"\",\"33\":\"这个函数用于在给定的Node-API环境中依据一个带有符号的64位整数创建一个ArkTS的BigInt对象。\",\"34\":\"\",\"35\":\"cpp部分代码\",\"36\":\"\",\"37\":\"```cpp\",\"38\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "该句子包含多个修饰成分，可以简化。",
      "更改后示例": "该函数在给定的Node-API环境中，根据带符号的64位整数创建一个ArkTS的BigInt对象。",
      "触发条件": "当句子中连续出现两个及以上相同/相似功能的介词结构（如\"在...中依据...\"），或存在可合并的重复修饰语（如\"带有符号的\"简化为\"带符号的\"）时触发。  \n\n识别模式：通过检测连续介词短语（如\"在...中依据...\"）和冗余修饰词（如\"带有\"vs\"带\"），判断是否存在语义重复或结构臃肿，优先处理技术文档中高频出现的\"用于/根据/依据/通过\"等多介词叠加句式。"
    },
    {
      "defect_id": 551551,
      "sentence": "用于从传入的参数中提取无符号64位整数的BigInt数据，以供后续处理。",
      "reference_sentence": "",
      "line_num": 212,
      "context": "{\"207\":\"```\",\"208\":\"<!-- @[ark_napi_get_value_bigint_int64](https://gitee.com/openharmony/applications_app_samples/blob/master/code/DocsSample/ArkTS/NodeAPI/NodeAPIUse/NodeAPIBigint/entry/src/main/ets/pages/Index.ets) -->\",\"209\":\"\",\"210\":\"### napi_get_value_bigint_uint64\",\"211\":\"\",\"212\":\"用于从传入的参数中提取无符号64位整数的BigInt数据，以供后续处理。\",\"213\":\"\",\"214\":\"cpp部分代码\",\"215\":\"\",\"216\":\"```cpp\",\"217\":\"#include \\\"napi/native_api.h\\\"\"}",
      "修改建议": "句子较长，包含多个逗号，且存在冗余描述。",
      "更改后示例": "用于从传入参数中提取无符号64位整数的BigInt数据，供后续处理。",
      "触发条件": "当句子包含冗余介词（如\"以\"、\"的\"）导致结构冗余，且存在多个逗号分隔的短句时触发。具体表现为\"X的Y中\"可简化为\"XY中\"、\"以供\"可简化为\"供\"的结构冗余。"
    },
    {
      "defect_id": 553660,
      "sentence": "- ArkTS1.1全局自定义构建函数的参数最多不超过10个。",
      "reference_sentence": "",
      "line_num": 27,
      "context": "{\"22\":\"\",\"23\":\"- 遵循[语言互操作](../quick-start/arkts-interop-overview.md#交互基本原则)的基本规范。\",\"24\":\"\",\"25\":\"- 遵循[ArkTS1.1自定义构建函数参数传递规则](../quick-start/arkts-builder.md#参数传递规则)\",\"26\":\"\",\"27\":\"- ArkTS1.1全局自定义构建函数的参数最多不超过10个。\",\"28\":\"\",\"29\":\"## 开发场景\",\"30\":\"\",\"31\":\"### 在ArkTS1.2引用ArkTS1.1中的全局自定义构建函数显示UI\",\"32\":\"\"}",
      "修改建议": "句子包含不必要的修饰成分。",
      "更改后示例": "- 全局自定义构建函数的参数最多10个。",
      "触发条件": "当句子中同时存在双重否定或重复限定词（如\"最多不超过\"）时，或包含上下文已明确的不必要修饰成分（如版本前缀）时触发。识别模式需检测\"最多+否定词\"结构（如\"不超过\"）或与上下文重复的冗余修饰语。"
    },
    {
      "defect_id": 552562,
      "sentence": "检查传入的会话ID，确保其取值正确。",
      "reference_sentence": "",
      "line_num": 173,
      "context": "{\"168\":\"\",\"169\":\"传入的会话ID不存在。\",\"170\":\"\",\"171\":\"**处理步骤**\",\"172\":\"\",\"173\":\"检查传入的会话ID，确保其取值正确。\",\"174\":\"<!--DelEnd-->\",\"175\":\"\",\"176\":\"## 5411001 解析或链接服务端地址错误\",\"177\":\"\",\"178\":\"**错误信息**\"}",
      "修改建议": "句子结构复杂，包含不必要的修饰成分。",
      "更改后示例": "检查传入的会话ID，确保其正确。",
      "触发条件": "当名词性修饰语（如\"取值\"）与后续形容词（如\"正确\"）存在语义重叠，或动词短语隐含被修饰属性的核心含义时触发。识别模式为\"名词+形容词\"结构中名词仅重复表达形容词已涵盖的属性特征（如\"取值正确\"→\"正确\"）。"
    },
    {
      "defect_id": 557049,
      "sentence": "由于ArkTS支持异步操作，阻塞锁容易导致死锁，因此ArkTS仅支持异步锁。",
      "reference_sentence": "",
      "line_num": 62,
      "context": "{\"57\":\"\",\"58\":\"## ArkTSUtils.locks\",\"59\":\"\",\"60\":\"为了解决多并发实例间的数据竞争问题，ArkTS语言基础库引入了异步锁能力。AsyncLock对象支持跨并发实例引用传递，提升开发效率。\",\"61\":\"\",\"62\":\"由于ArkTS支持异步操作，阻塞锁容易导致死锁，因此ArkTS仅支持异步锁。\",\"63\":\"\",\"64\":\"使用异步锁的方法需要标记为async，调用方需要await修饰调用，才能保证时序正确。因此会导致外层调用函数全部标记成async。\",\"65\":\"\",\"66\":\"### AsyncLockCallback\",\"67\":\"\"}",
      "修改建议": "句子包含多个逗号，可以拆分成两个句子。",
      "更改后示例": "由于ArkTS支持异步操作，阻塞锁容易导致死锁。因此，ArkTS仅支持异步锁。",
      "触发条件": "句子中存在由多个逗号连接的独立逻辑分句（特别是包含因果关系词如\"因此\"），且合并表达导致结构臃肿或可读性下降时触发。识别模式为：1个主句+2个及以上逗号分隔的完整语义单元（如\"由于A，B导致C，因此D\"的四段式结构）。"
    },
    {
      "defect_id": 557096,
      "sentence": "为支持将JSON字符串解析为共享数据，即[Sendable支持的数据类型](../../arkts-utils/arkts-sendable.md#sendable支持的数据类型)，ArkTS语言基础库新增了ASON工具。ASON工具支持解析JSON字符串并生成共享数据，用于跨并发实例引用传递，同时也支持将共享数据转换为JSON字符串。",
      "reference_sentence": "",
      "line_num": 667,
      "context": "{\"662\":\"conditionVariable.notifyOne();\",\"663\":\"```\",\"664\":\"\",\"665\":\"## ArkTSUtils.ASON\",\"666\":\"\",\"667\":\"为支持将JSON字符串解析为共享数据，即[Sendable支持的数据类型](../../arkts-utils/arkts-sendable.md#sendable支持的数据类型)，ArkTS语言基础库新增了ASON工具。ASON工具支持解析JSON字符串并生成共享数据，用于跨并发实例引用传递，同时也支持将共享数据转换为JSON字符串。\",\"668\":\"\",\"669\":\"### ISendable\",\"670\":\"\",\"671\":\"type ISendable = lang.ISendable\",\"672\":\"\"}",
      "修改建议": "句子过长，包含多个逗号。",
      "更改后示例": "为支持将JSON字符串解析为共享数据，即[Sendable支持的数据类型](../../arkts-utils/arkts-sendable.md#sendable支持的数据类型)，ArkTS语言基础库新增了ASON工具。ASON工具支持解析JSON字符串生成共享数据，用于跨并发实例引用传递，并支持将共享数据转换为JSON字符串。",
      "触发条件": "当句子包含超过两个由逗号或连词连接的并列结构，且存在重复连接词（如\"并\"和\"同时\"）时；或单句连续使用多个语义重复的动词短语（如\"支持解析...并生成...\"与\"同时也支持...\"）时。"
    },
    {
      "defect_id": 557128,
      "sentence": "返回当前缓冲区中所有值的列表，按从最近访问到最少访问的顺序排列。",
      "reference_sentence": "",
      "line_num": 1306,
      "context": "{\"1301\":\"\",\"1302\":\"**返回值：**\",\"1303\":\"\",\"1304\":\"| 类型      | 说明                                                         |\",\"1305\":\"| --------- | ------------------------------------------------------------ |\",\"1306\":\"| V&nbsp;[] | 返回当前缓冲区中所有值的列表，按从最近访问到最少访问的顺序排列。 |\",\"1307\":\"\",\"1308\":\"**示例：**\",\"1309\":\"\",\"1310\":\"```ts\",\"1311\":\"let pro = new ArkTSUtils.SendableLruCache<number|string,number|string>();\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "返回当前缓冲区中所有值的列表，按访问顺序排列。",
      "触发条件": "当句子中存在通过逗号连接的多个修饰成分，且存在可用更简洁术语替代的冗余描述（如\"从最近访问到最少访问的顺序\"→\"访问顺序\"）时触发；或当上下文已隐含顺序方向（如LRU缓存机制默认按访问时间排序）时仍显式重复说明。"
    },
    {
      "defect_id": 557064,
      "sentence": "包含每个锁的具体状态信息，如锁的名称、锁定状态和持有者信息的异步锁状态数组。",
      "reference_sentence": "",
      "line_num": 243,
      "context": "{\"238\":\"\",\"239\":\"**返回值：**\",\"240\":\"\",\"241\":\"| 类型                                | 说明                             |\",\"242\":\"| ----------------------------------- | -------------------------------- |\",\"243\":\"| [AsyncLockState](#asynclockstate)[] | 包含每个锁的具体状态信息，如锁的名称、锁定状态和持有者信息的异步锁状态数组。 |\",\"244\":\"\",\"245\":\"**示例：**\",\"246\":\"\",\"247\":\"```ts\",\"248\":\"let states: ArkTSUtils.locks.AsyncLockState[] = ArkTSUtils.locks.AsyncLock.queryAll();\"}",
      "修改建议": "该句子包含过多修饰成分，可以简化。",
      "更改后示例": "包含每个锁的状态信息（如名称、锁定状态和持有者信息）的异步锁状态数组。",
      "触发条件": "当句子中存在重复修饰成分（如\"具体状态信息\"中的\"具体\"冗余）或上下文已明确的限定词（如\"锁的名称\"中\"锁的\"可省略）时触发。识别模式为连续使用多个同义/重复修饰语或上下文已隐含的限定词。"
    },
    {
      "defect_id": 557053,
      "sentence": "查找指定名称的异步锁实例，如果未找到，则创建该实例。",
      "reference_sentence": "",
      "line_num": 160,
      "context": "{\"155\":\"\",\"156\":\"#### request\",\"157\":\"\",\"158\":\"static request(name: string): AsyncLock\",\"159\":\"\",\"160\":\"查找指定名称的异步锁实例，如果未找到，则创建该实例。\",\"161\":\"\",\"162\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"163\":\"\",\"164\":\"**系统能力：** SystemCapability.Utils.Lang\",\"165\":\"\"}",
      "修改建议": "句子可以更简洁，直接陈述方法的功能。",
      "更改后示例": "查找并创建指定名称的异步锁实例。",
      "触发条件": "当句子包含分步条件操作（如“如果未找到，则创建”）且可合并为连续动作（如“查找并创建”）时触发，或当功能描述隐含条件逻辑但显式拆分导致冗余时触发。  \n识别模式：存在“如果...则...”类条件分句，且前后动作可合并为单一连贯操作（如动词+连词+动词结构）。"
    },
    {
      "defect_id": 557062,
      "sentence": "从API version 12 开始，该接口支持在原子化服务中使用。",
      "reference_sentence": "",
      "line_num": 191,
      "context": "{\"186\":\"\",\"187\":\"static query(name: string): AsyncLockState\",\"188\":\"\",\"189\":\"查询指定异步锁的信息。\",\"190\":\"\",\"191\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"192\":\"\",\"193\":\"**系统能力：** SystemCapability.Utils.Lang\",\"194\":\"\",\"195\":\"**参数：**\",\"196\":\"\"}",
      "修改建议": "该句子包含过多修饰成分，可以简化。",
      "更改后示例": "从API version 12 开始，该接口支持原子化服务。",
      "触发条件": "当句子中出现\"在...中\"等冗余介词结构修饰动词宾语，且删除后不影响语义完整性时触发。具体识别模式为动词（如\"支持\"）后接\"在+名词短语+中\"结构，且该名词短语可直接作为动词宾语（例：\"支持在原子化服务中使用\"→\"支持原子化服务\"）。"
    },
    {
      "defect_id": 557051,
      "sentence": "这是一个补充类型别名，表示[lockAsync](#lockasync)函数所有重载中的回调。",
      "reference_sentence": "",
      "line_num": 70,
      "context": "{\"65\":\"\",\"66\":\"### AsyncLockCallback\",\"67\":\"\",\"68\":\"type AsyncLockCallback\\\\<T> = () => T | Promise\\\\<T>\",\"69\":\"\",\"70\":\"这是一个补充类型别名，表示[lockAsync](#lockasync)函数所有重载中的回调。\",\"71\":\"\",\"72\":\"**原子化服务API**：从API version 12 开始，该接口支持在原子化服务中使用。\",\"73\":\"\",\"74\":\"**系统能力：** SystemCapability.Utils.Lang\",\"75\":\"\"}",
      "修改建议": "句子可以更简洁，直接陈述类型别名的功能。",
      "更改后示例": "此类型别名表示[lockAsync](#lockasync)函数所有重载中的回调。",
      "触发条件": "当句子包含冗余修饰词（如\"补充\"）且存在更简洁的主语替代结构（如用\"此\"替代\"这是一个\"）时触发；或当定义性语句包含不必要解释性前缀时触发。"
    },
    {
      "defect_id": 557102,
      "sentence": "获取缓冲区键值对的回收次数。当缓冲区数量超出容量限制时，最少使用的键值对将被回收。",
      "reference_sentence": "",
      "line_num": 1125,
      "context": "{\"1120\":\"\",\"1121\":\"### getRemoveCount<sup>18+</sup>\",\"1122\":\"\",\"1123\":\"getRemoveCount(): number\",\"1124\":\"\",\"1125\":\"获取缓冲区键值对的回收次数。当缓冲区数量超出容量限制时，最少使用的键值对将被回收。\",\"1126\":\"\",\"1127\":\"**原子化服务API：** 从API version 18开始，该接口支持在原子化服务中使用。\",\"1128\":\"\",\"1129\":\"**系统能力：** SystemCapability.Utils.Lang\",\"1130\":\"\"}",
      "修改建议": "句子包含不必要的解释。",
      "更改后示例": "获取缓冲区键值对的回收次数。",
      "触发条件": "句子在核心功能描述后附加由句号分隔的补充说明，且该说明属于非必要的实现细节或上下文已明确覆盖的内容。\n\n识别模式：\n1. 句子结构为\"核心功能。补充说明...\"，且后半部分解释触发条件/机制而非功能本身\n2. 补充内容与当前API接口层的抽象描述无关（如本例回收条件应属缓存机制说明，而非getRemoveCount接口的功能定义）"
    },
    {
      "defect_id": 557093,
      "sentence": "按指定名称查找或创建等待通知操作的对象名称，字符串无特别限制。",
      "reference_sentence": "",
      "line_num": 555,
      "context": "{\"550\":\"\",\"551\":\"**参数：**\",\"552\":\"\",\"553\":\"| 名称 | 类型   | 必填 | 说明                             |\",\"554\":\"| ---- | ------ | ---- | -------------------------------- |\",\"555\":\"| name | string | 是   | 按指定名称查找或创建等待通知操作的对象名称，字符串无特别限制。 |\",\"556\":\"\",\"557\":\"**返回值：**\",\"558\":\"\",\"559\":\"| 类型                    | 说明                             |\",\"560\":\"| ----------------------- | -------------------------------- |\"}",
      "修改建议": "句子过长，包含不必要的修饰成分。",
      "更改后示例": "按指定名称查找或创建等待通知操作的对象，字符串无特别限制。",
      "触发条件": "当名词短语中包含与前置修饰语重复的属性词（如\"对象名称\"中的\"名称\"在前置介词短语\"按指定名称\"中已明确），或存在\"动词+属性\"与\"名词+重复属性\"的复合结构时。  \n\n识别模式：检测\"动词+属性词+名词+重复属性词\"结构（如\"按指定名称查找...对象名称\"），或名词短语中包含已被前置修饰语明确说明的冗余属性限定词。"
    },
    {
      "defect_id": 557105,
      "sentence": "返回true表示当前缓冲区为空，不包含任何键值对；返回false表示当前缓冲区不为空。",
      "reference_sentence": "",
      "line_num": 1216,
      "context": "{\"1211\":\"\",\"1212\":\"**返回值：**\",\"1213\":\"\",\"1214\":\"| 类型    | 说明                                     |\",\"1215\":\"| ------- | ---------------------------------------- |\",\"1216\":\"| boolean | 返回true表示当前缓冲区为空，不包含任何键值对；返回false表示当前缓冲区不为空。 |\",\"1217\":\"\",\"1218\":\"**示例：**\",\"1219\":\"\",\"1220\":\"```ts\",\"1221\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "句子包含重复信息，可以用更简洁的方式表达。",
      "更改后示例": "返回true表示当前缓冲区为空；返回false表示不为空。",
      "触发条件": "当同一逻辑判断的正反情况（如true/false）中，后置分句重复使用前置分句已明确定义的完整主体（如\"当前缓冲区\"），且存在可推导的冗余补充说明（如\"不包含任何键值对\"是对\"为空\"的同义解释）时触发。"
    },
    {
      "defect_id": 557130,
      "sentence": "返回当前缓冲区中所有键的列表，按从最近访问到最少访问的顺序排列。",
      "reference_sentence": "",
      "line_num": 1334,
      "context": "{\"1329\":\"\",\"1330\":\"**返回值：**\",\"1331\":\"\",\"1332\":\"| 类型      | 说明                                                         |\",\"1333\":\"| --------- | ------------------------------------------------------------ |\",\"1334\":\"| K&nbsp;[] | 返回当前缓冲区中所有键的列表，按从最近访问到最少访问的顺序排列。 |\",\"1335\":\"\",\"1336\":\"**示例：**\",\"1337\":\"\",\"1338\":\"```ts\",\"1339\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "返回当前缓冲区中所有键的列表，按访问顺序排列。",
      "触发条件": "当句子包含多个逗号分隔的修饰成分，且存在可被领域常识或上下文隐含的冗余描述时触发（如\"从最近访问到最少访问\"可简化为\"访问顺序\"），或使用重复性限定词（如\"当前缓冲区中所有键的列表\"已隐含完整集合，无需额外强调范围）。"
    },
    {
      "defect_id": 557278,
      "sentence": "通过设置maskColor参数，可对弹出框进行蒙层颜色定制。",
      "reference_sentence": "",
      "line_num": 32,
      "context": "{\"27\":\">\",\"28\":\"> 通过设置isModal参数，可以对弹出框进行模态和非模态的定制。非模态的弹出框，无蒙层效果，可以与弹窗周围其他控件进行交互。模态的弹出框有蒙层，不可与弹窗周围其他控件进行交互。\",\"29\":\">\",\"30\":\"> 在levelMode属性设置为LevelMode.EMBEDDED下，通过设置immersiveMode参数，可以对弹出框的蒙层是否往状态栏及导航栏延伸的效果进行定制。\",\"31\":\">\",\"32\":\"> 通过设置maskColor参数，可对弹出框进行蒙层颜色定制。\",\"33\":\">\",\"34\":\"> 通过设置openAnimation参数，可以对弹出框进入动画进行定制，蒙层的动画会受该参数影响。\",\"35\":\">\",\"36\":\"> 通过设置closeAnimation参数，可以对弹出框退出动画进行定制，蒙层的动画会受该参数影响。\",\"37\":\">\"}",
      "修改建议": "句子结构复杂，包含不必要的修饰成分。",
      "更改后示例": "设置maskColor参数可定制弹出框的蒙层颜色。",
      "触发条件": "当句子包含\"通过设置X参数\"的状语结构且后续使用\"对Y进行Z\"的冗余动词短语时，或出现\"进行...定制\"等可合并的动宾结构时触发。  \n\n识别模式：检测\"通过设置X参数\"+\"对Y进行Z\"的复合句式，或\"进行+动词性名词\"结构（如\"进行定制\"），判断是否可将双动词结构简化为单一主动词（如\"设置X可定制Y的Z\"）。"
    },
    {
      "defect_id": 557133,
      "sentence": "如果缓冲区包含指定的键，则返回true，否则返回false。",
      "reference_sentence": "",
      "line_num": 1399,
      "context": "{\"1394\":\"\",\"1395\":\"**返回值：**\",\"1396\":\"\",\"1397\":\"| 类型    | 说明                                       |\",\"1398\":\"| ------- | ------------------------------------------ |\",\"1399\":\"| boolean | 如果缓冲区包含指定的键，则返回true，否则返回false。 |\",\"1400\":\"\",\"1401\":\"**示例：**\",\"1402\":\"\",\"1403\":\"```ts\",\"1404\":\"let pro = new ArkTSUtils.SendableLruCache<number, number>();\"}",
      "修改建议": "句子过长，包含多个逗号，且有不必要的修饰成分。",
      "更改后示例": "缓冲区包含指定的键时返回true，否则返回false。",
      "触发条件": "当句子使用\"如果...则...否则...\"的条件状语从句结构，且包含重复连接词或多余逗号时触发；或存在可通过简化为\"时...否则...\"结构来消除冗余的条件表达时触发。"
    }
  ]
}